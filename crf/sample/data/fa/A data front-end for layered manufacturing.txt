
 A Data Front-End for Layered Manufacturing* Gill Barequett Yuval Kaplan$ Abstract In this paper we describe 
a geometric software package which serves as a data front-end for rapid prototyping systems. This package 
can be customized for every layered-manufact­uring technique. We survey the full path of data in the 
system, starting = data files originated by external tools, in most cases CAD systems, going through 
some repairing operations, then editing a job composed of several objects, and finally processing the 
job for actual production. Keywords: geometric software, rapid prototyping, lay­ered manufacturing, polyhedra. 
Introduction Layered manufacturing has become during the last decade the major method for Rapid Prototyping 
(RP) of models. Physical models are needed in almost every industry for de­sign verification, simulation, 
integration of complex systems, etc. RP has also applications in medicine (e.g., in surgery planning), 
in chemistry (e.g., for verifying docking sites of macromolecules), in architecture, civil engineering, 
and so on. RP haa emerged as a supporting tool for shortening the time-to-market of a product. In most 
stages of the design a prototype of a model does not necessarily have to be ss accurate as the final 
product or to have the same mechan­ical properties, color, functionality, etc. Rapid prototypes .Work 
of the first author on this paper has been supported in part by the Israeli Ministry of Science and the 
Arts under an Eshkol Grant 0562-2-95 and by the U.S. Army Research Office under Grant DAAH04-96-1-0013. 
t Center for Geometric Computing, Dept. of Computer Sci­ence, Johns Hopkins University, Baltimore, MD 
21218. E-mail: barequetacs. jhu. edu tWspomible for software development, Cubital Ltd., 13 HaSadna St., 
Industrial Zone North, Ra anana 43650, Israel. E mail: cubital@netvision net. il Pcmlissirm 10nvk digihhlmrd 
mpw. ofall or pml 01 [111snmlcri;d I or personfil or ckswoom use is granlcd wilhou( Fedprovided Ilml 
the ct~pies are not made or distributed for pmli! or commcrcifil Anntogc. the copv­right Wice, the title 
oflhe pulllicali,Jjl md ils d~lc :Ippmr. :Ind nolicc is given thot copyright is hy pwmissioll of the 
AC hi, Inc. TO COPYolhem ise. to republish, to post on servers or to rwlistribllte w lists. requires 
specitic pemlission and/or fce Compr{fotlonnl Geonrerry97 Nice France Copyright 1997 AChi O-8979 I -f(7~-9 
97J()(I ..$1,50 are expected above all to be produced fastand with low cost. While consuming relatively 
short time, layered manu­facturing overcomes many limitations of traditional milling techniques, especially 
the limitation on the geometries of the produced models. RP is also lately used for final-product fabrication, 
e.g., in some casting processes. RP techniques need to interface with the CAD world. The first player 
in the RP market, 3D Systems, Inc., set in 1988 the de-facto fil~format standard in the RP indus­try 
[3DS]. This standard is a syntax for describing the boundary of a model in a polyhedml (in fact, triangular) 
format, that is, as a piecewise-linear surface which contains only triangular faces. Objects however 
are rarely designed as polyhedra but as smooth objects described by more involved mathematical entities. 
The polyhedral boundary represen­tation is actually an approximation of the original object. Later file 
formats extended this standard by allowing non­triangulm faces, possibly perforated, but the whole rapid 
prototyping industry is still bssed on polyhedral object de­scriptions, where every model is described 
by a collection of facets (planar polygonal frees) which approximates the object bounday surface. The 
emerging RP industry created the need for support­ing software whose main features are: 1. Computing 
polyhedral approximations of smooth CAD files. 2. Cleaning and repairing ill-defined CAD files (or rather, 
their approximations), whose defects may not disturb the graphics display or external applications (e.g., 
fi­nite element analysis), but spoil the production of the models. 3. Designing a production job (a 
batch of several mod­els to be produced simultaneously). 4. Simulating the production, estimating its 
cost and du­ration, and predicting errors in it. 5. Converting-..~olvhedral formats to data recognized 
bv an actual RP technique.  Here is a brief (and incomplete) review of the currently available RP technologies 
(a more detailed review is given in the full version of the paper). In 1988, 3D Systems, Inc., introduced 
the stereolithography technology. Stereolithog­raphy builds parts from a 3D CAD file in slices, layer­by-layer 
from the bottom up, by curing layers of a liquid photopolymer resin with a laser in a slow serial process, 
one dot at a time. Other stereolithography-like machines are produced by EOS GmbH, Germany, and by CMET, 
Inc., D-MEC, Ltd., and Denken Engineering, all from Japan. In 1991 Cubital Ltd. from krael introduced 
its additive bi­materiai process, SGC (Solid Ground Curing), which uses a phot~curable acrylate or epoxy 
polymer resin and solid wax support material. Each layer image is first produced on a glass plate to 
form a photomaak. An ultraviolet (UV) light, projected through the photomaak of the cross-sectional layer 
onto the liquid ultraviolet-sensitive photo-polymer resin, so­lidifies the entire layer within seconds. 
Unsolidified excess resinisvacuumed awayandmoltenliquidwaxfillsinailcav­ities, surrounding the cured 
resin. The wax is then cooled to become a solid support media. DTM Corporation s Selec­tive Laser Sintering 
(SLS) process uses data from a CAD file to direct deposition of thin layers of heat-fusible powder in 
a pattern that is heated (sintered) with a C02 laser. RP man­ufacturer Helisys, Inc., offers Laminated 
Object Manufac­turing (LOM), a process wherein a laser beam cuts through a series of sheets of heat-sensitive 
paper, layered upon one another to build a part with the resulting consistency simi­lar to that of wood. 
A similar technology is available from Kira Corp., Japan. In Fhsed Deposition Modeling of Strata­sys, 
CAD file data directs part-building in slices by extrud­ing a thermoplastic material from a temperature-controlled 
head in layers that fuse to one another to build a solid part. Sanders Prototype, BPM Technology, Inc., 
and Soli­gen Corp. each use a form of ink-jet type spray to build parts. Sanders calls its process 3-D 
plotting, while BPM terms its methodology Ballistic-particle manufacturing. Soligen s Direct-shell production 
casting (DSPC) builds a ceramic mold which can be used to create parts from molten metal. 3D Systems 
has also introduced its own ink-jet type modeling process called Multi-jet modeling. Other pro­cesses 
deposit a stream of metallic powder into the path of a laser beam aimed at a target position on the built 
model. Such processes include CMB (Controlled Metal Build-up) of Fraunhofer IPT (Aachen, Germany) and 
LENS (Laser Engi­neered Net Shaping) currently under development at Sandia National Labs (Albuquerque, 
New Mexico). Three important facts characterize the flow of data from CAD systems to RP technologies: 
1. CAD systems transfer to RP polyhedral approxima­tions of the original objects, which contain in many 
cases errors or ambiguities [BW, BS1]. 2. CAD systems are able to output such files but are un­able 
in most cases to read them back for examining modifications and corrections [We]. 3. It is much more 
economical to produce several models during one run of an RP m~ine. For this purpose several objects 
are positioned in a job so as to use the full capacity of the machine.  These three facts, together 
with the growth of the popular­ity of RP (as a result of the increase in its availability and decrease 
in production time and cost), led to evolving imple­mentation of software packages which allow the user 
to view RP files, edit them, repair them, customize them for layered manufacturing, edit production jobs, 
simulate the manufac­turing (for estimating the production time, accuracy, etc. ), and finally for actually 
feeding the RP machines with data. Supporting software is supplied by most of the RP ven­dors listed 
above and also by independent firms. A recent review of Wohlers Po] lists most of these packages and 
their major features. In our opinion the most efficient packages (out of those listed in this reference) 
are Rapid Tools of DeskArtes Oy (mainly due to its ability to fix defects in files) and SolidView of 
Solid Concepts, Inc. (mainly because of its friendliness). The reader is referred to the reference cited 
above for details and commercial information. Re­cently, Morvan and Fadel [MF] and Krause, Stiel, and 
Lud­dermann [KSL] claimed systems for processing and repairing of CAD data. The DFE (Data Front-End) 
system described in this pa­per is a geometric software package which supports all stages of preparing 
CAD data files for production. It is customiz­able for every layered-manufacturing technique. We present 
the various components of the system along with detailed descriptions of the implemented algorithms. 
The system currently runs on DEC stations (CPU 5000/200-260) and SGI Indy and Indigo2 (CPU R5000) under 
the Ultrix 4.3 and Irix 5.3 or 6.2 operating systems, respectively. The un­derlying graphics package 
and required card are Phigs 2.3a and a Z-buffer (on DEC), and OpenGL md 24-bit XL (on SGI). The paper 
ia organized as follows. In Section 2 we de­scribe how data files are imported into the system. In Sec­tion 
3 we review the main geometric tools of the Academy, the package for editing and repairing data files. 
In Section 4 we present the job edkor, and in Section 5 we describe the production tool. We end in Section 
6 with some concluding remaxks. 2 Importing Data Files The data front-end is capable of reading files 
that contain polyhedral descriptions in many commonly-used tile formats. Most of the formats describe 
the bounday representation (B-Rep) of a polyhedron, which is typically an approxima­tion of a smooth 
object designed by using a CAD system. These formats usually belong to one of the following two ck@aes: 
I. Only one list of polygons, each consists of a sequence of vertices, where each vertex is specified 
by its 3­dimensional coordinates. II. Two lists: The fist list consists of indexed points, each specified 
by its 3-dimensional coordinates, and the second list consists of polygons, each specified by a sequence 
of indices referring to the point list. The advantages of the second class are obvious: vertex coor­dinates 
need not be repeated and adjacency between poly­gons (that shwe an edge of the polyhedron) is implicitly 
specified by the existence of two successive vertex indices (i, j) in one polygon and a matching successive 
pair (j, i) in the other polygon. Note that the neighborhood information is not provided explicitly in 
either class. The following is a partial list of file formats recognized by the data front-end. STL 
This is the de-facto standard of the rapid-prototyping industry. It is output by practically all CAD 
systems and is recognized by every rapid-prototyping system. This file format belongs to class I and 
allowstriangles only. The file format contains for each triangle the unit vector normal to it. The full 
specifications of this format are given in [3DS]. BSTL ThB is the binary form of STL. CFL This fde format 
belongs to class II and is used solely by Cubital s DFE and the SGC rapid-prototyping tech­nique. The 
file synt~ allows additional pieces of in­formation, e.g., details of the designer, geometric at­tributes, 
and manufacturing instructions. SOLI This is the binary form of CFL. RF Thii is another class II Aacii 
format used by the Rob-Cad (Robotic CAD) system of Tecnomatics Ltd. [Te]. UNV This is yet another class 
II Ascii format used by the I-Deas CAD system of SDRC Ltd. The front-end can also write data into CFL, 
STL, and BSTL files. When STL or BSTL INesare output the bound­ary polygons need to be triangulated. 
Since the vertices of every polygon are embedded in a 3-dimensional space, they are not necessarily all 
coplanar. (In most practical cases the vertices of a facet are almost coplanar, but the algorithm does 
not make any use of this assumption.) The system tri­angulates the spatial polygons so as to minimize 
the total area of the triangles. For this purpose it uses a dynamic­programming technique which closely 
followsKlincsek s al­gorithm [Kl] for triangulating a 2D polygon. The running­time of this algorithm 
is cubic in the complexity of the in­put polygon. The full details of this algorithm are found in [BS1, 
BS2]. Repairing Data Files Afier importing a data file, the DFE allows the user to anal­ize it, to modify 
it, and to fix defects in it. This is done via a software package called the Amdemy. The system automatically 
performs an analysis of the connected components of the object boundary (by perform­ing a depth-fkst 
search on the dual graph of the boundary) and provides the user with detailed statistics. Valid ob­jects 
may consist of more than one connected component, where each one is either a solid or an anti-solid a 
void in a solid. Figure 1 shows an object with two solid compo­nents a ball trapped in a cage. The graphics 
display of the Academy showaeach connected component in a diferent color. Some CAD systems compute inaccurately 
the polyhe­dral approximation of a smooth object aa is explained later in this section. Thus the boundary 
of the polyhedron may contain flaws ( holes ) or may even be broken into several connected components 
which may not necessarily enclose volumes. Connected components which are not true solids are bounded 
by one or more closed polygonal chains in space Figure 1: A ball in a cage which the system denotes 
as flaws. The statistics which the Academy provides for each connected component includes the number 
of vertices and facets, number of flaws, an indl­cation whether it encloses a volume or not (that is, 
whether it is closed or open), and an indication whether the compo­nent is orientable or not. (The facets 
of a non-orient able manifold cannot be oriented consistently, such that each edge appears exactly twice 
and in opposite directions in the two neighboring facets that share the edge.) The system provides some 
tools for haudling the con­nected components. The user may select some connected components of the object, 
then delete them, or extract them into a new file, or split the object into two files: one that cent 
ains the selected components aud one that cent ains the remaining components. The user may also separate 
the ob­ject into multiple objects, each containing one connected component of the original object. In 
many cases the orien­tations of the polygons that describe the boundary of the ob­ject are unreliable. 
As a rule, each facet should be oriented counter-clockwise when viewed from outside the object. The user 
may reorient the facets of each connected component. When a component is orientable, the system indicates 
for each facet its correct orient ation and whether it is currently oriented correct ly or not. For each 
connected component the user may choose to invert all the polygons, to orient them correct ly, or to 
orient them in their incorrect orient ations. The last option ia used for creating anti-objects, voids 
in correctly-oriented surrounding objects. In practice, both the resolution and the addressability of 
the manufacturing process are far coarser than the accuracy of the CAD system or that of the process 
that produced the polyhedral approximation of the original object. In many cases the object is an overdetailed 
approximation of the orig­inal object in which too small tolerance was allowed. The result is a tessellation 
of the model, which, although very similar to the original model, contains too many (close) ver­tices 
and very small facets. The Academy provides two ma­jor tools for reducing the complexity of the description 
of the object: ** (c) .5= lOin (d) s = 25in (a) Original object (b) E = sin Figure 2: Unifying e-close 
vertices 1. Diet~ in which sufficiently close vertices are unified into one vertex. The user supplies 
the threshold &#38;for the mutual dwtance between vertices below which they are merged into one vertex. 
This process may degen­ erate polygons into points or segments, which are au­tomatically removed. Figure 
2(a) shows a model of an airplane (with 2,375 vertices and 4,629 facets) of size 580in x 520in x 220in. 
Figures 2(b,c,d) show its diet­ed versions by e = 5in (with 2,025 vertices and 3,886 facets), by e = 
lOin (with 1,584 vertices and 3,017 facets), and by E = 25in (with 614 vertices ~d 1,243 facets), respectively. 
(Typically the user applies this operation with a value of e which is less than half of the minimum feature 
size of the layered-manufacturing technology.) When the user does not supply a thresh­old, the default 
value &#38; = O is taken. In this case the tool simply unifies vertices which appear more than once in 
the polyhedral description of the object. In fact, data files with synt~ of class I (see Section 2) automatically 
undergo this operation when they we imported into the system. 2. him, in which almost coplanar neighboring 
facets are united to form facets with larger complexities. The user supplies the threshold a for the 
deviation between the directions of the normal vectors to the facets, below which the facets are united. 
In other words, neighbor­ing facets are united when the dihedral angle between them is less than a away 
from x (exact copkm=ity). Figure 3(a) shows a rotor of a real car engin, which consists of 2,636 facets 
(and of 1,312 vertices). Fig­ure 3(b) shows its trimmed version (with a = 0.5° ) whkh contains only 872 
facets (the number of vertices is unchanged). Similarly, Figures 4(a,b) show a leg­bone implant (with 
7,700 facets and 3,852 vertices) and its trimmed version by a = 2° (with only 2,621 facets), respectively. 
When the user does not supply a threshold, the default value a = O is taken. In this case the tool simply 
unites only coplanar neighboring facets. Figures 5(a,b) show a mechanical part (with 1,164 facets and 
572 vertices) and its simplified version (with only 337 facets), respectively. When the sys­tem imports 
data files which allow triangles only (e.g., STL-see Section 2) the user is prompted whether he or she 
wishes this operation be performed as part of the conversion. Yet the most useful ability of the Academy 
is to fix flaws in the boundary of an object. These flaws usually appear in polyhedral approximations 
of CAD objects whose bound­aries are described by curved entities [BS1, BW, DM, MD, (a) Original object 
(b) Trimmed object Figure 3: Ikimming a car rotor with Q = 0.5°  (a) Orlgmtd object  (b) llimmed object 
Figure 4: Trimming a leg-bone implant with a = 2°   (a) Original object (b) Simpliied object Figure 
5: Uniting coplanar neighboring facets of an object ST]. In CSG (Constructive Solid Geometry) the object 
is described as the unions and intersections of cubes, spheres, cones, etc., whereas in using its B-Rep 
(Boundary Represen­tation) it may be described by NURBS (Non-Uniform Ra­tional Bisplines), B6zier surfaces, 
etc. Most flawsare caused by incorrect handling of trimming curves defined by intersec­tions of surfaces. 
Other flaws are caused by missing surfaces or patches within a surface, or by incorrect handling of adja­cencies 
between them. Flaws do not usually disturb graph­ics displays where the gaps between the surfaces me 
often too small to be seen or are handled straightforwardly [SW]. However, it causes severe problems 
in applications which rely on the continuity of the boundary, such aa rasterization algorithms [FD] which 
play a crucial role in layered manu­facturing (see Section 5). Flaws seem to appear in most large CAD 
files, so their detection and elimination is indeed a rather important prac­tical problem. Sheng and 
Tucholke [ST] refer to these errors x one of the most severe software problems in rapid proto­typing. 
Dolenc and Mikela [DM] and Sheng and Hirsch [SH] try to avoid it already in the surface fitting triangulation 
process. Others attempt to solve this problem given only the polyhedral approximation of the object. 
Some works use only local information and do not check for any global consistency violations. Ehahnand 
Wozny [BWl treat local flaws by iteratively triangulating them: at each step they eliminate the vertex 
which spans the smallest angle with its two neighboring vertices. Miikela and Dolenc [MD] apply a minimum 
distance heuristic in order to locally fill flaws in the boundary of the object. Barequet and Sharir 
[BS1] at­tempt to solve this problem while considering the global con­sistency of the resulting polyhedron. 
Their algorithm uses a geometric hashing technique for matching portions of the flaws (which are then 
stitched ) and an optimal triangula­tion of 3D polygons for resolving the unmatched portions; it also 
ensures that the resulting polyhedron is orientable. We now proceed to describe the Academy feature of 
de­tecting and ilxing flaws. The Academy first displays the list of flaws of each connected component 
of the object bound­ary. Each flaw is classified according to whether it is a real border of a surface 
patch, a thin crack in it, a missing trian­gle, or a degenerate gap in the boundary. (A degenerate gap 
occurs when edges do not match properly in pairs but yet the boundary is continuous.) For each flaw the 
system pro­vides its complexity (number of vertices), its 3-dimensional bounding-box, the total length 
of its edges, and in case of a thm crack, the two spatial angles spanned by the pairs of edges that form 
its two endpoints and the ratio between the lengths of the two polygonal chains between the two end­points. 
Degenerate gaps may be ignored, or added (in the opposite orientation) to the model, so as to topologically 
fill in the gaps. Missing triangles are also simple to resolve by simply adding them (or rather, the 
inverted veraions of the holes in the boundary) to the object. Cracks and borders may however be much 
more involved and user intervention is needed in most c-s. Cracks are usually fairly easy to fix: the 
two sides of a crack need to be stitched to each other by a sequence of triangles that follows the crack 
in space. This procedure re­sembles the mergin# of two sorted lists of numbers. The Academy provides 
such a patching tool which differs from that cited above only in the restriction that the two stitched 
polygonal chains must share their endpoints. The user may set the maximum allowed length of a chord (edge 
of a tri­angle) added in this process. Portions of the crack in which its width exceeds this value are 
not stitched and are left for further repairing operations. It is also possible that portions of diflerent 
borders should be stitched together. This is often the case when the bound­ary of an object is broken 
into pieces due to inconsistent approximations of the surfaces that describe the original ob­ject. Barequet 
and Sharir [BS1] dkcuss a heuristic method, based on a computer-vision technique, for identifying such 
matching portions of borders of connected components of the object. When automating this process one 
must take care not to create a non-orientable surface by inconsistently stitching between components 
of the object. They show that when matches are given scores (say, according to the lengths oft he matches 
and their widths t he dkdxmces between the matching portions) the problem of selecting a subset of con­sistent 
matches (which does not result in a non-orientable manifold) with a maximum total score is AfP-Hard. 
The cited reference hence uses an approximation scheme which reduces the time complexity of choosing 
the optimal consis­tent subset of matches from practically exponential in c, the number of components, 
and in m, the number of matches between them, to only O(m log m + mcr(m, c)).1 The Academy provides a 
manual version of the algo­rithm described in [BS1]. The user selects a subset of bor­ders on which the 
bindhg (matching and stitching) oper­ation is to be performed and a maximum allowed distance between 
matched portions of borders. Then the system it­eratively attempts to match all pairs of selected borders 
and to stitch sufficiently close matching portions of them. Typi­cally, the user invokes this tool several 
times with a slightly increasing sequence of limits on the inter-border dkkance. In difficult instances 
of the problem the user may select only two borders at a time. Identifying matching portions of bor­ders 
is performed by searching for a sufficiently close pair of vertices (one on each border) and expanding 
the match along the borders. No global surface-orientability is checked. If we denote by b the number 
of selected borders and by t; the complexity (number of vertices) of the ith border (for 1 ~ i < b), 
the running time of the implemented version is o(~~~~z~<b.t;tj ). This term is quadratic in the worst 
case in the complexity of the whole object, but in practice the user selects a small number of close 
borders in each itera­tion. Figures 6(a,b) show a CAD object and the borders of its connected components, 
respectively. Figures 6(c,d) show closeups of some flaws in the boundary of the object before and after 
fixing these flaws, respectively. Two additional operations on objects are provided by the Academy: 1. 
Widening a surface into a solid object. Occasionally an object is designed aa a zero-width open surface. 
The user specifies the desired thickness and the side of the original surface in which the offset surface 
is to be generated. Then the system generatm an otfset surface and the two surfaces are bound so as to 
create a solid. In case the ofiet size is comparable to that of 1a(rn, c) is an extremely slowly growing 
functional inverse of Ackermann s function. For all practical values of m and c, the function a(m, c) 
does not exceed a very small constant [Ta]. (c) A closeup of some flaws in (d) A closeup of some flaws 
in the object (before fixing) the object (after fixing) Figure 6: Repairing flaws in the boundary of 
a CAD object the features of the original surface (especially when it has sharp dihedral angles between 
neighboring facets) the offset surface may intersect itself or the original surface. A future release 
of the system will identify such self-intersections and will notify the user, which will then be able 
either to ignore the intersections or to perform local corrections of the object. 2. Cuttirm an obiect 
bv a rhne into two obiects. This tool co-reputes-all th~ in~ersections betwee~ the plane and facets of 
the object: each hit facet is split into a number of pieces (this number is proportional to the number 
of edges of the facet intersected by the plane). Then the original object is split into two parts. Each 
 Figure 7: A production job facet not hit by the cutting plane is put in its respective part, while the 
pieces of the hit facets are located in the appropriate part according to the side of the cutting by 
some angle 19about some axis 4) an object par­plane in which they lie. Finally, the two parts of the 
ticipating in a job, as well as scaling it (uniformly inoriginal object are closed by additional facets 
which lie all directions, or with different scaling factors in each within the cutting plane. The human 
interface of the direction), or mirroring it (reflecting it through somesystem allows the user to specify 
a series of k parallel plane in 3-space). In fact, the user may apply anyplanes used to cut the object 
into k + 1 new objects. affine transformation to an object. . Cresting multiple copies of the same object, 
either 4 Designing a Job along a line, or on a 2-or 3-dimensional grid, or along a 2-dimensional arc 
parallel to the zy-plane. In most cases the capacity of the layered-manufacturing ma­chine is by far 
larger than the size of any single built model. Figure 7 shows an example of a production job. For example, 
the capacity of Cubital s Solider 5600 machine The entire job description is kept in a simple Ascii file. 
is 20in x 14in x 20in. Therefore, it is much more economical The sophisticate user may edit this file 
by using a text editor. to produce a huge job which contains many small mod-Except that, of course, by 
doing that the user is unable toels than to build each model separately. The DFE system visualize the 
job. The purpose of visualizing a job is 3-fold: provides a package for editing such a production job 
whose main features are: 1. Positioning models in the desired orientations. Most layered-manufacturing 
techniques perform differently . Positioning objects at different locations. Each object along the different 
aces (especially the z axis), e.g., may have multiple instances in a job. with respect to the amount 
of model shrinkage during . Rotating (by specifying Euler angles [Go, p. 608] and after production. a 
triple of rotations around the x, y, and z axes, or (a) Original object (b) Displayed object Figure 8: 
A ghost of an object 2. Positioning models economically. That is, avoiding as much as possible voids 
in the job volume not occupied by models. Usually the cost of the production of a job is proportional 
to the volume of its axiwaligned bounding-box. 3. Positioning models so that they do not intersect each 
other. Such intersections spoil in most cases only the involved models but are nevertheless undesirable. 
  The collection of objects that participate in a job may sum up to a huge amount of data which require 
a large amount of memory resources and may slow down the display substantially. The user is therefore 
advised not to display every single object in its full details but to dkplay a ghost , a rough approximation 
oft he object which is yet descriptive enough for visualization and for designing the job. The sys­tem 
provides five approximation levels; in the higher levels the object is fist subdivided into parts and 
then a ghost is computed for each psxt separately. Figure 8(a) shows a model of human kidneys which contains 
192,062 vertices and 96,031 facets. Its ghost version, shown in Figure 8(b), contains only 964 vertices 
and 924 facets. Finally, the ultimate goal of the job editor is to consoli­date all the objects participating 
in the job into one object which will then be submitted for production. The consoli­dated job is saved 
in a file with the same structure as any other object. Thus, this operation may also be performed for 
saving a layout of multiple objects into one object to be further referred to as a whole for relocation, 
rotation, duplicating, etc. 5 Job Previewing and Manufacturing The rear-end of the data front-end may 
be connected to a layered-manufacturing machine. The system allows the user to fist preview the course 
of the manufacturing pro­cess without actually producing anything, and then, when the user is satisfied 
(and/or when the machine is ready), to perform the manufacturing job. Otherwise the user is able to return 
to the Academy (for repairing some object(s)) or to the job editor (for modifying the job), and then 
to invoke the production tool again. As described above, all layered-manufacturing technolo­gies produce 
the job layer by layer, and the different tech­nologies vary in how they produce the layers. As explained 
earlier in this paper (see Section 4), the user designs a pro­duction job which contains multiple objects 
and then con­solidates it into a single object-input to the production tool. This tool computes a series 
of intersections between zy-parallel planes (hereafter denoted dices), usually equally spaced along the 
z axis, and the job object. Since the job is actually a polyhedron (even though it consists of many con­nected 
components), computing its intersection with a plane is straightforward: Each facet that intersects the 
plane con­tributes one or more directed segments, e.g., so that its right side is on the materiaf side. 
The collection of all these seg­ments at some z (the height of the slice above the bottom of the job) 
forms a set of closed polygonal chains-simple polygons within the slic~which describe areas of mate­rial 
(inside some object) or non-material (outside any ob­ject). The computation of the series of such polygonal 
slices is performed efficiently: Since every facet is connected, it may intersect zy-parallel planes 
only within some range of heights (z values) which may be precomputed only once by scanning all the vertices 
of the facet and by finding the mini­mum and maximum z coordinates of the facet. Maintaining the active 
facets along the sequence of slices may be im­plemented, e.g., by two priority queues, whose keys are 
the minimum and maximum z coordinates of the facets, respec­tively. The process described above is common 
to all layered­manufacturing techniques. Now the system invokes the cus­tomizable part: converting the 
slice data into a format rec­ognized by the actual production machine. Some machines behave like pen-plotters 
: they need only the set of closed polygons per slice, so the production tool has to pack these data 
in the appropriate format and send them to the target machine. Other machines (e.g., the SLA series of 
3D Sys­tems) make some hatching process, where a laser beam first solidifies liquid along the polygons 
themselves, then makes a hatch at the interiors of these polygons. The DFE customization described here 
is for the Solider 5600 MPM (Model-Production Machine) of Cubital Ltd., which requires each slice data 
to be given as a raster im­age (pixel bitmap). The production tool is customized to produce slices at 
some z intervals, and then to rwterize each slice according to the required zy-resolution. Before sending 
the slices raster data to the machine, the user may wish to preview it in order to detect errors, as 
explained below. Figure 9 shows a typical slice of a job, in which the cross-sections of several objects 
are seen, all surrounded by machine-required protection aids. This specific machine re­quires the creation 
of a fence around the entire job, where Now consider the following two possible defects of an object: 
. lnnnr o 0 0 &#38;% Figure 9: A raster image of a job slice the walls of the fence are broken at 
predefine locations for releasing pressures that arise in the process of solidifying liquid. The rasterization 
process is based on a well-known scan­line algorithm [FD]. The polygons are scanned along the y axis 
(from top to bottom), and for each particular value of y, each active segment (a segment within the slice 
that intersects with the scan-line at that value of ~) contributes a point where the scan-line either 
enters or exits the materi­al area. The type of the point (enty or ezit) is determined according to whether 
the scan-line crosses the edge from its ieft side to its right side (recall that the segments are directed) 
or vice versa. Note that for this purpose the segments within a slice need not be collected into closed 
polygons: they can appear in random order but still the al­gorithm performs correctly. After all the 
crossing points are computed for some scan-line, they are ordered according to their x coordinates. An 
entry point means that the scan-line enters a material region, and conversely, an exit point means that 
the scan-line leaves the material region. When the orig­inal objects do not overlap (as in most cases) 
all the crossing points along a scan-line appear in alternate order, starting with an entry point and 
ending with an exit point. How­ever the job editor allows objects to intersect. Overlapping objects are 
reflected by some permutation of the crossing points: the scan-line may enter two objects in a row (the 
second entry-point is the entry to the overlapping area) and then exit from both (the first exit-point 
occurs when the scan-line leaves the overlapping area). More generally, any valid parentheseswiequence 
of entry cmd exit points is legal; the permutation of the points reflects the overlaps between the various 
objects. The scan-line needs only to count the level of material it is in. Initially (at cm along the 
z axis) it starts with level O (outside any object), then every entry point increments the level by 1 
and every exit point decre­ments the level by 1. Finally (at +CCIalong the x axis) the scan-line should 
return to level O. The simple observation is that the material lies wherever the level is greater than 
O (level k means that k objects overlap at this portion of the scan-line). 1. A missing facet (a real 
hole in the boundary of the object). 2. An inverted facet (a facet with an incorrect indication of the 
inside of the object).  These defects should have already been detected and fixed in the Academy. Nevertheless 
assume that such defects did reach the product ion phase, The effects of these defects are the following: 
1. A missing facet causes a missing segment(s) in all the slices in which it would be active if it were 
not missing. A missing segment in a slice causes missing crossing points along all the scan-lines in 
which it should be active. Such a missing crossing point prevents the in­crease or decrease of the material 
level. Thus, a scan­line fails to detect an entry to or an exit from an object. After processing all 
the crossing points the fi­nal level is not O, as expected, but +1 or 1 (in case of a single defect). 
Multiple defects may, of course, cancel out at the end of the scan-line. 2. An inverted facet causes 
inverted segments in all the slices in which it is active. An inver~ed segment in a slice causes crossing 
points of the wrong type (exit in­stead of entry and vice versa) in all the scan-lines in which it is 
active. Such an erroneous crossing point causes decreasing the material level instead of increas­ing 
it or vice versa. After processing all the crossing points the final level is not O, as expected, but 
+2 or 2 (in case of a single defect). Multiple defects may also cancel out at the end of the scan-line. 
 These defects cause the so-called stray-lines: scan-lines which do not have, starting at some defected 
point, the cor­rect level of material. From this point the result of the raaterization is incorrect. 
The rest of the scan-line erro­neously becomes either material (a black hair that con­nects bet ween 
seemingly separate objects) or non-material (a white hair that erases subsequent objects). The pro­duction 
previewing tool offers automatic detection of stray­lines which verifies that all the scan-lines terminate 
with level O. It is obvious from the discussion above that this sim­ple mechanism misses the rare (and 
unrealistic) situations where such defects cancel out in all the scan-lines within all the slices tiected 
by the defects. This may happen, for ex­ample, when two facets, where one is an exact z-translation of 
the other, are inverted. In this pathological case only the spatial region bounded by the convex hull 
of these two facets will have a level either greater or less than by 2 from the correct level. For completeness 
we mention that stray-lines may also be the result of (in)robustness issues. Round-off errors may cause 
the algorithm to miss segments (intersections of facets with the cutting planes) or crossing points. 
Furthermore, when a scan-line intersects with an original vertex of a poly­gon in the slice or when it 
contains a segment, wrong han­dling of these degeneracies may lead to an incorrect level update. Such 
events are inevitably present in our system too. Nevertheless most of these situations are avoided by 
perturbing the vertices such that no scan-line occurs at a vertex. Upon detecting hairs, the user may 
either return to the Academy in attempt to repair the defected object, or return to the job editor for 
repositioning the object (either in a position where it will not hurt other objects, or for rotating 
it a bit-such operation solves in most cases stray-Iines generated by robustness problems!), or to ignore 
them. The user may choose to ignore stray-lines either because he or she is unable to fix the problem, 
or because the stray-lines are thin (i.e., there are only few successive scan-lines within one slice 
with the same problem), there are not too many of them, and they do not appear in subsequent slices. 
The user may preview all the slices in a sequence, display every kth slice (for k > 1), or jump between 
them at random. Once the user is satisfied with the slices, he or she may submit the job to the production 
machine. The sliced data is then sent through communication channels by using the appropriate machine-dependent 
protocol. Summary In this paper we describe the DFE, a data front-end for layered manufacturing of 3-dimensicmal 
models out of com­puter data. The system accepts data files from a variety of sources, chief of which 
is CAD systems, analizes them, and allows the user to modify and repair them individu­ally, and to design 
a production job for rapid prototyping. The DFE maybe customized for any layered-manufacturing technique. 
The system is commercially available from Cu­bital Ltd.; details can be obtained from the second author. 
In our opinion, the next generation of the DFE and similar systems will handle not only polyhedra but 
general smooth objects which are typically designed by using CAD systems. The approximation of such smooth 
objects by polyhedra was imposed on this industry only because the first RP technolo­gies were accompanied 
by software that insisted on inputing polyhedra. The de-facto standard of this industry (STL see Section 
2) is widely considered inadequate for accurate yet efficient production. However, direct slicing of 
smooth objects may be a much more computationally involved (and error-prune) task to perform.   Acknowledgments 
The geometric data structures of the system [Ba] were de­veloped by the first author as a Ph.D. student 
at Tel-Aviv University under the supervision of Prof. M. Sharir. The authors wish to thank L. Werner 
from A-Z PR for helpful discussions on the RF industry.  References <RefA>[3DS] <SinRef><institution>3D SYSTEMS</institution>, INC. (Valencia, 
CA), <title>Stereolithogra­phy Interface Specification</title>, <tech>p/n 50065-S01-00</tech>, <date>1989</date></SinRef>. [Ba] <SinRef><author>G. BAREQUET</author>,<title>DCEL: A polyhedral 
database and programming environment</title>, submitted for publica­ tion, <date>1996</date></SinRef>. [BS1] <SinRef><author>G. BAREQUET </author>AND <author>M. SHARIR</author>, 
<title>Filling gaps in the boundary of a polyhedron</title>, <journal>Computer-Aided Geomet­ric Design</journal>, <volume>12 </volume>(<date>1995</date>), <pages>207-229</pages></SinRef>. [BS2] 
<SinRef><author>G. BAREQUET</author> AND<author>M. SHARIR</author>, <title>Piecewise-linew in­terpolation between polygonal slices</title>, <journal>Computer Vi­sion and 
Image Understanding</journal>, <volume>63 </volume>(<date>1996</date>), <pages>251-272</pages>, </SinRef>[BW] <SinRef><author>J.H B@HN </author>AND<author> M.J. WOZNY</author>, <title>Automatic CAD­model repair: Shell-closure</title>, 
<booktitle>Proc. Symp. on Solid l+eeform Fabrication</booktitle>, <institution>Dept. of Mech. Eng., Univ. of Texas at Austin</institution>, <date>1992</date>, <pages>86-94</pages></SinRef>. 
[DM] <SinRef><author>A. DOLENC </author>AND<author>1. MAKELA</author>, <title>Optimized triangula­tion of parametric surfaces</title>, <tech>Technical Report TKO-B74</tech>, 
<institution>Helsinki University of Technology</institution>, <date>1991</date>, h4ath­ematics of Surfaces IV</SinRef>. [FD] <SinRef><author>J.D. FOLEY</author> <author>ANDA. VAN DAM</author>, 
l<title>%ndamentals of In­teractive Computer Graphics</title>, <publisher>Addison Wesley</publisher>, <date>1984</date></SinRef>, [Go] <SinRef><author>H. Goldstein</author>, <title>Classical Mechanics</title>, 
<publisher>Addison-Wesley</publisher>, Reading, <location>MA</location>, <date>1980</date></SinRef>. [Kl] <SinRef><author>G.T. KLINCSEK</author>, <title>Minimal triangulations of polygonal domains</title>, <journal>Annals 
of Discrete Mathematics</journal>, <volume>9</volume> (<date>1980</date>), <pages>121-123</pages></SinRef>. [KSL] <SinRef><author>F.-L. KRAUSE</author>, <author>C. STIEL</author>, AND <author>J. LUDDERMANN</author>, <title>Processing 
of CAD-dataaonversion, verification and repair</title>, <booktitle>Proc. Jth ACM Symp. on Solid Model­ing</booktitle>, <location>Atlanta, GA</location>, 
<date>1997</date>, to appear</SinRef>, [MD] <SinRef><author>I. MAKELA </author>AND <author>A. DOLENC</author>, <title>Some efficient pro­cedures for correcting triangulated 
models</title>, <booktitle>Proc. Symp. on Solid R-eeform Fabrication</booktitle>, <institution>Dept. of Mech. Eng., Univ. of Texas </institution>at <location>Austin</location>, <date>1993</date>. </SinRef>
[MF] <SinRef><author>S.M. MORVAN </author><author>ANDG.M. FADEL</author>, <title>IVECS, interac­tive correction of .STL files in a virtual environment</title>, 
<booktitle>Proc. Symp. on Solid l+eeform Fabrication</booktitle>, <institution>Dept. of Mech. Eng., Univ. of Texas</institution> at <location>Austin</location>, <date>1996</date>1<pages>491498</pages></SinRef>. 
[SW] <SinRef><author>H. SAMET </author><author>ANDR.E. WEBBER</author>, <title>Hierarchical data structures and algorithms for computer graphics; Part 
II: Applications</title>, <journal>IEEE Computer Gmphics t3 Applications</journal>, <volume>8</volume> (<date>1988</date>), <pages>5975</pages></SinRef>. [SH] <SinRef><author>X. SHENG </author>AND<author> B.E. HIRSCH</author>, 
<title>Triangulation of trimmed surfaces in parametric space</title>, <journal>Computer-Aided Design</journal>, <volume>24 </volume>(<date>1992</date>), <pages>437444</pages></SinRef>. [ST] 
<SinRef><author>X. SHENGANDU</author>.<title> TUCHOLKE,On triangulating sur­face model for SLA</title>, <booktitle>Proc. 2nd Int. Conf. on Rapid %ototyping</booktitle>, 
<location>Dayton, OH</location>, <date>1991</date>, <pages>236-239</pages></SinRef>. [Ta] <SinRef><author>R.E. TARJAN</author>, <title>Data Structures and Network Algo­rithms</title>, <publisher>SIAM</publisher>, <location>Philadelphia</location>, 
<date>1983</date>. </SinRef>[Te] <SinRef><author>TECNOMATICS, N. V., </author><title>Robface: The universal Rob-Cad programming interface</title>, <date>1988</date>. </SinRef>No] <SinRef><author>T.T. WOHLERS</author>, 
<title>STL viewers and editors</title>, <date>1996 </date>(available at <url>http: //lamar. colostate. edul uohlersjstl.viev. html</url>).</SinRef></RefA> 
 
			

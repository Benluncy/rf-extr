
 An Approach to the Classification of Domain Models in Support of Analogical Reuse Chung-Horng Lung and 
Joseph E. Urban Department of Computer Science and Engineering Arizona State University Tempe, AZ 85287-5406 
 Email: {clung Ijurban} @asuvax.eas.asu. edu Abstract This paper presents an approach to classify domain 
models in order to facilitate reuse through analogy. Domain analysis plays a critical role for systematic 
reuse, but domain analysis is difficult to perform, especially for new application areas. Analogical 
approach to reuse can support the domain analysis process by providing software products in a different 
but analogous domain. In order to achieve this goal, domain models need to be classified. This paper 
proposes a classification method for domain models. The method is an integration of the enumerative hierarchy 
and faceted scheme. The classification approach can help the domain analyst to locate an analogous domain 
to perform the modeling and analysis process. Moreover, the approach is more flexible and more descriptive 
than conventional classification methods. 1. Introduction Software reuse is recognized as an important 
research topic in software engineering. Software reuse has the potential to increase productivity, improve 
quality, enhance reliability, and shorten time-to-market. The problem in the current software community 
is not a lack of reuse, but a lack of well-defined systematic reuse [Prieto-Diaz 93]. Different approaches 
to software reuse have been reported in the literature. Among the approaches, domain analysis is advocated 
as a necessary step for effective reuse. There are two main reasons for utilizing domain analysis. Firstly, 
domain analysis emphasizes the reusability of analysis and design instead of just program code, The Permission 
to copy without fee all or parl of this material is granted provided that the copies are not made or 
distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association of Computing 
Machinery.To copy otherwise, or to republish, requires a fee and/or specific permission. SSR 95, Seattle, 
WA, USA G 1995 ACM 0-89791 -739-1/95/0004 ...$3.50 other reason is that domain analysis is a study of 
relevant information in a problem area rather than just one particular system. As a result of the study, 
commonalities and reusable information within a domain can be identified in the process. The analysis 
can then be reused to build new applications which are also in the same problem domain. Thus, domain 
analysis may support reuse to a large degree and has the potential to receive high payoff. Although domain 
analysis has the potential to promote large-scale software reuse, it suffers some barriers due to the 
complexity and the effort required. Domain analysis is generally suited to well-understood domains. But 
domain analysis is difficult to start for poor-understood problems or new application areas. Analogical 
problem solving is another approach to software reusability. Analogical problem solving transfers knowledge 
from past problems to new target problems that share significant similarities with the past problems 
in order to construct solutions to the target problems. Analogy is a topic of interests in many research 
disciplines, such as psychology, cognitive science, artificial intelligence, education, and philosophy. 
While domain analysis identifies commonalities across applications in a specific domain, analogical reasoning 
often occurs between different domains. There are many analogous examples in sciences, e.g., the analogy 
between the solar system and the structure of an atom. Therefore, analogy is not based on syntactical 
similarities between different systems but the implicit knowledge structure of the problems. Two problems 
may be different in syntax, and yet share a common knowledge structure. The reuse of problem solving 
experience and knowledge from one domain to another makes analogy an interesting and attractive approach. 
Moreover, analogy may facilitate the analysis for a new domain or a poorly understood domain. In order 
to support software reuse across different but analogous domains, the results of domain analysis must 
be classified, especially the high-level software artifacts, such as domain models. A domain model is 
a representation of a domain that depicts objects and relationships, functions, and behaviors. The model 
 identifies generic requirements or commonalities and differences of the problems in a domain. Classification 
in one of the most fundamental methods adopted in various disciplines of science and engineering. Classification 
helps people compare and understand different systems or areas. Recently, classification has also been 
studied for software, either for low-level components or high-level artifacts. There are two major categories 
to classify software: enumerated and faceted schemes. The enumerative hierarchy approach suffers the 
problem of inflexibility, whereas the faceted scheme alone cannot adequately specify complex application 
domains. This paper describes a classification approach for domain models. The purpose of the classification 
is to facilitate the domain analysis process for new or not well-understood target domains through the 
retrieval of existing analogous domains. The classification is a hybrid of hierarchical and faceted schemes. 
In other words, the classification consists of a hierarchy of facets. The paper follows with Section 
2, which is an overview of the concept of domain analysis. Section 3 introduces the studies of analogy 
in various disciplines and in software engineering. Section 4 discusses methods to classify software 
and postulates a classification approach for domain models. Lastly, Section 5 summarizes the discussion 
of the paper and presents some future research directions. 2. Domain Analysis Greenspan, et al. [Greenspan 
82], Borgida, et al. [Borgida 85], Curtis, et al. [Curtis 88], and Johnson, et al. [Johnson 92] addressed 
the importance of incorporating real world knowledge (domain knowledge) into the process of requirements 
analysis. However, they only focused on a particular system instead of a class of applications. Neighbors 
[Neighbors 84] was one of the first researchers to define domain analysis as being the activity of identifying 
the objects and operations of a class of similar systems in a particular problem domain. Kang, et al. 
[Kang 90] defined domain analysis as the process of identifying, collecting, organizing, and representing 
the relevant information in a domain based on the study of existing systems and their development histories, 
knowledge captured from domain experts, underlying theory, and emerging technology within the domain. 
There were several approaches to domain analysis discussed in the literature, e.g., [McCain 85, Prieto-Diaz 
87, Cleveland 88, Arango 89, Shlaer 89, Bailin 90, Kang 90, Campbell 91, Devanbu 91, Lubars 91, Simos 
91]. These approaches have different perspectives on the process and the products on domain analysis. 
Nevertheless, these approaches share a common purpose, which is to manage the identification, capture, 
and evolution of domain knowledge and make the information reusable when creating new systems in the 
same application domain. Wartik and Prieto-Diaz [Wartik 92] proposed a set of classification criteria 
in order to compare different domain analysis approaches. The reusable information generally represents 
a set of features common to a collection of existing and future applications in a problem domain. Domain 
analysis has been advocated as a critical step to support systematic software reuse [Prieto-Diaz 93], 
Domain analysis is related to several other research areas. These areas include requirements engineering, 
object­oriented methods, knowledge engineering, software factories, and library science. Prieto-Diaz 
and Arango [Prieto-Diaz 91a] have addressed those issues in the tutorial and have collected a set of 
articles specifically on domain analysis. The kinds of software products that domain analysis may produce 
include source code, design, specifications, objects, text, architectures, and domain models. An architecture 
defines basic system components and their relationships and interfaces. Architectures are used as generic 
development frameworks for a set of similar problems, so that the developer does not need to build a 
high-level design for each application within a domain. A domain model defines the functions, objects, 
relationships, and behaviors in a domain. The model identifies generic requirements or commonalities 
and differences of the problems within a domain. Domain analysis can be viewed as an expansion of the 
conventional requirements analysis. The main advantage that domain analysis provides is flexibility. 
However, domain analysis suffers some barriers due to the complexity and a large amount of time required 
for development. Domain analysis is suited for stable, muture, and well-understood domains [Biggerstaff 
92, Arango 93]. For new domains, analysis may be difficult to start. Furthermore, commonalities of various 
levels also exist among different application domains. Therefore, domain analysis may suffer the same 
problem that requirements analysis has been suffering, i.e., lack of flexibility to support reuse for 
similar applications. Analogy analysis, presented in the next section to overcome the problem, broadens 
the scope of analysis for different but analogous application domains. Through analogy, reuse of various 
of levels of software is possible across domains. 3. Analogy Analogical problem solving is a process 
of transferring knowledge from past problem solving experiences to a new problem that share significant 
similarities with the past problem. The transferred knowledge is then used to construct solutions for 
the new problem. Analogy is a powerful problem solving and learning mechanism that has been studied 
in the areas of psychology, cognitive science, artificial intelligence, education, and philosophy. Several 
articles [Kedar-Cabelli 88, Hall 89, Leishman 90, Bejar 91] have surveyed or discussed analogy in those 
areas. Analogy also plays a vital role in scientific discovery or invention. One example is the analogy 
between electricity and water flow in a pipe. In this case, voltage is like the water pressure, and current 
is similar to the amount of water flowing through a pipe at a given time. John-Steiner [John-Steiner 
85] and Biela [Biela91] presented a number of examples explaining analogical inferences as a scientific 
method in science. Recently, the concept of analogy has been applied to systems management and software 
engineering [Silverman 85a, Silverman 85b, Finkelstein 88, Miriyala 89, Maclean 91, Neal 90, Maiden 92, 
Lung 93, Maiden 93, Harandi 93, Lung 94]. These papers discuss various aspects of analogy. The aspects 
include procedural models, role of analogy in the design of software, software derivation from analogous 
applications, types of knowledge required, and rules or strategies for the selection of analogous domains. 
It is generally accepted that there are similarities among different application domains. For example, 
Finkelstein [Finkelstein 88] presented the similarities between the patient monitor system and the burglar 
alarm system. Maiden and Sutcliffe [Maiden 92] also have showed that the air traffic controller and the 
flexible manufacturing systems share some important commonalities. Similarities can be further distinguished 
into three categories, namely, syntactical, semantic, and pragmatic similarities. Two syntactically similar 
domains may not be analogous. On the other hand, two domains may share similar knowledge structures even 
if the domains are different in syntax. Similar knowledge structures are the key to drawing an analogy 
between two different application domains. This paper does not address how or what features are required 
to draw an analogy between different problem areas. The papers just listed above presented different 
perspectives on the issue. Instead, the paper discusses how to classify the application domains in order 
to support the analogy analysis and identification process. The identified analogous domains can then 
be reasoned to facilitate the domain analysis process for the new problem area. The next section addresses 
the classification approach for domain models. 4. Classification Classification or clustering analysis 
is central to human reasoning and problem solving capabilities. Classification is useful in the construction 
of complex knowledge structures from featural information, object clusters, and category structure [Hanson 
83]. Classification is used to group similar entities together to develop a set of clusters, so that 
the similarity within a cluster is high, while the similarity between clusters is low. Clustering analysis 
has evolved from numerical methods to conceptual approaches [Michalski 83]. Lately, classification schemes 
have also been adopted for software components to support reuse [Prieto-Diaz91 b]. This section consists 
of several sub-sections. First, Section 4.1 provides an overview of software classification schemes. 
Section 4.2 presents an approach to the classification of domain models in support of software analogy. 
Finally, Section 4.3 illustrates the approach with examples. 4.1 Overview of Software Classification 
Schemes Maiden and Sutcliffe [Maiden 93], Mineau, et al. [Mineau 94] and Bhansali [93] have pioneered 
the research in classifying high-level software artifacts, such as software architectures and domain 
models. Although these approaches are different, there is, however, an aspect in common. These approaches 
all generate a classification hierarchy. The hierarchy follows the track of enumerative classification 
schemes in library science. The enumerative method divides the universe of knowledge into classes that 
include all possible compounded classes [Prieto-Diaz 87]. These classes are then organized in a hierarchical 
relationship. The major problem with the approach is the inflexibility. For software, a flexible classification 
is required that can meet the demands of continuous expansion and evolution of software. The consideration 
of flexibility is even more important for domain models, since domain models are much more complex than 
software parts. Moreover, a complex domain may consist of several sub-domains. A hierarchy of domain 
models is adequate to represent or distinguish various features embedded in different application domains. 
In faceted classification schemes [Prieto-Diaz 9 lb], parts or components are described by a set of standard 
terms or facets; each facet describes a key aspect of the software. These approaches are more descriptive 
and extensible than the enumerative methods. However, the faceted classification approach is mainly designed 
for software parts. For software products in the early phase of the life cycle, the approach alone has 
a major problem of determining and selecting the appropriate facets due to the complexity and uncertainty. 
Poulin and Yglesias [Poulin 93] also reported some empirical issues encountered in utilizing the faceted 
classification scheme. The authors advocated a combination of classification techniques to support software 
classification. Facet Description I Examples Application Broad problem domain area inventory control, 
Domain library Layer 1 Resource Type The type of key objects reusable, consumable Domain High level 
description of primary scheduling, allocation Abstraction domain characteristics J Function Key system 
functions check_out, return, I reserve Layer 2 Relation Class Classes of semantic relations for key class 
inclusion, ca&#38;e­ objects purpose Purpose Main design goal safety, productivity Trigger The type of 
triggering mechanism automatic, manual, neridic J Complexity The degree of complexity of the high, 
medium, low application domain Layer 3 Size The expected software size of the high, medium, low application 
domain Certification The quality rating of the generated high, medium, low Level domain models Figure 
1. Hierarchy of Domain Model Facets Domain abstractions proposed by Maiden and Sutcliffe  4.2 Integration 
of Enumerative Hierarchy [Maiden 93] are used to group similar application and Faceted Scheme domains 
based on high-level requirements and key facts about classes of domains. The concept is similar to the 
The main concept of the article is similar to that proposed problem-class model proposed by Bhansali 
[Bhansali 93] by Poulin and Yglesias, i.e., a combination of and generic data models presented in [Mineau 
94]. The classification methods. Two classification methods, facet approach adopted in this paper is 
similar to the idea namely, enumerative hierarchy and facets, described presented by Maiden and Sutcliffe, 
i.e., classes of domain above are integrated. The approach consists of various are identified by the 
key domain facts or characteristics. layers. Each level in the hierarchy, in turn, is composed Each class 
consists of several application domains which of a set of facets. Figure 1 illustrates the concept of 
share similar high-level generic abstractions. hierarchical facets. The hierarchy currently consists 
of three layers. Each layer also represents different levels of Currently, some commonly encountered 
domain abstraction. abstractions, mainly in the general business area, are defined in the paper to demonstrate 
the feasibility. Table Facets in the first layer are used as classifiers. The usage 1 shows those domain 
abstractions and their descriptions. of an application domain facet is to ensure that Obviously, the 
set of generic domain abstractions will applications in the same domain are grouped together in continuously 
evolve as more research and experiment in the classification stage. In this way, applications in the 
this area is conducted. Some areas like data base same domain are always retrieved first for the target 
management systems, networks, programming languages,during the analogy phase. Critical objects or resources 
are and software engineering environments are considered as then categorized. Grosz [Grosz 92] defined 
different supporting systems instead of domain abstractions. The types of resources. The categories include 
consumable facet of domain abstractions is primarily used to select resources (for instance, the product 
in the inventory some analogous domains to facilitate the domain analysis system) and reusable resources 
(for example, books in a process of the target if there is no existing products of the library). Consumable 
types are further composed of same domain available in the library. perishable (fresh products in a grocery) 
and nonperishable (hardware). Reusable objects are distinguished as Facets in layer 2 primarily serve 
to bridge the gaprenewable objects (books in a library or video tapes in a between the generic domain 
abstractions and features in rental store) and repairable objects (cars or airplanes). An specific application 
domains. These facets are actuallyobject can also be characterized by more than one feature. abstractions 
of software products developed in the domain Table 1 Some Representative Domain Abstractions nnrn-v... 
2; n A h~frnotinn -... . . UU -w ...,.. I Tbw-rintinn -Vuw. .yuu.. I Flv.m l.c -(.u,,.~.w. Object Amount 
Control This abstraction supports an analogy for domains warehouse stock control, that resupply an object 
when a minimum level is room temperature reached. A predefine amount will be ordered or control added, 
or a warning is signaled. Object Recording This abstraction supports an analogy for domains personnel 
information that keep track of objects records as objects system, student entering and leaving an environment. 
administration, zoo animals control Object Scheduling This abstraction supports an analogy for domains 
manufacturing systems, that deal with scheduling objects in order to get a vehicle (aircraft, buses, 
maximum productivity or efficiency with limited trucks) dispatching resources. systems Object Positions 
This abstraction supports an analogy for domains ATC, airspace that monitor the moving of objects in 
a space to navigational systems, ensure the correct positions. manufacturing systems Object Allocation 
This abstraction supports an analogy for domains library systems, car that allocate an object to another 
object (usually rental, reservation an agent). The allocated objects are returned after systems (hotel, 
airline) a period of time. Object Distribution This abstraction supports an analogy for domains parcel 
delivery systems, that collect mass objects in a central location and goods distribution then distribute 
the objects into prespecified applications destinations. Periodic Object This abstraction supports an 
analogy for domains banking systems, [nitiating that periodically report or verify the status of an vehicles 
(aircraft, trucks, object, or issues some operations to other objects. cars) maintenance, recording periodic 
inventory report, salary systems Object Coordination This abstraction supports an analogy for domains 
traffic signal control that monitor an object class (vehicle), systems, traffic synchronize and coordinate 
other objects (traffic management systems lights) to increase the efficiency or safety of the object 
class (vehicle). 3bject Simulation This abstraction supports an analogy for domains discrete simulation, 
that simulate real world problems by controlled continuous simulation, resources and analyze results. 
computer systems simulation 3bject Combination This abstraction supports an analogy for domains traffic 
management that collect individual objects and combine those systems, point-of-sale objects for update, 
analysis, or control. (POS) systems modeling phase. A function facet represents key functions in the 
domain. The relation class depicts the type of semantic relations for critical objects. Relations between 
objects have been recognized as basic in analogical problem solving. Empirical evidence supports that 
comparison and evaluation of relations is a commonly used and effective approach to judge similarities 
between two entities [Herrmann 86, Chaffin 881. Studies in cognitive science also indicate that words, 
analogy may be processed differently for different types of relations. Bejar, et al. [Bejar 91] derived 
a taxonomy to group semantic relations. Detailed discussion of the classification of semantic relations 
is beyond the scope of this paper. With the taxonomy, th relations can be decomposed into common aspects 
that the systems are sharing and aspects that the systems differ, Thereby, relations can be better understood 
and analogical reasoning can be facilitated. different relations ma~ be processed differently. In other 
173 Facet type Specific Facet Descriptions Application car rental problem Domain Resource Type vehicle: 
reusable, repairable Layer 1 user: customer, agent staff agent Domain object allocation Abstraction 
 Function users can check outheturnlreserve vehicles staff can search/manage/ttpdate/verify vehicle 
fleet Relation Class user: vehicle Agent: Instrument staff vehicle Agent: Object Layer 2 staff user 
 Agent: Recipient Purpose The system provides services to allow users to rent vehicles. The system allows 
staff to keep track of vehicle fleet. The system calculates the rental cost for users. ~ Trigger Figure2. 
Specific Facet Descriptions forthe Car Rental Problem Purposes or system goals will heavily influence 
the lead the software developer to a simpler design method information transfer from a base to a target 
[Kedar-Cabelli for the car rental problem. Certification level is an The purpose in layer 2 lists the 
85, Holyoak 89]. indicator of how rigorous the models are produced. To prioritized design goals. Two 
different domains may have reuse existing software artifacts, no matter in what form, similar static 
structures and dynamic characteristics, but quality is one of the major factors that must be different 
goals. For example, the air traffic controller considered. (ATC) and the flexible manufacturing system 
(FMS) presented in [Maiden 92] have a similar object monitoring In cases where a domain contains a set 
of sub-domains, concept, but different goals. For ATC, the main goal is to the iterative process can 
be applied to examine and select maintain safe, orderly, and expeditious flow of traffic appropriate 
facets. For example, the ATC consists of [Garot 87]. In FMS, the major concern is how to schedule several 
major functional elements. Those elements are and coordinate machine stations to gain a high planning, 
controlling, system, data managing, and man­productivity rate and machine utilization, and at the same 
machine interface [Hunt 87]. Thus, the ATC may include time reduce throughput time [p. 174, Talavage 
88]. The several domain abstractions. A FMS also contains sub­significant difference will lead to different 
emphasis in domains. The major control functions for the FMS are reasoning and problem solving. planning, 
scheduling, monitoring, and real-time control [Lee 93]. Triggering describes the main cause of system 
dynamics. Presently, a distinction is made among automatic, manual, 4.3 Illustration of the Classification 
of and periodic triggering for main domain transitions. Domain Models Although periodic triggering is 
a special case of automatic triggering, it is explicitly listed because of the important This section 
explains the task to classify a target domain. role that periodic triggering plays in some applications. 
The first step is to fill out the top two layers of a hierarchy of facets, as demonstrated in Figure 
1, Layer 3 is thisFacets in the third layer are general software attributes. figure will be examined 
and filled out after the analysisThese attributes reveal another aspect of the domain and phase. For 
the car rental problem, Figure 2 illustrates are used to bridge the gap between the domain and a those 
facets for the top two layers. specific application or design alternatives. Two analogous domains with 
different complexity levels may A domain may consist of more than one domainneed different design approaches. 
For example, the abstraction, since a domain may include smaller sub­library problem and the car rental 
system have similw key domains. The car rental problem shown above is limitedfeatures like checkout, 
return, and search. General library to a specific task: manage the system to rent vehicles toproblems 
usually need a more sophisticated data base customers. The problem can be expanded to includemanagement 
system than can rental systems due to the vehicle maintenance tasks. In other words, the systemlarger 
volume of books than cars. The difference may will keep a maintenance record for each vehicle and periodically 
signal the need for specific inspection or 174 maintenance work for the vehicles. In such a situation, 
the domain boundary is enlarged to include another domain abstraction, which is the periodic object initiating 
as listed in Table 1. The expansion of the problem domain will yield another hierarchy of facets specifically 
for the new domain abstraction. Up to this point in the process, a generic domain abstraction has been 
generated and specific facet values forthetarget domain have been identified. However, this information 
alone is not sufficient to guide the designer to reuse more analysis and design knowledge in the future 
because generic domain abstractions are at too high a level to bereused for specific applications. The 
generic domain abstraction must be provided with some specific guidelines to facilitate further reuse 
of existing reusable software artifacts. A bridge needs to be established between the generic domain 
abstraction and specific domain facts or features. The concept is illustrated in Figure 3. The top level 
of Figure 3 is a domain abstraction common to a class of analogous domains. This level represents domain 
independent features within the domain abstraction. Domain-specific features are identified during the 
analogy process. These features lead to a subset of domains sharing the features. This level is domain 
dependent, but is application independent. For example, one of the features in the car rental problem 
is that customers can reserve a vehicle for a period of time. Reservation is then deemed as a domain-specific 
feature for this class, since this characteristic is not included in the domain abstraction. If the fact 
is totally new to the reuse library, design horn scratch is needed. The newly designed software artifacts 
are hence stored in the library. If the fact has been previously identified for some domains, then those 
domains sharing the same feature are classified in the same group. Reuse of existing analysis and design 
for this particular fact is then highly possible for the new domain. For instance, the hotel management 
system also features the fact of reservation. The fact will guide the designer to examine existing application 
domains that have reservation features in common. As a result, the car rental problem is grouped together 
with the hotel reservation problem under the same characteristic of reservation. After the identification 
of domain-specific features, the next level depicts the differences between applications in the same 
domain. For instance, different rental companies may have different reservation policies. The bottom 
two levels can further be decomposed into several layers of specific features. For example, the reservation 
feature may be divided into two groups: one for car rental and hotel applications, the other one for 
airline reservation systems. As more research is conducted and more practical domain analysis .is performed, 
the classification will be more rigorous and have more accurate information. For the library problem 
and the car rental problem, different features yield a generic/specific modeling structure. Figure 4 
represents a simple illustration of this approach. The first level shows a domain abstraction, object 
allocation, and the key features generic to all domains classified in the same category. The second level 
represents some features which are specific to some domains. For instance, in both the car rental problem 
and the library problem, a user can renew an object. But the same feature is not allowed in the airline 
reservation problem. The next level reveals features that are specific to different applications in a 
domain. For example, different library systems may adopt different renewal policies as demonstrated in 
Figure 4. The reuse library of domain models will keep evolving and improving. Classification of domain 
models supports the identification and retrieval of similar or analogous domains. The analysis process 
for the new target domain can then be facilitated by comparing and reasoning existing solutions to analogous 
domains. Classification of domains into generic and specific models also leads to more flexible architectures, 
because the adaptability is already embedded in the hierarchy. Adaptation is an important but often neglected 
processing stage in analogy [Keane 94]. In addition, the approach gives the analyst or designer more 
leverage than current approaches in software analogy and domain analysis. 5. Conclusion and Future Research 
Directions This paper described the potential of software analogy. Software analogy can facilitate domain 
analysis tasks by providing analogous application areas which has been previously well analyzed and designed. 
The paper presented an approach to classifying high-level software products in support of software analogy. 
The approach is a hybrid of enumerative hierarchy and faceted scheme approaches. More research and empirical 
studies are needed in order to effectively classify domain models. Supporting tools are necessary to 
facilitate the retrieval and storage of software artifacts. Also, an environment with integrated tools 
and repositories are required to systematically support the analogy process and transformation between 
different representations. 175 domain independent \ .-- I I domain dependent, feature 1 feature m ... 
application independent Figure 3. Hierarchical View of Analogous Domains and Applications domain user 
checks outheturns abstraction staff manages/rrpdates/verifies/searches ... domain­specific features 
 ? ? application­specific features   @5Ex!!El Q timing restrictions  Figure 4, An Illustration of 
Domain Hierarchy References <RefA>[Arango 89] G. Arango, Domain analysis from art to engineering discipline, 
in Proc. of the 5th Int 1 Workshop on Soflware Spec@cation and Design, 1989, pp. 152-159. [Arango 93] 
G. Arango, E. Schoen, and R. Pattengill, A process for consolidating and reusing domain knowledge, in 
Proc. of the Int 1 Con on Software Engineering, 1993, pp. 231-142. [Bailin 90] S. C. Bailin, J. M. Moore, 
R. Bentz, and M. Bewtra, KAPTUR: Knowledge acquisition for preservation of tradeoffs and underlying rationales, 
in Proc. of the 5th Knowledge-Based Sofiware Assistant Conf, 1990. [Bejar 91 ] I. I. Bejar, R. Chaffin, 
and S. Embretson, Cognitive and Psychometric Analysis of Analogical Problem Solving, Springer-Verlag, 
1991. [Biela 91] A. Biela, Analogy is Science: From a Psychological Perspective, Peter Lang, 1991. [Bhansali 
93] S. Bhansali, Architecture-driven reuse of code in KASE, in Proc. of the 5th Conf on Sof~are Eng. 
&#38; Knowledge Eng., 1992, pp. 100-109. [Biggerstaff 92] T. J. Biggerstaff, An assessment and analysis 
of software reuse, in Advances in Computers, vol. 34, 1992, pp. 1-57. [Borgida 85] A. Borgida, S. Greenspan, 
and J. Mylopoulos, Knowledge representation as the basis for requirements specifications, Computer, pp. 
82-90, April 1985. [Campbell 91] G. Campbell, N. Burkhard, J. Facemire, and J. O Connor, Synthesis Guidebook, 
Technical Report SPC-91122-MC, Software Productivity Consortium, Hemdon, VA, 1991. [Chaffin 88] R. Chaffin 
and D. J. Herrmann, The nature of semantic relations: a comparison of two approaches, in Relational Models 
of the Lexicon: Representing Knowledge in Semantic Networks, M. W. Evens, Ed., Cambridge University Press, 
1988, pp. 289-334. [Cleveland 88] J. C. Cleaveland, Building application generators, IEEE SofMare, pp. 
25-33, July 1988. [Curtis 88] B. Curtis, H. Krasner, and N. Iscoe, A field study of the software design 
process, Commun. of the ACM, vol. 31, no. 11, pp. 1268-1287, NOV. 1988. [Devanbu91] P. Devanbu, R. Brachman, 
P. G. Selfridge, and B. W. Ballward, LaSSIE: a knowledg-based software information system, Commun. of 
the ACM, vol. 34, no. 5, pp. 34-49, May 1991. [Finkelstein 88] A. Finkelstein, Re-use of formatted requirements 
specifications, Software Eng. J., pp. 186-197, Sept. 1988. [Garot 87] J. M. Garot, D. Weathers, and 
T. Hawker, Evaluating proposed architectures for the FAA s advanced automation system, Computer, vol. 
20, no. 2, pp. 33-46, Feb 1987. [Greenspan 82] S. J. Greenspan, J. Mylopoulos, and A. Borgida, Capturing 
more world knowledge in the requirements specification, m Proc. of Int 1 Conf on Software Engineering, 
1982, pp. 225-234. [Grosz 92] G. Grosz, Building information system requirements using generic structures, 
 in Proc. of [he 16th Int 1 Computer Sof~are &#38; Applications Conf (COMPSAC), 1992, pp. 200-205. [Hall 
89] R. P. Hall, Computational approaches to analogical reasoning: a comparative analysis,  Artificial 
Intelligence, VOI. 39, no. 11, pp. 39-120, May 1989. [Hanson 83] S. J. Hanson, Conceptual clustering 
and categorization, in Machine Learning: An Art@icial Intelligence Approach, vol 3, Y. Kodratoff and 
R. Michalski, Eds., Morgan Kaufmann Publishers, pp. 235-268, 1983. [Harandi 93] M. T. Harandi, The role 
of analogy in software reuse, in Proc. of 1993 ACM/SIGAPP Symposium on Applied Computing, 1993, pp. 
40-47. [Herrmann 86] D. J. Herrmann and R. Chaffin, Comprehension of semantic relations as a function 
of the definitions of relations, in Human Memory and Cognitive Capabilities: Mechanisms and Pe~ormances, 
F. Klix and H. Hagendorf. Eds., Elservier Science Publishers B. V., North-Holland, 1986, pp. 311-319. 
[Holyoak 89] K. J. Holyoak and P. Thagard, Analogical mapping by constraint satisfaction, Cognitive Science, 
vol. 13, pp. 295-355, 1989. [Hunt 87] V. P. Hunt and A. Zellweger, Strategies for future air traffic 
control systems, Computer, vol. 20, no. 2, pp. 19-32, Feb. 1987. [Johnson 92] W. L. Johnson, K. M. Benner, 
and D. R. Harris, Applying domain and design knowledge to requirements engineering, ACM SIGOIS Bulletin, 
vol. 13, no. 2, pp. 48-57, /w&#38; 1992. [John-Steiner 85] V. John-Steiner, Notes of the Mind: Explorations 
of Thinking, University of New Mexico Press, 1985. [Kang 90] K. C. Kang, et al. Feature-oriented domain 
analysis (FODA) feasibility study, Technical Report CMU/SEI-90-TR­21, 1990. [Keane 94] M. T. Keane, Analogical 
asides on case-based reasoning, in Lecture Notes in Artficial Intelligence, Topics in Case-Based Reasoning, 
vol. 837, Springer-Verlag, 1994. [Kedar-Cabelli 85] S. Kedar-Cabelli, Purpose-directed analogy, in Proc. 
of Cognitive Science Society Conf, 1985, pp. 150-159. [Kedar-Cabelli 88] S. Kedar-Cabelli, Analogy -from 
a unified perspective, in Analogical Reasoning, D. H. Helman, Ed., Kluwer Academic Publishers, 1988, 
pp. 65-104. [Lee 93] Y. K. Lee and S. J. Park, OPNets: an object-oriented high-level Petri net model 
for real-time system modeling, J. of Systems Software, vol. 20, no. 1, pp. 69-86, Jan. 1993. [Leishman 
90] D. Leishman, An annotated bibliography of works on analogy, Int 1 J. of Intelligent Systems, vol. 
5, no. 1, pp. 43-82, March 1990. [Lubars 91] M. D. Lubars, Domain analysis and domain engineering in 
IDeA, in Domain Analysis and Software Systems Modeling, R. Prieto-Diaz and G. Arango, Eds., IEEE Computer 
Society Press, Los Alamitos, CA, 1991, pp. 163-178. [Lung 93] C. H. Lung and J. E. Urban, Integration 
of domain analysis and analogical approach for software reuse, in Proc. of 1993 ACM/SIGAPP Symposium 
on Applied Computing, 1993, pp. 48-53. [Lung 94] C. H. Lung, An analogy-based domain analysis methodology, 
Ph.D. Dissertation, Dept. of Comp. Sci. and Eng., Arizona State University, Tempe, AZ, 1994. [MacLean 
91] A. MacLean, V. Bellotti, and R. Young, and T. Moran, Reaching through analogy: a design rationale 
perspective on roles of analogy, in Proc. of the Conf on Human Factors in Computing Systems, 1991, pp. 
167-172. [Maiden 92] N. A. M. Maiden and A. G. Sutcliffe, Exploiting reusable specifications through 
analogy, Commun. of the ACM, vol. 35, no. 4, pp. 55-64, April 1992. [Maiden 93] N. A. M. Maiden and A. 
G. Sutcliffe, Requirements engineering by example: an empirical study, in Proc. of IEEE Int 1 Symposium 
on Requirements Eng., 1993, pp. 104-111. [McCain 85] R. MaCain, Reusable software component construction, 
 in Proc. of 5th AIAA/A CM/NASA/IEEE Computers in Areospace Conf, 1985, pp. 125-135. [Michalski 83] R. 
Michalski and R. Stepp, Learning for observation: conceptual clustering, in Machine Learning: An Artificial 
Intelligence Approach, vol 3, Y. Kodratoff and R. Michalski, Eds., Morgan Kaufmanrr Publishers, pp. 331-363, 
1983. [Mineau 94] G. W. Minuau and R. Godin, Automatic sturcturing of knowledge bases by conceptual clustering, 
 to appear in IEEE Trans. of Data and Knowledge Eng.. [Miriyala 89] K. Miriyala and M. T. Harandi, Analogical 
approach to specification derivation, in Proc. of 5th Workshop on Sofmare Specification and Design, 
1989, pp. 203-210. [Neal 90] L. Neal, Support for software design, development, and reuse through an 
example-based environment, in Proc. of the 5th Conf on Knowledge-based SofWare Assistant, 1990, pp. 
176-182. [Neighbors 84] J. M. Neighbors, The Draco approach to constructing software from reusable components, 
 lEEE Trans. on Soflware Engineering, vol. 10, no. 5, pp. 564-574, Sept. 1984. [Poulin 93] J. S. Poulin 
and K. P. Yglesias, Experiences with a faceted classification scheme in a large reusable software library 
(RSL), in Proc. of the 17th Int 1 Computer Software &#38; Applicatfins Conf (COMPSAC), 1993, pp. 90-99. 
[Prieto-Diaz 87] R, Prieto-Diaz, Domain analysis for reusability, in Proc. of the Ilth Int 1 Computer 
Software &#38; Applications Conf (COMPSAC), 1987, pp. 23-29. [Prieto-Diaz 91a] R. Prieto-Diaz and G. 
Arango, Eds., Domain Analysis and Software Systems Modeling, IEEE Computer Society Press, Los Alamitos, 
CA, 1991. [Prieto-Diaz 9 lb] R. Prieto-Diaz, Implementing faceted classification for software reuse, 
Commun. of the ACM, vol. 34, no. 5, pp. 89-97, May 1991. [Prieto-Diaz 93] R. Prieto-Diaz, Status report: 
software reusability, IEEE Sof~are, pp. 61-66, May 1993. [Shlaer 89] S. Shlaer and S. J. MeHor, An object-oriented 
approach to domain analysis, Sof2ware Enginering Notes, vol. 14, no. 5, July 1989, pp. 66-77. [Silverman 
85a] B. G. Silverman, The use of analogs in the innovation process: a software engineering protocol analysis, 
IEEE Trans. Systems, Man, and Cybernetics, vol. SMC-15, no. 1, pp. 30-44, Jan./Feb. 1985. [Silverman 
85b] B. G. Silverman, Software cost and productivity improvements: an analogical view, Computer, vol. 
18, no. 5, pp. 86-96, May 1985. [Simos 91] M. A. Simos, The growing of an organon: a hybrid knowledge-based 
technology and methodology for software reuse, in Domain Analysis and Soflware Systems Modeling, R. Prieto-Diaz 
and G. Arango, Eds., IEEE Computer Science Press, Los Alamitos, CA, 1991, pp. 204-221. [Talavage 88] 
J. Talavage and R. G. Hannam, Flexible Manufacturing Systems in Practice: Applications, Design, and Simulation, 
Marcel Dekker, Inc., New York, NY, 1988. [Wartik 92] S. Wartik and R. Prieto-Diaz, Criteria for comparing 
reuse-oriented domain analysis approaches, Int 1 J. of Soflware Eng. and Knowledge Eng., vol. 2, no. 
3, pp. 403­432, Sept. 1992. </RefA>
			


 Algorithmic Lower Bounds for Problems Parameterized by Clique-width Fedor V. Fomin* Petr A. Golovach 
Daniel Lokshtanov Saket Saurabh Department of Informatics, University of Bergen, N-5020 Bergen, Norway 
{fedor.fomin|petr.golovach|daniello|saket.saurabh}@ii.uib.no Abstract Many NP-hard problems can be solved 
e.ciently when the input is restricted to graphs of bounded tree-width or clique­width. In particular, 
by the celebrated result of Courcelle, every decision problem expressible in monadic second order logic 
is .xed parameter tractable when parameterized by the tree-width of the input graph. On the other hand 
if we restrict ourselves to graphs of clique-width at most t, then there are many natural problems for 
which the running time of the best known algorithms is of the form n f(t), where n is the input length 
and f is some function. It was an open question whether natural problems like Graph Coloring, Max-Cut, 
Edge Dominating Set, and Hamiltonian Path are .xed parameter tractable when parameterized by the clique-width 
of the input graph. As a .rst step toward obtaining lower bounds for clique-width parameterizations, 
in [SODA 2009 ], we showed that unless FPT =W[1], there is no algorithm with run time O(g(t) · n c), 
for some function g and a constant c not depending on t, for Graph Coloring, Edge Dominating Set and 
Hamiltonian Path. But the lower bounds obtained in [SODA 2009 ] are weak when compared to the upper bounds 
on the time complexity of the known algorithms for these problems when parameterized by the clique-width. 
In this paper, we obtain the asymptotically tight bounds for Max-Cut and Edge Dominating Set by showing 
that both problems cannot be solved in time f(t)n o(t), unless Exponential Time Hypothesis (ETH) collapses; 
and O(t) can be solved in time n , where f is an arbitrary function of t, on input of size n and clique-width 
at most t. We obtain our lower bounds by giving non-trivial structure-preserving linear FPT reductions 
. 1 Introduction Tree-width is one of the most fundamental parameters in Graph Algorithms. Graphs of 
bounded tree-width enjoy good algorithmic properties similar to trees and this is why many problems which 
are hard on general graphs can be solved e.ciently when the input is restricted to graphs of bounded 
tree-width. On the other hand, many hard problems also become tractable when restricted to graphs similar 
to complete graphs . Courcelle and Olariu [6] introduced the notion of clique­width which captures nice 
algorithmic properties of both extremes. Since 2000, the research on algorithmic and struc­tural aspects 
of clique-width is an active direction in Graph Algorithms, Logic, and Complexity. Corneil, Habib, Lanlignel, 
Reed, and Rotics [4] show that graphs of clique-width at most 3 can be recognized in polyno­mial time. 
Fellows, Rosamond, Rotics, and Szeider [10] settled a long standing open problem by showing that computing 
clique-width is NP-hard. Oum and Seymour [26] describe an algorithm that, for any .xed t, runs in time 
O(|V (G)|9 log |V (G)|) and computes (23t+2 - 1)­expressions for a graph G of clique-width at most t. 
Recently, Hlin.en´y and Oum obtained an algorithm run­ning in time O(|V (G)|3) and computing (2t+1 - 
1)­expressions for a graph G of clique-width at most t [18]. We refer to the recent survey [19] for further 
information on di.erent width parameters beyond tree-width. There was an intensive study on the algorithmic 
perspective of graphs of bounded clique-width. There is a meta-theorem of Courcelle, Makowsky, and Rotics 
[5] that all problems expressible in MS1-logic are .xed parameter tractable when parameterized by the 
clique­width of a graph. For many other problems, that are not expressible in this logic, like Max-Cut, 
Edge Dominating Set, Graph Coloring, or Hamilto­nian Cycle, there is a signi.cant amount of the literature 
devoted to algorithms for these problems and their generalizations on graphs of bounded clique­width 
[9, 14, 15, 16, 21, 22, 23, 27, 28, 29]. The run­ning time of all these algorithms on an n-vertex graph 
of clique-width at most t is O(nf(t)), where f is some function of t. One of the central questions in 
the area is whether the bound of O(nf(t)) on the running time of all these algorithms is asymptotically 
optimal. Even the ex­istence of .xed parameter tractable algorithms (with clique-width being the parameter) 
for all these prob­ *Partially supported by the Norwegian Research Council  lems (or their generalizations) 
was open until very re­cently [14, 21, 22, 23, 16]. As the .rst step toward obtaining lower bounds for 
clique-width parameteriza­tions, we have shown in [12] that unless FPT W[1], = there is no algorithm 
with run time O(g(t) · nc), for some function g and a constant c not depending on t, for Graph Coloring, 
Edge Dominating Set and Hamiltonian Path. Even though our results in [12] resolve the param­eterized 
complexity of these problems, the conclusion that unless FPT = W[1], there is no algorithm with run time 
O(g(t) · nc), for some function g and a constant c not depending on t, is weak to compare the known algo­rithmic 
upper bounds. In this paper, we provide asymp­totically tight optimal lower bounds for Max-Cut and Edge 
Dominating Set. In particular, we show that unless ETH fails, there is no f(t)no(t)-time algorithm for 
these problems, where f is an arbitrary function of k, on input of size n and clique-width at most k. 
While O(t2) known algorithms for these problems run in times n[21, 22, 9, 29], we give new algorithmic 
upper bounds of the form nO(t). These two results together, lower and upper bounds, give asymptotically 
tight algorithmic bounds for Max-Cut and Edge Dominating Set. To obtain our lower bounds we construct 
linear FPT-reductions . These type of reductions are much more stringent and delicate than the usual 
FPT re­ductions. This is the reason why this research di­rection is still in a nascent stage and not 
so many asymptotically tight results are known in the litera­ture. Chen et al. [2, 3] initiated this 
area of strong computational lower bounds and showed that there is no algorithm for k-Clique (.nding 
a clique of size k) running in time f(k)no(k) unless there exists an algo­rithm for solving 3-SAT running 
in time 2o(n) on a for­mula with n-variables. The assumption that there does not exists an algorithm 
for solving 3-SAT running in time 2o(n) is known as Exponential Time Hypoth­esis (ETH) [20] and it is 
equivalent to the parame­terized complexity conjecture that FPT =M[1] [7, 11]. The lower bound on k-Clique 
can be extended to some other parameterized problems via a linear FPT­reductions [2, 3]. This kind of 
investigation has also been useful in obtaining tight algorithmic lower bounds for polynomial time approximation 
schemes [25] and for constraint satisfaction problems when parameterized by the tree-width of the primal 
graph [24]. We further extend the utility of this approach by obtaining asymp­totically tight algorithmic 
bounds for clique-width pa­rameterizations. 2 De.nitions and Preliminary results Parameterized Complexity: 
Parameterized com­plexity is a two dimensional framework for studying the computational complexity of 
a problem. One dimen­sion is the input size n and another one is a parameter k. We refer to the books 
of Downey and Fellows [8] and Flum and Grohe [11] for a detailed treatment to parameterized complexity. 
Now we de.ne the notion of parameterized (linear) reduction which is the main tool for establishing of 
our results. Definition 1. Let A, B be parameterized problems. We say that A is (uniformly many:1) FPT-reducible 
to B if there exist functions f, g : N . N, a constant a . N and an algorithm F which transforms an instance 
(x, k) l of A into an instance (x,g(k)) of B in time f(k)|x|a l so that (x, k) . A if and only if (x,g(k)) 
. B. The reduction is called linear if g(k)= O(k). Graphs: We only consider .nite undirected graphs without 
loops or multiple edges. The vertex set of a graph G is denoted by V (G) and its edge set by E(G). A 
set S . V (G) of pairwise adjacent vertices is called a clique. For v . V (G), by EG(v) we mean the set 
of edges incident to v. For a vertex v, we denote by NG(v) its (open) neighborhood, that is, the set 
of vertices which are adjacent to v. The closed neighborhood of v, that is, the set NG(v) .{v}, is denoted 
by NG[v]. The degree of a vertex v is denoted by dG(v). For a graph G, the incidence graph of G is the 
bipartite graph I(G) with the vertex set V (G) . E(G) such that v . V (G) and e . E(G) are adjacent if 
and only if v is incident to e in G. Tree-width: A tree decomposition of a graph G is a pair (X, T ) 
where T is a tree whose vertices we will call nodes and X =({Xi | i . V (T )}) is a collection of subsets 
of V (G) such that 1. Xi = V (G), i.V (T ) 2. for each edge vw . E(G), there is an i . V (T ) such that 
v, w . Xi, and 3. for each v . V (G) the set of nodes {i | v . Xi}forms a subtree of T .  The width 
of a tree decomposition ({Xi | i . V (T )},T ) equals maxi.V (T ){|Xi|- 1}. The tree-width of a graph 
G is the minimum width over all tree decompositions of G. We use notation tw(G) to denote the tree-width 
of a graph G. Clique-width: Let G be a graph, and t be a positive integer. A t-graph is a graph whose 
vertices are labeled by integers from {1, 2,...,t}. We call the t-graph consisting of exactly one vertex 
labeled by some integer from {1, 2,...,t} an initial t-graph. The clique-width cwd(G) is the smallest 
integer t such that G can be constructed by means of repeated application of the following four operations: 
(1) introduce: construction of an initial t-graph labeled by i (denoted by i(v)), (2) disjoint union 
(denoted by .), (3) relabel: changing all labels i to j (denoted by .i.j) and (4) join: connecting all 
vertices labeled by i with all vertices labeled by j by edges (denoted by .i,j).  An expression tree 
of a graph G is a rooted tree T of the following form: The nodes of T are of four types i, ., . and 
..  Introduce nodes i(v) are leaves of T , corresponding to initial t-graphs with vertices v, which 
are labeled i.  A union node . stands for a disjoint union of graphs associated with its children. 
 A relabel node .i.j has one child and is associated with the t-graph, which is the result of relabeling 
operation for the graph corresponding to the child.  A join node .i,j has one child and is associated 
with the t-graph, which is the result of join operation for the graph corresponding to the child.  The 
graph G is isomorphic to the graph associated with the root of T (with all labels removed).  The width 
of the tree T is the number of di.erent labels appearing in T . If a graph G has cwd(G) = t then it is 
possible to construct a rooted expression tree T with width t of G. Given a node X of an expression tree, 
the graph GX represents the graph formed by the subtree of the expression tree rooted at X. A well-known 
fact is that if the tree-width of a graph is bounded then its clique-width also is bounded. On the other 
hand, complete graphs have clique-width 2 and unbounded tree-width. But for sparse graphs the tree-width 
and clique-width are linearly related. Particularly, Gurski and Wanke [17] proved that if a graph G has 
no subgraph isomorphic to Kr,r, then tw(G) = 3(r - 1)cwd(G) - 1. Linear upper bounds of the clique-width 
by the tree-width for sparse graphs were established by Fomin et al. [13]. We use the following proposition. 
Proposition 2.1. ([13]) If G is a planar graph, then cwd(G) = 12(tw(G) + 1). Moreover, the proof is constructive 
and an expres­sion tree for G of width at most 12(tw(G)+1) can be constructed in FPT time (with tree-width 
being the pa­rameter) from the tree decomposition of a planar graph G. Capacitated Domination Preliminary 
Results. A capacitated graph is a pair (G, c), where G is a graph and c: V (G) . N is a capacity function 
such that 1 = c(v) = dG(v) for every vertex v . V (G) (sometimes we simply say that G is a capacitated 
graph if the capacity function is clear from the context). A set S . V (G) is called a capacitated dominating 
set if there is a domination mapping f : V (G) \ S . S which maps every vertex in V (G)\S to one of its 
neighbors such that the total number of vertices mapped by f to any vertex v . S does not exceed its 
capacity c(v). We say that for a vertex u . S, vertices in the set f-1(u) are dominated by u. In the 
Capacitated Dominating Set (or CDS) problem, we are given a capacitated graph (G, c) and a positive integer 
k as an input and the question is whether there exists a capacitated dominating set S for G containing 
at most k vertices. We also consider a special variant of CDS problem which we call Exact Saturated Capacitated 
Dom­inating Set (or Exact Saturated CDS). Given a capacitated dominating set S, a vertex v . S is called 
saturated if the corresponding domination mapping f maps c(v) vertices to v, that is, |f-1(v)| = c(v). 
Aca­pacitated dominating set S . V (G) is called saturated if there is a domination mapping f which saturates 
all vertices of S. In the Exact Saturated Capacitated Dominating Set problem, a capacitated graph (G, 
c) and a positive integer k are given as an input and the question is whether G has a saturated capacitated 
dom­inating set S with exactly k vertices. A red-blue capacitated graph is a pair (G, c), where G is 
a bipartite graph with the vertex bipartition R and B and c: R . N is a capacity function such that 1 
= c(v) = dG(v) for every vertex v . R. The vertices of the set R are called red and the vertices of B 
are called blue. A set S . R is called a capacitated dominating set if there is a domination mapping 
f : B . S which maps every vertex in B to one of its neighbors such that the total number of vertices 
mapped by f to any vertex v . S does not exceed its capacity c(v). The Red-Blue Capacitated Dominating 
Set (or Red-Blue CDS) problem for a given red-blue capacitated graph (G, c) and a positive integer k, 
asks whether there exists a capacitated dominating set S for G containing at most k vertices. A capacitated 
dominating set S . R is called saturated if there is a domination mapping f which saturates all vertices 
of S, that is, |f-1(v)| = c(v) for each v . S. The Red-Blue Exact Saturated Dominating Set problem (Red-Blue 
Exact Saturated CDS) takes a red-blue capacitated graph (G, c) and a positive integer k as an input and 
asks whether there exists a saturated capacitated dominating set with exactly k vertices.  If the input 
graph G is restricted to be planar we call these problems Planar CDS, Exact Saturated Planar CDS, Red-Blue 
Planar CDS and Red-Blue Exact Saturated Planar CDS respectively. The following proposition can be deduced 
from the constructions presented in [1]. Proposition 2.2. Planar CDS, Exact Saturated Planar CDS, Red-Blue 
Planar CDS and Red-Blue Exact Saturated Planar CDS can not be solved in time f(t)no(t), where n is the 
number of vertices and t is the tree-width of the input graph, unless ETH fails. The basic schema of 
all the proofs to come is following. The reduction in Proposition 2.2 is from k-Clique to the above mentioned 
problems and the graphs obtained after the reduction are essentially k × k2 grid. This immediately implies 
that the tree-width t of these instances is O(k). Now using the result of Chen et al. [2, 3] about k-Clique, 
we conclude that Planar CDS, Exact Saturated Planar CDS, Red-Blue Planar CDS and Red-Blue Exact Saturated 
Planar CDS can not be solved in time f(t)no(t), where t is the tree-width of the input graph, unless 
ETH fails. Now from Proposition 2.1 we know that the tree-width and the clique-width are linearly related 
in planar graph. This allows us to conclude that Planar CDS, Exact Saturated Planar CDS, Red-Blue Planar 
CDS and Red-Blue Exact Saturated Planar CDS can not be solved in time f(t)no(t), where t is the clique-width 
of the input graph, unless ETH fails. This result is the starting point for our reductions to obtain 
the desired algorithmic lower bounds for Max-Cut and Edge Dominating Set when parameterized by the clique-width. 
Furthermore, our reductions are constrained to not blow up the clique-width in the resulting instances. 
That is, the clique-width of the input instance and the clique-width of the instance obtained after the 
reduction must be linearly related. 3 Max-Cut and related problems In this section we consider the Max-Cut 
problem and a few other problems that are closely related to it. A cut set of a graph G is the set of 
edges C . E(G) such that the graph Gl with the vertex set V (G) and the edge set C is a bipartite graph. 
The size of a maximum cut set in G is denoted by mcut(G). For a partition V1,V2 of V (G), the cut set 
is de.ned as CG(V1,V2)= {uv . E(G): u . V1,v . V2}. It is well known that there is one to one correspondence 
between cut sets and partitions of the vertex set. In the Max-Cut problem, we are given a graph G and 
a positive integer k, and the objective is to check whether there exists a cut set C . E(G) such that 
|C|= k. Our main theorem in this section is following. Theorem 3.1. The Max-Cut problem can not be solved 
in time f(t)no(t) unless ETH fails, where n is the number of vertices and t is the clique-width of the 
input graph. Moreover, the Max-Cut problem can be solved in time nO(t) if an expression tree of width 
t is given. We prove this theorem in two parts. We .rst show the lower bound and then complement this 
result with the corresponding upper bound. 3.1 Lower Bounds. To prove our result we give a reduction 
from the Red-Blue Planar CDS problem to the Max-Cut problem. The proof is organized as follows: we .rst 
give a construction, then prove its correctness and .nally argue on the clique-width of the transformed 
instance. Construction: Let (G, c) be an instance of Red-Blue Planar CDS with R = {u1,...,un} being the 
set of red vertices and B = {v1,...,vr} being the set of blue vertices. We also assume that G has m edges 
and k is a positive integer. Now we describe the auxiliary gadgets. Auxiliary gadgets F (x, y) and F 
l(x, y): Let x, y be two vertices. We construct F (x, y) by joining x and y by 4m + 1 paths of length 
two. The graph F l(x, y) is constructed by joining x and y by 4m+1 paths of length three. The properties 
of F (x, y) and F l(x, y) which is required for our proof is summarized in the following simple lemma. 
Lemma 3.1. For a pair of vertices x and y, mcut(F (x, y)) = 8m +2, mcut(F l(x, y)) = 12m +3. For any 
partition V1,V2 of the set of vertices in the gadget F (x, y) such that x . V1 and y . V2, |CF (x,y)(V1,V2)|= 
mcut(F (x, y)) - 4m - 1, and for any partition V1,V2 of the set of ver­tices in the gadget F l(x, y) 
such that x, y . V1, |CF'(x,y)(V1,V2)|= mcut(F l(x, y)) - 4m - 1. We are going to attach gadgets F (x, 
y) and F l(x, y) to other part of our construction through the vertices x and y. Notice that we can always 
assume that the vertices of V (F (x, y))\{x, y} are included in exactly one side of an optimal partition 
of the vertex set leading to the maximum sized cut. Similarly, we can assume that the vertices of NF 
'(x,y)(x)(NF '(x,y)(y) respectively) also included in exactly one side of an optimal partition of the 
vertex set. Auxiliary gadgets Hs,t(x1,...,xs,y): Let l = max{n, r}. We .rst construct a graph H  x1 
xs y Figure 1: Graph Hs,t(x1,...,xs,y) with the vertex set {zi,j :1 = i = 2l, 1 = j = 4m +1}. Any vertices 
zi,j and zi',j' are joined by an edge for 1 = i<il = 2l. That is, we get a complete 2l partite graph 
with the 2l-partition Z1,...,Z2l, where Zi = {zi,1,...,zi,4m+1}. Then we add graphs F (zi,1,zi,2),...,F 
(zi,4m,zi,4m+1) for each i .{1,..., 2l}. Let h = l(4m + 1)(4ml + 16m + l). One can easily see that a 
partition V1,V2 corre­sponding to mcut(H) is following. Let V1 con­sist of Z1,...,Zl and all the vertices 
of gadgets F (zi,1,zi,2),...,F (zi,4m,zi,4m+1), i .{l +1,..., 2l}, except those vertices of these gadgets 
which are con­tained in Zl+1,...,Z2l and let V2 be the remaining vertices. Using this partition V1,V2 
corresponding to mcut(H) and Lemma 3.1, we get the following. Lemma 3.2. For any partition V1,V2 of the 
set of ver­tices of H such that if V1 (or V2) does not contain exactly l sets from Z1,...,Z2l, then |CH 
(V1,V2)|= mcut(H) - 4m - 1. Furthermore, mcut(H)= h. Let s and t be two positive integers such that s, 
t = l. We construct the graph Hs,t(x1,...,xs,y) from H by adding vertices x1,...,xs and y, and then joining 
them with H by the fol­lowing gadgets, F (x1,z1,1),...,F (xs,zs,1) and F (y, zl+1,1),...,F (y, zl+t,1) 
(see Fig 1). Let hs,t = h + (8m + 2)(s + t). Lemmata 3.1 and 3.2 imply the following properties of this 
graph. Lemma 3.3. The following properties holds for the graph Hs,t(x1,...,xs,y). The mcut(Hs,t(x1,...,xs,y)) 
= hs,t. Let V1, V2 be an optimal parti­ tion of V (Hs,t(x1, . . . , xs, y)), that is, mcut(Hs,t(x1, . 
. . , xs, y)) = |CHs,t(x1,...,xs,y)(V1,V2)|, and y . V1. Then at most l - t vertices among x1,...,xs 
are included in V1. Furthermore, there is an optimal partition V1,V2 such that y . V1 and for any 0 
= p = l - t, exactly p vertices among x1,...,xs are included in V1.  Moreover, for any non optimal partition 
V1,V2 of V (Hs,t(x1,...,xs,y)) such that (a) for any gadget F (zi,j ,zi,j+1), 1 = i = 2l and 1 = j = 
4m, we have that V (F (zi,j,zi,j+1)) \{zi,j,zi,j+1} is either contained in V1 or V2; (b) for any gadget 
F (xi,zi,1), 1 = i = s and F (y, zl+j,1)1 = j = t, we have that V (F (xi,zi,1)) \{xi,zi,1}and V (F (y, 
zl+j,1)) \{y, zl+j,1} is either contained in V1 and V2; then |CHs,t(x1,...,xs,y)(V1,V2)|= mcut(Hs,t(x1,...,xs,y)) 
- 4m - 1.  Final Reduction: Now we describe our reduction. Each edge e = uivj of G is replaced by two 
vertices ae and be and joined by edges to ui and vj . We create two vertices w1 and w2 and construct 
a copy of F l(w1,w2). For each vertex vj . B, a copy of F (vj,w1) is created. In the next step, we introduce 
a copy of Hn,l-k(u1,...,un,w1). By Gl we denote the graph obtained until now. Finally, for each vertex 
ui . R, a copy of HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2), where {e1,...,edG(ui)} = EG(ui) is con­structed, 
and for each vertex vj . B,a copy of HdG(vj),l-1(ae1 ,...,aedG(vj ) ,w2), where {e1,...,edG(vj)} = EG(vj 
) is added. Let the resulting graph be Q. Let µ = (4m + 1)(2r + 3) + hn,l-k + g g nr i=1 hdG(ui),l-c(ui) 
+ j=1 hdG(vj ),l-1 + 2(m + r). Lemma 3.4. The graph G has a capacitated dominating set of the size at 
most k if and only if Q has a cut set with at least µ edges. Proof. Let S be a capacitated dominating 
set of the size at most k in G and f be a corresponding domination mapping. We construct a partition 
V1,V2 of the ver­tex set of Q which corresponds to the cut set of size at least µ as follows. The vertex 
w1 is included in V1, the vertex w2 is included in V2, all vertices v1,...,vr are included in V1, all 
the vertices in S are included in V1 and vertices in R \ S are included in V2. We also include all the 
vertices be in V2. For each edge e = uivj . E(G) such that f(vj)= ui, that is, e is being used for domination, 
the corresponding vertex ae is in­cluded in V2 and all other vertices ae, whose correspond­ing edge is 
not used for domination are included in V1. Finally, we extend our partition to an optimal partition 
of all gadgets F (x, y), F l(x, y) and Hs,t(x1,...,xs,y) used in the construction of Q. The desired extensions 
of these gadgets to an optimal partition can be done by applications of Lemmata 3.1, 3.2 and 3.3. By 
con­struction of our partitions V1 and V2, the contribution of the gadgets F (x, y), F l(x, y) and Hs,t(x1,...,xs,y) 
to the cut CQ(V1,V2) is mcut(F (x, y)), mcut(F l(x, y)) and mcut(Hs,t(x1,...,xs,y)) respectively. Hence, 
we have already accounted for (4m + 1)(2r + 3) + hn,l-k +  g g nr i=1 hdG(ui),l-c(ui) + j=1 hdG(vj ),l-1 
edges in the cut CQ(V1,V2). The remaining 2(m + r) edges in the cut CQ(V1,V2) come from the edges incident 
on the vertices ae and be for some e. Look at an edge e, then we have two cases, either it is an edge 
used for domination or not. In the .rst case when e = uv is used for dominat­ing then uae, aev, ube and 
bev are part of the cut. In the second case, for an edge when e = uv exactly two of the edges among uae, 
aev, ube and bev are part of the cut. In any case for every e at least two edges among uae, aev, ube 
and bev are part of the cut and hence edges incident to the vertices ae and be contribute at least 2(m 
- r)+4r = 2(m + r) to the cut CQ(V1,V2). This completes the forward direction of the proof. Assume now 
that Q has a cut set C of size at least µ, and V1,V2 be the corresponding partition of the vertex set 
of Q. Let Ql be the graph obtained by the union of the edge sets of auxiliary gadgets F (x, y), F l(x, 
y) and Hs,t(x1,...,xs,y). Then there exists a partition A and B of V (Ql) such that CQ' (A, B)= µl, where 
g n µl = (4m + 1)(2r + 3) + hn,l-k + i=1 hdG(ui),l-c(ui) + g r hdG(vj),l-1. Suppose that at least for 
one of our j=1 auxiliary gadgets F (x, y), F l(x, y) or Hs,t(x1,...,xs,y), say F (x, y), the partition 
V l and V l of V (F (x, y)) 12 obtained by restricting the partition V1 and V2 to V (F (x, y)) is not 
optimal. That is, |CF (x,y)(V1 l,V l)| < 2 mcut(F (x, y)). Then because of Lemmata 3.1, 3.2 and 3.3, 
|C|= µl - (4m + 1) + 4m<µ. By choosing a non-optimal partition of auxiliary gadgets we at least loose 
4m + 1 edges while we can only gain 4m new edges by cutting 4m edges of Q which do not belong to these 
gadgets. This implies that C restricted to all these gadgets is an optimal cut in Ql . By Lemma 3.1, 
w1 and w2 belong to di.erent sets of the bipartition V1,V2. Assume that w1 . V1 and w2 . V2. Then Lemma 
3.1 implies that v1,...,vr . V1. Thus, using Lemma 3.3 we conclude that at most k vertices of the set 
R = {u1,...,un} belong to V1. We set S = R n V1 and prove that S is a capacitated dominating set in G. 
Notice that by Lemma 3.3, at most one vertex ae in the neighborhood of each vertex vj is included in 
V2. Suppose that there is a vertex vj such that it s neighborhood in Q has no vertices ae . V2. Then 
|C|= µl +2m + 2(r - 1) <µ, a contradiction. So, for each vertex vj , there is an edge e = uivj such that 
ae . V2. Now we argue that ui . S. This follows from the fact that if ui ./S then ui . V2 and hence |C|= 
µl +2m +2r - 2 <µ. We de.ne the domination mapping f(vj)= ui. Since by Lemma 3.3, at most c(ui) vertices 
in the set NQ(ui)n{ae | e . E(G)} are included in V2, |f-1(ui)|= c(ui). This concludes the proof. Now 
we upper bound the clique-width of Q by a linear function of the tree-width of G. Lemma 3.5. Let t = 
2. If tw(G) = t then cwd(Q) = 96t + 106. Proof. Since t = 2, tw(I(G)) = tw(G), and by Proposition 2.1 
we have that cwd(I(G)) = c = 12t+12. We construct an expression tree for Q in two stages and use 8c + 
10 labels. At the .rst stage we construct en expression tree for Gl using 4c + 10 labels, and at the 
second stage we describe how it can modi.ed to get an expression tree for Q using 4c additional labels. 
Construction of an expression tree for Gl: Sup­pose that the expression tree for I(G) uses c labels {a1,...,ac}. 
To construct the expression tree for Gl we use the following additional labels. Labels ß1,...,ßc for 
the vertices v1,...,vr.  Labels .1,...,.c for the vertices {ae | e . E(G)}.  Labels d1,...,dc for the 
vertices {be | e . E(G)}.  Labels .1,.2 for the vertices w1,w2.  Label . for the vertices zi,j in Hn,l-k(u1,...,un,w1). 
 Working labels .1,.2,.3 and .1,.2,.3,.4.  We construct the required expression tree for Gl by going 
over the expression tree for I(G) and making necessary changes in it. When a vertex ui . R labeled by 
ap is introduced, we perform following set of operations. We .rst introduce the vertex ui labeled ap 
and a vertex (which is essentially zi,1) labeled by .3. Then 4m + 1 vertices labeled with .2 are introduced 
and joined with vertices labeled ap and .3. Then the vertices labeled .2 are relabeled .1. Now we repeat 
the following operations 4m times: (a) introduce a vertex labeled .1 and 4m + 1 vertices labeled .2; 
(b) join vertices labeled .2 with vertices labeled .1 and .3; (c) relabel vertices labeled .2 by .1, 
the vertex labeled .3 by ., and the vertex labeled .1 by .3; (d) .nally, the vertex labeled .3 is relabeled 
.. We omit the union operations from our descriptions here and henceforth in any similar descriptions 
and assume that if some vertex is introduced then union is always performed. When a vertex x . V (I(G)) 
which corresponds to an edge e . E(G) labeled ap is introduced, we introduce the vertices ae and be and 
label it with .p and dp, respectively. Now we move toward introduction of vertices from the set B. When 
a vertex vj . B labeled ap is introduced, we introduce the vertex vj with label ßp. Then 4m + 1 vertices 
labeled .1 are introduced, joined with the vertex labeled ßp and relabeled .2. We are labeling these 
vertices with .2 to .nally join them with the vertex w1, when it gets introduced.  For each union operation 
in the expression tree for I(G), we do as follows. If both graphs contain vertices labeled ., then (a) 
vertices labeled . in one of the graphs are relabeled .1; (b) we perform the union operation; (c) the 
vertices labeled . and .1 are joined; and (d) the vertices labeled .1 are relabeled .. If only one graph 
contains vertices labeled . then we just do the union operation. If in the expression tree of I(G), 
we have join operation between two labels say ap and aq then we simulate this by applying join operations 
between following: (i) ap and .q; (ii) ap and dq; (iii) ßp and .q; (iv) ßp and dq; (v) aq and .p; (vi) 
aq and dp; (vii) ßq and .p; and (viii) ßq and dp.  Finally, the relabel operation in the expression 
tree of G, that is, relabel ap to aq is replaced by following relabeling process: (a) ap to aq; (b) ßp 
to ßq; (c) .p to .q; and (d) dp to dq. After we have completed the scanning of the expres­sion tree for 
I(G), the vertices w1 and w2 labeled by .1 and .2 respectively, are introduced. Then we repeat the following 
operations 4m + 1 times: (a) introduce two vertices labeled .1 and .2; (b) join vertices labeled .1 and 
.1, .1 and .2, .2 and .2; (c) and relabel vertices la­beled .1 and .2 by .1. After that the vertex w1 
labeled .1 is joined with vertices labeled .2. Now we show how to complete the construction of Hn,l-k(u1,...,un,w1). 
We start of by repeating the following l - n + k times. A vertex labeled .3 is introduced. Now we repeat 
the following operations 4m times: (a) introduce a vertex labeled .1 and 4m +1 vertices labeled .2; (b) 
join vertices labeled .2 and vertices labeled with .1 and .3; (c) relabel vertices labeled .2 by .1, 
the vertex labeled .3 by .4, and the vertex labeled .1 by .3. Finally, the vertex labeled .3 is relabeled 
.4, the vertices labeled .4 are joined with vertices labeled . and then relabeled by .. Now, we do the 
following l - k times. A vertex labeled .3 and 4m+1 vertices labeled .1 are introduced. The vertices 
labeled .1 are joined with vertices labeled .1 and .2, and relabeled .1. After this we repeat the following 
operations 4m times: (a) introduce a vertex labeled .1 and 4m+1 vertices labeled .2; (b) join vertices 
labeled .2 and vertices labeled .1 and .3; (c) relabel vertices labeled .2 by .1, the vertex labeled 
.3 by .4, and the vertex labeled .1 by .3. Finally, the vertex labeled .3 is relabeled .4, the vertices 
labeled .4 are joined with vertices labeled . and then relabeled .. Construction of an expression tree 
for Q: We now show how to modify the expression tree for Gl to add gadgets HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) 
,w2) where {e1,...,edG(ui)} = EG(ui) for ui . R using 2c additional labels. The gad­gets HdG(vj ),l-1(ae1 
,...,aedG(vj ) ,w2) where {e1,...,edG(vj)} = EG(vj ) for vertices vj . B can be added in the same way 
by using additional 2c labels. To add gadgets HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2) where {e1,...,edG(ui)} 
= EG(ui) for ui . R, we use following additional labels al 1,...,al and ß1l ,...,ßl . cc We scan the 
expression tree for Gl and iteratively change it for each ui, i .{1,...,n} to add the corresponding gadgets. 
Let EG(ui)= {e1,...,edG(ui)}. Let A denote the set of vertices {ae1 ,...,aedG(ui) } and let U = A . {ui}. 
Let X be a node of the expression tree for Gl and Gl be the subgraph of Gl corresponding to this node. 
X If V (Gl ) n U = Ø but Gl[U] is not a subgraph of Gl XX then we can observe the following: If ui . 
V [Gl ] then ui is labeled by a label which X is di.erent from labels of other vertices of Gl X . If 
ui ./V [Gl ] then vertices of U n V (Gl ) are XX labeled by labels which are di.erent from labels of 
other vertices of Gl X . We use these observations to construct the graph HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) 
,w2) in such a way that all vertices zi,j of this gadget constructed for the node X are labeled by same 
labels, if ui . V [Gl ] and this X vertex is labeled by .p then we label it by al , and if pui ./V [Gl 
] and the labels .p1 ,...,.ph are used for ver- X tices U n V (Gl ) then all vertices zi,j are labeled 
by X one of the labels .l ,...,.l . The construction of the p1 ph gadget HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) 
,w2) is completed when after some union operation all vertices of U are in­cluded in the graph Gl We 
.nally relabel vertices of X . Gl by the label .1 which is not used for any join oper- X ation. When 
a vertex ui . R labeled by ap is introduced, we perform following set of operations. First, we introduce 
the vertex ui labeled by ap. Then we repeat the following operations l + c(ui) - dG(ui) times. A vertex 
labeled .3 is introduced and then the following operations are repeated 4m times: (a) introduce a vertex 
labeled .1 and 4m + 1 vertices labeled .2, (b) join vertices labeled .2 and vertices labeled .1 and .3, 
(c) relabel vertices labeled .2 by .1, the vertex labeled .3 by .4, and the vertex labeled .1 by .3. 
Finally, the vertex labeled .3 is relabeled .4, the vertices labeled .4 are joined with vertices labeled 
al (if they exist) and then p relabeled al . Next we perform the following l - c(ui) p times: (a) a vertex 
labeled .3 and 4m+1 vertices labeled .1 are introduced; (b) the vertices labeled .1 are joined with vertices 
labeled .2, and relabeled .3. Then we repeat the following operations 4m times: (i) introduce a vertex 
labeled .1 and 4m + 1 vertices labeled .2, (ii) join vertices labeled .2 and vertices labeled .1 and 
.3,  (iii) relabel vertices labeled .2 by .1, the vertex labeled .3 by .4, and the vertex labeled .1 
by .3. Finally, the vertex labeled .3 is relabeled .4, the vertices labeled .4 are joined with vertices 
labeled al and then relabeled p al . p When a vertex ae such that uiae . E(Q) labeled by .q is introduced, 
we perform following set of operations. First, we introduce the vertex ae labeled .q and a vertex labeled 
by .3. Then 4m + 1 vertices labeled .2 are introduced and joined with vertices labeled .p and .3. Then 
the vertices labeled .2 are relabeled .1. Now we repeat the following operations 4m times: (a) introduce 
a vertex labeled .1 and 4m + 1 vertices labeled .2, (b) join vertices labeled .2 and vertices labeled 
.1 and .3, (c) relabel vertices labeled .2 by .1, the vertex labeled .3 by .ql , and the vertex labeled 
.1 by .3. Finally, the vertex labeled .3 is relabeled .l . q Having dealt with introduction nodes, next 
we consider union operations. Let X be a union node of the expression tree for Gl . Denote by X and Y 
two children of this node and let Gl and Gl be subgraphs YZ of Gl which correspond to these nodes. If 
one of these graphs do not contain vertices of U then we just perform the same operation. Otherwise we 
have two cases. ui . V (Gl ) . V (Gl ). Suppose that ui . V (Gl ) YZ Y and is labeled ap. Then vertices 
zi,j of HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2) which are constructed for the node Y are labeled al p. 
The graph Gl includes vertices of A labeled by Z some labels .p1 ,...,.ph , and all vertices zi,j of 
HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2) corresponding to this node are labeled by same label .l . We pj 
do the union operation as before, then join the vertices labeled al p and .pl j , relabel the vertices 
labeled .l by al . If the graph Gl corresponding pj pX to X contains all vertices of U, then the vertices 
labeled al are relabeled .1. p ui ./V (Gl ) . V (Gl ). Then Gl includes vertices YZ Y of A that are labeled 
by .p1 ,...,.ph , and all vertices zi,j of HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2) corresponding to this 
node and are labeled by same label .l . Similarly, Gl includes vertices of A pi Z labeled by some labels 
.q1 ,...,.qf , and all the vertices zi,j of HdG(ui),l-c(ui)(ae1 ,...,aedG(ui) ,w2) corresponding to this 
node and are labeled by same label .l . We relabel vertices labeled .l by .2 in qj pi the .rst graph, 
then perform the union operation, join the vertices labeled .2 and .l , relabel the qj vertices labeled 
.2 by .l . qj The join operations in the expression tree for Gl are done in the new tree in exactly the 
same way. The relabel operation in the expression tree of Gl, that is, relabel ap to aq and relabel .p 
to .q, are replaced by relabel ap to aq, al to al , and .p to .q, .l to .l , pqpq respectively. When 
we have completed the scan of the expression tree for Gl , the only thing which remains is to join vertices 
labeled .3 and the vertex labeled .2 (the vertex w2). To conclude the .rst part of the proof of the Theorem 
3.1, we observe that the number of vertices of Q is polynomial in n + r, and therefore if we could solve 
the Max-Cut in time f(t)|V (Q)|o(t) where t = cwd(Q) then the Red-Blue Planar CDS could be ) solved in 
time f(t)|V (G)|o(t ' = f(t)|V (G)|o(t) where tl = tw(G)= O(cwd(Q)) = O(t). 3.2 Algorithmic upper bounds 
for Max-Cut. Now we outline an algorithm for solving Max-Cut in time nO(t) on graphs of clique-width 
at most t. The algorithm is based on dynamic programming over the expression tree of the input graph. 
We .rst describe what we store in the tables corresponding to the nodes in the expression tree. Let G 
be a graph with n vertices and m edges, and let T be an expression tree for G of width t. For a node 
X of T , denote by GX the t-graph associated with this node, and let U1(X),...,Ut(X) be the sets of vertices 
of GX labeled 1,...,t respectively. The table of data for the node X stores vectors (s1,...,st,r) of 
integers such that 0 = si =|Ui(X)| for 1 = i = t, and 0 = r =|E(GX )|, for which there is a partition 
V1,V2 of V (GX ) such that |V1 n Ui(GX )| = si and |CGX (V1,V2)|= r. Notice that this table contains 
at most (n+1)t ·m vectors. If X is the root node of T (that is, G = GX ) then mcut(G) is equal to the 
maximum value of r for which the table for X contains an entry with this value. Now we give the details 
of how we make our tables and how do we update it. Introduce Node: Tables for introduce nodes of T are 
constructed in a straightforward manner. Relabel Node: Suppose that X is a relabel node .i.j, and let 
Y be the child of X. Then the table for X contains a vector (s1,...,st,r) if and only if si =0 ll and 
the table for Y contains the entry (s1,...,s,r) t l such that s= sp for 1 = p = t, t = i, j, and p ll 
sj = s+ sj. i  Union Node: Let X be a union node with children Y and Z. In this case the table for X 
contains a vector (s1,...,st,r) if and only if the tables for Y and l l ll llll) Z have vectors (s1,...,s,rl) 
and (s1 ,...,s,r tt l ll respectively, such that s+ s= si for 1 = i = t, ii ll = r. and rl + r Join Node: 
Finally, suppose that X is a join node .i,j with the child Y . It can be noted that the table for X has 
a vector (s1,...,st,r) if and only if the table for Y includes a vector (s1,...,st,rl) such that rl + 
si(|Uj (Y )|- sj)+ sj(|Ui(Y )|- si) = r. Correctness of the algorithm follows from the de­ scription 
of the procedure, and its runs in time O(tO(1) n2t+O(1)). This proves that Max-Cut can be solved in time 
nO(t) on graphs of clique-width at most t. 3.3 Bipartization by Edge Removal and Maxi­mum (Minimum) Bisection. 
Theorem 3.1 have sev­eral interesting corollaries for similar problems like Bipartization by Edge Removal 
and Maximum (Minimum) Bisection. In the Bipartization by Edge Removal prob­lem, we are given a graph 
G and a positive integer k, and the question is whether there is a set of edges X such that |X|= k and 
the graph Gl with the vertex set V (G) and the edge set E(G) \ X) is bipartite. Since this problem is 
dual to the Maximum Cut problem, we immediately have the following corollary. Corollary 3.1. The Bipartization 
by Edge Re­moval problem can not be solved in time f(t)no(t) un­less ETH fails, where n is the number 
of vertices and t is the clique-width of the input graph. Moreover, the Bi­partization by Edge Removal 
problem can be solved in time nO(t) if an expression tree of width t is given. In the Maximum (Minimum) 
Bisection problem, we are given a graph G with an even number of vertices and a positive integer k, and 
the objective is to check whether there is a partition of V (G) into two sets V1 and V2 of equal size 
such that |CG(V1,V2)|= k (|CG(V1,V2)|= k). Corollary 3.2. The Maximum (Minimum) Bisec­tion problem can 
not be solved in time f(t)no(t) unless ETH fails, where n is the number of vertices and t is the clique-width 
of the input graph. Moreover, the Maxi­mum (Minimum) Bisection problem can be solved in time nO(t) if 
an expression tree of width t is given. Proof. The algorithmic upper bound for the Maximum Bisection 
follows from the observation that the algo­rithm for the Max-Cut described in 3.2 can be modi­.ed for 
this problem. The lower bound can be obtained from the fact that the Max-Cut problem for a graph G can 
be reduced to the Maximum Bisection by adding |V (G| isolated vertices. The claim about the Minimum Bisection 
follows from the observation that the Max­imum Bisection problem for a graph G can be reduced to the 
Minimum Bisection problem in the complement G, and the fact that cwd(G) = 2cwd(G) (see [29, 6]). 4 Edge 
Dominating Set In this section, we consider the Edge Dominating Set problem. In the Edge Dominating Set 
problem, we are given a graph G and a positive integer k, and the objective is to determine whether there 
is a set of edges X . E(G) such that |X|= k and every edge of G is either included in X, or it is adjacent 
to at least one edge of X (which dominates it). The set X is called an edge dominating set of G. We prove 
the following result for Edge Dominating Set. Theorem 4.1. The Edge Dominating Set problem can not be 
solved in time f(t)no(t) unless ETH fails, where n is the number of vertices and t is the clique­width 
of the input graph. Moreover, the Edge Domi­nating Set problem can be solved in time nO(t) if an expression 
tree of width t is given. The proof of Theorem 4.1 is omitted here and will appear in the journal version 
of pur paper. 5 Conclusion and Further Directions In this paper, we obtained the .rst asymptotically 
tight bounds for problems parameterized by the clique-width of the input graph. In particular, we showed 
that Max-Cut and Edge Dominating Set cannot be solved in time f(t)no(t), unless ETH collapses; while 
there do exist algorithms with running time nO(t) for both these problems, where t is the clique-width 
of the input graph. We believe that our results opens a new direction in the algorithmic study around 
clique-width. Our reduction to obtain a tight lower bound for Max-Cut is also an FPT-reduction, thus 
resolving an open problem about the parameterized complexity of Max-Cut. We conclude with an open problem 
related to Hamiltonian Cycle. In the Hamiltonian Cycle problem, we are given a graph G and the objective 
is to check whether there exists a cycle passing through every vertex of G. Similar to Max-Cut and Edge 
Dominat­ing Set we can obtain the following algorithmic lower bound for the Hamiltonian Cycle problem 
when pa­rameterized by the clique-width of the input graph. Theorem 5.1. The Hamiltonian Cycle problem 
can not be solved in time f(t)no(t), where n is the number of vertices and t is the clique-width of the 
input graph, unless ETH fails.  However, all the algorithms we know for Hamiltonian Cycle run in time 
nO(t2) if an expression tree of width t is given. We leave it open to .nd either an improved lower bound 
or an improved upper bound for the Hamiltonian Cycle problem. References <RefA>[1] H. Bodlaender, D. Lokshtanov, 
and E.Penninkx, Planar capacitated dominating set is W [1]-hard, in IWPEC 09, 2009. [2] J. Chen, X. Huang, 
I. A. Kanj, and G. Xia, On the computational hardness based on linear FPT­reductions, J. Comb. Optim., 
11 (2006), pp. 231 247. [3] , Strong computational lower bounds via param­eterized complexity, J. Comput. 
Syst. Sci., 72 (2006), pp. 1346 1367. [4] D. G. Corneil, M. Habib, J.-M. Lanlignel, B. A. Reed, and U. 
Rotics, Polynomial time recognition of clique-width = 3 graphs (extended abstract), in LATIN 00, vol. 
1776 of LNCS, Springer, 2000, pp. 126 134. [5] B. Courcelle, J. A. Makowsky, and U. Rotics, Linear time 
solvable optimization problems on graphs of bounded clique-width, Theory Comput. Syst., 33 (2000), pp. 
125 150. [6] B. Courcelle and S. Olariu, Upper bounds to the clique width of graphs, Discrete Appl. Math., 
101 (2000), pp. 77 114. [7] R. G. Downey, V. Estivill-Castro, M. R. Fel­lows, E. Prieto, and F. A. Rosamond, 
Cutting up is hard to do: the parameterized complexity of k-cut and related problems, Electr. Notes Theor. 
Comput. Sci., 78 (2003). [8] R. G. Downey and M. R. Fellows, Parameter­ized complexity, Monographs in 
Computer Science, Springer-Verlag, New York, 1999. [9] W. Espelage, F. Gurski, and E. Wanke, How to solve 
NP-hard graph problems on clique-width bounded graphs in polynomial time, in WG 01, vol. 2204 of LNCS, 
Springer, 2001, pp. 117 128. [10] M. R. Fellows, F. A. Rosamond, U. Rotics, and S. Szeider, Clique-width 
minimization is NP-hard (extended abstract), in STOC 06, ACM, 2006, pp. 354 362. [11] J. Flum and M. 
Grohe, Parameterized complexity theory, Texts in Theoretical Computer Science. An EATCS Series, Springer-Verlag, 
Berlin, 2006. [12] F. V. Fomin, P. A. Golovach, D. Lokshtanov, and S. Saurabh, Clique-width: on the price 
of gen­erality, in SODA, 2009, pp. 825 834. [13] F. V. Fomin, S.-il Oum, and D. M. Thilikos, Rank-width 
and tree-width of H-minor-free graphs, Manuscript, (2008). [14] M. U. Gerber and D. Kobler, Algorithms 
for vertex-partitioning problems on graphs with .xed clique-width, Theoret. Comput. Sci., 299 (2003), 
pp. 719 734. [15] O. Gim´y, and M. Noy, Computingenez, P. Hlinen´the tutte polynomial on graphs of bounded 
clique-width, SIAM J. Discret. Math., 20 (2006). [16] B. Godlin, T. Kotek, and J. A. Makowsky, Evaluations 
of graph polynomials, in WG, vol. 5344 of Lecture Notes in Computer Science, 2008, pp. 183 194. [17] 
F. Gurski and E. Wanke, The tree-width of clique­width bounded graphs without kn,n, in WG 00, LNCS, Springer, 
2000, pp. 196 205. [18] P. Hlineny´ and S. il Oum, Finding branch­decompositions and rank-decompositions, 
SIAM J. Comput., 38 (2008), pp. 1012 1032. [19] P. Hlinen´y, S.-il Oum, D. Seese, and G. Gottlob, Width 
parameters beyond tree-width and their applica­tions, Comput. J., 51 (2008), pp. 326 362. [20] R. Impagliazzo, 
R. Paturi, and F. Zane, Which problems have strongly exponential complexity?, J. Comput. Syst. Sci., 
63 (2001), pp. 512 530. [21] D. Kobler and U. Rotics, Polynomial algorithms for partitioning problems 
on graphs with .xed clique-width (extended abstract), in SODA 01, ACM-SIAM, 2001, pp. 468 476. [22] , 
Edge dominating set and colorings on graphs with .xed clique-width, Discrete Appl. Math., 126 (2003), 
pp. 197 221. [23] J. Makowsky, U. Rotics, I. Averbouch, and B. Godlin, Computing graph polynomials on 
graphs of bounded clique-width, in WG 06, LNCS, Springer, 2006, pp. 191 204. [24] D. Marx, Can you beat 
treewidth?, in FOCS, 2007, pp. 169 179. [25] , On the optimality of planar and geometric approximation 
schemes, in FOCS, 2007, pp. 338 348. [26] S.-il Oum and P. Seymour, Approximating clique­width and branch-width, 
J. Combin. Theory Ser. B, 96 (2006), pp. 514 528. [27] M. Rao, MSOL partitioning problems on graphs of 
bounded treewidth and clique-width, Theoret. Comput. Sci., 377 (2007), pp. 260 267. [28] K. Suchan and 
I. Todinca, On powers of graphs of bounded NLC-width (clique-width), Discrete Appl. Math., 155 (2007), 
pp. 1885 1893. [29] E. Wanke, k-NLC graphs and polynomial algorithms, Discrete Appl. Math., 54 (1994), 
pp. 251 266.</RefA>  
			

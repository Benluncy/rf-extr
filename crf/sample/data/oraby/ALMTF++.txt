
 ALMTF++: Um novo controle de congestionamento para transmissões multicast em larga escala Andrea Krob, 
Alberto S. Jr., João V. Portal, Jonas Hartmann, José V. de Lima, Valter Roesler UFRGS Universidade Federal 
do Rio Grande do Sul Av. Bento Gonçalves, 9500 Bloco IV -CEP 91501-970 - POA/RS Brasil {andrea.krob, 
ascjunior, jportal, jonas, valdeni, roesler} @inf.ufrgs.br ABSTRACT One of the obstacles for scaling 
the use of multicast over the Internet is the development of adequate congestion control protocols. The 
ALMTF (Adaptive Layered Multicast TCP-Friendly) protocol is part of the project SAM (Multimedia Adaptive 
System), and it was elaborated in a dissertation for achieving doctorate degree. It had its original 
evaluation in the network simulator NS-2. One advantage of this algorithm is to infer the level of network 
congestion, determining the best receiving rate for each receptor. Besides that, the protocol controls 
the received rate, aiming to achieve fairness and impartiality with the concurrent network traffic. The 
objective of this work is to extend the ALMTF protocol to a real network, proposing new alternatives 
for this environment adaptation, in such a way that it can be integrated in multicast applications such 
as distance education, internet conferences or IPTV. The results were validated in local and long distance 
networks and showed a new and more efficient algorithm, called ALMTF++.  Categorias e Descritores H.4.3 
[Communications Applications]: Computer - conferencing, teleconferencing, and videoconferencing.  Termos 
Gerais Algoritmo, Implementação, Desempenho.  Palavras-chave Controle de Congestionamento, Multimídia, 
Multicast. Permission to make digital or hard copies of all or part of this work for personal or classroom 
use is granted without fee provided that copies are not made or distributed for profit or commercial 
advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, 
or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or 
a fee. WebMedia 09, October 5 7, 2009, Fortaleza, CE, Brazil. Copyright 2009 ACM 978-1-60558-880-3/09/0010 
$10.00.  1. INTRODUÇÃO Um dos obstáculos para o uso disseminado do multicast na Internet global é o 
desenvolvimento de protocolos de controle de congestionamento adequados [2, 3, 4]. Pesquisas recentes 
apontam vários fatores relacionados a este problema, como por exemplo, a heterogeneidade de equipamentos, 
enlaces e condições de acesso dos receptores, que dificulta um acordo sobre a melhor taxa de transmissão 
a ser utilizada entre eles [3]. Satisfazer as demandas dos usuários mantendo a estabilidade na transmissão 
é outro fator que agrega dificuldade aos protocolos de controle de congestionamento multicast [5], visto 
que um comportamento oscilatório e instável é negativo para transmissões multimídia em geral. Além disso, 
é necessário realizar um controle sobre a transmissão, garantindo que o tráfego utilize uma parcela equitativa 
da banda, funcionando de maneira imparcial e amigável com os demais tráfegos concorrentes [3]. O fato 
do multicast geralmente ser utilizado em larga escala também aumenta a complexidade dos protocolos, pois 
torna a escalabilidade uma característica fundamental no seu desenvolvimento. Isto se justifica devido 
à comunicação existente entre os receptores e o transmissor poder gerar um problema conhecido como implosão 
de feedbacks, sendo essencial um mecanismo para controlar o fluxo por parte dos receptores [6]. Por esses 
motivos, a área de controle de congestionamento multicast tem sido um tópico de intensa pesquisa nos 
últimos anos [4, 5, 7], sendo indispensável para aplicações multimídia que desejam compartilhar amigavelmente 
os recursos da rede, mantendo a estabilidade da Internet. O protocolo ALMTF [1] faz parte do Projeto 
SAM (Sistema Adaptativo Multimídia) e foi desenvolvido para aplicações que necessitam realizar a transmissão 
de vídeo de forma adaptativa, como ensino a distancia, transmissão de shows, etc. Como pode ser visto 
na figura 1, o SAM consiste de uma ferramenta composta por um Transmissor (formado pelos blocos Codificador 
em camadas e Transmissão ) e um Receptor (formado pelo bloco Receptor e o bloco Decodificador em camadas 
 responsável por apresentar os dados ao usuário). A idéia central do sistema consiste na transmissão 
do sinal multimídia em multi-taxas, onde o fluxo multimídia é codificado em várias camadas e cada camada 
é transmitida como um grupo multicast diferente. O benefício obtido é a garantia de um acesso universal 
à transmissão multimídia, onde cada receptor se ajusta na melhor qualidade possível de acordo com as 
suas limitações. O ALMTF é o protocolo mais importante do SAM, sendo executado no lado do receptor. A 
adaptação dos usuários é realizada com base na detecção de perdas, equidade e estimativa de banda máxima. 
Conforme o nível de congestionamento e a banda disponível na rede, o ALMTF determina a quantidade de 
camadas que o receptor poderá suportar, buscando a justiça com os demais tráfegos concorrentes. Figura 
1. Arquitetura do sistema SAM. No SAM as camadas são cumulativas, ou seja, a próxima adiciona qualidade 
à anterior, e o receptor inscreve-se em tantas camadas quanto a sua condição de rede e máquina permitir. 
Os blocos Codificador em camadas e Decodificador em Camadas são detalhados na Figura 2, que mostra um 
resultado obtido para o vídeo carphone . O objetivo é capturar um sinal de vídeo e dividir o mesmo em 
diferentes taxas ou camadas, onde cada camada agrega qualidade à anterior. Figura 2. Codificação em 
Camadas. Caso o usuário se inscreva somente no grupo multicast referente à camada 1, ele vai receber 
o sinal com artefatos de blocagem , como pode ser visto na Figura 2a. Caso o usuário se inscreva nos 
5 grupos multicast (5 camadas), ele vai receber um sinal bastante superior, conforme apresenta a Figura 
2e. O protocolo ALMTF foi desenvolvido originalmente em uma Tese de doutoramento [1], sendo amplamente 
testado e validado através de simulações no NS-2. O algoritmo foi comparado com outros protocolos multicast 
em camadas, como o RLM [9], RLC [10] e TFMCC [11]. As principais métricas utilizadas foram: a) adaptabilidade 
em ambientes heterogêneos; b) escalabilidade; c) estabilidade; d) equidade com o próprio tráfego (fairness) 
e e) equidade com tráfego TCP (friendliness). O ALMTF se mostrou superior a todos os protocolos avaliados, 
no entanto não foi analisado em ambientes reais. Recentemente, foi realizada uma implementação inicial 
do ALMTF para verificar sua viabilidade de uso em redes reais. A pesquisa analisou o protocolo somente 
em relação às métricas de adaptabilidade e estabilidade, utilizando um ambiente controlado e sem tráfego 
concorrente. Resultados satisfatórios foram encontrados [3], fazendo com que o mesmo continuasse em desenvolvimento 
dentro do Projeto SAM. Os autores deste trabalho implementaram e validaram o protocolo ALMTF em redes 
reais e de longa distância, avaliando seu comportamento com relação as mesmas métricas da simulação. 
Em geral, os resultados obtidos foram semelhantes à simulação, porém, o protocolo se mostrou TCP-Compatível 
e não TCP-Friendly , visto que o TCP ocupa mais banda que o mesmo. A expansão do ALMTF para redes reais 
possibilitou identificar os principais pontos fracos do protocolo, bem como diversas melhorias para o 
mesmo. Entre as modificações efetuadas, a mais impactante e complexa foi da adaptação com o TCP, que 
os autores deste artigo conseguiram realizar com sucesso. As adaptações realizadas no ALMTF originaram 
um novo e mais eficiente protocolo, denominado ALMTF++. O protocolo ALMTF++ mantém todos os benefícios 
do algoritmo original, porém é superior em diversos aspectos, como será visto na seção de resultados. 
As comparações com os outros protocolos multicast já foi efetuada durante a Tese, portanto, assumiu-se 
que basta comparar o ALMTF++ com o ALMTF. Este trabalho está organizado como segue. A seção 2 apresenta 
o estado da arte em controle de congestionamento multicast. A seção 3 aborda o funcionamento do protocolo 
ALMTF, enquanto a seção 4 descreve as melhorias que deram origem ao ALMTF++. A seção 5 apresenta a metodologia 
utilizada nos experimentos e os resultados encontrados, fornecendo uma comparação entre os dois protocolos. 
E por fim, a seção 6 tece as considerações finais e apresenta futuras direções que podem ser tomadas 
como continuidade desta pesquisa. 2. TRABALHOS RELACIONADOS Vários protocolos foram propostos com o 
objetivo de solucionar ou amenizar os problemas do controle de congestionamento multicast. A maioria 
das pesquisas divide os protocolos em duas categorias: taxa-única e multi-taxa. Os protocolos de taxa-única 
enviam os dados na mesma taxa de transmissão para todos os receptores, realizando ajustes dinamicamente 
com base no receptor mais lento. Consequentemente, todos os demais são prejudicados, pois subutilizam 
os seus recursos. Exemplos de protocolos de taxa única são: TFMCC [11], TEAR [12] e ORMCC [13]. Os protocolos 
multi-taxa, foco deste trabalho, permitem que a transmissão seja realizada em várias taxas simultaneamente, 
através da técnica de transmissão em camadas. Dessa forma, possibilita que cada receptor se adapte na 
melhor taxa possível dentro das suas limitações, se tornando uma das principais soluções para o problema 
da heterogeneidade. Alguns exemplos de protocolos multi-taxa são: RLM [9], RLC [10] e o próprio ALMTF 
[1]. Recentemente, uma nova linha de pesquisa passou a unir conceitos de protocolos de taxa-única e multi-taxa 
para desenvolver protocolos híbridos. Estes protocolos fornecem multi-taxa através da utilização de subcamadas 
independentes de taxa única, ou seja, o protocolo disponibiliza diversas camadas, onde cada camada pode 
apresentar variações na sua taxa de transmissão interna. O protocolo GMCC [15] e SMCC [15] são alguns 
exemplos desta nova categoria de protocolo. Um comparativo de vários protocolos de controle de congestionamento 
pode ser encontrado em [14], juntamente com as vantagens e desvantagens de cada abordagem. Um novo esquema 
de controle de congestionamento multicast denominado PSLM é proposto em [16], tendo como base o protocolo 
PLM. Este algoritmo manteve as vantagens do original, acrescentando duas inovações: um gerenciador de 
seção e um gerenciador de camadas. A idéia básica consiste em definir prioridades as camadas, garantindo 
que as sessões mais importantes tenham preferência durante os congestionamentos. Yang [17] apontou os 
principais problemas a serem enfrentados pelos protocolos multicast como implosão de feedbacks, inferência 
de congestionamento e equidade de tráfego, discutindo as soluções mais promissoras para cada problema. 
Além disto, apresentou uma nova proposta que visa melhorar as alternativas atuais. Em [18] é realizado 
um extenso estudo sobre as limitações do controle de congestionamento baseado na equação do TCP, utilizada 
por vários protocolos atualmente. Nessa pesquisa, foram analisadas as possíveis razões para a diferença 
de throughput encontrada entre o TCP e os demais protocolos, dando ênfase ao TFRC. Os autores provaram 
que, mesmo estando sob o mesmo gargalho e com as mesmas condições de rede, a diferença na taxa de envio 
dos fluxos faz com que eles experimentem taxas de perdas diferentes, ocasionando uma significante diferença 
no throughput observado por eles. Os resultados obtidos analiticamente e através de simulações mostraram 
que, em casos extremos, o TFRC pode utilizar 20 vezes mais banda que o TCP, enquanto em outras situações, 
10 vezes menos. Outra contribuição desse trabalho foi a identificação de dois novos fatores que aumentam 
a diferença na taxa de envio dos protocolos: a convexidade no período de perdas e diferenças no cálculo 
de RTO. Por essas razões, os fluxos podem não compartilhar a banda da mesma maneira.  3. ALMTF Esta 
seção tem por objetivo descrever o algoritmo ALMTF em seu projeto original, detalhando os mecanismos 
utilizados para que o mesmo tivesse uma característica semelhante ao tráfego TCP, mas de forma mais estável. 
3.1 Controle de Fluxo e Congestionamento O ALMTF emprega dois métodos para realizar o controle de fluxo 
e congestionamento, um baseado em janela e o outro na equação do TCP. A taxa descoberta pelo mecanismo 
de janela é a principal no ALMTF, enquanto a taxa da equação é utilizada como apoio à decisão. Entretanto, 
a fim de evitar uma diferença muito grande, emprega uma proteção que limita a taxa da janela em no máximo 
duas vezes o valor da equação. 3.1.1 Método baseado em Janela Para se criar um mecanismo semelhante ao 
TCP, utilizou-se uma variável denominada cwnd que representa o tamanho da janela de congestionamento 
atual em pacotes. Essa variável está relacionada diretamente à quantidade de banda permitida para o receptor 
se cadastrar (taxa da janela). A relação entre cwnd e a taxa da janela é dada pelo cálculo abaixo, que 
estima a banda utilizada em uma conexão TCP equivalente para um determinado tamanho de janela. Por exemplo, 
se o RTT é 100ms e o tamanho de pacote é 500 bytes, tendo cwnd igual a 2 pacotes, a banda será igual 
a 80 kbit/s.   cwnd upacketsize u8taxa janela RTT Em alguns momentos é necessário efetuar o inverso, 
ou seja, passar de uma determinada taxa para o equivalente em janela de congestionamento. Isso acontece, 
por exemplo, quando é necessário adaptar a taxa da janela de acordo com o valor obtido via equação do 
TCP. Para que cwnd reflita o valor da banda da janela é utilizado o seguinte cálculo: taxa janela uRTT 
cwnd packetsize u8 Por exemplo, se a taxa da janela foi limitada em 400 kbit/s, com packetsize = 500 
bytes e RTT = 100ms, o valor calculado equivalente para cwnd é 10. O ALMTF foi dividido em duas fases: 
start-state e steady-state. Durante a fase start-state, o algoritmo tenta alcançar rapidamente sua banda 
equitativa com os fluxos concorrentes, e faz isso incrementando rapidamente cwnd até a detecção de perdas. 
Caso alguma perda seja detectada, o algoritmo considera que passou sua banda equitativa, então reduz 
sua taxa em 30% e passa para a fase steady-state. Para evitar que o algoritmo se torne muito agressivo, 
foi implementada uma proteção que inclui um tempo de estabilização após o receptor se cadastrar em uma 
nova camada. Além disso, o incremento de cwnd é de 50% a cada RTT, em vez dos 100% utilizados pelo TCP. 
Durante a fase steady-state, o algoritmo permanece incrementando a variável cwnd a cada RTT, caso não 
ocorram perdas. Para isto, incrementa cwnd em 0,1 por RTT, ao invés de 1 como utilizado no TCP. Da mesma 
forma, caso ocorram perdas, a redução da banda é dez vezes menos agressiva. Quando o método baseado em 
janela permitir, o receptor pode efetuar join em uma nova camada, no entanto isto somente é realizado 
caso seja permitido pelo mecanismo de sincronismo. Caso o valor calculado pelo método da janela seja 
menor que a taxa recebida pelo receptor, o algoritmo deduz que não possui banda suficiente para sustentar 
a taxa atual, mas efetua o leave apenas se a banda calculada pelo método da equação também for menor, 
caso contrário o sistema se mantém na taxa atual. 3.1.2 Método baseado em Equação O controle pela equação 
do TCP é semelhante ao utilizado no TFMCC [11]. A cada pacote recebido, o ALMTF estima a banda através 
da equação abaixo, que representa a fatia média de banda utilizada por um fluxo TCP. Como se pode verificar 
a partir da equação, é necessário ter conhecimento do tamanho do pacote, o valor do RTT e as perdas (p). 
O ALMTF utiliza um tamanho de pacote de 1000 bytes. O cálculo de RTT será descrito no item 3.2 e o cálculo 
de perdas será detalhado a seguir. packetsize B( p) | 2 p ¨ 3p ¸§ 2· RTT ¨§1,3 ¸·u4uRTT up¨1 32 p ¸ 
38 &#38;#169;¹ &#38;#169;¹ No ALMTF, a detecção de perdas é realizada com base no número de sequência 
existente em cada pacote. Caso o receptor detecte uma perda, ele incrementa uma variável que reflete 
a quantidade de perdas durante um determinado tempo. Se as perdas ocorrerem durante o mesmo RTT, são 
consideradas como uma única ocorrência de perda. Para realizar o cálculo de perdas (p), o algoritmo considera 
os oito últimos eventos de perdas, que são calculados conforme ilustra a figura 3. Quando acontece uma 
perda, o algoritmo primeiro verifica se já passou o RTT, se passou, inicia um novo evento de perda, caso 
contrário, mantém o mesmo evento. Na figura 3, pode-se ver que durante o evento de perda 1 ocorreram 
duas perdas e chegaram 13 pacotes (visto através do número de círculos preenchidos, que representam os 
pacotes recebidos), durante o evento de perda 2 ocorreram três perdas e chegaram 24 pacotes, e durante 
o evento de perda 3 ocorreu apenas uma perda, e chegaram 27 pacotes. Pacote recebido = Pacote perdido 
= Evento de Evento de Evento de perda 1 perda 2 perda 3 RTT RTT RTT Figura 3. Criação do vetor Evento 
de Perda . Através desse método, é gerado um vetor de oito entradas contendo o número de pacotes recebidos 
em cada evento de perdas, sendo que o valor inicial do vetor refere-se ao evento mais recente. No caso 
da figura 4, o vetor seria: vet_perdas = [27; 24; 13; 0; 0; 0; 0; 0]. No vetor de perdas, é dado um maior 
peso para os eventos mais recentes. O filtro utilizado se baseia nos 8 tempos anteriores, definindo um 
vetor da seguinte forma: [5; 5; 5; 5; 4; 3; 2; 1]. O valor de p será o inverso da média do valor dos 
eventos de perdas. Após a obtenção desta variável, basta aplicar a fórmula da equação para obter a banda 
máxima que o receptor poderá utilizar.  3.2 Cálculo do RTT Por determinar o aumento da janela e estar 
diretamente ligado ao aumento da taxa do TCP, o RTT é um dos elementos que gera o maior impacto nos protocolos 
que querem gerar tráfego equitativo. Para estimativa de RTT, o ALMTF utiliza um método no qual os relógios 
do transmissor e receptor não precisam estar sincronizados. No instante inicial e a cada intervalo entre 
feedbacks, o receptor envia ao transmissor um pacote de dados solicitando o cálculo. Esse pacote contém 
o instante em que o pedido foi enviado e a identificação do receptor. O transmissor responde a este pacote 
enviando as seguintes informações: a) instante em que o pacote está sendo enviando (timestamp); b) diferença 
de tempo entre a chegada da solicitação e a transmissão da resposta e c) identificação do receptor que 
deverá receber o pacote. Com base nestas informações, o receptor estará apto a calcular o RTT com precisão. 
O cálculo do RTT pode ser realizado de duas formas: 1) quando o receptor recebe uma resposta à sua solicitação 
e calcula o RTT com precisão, bem como a diferença entre os relógios do transmissor e do receptor e 2) 
quando o receptor recebe um pacote de dados somente com o timestamp do transmissor e calcula uma estimativa 
do RTT, verificando a sua variação. 3.3 Intervalo entre feedbacks Conforme visto no item 3.2, os receptores 
precisam enviar feedbacks ao transmissor em intervalos regulares de tempo, a fim de calcular com precisão 
o RTT. Entretanto, o número de pacotes enviados deve respeitar um limite, caso contrário poderia provocar 
uma implosão de feedbacks se houvesse um grande número de receptores simultaneamente. O ALMTF controla 
os feedbacks da seguinte maneira: até 60 receptores, o total de mensagens deve ser limitado a uma por 
segundo. Neste caso, se existirem 60 receptores, cada um deles pode enviar uma mensagem a cada 60 segundos, 
obtendo uma atualização de RTT por minuto. Entretanto, acima de 60 receptores mantém-se a mesma atualização 
por minuto, a fim de evitar uma espera muito grande para o cálculo com precisão.  3.4 Pares de Pacotes 
(PP) O protocolo ALMTF utiliza o método de PP para determinar a banda máxima na qual o receptor poderá 
se inscrever. A descrição completa deste método encontra-se em [1]. 4. ALMTF++ Diversos pontos fracos 
foram identificados durante a análise do protocolo original e seus mecanismos. Esta seção tem por objetivo 
apresentar as modificações que deram origem ao ALMTF++, resultando em um novo protocolo de controle de 
congestionamento multicast. As inovações descritas a seguir corrigiram deficiências que afetavam o desempenho 
do protocolo com relação à estabilidade, equidade e escalabilidade na transmissão, fazendo com que o 
mesmo fosse totalmente adaptado para redes reais. 4.1 Controle de Fluxo e Congestionamento Conforme comentado 
na seção 3.1, o ALMTF emprega dois métodos completamente diferentes para realizar o controle de fluxo 
e congestionamento. No entanto, após os primeiros experimentos já foi possível verificar diversas inconsistências 
devido à utilização conjunta desses mecanismos. Um exemplo é a proteção existente sobre o método da janela, 
forçando que a taxa utilizada seja no máximo 2x maior ou menor que o valor obtido pelo método da equação. 
Considerando que a equação pode calcular valores muito diferentes a cada execução, possibilita que ocorram 
variações bruscas na taxa da janela, tornando o protocolo menos estável. Esse problema se estende também 
à variável cwnd, visto que ela reflete a banda da janela e sofre consequências com a sua alteração. Portanto, 
nem sempre as modificações em cwnd resultarão no comportamento esperado pelo algoritmo, podendo haver 
aumentos maiores que 50% na fase start-state e reduções acima que 30% na fase steady-state. As falhas 
tornam-se mais aparentes quando não é utilizado o mecanismo de PP, pois durante a sua utilização o algoritmo 
não leva em consideração valores maiores que o inferido por ele. Outras deficiências foram encontradas 
com relação à equidade de tráfego na presença de fluxos TCP concorrentes. Os resultados mostraram que 
o ALMTF é amigável com ele mesmo e com outros fluxos UDP, contudo, diferente dos resultados obtidos na 
simulação [1], não consegue dividir a banda de forma adequada com o protocolo TCP. Visando reparar essas 
limitações e reduzir a complexidade do protocolo, os mecanismos de janela e equação foram isolados e 
analisados separadamente. O método baseado na equação obteve o melhor desempenho, e por essa razão é 
o único utilizado no ALMTF++. Segundo [18], outra vantagem da utilização do controle baseado na equação 
é que ele está sendo adotado como um padrão pelos protocolos de controle de congestionamento multicast 
na Internet. É importante destacar que esta modificação afeta diretamente a estabilidade do protocolo, 
tornando a transmissão menos instável e, consequentemente, mais agradável para o usuário. O problema 
da equidade foi amenizado através do auxílio do método de aprendizado com estados da rede, descrito na 
seção 4.3. Contudo, novos estudos estão sendo realizados para deixar o ALMTF++ ainda mais competitivo 
com o TCP. 4.2 Cálculo de RTT e Controle de Feedbacks O RTT é um dos principais parâmetros do ALMTF, 
sendo fundamental para o cálculo da banda equivalente do TCP. No entanto, para que a banda se mantenha 
equitativa ao longo do tempo, é preciso que os receptores enviem pedidos de feedbacks em intervalos regulares, 
obtendo o RTT com precisão. Conforme comentado anteriormente, isso gera uma complexidade adicional aos 
protocolos multicast que é controlar o fluxo de retorno por parte dos receptores, evitando que ocorra 
uma implosão de feedbacks no transmissor. Apesar de existir diversas propostas para impedir esse problema, 
o ALMTF não utiliza nenhuma técnica especial para supressão das mensagens, tendo seu controle baseado 
apenas no intervalo entre os envios de mensagens em cada receptor. Desse modo, perde eficiência por não 
ter um controle efetivo na taxa de envio dos pacotes, além de não garantir escalabilidade quando utilizado 
em larga escala. Os mecanismos de cálculo de RTT e controle de feedback foram totalmente reformulados 
no ALMTF++. As alterações motivaram a criação de um novo método para transmissões multicast de larga 
escala denominado FeedC [6], que une um conjunto de algoritmos conhecidos na literatura com um mecanismo 
de cooperação de receptores da mesma rede local. Em síntese, o FeedC pode ser dividido em duas etapas, 
que juntas monitoram as trocas de mensagens entre os receptores e o transmissor. A primeira etapa é responsável 
pelo cálculo do RTT, que é realizado de três formas complementares: a) utilizando a troca de mensagens 
entre receptor e transmissor (laço fechado); b) utilizando o timestamp do transmissor (laço aberto) e 
c) através da troca de informações entre os receptores da mesma rede local. A segunda etapa é destinada 
ao controle de feedback, sendo composta pela integração de vários mecanismos, como timer com distribuição 
exponencial, técnicas de supressão e cooperação entre receptores da mesma rede local. Por motivo de espaço, 
os resultados obtidos com o FeedC não serão incluídos neste trabalho, podendo ser encontrados em [6]. 
 4.3 Aprendizado com o estado da rede Conforme comentado na seção 4.1, verificou-se que o ALMTF apresenta 
problemas de instabilidade ocasionada por tentativas frustradas de join, gerando perdas e congestionamento 
na rede. Os resultados apontam que o ALMTF é falho especialmente em duas situações: a) quando não tem 
conhecimento da banda máxima que ele pode utilizar e b) na existência de tráfegos concorrentes. A primeira 
situação pode ser amenizada com a utilização da técnica de PP, entretanto, a segunda é inevitável em 
qualquer ambiente real. Visando diminuir a oscilação gerada pelo algoritmo, foi desenvolvido um mecanismo 
que aprende com as falhas anteriores, reduzindo significativamente a quantidade de joins sem sucesso 
durante a execução. O mecanismo funciona da seguinte maneira: cada vez que ocorre uma falha, é armazenado 
o estado da rede no exato momento em que houve a tentativa. Antes de tentar se inscrever em uma nova 
camada, o protocolo irá analisar se existe algum estado de rede parecido com o atual. Se houver ele não 
sobe, caso contrário, tem permissão para subir. É considerada uma falha quando ocorre uma subida de camada 
que resulte em descida em um intervalo de tempo menor que o estipulado pelo mecanismo. O estado da rede, 
como foi definido neste trabalho, é o valor do RTT e a probabilidade de perdas no momento anterior ao 
join. Caso o RTT atual seja maior que os estados armazenados ou existirem mais perdas, não sobe por haver 
uma grande probabilidade de falha. As principais variáveis utilizadas pelo mecanismo são: a) fail_time: 
tempo considerado com falha; b) join_failures: contador com o número de falhas; c) t_failure: tempo em 
que ocorreu a falha e d) storage_time: tempo de armazenamento de um estado de falha. Todos esses parâmetros 
são configuráveis, podendo ser ajustados para deixar o protocolo mais ou menos estável.  4.4 Sincronismo 
na rede local Foram desenvolvidos dois mecanismos adicionais a serem utilizados entre os receptores da 
mesma sub-rede (TTL=1). Os novos mecanismos, denominados aprendizado de join e aprendizado de leave, 
têm como objetivo sincronizar os receptores dentro da rede local, melhorando a estabilidade da transmissão. 
Isto é realizado através da captura e gerenciamento das mensagens IGMP que trafegam dentro da rede. O 
mecanismo de aprendizado de join monitora as subidas de camada dos receptores. Caso um receptor se inscreva 
em um grupo multicast correspondente a duas ou mais camadas acima de outro receptor fará com que o menor 
se cadastre em todas as camadas até a anterior à qual foi feito o join. Por exemplo, o receptor R1 está 
na camada C2 e outro receptor faz join na camada C4. Imediatamente R1 vai para camada C3. O aprendizado 
de leave evita que pequenas instabilidades na rede causem descidas de camada desnecessárias. Se a rede 
está congestionada e tem dois receptores, R1 na camada C3 e R2 na camada C2, R2 não deve descer o nível 
para C1 até R1 descer para a camada C2. Assim, a diferença máxima de camadas entre os receptores será 
um.  5. METODOLOGIA E RESULTADOS Foram desenvolvidas duas aplicações para analisar os protocolos ALMTF 
e ALMTF++: um transmissor e um receptor de dados com o respectivo protocolo integrado. Ambas as versões 
foram implementadas na linguagem C/C++ e compiladas para o sistema operacional Linux. A ferramenta transmissora 
gera o tráfego multicast nas taxas especificadas em cada camada. O receptor recebe os pacotes e efetua 
o controle de fluxo e congestionamento mais apropriado de acordo com as suas condições de rede. Os protocolos 
foram validados experimentalmente em redes locais (ambiente controlado) e de longa distância (Rede Nacional 
de Pesquisa -RNP), utilizando as seguintes métricas: a) adaptabilidade em ambientes heterogêneos; b) 
escalabilidade; c) estabilidade; d) equidade com o próprio tráfego (fairness) e e) equidade com tráfego 
TCP (friendliness). Por questões de espaço, os resultados obtidos com relação à escalabilidade não serão 
apresentados neste trabalho, podendo ser encontrados em [6]. Visando examinar o impacto da granularidade 
das camadas nos quesitos estabilidade e equidade, foram efetuados testes com camadas fixas e exponenciais. 
A tabela 1 apresenta as camadas exponenciais utilizadas nos experimentos, bem como os grupos multicast 
e suas respectivas taxas de transmissão. Os testes utilizando camadas fixas foram realizados com 32 camadas 
de 250kbit/s cada. Tabela 1. Exemplo de Camadas e Taxas de Transmissão GRUPO GRUPO TAXA (kbit/s) 1 239.1.1.1 
128 2 239.1.1.2 256 3 239.1.1.3 512 4 239.1.1.4 1024 5 239.1.1.5 2048 6 239.1.1.6 4096 TOTAL - 8064 
A topologia visualizada na figura 4 foi utilizada para analisar a adaptabilidade e estabilidade em ambiente 
heterogêneo. O cenário foi composto por um transmissor e três receptores, cada um localizado em um link 
separado, além de um roteador responsável por realizar o roteamento dos pacotes multicast e a limitação 
de banda das estações. O sistema operacional usado no roteador foi o Fedora versão 9.0, recompilado com 
os módulos traffic control (tc), token bucket filter (tbf) e mrouted. Figura 4. Cenário 1: adaptação 
e estabilidade. Através da limitação da banda foi possível verificar a adaptabilidade dos algoritmos, 
avaliando se as taxas recebidas estavam de acordo com a capacidade de cada receptor. A estabilidade foi 
analisada observando se os protocolos mantinham o recebimento constante dos dados. Para isso, foi desenvolvido 
um script que calcula a média de variações de camadas por minuto (VCM) efetuado por cada receptor, permitindo 
uma comparação rápida de todos os experimentos. Os resultados a seguir apresentam o protocolo ALMF original, 
sendo possível avaliar seu comportamento antes das alterações. As figuras 5 e 6 mostram os resultados 
obtidos na análise da adaptabilidade, onde os receptores foram configurados com larguras de banda de 
2.5, 4.5 e 9Mbit respectivamente. O experimento da figura 5 foi realizado utilizando o mecanismo de PP 
e camadas exponenciais. Figura 5. Adaptabilidade com PP. Conforme pode-se observar, todos os receptores 
conseguiram se adaptar na camada correta, conforme a largura de banda estipulada para cada um. O receptor 
1, por exemplo, se cadastrou até a camada 4, recebendo uma taxa total de 1.9Mbit/s (soma das camadas 
1+2+3+4). Como a taxa acumulada da próxima camada é superior a sua banda máxima, não permite que o receptor 
suba, mantendo-se na camada ideal. A figura 6 apresenta o mesmo teste, mas sem a utilização do método 
de PP. O resultado comprova a análise realizada na seção 4.1, mostrando que os fluxos não se adaptam 
corretamente sem o mecanismo, gerando frequentes oscilações entre as camadas. Figura 6. Adaptabilidade 
sem PP. Na figura 6, somente o receptor 3 conseguiu se adaptar na sua camada ideal e permanecer nela 
durante toda a execução. Isso ocorreu porque a sua largura de banda era maior que a soma de todas as 
camadas disponibilizadas na transmissão. A tabela 2 analisa a estabilidade do ALMTF durante os dois experimentos 
anteriores. Tabela 2. Estabilidade com e sem o método de PP Experimento VCM Receptor 1 Receptor 2 Receptor 
3 Com PP 0,5 0,66 0,2 Sem PP 37,68 42,59 0,43 Os resultados apontam que a estabilidade do ALMTF pode 
ficar comprometida mesmo em ambientes sem tráfego concorrente, caso não esteja sendo utilizado o método 
de PP ou se o mesmo não estiver funcionando corretamente. É importante destacar que essa técnica também 
possui várias deficiências quando utilizada em ambientes reais, podendo inferir valores maiores ou menores 
que a banda real [3]. Outros experimentos foram realizados utilizando camadas fixas e diferentes atraso 
na rede. Os resultados encontrados foram semelhantes, porém observou-se que quanto menor a granularidade 
das camadas, pior a estabilidade do algoritmo, pois mais tentativas de join são efetuadas. A topologia 
apresentada na figura 7 foi utilizada para verificar as métricas de equidade e estabilidade. Neste cenário, 
todos os receptores dividem um único link, compartilhando uma banda de 1.2Mbit/s. Figura 7. Cenário 
2: equidade e estabilidade. A figura 8 apresenta o resultado do experimento onde dois receptores ALMTF 
disputam o link entre si. O teste foi realizado com o mecanismo de PP e utilizando camadas fixas. Pode-se 
verificar que ambos os receptores dividiram a banda de maneira equitativa entre si, recebendo uma taxa 
média de 400kbit/s cada um.  O fluxo UDP não se adapta, forçando os dois fluxos ALMTF a dividirem o 
restante da banda entre si. Quando o fluxo UDP termina, no instante 400s, os fluxos ALMTF voltam a subir, 
compartilhando a banda total do enlace. O início do segundo fluxo UDP, no instante 600s, provoca perdas 
faz com que os fluxos ALMTF voltem a se adaptar, voltando a dividir o restante da banda. A figura 11 
ilustra o comportamento do ALMTF na presença de fluxos TCP concorrentes. O experimento foi realizado 
com um fluxo ALMTF e um TCP dividindo um enlace de 1.6Mbit/s. Figura 11. Equidade com fluxo TCP concorrente. 
 Conforme se pode observar, o ALMTF não consegue dividir o enlace de forma adequada, utilizando uma banda 
muito abaixo do seu valor equitativo. Enquanto o TCP recebia uma média de 1.3Mbit/s, o ALMTF utilizava 
o restante do link (250kbit/s), ficando cadastrado apenas na camada 1. Essa característica indica que 
o protocolo é TCP-Compatível e não TCP-Friendly. A figura 12 apresenta o mesmo experimento utilizando 
o protocolo ALMTF++ e um enlace de 4.5Mbit/s. Diferente do resultado anterior, o ALMTF++ consegue competir 
pela banda de forma mais adequada, reduzindo a diferença de throughput observada pelos protocolos. Figura 
12. Equidade com fluxo TCP concorrente. Enquanto o TCP utilizava em média 3Mbit/s, o ALMTF++ conseguiu 
ocupar a metade, existindo momentos em que sua taxa ultrapassou a do TCP e forçou a sua descida. Esse 
comportamento é um grande avanço em relação ao ALMTForiginal. É importante destacar que o fato das taxas 
de envio dos protocolos serem diferentes impede que eles tenham, de fato, taxas totalmente igual [18]. 
O experimento realizado na RNP teve como objetivo comparar a estabilidade dos protocolos em um ambiente 
com muitos tráfegos concorrentes. Foram utilizados ao todo 4 PoPs (Pontos de Presença), todos com IP 
multicast habilitado. Os PoPs envolvidos (PoP-PR, PoP-RJ, PoP-RS e PoP-PE) estão ilustrados na Figura 
13. O tempo de duração do teste foi de aproximadamente 30 minutos para cada protocolo, sendo que o transmissor 
foi posicionado no PoP-RJ e os receptores nos demais PoPs. A tabela 4 apresenta o VCM obtido pelos dois 
protocolos. Nota­se que o ALMTF++ realiza a mesma transmissão de maneira muito mais suave, amenizando 
o problema de instabilidade existente no protocolo original. Tabela 4. Estabilidade na RNP PROTOCOLO 
VCM POP-PE POP-RS POP-PR ALMTF 70,5625 68,3125 56,5882 ALMTF ++ 25 30,9412 27,5882  6. CONSIDERAÇÕES 
FINAIS Este trabalho apresenta uma validação do protocolo ALMTF em redes locais e de longa distancia, 
analisando seu comportamento em relação à adaptabilidade, estabilidade e equidade na transmissão. Os 
resultados obtidos foram semelhantes aos originais [1], porém o protocolo mostrou-se TCP-Compatível e 
não TCP-Friendly, visto que o TCP ocupa mais banda que o mesmo. As inovações e melhorias realizadas no 
ALMTF originaram um novo protocolo, denominado ALMTF++. Uma comparação dos protocolos é realizada, indicando 
que o ALMTF++ mantém todos os benefícios do original, sendo superior em diversos aspectos, como por exemplo, 
na equidade de tráfego com o TCP e na estabilidade na transmissão. A comparação do ALMTF++ com os demais 
protocolos não foi realizada, visto que isso já foi efetuado pelo ALMTF, obtendo­se melhores resultados 
em todos os quesitos analisados. Dessa forma, assumimos que se o ALMTF++ é mais eficiente que o ALMTF, 
será ainda mais superior que os demais analisados.  7. REFERÊNCIAS <RefA>[1] Roesler, V. SAM: um sistema adaptativo 
para transmissão e recepção de sinais multimídia em redes de computadores. Tese de Doutorado (Ciência 
da Computação) Universidade Federal do Rio Grande do Sul (UFRGS), Porto Alegre, 2003. [2] Bai, B.; Harms, 
J.; Li, Y. Configurable active multicast congestion control. Computer Networks, 52, 7, 2008. [3] Krob, 
A. C. et al. ALMTF: Adaptive Layered Multicast TCP-Friendly. In: Simpósio Brasileiro de Sistemas Multimídia 
e Web, WEBMEDIA, 13, 2007, Gramado, RS. [4] Byers, J. et al. Fine-Grained layered Multicast with STAIRS. 
IEEE Transactions on Networking, March 2006, 14, pp. 81-93. [5] Li, J. et al. Generalized Multicast Congestion 
Control. Computer Networks, Amsterdam, v. 51, n. 6, pp. 1421­1443, April 2007. [6] Carvalho, J. S. et 
al. FeedC: um novo mecanismo de cálculo de RTT e controle de feedback para transmissões multimídia de 
larga escala. In: Simpósio Brasileiro de Sistemas Multimídia e Web, WEBMEDIA, 2008. [7] Kammoun, W.; 
Youssef, H. Improving the performance of End-to-End single rate Multicast Congestion Control. In: Computers 
and Communications, 2008. ISCC 2008. IEEE Symposium on, pp.1128-1132, July 2008. [8] Bavier, A. et al. 
PlanetLab-VINI: Uma infra-estrutura de redes virtualizada. In: Workshop de P&#38;D do Projeto GIGA/RNP- 
RJ, 2007. [9] Mccanne, S.; Jacobson, V.; Vetterli, M. Receiver driven layered multicast. ACM Sigcomm, 
1996, California, USA. Proceedings New York: ACM, 1996. p.117-130. [10] Vicisano, L.; Rizzo, L.; Crowcroft, 
J. TCP-like congestion control for layered multicast data transfer. IEEE INFOCOM, 1998, San Francisco, 
California, USA. Proceedings New York: IEEE, 1998. [11] Widmer, J.; Handley, M. Extending equation-based 
congestion control to multicast applications. ACM Group on Communications, ACM SIGCOMM, 2001, San Diego, 
USA. Proceedings New York: IEEE, 2001. [12] Rhee, I.; Ozdemir, V.; Yi, Y. TEAR: TCP emulation at receivers 
- flow control for multimedia streaming. North Carolina: NCSU, Department of Computer Science, 2000. 
[13] Jiang, L.; Shivkumar, K. ORMCC: A Simples and Effective Single-Rate Multicast Congestion Control 
Scheme. 2003. Disponível em: <http://citeseer.ist.psu.edu/624716.html>. Acesso em: abril 2009. [14] Widmer, 
J. et al. A Survey on TCP-Friendly Congestion Control. IEEE Network, v.15, n.3, p.28 37, May 2001. [15] 
Kwon, G.; Byers, J. Smooth multirate multicast congestion control. In: Conference of the IEEE Computer 
and Comunications, INFOCOM, 22., 2003, San Francisco, USA. Proceedings [S.l.]: IEEE, 2003. p. 1022-1032. 
[16] Li, Y.; Munro, A.; Kaleshi, D.; Multi-rate Congestion Control using Packet-pair Bandwidth Detection 
with Session and Layer Changing Manager. IPCCC. In: 24th IEEE International, p. 485 490. April 2005. 
 [17] Yang, R. Y; Simon, S. L. Internet Multicast Congestion Control: A Survey. In Proceedings of the 
International Conference on Telecommunications (ICT'00), Acapulco, Mexico, May 2000. [18] Injong, R.; 
Lisong, X. Limitations of equation-based congestion control. SIGCOMM Comput. Commun. Rev., 35(4):49 60, 
October 2005. </RefA>  
			

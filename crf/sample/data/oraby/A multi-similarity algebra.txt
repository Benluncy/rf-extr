
 A Multi-Similarity Algebra * S. Adab P. Bonatti and M.L. Sapino V.S. Subrahmanian Rensselaer Polytechnic 
Institute Universita di Torino University of Maryland sibel@cs.rpi.edu {bonatti,mlsapino}@di.unito.it 
vs@cs.umd.edu Abstract The need to automatically extract and classify the contents of multimedia data 
archives such as images, video, and text documents has led to significant work on similarity based re-trieval 
of data. To date, most work in this area has focused on t,he creation of index structures for similarity 
based retrieval. There is very little work on developing formalisms for querying multimedia databases 
that support similarity based computa-t,ions and optimizing such queries, even though it is well known 
that feature extraction and identification algorithms in media data are very expensive. We introduce 
a similarity algebra i,hat brings together relational operators and results of mul-i,iple similarity 
implementations in a uniform language. The algebra can be used to specify complex queries that combine 
different interpretations of similarity values and multiple al-gorithms for computing these values. We 
prove equivalence and containment relationships between similarity algebra ex-pressions and develop query 
rewriting methods based on these results. We then provide a generic cost model for evaluating cost of 
query plans in the similarity algebra and query opti-mization methods based on this model. We supplement 
the paper with experimental results that illustrate the use of the algebra and the effectiveness of query 
optimization methods using the Integrated Search Engine (I.SEE) as the testbed. Introduction The need 
to automatically extract and classify the con-tents of multimedia data archives such as images, video, 
and text documents has led to significant work on simi-larity based retrieval of data. To date, most 
work on sim-ilarity based retrieval has focused on the creation of index structures for similarity based 
retrieval [9, 4, 151, with the exception of a very general theory of similarity developed *Supported 
by AR.0 grants DAAff-04-95-10174, DAAH-04-S&#38; 10297, and DAAH04-96-l-0398, by ARL contract DAALOl-97. 
K0135, and by NSF grant IHI-93.57756. Permission to msks digital or hard copies of all or part of this 
work for personal or classroom usa is granted without fee provided that copies are not made or distributed 
for profit or commercial sdvan-taga and that copies bear this notice and the full citation on the first 
page. To copy otherwise. to republish, to post on servers or to redistribute to lists, requires prior 
spacific permission and/or a fee. SIGMOD 98 Seattle. WA, USA 63 1996 ACM o-69791.996.6/96/006...55.00 
in [12]. However, to date, there has been no work on developing an algebra (similar to the relational 
algebra) for similarity based retrieval. Given the fact that most feature extraction and identification 
algorithms in media data arc very expensive, the need for query optimization to such databases is critical 
-yet, it is impossible to cre-ate principled query optimization algorithms without an initial underlying 
algebra within which similarity based retrieval operations are executed. Our approach in this paper is 
to start with an arbitrary multimedia database MDB that has been organized ac-cording to any arbitrary, 
but fixed set of index structures and algorithms for retrieval using these index structures. Note that 
such a database may access a variety of spc-cialized data structures each organized to facilitate one 
or more operations. Starting from this point, we define (Sec-tion 2) a Multi-Similarity Algebra, MSA. 
Unlike previous works, MSA may be used to access not just one notion of similarity, but multiple similarity 
measures, encoded, by different algorithms, and to combine them in almost any way that the user wants. 
We then establish (Sec-tion 3) a set of equivalence, as well as containment, results for MSA which provide 
the basis for query optimization techniques for processing similarity based queries given in Section 
4. Before proceeding any further, we present two simple motivating examples from two different domains. 
Example 1 (Face Recognition) Consider a set of im- ages depicting faces of individuals. We might have 
two databases of such faces - a black and white image database BW-DB that comes accompanied by similarity 
based re-trieval algorithms based on a holistic approach to face recognition (e.g. Chellappa s work at 
UMD), and a color image database COL-DB that uses eigenface based face retrieval algorithms (e.g. Pentland 
s work at MIT). While COL-DB can be used to retrieve images in BW-DB, the converse is not true. Furthermore, 
using COL-DB to re- trieve images from BW-DB is less accurate than using BW-DB. Suppose now a user has 
a query image imQ, and she wants to find images in BW-DB and COL-DB that are similar to imQ. For this 
purpose, the user may specify the following types of queries: 1. Find the R closest matches to imQ in 
BWDB that match img. 2. Find the rr closest matches to imQ in BW-DB U COL-DB where the distance between 
an image im  in BW-DB from img is the aver ge of the dis-tances between im, imQ reported byr BW-DB and 
COL-DB respectively. 3. Find the n closest matches to imQ in BW-DB U COL -DB under the same condition. 
as before, tak-ing into account, only texture prope 4ties. 4. Find the IL closest matches to imglin 
BW-DB U COL-DB under the same conditions as before, tak-ing into account, images snapped a er January 
1,  11997. Example 2 (Integrating multiple we search en-gines) Internet search engines manage k yword 
indexes of text documents. Given a queries, they eturn a set of documents together with an associated 
sim larity match . These similarity measures reflect the perce tage of matched terms with associated 
weights that depe d on the fre-quency of occurrence of each term in the do .ument. Search engines such 
as HotBot a.nd Excite support ull text search whercxas Infoseek supports searching wit in a different 
part of document such as the title, abst act, URL and etc. Suppose we are conducting an invesj igation 
into a suspected plagiarized research paper d,. pe ask for all documents that contain keywords similar 
t the keywords of d, in all of the four above search engin s. We want to {find all documents d such that: 
d is returned by either HotBot or Excith with at least I65% percent similarity, and - d is returned by 
AltaVista within the rst 100 docu- Bments, and - d is returned by Infoscek in the docu the words in the 
title of d, with at least We can refine this query further by j ments returned by Infoseek for the ti 
bot for the full text with at least choose those documents returned by one other search engine. 2 Heterogeneous 
Architecture for Simi Figure 1 shows our proposed similarity architecture. The main features of our ar 
ecture are as follows: Autonomous/Legacy Implemen architecture, we assume the existence implementations 
of similarity whose AP functions. This is certainly realistic --. to larity based retrieval algorithms 
have be ing special purpose techniques that var Section 2.3. As there is often a mismatch between indi-vidual 
similarity implementations and the S.4, similar- ity implementations need a wrapper th t can be used 
to present a homogeneous interface betwee the similarity User Figure 1: Architecture of Multi-Similarity 
Index Struc- ture implementations and the MSA. Similarity abstractions are defined in Section 2.4. Relational 
Multi-Similarity Algebra (rMSd): provides a relational interface through which the user may query a set 
of similarity implementations. In effect, the rMSA hides implementation details from the user. It also 
gives him the ability to express complex queries and complex similarity strategies based upon his knowledge 
of the domain he is searching and his knowledge of the similarity engines (e.g. he may choose to disregard 
some of the similarity engines). The relational multi-similarity algebra is introduced in Section 2.6. 
Query Optimization: We will develop techniques to optimize queries expressed both in MSA and in rMSd. 
In particular, Section 3 describes various query equiva-lences, and how these equivalences may be used 
to create query plans. Using the rMSd, the user may create views which may then be used for further query 
optimization. Section 4.2 defines similarity views, and shows how we may use a cost model (defined in 
section 4) for re-using views to optimize queries. 2.1 Preliminaries on Objects In this section, we will 
introduce the notion of objects. Intuitively, an object is any abstract data type with asso-ciated properties. 
Objects can be images, text documents, video segments, etc. Properties model the attributes that similarity 
implementations can search on. As objects can have many different attributes, we will assume that any 
similarity measure is defined with respect to a subset of these properties. For this reason, we will 
introduce the notion of a type as an identifier for an object with respect to a different similarity 
measure. Below, we formalize these notions. Definition 2.1 A property is a pair (PropId, VSet) , where 
PropId is the property identifier and V/Set is the set of possible values for that property. We will 
use PropId to identify the property. PropId.VSet denotes the second component of the property. A type 
is a finite set of prop- erty identifiers. For example, suppose keyword-list is a propert,y and VSet 
contains the power-set of all words in a document archive. Similarly, in the case of thumbnail images, 
prop-erties might include avg-R, avg-G, avg-B, avg-texture, each having the set of reals as the associated 
VSet, spec-ifying the average red-green-blue values and texture, re-spectively. Now, given a database 
of thumbnail images, we may only want to consider the avg-R, avg-G, avg-B, avg-texture properties as 
significant values. Then the set of these four properties (namely {avg-R, avg-G, avg-B , avg-texture}) 
is a t,ype. Definition 2.2 An ob,ject of type 7 = { pl, , p, } is a pair consisting of an object template, 
and a set {pl = 1:. ,p7%= vn }, where u, C p,.VSet. Returning to our thumbnail sketch domain, an exam- 
ple object with oid = 01 may have the values avg-R= [0.2,0.3], avg-B= [0, 01, avg-G= [0.7,0.9] and avg-texture 
= 1. In some cases, templates correspond to the ac-tual attributes of objects stored in a database. In 
cases when the user does not have access to the actual at-tributes, properties may denote a region in 
the similarity search space. III search engines, an object template can be a list of keywords or a conjunction 
of query attributes as in the I.SEE system (Integrated Search Engine [I]). An example template can be 
a list of keywords such as PostModern Culture Netzine . A document matching such a template may have 
properties such as URL, title, abstract. This is consistent with image retrieval imple-mentations that, 
retrieve pictures that are similar to a sketch input by the user. In this paper, we do not differ-entiate 
between these two types of templates.  2.2 Similarity implementations Suppose MDB is any set of media 
objects (the multi-media database ), organized according to some indexing structure. Most existing similarity 
based retrieval imple-mentations on these objects provide functionalities of sim- ilar nature. We group 
these functionalities into two cat-egories. In the first category, similarity implementations may allow 
the similarity measures that they compute to be queried directly. In some cases, such measures may not 
be visible or even available to an external source. In t,he second category, we will consider the similarity 
im-plementations that will retrieve documents in decreasing order of similarity. These implementations 
will allow dif-ferent ranges in the ranking with respect to similarity to be retrieved. The two abstract 
functions below model the behavior of these two different similarity queries. Definition 2.3 (Similarity 
Implementation) Let Obj be a given set of objects. A similarity implementation (SIMP for short) for Obj 
is a nonempty set of functions of the following types: p : 20bJ x Obj x N -+ 20bJXRk , K : Obj x Obj 
+ R where card(p(MDB, 0, k)) < k. If t 5 1 then card(p(MDB, 0, k)) 5 card(p(MDB, 0,1)). Moreover, if 
(0 , m) E p(MDB, 0, n), then 0 E MDB. Intuitively, IE takes objects 0,O E MDB and returns a vector of 
real numbers r = ( ~1,. . . , Vk ). USUdy, T contains only one value, such as a distance between 0 and 
0 ~- the smaller the distance, the more similar t,hese ob,jects are considered to be. Likewise, the function 
p takes a database of objects, a search object Obj and a number N as input. It re-turns as output the 
first N objects in similarity ranking with respect to Obj from the input database. Note that a similarity 
implementation may contain several functions however, the signatures (input-output types) of these func-tions 
must fall into one of the two categories above. Example 3 Recall the example about the Internet Search 
Engines. We assume that there exists a similarity im-plementation p-X for each search engine X. Each 
im-plementation takes as value the proprietary database of the search engine, a search query containing 
keywords, connectives and other attributes and a number denot-ing the number of documents requested in 
the answer. The description of the generic query language for Inter-net, search engines and query specification 
in this generic language can be found in [I]. An expression of the form p-E(EDB, Ql, 10) requests the 
first 10 documents that are most similar to the description Ql in the database for Excite. Excite returns 
a vector of two values asso-ciated with each answer to this query, the first number corresponds to the 
rank of the document and the sec-ond to the similarity measure expressed as a percentage value. Each 
object returned by this similarity implemen-tation will have the properties title, URL, abstract and 
last modification date. We assume that all similarity implementations use a special constant all. A call 
of the form pE(EDB, Ql, all) is requests all tuples from the database EDB in decreas- ing order of similarity 
w.r.t. Ql. Technically, all de-notes the number corresponding to the size of the input database for any 
similarity implementation. 2.3 Similarity Measures Similarity measures refine similarity implementations 
as follows. First, we will allow a similarity measure to not just take two objects, but also a type as 
input. Intuitively, this measures the similarity of two objects with respect to a specific type. (Later, 
the similarities between 0,O w.r.t. different types may be merged). Second, we will as-sume that the 
answer returned is not a single value -but a bag of values. This approach not only generalizes the point 
based approach as a special case, it also provides a declarative definition language for expressing similarity 
computations that manipulate multiple similarity imple-mentations and various interpretations of the 
similarity values returned by them. Finally, for the sake of conve-nience (this will make later definitions 
easier to read), we will represent similarity measures by sets of tuples (the reader will readily believe 
that all functions can be repre- sented as relations, e.g. f(x) = y can be represented as a relation 
with the tuple f(~, y)). Definition 2.4 (Similarity Measure) A similarity mea-sure m is a set of tuples 
of the form ( 0, 0 , T, v ) , where 0,O are objects, 7- is a type and 21 is a bag of real numbers. A 
similarity measure m should be such that ( 0, O , r, v ) E m and ( 0, 0 ) T, v ) E m imply v = v , i.e. 
identical bags. Example 4 ml and m2 below are two similarity mea- Definition 2.6 (Collect Function) Let 
mr and mZ dc- sures. note similarity measures, f E F , and 0 E { U. n, -}. Then the collect function 
computes bags of bags as de-fined below: Coll,(m~~ m2,0,0 , r) = 2.4 Similarity Abstractions The concept 
of a similarity abstraction ties together the concept of similarity implement,ations and similarity mea-sures 
by mapping the values obtained from an implemen- tation to the appropriate bag representation. Definition 
2.5 (Similarity Abstraction) A similarity abstraction of a similarity implementation SI w.r.t. r and 
f : 72 -+ R, is a set of functions contained in {p:,f, rc:,f 17 is a type and f is a function from vectors 
of reals of arity k to reals }, corresponding to the functions of SI, defined as follows: 1. If p E SI 
and p(DB, 0, n) = { (01, vi), , (O,, ZJ,) }, then P:,~(DB, 0, n) = {(O,Ol,T, {f(Ul) )), ,(o,o,,T,{f(wn.) 
1)). 2. IfKESI,then C,,(O, 0 ) = { (0, 0 3 T, { f(40,O )) 1) 1. The type associated by an abstraction 
may be the iden-tifier of an implementation allowing us to combine sim-ilarity measures depending on 
which source they came from. Other type information may include different fields considered by an implementation, 
or the significant prop-erties of objects for which an implementation gives better results. It is also 
possible to write relevant algebraic op-erations that focus on similarity values associated with a specific 
type. Example 5 In this example we consider the similarity implementations for search engines introduced 
in Exam- ple 3. Suppose now for each similarity implementation pX for a given search engine X, we introduce 
a new type X corresponding to the similarity values returned by this engine. Hence, a simple query of 
the form pHi, ),8,10,,(HDB, Postmodern Culture Netzine ,20) returns the first 20 documents that contain 
the keywords Postmodern Culture Netzine The function y/100 changes percentages to values between 0 and 
1. 2.5 Similarity Algebra We have come to the second level of abstraction in our multi-similarity algebra. 
Recall that in the first level, we abstracted similarity operations with respect to a given type to similarity 
measures. In this section, we intro-duce a set of algebraic operations on similarity measures that allow 
formulation of different methodologies for com- bining multiple similarity computations in a declarative 
language. This will make it possible to develop query re-formulation and optimization methods on top 
of similarity computations. In the following let .F be a family of com- putable functions over sets of 
reals, i.e. each f E F takes as input, a set of real numbers, and returns as output, a single real number. 
Example 6 R.ecall the similarity measures given in Ex-ample 4. The following is returned by the Co&#38; 
function: ColZu(ml, m2,01,02~ 71 U ~2) = { { 0.4,0.6,0.5,0.7} } Definition 2.7 (Similarity Algebra Operations) 
Sup-pose P is a computable predicate over types and hags of reals, and f E FT. Then, the similarity algebra 
operat,ions are defined as shown in Figure 2. Example 7 Recall the similarity measures ml and m2 given 
in Example 4. The followmg are examples of the results of the basic similarity algebraic operations on 
these two similarity measures. mlwu rn2 = {(o~,0~,~1,{0.4,0.6,0.8,0.9}), (01,02,n U rz,{0.4,0.5,0.6,0.7}), 
(01,03,~1,{0.2,0.5,0.6,0.9}), (01,0:3,71 u r2, { 0.2,0.4,0.5,0.9 }), (02,03%71u~~,{0.1,0.2,0.5,0.8})}. 
ml W-rn.2= {(o~,o2,~,{0.4,0.6,0.8,0.9}), (01,oz.r~ -~1,{0.4,0.5,0.6,0.7}), (o1,03:0,{0.2,0.5,0.6,0.9}), 
(01,03:71 -T2,{0.2,0.4,0.5,0.9}), (02~03~~2 -~~,{0.1,0.2,0.5,0.8})}. ml ~3~2 = {(o~,0~,r~,{0.4,0.6,0.8,0.9}), 
(o~,02,r2,{0.5,0.7}),(o1,o3,~~,{0.2,0.9,0.6,0.5)); (02,03:T~,{0.5,0.8}),(01,03,~~,{ 0.4,0.5 }), (02,03,~1,{0.1,0.2})}. 
ml \ 7n2 = 0 Definition 2.8 (Similarity Algebra) Suppose we have some arbitrary, hut fixed set of similarity 
implementa-tions S1. MSA consists of (1) the space of all possihle similarity measures, and (2) the set 
of all similarity ab-stractions P:,~ and FG:,~ (associated with the similarit,y implementations SI being 
considered). hi expression in the similarity algebra is inductively defined as follows: . d,f(DB, 0, 
n) > is an expression in the similarity algebra where DB is a set of objects, 0 is an object, (not necessarily 
in DB) and n is an integer; 0 K:,~(O, 0 )) is a n expression in the similarity alge-bra where 0 and 0 
are objects; l op(ee,..., e,) , is an expression in the similarity al-gebra where op is one of the similarity 
algebraic op-erators and er , . . . , en are expressions of the similar- ity algebra. Some simple examples 
involving the database BW-DB introduced at the beginning of this paper are as follows. (imQ, im) first 
determines the sim- The query Zexture,+ ilarity of imQ and im based on texture, using the simi-larity 
implementation provided by BW-DB. The result-ing set is then combined by merely adding the values in 
Operation Name Notation Definition Sim-Union Join ml wu m2 {(O,O ,r,w) IV= JCollu(ml,mz,0,0 ,7)) Sim-Intersection 
Join ml wn rn2 t(o,o ,T,~)l~= Coll~(mi,mz,O,0 ,r)} Sim-Difference Join ml w-rn2 { (O,~ ,T,ZJ) 1 u = JColl-(ml,mz,O,O 
,7)} Sim-Merge ml em2 (I;~~ ~:,;)IV= Jt~ l(0,0 ,~,u )~mlumz}} Sim-Subtract ml m2 { ) 1 (O,O ,t,2,) Eml, 
P(O,O ,7 ,d) Em21 Sim-Select UP m { (O,O ,T:~J) 1 (O,O ,T,W) 6 m and P(O,O ,7,w ) = true} I/ I ,\,I, 
I \ Sim-Map mwf (ml l\O,O 7,f\v)l I iO,O ,T,VI Em, (fE7) Figure 2: Similarity Algebra Operations the 
set and this is the output. The query p *texture,+ op(el, , e,) , is an expression where op is one of 
(BW-DB, imQ, 5) on the other hand, returns the five the standard nary relational algebraic operators 
and closest matches to imQ using the above criterion. ei , , e, are expressions of the similarity relational 
algebra.  2.6 Relational Multi-Similarity Algebra rMSA Best(n,T,c), is an expression where n and c are 
natural numbers, and T is an expression of the sim- In this section, we will augment the algebra MSA 
so that ilarity relational algebra. it presents a relational interface to the user, even though it manipulates 
non-relational structures underneath. We Example 10 In this example, we consider several rMSAwill add 
two new operators to the standard relational al-expressions involving the Internet search engines. We 
as- gebra. The relational similarity operator RSO will give sume that we have access to three engines, 
namely Ex-a relational view over the similarity measures computed cite, HotBot and Infoseek with corresponding 
similarityby the similarity algebra. The Best operator which is the abstractions p-E*, pH*, p-I* as introduced 
in Example 5. relational analog of the p operator in MSA will make it Then, we write the following queries 
in the MSA algebra: possible to ask rank related queries over multiple similar-ity abstractions. Definition 
2.9 (Relational Similarity Operator) Let f be a function from bags of reals to reals. Then the re-lational 
similarity operator RSO is defined as follows: RSOf(m,T) ={(O,o ,.f(o)) I (o,o ,~,u) EmI. Example 8 For 
example, consider the similarity mea-sure ml in Example 4. Then RSOmin(ml,T1) = {(01,02,O.8),(0~,~~,0.2)}. 
Definition 2.10 (Best n operator) The best n oper-ator Best : N x Table x N -+ Table selects tuples from 
a given table. The expression Best(n,T,c) returns the The first query asks for the first 5 documents 
with respect table containing the maximal n tuples of T, w.r.t. the to the average similarity measure 
computed by both Ex- value of the cth column of T. If there exist two tuples cite and Infoseek and all 
the documents should appear in (ti ,..., tk) and (t; ,..., tk) with t, = tb, then the two the first 60 
documents for Excite. The second query re- tuples are ordered according to lexicographic ordering. turns 
all documents that have 0.8 similarity with respect Example 9 Returning to the example of Example 8, 
we to both Excite and Infoseek. The last query merges the notice that Best(1, RSO,,,(ml, ri), 3) yields 
the single first 20 answers from Excite and HotBot. The similarity tuple (oi,o2,0.8). is averaged if 
the document appears in first 20 of the both engines, otherwise it is divided by half. Definition 2.11 
(Relational Multi-Similarity Alge-bra) The relational multi-similarity algebra consists of 3 Equivalences/Containments 
in MSA and rMSA the space of possible relational tables, together with the relational similarity operator 
RSO, the standard rela-In the previous sections, we introduced a new algebrational operators, and the 
aggregate operator Best. An that allowed us to relate various similarity implemen-expression in the similarity 
relational algebra is induc- tations with relational tables and relational operations. t,ively defined 
as follows: In this section, we will investigate the conditions under which expressions in the similarity 
relational algebra canl RSOf (se, r), is an expression where se is a similar- be rewritten to equivalent 
or more restrictive (throughity algebraic expression; containment) expressions. The results of this section 
will l e, is an expression where e denotes a relational table, be used to develop query optimization 
techniques to lower the cost of query processing by pushing selections down and reordering costly joins. 
We will also use these results to find alternate ways of evaluating queries by reusing the results of 
cached items and by accessing pre-defined views over the sources. When considering equivalences, it is 
particularly im-portant to note that an algebraic expression of the form p* (MDB, o, all) says find the 
top all matches for ob-ject o from MDB , which of course causes all objects in MDB to be returned in 
the appropriate order. In general, similarity implementations are the most costly operations in the MSA. 
Hence the size of the input to these implementations must be reduced by either rcduc-ing the database 
MDB by pushing selections down or by putting additional bounds on the number of objects (all) requested 
whenever possible. It will turn out that selections over objects, values and types have different properties 
and we examine them separately. Let PO, Pv and Pt be predicates over the objects 0, 0 , values u and 
t,ypes r respectively of the members ( 0, 0 , T, II ) of the similarity measures. PO(O) denotes the unary 
predicate obtained by letting the first argument of PO be 0. 3.1 Pushing Selection into Similarity Implementations 
The following theorem tells us that selection is commu- tative. Furthermore, it tells us that when we 
consider selection conditions on values, then selections cannot be pushed inside the p operator. However, 
when selections are made using predicates on objects this is possible and sometimes, the selection can 
even be eliminated altogether. In addition, when selections are performed on types, then the selection 
can always be eliminated. Theorem 1 Consider a multimedia database, MDB. 1. UpUQm = ugffpm for any similarity 
measure m. 2. a~>, (P~,~(DB, 0, n)) does not change since upV cannot be pushed inside P:,~, (no values 
in DB, 0, n). 3.  $.f(DB, 0, n) UP~(P:J(DB, 0, n)) = ,o;,f(opo~o~(DB),O ,n ) 1 :iii ;:,f(DB, 0, n) 
if Pt(T)hold  u~tb:,f(DB,0, n)) = otherwise. where the above conditions are (i) if PO depends only 
on 0 and Po(0) holds, (ii) if PO depends only on 0 and ~Po(0) holds, (iii) if PO depends on both 0 and 
0 and 7~ = all. Also note that p: (upo(o)(DB), 0, n) = P:,~(~P~(o)(DB)>O, I ~~o(oS'B)~i~ 3.2 Pushing 
Object Selections It turns out that selections based on objects can always be pushed through all our 
MSd operations as well as the RSO operations. Theorem 2 Selections can be pushed through all opera- tions 
of the rMSd algebra, i.e. u~,(RS0f(m, T)) = RSOf(up,m, r) uh(ml wop m,2) = (uhml) wp (uhm2) up,(ml f3 
mz) = (uhml) @ (up,mz) uh(mapf (m)) = mwf (oh m) uh(ml \ m2) = (u~,ml) \m2 (u~~ml)\(~~, mz). This result 
has a significant impact on the evaluation of MSA and rMSd queries, as is apparent from the fol-lowing 
example. Example 11 Suppose we have a database DB of pic- tures which, among their attributes, have the 
photogra-pher s name. We want to rank the pictures by Hamilton according to their similarity to a given 
query picture 0. Moreover, suppose that we can use two similarity imple-mentations pA and pB, that return 
similarity evalua-tions with respect to attributes a and b, respectively. We want to combine these measures 
by taking their average values. In the similarity algebra the combined measure can be expressed as follows: 
m = map,U,(pA{,),idDB, 0, all) wu pBit,),;d(DB, 0, all)). If DB contains n pictures by Hamilton, thanks 
to the above equivalences and Theorem 1, the above expression can be rewritten as m = mapalig(pAi,),id(uauthor=Hamtlton(DB), 
0, n) wu ~B?b),id( ~,,thor=~nmilton(DB), 0, n)). Note that, by anticipating the selection, we are able 
to re- strict the search space of the similarity implementations. 3.3 Type Selections In contrast to 
the case of value selections and object selec-tions, type selections are less amenable to being pushed. 
They can be pushed only under certain strong conditions. The following result shows that type selections 
can be pushed through the operator @ that merges similarity measures, and the operator mapf that combines 
results of different similarity implementations. Theorem 3 Suppose ml, m2 are similarity, P(T) is a type 
selection, and f is a computable map in 7. Then: ur>t(ml CDmz) = (uptml) @ (uPtm2) upt(mapf(m)) = mapf(upt)m. 
 In general, selection over types cannot be pushed through a join, i.e. the equality, upt(ml WU m2) = 
(flptml) MU (uPtm2) does not generally hold, as is shown by the following ex-ample. Example 12 Suppose 
that ml and mz are similarity mea-sures containing only tuples with type { a }, and { b } re-spectively. 
Secondly, suppose that ml wu m2 # 0. We have u,={,J, I(ml wu mz) = ml wu m2, but (a,={,,bjnal) WU (ar{a,b))m2 
= 0 WU 0 = 0. Nevertheless, the following theorem shows that under ap-nronriate conditions. the result 
does hold. 1~ ~1 Theorem 4 (Behavior of Type Selection w.r.t. wu) Suppose we consider the case where 
similarity measures ml and m2 have the same type r. Then: upt(m1 Mu m2) = (omm1) wu (OPmt2) The above 
result is very useful when we deal with similar-ity implementations that consider only one property (e.g. 
average RGB values of pixels). Dual results exist when we consider the behavior of type selection w.r.t. 
wn -we state these below for the sake of completeness. Theorem 5 (Behavior of Type Selection w.r.t. MI,-,) 
If all tuples in the similarity measures ml and m2 have the same type r then or+(ml wn 77~2)= (uptml) 
wn (uPtm2). We finally consider type selection w.r.t. W-. Here again, similar equivalence results exist. 
Theorem 6 (Behavior of Type Selection w.r.t. W-) The following are the equivalence results for pushing 
type selections down the sim-difference operator: 1. If, for all 7, r , P(T -7 ) -P(T) A P(, ), then 
upt(m1 W-7n2) = (uptml) w-(uptm2). 2. If the type components in the similarity measures ml and m2 are 
disjoint, then uPt(ml w-m2) = (uptml) w-m2.  3.4 Value Selection In this section, we study the behavior 
of the similarity- selection operator when value conditions are evaluated. The following result shows 
that selection over values may be pushed inside the relational similarity operator, RSO. Theorem 7 Let 
CTJ>~f be the composition of CYP, and f (i.e. (opV f)(u) = cpv(f(u))). Suppose f E F and m is any similarity 
measure. Then: upv(RSOf(m,r)) = RSOf(up, fm,r). oh (mapf(m)) = mwf (oh f m) .  3.5 The Best Match Operator 
Recall that the operator Best(n,T, c) finds the best R matches in T w.r.t. the c th column of T. Usually, 
T is a relational view of a non-relational source -for example, T may be RSO,i, (ml, 71) where ml, ri 
are as defined in Example 4. In this section, we will study various equiva-lences associated with this 
operator. In particular, what we would like to ensure -when later doing query opti-mization -is that 
the similarity implementations (which are usually slow) do as little work as possible. Our study of equivalences 
involving Best will be motivated by this need. The operator Best has good properties with re-spect to 
standard selections, projections, and unions and differences, as illustrated by the following result. 
Theorem 8 (Interaction between Best and Projec- tion,Union, Difference) For any c E 7, it is the case 
that: Best(n,&#38;T,c) = II,(Best(n,T,c )) where c is the col- umn of T corresponding to column c of 
l&#38;T. Best(n,TlUTz,c) = Best(n,Best(n,T~,c)UBest(n,T~,c),c). Best(n,Tl -Tz,c) = Best(n, Best(n+ ) 
T2 [,TI,c) - T2,c). Best(n, RSO,(m, T), c) = RSO,(Be&#38;,m). We observe that Best(n, T, c) belongs to 
the relational al-gebra; when it is pushed inside similarity expressions its parameters must be changed. 
In particular, there is no clear ordering function between bags of real values. We use the notation Best9 
7L,Tm to denote the operator that se-lects the n best matches (w.r.t. similarity measure m and type r) 
after executing function g on the bags of values of similarity measures. This will be the same function 
that is used to perform relational similarity operations. Given bags 11, w of real numbers, we say that 
u 5s w -9(v) 5 9(w). Suppose now that T is a relational table. The follow-ing result presents some containment/equivalence 
results. The first says that pushing Best inside a selection yields a subset of the original query. The 
second result says that when Best and selection interact and the selection condition is a true type-selection, 
then the selection may be eliminated or set to the empty set (hence, this is a highly desirable optimization). 
On the other hand, when performing object selections and Best together, we have a containment result 
in part (1) below. Pushing Best inside a cpO(m) query yields a subset of the answer to the original. 
Thus, if we had previously stored the view Best$,,(up,(m)), and we now want to execute the query cm(Besti,, 
m), then we can execute this selection on the materialized view Best9 n,r(ap,(m)), thus avoiding recom-putations. 
This will be explained in further detail in Sec- tion 4.2. Finally, the fourth part of the theorem says 
that the same property holds for value-selections. Theorem 9 (Interaction of Best and Selections) Best(n, 
upT, c) > up(Best(n, T, c)). Bestz,,m holds,  if Pt(T) BestZ,,(uA,.ptm) = Q) otherwise Best:,, (uhm) 
2 uh(BestZ,,m) Best:,, (up,m) 2 up,(Best$,,m). However, things become rapidly more complex when we consider 
the interactions between Best and the op-erations p*. These interactions describe the conditions under 
which we may push the global best operation to p* which applies to a single similarity implementation 
at a time. Before proceeding to define the interactions between Best and p*, we define two generic conditions 
that we will use. (Cl) &#38; preserves the ordering of real numbers over sin-gletons, i.e., 2 5 y * {z} 
Is { y }; Example 13 All monotonic functions of min/max sat-Example 15 isfy the above conditions. For 
example, g can be c, max(v), max(u)+min(v) max(v) min(zl), c ,c , etc., where c is a positive constant. 
The first part. of the following result tells us that under some easy to check conditions, the computation 
of Best is redundant and can be eliminated. The second result tells us that if both conditions (Cl) and 
(C2) hold, then doing a Best computation on a merged pair of similarity measures is equivalent to performing 
the Best operation on each, and then taking the Best again. Which of these two execution orders is preferable 
will be studied through experiments in Section 5. The last result sa,ys that com-bining sets of rankings 
through function f E F can be either done before executing Best or after. Theorem 10 (Interaction of 
Best, p* and Similarity Measures) Z d,f(DB, 0, k) if n 2 k = /I:,~(DB, 0, n) if n < k and (Cl) holds. 
BestY,,,(pZ~,f (DB,O,Ic))=@ifr#r Bestz,,(ml &#38;i mz) = Best$,,(BestZ,,(ml) 69 BestiT,,( if both (Cl) 
and (C2) hold, Best~,,(mapyrn) = mapf(Besti;:m) The use of the above theorems for query optimization 
is illustrated by the following example. Example 1.4 Bc:st(n, RSO,ax(u,={ a } (ml)~(T,={b}(m2),{a}),3) 
= = RSO,,a,(Best~ ,~, l (BestE,i; , 1 (oT=( a 1 (ml)) cT~ Bestz ,ya 1(a,={b}(m2)),ta)) = RSO,,,( Best:,?, 
j (Best:,% }(ml) @ 01, {a 1) = RSO,,,,(Best~,aix,~(Best~,~,~(ml)), {a}) Note that the calls to the similarity 
implementations in mz and one of the selections have been removed. The following result specifies the 
relationship between Best and the different types of join. It says that under certain conditions, performing 
Best after doing a similar- ity join is the same as performing Best first on each of the similarity measures 
being joined, then joining the results, and then repeating the Best operation. Best&#38;,(@T= Theorem 
11 (Interaction of Best with Similarity Joins) Suppose f is monotone w.r.t. Is and (Cl) and (C2) hold. 
Then: Best$i,,(ml w,,mz) = - -71OP 2 Be%,, (ml) MOP BestR,,,(mz)). = Best$,,(@ = Be.%,,, (ml) wop r 
T1 OP ?2 Be&#38;,( Be%,,,(m))). The following example shows some uses of these results in optimizing 
some simple queries. Be.St;:$&#38;d?;b >(DB, 0, au))) Be&#38; ;,,b j (Best; ;, j (PA; a l (DB, 0, d)) 
MU fkt;yb l (p-Byb ) (DB, 0, ~zz))) BeSt;:; ,,b j (PA; a 1 (DB, 0,5) Wu p ; b } (DB, 0,5)) 4 Cost Model 
for MSA In this section, we will consider a cost model for query processing using MS&#38;. In this model, 
we make the fol- lowing assumptions. First, we assume that all similarity implementations are linked 
to the query processor as for- eign functions. On the average, the cost of executing sim-ilarity implementations 
is an order of magnitude higher than the cost of joining tables in the similarity algebra. In general, 
the number of similarity implementations exe-cuted per query is a negligible number in comparison with 
the number of objects. Hence, we will ignore the cardi-nality of the set of similarity values in similarity 
imple-mentations for cost estimation purposes. This is certainly a reasonable assumption ~ for example, 
when considering Internet scar&#38; engines as in I.SEE, the number of search engines is negligible when 
compared to the number of ob- jects (web pages) accessible through the search engines. 4.1 Cost Estimation 
in the Similarity Algebra First, we will estimate the cost of execution for similarity algebra operations. 
We recognize that the cost of simi- larity implementations is the bottleneck of the operations performed 
in the similarity algebra. For example, in the face recognition example, the face recognition software 
is the one that is a bottleneck -similarly, in the case of the Internet search engine, most computation 
time consumed is in the access and execution by the Internet search en-gine -this includes both the connect 
time and the execu-tion time. We will model their cost with respect to the similarity abstractions computed 
on top of them. Definition 4.1 (Cost Estimate) Suppose m is a sirni- larity measure. A cost estimate 
of the tuples in m of the form ( 0, O , 7, s ) is a triple ( card, T, g ) where card is a set of pairs 
of the form (r,~) (denoted by card,), such that ZI is the expected cardinality of the pairs of type T, 
T is the expected time cost of computing all the tuples in m, and (T is the expected number of different 
objects 0 . Givenacostestimate({(71,,~~I),...,(~~, Uk)},T,~)ofa similarity measure, the expected cardinality 
is given by the following expression c:=,v,. Supposn ml is t,he similarity measure given above and (((71 
j 2): (~1,3)}, 20, 2) is a cost estimate for 7121. Accord- ing to this estimate, we expect at most 2 
objects of type ~1 and 3 ol)jccts of typcl r~. The expected number CT= 2 indi- cates that, there are 
at most, two different, objects, possibl,v corresponding to thr sum of objects ret,rirved by similar- 
ity irrlplf:mt~ntations. Finally, the expected tirne is T = 20 assuming 5 t,inie units for t1ac.h tuple 
in lr61 - note that all four tuplrs in ml are considered when deriving 20 here because each of them must 
be taken into account when retrieving ohjccts asso( i;lt cd with tvpc ~1 The cxpc~~tcti cardinality of 
t,his cost c&#38;mate is 2 + 3 = 5. The cost estimate of a similarit,y abstraction P:,~(DH, 0; 7~) is 
given by the csxprcssion: ({ (T, tnir1(n, IDSI)) }, f,(T,7rri7?(rr. lDOl)), n) for sornc f unct,ion f,, 
that is monotonic.atly lion-(Iccrc~asing in its sccw1tl argument,. R.ecall t,hat, P:,~(DB, 0. 7~) is 
a rc- quest saying Find t,hc t,op 11 matches for object 0 in the database DU, using 7 and S to define 
the concept, of a best match (as described earlic>r in the paper). Only a single type is returned by 
t.hc> similarity abstraction and the ex-pectctd number of objects 0 is rrG71(72, IDBl). Sirnilarly, cost 
parameters for a similarity abstraction K:,~(O, 0 ) are given by t,he triple: ( { (T, 1) }, cX, 1). The 
explana-t.ion for this is that wr merely want to see how closely objects 0, 0 are matched, and this can 
be done in COII- st,ant time, for some constant, c,. We now examint! thtl cost of sirnilarity algebra 
opera-t,ions. Let, rr~, and 1~2 ?)e similarity measures with asso-ciated cost vectors (cl, Tl, ff~i ) 
and (~ 2, Tz, (~2 ). Suppose (5-I, lil) E cl represents a tuple in cl and (72, wz) E ~2 rep- resc,nts 
a tuplc in ( 2. The following table shows how we can estimate thf: cardinalit,ics and select,ivities 
of algebraic operations applied t,o trill , rnz. Due to space constraints, we will not go into their 
det,ailed derivations.  4.2 Query Optimization in rMSA III this section, we discuss the basics steps 
involved in optimizing queries in rMSA. We first define the concept of a query tree, and then provide 
various operations that transform query trees int,o equivalent,; simpler query trees. 4.2.1 Query Tree 
Given a query formulated in t,he correct algebraic form, we construct a query tree for this expression. 
An rMSA query t,ree is very similar to a relational query trcle, but, it also includes t,hc similarity 
algebraic operators. Definition 4.2 (Query Tree) A query tree associated with an ,rMSA query &#38; is 
a labeled directed acyclic graph GQ = (V, L, E) with a unique root where V, L, E are set of vertices, 
labels and labeled edges respectively. Edges are denoted by (nl 4 nz) for some 721, n2 E V and e E L. 
A11 admissible query trrc GQ satisfies the f(,ltowing conditions. (1) All leaves correspond either t,o 
a data.basr table or a similarity abstraction. (2) All labels in GQ con- tain rxpressions involving selection, 
projection, plus sim-ilarity abstraction, Sim-Set&#38;, Sim-Map, Best and RSO operators. Labels may also 
be equal to X which indicat,es no selcct,ion operation to be pc rformcd at that labc~l. (3) If ~1is a 
node with both incoming and out,going edges ( intc- rior node ), then u corresponds to tither a sirnila.rity 
op-crater (with the exception of Sim-Select, and Sim-Map). a rc~lat,ionaI join operation or a special 
operator called a sirnilarit,y view (denoted by SV). Intuitively, a similarit,y view is a similarity 
algebra query that has been previously c.omput,ed and stored. T(U) denotes the set of edges con- tainctl 
in the suhtrer root.rJd at vertex u in a query graph G. Hence. an odge (T!, -% ,I,,) E T(a) if vertex 
01 is rea.ch- able from vertex II. If ~1 is rcachablc from u and if t,here is an f>figc from 01 to vz, 
then t,his edge is in the subt,rcc rooted at II. The construct,ion of an initial query tree from a given 
yucry is straightforward. However, in gem ral this tree must be reorganized to lower the cost of query 
process-ing. To this end, we will introduce tree manipulation operators. Due to the high execution cost 
of sirnilarit,y implementations, WC want subox- to make use of corr~111011 pressions as much as possible. 
This requires identifying common equivalent subexpressions in a query, treating those common equivalent 
suhcxpressions as views, and materializing them to avoid redundant computation. The t,ree compaction 
operator introduced below handles this case. Definition 4.3 (Tree Compaction) Let G = (V, L, E) be a 
query t,ree and let the edges (n, 4 no), (7~: s 7~;) be elements of G such that n2 is not a leaf node. 
The relation 1~ 5 n; holds whenever the query corresponding to the subqucry of na is equivalent to the 
query corresponding to the subquery of 71;. The t,ree compaction operator TCO, returns the following 
graph whenever 71%c n,;: TCO,(E, (711 i nz), (n; 5 76;)) = (E U X) -T(nL) -({ (7L; 5 7&#38;),(7L1 i m)}). 
x s = ((711 4 SV),( n; % SV), (SC + na) } if e # e { (7~1 1 SV), (71: 1 SV), (SV 4 nz) } if e = 6 . I 
Intuitively, the above tree compaction operator looks at t,wo edges, (nl 5 ~LZ) and (n , 5 r&#38;) in 
the graph where 7~2 and 71; are equivalent. We have already provided a comprchcnsivc list of equivalent 
queries in earlier parts of this paper. The TCO operator then treats nz as a similarity view SV that 
is computed only once. It then reconstructs the tree by appropriately replacing explicit calls to n2, 
n; by SV and ensuring that the view itself is computed in the tree once (and only once). The significance 
of the tree compaction operator is the detection of common subexpressions that can he cached ad re-used 
for query processing. A similar tree com- pact.ion operator can also be defined for the subsumption relation 
(C) that does not guarantee equality. The TCOc operator can be used in conjunction with the containmen? 
preserving query rewriting methods to reduce the cost of retrieving first set of tuples. In either case, 
we need to use query rewriting methods that depend on syntactic or se- mantic description of query contents. 
Such methods were discussed in the literature for different applications [2, 161. Extending these m&#38;hods 
to the similarity algebraic op- erations is beyond the scope of t,his paper. In addition to the tree 
compaction operator, we use the traditional selection push operators below join oper-at,ions. The intended 
gain in pushing selections is the reduction of the number of tuples processed. The lrgal selection operations 
were discussed in Section 3. The im-portant point to note is that a selection is pushed down a node n 
if n has a single incoming edge. If two nodes are pointing to the same common subexpression T(n) when 
a selection operation was pushed down, then T(n) must 1,~ duplicated and the expression must be pushed 
only for the appropriat,e node. Hence, pushing selections have the obvious effect of reducing t,hc number 
of mmmo~~ subex-pressions. 4.2.2 Computing with Similarity Abstractions In this section, we discuss possible 
optimizn.tions for the execution of similarity abstractions. We assume that for large numbers n, all 
answers to an expression of the form /I:,~(DB, 0, /I,) will be rd,urned in a nontrivial time inter-val. 
As similarity computations are usually very costly, the rest of the selection operations can be interleaved 
with the retrieval of similarity attributes. In this model, the query processor should st,op the execution 
of a similarity implernelltat.ion when the necessary conditions have been met to evaluate t,he rest of 
the query. We first define the notion of a similarity abstraction filter. Definition 4.4 (Similarity 
Abstraction Filter) Let 0 be a select,ion operation involving sim-map, sim-select, and Best,,, i\ similarity 
abstraction filter associated with c is a function of the form Z(V) > lh where Zb is a constant and Z(V) 
preserves ordering of real numbers with respect to singleton sets such that whenever Z(U) 2 Zh is false 
for a set of values 71, then the selection condition o evaluates to false for U. Similarity abstraction 
filters need not always exist. For them to be calculated, o should involve selections over values. As 
we will XC in the implementation sec-tion, the existcncr of query filters introduce great savings in 
query response time. suppose cost( ]DB(, n) character- izcs the execution cost of P~,~(DB, 0, n), costconv(]DB]) 
is the cost of creating index structures necessary for exe-cuting p and the cost of 0 is ci. Pushing 
selections into similarity abstraction offers four possibilities: 1. Push selection if possible to create 
an int,ermediate table, execut,e p on this table. o(~:,~(DB, 0, n)) = P;,~(u(DB),O, 7~). E xecii, t ion 
cost of p:,?(a(DB), 0, n) is ci + cOstcono (Ia(D 0, 71) + fmst(u(~DBI), 7x). 2. Push selection if possible 
into p to create a modified  similarity implementation execution. In this case, the se-lection is performed 
at the database that is computing the u function, hence the query is optimized for execution as a whole. 
o(p*((DB, 0, n)) = P:,~(~(DB), 0, n). Execu-tion cost of p:,f(a(DB), 0, n) is cost(a(]DB]), 7~). 3. No 
push is possible since the database DB does not support selections and all the objects are retrieved 
from DB via similarity implementations. The: execution cost of a na.ivc implernentation is then u(~:,~(DB,O, 
7~) = cost(lDBI,n) + cl. 4. Supposc selection cannot be pushed down, but there exists a similarit,y 
abstraction filt,er Z(U) > Ib associated wit,h cr. If f is an order preserving function, then p* is comput,ed 
until ~(1)) > Zb becomes false. We denote this operation with (T([z, Zb](p:,f(DB, 0, n)) The worst case 
cost of this execution is the same as the previous case. Experimental results are provided to show the 
average behaviour of the filter operation. Suppose now we are computing the following join exprcs-sion 
+T,.fl Mop ~;,,f~ ) Two new optimizations for this operation are introduced below:  Join Cardinality 
Filter: Suppose (T = Be&#38;$,, such that 9 is an order preserving function over bags of two real numbers. 
In other words, whenever ~1 < *UZ and PJQ 1. 7~4, then g({ ~i,r~ }) _< g({ va, ~4 }). Then,% both fi 
and fz are order preserving relations, replace the above join with the following filter join: The join 
cardinality filter is executed as follows. The ex- ecution of similarity operations are performed in 
stages, where in each stage, the join is performed and the best elements are chosen after g is executed. 
R.ecall that g is a function that operates on bags of reals and returns a real as output. Suppose z is 
the nth highest value found so far in the join with respect to function 9, {hi} is the highest element 
in p:, ,f, that did not contribute to joined tuple, and (11) is the lowest element in the bags computed 
by /I:, ,f,. The same is true for {J&#38;z} and (12) as well. The cardinality join filter will request 
the next set of similarity abstractions if either g({lLi, 22)) 2 z or y({hz,li}) 2 x is true. At the 
end of every step, the high and low values will be updated. Join Value Filter: Suppose there exists a 
relation of the form y(vi, ~2) 2 lb where Zb is a constant and y is an order preserving function over 
bags containing two real numbers such that whenever this relation evaluates to false, u is not satisfied. 
Then, if both fi and fi are order preserving relations, replace the above with the following filter join: 
The join value filter is executed similar to the join cardi-nality filter, where the execution of similarity 
abstractions is stopped when both y({hi}, (12)) > 10 and y({hz}, {Ii}) > Zb evaluate to false. Intuitively, 
both of the filters take advantage of the fact that similarity implementations return the answers in 
the descending order of similarity for the metric that they are using. The cardinality filter checks 
if it is pos- sible to obtain a better answer in the join from the un- matched elements in the set. The 
join value filter checks if the joining tuples will no longer satisfy the selection condition. This is 
the important motivation for pushing selections down as much as possible. In general, it is very hard 
to generate filters for arbitrary functions. However, we assume that functions that are not combinations 
of the average, min and max functions are complex operations that need to be implemented and linked to 
the algebraic query processor. It is also possible for filters to be defined for these functions in a 
declarative way. The query pro- cessor can then choose these filter definitions and derive combination 
filters when necessary. As in any algebraic system, the query optimization process consists of rewriting 
queries using the available operators such that the query with the lowest estimated cost can be found 
and executed. As the space of all pos- sible rewritings can be prohibitively large, certain heuris-tics 
can be developed to explore and prune the search space. Even though pushing selections down as much as 
possible is almost always desirable, this operation re-duces the amount of common subexpressions that 
can be combined into one. However, checking equivalence and containment between subgraphs of a graph 
is a very costly operation. Involved containment checks are more suitable for fixed queries that are 
optimized at compile time. In general, query optimization can be solved by any directed generate-and-search 
algorithm with a pre-determined heuristic benefit function. 5 Implementation and Experiments In this 
section, we will describe the current implementa-tion of the similarity algebra on top of the ISEE (Inte-grated 
SEarch Engine) system that is being built at Rens- selaer Polytechnic Institute. I.SEE provides a common 
interface to query interfaces of multiple search engines. Detailed search queries are posed in a generic 
language with the help of explicit menu items. These queries are in turn rewritten by relaxation to match 
the capabilities of the underlying search engines. In addition, ISEE exe-cutes all the translated search 
queries in parallel and then merges the results with respect to the relevant similarity algebra expression. 
More detailed information on I.SEE can be found at www.cs.rpi.edu/research/isee/. The implementation 
supports all similarity algebra op-erations, as well as Best, RSO and relational selection operators. 
Only functions allowed in mapf and RSO operators are min, max and average. All the similar-ity abstractions 
are assumed to contain order preserving operations. The optimization heuristic performs query compaction 
only on the individual similarity abstractions. The selections are pushed as much as possible and joins 
are replaced by filter joins whenever it is possible. Fig-ure 3 shows an example query session from ISEE. 
The query posed in this example is the first query given in Example 10. Below, we give experimental results 
showing the util- ity of query optimization in similarity algebra operations. The results corresponds 
to the three queries given in Ex- ample 10. Each query is shown executed for the string, Figure 3: Query 
1 in ISEE Alexandria Library . For each query string, two query plans are considered. The first is the 
results of naive query evaluation without any optimization. The second evalua- tion is a query plan that 
makes use of filter joins. For each query, the rewriting is given below. Note that no filtering is possible 
for qa since there is no selection condition on it. However, in this case it is possible to reduce the 
common subexpressions. We now give the experimental results corresponding to the execution of these two 
queries. 41 = ~51,s3(RSOavg(Best~~~~~,I l * (EDB, 0, all) (P{ E },x/loo (av9>lnl) wu Pi 1 >,,,u&#38;DB, 
0, GO)), { E> I}), 3)). qz = ~Iol,$3(RSOmin(cr$m4>0.8i~(pi ,tz l,z+oo(EDB, 0, all) [min,0.6] NJ Pi,~,~,loo(lDB,O,all)),{E,I}))) 
 q3 = J&#38;l,s3(RS0,,,((SK wu SK), { E, H})U RSO&#38;(SK \ S%), { E}) u RS0,/2((% \ SK), {H})) SK = 
P; E l,x,loo(~DB, 0,201 Sv2 = P;H >,,,loo(EDB, 0,201. # Network # Tuples Execution Query String Connections 
Processed Time Alexandria Library Querv 1. Naive 106 63000 2.54.7s . 1 Query 1, Rewritten 47 30240 107.8s 
Query 2, Naive 106 63000 252.8s Query 2, Rewritten 40 8303 83.2s Query 3, Naive 12 1118 7.3s Query 3, 
Rewritten 4 1118 7.2s The table above illustrates the following points: First, using our query rewriting 
strategies, the number of re-quested network connections decreases substantially, as does the number 
of tuples processed. The total time re-quired to process our queries does decrease substantially as a 
result of query rewriting. However, query rewriting is not always effective. For example, in the case 
of query 43, the similarity union-join wU was empty, leaving little room for optimization. In general, 
we have noticed that the expected number of objects after a join operation was a significant factor in 
optimization. This figure was also very hard to estimate for arbitrary query strings, such as Postmodern 
Culture Netzine . Nevertheless, we could cut the time required to process queries in half using our query 
optimization methods in most cases. 6 Conclusions and Related Work Most existing similarity retrieval 
algorithms assume that the notion of similarity is fixed, and that user queries are processed against 
this fixed similarity metric. In prac-tice, however, there are many applications of similarity based 
retrieval (e.g.document retrieval through Internet search engines are the best known example) where there 
are many different indexes and algorithms for similarity based retrieval. This is also true (to a slightly 
lesser ex-tent) in image retrieval domains where multiple image processing algorithms often retrieve 
data in multiple ways according to multiple notions of similarity. Our aim in this paper was two-fold. 
First, to provide an algebraic framework within which users can access not just one, but several similarity 
implementations, and mix and match the results of such accesses within a single algebra. To date, there 
has been little work on developing a version of the relational algebra for images/text. Our architecture 
applies to not just one, but many such implementations and so does our algebra. In addition, our algebra 
extends the relational algebra rather than start from scratch, thus making it present a relational interface 
to non-relational structures -thus, it is consistent with prevailing trends in industry to add datablades 
, extenders , and car-tridges to relational DBMS systems to extend their capa-bilities. Our second goal 
was to develop ways of optimiz- ing queries over such similarity based retrieval engines. We accomplished 
this by proving a set of equivalences be-tween queries (which in turn lead to query rewrite rules) in 
the rMSA. Later we defined query trees and showed how query trees may be transformed through specialized 
operators such as the tree compaction operator, similar-ity abstraction filter based optimizations, join 
cardinality filters, and join value filters. By transforming query trees using these operations, we may 
rewrite a query tree into an equivalent one and use our cost model to choose the best. Last, but not 
least, we have developed a prototype application of our algebra to develop an Integrated Web Search Engine 
(I.SEE) based upon which we have vali-dated the experimental benefits of our approach. Most existing 
research on similarity based retrieval to date falls into three classes. The first class aims at defining 
what constitutes similarity, and has been stud-ied by many researchers in the context of text/document 
data [6, 17, 1, 11, image data [3, 9, 11, 141, and audio data [5]. Santini and Jain [15] provide a good 
overview of different, approaches to similarity. The second class of work involves ways to index media 
data to support similarity-based retrieval -these include data structures such as those in [4, 9, 131. 
The third class includes pro-viding abstract models of similarity as elegantly devel-oped by Jagadish 
et. al. [12]. Chaudhuri and Gravano [8] were the first to suggest ways of optimizing multimedia queries 
using a cost, based model of such queries. Carey and Kossmann [7] introduced an SQL operator analogous 
to Best named stop after for relational queries that aims to reduce the cardinality of input streams. 
Our work, in contrast, provides an algebra for multiple similarity en-gines to be integrated ([lo] also 
makes a proposal for this in the context of Internet Search Engines, but provides no algebra or equivalence 
results) and provides provably correct query rewriting methods, and query optimization techniques. References 
<RefA>[I] S. Adah, C. Bufi and Y. Temtanapat. Integrated Search Engine , to appear in the Proc. of 1997 IEEE 
Knowledge and Data Engineering Exchange Workshop, KDEX 97. PI S. Adah, K.S. Candan, Y. Papakonstantiuou 
and V.S. Subrahmanian. Query Caching and Optimization in Dis- tributed Mediator Systems , Proc. of the 
1996 Sigmod Conference on Management of Data, pp. 137 -148. PI M. Arya, W. Cody, C. Faloutsos, J. Richardson 
and A. Toga. (1995) Design and Implementation of QBISM, a 3D Medical Image Database System , in: (VS. 
Snbrah-manian and S. Jajodia, eds.) Multimedia Database Sys-tems: Issues and Research Directions , Springer 
1995. [41 S. Berchtold, D. A. Keim, and Hans-Peter Kriegel. (1996) The X-tree : An Index Structure for 
High-Dimensional Data , Proc. 1996 Intl. Conf. ou Very Large Databases, Bombay, India, pps 28-39. [51 
T. Blum, D. Keislar, J. Wheaton and E. Wold. (1995) Audio Databases with Content-based Retrieval , Proc. 
1995 IJCAI workshop on Intelligent Multimedia Informa-tion Retrieval, Montreal, Canada. PI E.W. Brown, 
J.P. Callan and W. B. Crof. (1994) Fast Incremental Indexing for Full-Text Information retrieval , Proc. 
1994 Intl. Conf. on Very Large databases, Santiago, Chile, pps, 192-202. [71 M. J. Carey and D. Kossmann 
(1997) On Saying Enough Already! in SQL. Proceedings of the 1997 Sig- mod Conference on Management of 
Data, pp. 219-230. PI S. Chaudhuri and L. Gravano. (1996) Optimizing Queries over Multimedia Repositories 
, Proc. 1996 ACM SIGMOD Conf. on Management of Data, pps 91-102. PI C. Faloutsos. (1996) Searching Multimedia 
Databases by Content , Kluwer Academic Publishers. [a L. Gravano, C. Chang, H. Garcia-Molina and A. Paepcke. 
STARTS: Stanford Proposal for Internet Meta-Searching , SIGMOD 1997, pp. 207~218. 1111 V.N. Gudivada 
and V.V. Raghavan. (1993) Design and Evaluation of Algorithms for Image Retrieval by Spatial Similarity 
, ACM Transactions on Information Systems, 13.1. nns 115-144. I II. [121 H. V. Jagadish, A. Mendelzon 
and T. Milo. Similarity-Based Queries , Proc. of ACM PODS 1995, pp. 36-45. f131 K.-I. Lin, H.V. Jagadish 
and C. Faloutsos. (1994) The TV-Tree: An Index Structure for High-dimensional Data , VLDB Journal, 3, 
pps 517-542. u41 W. Niblack, et. al. (1993) The QBIC Project: Query-ing Images by Content Using Color, 
Texture and Shape , IBM Research Report, Feb. 1993. 1151 S. Santini and R. Jain. (1996) Similarity Matching 
, to appear in: IEEE Transactions on Pattern Analysis and Machine Intelligence. [I61 X. Qian. Query folding. 
In Proceedings of the Twelfth International Conference on Data Enginnering, 1996. [17] A. Tomasic, H. 
Garcia-Molina and K. Shoens. (1994) In-cremental Updates of Inverted Lists for Text Retrieval , Proc. 
1994 ACM SIGMOD Conf. on Management of Data, Minneapolis, pps 2899300.</RefA>  
			

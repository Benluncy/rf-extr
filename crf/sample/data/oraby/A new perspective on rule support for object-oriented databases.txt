
 A New Perspective on Rule Support for Object-Oriented Databases* E. Anwar L. Maugis S. Chakravarthy 
Database Systems Research and Development Center Computer and Information Sciences Department University 
of Florida, Gainesville, FL 32611 shanua@snapper. cis. uf 1. edu Abstract This paper proposes a new approach 
for supporting reactive capability in an object-oriented database. We introduce an event interface, which 
extends the conventional object semantics to include the role of an event generator. This interface provides 
a basis for the specification of events spanning sets of ob­jects, possibly from different classes, and 
detection of primitive and complex events, This approach clearly separates event detection from rules. 
New rules can be added and use existing objects, en­abling objects to react to their own changes as well 
as to the changes of other objects. We use a runtime subscription mechanism, between rules and objects 
to selectively monitor particular objects dynamically. This elegantly supports class level as well as 
instance level rules, Both events and rules are treated as first class objects. 1 Introduction The need 
and the relevance of reactive capability as a unifying paradigm for handling a number of database features 
are well-established. Most of the earlier re­search on active databases and commercial implemen­tations 
have concentrated on the support for active ca­pability in the context of relational database systems 
[Ct89, SHP88, WF90, DB90, Int90]. Recently, there have been a number of attempts [GJS92, GJ91, DPG91, 
MP90, CHS93, Anw92, SKL89] at incorporating event and rule support into an object-oriented database man­agement 
system (OODBMS). Clearly, there is a paradigm shift when we move from the relational model to an 00 one. 
This warrants re­examination of the functionality as well as the mecha­nism by which reactive capability 
is incorporated into the 00 data model [BM91]. Below, we enumerate some *This work was supported in part 
by the NSF Grant (IRI­9OI 1216), by the Office of Naval Technology and the Navy Command, Control and 
Ocean Surveillance Center RDT&#38;E Division and by Sofr4avia, Paris, France. Permission to copy without 
fee all or part of this material is granted provided that the copies are not mada or distributed for 
direct commercial advantage, the ACM copyright notice and the title of the publication and ite date appear, 
and notioe ia given that oopying is by permission of the Association for Computing Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. SIGMOD 151931Washington, DC, USA 
e 1993 ACM 0.89791 .592.5/93/0005 /0099 . ..$1 .50 of the differences between the data models that led 
to the design choices presented in this paper: 1. In contrast to a fixed number of pre-defined primitive 
events in the relational model, every method/message is a potential event, 2, The principle of encapsulation 
and further the dis­ tinctions between features supported (e.g., private, protected, and public in C++) 
need to be accounted for; this is orthogonal to both the access control issue and global nature of rules 
in the relational database context, 3. The principle of inheritance (both single and multi­ple) and its 
effect on rule incorporation, and 4. Scope, accessibility, and visibility of object states for rules. 
 Furthermore, the following performance issues were con­sidered: 1. Effect of rule specification only 
at class definition time and its activation and deactivation at runtime. This entails changing the class 
definition every time rules are added or deleted, 2. Rule management. For example, cost incurred in 
as­sociating class level rules (rules that are applicable to every inst ante of a class) and other types 
of rules, and 3. Event management. For example, cost incurred for event detection (both primitive and 
complex) as the number of events can be very large in contrast to the relational case.  The approaches 
taken so far for incorporating rules into an 00DBMS can be broadly classified into: i) specifica­tion 
of (parameterized) rules only at the class definition time (allowing binding of a rule to an instance, 
its ac­tivation, and deactivation at runtime) and ii) rule cre­ation, activation, deactivation, and binding 
at runtime. The first approach is motivated by efficiency considera­tions and keeps the runtime processing 
(not necessarily the overhead for rule processing depending on the im­plementation) low and does not 
require any new classes for supporting rules. All specifications are pre-processed into the code of the 
host language, The primary draw­back of this approach is that the integration is some­what ad hoc and 
provides little or no support for the runtime specification of rules. On the other hand, the second approach 
tries to accomplish everything at run­time thereby incurring a reasonable amount of overhead. In this 
approach, it is cumbersome to make a rule appli­cable to only a small number of inst antes. To the best 
of our understanding, Ode [GJ91, GJS92] has taken the first approach and ADAM [DPG91] the second one. 
It is likely that the environments used by these two systems (C++ and PROLOG, respectively) have been 
a factor for the approaches. 1.1 Cent ributions In this paper, we take the view that the two approaches 
outlined above represent two end points of a spectrum; individually, neither approach fully meets the 
function­ality and seamless 1 requirements of rule support for an 00 database. Our approach clearly separates 
the mod­eling issues from the implementation choices. As a re­sult, the functionality of our system is 
not diet ated by the environment although the implementation choices are to a large extent influenced 
by the environment cho­sen (C++ in our case). Our approach synthesizes the advantages of both the approaches 
outlined and further extends them in sev­eral significant ways. Briefly, we support rules that are specified 
at class definition time (Ode style) and rules that can be constructed at runtime (ADAM style) and compile 
both using a uniform framework. In addition, we support primitive events and event operators for con­structing 
complex events as first class objects. We also support rules as first class objects. Most importantly, 
we introduce a monitoring view­point (termed external monitoring viewpoint) that is not present in either 
Ode or ADAM. This viewpoint permits: i) rule definition to be independent from the objects which they 
monitor, ii) rules to be triggered by events spanning sets of objects (inter-object rules), possibly 
from different classes, and iii) any object to dynamically determine which objects state changes it should 
react to and associate a rule object for reacting to those changes. We present an implementation of this 
external monitoring viewpoint in the 00 framework. We consider this generalization extremely important 
as the expressiveness and the extensibility of the result­ing system is significantly enhanced (Ode has 
tried to implement the functionality of inter-object rules in a straightforward manner by making the 
same set of rules applicable to more than one object class [J Q92]). This feature enables the seamless 
integration of rules as well. The remainder of this paper is structured as follows. Section 2 provides 
the motivation for our approach. In section 3 we provide the design overview and the ra­tionale behind 
it. Section 4 provides implementation details. In section 5 we contrast the functionality of our system, 
Sentinel, with Ode and ADAM through an il­lustrative example. Section 6 briefly describes Ode and Adam 
leading to a back-of-the-envelope comparison and future research directions in section 7. 1By seamless 
approach we mean that the concepts pro­posed blend homogeneously into the paradigm into which they are 
introduced without circumventing the tenets of the paradigm. 2 Mot ivat ion The design and implementation 
of rules in Sentinel was primarily motivated by the following limitations of the extant systems: Although 
current approaches allow a rule to moni­tor one or more instances of the same object class, a rule is 
triggered by changes occurring to only one of the instances it monitors. To enhance expressive­ness, 
support for rules which are triggered by changes occurring to one or more inst antes, possibly from dif­ferent 
classes, is necessary,  Some systems permit rule specification only within class definitions. This will 
lead to difficulties when rules are added, deleted, or modified, since inst antes of these changed classes 
may be previously stored in the database. This compromises the extensibility of the system since the 
addition of rules is not divorced from the behavior of pre-existing objects and methods in the system, 
 Rules and events are not always treated as first class objects, thereby resulting in a dichotomy between 
them and other objects. Rules and events cannot be added, deleted, and modified in the same manner as 
other objects. Furthermore, they are not subject to the same transaction semantics. Finally, their persis­tence 
is dependent on the existence of other objects, and  Specification of events and the mechanism by which 
they are detected. Although Ode [GJ91] supports the specification and detection of complex events, the 
manner in which they are supported prevents express­ing events spanning instances of the same as well 
as different classes. Furthermore, events can only be de­fined within a class thus perpetuating the problems 
outlined above.  2.1 Need for External Monitoring Viewpoint In a number of applications, such as patient 
databases, portfolio management, and network management, mon­itored and monitoring objects are often 
defined not only independently but at different points in time. For ex­ample, when a patient class is 
defined (and instances are created), it is not known who may be interested in monitoring that patient; 
depending upon the diagnosis, additional groups or physicians may have to track the patient s progress. 
Similarly, stock objects may have to accommodate a varying number of objects (e.g., portfo­lio) that 
may be interested in their state (e.g., price) for buying and selling purposes. That is, there is a need 
to monitor pre-defined objects, preferably, without having to change their class definitions for that 
purpose. For example, there should not be a requirement that the stock object itself modifies its attributes 
or behavior for a new portfolio object to monitor it. If one has to declare all the rules that are likely 
to be associated with an object at the class definition time, clearly, the above application requirements 
cannot be supported (as that information is mostly not available at the object definition time). Even 
if one were to allow rule definition at runtime on a clam, if the rule firing is restricted to only events 
of the same class, then also the above application requirements cannot be adequately supported. Consistent 
with the notion of encapsulation, it is im­perative to support the above requirement through an interface 
(analogous to the traditional interface for ob­jects). We introduce an event interface for this pur­pose. 
It is equally important to separate the (visible) event interface from: i) its implementation and ii) 
the use (or invocation) of that interface by other objects. The event interface needs to be defined (or 
revealed) at the class definition time whereas its use needs to be supported at runtime. Below, we give 
an example of how the external monitor­ing viewpoint also supports one or more objects to be monitored 
by a rule preserving both encapsulation and independent persistence, Stock IBM; portfolio Parker; FinancialInfo 
DowJones; rule Purchase : when IBM+ SetPrice And DowJones+SetValue if IBM+ Price < $55 &#38; DowJones+Change 
< 3.4~o then Parker+ PurchaseIBMStock In the above example, three classes are defined, namely, the Stock, 
Portfolio, and FinancialInfo classes. A rule, Purchase, is defined independently of these three classes 
and monitors two objects, viz; the IBM Stock object and the DowJones FinancialInfo object. The rule is 
triggered when events spanning these two objects are generated, specifically, when the IBM object invokes 
the method Set Price and the DowJones object invokes the method SetValue. The condition then checks the 
IBM stock price and the percentage change in the DowJones value. If the condition is satisfied, the Parker 
Portfolio object purchases IBM stock. We discuss how the above rule is specified and executed in a later 
section. Design Rationale Our design choices, substantiated in the remainder of this section, can be 
summarized as follows: 1. Augment the interface of conventional C++ objects with an event interface which 
has the ability to raise and propagate events occurring on their state, providing encapsulation, 2. 
Support primitive events, event operators, and rules as first class objectsz, 3. A11ow rules to be triggered 
by events spanning several objects, 4. Allow an object to dynamically specify which objects to react 
to in response to their state changes, and  2Even rules that are declared as part of the class defini­ 
tion are translated into instances of rule objects; of course, there existence is dependent on the existence 
of the object class. 5. Provide an efficient mechanism for associating rules to all instances of a class 
as well as to a subset of instances, possibly from different classes. To elaborate: (1) and (3) extend 
the expressive power of the resulting system, preserve encapsulation, support monitoring of multiple 
objects possibly from different classes, thereby reducing the number of rules. (2) sup­ports an incremental 
design capability for user applica­tions. At design time, while defining a class, the user is not required 
to explicitly list all the rules applicable to that class. At runtime, new rules can be added and ass~ 
ciated/applied with/to existing objects in the database, i.e., the addition of rules does not affect 
the definition of objects currently existing in the system. Consequently, the extensibility and modularity 
of the resulting system is not compromised. (4) facilitates binding of rules to event, condition, and 
action at runtime by choosing an appropriate implementation for (1). Also, our design allows incorporation 
of new features (for example, providing a new conflict resolution strat­ egy) without modifications to 
application code. 3.1 External Monitoring Viewpoint Conventional Interface (asynchronous) 7 1 J Figure 
1: Behavior of a reactive class. To treat rules independently from the objects they mon­itor, objects 
must be capable of i) generating events when their methods are invoked and ii) propagating these events 
to other objects. To achieve these capa­bilities we extend conventional C++ objects with an event interface. 
This interface enables objects to des­ignate some, possibly all, of their methods as primitive event 
generators. The implementation of the interface specification is through primitive event generators that 
raise an event when a method is invoked, The aug­mented C++ object is depicted in Figure 1. Tradition­ally, 
objects receive messages defined using the conven­tional interface, perform some operations and then 
re­turn results. Now, in addition, they generate events for the methods (defined using the event interface) 
when they are invoked and propagate these events to other objects asynchronously. Events are generated 
either be­fore or after the execution of a method. A class that supports the external monitoring viewpoint 
is termed as a reactive class and is defined as : Reactive class definition = Ikaditional class definition 
+ Event interface specification Using the event interface, events are specified ss part of the class 
definition by the user. The event interface only specifies the events that are to be produced by that 
re­active object class. The semantics of the event interface is that every instance of the Reactive chtas 
will gen­erate and signal an event for methods specified in the event interface. Although every method 
of a class corre­sponds to two3 potential primitive events, the designer may want to specify a meaningful 
subset as part of the event interface specification. Hence, only objects that are likely to be monitored 
need to be made instances of the Reactive class and further only those methods that change the state 
that one is interested in monitoring, need to be defined in the event interface. In contrast to the conventional 
interface which is specified and imple­mented by the user, only the event interface is specified by the 
user; its implementation is provided by the sys­tem. The event message generated by the Reactive class 
consists of the following parameters : Generated primitive event = Oid + Class + Method + Actual-parameters 
+ Time_stamp Since instances of the Reactive class are producers of events, they need to know the consumers 
of those events. This leads us to the introduction of the Notifiable object class. An inst ante of a 
notifiable class is a consumer of an event that is of interest to that class. An association is established 
between an event and a notifiable object using the subscript ion mechanism. In contrast to Ode, only 
primitive event specifications are part of the reactive object s class definition. The rule itself, which 
monitor objects, is not required to be part of the class. Rules and event operators are the consumers 
of primitive events generated by instances of the Reactive object class, and use these events to detect 
primitive and composite events. 3.2 Object Classification In Sentinel, objects are classified into three 
categories : passive, reactive, and notifiable. As with other 00 databases, a designer creates a schema 
which defines classes for an application. However, he/she needs to also define which object classes are 
reactive, to produce appropriate events, and which object classes are notifi­able, to make them consume 
and detect events. Passive objects : These are regular C+-I-objects. They can perform some operations 
but do not gener­ate events. An object that needs to be monitored and inform other objects of its state 
changes cannot be pas­sive. No overhead is incurred in the definition and use of such objects. Reactive 
objects : Objects that need to be monitored, or on which rules will be defined, need to be made re­active. 
The event interface of objects enables them to declare any, possibly all, of their methods as event gen­erators. 
Once a method is declared as an event gen­erator (through the event interface), its invocation will be 
propagated to other objects. Thus, reactive objects communicate with other objects via event generators. 
Notifiable objects : Notifiable objects, on the other hand, are those objects capable of being informed 
of the 3The primitive events before and after correspond to the invocation and return of methods. These 
two can be au­tomatically generated; also, the designer can also explic­itly generate other primitive 
events, within the body of the method. events generated by reactive objects. Therefore, notifi­ able 
objects become aware of a reactive object s state changes and can perform some operations as a result 
of these changes. &#38;-­ CEzE=D   Id-d,.-., el 0!4 k?d Figure 2: An Event Producer/Consumer Analogy. 
 Figure 2 illustrates the producer/consumer behavior of object types. Two independent objects object 
1 and ob­.ject2 generate primitive events el and e2, sending them to a rule RI. The rule passes the events 
to the event de­tector for storage and event detection, and if the event is detected, the rule checks 
the condition and takes ap­ propriate actions. Notifiable objects subscribe to the primitive events gen­erated 
by reactive objects. After the subscription, the reactive objects propagate their generated primitive 
events to the notifiable objects. Lastly, the notifiable objects perform some operations as a result 
of these propagated events. The operations can affect passive, reactive, and notifiable objects. There 
is a m:n rela­tionship between notifiable and reactive objects; that is a reactive object inst ante can 
propagate events to sev­eral notifiable object inst antes and a notifiable object inst ante can receive 
events from several reactive object instances. Events and rules are examples of notifiable objects. Rules 
receive events from reactive objects, send them to their local event detector, and take appropriate actions, 
Event detectors receive events from reactive objects, store them along with their parameters, and use 
them to detect primitive and complex events. 3.3 Events Several approaches are possible for event specification 
in an 00 context. Currently, three approaches are used: i) events aa expressions declared within class 
definitions, e.g., Ode [GJ91, GJS92], ii) events as rule attributes, e.g., Bauz [M P90], and iii) events 
as first claas objects, e.g., ADAM [DPG9 1]. Below, we discuss the advantages and disadvantages of each 
approach. Events as Expressions : This approach is motivated by runtime processing gains, since processing 
of event specification is performed primarily at compile time and little or none at runtime. The main 
disadvantage is that events cannot be added, deleted, or modified at runtime, thereby resulting in a 
dichotomy between events and other types of objects, Further, persistence of events is dependent on the 
existence of other objects. More importantly, events spanning distinct classes cannot be expressed. In 
addition, events cannot have attributes or methods of their own and hence cannot store and ac­cess the 
parameters computed when the event is raised. Lastly, new event types or event attributes cannot be easily 
incorporated, thereby compromising the extensi­bility. Events as Rule Attributes: This alternative im­proves 
upon the former approach by allowing events to be added, deleted, and modified dynamically. Another advantage 
is that event and rule association is achieved since events are part of a rule s structure. However, 
this approach suffers from the same disadvantages as those of the first approach. Events as Objects: 
This alternative has several advantages and is superior to the former alternatives. First, this approach 
models the properties of events. Events have a state, structure and behavior, i.e., events exhibit the 
properties of objects. The state informa­tion associated with each event includes the occurrence of the 
event and the parameters computed when an event is raised. The structure of an event consists of the 
event(s) it represents while the behavior consists of specifying when to signal the event, Second, events 
can be created, deleted, modified, and designated as persis­tent as other types of objects, i.e., events 
are treated in a uniform manner as other objects. Furthermore, the introduction of new event typea/attributes 
can be easily incorporated by modifying/augmenting class definitions without compromising the extensibility 
and modular­ity of the system. Moreover, events spanning distinct classes can be expressed. However, 
with this approach, runtime overhead is incurred when events are created, deleted, and modified dynamically. 
In Sentinel, we adopt the third alternative and treat events as first class objects. Furthermore, we 
construct complex events using a hierarchy of event operators. Event objects are consumers of events 
generated by re­active objects. 3.4 Rules The 00 environment offers numerous design alterna­tives for 
the incorporation of rules. Rules can be speci­fied declaratively, embedded inside other objects as at­tributes 
or data members, or as objects. Below, we discuss the advantages and disadvantages of each alter­native. 
Rules as declarations only inside classes : Rules are declared by the user and then inserted by the system 
into each place in the code where they might be trig­gered. It is necessary to first determine where 
and how rules should be declared. Rules are associated with ob­jects and contribute to their behavior. 
Thus, the natural place for declaring rules is within class definitions. We shall not discuss rule declaration 
syntax since it does not affect the active functionality provided. The pri­ mary advantage of this approach 
is that rule processing is performed primarily at compile time, and hence little or no rule processing 
is performed at runtime. Further­ more, the declaration of rules within class definitions offers an easy 
mechanism for determining the rules ap­ plicable to objects; this information is easily obtained from 
the class definitions themselves. In addition, the inheritance of rules is easily supported. This approach 
does not treat rules as objects and their existence is dependent on the existence of other objects. Furthermore, 
the system is not extensible since the in­ troduction of new rule components, e.g., rule priority levels, 
requires modifying class definitions containing rule declarations. The main disadvantage of this ap­ 
proach lies in its inefficiency in handling the addition, deletion, and modification of rules. This is 
because changing the rules defined for objects requires the mod­ification of class definitions and thus 
recompiling the system. This presents a major problem for interpre­tive 00 environments. Furthermore, 
modification of a class definition may present some difficulties to already existing and stored inst 
antes of the class, thereby com­promising the extensibility of the system since addition of rules should 
be allowed irrespective of already exist­ing objects in the system. In addition, rules cannot be reused 
or shared. For example, a rule that ensures an employer s salary is always less than his/her manager 
s salary needs to be declared twice once within the em­ployee class and once within the manager class. 
Rules as Data Members : By treating rules as data members we must first find a convenient type to model 
them. Let us assume that an appropriate type has been determined. The advantage of this approach is its 
reusability and extensibility; once a type has been de­fined it can be used throughout an application 
as well as in other applications, Furthermore, the introduction of new rule components only requires 
redefining the type definition. Moreover, rules are easily associated with objects since they are part 
of an object s structure. In addition, rules can be easily added, deleted, and mod­ified dynamically. 
However, the main disadvantage is that it does not support inheritance. This is because the value of 
a data member cannot be inherited. Sec­ond, a rule s existence is dependent on the existence of other 
objects. Rules as Objects : There are numerous advantages to treating rules as objects. First, rules 
can created, mod­ified, and deleted in the same manner as other objects, thus providing a uniform view 
of rules in an 00 con­text, Second, rules are now separate entities that exist independently of other 
objects in the system. Rules can be designated as transient or as persistent objects. In addition, they 
are also subject to the same transaction semantics aa other objects. Third, each rule will have an object 
identity, thereby allowing rules to be associated 4Thw excludes the possibility of a class. This possibility 
is also examined. with other objects. Fourth, the structure and behav­ior of rules can be tailored to 
model the requirements of various applications. For example, it is possible to create subclasses of the 
rule class and define special at­tributes or operations on those subclasses. As an exam­ple, hard and 
soft constraints of Ode [GJ91, GJS92] can be modeled as subclasses of the rule class. Lastly, by treating 
rules as first class objects an extensible system is provided. This is due to the ease of introducing 
new rule attributes or operations on rules; this requires the modification of the rule class definition 
only. In Sentinel, we adopt the latter alternative and chose to treat rules not only as first class, 
but also as notifiable objects. 3.5 Rule Association Rules in active relational databases have been 
treated as global constraints which must be satisfied by all relations in the database. This global treatment 
of rules is no longer meaningful in the context of an ac­tive 00DBMS due to a fundamental feature of 
the 00 paradigm, viz. abstraction. An abstraction denotes the essential characteristics of an object 
that distinguish it from all other kinds of objects. Rules defined on an object undoubtedly cent ribute 
to the essential charac­teristics, especially behavior of an object. In many ap­plications, objects differ 
considerably in both structure and behavior from one another. Therefore, it is realis­tic to assume that 
different kinds of objects may have different rules applicable to them. To accommodate rules in an 00 
environment, we clas­sify rules into two main categories, namely, class level and inst ante level rules. 
Class level rules are applica­ble to all instances of a class while instance level rules are applicable 
to specific instances, possibly from dif­ferent classes. Rules, regardless of their classification, are 
treated as first class notifiable objects. To associate rules with objects, we introduce a subscription 
mech­anism. This mechanism allows notifiable objects (rules in this case) to dynamically subscribe to 
the events gen­erated by reactive objects. After the subscription takes place, a notifiable object will 
be informed or notified of the events generated by reactive objects and react to those events. The subscription 
mechanism can be im­plemented on varying degrees of granularity. For exam­ple, a notifiable object may 
subscribe to all the events defined in the event interface of a reactive object or sub­scribe to specific 
events. The latter case is more efficient since rules are checked only when specific events defined in 
the event interface of a reactive object are generated. This is in contrast to checking rules whenever 
each event defined in the event interface is generated. However, the former approach uses less storage 
since only one list of notifiable objects needs to be maintained per reactive object. The latter approach 
needs to maintain one list for each message defined in the event interface of a re­active object. The 
subscription mechanism introduced in this paper has three main advantages. First, runtime rule checking 
overhead is reduced since only those rules which have subscribed to a reactive object are checked when 
the reactive object generates events. This is in contrast to adopting a centralized approach where all 
rules defined in the system are checked when events are generated. Second, a rule can now be applied 
to different types of objects in an efficient manner; the rule is defined only once and then subscribes 
to the events generated by different types of objects. This is more efficient than defining the same 
rule multiple times and applying each rule to one type of object. Lastly and more importantly, rules 
triggered by events spanning distinct classes can be expressed, This is accomplished by a rule subscribing 
to the events generated by inst antes of different classes. 4 Implementation Details &#38; * Figure 
3: Sentinel Class Hierarchy for Rule Support. The Sentinel system is being developed using Zeit­geist, 
a C++ OODBMS developed at Texas Instru­ments[PP9 1]. To incorporate rules in Zeitgeist we mod­ified the 
class hierarchy to include the Reactive, iVo­tifiabJe, Event, and Rule classes. The clam hierarchy introduced 
for rule support is illustrated in Figure 3. In Zeitgeist, persistence is provided by the zg-pos class 
for all objects that are derived from that class. There­fore, by deriving the Rule and Event classes 
from the zg-pos class, rule and event objects can be designated as persistent. The Rule and Event classes 
are derived from the Notifiable class in order for rule and event ob­jects to act as consumers, i.e., 
be capable of receiving and recording the events propagated by reactive objects. In the following subsections 
we briefly outline the imple­ mentation of the Reactive, Notifiable, Event, and Rule classes. 4.1 The 
Reactive Class class Reactive ( I* n~tiffabk ~bje&#38;q @t ~~~~~ ~en~ *I lii+f-not~lablesubswibers CXXISUMerX 
public : Subscribe (Notifiable obj); Unsubsdx f,?iotifiablc abj} RcactiveI) [cxmmmtm = Null; }; NotifY 
(iit *obj, char *event-name, time timestanp,ti argc...) ); Figure 4: The Reactive Class. The public 
interface of the Reactive class consists of methods by which objects acquire reactive capabilities. Each 
class derived from the Reactive class inherits the private data member consumers and the four methods 
Reactive, Subscribe, Unsubscribe, and Notify. 5 Reactive and Notifiable are designated for persistence, 
their inst antes can be made persistent (or transient). Each reactive object s definition is enlarged 
with the pri­vate data member consumers. This data member stores as its value the set of notifiable objects 
associated with events generated by a reactive object, When a reac­tive object generates events, they 
will be consumed by the set ofnotifiable objects listed in the attribute con­ sumers. The Subscribe method 
appends a notifiable object to the consumers attribute. The Unsubscribe method reverses the effect produced 
by the Subscribe method. The set of objects in the consumers attribute are notified of the generated 
primitive events via the No­tify method. The Notify method informs the consumers of : i) the identity 
of the reactive object generating the primitive event, ii) a unique string identifier that in­dicates 
the event generated along with whether it was generated before or after execution of the method, iii) 
a time-stamp indicating the time when the event wss generated, and iv) the number and actual values of 
the parameters of the message invoked by the reactive ob­ject. 4.2 The Notifiable Class The primary 
objective for defining the Noiijiable class is for allowing objects to receive and record primitive events 
generated by reactive objects. Both the Event and Rule classes are subclasses of the Notifiable class; 
they receive and record primitive events generated by reactive objects. The Record method defined in 
the No­tifiable class documents the parameters computed when an event is raised. It takes as its parameters 
the iden­tity of the reactive object which generated a primitive event, the primitive event generated, 
the time-stamp indicating when the event was raised, and the number and actual values of the parameters 
sent to the reactive object. 4.3 The Event Hierarchy Event specifications are translated into first 
class ob­jects which are created, deleted, modified, and des­ ignated as persistent as other types of 
objects. We support both primitive and complex events. Primitive events are in the form of messages sent 
to objects and are of two shades: begin of method (born) and end of method (eom) events. born and eom 
events are signaled before an object starts executing a method and imme­diately after an object returns 
from a method, respec­tively. Composite events are constructed by applying event operators to primitive 
events. Currently, the op­ erators disjunction, conjunction, and sequence are sup­ported. An event E 
constructed by applying the conjunction op­erator to two primitive or complex events El and E2, is signaled 
when both El and E2 occur, regardless of the order of their occurrence (or of their components). An event 
E constructed by applying the disjunction opera­tor to two events El and E2, is used to signal an event 
when either El or E2 occur. An event E constructed by applying the sequence operator to the events El 
and E2, is signaled when event E2 occurs, provided El has occurred earlier. In the case where El and 
E2 are com­ classConjunction: Event { Event *EventOne, EventTwo: int Raised; pubIic : Conjonction(Event* 
FirstEveaL Event* .%mndl?vent); Notitj@a obj. char+evtm~time timestamp,int argcJ ): Figure 5: The Conjunction 
Subclass. posite events, E is signaled when the last component of E2 occurs provided all the components 
of El have occurred . An Event superclass was defined to provide the common structure and behavior shared 
by all event types. By creating an event class hierarchy, primitive and complex events structure and 
behavior were defined using in­heritance, The primitive, conjunction, disjunction and sequence events 
are defined as subclasses of the Event class. Each subclass definition is augmented with the necessary 
attributes and operations required for model­ing the event type it represents. Figure 3 illustrates the 
event hierarchy created. The structure and behavior of the Conjunction subclass is shown in Figure 5. 
It consists of the data mem­bers EventOne, EventTwo, and Raised. Event One and Event Two are pointers 
to event objects and represent the two events upon which the conjunction operator is applied. Raised 
indicates whether the event has been raised or not. The constructor of the class takes as its parameters 
the object identities of the event objects upon which the conjunction operator is to be applied. The 
last method Notify determines whether the events propagated raise the event or not and informs the rule 
object of the result. 4.4 The Rule Class The primary structure defining a rule is the event which triggers 
the rule, the condition which is evaluated when the rule is triggered, and the action which is executed 
if the condition is satisfied. To model the structure of rules, a Rule class is defined as shown in Figure 
6. Rules are notifiable objects having an event object as an at­tribute, and the condition and action 
as public mem­ber functions. In addition, the rule operations create, delete, update, enable, and disable 
are implemented as methods. Each notifiable rule object consists of the data mem­bers name, event-id, 
condition, action, mode, and en­abled. The rule attribute name takes as its value the name of the rule 
and can be used by the user to ac­cess the attributes and methods of the rule. event-id denotes the identity 
of the event object associated with the rule. The data members condition and action are pointers to the 
condition and action member functions, 6Solutions for overcoming indefinite waiting for events are given 
in [CM91]. 71n the current implementation, each rule defined m ts own condition and action implemented 
as methods defined in the Rule class. {9 Rule ~~ ~ad~ notifiable I classRule: Notifiable{ &#38;=* ~~q 
/8 R~e ~~e l Event*event-id I* Event9/ pm *SOIXStiUI, *@irn, /* pMF is a pointsr to a member function 
/ COoplingI* mode I modq Coupiiig /. R~e ~nab]~ ~ Ot Iim alabld, public: virtual int Enabl@; virtual 
int D~bldJ virtual Updatc@vatt*evantid} virtual int Cmditim(J virtual int Auion@, Rule(Event* cvmtid, 
PMF curditkm, PMP wtiom Coupling mode); -Rui@, ); Figure 6: The Rule Class. classFxnployea:Rsactivc{ 
1.mxke Employex cIx89 -va 1 t-bat salaq$ public: eventd Oc.t.salaryo, /s v=, im~= / svartbegii&#38;&#38;end 
Oa_Agc(J P ewnt intarf~ 81 chfi Oe_NamO, 1; Figure 7: A Reactive Subclass. . respectively, The attribute 
mode denotes the couDlin~ m~de whil~ enabled denotes whether the rule is en~ble~ or not.  4.5 Usage 
of Reactive Class Primitive events are generated by an object when it in­vokes a method. In the interest 
of reducing the amount of overhead, we recommend the user to specify which member functions should generate 
events upon their in­vocation, i.e., which methods are to be treated as prim­itive event generators. 
Using this information, event generation (and hence rule checking) is limited to only those methods designated 
as potential primitive events. When the event should be raised is specified by the before or after prefixes. 
Potential primitive events are specified using the event interface in the public, private, and protected 
sections of a subclass of the Reactive class as shown in Figure 7. In the employee class definition shown 
in Figure 7, begin of message events (born) will be generated when an em­ployee object receives the private 
Change-Salary and the public Get-Age messages. End of message events (eom) will be generated aa a result 
of executing the methods Get-Salary and Get-Age. Notice that a method may generate both born and eom 
events; this is the case for the member function Get-Age. The method Get-Name does not generate any events, 
and hence its invocation does not cause any rule evaluation. After specifying the event interface, the 
applica­tion/user needs to create the appropriate event and 8An alternative is to assume that all member 
functions are potential events which generates twice the number of member functions defined on that class. 
public : evmt bsgin Marry (l%sm* spome~ /* event interface 8/ /* clasa level rule apacifldion / Rules 
: R : Mmixgq E: Evmt* marry *new primitive (%sgin Porsax:Mamy (Pemrm* spouse) } c :if 8CX -Spause.scx 
A : abo~ M : Immediate la coupling mode *I  Figure 8: A Class Level Rule. rule ob iects which are 
informed of the generated prim­ itive events. This is the mechanism by which primitive and complex events 
are detected and their parameters recorded. 4.6 Event Creation Events are created, modified, deleted, 
and designated sa persistent in the same manner as other objects. Cre­ation of primitive event objects 
requires indicating the method which raises the event and when the event should be raised. For instance, 
a primitive event object that de­tects the end of the execution of the method Set-Sal by an employee 
object can be created by: Event* sal = new Primitive( end Emp::Set-Sal(float x) ); The parameter of the 
Primitive constructor is the sig­nature of the event which uniquely identifies the method that raises 
the event in addition to specifying when the event is raised. Therefore, the event is raised after the 
execution of the method Set-Sal defined in the Emp class. Composite events are instances of one of the 
Event sub­classes representing complex events. A complex event raised after depositing money into a bank 
account fol­lowed by an attempt to withdraw money is created by: Event* DEP = new Primitive( end ACN::Dep(int 
x) ); Event* WTD = new Primitive( before ACN::Wtd(int x) ); Event* DepWit = new Sequence(DEP, WTD); This 
event is raised when the method Dep is executed followed by an attempt to execute the method Wtd. 4.7 
Creating Class and Instance Rules Rules can be classified into class level and instance level rules depending 
on their applicability. Class level rules are applicable to all instances of a class whereas in­stance 
level rules are applicable to particular instances, possibly from different classes. Since class level 
rules model the behavior of a particular class, they are de­clared within the class definition itself. 
On the other hand, instance level rules are declared in the applica­t ion code. Rules, regardless of 
where they are declared, are translated into notifiable rule objects. The declaration of a class level 
rule entails specifying a rule name, an event, a condition, an action, and a cou­pling mode. Class level 
rules are declared in the rule section of a class as shown in Figure 8. In the above example the rule 
name is Marriage, the event is a per­ ampb~ m Mmqa M&#38;o: Evmt* emp = MW Primitive ( end smpJOyLwChmSO.JmOmc!(aOat 
amllnt)v Event* mmg = mw primitive ( end Mmagmx(lwnge-lnmrne(tlost amount) ): Event* equal. new Disjunction 
(e.mp, nwr&#38; RuJo Jnccmelavel (q~ C!hmkE@(), MkeJ@mlO] P Rub autim I Fmd.Subscrii @xmeLeveI): PRdo.bdtwtoe.vata 
gomdedbyFre-d*/ Mike.Subsailx? (komek~ PRulesubuaitwto.writsgcnmmibyMike*l Figure 9: An Instance Level 
Rule. son object receiving the message Marry, the condition checks whether the-person objects getting 
married are of the same sex, and the action aborts the triggering transaction, Notice that the method 
Marry is declared as a primitive event generator inside the person class definition, This rule, when 
enabled, is applicable to all person objects and instances derived from the person class. The rule is 
executed using the coupling mode specified. Instance level rules, on the other hand, are applicable to 
only those instances explicitly specified by the user. Let us assume that a specific employee, Fred, 
and his man­ager Mike, should always have the same yearly income. Therefore, whenever Fred or Mike update 
their income this rule should be checked. Notice that this rule is ap­plicable to instances from different 
classes, specifically, the employee and the manager classes. The instance level rule is then created 
as illustrated in Figure 9. This rule has as its event a complex event that is raised when an employee 
object executes the method Change-Income or a manager object executes the method Change-Income. Both 
these methods must be declared as primitive event generators in their re­spective class definitions. 
The condition part of the rule checks whether the incomes are equal and the action sets the incomes to 
the same amount. For the IncomeLevel rule object to be notified of the events generated by the employee 
object Fred and the manager object Mike, the rule must subscribe to those objects. Once the rule IncomeLevel 
subscribes to the objects Fred and Mike, all primitive events generated by Fred and Mike are propagated 
to the rule object. Therefore, the IncomeLevel rule object is monitoring the Employee object Fred and 
the Manager object Mike simultane­ously. Examples In this section we provide an example which highlights 
the features of our approach and compares it with Ode and ADAM. Consider a rule that requires the monitoring 
of events spanning several objects from different classes and fur­ther the rule can be meaningfully specified 
only at run­time. A portfolio Parker is interested in purchasing IBM stock if its price is less than 
$55 and the percentage change in the DowJones Industrial average is less than 3.470. The rule needs to 
monitor IBM price changes and DowJones value changes and is triggered when both these changes occur. 
Hence, this rule can be modeled by using the conjunction operator. Although Ode sup- I* code In applka 
tlon program */ Stock MM; PwtfolJa Pukq Jh8nciallnfo DOwJm, Ewmt* stOck@e = ~W RiMitiV6 (-aid StockSntPriC&#38;tlcu 
unount) ~ Ewmt* mwvalti = mw Primitive (%M PimncidJnfa:SetVdue@Od unountrk Iheti* pdmvti = mw Cmjumtkm 
(smckpics, mwvduez P Rule euadm 1 RUB* Purdu@@mmlue, PurchweCdi m,~-, ~k IBM.SuLuaitc@rcJmeX P Rule 
bubsmbw to -&#38;mua&#38;d by ISM obpct I Figure 10: Instance level rule spanning two classes, N . . 
. . . f S ~tit * WI* *.P C.3@ex ~- Evsnb adRlks d Cu@rlg %­Ct@cta W* Ruin Emirm­m RI&#38;s mm! O&#38; 
Inmmai Inm.cq an=, Rdadw, No No 1, $&#38; c++ I-9 Plia, m, WIN cot ADAM Illtmnl Iwa-.abj am m W, Yw I 
Yw PROLOG r Figure 11: Comparison of Active 00DBMS Features. ports complex events, it cannot express 
this event since it spans two classes. Since ADAM does not support complex events, it also cannot express 
this event. There­fore, we consider the Sentinel approach only. First, the event interfaces of the Stock, 
Portfolio and Fi­ nancialInfo clrisses need to specified when defining the classes. Invocations of the 
method SetPrice in the Stock class and the method Sei Value in the FinancialInfo class need to generate 
events and thus are part of the event interface of their classes. No methods in the Portfolio class are 
declared ae event generators. The next step en­tails creating the event object which monitors these two 
events. This event object is an inst ante of the Conjunc­tion class and is created es shown in Figure 
10. The rule object Purchase is then created. Its event is the pricevalue event object and its condition 
is the method PurchaseCondition which checks whether the IBM price is less than $55 and whether the DowJones 
percentage change is less than 3.4!Z0. If the condition evaluates to true, the method PurchaseAction 
will be invoked and it will purchase IBM stock for the Parker portfolio. After creating the rule, it 
subscribes to the events generated by the IBM stock instance and the DowJones Financial-Info instance. 
6 Related Work Although a number of efforts have addressed incorpo­rating active capability in the context 
of an OODBMS [MP90, C+89, SKL89], only Ode [GJ91, GJS92] and ADAM [DPG91] are pertinent to our work. 
Ode provides active behavior by incorporating rules in the form of constraints and triggers. Both constraints 
and triggers consist of a condition and an action and are defined within class definitions. Events in 
Ode are implicit and are considered as the disjunction of all non­constant public methods. Constraints 
are applicable to all inst antes of the class in which they are declared while triggers are applicable 
only to those instances specified explicitly by the user at runtime. More recently Ode [GJS92] has proposed 
a language for specifying compos­ite events which is similar to Snoop [CM9 1]. Detection of events is 
accomplished by using a finite automata. ADAM [DPG91] is an active 00DB implemented in PROLOG. Both events 
and rules are treated as first class objects. An object s definition is enlarged to in­dicate which rules 
to check when the object raises an event. Thus, each class structure is augmented with a class-rules 
attribute; this attribute has as its value the set of rules that are to be checked when the class raises 
an event. A Rule-class is defined where each rule is an instance of that class. Rule operations are implemented 
as class methods. Events are classified into DB events, clock events, and application events. Events 
are gener­ated either before or after the execution of a method. A comparison of Ode, ADAM and Sentinel 
is shown in Figure 11. 7 Summary and Future Research This paper describes the external monitoring view­point 
that separates object and rule definitions from the event specification and detection process. This re­sults 
in a modular and extensible system. Event de­tection and rule processing mechanisms can be easily changed/replaced 
without changing the object defini­tions. Furthermore, this monitoring viewpoint allows objects to monitor 
and react to their own state changes aa well as the state changes of other objects. We have supported 
the specification and detection of simple as well as complex events, and compile time as well as run­time 
rules, We have significantly reduced rule checking overhead by introducing the demand-based subscription 
mechanism. Our design easily supports customizing the behavior of event and rule objects. For example, 
various conflict resolution strategies can be implemented by defining methods within the rule class. 
Also, methods defined on the rule class can be designated as event generators to define rules on the 
rule object class itself. Although the before and after events are supported as part of the event interface, 
users can use the not ify mechanism to generate (or signal) events at arbitrary points in their methods. 
7.1 Future Research We are currently investigating: Transformation of higher-level user specification 
of an active database to SentineI,  Support for all events and parameter contexts in Snoop [CM91]. 
 Performance evaluation of our design choices,  Communication among applications and cooperative transactions 
using the active database paradigm.  References <RefA>[Anw92] E. Anwar. Supporting complex events and rules 
in an oodbms: A seamless approach. Master s thesis, DBSRDC, University of Florida, Nov. 1992. [BM91] 
[C+89] [CHS93] [CM91] [DB90] [DPG91] [GJ91] [GJS92] [Int90] [JQ92] [Mau92] [MP90] [PP91] [SHP88] [SKL89] 
[WF90] C. Beeri and T. Millo. A model for active object­oriented databases. In Proc. of VLDB, Barcelona 
, Sept. 1991. S. Chakravarthy et al. HiPAC: A Research Project in Active, Time-Constrained Database Manage­ment, 
Final Report. Technical Report XAIT-89­02, Cambridge, Aug. 1989. S. Chakravarthy, E. Hanson, and S.Y.W. 
Su. Active Database Research at the University of Florida. IEEE Quarterly Bulletin on Data Engi­neering, 
Jan. 1993. S. Chakravathy and D. Mishra. An event specifi­cation language (snoop) for active databases 
and its detection. Technical Report UF-CIS TR-91-23, DBSRDC, University of Florida, Sep. 1991. M. Darnovsky 
and J. Bowman. TRANSACT-SQL USER S G UIDE, Release 4.2. Document 3231-2.1, Sybase Inc., May 1990. 0. 
Diaz, N. Paton, and P. Gray. Rule Manage­ment in Object-Oriented Databases: A Unified Approach. In Proc. 
of VLDB, Barcelona, Sept. 1991. N. H. Gehani and H. V. Jagadlsh. Ode as an Active Database: Constraints 
and Triggers. In Proc. of VJ5DB, Barcelona, Sep. 1991. N. H. Gehani, H. V. Jagadish, and O. Shmueli. 
Event Specification in an Object-Oriented Database. In Proc. of A CM-SIGMOD, San Diego, June 1992. InterBase 
Software Corporation, Bedford, MA. In­terBase DDL Reference Manual, InterBase Ver­sion 3.0, 1990. H. 
V. Jagadish and X. Qian. Integrity Mainte­ nance in an Object-Oriented Database. In Proc. o~ VLDl?, Vancouver, 
Canada, Aug. 1992. L. Maugis. Adequacy of active oodbms to flight data processing servers. Master s thesis, 
National School of Civil Aviation / University of Florida, Aug. 1992. C. B. Medeiros and P. Pfeffer. 
A Mechanism for Managing Rules in an Object-oriented Database. Technical report, GIP Altair, Sept. 1990. 
Edward Perez and Robert W. Peterson. Zeit­geist Persistent C++ User Manual. Information Technologies 
Laboratory Technical Report 90-07­02, 1991. M. Stonebraker, M. Hanson, and S. Pot amianos. The POSTGRES 
rule manager. IEEE Transac­tions on Software Engineering, 14(7):897-907, Jul. 1988. S. Y. W. Su, V. Krishnamurthy, 
and H. Lam. An Object-Oriented Semantic Association Model (OSAM*) . Theoretical Issues and Applications 
in Industrial Engineering and Manufacturing, pages 242 251, 1989. J. Widom and S. Finkelstein. Set-Oriented 
Pro­duction Rules in Relational Database Systems. In Proc. of A CM-SIGMOD, pages 259 270, May 1990. </RefA>
 
			

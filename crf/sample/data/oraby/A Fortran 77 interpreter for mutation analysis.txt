
 A Fortran 77 Interpreter for Mutation Analysis A . Jefferson Offutt V I K. N . Kin g Software Engineering 
Research Cente r Georgia Institute of Technolog y Atlanta, GA 3033 2  ABSTRAC T Mutation analysis is 
a powerful technique fo r testing software systems . In the Mothra project , conducted at Georgia Tech's 
Software Engineer­ing Research Center, mutation analysis is use d as a basis for building an integrated 
softwar e testing environment . Mutation analysis require s the execution of many slightly differing 
version s of the same program to evaluate the quality of the data used to test the program . In the current 
version of the Mothra system, a program to b e tested is translated to intermediate code, wher e it and 
its mutated versions are executed by a n interpreter . In this paper, we discuss some of the uniqu e 
requirements of an interpreter used in a mutation-based testing environment . We then describe how these 
requirements affected th e design and implementation of the Fortran 7 7 version of the Mothra interpreter. 
Other topics covered include the architecture of the inter­preter and many of the design elements that 
i t incorporates. We also describe the intermediate language used by Mothra and the features of th e 
interpreter that are needed for software testing . Permission to copy without lee all or part of this 
material is granted pros ided that the copies are not made or distributed for direct commercial advantage 
. the ACM copyright notice and the title of the publication and its date appear . and notice is given 
that copying is by permission of the Association for Computing Machinery . To copy otherwise, or to republish, 
requires a fee and / or specific permission . &#38;#169;1987 ACM 0-89791-235-7/87/0006/0177 75(G 1 . 
MUTATION Software testing attempts to provide a partia l answer to the following question : If a program 
is correct on a finit e number of test cases, is it correc t in general ? Several techniques have been 
used to generate a finite set of test cases that will allow one to gai n confidence in a program's correctness, 
includin g input space partitioning [11], symbolic testin g [14], functional testing [12], as well as 
mutatio n analysis. (See [8] for a survey of these and other techniques .) Since software testing is 
insufficient to guarantee program correctnes s [11], these testing techniques do not attempt t o establish 
absolute program correctness but t o provide the tester with some level of confidence in the program 
. Although each of these tech­niques is effective at detecting errors in the pro ­gram, mutation analysis 
goes one step further b y supplying the user with information in the absence of errors. This unique ability 
helps the tester predict the reliability of the program an d indicates quantitatively when the testing 
proces s can end . Mutation analysis also has been show n analytically and experimentally to be a generali­zation 
of other test methodologies [4, 10] . Thus , a mutation analysis testing tool gives a tester the capabilities 
of several other test techniques a s well as features that are unique to mutation . The rest of this 
section describes the mutatio n approach to software testing . This work supported in part under Contract 
F30602-85 ­C-0255 through Rome Air Development Center . 177 1 .1 Mutation Analysis Mutation analysis 
[6, 7] is a powerful tech­nique for software testing that assists the user i n creating test data and 
then interacts with the use r to improve the quality of the test data . Th e technique is briefly described 
here, but th e reader is referred to [4, 7] for more details . Mutation analysis is based on the construction 
o f a set of mutants of the test program, each of which is a version of the test program tha t differs 
from the original by one mutation . A mutation is a single syntactic change that is mad e to a program 
statement to imitate a typical pro­gramming error . Figure 1 shows a simple For­tran function containing 
a mutated statemen t (preceded by the # symbol) . INTEGER FUNCTION MAX (M, N ) INTEGER M, N MAX = N IF 
(M.GT .N) MAX =M #IF (M.GT.N) MAX = M END Figure 1. Function MAX The mutated version of MAX is created 
by replacing the original IF statement by th e mutated version on the line below . A program is mutated 
by applying a mutant operator to the program . The mutant operators currently supported by the Mothra 
system can b e divided into three classes : statement analysis, predicate analysis, and coincidental 
correctness . A simplified list of the operators in each clas s follows . e Statement analysis : replace 
each statement b y TRAP (an instruction that causes the pro ­gram to halt, killing the mutant) ; replace 
eac h statement by CONTINUE ; replace each state­ment in a subprogram by RETURN ; replace the target 
label in each GOTO ; replace the label in each DO statement . Predicate analysis: take the absolute value 
o r negative absolute value of an expression ; replace one arithmetic operator by another ; replace one 
relational operator by another ; replace one logical operator by another ; insert a unary operator preceding 
an expres­sion; alter the value of a constant ; alter a DATA statement . ® Coincidental correctness : 
replace a scalar variable, array reference, or constant by another scalar variable, array reference, 
o r constant ; replace a reference to an arra y name by the name of another array . These operators were 
derived experimentall y to correspond to simple errors that a program­mer might make. For example, the 
coincidental correctness operators represent cases where the programmer uses the wrong variable name 
or array reference . The predicate analysis opera­tors represent errors that a programmer might make 
inside an expression using an incorrect comparison operator or the wrong arithmeti c operator. The statement 
analysis operators check for several types of errors . The TRAP statement ensures that each statement 
is reached , the CONTINUE replacement ensures that eac h statement is necessary, and the RETUR N replacement 
ensures that the code following tha t statement is necessary . The label replacements , of course, imitate 
the error of using the wron g label . Test cases are used to kill mutant program s by differentiating 
the mutants from the origina l program . If a test case produces different out­put behavior in the mutant 
program, then th e test ease is strong enough to detect the fault represented by that mutant and the 
mutant is considered dead . The goal of mutation analysis is to construct a set of test cases powerfu 
l enough to kill a large number of mutant pro­grams . Each set of test cases is given an ade­quacy score, 
with a score of 100% indicating tha t the test cases kill all mutants of the program . 1 .2 Mutation 
Interpreter Requirements During the initial design of Mothra, it wa s decided to translate the program 
being tested t o intermediate code, mutate the code, and the n interpret it . Because of this design, 
the inter­preter was required to satisfy the followin g requirements : 1. The instructions that the interpreter 
exe­cutes must be capable of being mutated . 2. The instructions that the interpreter exe­cutes must 
be capable of being decompile d to Fortran 77 statements . 3. The interpreter must closely monitor the 
input/output behavior of the program unde r test. 4. The interpreter must protect against the program 
under test causing the test syste m  to fail. 5. The interpreter must execute large numbers of mutated 
programs as efficiently as possi­ble. 6. The interpreter must be capable of han­dling a substantial 
subset of Fortran 77 .  The following paragraphs describe thes e requirements. 1 .2 .1 Mutate cod e 
 The intermediate code must allow easy muta­tion. Although mutations are defined at th e source level, 
they are in fact performed on th e intermediate code version of the program. 1 .2 .2 Decompile mutants 
To design test cases that kill individual mutants, the tester usually needs to examine th e mutated programs 
. Thus, a mutation system must be able to display mutants as Fortran state­ments. Since mutations are 
applied to the inter ­mediate code, it must be possible to decompile this code into Fortran statements 
. 1 .2 .3 Input/output behavior The results of testing a program with muta­tion analysis are based on 
the input/outpu t behavior of the program . The interpreter mus t be able to store and repeatedly use 
input presented to the program as well as capture and examine the program's output . Moreover, th e interpreter 
must be able to begin execution at any arbitrary subroutine or function rather tha n just the main program, 
thus these inputs must b e placed in the program's memory space befor e execution begins . Since the 
program being tested may be used interactively, the value s typed by the user during original execution 
mus t be saved and used during mutant execution . 1 .2.4 Handle errors During mutant execution, testers 
are actively looking for errors in the program. Rather than handling errors as exceptional behavior, 
th e interpreter must treat them as normal, expected events . This is of particular importance to muta­tion 
analysis because the purpose of executing a mutant is not to provide the user with answers , but to provide 
output to compare with that of the original program . This means that an error con­dition is not an exception, 
but a value to be used in this comparison . Most importantly, the inter­preter must protect against the 
program unde r test causing the test system itself to fail. Failures in the program under test must be 
trapped and used to kill mutants . 1 .2 .5 Speed vs. parsing speed Since the interpreter is executed 
during the inner loop of the mutation process and the parser is not, a design goal of a mutation syste 
m is for the parser to perform as much computa­tion as possible to allow the interpreter to exe­cute 
faster. Unfortunately, this requirement is often at odds with several of the other require­ments, specifically 
decompiling and mutant crea­tion.  1 .2.6 Handle a substantial subset of Fortran 77 In order to be able 
to use Mothra for testin g nontrivial programs, the interpreter must handl e a large subset of Fortran 
77. At present, the only major feature not completely implemente d is input/output; only READ and PRINT 
state­ments are currently supported . The other miss­ing features are statement functions, alternat e 
returns from subroutines, entry points , assumed-size array arguments, and subprogram s used as arguments 
. 2. MOTHRA ARCHITECTURE Mothra is a mutation-based testing environ­ment that has been implemented at 
the Georgi a Institute of Technology . We will briefly describe the architecture of Mothra ; a more com­plete 
description can be found in [9] . The principal subsystems of interest are the parser, the decoder (decode), 
the test case for­matter (mapper), the mutant maker (mutmake) , the mutant generator (mutgen), and the 
inter­preter (rosetta) . When supplied with a progra m to test, Mothra first invokes the parser to creat 
e a code file and a symbol file . The code file con­tains instructions in Mothra Intermediate Cod e (MIC), 
a postfix intermediate language . MIC is discussed in Section 5 . The symbol file contains tables of 
program names and their attributes . These and other data structures are described i n Section 6 . After 
parsing the program, Mothra invokes mutmake to produce a file of Mutant Descriptor Records (MDRs) . Each 
record describes the change(s) needed to the code file to produce a single mutant. The number of mutants 
for a program is on the order of the square of th e number of names in the program . To avoid the cost 
of storing many copies of the same code , the MDRs are applied to the code file at ru n time (by mutgen) 
to create mutated versions of the code . Before executing these mutants, the tester must submit a test 
case to the Mothra system to produce the original output. Test cases are entered by interacting with 
mapper . When given a test case, Mothra invokes rosetta to execute the original code file (original execution) 
and sav e the output for later comparison . Mothra also saves the test case for use during the execution 
of mutants (mutant execution) . This process is explained in Section 10 . Once a test case and a set 
of MDRs has been created, Mothra executes the mutant programs . For each MDR, mutgen applies the MDR 
to the code file to produce an (in-memory) mutated version of the code. The interpreter is the n called 
to execute the mutated program and pro ­duce the output . This mutant output is com­pared to the original 
output by the output com­parator kilroy . If the outputs differ, then kilroy marks the mutant dead ; 
dead mutants are no t executed against subsequent test cases . If the outputs are the same, the mutant 
is left alive . The loop in which mutgen, rosetta, and kilroy execute each mutant in turn is called the 
inner loop because it is the most computationall y expensive part of the mutation process and is executed 
without interaction from the tester . The inner loop is dominated by the speed of th e interpreter ; 
since the MDR file may contain mil ­lions of records, the speed of rosetta is critical t o the functioning 
of Mothra . A late optimizatio n step during the implementation of Mothra was t o change both mutgen 
and kilroy from independent tools to subroutines that are called from rosetta. This paper discusses rosetta, 
the Mothra interpreter for Fortran 77 . rosetta was written in C and runs on a DEC VAX 11/780 under UNIX 
BSD 4.3 . rosetta features several design ele­ments that are interesting beyond the scope of Fortran 
77. Thus, the purpose of the paper i s not to describe a Fortran 77 interpreter, but to emphasize the 
special capabilities needed fo r mutation analysis and the problems involved with building a language 
system within a mutation-based testing environment such a s Mothra . Many of these problems, although 
spe­cialized, are similar to those found in other applications such as debuggers and inferenc e engines 
. 3 . INTERPRETER GOALS In addition to the requirements listed in Sec­tion 1.2, the implementation of 
rosetta was guided by four goals that influence many of the features described in this paper : 1. Build 
on previous work . 2. Maximize use of existing code . 3. Serve as a prototype for later interpreters 
. 4. Serve as a test harness within Mothra .  We explain the rationale for each of thes e goals below 
. 3 .1 Build on Previous Wor k Several prototype mutation systems wer e used as models during the design 
and implemen­tation of Mothra . In particular, the EXPER sys­tem [5] was of great help during the design 
o f rosetta . The designers of EXPER had alread y faced the problems of designing a language sys­tem 
for mutation analysis and we based much o f rosetta on the algorithms and data structure s used in EXPER 
. 3 .2 Maximize Use of Existing Cod e Writing a system such as Mothra is an enor­mous undertaking . Reusing 
existing code was therefore an important goal of the project . The construction of rosetta in such a 
short time wa s made possible by relying on the UNIX f77 libraries for I/O and intrinsic functions . 
 3.3 Serve as a Prototype For Later Interpreter s rosetta was conceived as a prototype for late r interpreters 
that will be more efficient and han­dle multiple source languages . 3 .4 Serve as a Test Harness Within 
Mothra Since testing is often performed on a subpro­gram rather than an entire program, rosetta needs 
to function as a test harness [2] to provid e the test subprogram with appropriate values for its parameters 
and global variables . This goal is reflected in the input/output and the progra m failure protection 
requirements . 4 . INTERPRETER ARCHITECTURE Figure 2 shows the major components of rosetta . DRIVER is 
the main routine. The DRIVER component initializes various data struc­tures, calls rosetta's instruction 
handler, an d calls the output comparator, kilroy. DRIVER is not dependent on the MIC instruction set 
. Figure 2. Rosetta Architecture QUERY is the data base of test cases for rosetta . The QUERY component 
provides routines to access and store the test case values . QUERY is also used by the mapper pro­gram 
. In general, mapper puts the test cas e values into QUERY's storage and rosetta uses them . KILROY implements 
the output compariso n function of rosetta. The output of a mutant program is compared against the output 
o f the original program to determine whethe r the mutant can be pronounced dead . INSTRUCTION HANDLER 
implements the to p level of the interpretation process . Th e instruction handler component performs 
th e fetch-execute cycle and executes individua l MIC instructions . OBJECTS are data structures that 
are used b y rosetta to execute MIC instructions . Som e objects are shared with other Mothra tools ; 
others are private to rosetta. INTERNAL MODULES are collections of sub ­routines that implement various 
functions for rosetta such as type conversion and faul t handling . The flow of control through rosetta 
differs from that in many interpreters . Before execu­tion, appropriate variables are initialized b y 
placing user-supplied values in memory . Supply­ing subprogram parameters and global variable s with 
values before execution begins allow s rosetta to initiate execution with subprograms a s well as a main 
program. In rosetta' s fetch­execute cycle, source statements and MI C instructions are handled at different 
levels t o allow some operations to be performed at th e statement level rather than at the code level 
. After the program executes, the output is use d for one of two purposes, depending on whethe r rosetta 
is executing the original program or a mutant. If the original program is being exe­cuted, the output 
is saved in a file . If a mutant is being executed, the output is compared against the previously saved 
original output . 5 . MOTHRA INTERMEDIATE CODE MIC instructions are simple operator-operand pairs . Although 
mutations are defined at the source language level, they are applied to MI C instructions to save the 
expense of generating intermediate code for every mutant program . Because of this and the decompiling 
require­ment, MIC instructions were designed so that the code produced for a program would have a direct 
relationship with the original source. This causes MIC to be higher-level than most interna l forms. 
For example, a DO statement is not translated to tests and branches, but represented by a special MIC 
instruction . Thus, the Fortran statements DO 10 I = 1, 5 SUM = SUM + I 10 CONTINUE are translated into 
the following MIC instruc­tio ns : IDDOLOOP I CONST 1 CONST 5 CONST 1 DOSTMT 10 IDNOCONST SU M IDENT 
SU M IDENT I BINARYOP OPPLU S ASSIGN CONT The IDDOLOOP and IDNOCONST opcodes ar e variants of the IDENT 
opcode . The IDDOLOOP opcode indicates that I is used a s the index variable of a DO loop and therefor 
e should not be replaced by a constant or array element during mutation . The IDNOCONS T opcode indicates 
that SUM appears on the left side of an assignment statement and therefor e should not be replaced by 
a constant . The third CONST instruction gives the increment of th e DO loop; the DO statement did not 
specify th e increment, so the parser supplied it . The high-level form of MIC allows eas y decompilation 
and mutation at the expense o f some run-time efficiency. For example, the DOSTMT opcode makes it easy 
to locate an d replace labels during mutation, but require s extra work during interpretation . 6. DATA 
STRUCTURE S The principal data structures that rosetta uses are implemented as independent objects . 
This independence promotes sharing between th e Mothra tools as well as orthogonality in th e design 
. All of these data structures are imple­mented as dynamically-created arrays . If, dur­ing execution, 
a structure grows beyond its current bounds, its array is automatically reallo­cated to be twice its 
previous size . 6 .1 Symbol Table When a Fortran 77 program is parsed, a cod e file and a symbol file 
are created . The symbol file contains the program's symbol table, whic h is used by several Mothra tools, 
including rosetta, mutmake, and decode . Internally, a sym­bol table consists of several smaller tables 
: a table containing type records, a table containin g information about local names (e .g ., variables 
, arguments, and symbolic constants), a table con­taining global names (e .g., program units and common 
blocks), and a table that relates interna l numbers assigned to program units to the orde r in which 
the units appear in the source file . The table of local names contains information abou t all local 
names in a program ; the local names belonging to a particular program unit occupy contiguous entries 
in this table . 6.2 Statement Tabl e The statement table contains one entry fo r each executable statement 
in the source pro­gram . The statement table is built by the parser and used during execution to differentiate 
between executing Fortran 77 statements and MIC instructions . Each entry in the statemen t table contains 
fields for the statement label (if any), the statement's nesting Ievel, and the inde x of the first MIC 
instruction generated for th e statement . Section 8 explains the meaning of th e nesting level ; it 
also discusses how the statemen t and code tables are used during execution.   6 .3 Code Tabl e The 
code table contains one entry for eac h MIC instruction . Each record in the code table contains an opcode 
and a (possibly null ) operand . 6.4 Stack rosetta's stack has space for three fields : a code to indicate 
the type of stack entry, a typ e field to indicate the type of a variable or expres­ sion in that stack 
entry, and a variant field tha t can hold an operand, address, partial expression , or some other piece 
of information . 6 .5 Data Table Fortran DATA statements require special handling by the parser and interpreter. 
DATA statements are translated into MIC instructions and stored in a special table, the data code table 
. Values appearing in DATA statements are stored in a parallel table called the data valu e table . Before 
it executes the instructions belong­ing to a Fortran program, rosetta first initializes memory by executing 
the instructions in th e program's data code table . These instructions fetch values from the data value 
table and store them into memory. This mechanism allows DATA statements to be mutated in the sam e way 
as executable statements . 6.6 Test Case Strea m A test case to be used by rosetta consists of a sequence 
of values to be placed into memor y before execution begins . During original execu­tion, the user responds 
to READ statements with input values that are then saved (in th e order they are entered) for use during 
mutan t execution. These values are placed on a linked list to form a stream of test case values .  
6.7 Memory rosetta implements memory as a long array of bytes. Variables are assigned static memory addresses 
by the parser to simplify address com­putation and to allow the required memory siz e to be known when 
execution begins . Values are placed into and retrieved from memory using byte-by-byte copy operations 
. 7. INITIALIZATIO N Before rosetta begins execution, it performs several actions that are crucial to 
the test harness capabilities of the mutation interpreter. These initialization steps allow the test 
program to exe­cute as if it was being executed in the intende d environment, rather than inside a test 
harness . This section discusses the three most interesting aspects of initialization . 7.1 Memory Initialization 
One common difference between machine s that can be important to software testing is th e values that 
are found in memory before execu­tion begins. Though some machines will initial­ize all of a program 
' s memory space to zeros before execution begins, others will leave previ­ous data in the memory. This 
will affect a program's behavior when references are made t o uninitialized variables or to invalid array 
sub ­scripts . The latter case is especially important i n a mutation context because several mutan t 
operators change array references, often causin g subscripts to be out of range. To allow for this problem, 
rosetta can per­form a memory initialization step before execu­tion begins . If this option is requested, 
rosetta is called with an integer value to be used for memory initialization . During the memory ini­tialization 
step, each byte in memory is fille d with this value. For efficiency, no memory ini­tialization is performed 
if this option is not selected . 7 .2 Execution Initialization Software is often tested at the module 
level rather than the program level . Thus, rosetta can begin execution inside an arbitrary subprogra 
m rather than a main program . The rule is simple ; if the parser finds a main program, rosetta exe­cutes 
the entire program . If not, rosetta begin s execution with the first subprogram in the sourc e file. 
If the initial subprogram is a function, then the value that the function returns is considere d part 
of the program's output (see Section 10) . 7 .3 Variable Initialization Variable initialization is the 
most importan t part of rosetta's test harness capabilities . Since the program being tested may not 
contain a mai n program, the parameters and global variable s used by the initial subprogram need values 
before execution. This assignment is imple­mented by assigning a class attribute to each variable . Each 
variable has one of four classes ; a class of initial (IN) indicates that the variabl e should get a 
value before execution begins, a class of output (OUT) indicates that th e variable's value should be 
considered part of th e program's output (see Section 10), a class of initial/output (INOUT) combines 
both IN an d OUT, and the don't care class (DONTCARE ) indicates that neither the initial nor the final 
value of the variable is relevant to the program' s input/output behavior. The determination of a variable's 
clas s depends on the initial subprogram that rosetta executes . If there is a main program, the use 
r defines the class of each of the variables defined in the main program . If the user defines all the 
variables to be DONTCARE, then the program is assumed to handle all input/output on its own . If the 
initial subprogram is a Fortran 77 subrou­tine, then each of the parameters is assumed to have class 
INOUT. Also, any global variables are assumed to be INOUT. If the initial subpro­gram is a function, 
then all parameters are give n class INOUT and the value of the function i s considered an OUT value 
. 8. EXECUTION LOOP A novel feature of rosetta is the structure o f its main execution loop . To allow 
the mutatio n process to function efficiently, rosetta differen­tiates between source statements and 
individua l MIC instructions (this was alluded to in Sectio n 6) . Thus, the main execution loop in rosett 
a functions on two distinct levels, the statement level and the code level . In general, having a separate 
statement level loop allows rosetta to perform various bookkeeping activities whe n statements are executed 
. The specific activities are discussed in detail below . The major action performed at the statemen 
t level loop is DO statement checking. Section 5 gave an example of the MIC instructions gen­erated for 
a DO loop . This code contains all th e information necessary for mutation and decom­piling. On the other 
hand, the interpreter that executes this code is forced to recognize the end of a DO loop and perform 
the loop increment o n its own. rosetta accomplishes this by using state­ment nesting level information. 
As the program is parsed, the level of DO-loop nesting i s recorded in the statement table . During execu­tion, 
if the current statement is nested at a lowe r level than the previous statement, then the pro­gram has 
left a DO loop and the interprete r needs to increment and if necessary go to th e next iteration of 
the loop . The two-level execu­tion loop is used to minimize the number of these DO loop checks . Because 
mutating a program may cause a n infinite loop, rosetta protects the mutation sys­tem by checking for 
infinite loops at the state­ment level . rosetta does this by counting and saving the number of statements 
executed during original execution. During mutant execution , this count is compared against the current 
state­ment count. If the current statement count exceeds the original count (multiplied by a user ­supplied 
constant), then the mutant is killed . For efficiency, this counting and comparing i s performed at the 
statement level . The TRAP mutant operator is treated as a special case . The TRAP operator replaces 
on e line in the program by a special TRAP state­ment. Execution of a TRAP statement immedi­ately kills 
the mutant. During optimization, rosetta was modified so that TRAP mutants are not actually executed 
. Instead, a table is built during original execution to keep track of whic h statements were executed 
. During mutant exe­cution, each TRAP mutant whose affected state­ment appears in the table is marked 
dea d without being executed. Statement tracing is also performed within th e statement loop . This feature 
is discussed in Sec­tion 12 . 9. STRING PROCESSING String constants are stored, null-terminated , in 
a string table and accessed through an offse t relative to the beginning of the table . String variables, 
on the other hand, are fixed-length and stored in program memory without the ter­mination marker. String 
expressions are evaluated using the space remaining at the end of the string table, then copied to memory 
when an assignment takes place. 10. HANDLING INPUT/OUTPUT BEHAVIO R Two factors are taken into account 
whe n determining whether the output behavior of a mutated program matches the output behavior o f the 
original program : the stop code of the mutant and the output produced by the mutant. The stop code is 
a status value generated durin g the execution of a program (original or mutated) that indicates the 
reason for termination . There is one stop code for normal termination and on e for each possible run-time 
error. If a mutant program finishes execution with a different sto p code than the original program, 
the mutant is marked dead . Thus, if the original progra m encountered an error condition and the mutan 
t program finished normally, the mutant is killed . If the two stop codes are the same, then kilroy compares 
the output of the mutant with the ori­ginal output. During original execution, the final values o f OUT 
and INOUT variables are saved in a file . During mutant execution, the final values o f these OUT and 
INOUT variables are compare d against the values saved from the original execu­tion. If the program contains 
Fortran output statements, the values printed by these state­ments are also captured and saved during 
origi­nal execution and compared against the output of the mutant code. As mentioned above, if the initial 
subprogram is a function, then the valu e of that function is also used as output for com­parison . Because 
rosetta must also handle input state­ments, special provisions are made to save th e values entered to 
these statements. A test case for a program consists of all the inputs used b y the program during original 
execution . During the mutant execution phase, each mutant that i s still alive must be executed with 
the same dat a values used by the original program . IN and INOUT variables are assigned values before 
exe­cution begins as described in Section 7. In Mothra, these values are taken from an external tool 
(mapper) that generates test cases . Interac­tive inputs, however, are more difficult . rosetta handles 
interactive inputs during original execu­tion by accessing the UNIX BSD 4 .3 Fortran 77 I/O library, 
trapping the values that are read , and storing them with the current test case. During mutant execution, 
input statements are handled differently . Rather than using the For­tran 77 library, the values that 
were read durin g original execution are carefully placed int o memory to mimic the effect of a Fortran 
77 input statement. These values are used in the same order during mutant execution that they were entered 
during original execution . 11. HANDLING SOFTWARE FAILURES SAFEL Y To handle exceptional conditions, 
rosetta per­forms extensive checks on all instructions exe­cuted. If an error condition is found, then 
an error code is propagated back to the executio n loop and execution is halted before the next MI C 
instruction is executed . This generates a sto p code that is treated as part of the program's out ­put 
state as described in Section 10 . This exten­sive error checking is a computational expens e that is 
necessary to ensure the integrity of th e Mothra testing system . rosetta is capable of detecting several 
kinds of errors in a program. Some of these are errors introduced during mutation . (Care is taken during 
mutant generation not to produce illega l programs, but certain kinds of errors are diffi­cult to detect 
at this stage.) Others are more conventional error conditions that are detected by most interpreters 
. The errors that rosetta can detect include : e Bad type: An expression contains an illega l combination 
of types. This error is some ­times introduced during mutation . . Bad assignment: The value being assigned 
i s of an incompatible type . This error also results from mutation . Time out: A mutated program is 
taking too long to execute, possibly indicating an infinit e loop . Detection of this error is discussed 
i n Section 8 . ® Subscript out of range : Since subscript check­ing is not required in Fortran 77, rosetta 
does not perform it unless requested to do so . 12. TRACE During testing of rosetta, we implemented a 
tracing feature that has worked well not only i n testing rosetta, but also Mothra's parser, mutant maker 
and the definition of the mutants them ­selves. We patterned the trace after the UNIX communications 
program uucp [15] . rosetta has four levels of trace, giving increasing levels o f detail in the output 
. Each level includes all th e information from the lower levels . The four lev­els currently implemented 
are: 1. Extra status information is printed afte r execution stops . 2. Source statements are displayed 
as they are executed . (This uses the Mothra decom­piler. ) 3. The result of each assignment statement 
is shown. 4. MIC instructions are printed as they are executed .  Note that level 2 tracing is handled 
in th e statement loop, while the last two levels are han­dled in the instruction loop . Thus, there 
is a definite performance degradation (as well a s increase in output) at higher trace levels. 13 . PERFORMANCE 
The performance of rosetta has a critical impact on its usability in a mutation testing system . In this 
section, we list some of the step s that we took to optimize rosetta and discuss its current performance 
levels . 13 .1 Optimizations performe d rosetta was designed using an object-oriente d design methodology 
[3]. Though a common argument against using object-oriented design is that efficiency is lost, we felt 
that this desig n approach was valuable for other reasons . In fact, it actually provided some straightforward 
way s to optimize interpretation . Since one purpose of the project was to integrate the interpreter 
int o the Mothra test system, using objects for suc h things as memory, the stack, the symbol table and 
the code table provided a convenient inter­ face between rosetta and the other Mothra tools . These factors 
greatly simplified the optimizatio n stage, which consisted initially of eliminatin g redundant code 
and isolating critical code fo r detailed optimization. We also isolated impor­tant algorithms that could 
be rewritten in mor e efficient ways . In the final system, the overhea d resulting from using objects 
was greatly reduced by replacing selected procedure calls by macr o invocations. 13 .2 Current performanc 
e The interpreter described was implemented i n approximately three man-months. It has since been used 
by researchers at Georgia Tech and demonstrated with preliminary versions of the Mothra interface for 
several months . It has exe­cuted Fortran 77 programs of up to 1000 lines and currently satisfies all 
the requirements men­tioned above while executing programs at a rat e approximately 15 times slower than 
if the pro ­gram were compiled using f77 . 14 . RELATED TOOLS The Mothra testing environment is compose 
d of several independent but related tools . The tools are related through shared data and share d modules. 
Much of the communication betwee n tools is accomplished by passing data files between the tools (symbol 
table, code file, tes t case file, etc.) . Many of the tools also share common modules, often based on 
one of the data files . For example, the parser creates th e symbol file that is later used by rosetta, 
mut­make, and mapper . Each of the tools that use the symbol file accesses it through the routine s found 
in the symbol table module . 15. LESSONS LEARNED    14.1 Parser The parser was built using the lexical 
analyzer and parser portions of the UNIX f77 compiler. The lexical analyzer was used withou t change 
; the parser was generated from the yacc rules in thein parser.  14.2 Decode decode is a general-purpose 
tool used fo r viewing a Fortran program and related informa­tion. decode allows the viewing of the entir 
e program, a single program unit, or a single line . Information that can be displayed include s source 
lines, MIC instructions generated fo r these lines, and mutated versions of these lines. Symbol table 
information may also be viewed . The information produced by decode is con ­trolled by options that can 
be combined to pro ­duce varying amounts of information . The most interesting feature of decode is the 
method it uses for decompiling Fortran state­ments. The decompilation procedure symboli­cally "executes" 
the MIC instructions belonging to the statement, using a stack of strings to reconstruct the statement 
from the identifiers , constants, and operators that appear in the MI C instructions . Decompilation 
is done using only the infor­mation in the code and symbol files . These con­tain no record of the type 
of each statement ; this is deduced from the pattern of MIC instruction s generated for the statement 
.  14.3 Mapper mapper works interactively with the user t o create test cases for Mothra (see Section 
7) . If a main program is present, mapper asks the user to define the class of each variable in the pro 
­gram . It then prompts the user to supply initia l values for each of the IN and INOUT variables . 14.4 
Mutmake mutmake is responsible for generating mutant descriptor records (MDRs). MDRs are gen­erated from 
the information in the code and symbol files. In general, mutmake is able to avoid generating mutated 
programs that would be illegal under the rules of Fortran 77. Expres­sions, however, cause problems, 
since changing the type of an operand anywhere in an expres­sion can change the type of the entire expres­sion 
. As a result, type checking and typ e conversion is done during interpretation . In the process of implementing 
any languag e system, the designers always learn a few (often painful) lessons . Although the lessons 
may be familiar to some, we pass them on in the hop e that someone may profit from our experience . 15 
.1 Desig n The most important lesson is that the axiom s of software engineering are actually sensible 
an d worthwhile. The most frequent source of errors and frustrations during our implementation wa s the 
task of adding forgotten features or fixing cases that were not considered in the initial ver­sion of 
a feature . The moral is to know the source language and design for all cases before beginning to code. 
15.2 Language grafts String processing was the most difficult language feature to implement . Since strings 
were grafted onto Fortran 77 (they do not appear in earlier Fortran standards), they do no t mesh well 
with the other features of the language, causing great difficulty for implemen­tors. Although most Fortran 
types could be han­dled uniformly by rosetta, strings were handle d as a special case.   15.3 Algorithm 
optimization vs. micro­ optimization s Software engineers often agonize ove r whether to spend time optimizing 
algorithms ( a time-consuming task, but one with a potentially high payoff) or optimizing small sections 
of code (easier to do, but with a small return) . This pro­ject gave us an opportunity to try both. After 
spending much time converting simple subrou­ tine calls into macros and changing C library calls to more 
efficient versions to gain tiny spee d improvements (< 10%), two algorithm changes multiplied the speed 
of rosetta by a much larger factor. One change was to use the statemen t nesting level to recognize DO 
loops ; the other was to integrate the inner loop into rosetta rather than have mutgen and kilroy as 
external tools . 16. FUTURE WORK Current optimization efforts are directed a t the internal algorithms 
used in rosetta, optimiza­tions of MIC, and modifying the architecture of the interpreter . 16 .1 Combined-stream 
execution One architectural method currently under study takes advantage of properties that are unique 
to mutation analysis . During mutatio n analysis, the program is executed many times once in the original 
form and once for eac h mutant . Since each mutant causes only one change in the program, the execution 
stream of a mutated program is identical to that of the origi­nal version up to the point where the mutate 
d statement is executed . If each mutated program begins execution at the beginning of the pro ­gram, 
this results in duplicated work . A combined-stream execution approach takes advantage of this duplication 
of effort by having the interpreter split the execution stream of th e original program to begin mutant 
execution a t the point where the mutated statement appear s in the program . The execution paths form 
a tre e such as the one in Figure 3 . (Boxes represen t mutated program lines and circles represent ori­ginal 
source lines .) Figure 3 . Combined-Stream Executio n If properly implemented, this technique coul d 
significantly improve the execution speed of a mutation interpreter . 16 .2 Data flow Looking at the 
interpreter's execution of a program from the perspective of dataflow tech­niques gives another method 
for speeding u p mutant execution. A flow graph can be made of the original execution of the test progra 
m representing changes in the program's data spac e [1]. Since each mutant affects only one node in this 
flow graph, an interpreter could avoid exe­cuting the entire program for each mutant by making the appropriate 
change to the affected node and propagating the change throughout th e flow graph to generate the final 
output . This technique is similar to Howden's weak mutatio n [13], but with fewer restrictions. 16.3 
Multiple source languages During the next phase of Mothra's develop­ment, we plan to generalize the system 
to handle multiple source languages. This will requir e extensions to MIC, revisions to the tools, an 
d the addition of parsers for the other source languages. References <RefA>1. Aho, A. V., Sethi, R., and Ullman, 
J. D . , Compilers: Principles, Techniques, and Tools, Addison-Wesley, Reading, Mass . , 1986 . 2. Bilsel, 
M . S., A Survey of Software Test and Evaluation Techniques, Technical Report GIT-ICS-83/08, School of 
Information an d Computer Science, Georgia Institute o f Technology, April, 1983. 3. Booch, G., Software 
Engineering with Ada , Benjamin/Cummings, Menlo Park, 1983 . 4. Budd, T. A., DeMillo, R. A., Lipton, 
R. J ., and Sayward, F. G., The design of a proto­type mutation system for program testing .  AFIPS 
National Computer Conferenc e Proceedings, Vol. 47, 1978, pp . 623-627 . 5. Budd, T. A., and Hess, R 
. L., EXPER Implementation Notes, unpublishe d manuscript . DeMillo, R. A., Lipton, R. J., and Sayward 
, F . G ., Hints on test data selection : help for the practicing programmer . Computer 11, 4 (April, 
1978) 34-41 . 7. DeMillo, R. A., Lipton, R. J., and Sayward , F. G., Program mutation: a new approach 
to program testing . Infotech State of the Art Report, Software Testing, Volume 2: Invited Papers, Infotech 
International, 1979, pp . 107-126 . 8. DeMillo, R. A., McCracken, W. M., Mar­tin, R. J., and Passafiume, 
J. F., Softwar e Testing and Evaluation, Benjamin/Cummings , Menlo Park, 1987 . 9. DeMillo, R. A., and 
Spafford, E . H ., The Mothra Software Testing Environment, Techn­ical Report GIT-SERC-87/01, Softwar 
e Engineering Research Center, Georgia Insti­tute of Technology, January, 1987 . 10. Girgis, M. R., 
and Woodward, M. R., An experimental comparison of the error expos­ing ability of program testing criteria 
.  Workshop on Software Testing Conferenc e Proceedings, IEEE Computer Society Press , July, 1986, pp 
. 51-60 . 11. Howden, W. E., Reliability of the path analysis testing strategy . IEEE Transactions on 
Software Engineering SE-2, 3 (1976) 208 ­ 215 . 12. Howden, W. E., Functional testing an d design abstractions 
. Journal of Systems an d Software 1, 4 (1980) 307-313. 13. Howden, W. E., Weak mutation testing and 
completeness of test sets . IEEE Transactions on Software Engineering SE-8, 4 (1982) 371 ­  379 . 14. 
King, J . C ., Symbolic execution and pro ­gram testing . Communications of the ACM 19, 7 (1976) 385-394 
. 15. Nowitz, D. A., and Lesk, M. E., A dial-up network of UNIX systems . UNIX Syste m Manager's Manual, 
4.2 Berkeley Software Distribution, Virtual VAX-11 Version, Com­puter Science Division, University of 
Cali­fornia at Berkeley, March, 1984 .</RefA>   
			

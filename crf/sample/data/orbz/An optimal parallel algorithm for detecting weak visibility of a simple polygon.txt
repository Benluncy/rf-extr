
 An Optimal Parallel Algorithm for Detecting Weak Visibility of a Simple Polygon (Extended Abstract) 
 Danny Z. Abstract The roblem of detecting the weak visibilit of an n-vertex slmp 1 e polygon P IS that 
of finding whet x er or not P is weakly visible from one of its edges and (if it is) identifying every 
edge from which P is weakly visible. In this paper, we present an optimal parallel algorlthm for solving 
thm prob­ lem. Our algorithm runs in O(log n) time using O(n/ log n) processors in the CREW-PRAM computational 
model, and E very different from the sequential algorithms for this prob­lem. This algorithm also enables 
us to op~irnally sollve, in parallel, several other problems on weakly vmlble poly,gons. Introduction 
Visibility is one of the most fundamental topics in computa­tional geometry. Visibility problems arise 
in many applica­tion areas, such as computer graphics, vision, VLSI dlesign, and robotics. Visibility 
problems also appear as subprob­lems in other geometric problems (like finding the short­est obstacle-avoiding 
paths and computing intersections be­tween geometric figures). Therefore, a great deal of research has 
been devoted to finding efficient algorithms for solving various visibility problems, in both sequential 
and parallel computational models. Weak visibility problems concern visibility with respect to observers 
in the shape of line segments. An important class of weak visibility problems deals with the case where 
the opaque object is the boundary of a simple polygon. For a point p in a polygon and a line segment 
s, p is weakly visible from s if p is visible from some point on s. An example of such problems is that 
of computing the region inside a polygon that is weakly visible from a segment. Fcm this problem, many 
sequential algorithms [4, 12, 14, 18, 23] and a parallel algorithm [11] have been discovered. For more 
examples of the weak visibility problems on simple polygons, see [2, 3, 6, 13, 15, 22]. This paper considers 
the problem of detecting the weak visibtity of a simple polygon. An n-vertex simple polygon *Department 
of Computer Science, Purdue University, West Lafayette, IN 4 7g0 i. This research was partially supported 
by the Office of Naval Research under Grants NOO014-84-K-0502 and NOO014-86-K-0689, the Na,tional Science 
Foundation under Grant DCR-8451393, and the Na­tional Library of Medicine under Grant Ro1-LM051 18. Permission 
to copy without fee all or part of this material is granted provided that the copies are not made or 
distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association for Computing 
Machinery. To copy other­wise, or to republish, requires a fee andlor specific permission. 8th Annual 
Computational (_ieomeny, blY2, Berlin, Germany @1992 ACM 89791 -518-6/92/0006/W63 . . . . .. ... $1.56 
63 Chen* P is weakly visible if there exists an edge e of P such that any point of P is weakly visible 
from e (e is called a weakly u:sible edge of P). The problem of detecting the weak visibility of P is 
that of finding whether or not P is weakly visible and (if it is) identifying ail weakly visible edges 
of P. Note that this problem is a natural generalization of the well-known problem of computing the kernel 
of a simple polygon [19]. (Recall that a point is in the kernel of a polygon iff the whole polygon is 
visible from that point, and that a polygon with a nonempty kernel is called a star-shaped polygon [21].) 
Avis and Toussaint [2] first consider the problem of de­tecting the weak visibility of a simple polygon. 
They present a sequential linear time algorithm for the following case: check whether or not a polygon 
P is weald~ visible from a specified edge e of P. Another sequential linear time al­gorithm for this 
case was recently given in [13]. Using the algorithms in [2, 13], the problem of detecting the weak visi­bility 
of P can be trivially solved in 0(n2 ) time (by checking separately each edge of P), but Sack and Suri 
[22] succeeded in finding a linear time rdgorithm for this problem. Our in­terest here is to solve this 
problem in paralleL The parallel computational model we use is the CREW-PRAM; this is the synchronous 
shared-memory model where multiple pro­cessors can simultaneously read from the same memory lo­cation 
but at most one processor is allowed to write to a memory location at each time unit. Based on the observations 
of Sack and Suri [22], a sub­optimal parallel algorithm can be easily obtained by using the recent result 
of Goodrich et ai. [11] on constructing a data structure that supports ray-shooting queries [4]. This 
algorithm first preprocesses P and builds the data structure in O(log n) time using O(n) processors [1 
1], and then does O(n) ray-shooting queries by using the data structure. Tbe algorithm takes in total 
O(log n) time and O(n log n) work (the work complexity of a parallel algorithm is the total number of 
operations performed by the algorithm). Obvi­ ously, the work complexity of this algorithm is a factor 
of log n away from optimality. The sequential algorithm in [22] manages to avoid doing the ray-shooting 
queries, but that method seems to be inherently sequential. Our method for obtaining an optimal parallel 
algorithm is very different from the above approaches. We give geo­metric insights and parallel techniques 
which enable us to use the divide-and-conquer strategies and to avoid the dif­ficulty of doing ray-shooting 
queries. Our algorithm runs in O(log n) time using O(n/ log n) processors, and is ob­viously optimal. 
We also use this algorithm to optimally solve, in parallel, several other problems on weakly visi­ble 
polygons (such as the shortest paths, triangniation, and one cruising guard [6] problems); these parallel 
solutions all take O(log n) time using O(n/ log n) processors and avoid Figure 1: Illustrating HE? and 
HE;. the preprocessing step of triangulating an arbitrary simple polygon. (The best known parallel algorithms 
for trian­gulating a simple polygon require O(n) processors in the CREW-PRAM [9, 24], or O(n/ log n) 
processors in the more powerful CRCW-PRAM [10], and O(log n) time.) The ge­ometric insights we present 
could be useful in solving other geometric problems. There are two major subproblems solved by our weak 
 visibility algorithm: (1) identifying all weakly visible edges for a star-shaped polygon whose kernel 
contains a convex vertex, and (2) checking whether or not a polygon is weakly visible from a specified 
edge (i.e., the case solved by [2, 13]). The solutions to these two subproblems could be interesting 
in their own right. The problem of detecting the weak visi­bility of a simple polygon is reduced to the 
two subproblems. The idea for the reduction is derived from the one used in [22], but our reduction procedure 
is very different from [22]. Owing to the limitation of space, we leave the reduction and the applications 
of the algorithm to the full paper. The rest of this paper consists of 4 sections. Section 2 gives some 
notations and preliminary results on the weak visibility of a simple polygon. Section 3 discusses several 
geometric and computational observations needed by the algorithm. Sections 4 and 5 describe the algorithms 
for solving the two subproblems mentioned above, respectively.  Preliminaries An n-vertex simple polygon 
P is given as a sequence (VI, V2, . . . . W) of its vertices, in the order in which they are visited 
by a counterclockwise walk along the boundary of P, starting from vertex m. An edge of P joining w and 
r-r,+l . w denoted by e, = V,v, +l (= V,+l v,), with the convention that W+ I = VI. The boundary of P 
is denoted by bd(P). Without loss of generality (WLOG), we assume that no edge of P is vertical and no 
three consecutive vertices of P are collinear. Vertex v, is convex if the interior angle of P at v, is 
< ir. Edge e, is conuezif both v, and W,+l are convex. For a vertex U, if V,+ I (resp., v, 1 ) iS nonconvex, 
then let T: (resp., T:) be a ray starting at v, and containing e, (resp., e,_l ). The set of all such 
ry s (resp., r; s) is denoted by Ray+ (P) (resp., Ray-(P)). Let h: (resp., hj) be the first point at 
which r~ (resp., r-,-) hits bd(P) e, (resp., bd(P) e, _l ) (i. e., v, is closer to h: (resp., h:) than 
to any other point in ~~ n (M(P) -e,) (resp., r,-n(bd(P) -e,_l))). Let h? (resp., h;) be on e~ Vj (resp., 
e~ v~) for some j (resp., k). Then we call the consecutive edges that are on the portion of bd(P) from 
V,+z (resp., VI-2) counterclockwise (resp., clockwise) to Oj (resp., vk) the counterclockwise (resp., 
ciockwise) hzdden edges of v,. The set of counterclockwise (resp., clockwise) hidden edges of v, is denoted 
by HE? (resp., HE;) (see Fig. 1). For examples, in Fig. 1, HEY = {es, el } and HE: = {e,}. Note that 
HE~ (resp., HE;) can be empty. The union of all HE: (resp., HE:) is denoted by HE+ (P) (resp., HE-(P)). 
We henceforth call h~ (resp., h;) the first-hit point of r? (resp., T;). The following lemma characterizes 
an important property of the weakly visible polygons. Lemma 1 (Sack and Suri [22]) Suppose that poiygon 
P is weakly visible from edge en and en is convex. Then for every 2 =1,2,..., n, the following holds: 
if h~ exists, then h? w the first po:nt on bd(P) e, collinear with e, encountered m the counterclockwise 
walk along bd(P) starting from v,+ 1, and if h; ezists, then h: :s the first point on bd(P) e,-] collinear 
with e,-1 encountered in the clockwise walk along bd(P) starting from v,_l. Proof. See Lemma 3 of [22]. 
0 It is shown in [22] that the set of weakly visible edges of P, denoted by WE(P), is equal to bd(P) 
 (HE+ (P) U HE-(P)) (see Theorem 1 of [22]). For convenience, we call the edges in HE+ (P) U HE-(P) the 
bad edges of P. If HE+ (P) and HE-(P) were available, then WE(P) could be obtained in the desired complexity 
bounds. The main difficulty, therefore, is in computing HE+ (P) and HE-(P). WLOG, we will show the computation 
for HE+ (P) (the computation for HE (P) is similar). A point p is represented by its z-coordinate and 
y­coordinate, denoted by z(p) and y(p), respectively. For a line segment s (resp., a ray r), the line 
containing .s (resp., r) is denoted by i(s) (resp., i(r)). The slope of a line 1 (resp., a segment s, 
a ray r) is denoted by siope(l) (resp., slope(s), s/ope(r)). The chain on bd(P) from v, counterclockwise 
to Vj, i # j, is denoted by bd,j. The size of a chain C is the number of line segments on C, denoted 
by ICl. For three non-collinear points p, g, and r, we say that the directed chain from p to q to r makes 
a left (resp., right) turn if z(r)(y(p) y(g)) + g(r)(z(g) -z(p)) + z(p)y(g) z(q)y(p) > 0 (resp., < 
O). For a directed simple chain C = (Pi, PZ, . . . ,p~), k z 3, C is said to only make left (resp., right) 
turns iff every subchain of the form (p, l ,p,, p,+l ) makes a left (resp., right) turn, l<z <k. If polygon 
P is weakly visible from edge en and en is convex, then for 1 < z ~ j s n, the (directed) shortest path 
from v, to VJ inside P goes through only the vertices on bd,,, and the shortest path only makes right 
turns (this fact is shown in [2, 13]). Hence, we call such a shortest path the internal convex path of 
bd,l, and denote it by ICP(bd,j ). Let 1 be a non-vertical line. We say a point p is above (resp., below) 
/ iff the vertical line passing p intersects 1 at a point g such that y(q) < Y(P) (resp., v(q) > y(p)). 
A segment s is said to be (properly) above (resp., below) 1 if every point of s is above (resp., below) 
1. The upper (resp., lower) half-plane of i is the half-plane defined by 1 whose interior points are 
all above (resp., below) 1. A left (resp., right) half-plane of a ray T is the half-plane whose boundary 
contains r and which is to the left (resp., right) of l(r). For a set L of lines, we use UPCI(L) (resp., 
LPCI(L)) to denote the common intersection of the upper (resp., lower) half­planes for the lines in L. 
Internal convex paths and common intersections of half­planes play important role in our algorithm. We 
will repre­sent the internal convex paths and common intersections of half-planes by a data structure 
called the hull tree [8, 9] or rank tree [.5]. This data structure supports efficient imple­mentation 
for the parallel operations of search, concatena­tion, and split (see [8, 9, 5] for the details). 3 
Some Useful Observations This section gives some useful geometric observations and develops the computational 
machinery needed by the algo­rithm. The following type of tests will be frequently done by the algorithm: 
given a set L of lines and a line segment s, find (i) whether there is a line 1 c L such that s is below 
1, or (ii) whether s is above all the lines in L. We call such a test a lines-us-segment test and denote 
it by Test(L, s). (Note: Another type of tests which is also needed by the algorithm is: (i ) whether 
there is a line 1 E L such that s is above 1, or (ii ) whether s is below all the lines in L. The tests 
for (i ) and (ii ) are handled similarly to the tests for (i) and (ii). Hence we omit the discussion 
for (i ) and (ii ).) Doing Test(L, s) by a brute force method, which checks segment 9 against every line 
in L, is inefficient (it requires O(ILI) work and O(log ILI) time). We would like to achieve O(log ILI) 
time and O(lL1a) work for every Test(L, s) done by the algorithm, where a is some constant, O < a < 1. 
Our method for doing the tests makes use of the common intersection of upper half-planes. It is clear 
that s is above all the lines in L if s is properly contained in UPC7(L). However, it is not necessarily 
true that ifs does not intersect UPC1(L), then s is below a line in L. Our solution tc] the tests is 
based on the following observation. Lemma 2 Given a non-vertical segment s and a set L oj lines, ijL 
is partitioned into two subsets L and L suchl that L (resp., L ) conta:ns the lines of L whose slopes 
are all ~ slope(s) (resp., < slope(s)), then the following is true: (i) s is below a line in L ifls does 
not intersect either UFYY(L ) or UPCI(L ), and (ii) s is above all the lines in L iff s is properly contained 
in both UPCI(L ) and UPCI(L ). Proof. Omitted. See the full paper. 0 The computational lemma below follows 
from Lemma 2. Lemma 3 Given a non-vert:cal segment s and a set L of m lines, suppose that the slopes 
of all the lines in L are ~ (resp., ~) siope(s) and that UPCZ(L) is c~uaiL able. Then using k processors, 
Test(L, s) can be done ~n O(log m/ log(k + 1)) time if UPCI(L) is stored m an arra~, and in O((log m)2/ 
log(k + 1)) twne if UPCZ(L) is stored in a rank tree. Proof. Omitted. See the full paper. 0 Note that 
in Lemma 3, if k = O(m ) for any constant a, O < cr < 1, then the time complexities become 0(1) (when 
UPCI(L) is stored in an array) and O(log m) (when UPCI(L) is stored in a rank tree). Based on Lemmas 
2 and 3, the next lemma describes the basic operation done by the procedure for performing the lines-vs-segment 
tests. Lemma 4 Giuen a non-vertical segment s and a set L of m lines, suppose that L is partitioned into 
mllc subsets LI, LZ, . . . . Lm,ic o~ eguai szze such that the slope of every line In L,+l IS z the slopes 
of all the lines in L,, and that UPCI(L1), UPCI(L2), . . . . UPCI(Lm,/. ) are avai(­ able (each stored 
in a rank tree), where c > 1 is a con­ stant. Then, in O(log m) time using O(mco processors, either the 
resrdt of Test(L, s) M found, or the test range is restricted to a unique LJ (i. e., Test(L, s) u compieted 
by doing Test(L,, s)), where c is a constant and ]/c < c < ]. Proof. There are two possible cases: (I) 
there is a unique subset LJ which contains two lines 1 and 1 such that siope(l ) < slope(s) < siope(l 
), or (2) there is no such Lj. In case (2), we apply Lemma 3 and do Test(L,, s), in parallel, for each 
i = 1, 2, . . . . mllc. Each Test(L,, s) takesO(log m) time using O(m ) processors (by Lemma 3), where 
a = c (l/c) is aconstant and O< a < 1. The answer to Test(L, s) can be easily obtained from the answers 
to the Test(L,, S) S (based on Lemma 2), in the desired com­plexity bounds. In case (l), suppose LJ is 
the unique subset which gives rise to this case. We first do Test (L,, S) for each i # ~ (in O(log m) 
time using O(me ) processors). If the answer to Test(L, s) can be derived from the answers to the mli 
 1 Test(L,, S) S (e.g., there is a line in L Lj that is above s), then we are done. Otherwise, the answers 
to the mllc 1 Test(L,, S) S must be combined with the answer to Test (Lj, s) in order to obtain the 
result for Test (L,s); hence Test(L, s) will be completed by performing Test(L~, s). 0 Note that if Lemma 
4 can be recursively applied to Test(LJ, s), then we only need to repeat the use of Lemma 4 a constant 
number of t?mes in order to reduce the size of the test range to O(rnc ) (at that point the brute force 
method can take over). In this way, Test(L, s) is processed in totally O(log m) time using O(mc ) processors. 
Lemmas 3 and 4 require that the common intersections of the upper half-planes be available before the 
tests are performed. The computation for the common intersection of m half-planes, in general, requires 
O(log m) time and Ct(m log m) total work. In our situation, there can be as many as O(n) rays (and thus 
O(n) half-planes) to consider. It would be impossible to compute the common intersection of O(n) half-planes 
in O(log n) time using O(n/ log n) pro­cessors if the O(n) rays were arbitrary. Next, we show that if 
polygon P is weakly visible from a convex edge, then it is possible to obtain a subset of Ray+ (P) (resp., 
Ray-(P)), denoted by DR+ (P) (resp., DR (P)), with the following properties: (i) HE+ (P) (resp., HE-(P)) 
can be computed by using only DR+ (P) (resp., DR-(P)), and (ii) DR+(P) (resp., DR-(P)) can be easily 
partitioned into two subsets, each containing rays sorted by slopes. The rays in DR+ (P) (resp., DR-(P)) 
are called the dominating rays of Ray+ (P) (resp., Ray-(P)). We just discuss the case for DR+(P) (the 
case for DR-(P) is similar). WLOG, we assume that P is weakly visible from convex edge en, that en is 
horizontal, and that l(e~) is below P en. We define the polar angle of a ray r,+ E Ray+ (P), denoted 
by a(r> ), as follows: let the starting vertex V, of r~ be at the origin; then a(r~ ) is the angle from 
the positive z-axis counterclockwise to r?. Note that O ~ a(r>) < 27r. For rays r: and r; in Ray+ (P), 
z < j, we say r: dom~nates r+ f ~(r~) ~ ~(r;), Let DR+(P) consist of the raYs ill 1 Ray+ (P) that are 
not dominated by any ray in Ray+ (P). The following lemma characterizes DR+ (P). and ~+ in Ray+ (P)j 
t < j, if ~Lemma 5 For rays r~ dominates T;, then HE; ~ H~~ for some k, i ~ k < I. Proof. Let Q be the 
polygon formed by segment V,+l h: and the subchain of bd(P) from V,+l counterclockwise to h+ (h: is the 
first-hit point of r~). WLOG, assume that h! # VJ. There are two possible cases: (a) VJ is in Q (see 
Fig. 2 (a)), and (b) W, is not in Q (see Fig. 2 (b)). We first show that in case (a), HE: ~ HE:. If HE: 
were not a subset of HE:, then h; would have to be outside Q. For this to happen, r; must intersect V,+ 
I h? before hitting h+ (~ince VJ is in Q); furthermore, r; must start in the J  q 1 $, --- I ... I 
t ... I v.~ AF:$ :) $i% Q j 1 . i --- v~, / \-/ \ > \{  i  \ \ /- ~-.- en n 0) (a) Figure 2: Illustrating 
the proof of Lemma 5. right half-plane of r: and hit h; in the left half-plane of r~. When a(r~ ) CY(T} 
) < m, such an intersection between r; and u~+l h: is impossible because Vj is in the right half­ pkme 
of r~ and a(r~ ) ~ cv(r~ ) (e.g., Fig. 2 (a)). When a(r~ ) a(r~ ) > r, such an intersection between 
T; and v,+ 1h? is also impossible for the following reason. That cv(T~) cr(r~) > m impiies that a(r~) 
> z and cr(r~) < m. If r: did not intersect bd(P) ej before crossing w+l h:, then Vj would not be weakly 
visible from en, a contradiction. Hence HE? ~ HE? in case (a). In case (b), chain M(,+l)j first intersects 
the right half­ plane of T: and must later go to the left half-plane of r~ by crossing r: at h?. Let 
h? be on et, 1> i+ 1. Since P is weakly visible from en, the internal convex path zcp(~d(i+l)j ) makes 
right turns only. It is not hard to see that there exists a vertex Vk, / ~ k < j, such that ~fc+l is 
a vertex on ICP(bd(l+l)J) and HE~ ~ HE; (Fig. 2 (b)). Q Baaed on Lemma 5, it is easy to compute DR+ (P) 
in O(log n) time using O(n/ log n) processors (by doing par­allel prefix [16, 17]). Note that the rays 
in DR+ (P) are sorted by polar angles. We further partition DR+ (P) into two subsets DR~ (P) and DR~ 
(P) such that the rays in each subset are sorted by slopes. This partition is done by split­ting DR+ 
( P) using a ray whose polar angle is ~. DR~ (P) (resp., DR~ (P)) contains the rays of DR+ (P) whose 
polar angles are all ~ (resp., >) r. From now on, we aasume that DRf (P) and DR~ ( P) are already available. 
4 Detecting the Weak Visibility of a Star-Shaped Polygon This section deals with the following problem: 
given that P is star-shaped and its kernel contains a convex vertex (say v,), compute the bad edges in 
HE+ (P) using DR+ (P). Clearly, P is weakly visible from e] (since P is visible from w ) and e] is a 
convex edge. The algorithm for this problem has two phases. Phase 1.A computes the internaJ convex paths 
and the data structure storing the common intersec­ tions of the half-planes for the rays of DR+ (P). 
This phase also identifies some bad edges. Phase 1.B completes the identification of all bad edges; it 
makes use of the internal convex paths and the data structure constructed in Phase 1.A. The computation 
consists of two separate parts, one using DRY (P) and the other using DR~ (P). Due to the similarity 
between the two parts, we only discuss the part using DRY (P). 4.1 Phase 1.A We first sketch the outline 
and describe the main opera­ tion of the algorithm, then we give the analysis and some computational 
details.  4.1.1 The Outline We associate each r: 6 DR~ (P) with v., and denote by RC the set of those 
rays in DR~ (P) whose starting vertices are on a subchain C of bd(P). The outline below sketches the 
divide-and-conquer strategies used by this phase. Input. A subchain C of M(P) with ICI = m, Rc, and a 
positive integer d. Step a.1. If m s d, then use one processor to perform the computation in 0(m) time. 
Step a.2. If d < m ~ d6, then divide C into two subchains Cl and CZ of equal size, and recursively solve 
the two subproblems on (CI, RG1, d) and (CZ, RC2, d), in parallel. Then perform the computation for C 
and RC using the output from the recursive calls on the two subproblems, with m/d processors and in O(log 
m + (dlog d) f ) time. Step a.3. If m > d6, then partition C into g = (m/d) l/3 subchains Cl, CZ, . . 
. . Cg of size m2 3d1 3 each. Then recursively solve the g subproblems, in parallel. Fi­nally, perform 
the computation for C and RC using the output from the g recursive calls, with m/d pro­cessors and in 
O(log m) time. Observe that, if we could perform the various steps of the above outline within the claimed 
complexity bounds, then a procedure with such an outline would run in O(d + log m) time with O(m/d) processors. 
Choosing d = log m, then the time and processor complexities become O(log m) and O(m/ log m), respectively. 
Therefore, a call to the proce­dure with input (C, Rc, log n), ICI = n, will take O(log n) time using 
O(n/ log n) processors. We must discuss what exactly is computed within the above outline. Let L(Rc) 
be the set of lines containing the rays in RC. The following is computed in Steps a.1 a.3. (i) Compute 
the internal convex path ICP(C). (ii) Build the data structure which stores the common in­tersection 
of the relevant half-planes of L(Rc ) (e.g., UPCI(L(RC ))) (this data structure is needed for per­forming 
the lines-vs-segment tests).  (iii) Do the iines-vs-eegment tests to identify the bad edge, on C (we 
may not be able to identify all the bad edges in this phase; some of them are left to Phase 1. B). Since 
P is star-shaped, in each of the three steps, the internal convex paths for the subchains of bd(P) can 
be computed in the required complexity bounds by using the algorithm in [5]. By Lemma 5, RC (thus L(RC 
)) is sorted by slopes. Hence the common intersection of the relevant half­planes for L(Rc) is also computable 
in the required com­plexity bounds (e.g., by the algorithms in [8, 5]). Thereforej we will focus on how 
to use the internal convex paths and the data structure for the lines-vs-segment tests returned from 
the recursive calls to identify the bad edges in this phase. Vb Van.< .................. . *VI) ..... 
....... va ----­.0--A j Cj Cj  (c) (d) Figure 3: Illustrating the four cases of IICP(CJ )[. 4.1.2 
The Main Operation The following operation is cruciaf in the conquer stages of Steps a.2 and a.3 (say, 
in Step a.3): given ICP(C, ) and UPCI(L(RC, )), .s = 1, 2, . . . . g, determine the bad edges on CJ using 
Rc,, for every pair of tand J, 1s z< J s g. We classify ICP(Cj ) into one of four possible cases according 
to its size, and show how to determine the bad edges on C, by using Rc, in each case. The classification 
is as follows. Case (a). ICP(Cj ) has more than 3 segments (see Fig. 3 (a)). Then afl the edges on CJ 
are bad. in Fig. 3 (a.), the edges on C, are all contained in HE~_, U HE;+,. Hence there is no need to 
use Rc, to identify the bad edges on CJ. Case (b). ICP(CJ ) has exactly 3 segments (see Fig. 3 (b)). 
Then the edges on subchains bdab and bdcd of C, are alf bad (cf. Fig. 3 (b)), because they are contained 
in HE~_l . . u HE;+,. Furthermore, If ?Jb?Jc1s not an edge of P (i.e., c > b+ 1), then alf the edges 
on Cl are bad because the edges on subchain bdb. are also contained in HE~_l U HE;+, . The only edge 
on Cj that may not be bad is ?Jb7Jc,provided that c = b + 1. Thus the problem in this case, when c = 
b + 1, is that of finding whether or not vbvb+ ~ is bad with respect toRc, . Case (c). ICP(C, ) has 2 
segments (see Fig. 3 (c)). Then clearlY all the edges on C. j, except the two edges ub 1 ~E and ?Jb Ub+l, 
are bad (cf. Fig. 3 (c)). We need to check iJb_] Vb and Vbvb+ I by using Rc,. Case (d). ICP(C3) has 1 
segment (see Fig. 4 (cl)). If there is a ray r; G Rc, such that bd.b $ HE?, then certainly alf the edges 
on Cj are bad. Otherwme, we might have to shoot the rays of Rc, onto Cl to find which of the edges on 
C$ are bad (this ray-shooting on C~J is to be done in Phase 1. B). Thus we need to check whether bd.b 
~ HE: for a r~ c Rc,. This check is done by testing segment ~ against the rays in Rc,. From the discussion 
above, it is clear that the main com­ putation in Cases (a) (d) is to test an edge of CJ (in (Cases (b) 
and (c)) or a segment of ICP(Cj) (in Case (d)) against the rays in Rc,, in order to find out whether 
the edge of Cj or Cj itself is bad with respect to Rc, . We call such a test a bad-segment test. We need 
some notations for describing the solution to the bad-segment tests. WLOG, let v] be at the origin and 
el be on the positive z-axis (hence P el is above l(el)). The polar angle of a point p G bd(P) V1, 
denoted by a(p), is the one from the positive z-axis counterclockwise to the ray starting at VI and going 
through p. Since v] is in the kernel of P and rJl is convex, it follows that O ~ a(p) .: ~ for .-*  
et N \   0-- \\ Ies: \ \ 1 \ I - r-+---o,  \, ~-~ V1 Figure 4: Illustrating the proof of Lemma 
6. each point p G bd(P) V1, and that the polar angles of the points on bd(P) VI, from VI counterclockwise 
to Vn, are in non-decre~ing order. For each r~ 6 DRY(P), h: is on For a ray r~ c DR~ (P) and a segment 
s, we say s is properly contained in the upper-right (resp., upper-left) quarter-plane of r? iff (i) 
s is contained in the intersection of the right (resp., left) half-plane of r: and the left half­plane 
of the ray starting at VI and going through v~+ 1, and bd(t+z)l. (ii) s does not intersect r~. Observe 
that if el E HE~, then et is properly contained in the upper-right quarter-plane of + Tt . WLOG, we assume 
that for each ray r in Rc, the right half-plane of r is equaf to the lower half-plane of line Z(r). We 
would like to obtain the answer to the bad-segment test on Rc, and a segment s (of C j or ICP(C3 )) by 
perform­ing a lines-vs-segment test Test(L(Rc, ), s) (because we can handle Test(L(RC, ), s) by using 
Lemma 4). In generaf, how­ever, a bad-segment test cannot be answered by a lines-vs­segment test. For 
example, fine Z(r) intersecting a segment s does not necessarily imply that ray r also intersects s . 
Furthermore, even though the half-line defined by a ray r E Rc, does intersect segment s (of CJ or ICP(Cj 
)), r may first-hit a point on some Ck, i ~ k < j, before it intersects s (i.e., ck blocks r from reaching 
s if r is viewed as a beam of light emanating from its starting vertex). Therefore, even if the result 
of Test(L(RC, ),s) does indicate that s is properly contained in the upper-right quarter-plane of r~ 
for a r~ 6 Rc,, the rays of Rc, may be totally blocked from CJ. This means that, in this situation, no 
edge of C, truly belongs to HE: for any rt+ E Rcx, and hence no edge of CJ is bad withrespect to Rc,. 
If we had to find out whether or not Rc, is totally blocked from Cl, then for every k, z ~ k < j, we 
might either do ~(l~cp(ck)l) bad-segment tests (for Rc, and each segment of lcp(ck )), or shoot each 
ray of Rc, on lCP(Ck) (by doing a binary search on lCP(C~)). Since we can have \ICP(C~)l proportional 
to lCk I and lRc, I proportional to IC, 1, either method would be too expensive to be performed within 
the desired complexity bounds. The next lemma saves us from doing these costly computations. Lemma 6 
If a ray r G Rc, first-hits some Ck at edge e., i S k < J, and if edge e~ on C~ w properly contained 
tn the upper-right quarter-piane of r, then there ezzsts a vertez v, on bd(, _l)(W 2) such that e~ ~ 
HE:. Proof. Chain bd( ~_l)W must start in the right half-plane of r. It then intersects r on e,, and 
eventually enters the right half-plane of r to join VW (see Fig. 4). Since P is visible from V1, ICP(bd,W 
) makes right turns only. Hence there must exist a vertex V.+l on ICP(bd.~) such that s 1 <z<w 2andeWGHE~. 
0 Lemma 6 implies that if edge e~ of CJ is properly con­tained in the upper-right quarter-plane of a 
ray r E Rc,, then e~ is definitely a bad edge. Note that for any k such that k < t or k > ~, Ckl cannot 
block the rays of Rc, from Cj (by Lemma 1). The next lemma justifies the use of the lines-vs-segment 
tests for the bad-segment tests. Lemma 7 For i < ~, a bad-segment test on Rc, and a segment s of C, or 
IC P(Cj) can be done by using Test(L(RC, ),s). Proof. Let r~ be a ray in Ret. Recall that by our as­ 
sumption, the left half-plane of r~ is the upper half-plane of i(r~ ). The lemma holds if the folfowing 
is true: (i) s is properly contained in the upper-right quarter-plane of r? iff s is below Z(r$ ), and 
(ii) s is properly contained in the upper-left quarter-plane of r? if s is above l(r~ ). We only give 
the proof for (i) (that for (ii) is very similar). If s is properly contained in the upper-right quarter-plane 
of r:, then s is below i(r~ ). If s is below Z(rt), then s is prop­erly contained in the lower half-plane 
of 1(T: ) (i.e., the right half-plane of r-~) and certainly s # vtot+]. The facts that z < J, that s 
# Vtvt+l, that P is visible from O], and that U1 is convex, together imply that cr(vt+l) s a(~) < ir 
for each point p on s. This means that s is to the left of the ray r starting at VI and going through 
vt+l, and thus s is in the left half-plane of r. n If the result of Tesf,(L(Rc, ),s) indicates that neither 
(i) s is below a line in L(Rc, ) nor (ii) s is above all the lines in L(Rc, ), then there must be a ray 
T c Rc, such that the half-line defined by ~ intersects s. We need to distinguish two types of intersection 
between r and s. Suppose that Test(L(RC, ),s) indicates that neither (i) nor (ii) occurs. Let ray r in 
Rc, intersect s. Let s = v~vb, a < b, and let r(s) be the ray starting at V. and going through Vb. If 
the starting vertex of r is properly contained in the right half-plane of r(s), then we say r pseudo-hits 
s; otherwise, r does not pseudo-h~ts. Furthermore, Rc, is said to pseudo-hit s if (1) for each ray r 
in Rc,, r intersecting s implies that r pseudo-hits s, and (2) there is at least one ray in Rc, that 
pseudo-hits s; otherwise, we say Rc, does not pseudo-hits. We distinguish the types of hits from Rc, 
on s because only when Rc, does not pseudo-hit s can the rays in Rc, first-hit bdab -V. (it is stilf 
possible that Rc, is blocked from bdab). If Rc, pseudo-hits S, then clearly no ray in Rc, can first-hit 
bd~b VO. We define the polar angle of s as a(s) = cr(~(s)) (with obvious meaning for a( r(s))). The 
foflowing lemma charac­terizes the types of hits. Lemma 8 Suppose that a ray r~ of Rc, intersects a seg­ 
ment s on ICP(Cj), t < J. Then ry pseudo-hits s iflcv(r~) > cl(s). Proof. Omitted. See the full paper. 
0 The next Lemma shows that the lines-vs-segment tests can be used to find out the type of hits from 
Rc, on s. Lemma 9 The type of hits from Rc, on a segment s o-f ICP(CJ ), i < J, can be determmed by using 
the lines-vs­ segment tests, in the same complexity bounds as those for Test(L(Rc, ),s). Proof. Omitted. 
See the full paper. 0 If the result of Test(L(Rc, ), s) indicates that s is neither below a line in L(Rc, 
) nor above all the lines in L(RC, ), then one of the following three situations occurs: (]) if s is 
an edge of Cj, then s is not bad with respect to Rc,, or (2) if s is not an edge of Cl and Rc, pseudo-hits 
s, then bdab is not bad with respect to Rc, (where .s = va?J&#38; a < b), or (3) if s is not an edge 
of C j and Rc, does not pseudo-hit s. then IICP(C3 )1 may be Case (d) (which is to be handled in Phase 
I. B). 4.1.3 Performing Z est(L(RC, ),s) in Step a.3 We need to discuss how the fines-vs-segment tests 
are ac­tually performed in the algorithm. We only discuss this for Step a.3 (Step a.2 is left to the 
fulf paper). In Step a.3, there are 0(g2) = 0((rn/d)2/3) pairs of C, and Cj, i < j, where m = IC1. For 
each pair of C, and CJ, we need to do Test(L(Rc, ),s) for O(1) segments s on ICP(CJ), if ICP(CJ ) is 
not of Case (a). There are totally O(m/d) processors available. Thus O(g) = 0((m/d)li3) processors are 
allocated to each pair of C, and CJ. It suffices to show how to do one Test(L(RC, ),s) using O(g) processors. 
Our primary tool is Lemma 4. In Step a.3, to perform Test(L(Rc, ),s) in O(log m) time, we need to achieve 
two things: (i) in performing the test, Lemma 4 is recursively applied only O(I) times, and (ii) the 
size of the test range, after (i) is done, is reduced to 0((m/d)lf3) (so that the brute force method 
can take over). In the conquer stage of Step a.3, UPCI(L(Rc, )) is avail­able (stored in a rank tree), 
for each z = 1, 2, . . . . g, and we compute UPCZ(L(RC )) from the UPCI(L(RC, )) s. Because L(Rc) is 
sorted by slopes, for each i, bd(UPCI(L(Rc, ))) n bd(UPCI(L(RC))) consists of at most one connected compo­nent, 
and bd(UPCI(L(Rc, ))) bd(UPCI(L(Rc))) consists of at most two connected components. After UPCI(L(RC 
)) is computed, we still retain the (at most) two connected components of bd(UPCI(L(Rct))) bd(UPCI(L(Rc))) 
in two separate rank trees. This structure can be readily maintained in every recursion level of Step 
a.3. us­ing this structure, it is easy to obtain the information about each UPCZ(L(RC, )) (either from 
UPCI(L(IZC)) or from the two connected components of bd(UPCZ(L(Rc, ))) bd(UPCI(L(RC )))). Furthermore, 
for a subchain C: of C,, the information about iYPC1(L(Rck )) can be obtained from UPCI(L(RC, )) and 
UPCI(L(Rc~j) UPCZ(L(RC, )). In general, the information about tie common intersection of the half-planes 
at each level of the afgorithm can be ob­tained from the information stored at its ancestor levels. WLOG, 
we assume that in the recursive call on (C,, Rc,, d), C, was partitioned into O((m/d) / ) subchains (the 
caae where C, was as in Step a.2 can be eaaify taken care of within the desired complexity bounds). In 
perform­ing Test(L(RC, ), s), we repeat the following two steps. (i) Apply Lemma 4 to Test(L(Rc, ), s) 
using 0((rrz/d)lj3 ) pro­cessors. (Note that the information on UPCI(L( Rch )), for each subchain C,k 
of C,, is obtained using the structure described in the previous paragraph. ) (ii) Either we have found 
the answer to Test(L(RC, ), s) in (i), or we have re­ duced the test to a unique subchain C! of C,, in 
which case we continue the test by repeating (i) for Test(L(Rc: ), s). The size of C is m at the current 
recursion level of the algorithm. The following can be easify proved by induc­tion: at the i-th recursion 
level below, z ~ 1, the chain size is O(m~t Jdl ~(~)) and the chain is partitioned into O((m/d)f( J(l 
/3)) subchains (for the (i+ I )-th level), where ~(t) = (2/3) . We want to stop the recursive procedure 
for Test(L(Rc, ), s) when we reach the structure for the z-th level below (in the recursion tree of Phase 
1.A) for some i z 1, such that the size of the chain at that level is < (m/d)113. Hence we have (m/d) 
l/s ~ mf(;)d]-f(:), which is equivalent to m(l/3)-f(:) > d(4/3) f(:) Choosing i to be 5, the inequality 
becomes ~49/243 > ~1+(49/243), and it holds aa long as m z de. Thus, the test range size is reduced to 
O((rrz/d)l f3 ) by going down at most five IIevels in the recursion tree of Phase 1.A.  4.1.4 The Procedure 
for Step a.3 We only sketch the computation for Step a.3, as follows. (1) For every pair of C, and C, 
such that i < j and IICP(CJ)I is not Case (a), do Test(L(Rc, ), s) for each segment s on lCP(CJ ). (2) 
For every Rc,, find all segments s such that s is tested in (1) and s is not beiow any line in .L(Rc, 
); furthermore, among these segments s, find s, = ~ such that the vertex indices a and b for s, are no 
bigger than the vertex indices for any of these segments, where a < b (by Lemma I, Rc, cannot reach any 
of these segments other than s,). Let s, be on lCP(CjI) for some j . (3) If llCP(CJ, )\ is Cases (b) 
or (c), or s, is above all the lines in L(RC, ), or Rc, pseudo-hits s,, then the bad edges on the subchain 
of bd(P) from the last vertex of C, counterclockwise to 215 (on Cjt ) can be determined; otherwise, lICP(Cj/ 
) I is Case (d) and Rc, does not pseudo-hit s, (in this case, we will decide in Phase 1.B the bad edges 
on the subchain of bd(P) from C, counterclockwise to CJt ).  4.2 Phase 1.B By using the structure built 
in Phase 1.A, this phase fin­ishes the identification of the edges in HE+ (P). Phase 1.B has the same 
algorithmic outline as Phase 1.A. Its com­putation follows the recursion tree of Phase 1.A, level by 
level, from the root down to the leaves. The following operation is typicaJ in this phase: iden­tify 
the bad edges on C by using Rc, where C # C and IICP(C )1 is Case (d). What we do is to shoot Rc onto 
each subchain C: of C . Thus, we encounter one of the four cases at each ICP(CJ), and we may have to 
continue the recursive computation on a unique C; where IICP(C~ ) I is again Case (d). We will not go 
into the details of this procedure, since these details are similar to those in Phase 1.A. But we would 
like to point out one thing that must be handled carefully in this top-down procedure, ss follows. If 
one keeps using the same data structure for Rc (i.e., UPCI(L( Rc))) in the upcoming recursion levels 
below C , then the same O(log ICl) time will be spent at each level. This will not give an O(log n) time 
algorithm; instead, the time bound so resulted will be O(log n log log n). To avoid this ineffi­ ciency, 
what we do when shooting RC onto Cl is to par­ tition C into g = (lC1/cf)113 subchains Cl, C2, . . . 
. Cg (as in Phase 1. A). Then, by using the structures for the UPCZ(L(Rck )) s (rather than UPCI(L(RC))), 
every RCA is independently shot onto each of the C; s. Note that each UPCl(L(RCk )) can be recovered 
from UPCI(J5(RC ) ) and from the (at most) two connected components of UPCI(L(RC, )) UPCI(L(RC) ) in 
the desired complexity bounds. 69 Vj /:/;t\v .-~  ay:, J+l j 1 V Sj(k) : ~j(i) vi Pi en Figure 5: 
Illustrating Lemma 10. 5 Checking the Weak Visibility of a Polygon from an Edge This section concerns 
the following problem: check whether or not a simple polygon P is weakly visible from a specified edge 
e of P (i.e., the case solved sequentially in [2, 13]). We show how to solve this problem in O(log n) 
time using O(rt/ log n) processors. Our solution consists of two parts: a preprocess and a two-phase 
procedure. WLOG, let e = en, en be on the z-axis, and Z(V1) > Z(vn). The preprocess reduces the problem 
to that of checking the weak visibility of a simple polygon from a conuezedge. Also, the preprocess checks 
to make sure that for every Z, 1 < z < n, none of the following local conditions is satisfied: (i) e 
does not intersect the left half-plane of r(e,), and (ii) cr(r(e,-1)) < rr, cr(r(et)) > r, and v, is 
nonconvex, where r(e, ) is the ray starting at v, and containing e,. (For any Z, P is not weakly visible 
from e if either (i) or (ii) is satisfied. ) The two-phase procedure handles the problem of checking 
the weak visibility of P from a convex edge (say, en). 5.1 The Basic Idea We still use ICP(bd,J ) to 
represent the directed shortest path from v, to v, that goes through only the vertices of bd,J (i.e., 
the computation of ICP(bd,J ) is based only on bd,j and disregards bd(P) bd,~ ). Note that in general, 
ICP(bd,j ) does not necessarily make consistent right turns for z < j; furthermore, ZCP(bd,~ ) may even 
intersect the exterior of P (because it can intersect bd(P) bd,j ). The lemma below gives the basic 
idea for solving this weak visibility problem. For t < i (resp., z > z ), let s,(z ) (resp., s,(i )) 
be the segment on ICP(bd,,l) (resp., ICP(bd,,l, )) that contains u,. Lemma 10 If P is weakly visible 
from e~, then for any t, j, andk,1~i<J<ksn,ascan oftheinterior angle of P at VJ, from edge ej l clockwise 
to edge ej, encounters e~ 1 t ~~(i), S~ (k), and e~ ) in that order (cf. Fig. ~). Proof. Omitted. See 
the full paper. By Lemma 10, if SJ (z) and S3 (k) are not in correct order with ej_l and ej for some 
i, j, and k, i < j < k, then Pis not weakly visible from e. If they are in correct order, then there 
is a ray (say, the one starting at VJ and containing S~(z)) separating ICP(bd,3) from ICP(bd3~). Let 
the ray starting at u, and containing s, (i) be denoted by T(sj (i)). If r(SJ (z)) seParates ~CP(bd:J 
) from l@(bd~~ ), then l@(bdt~) can be computed efficiently from ICP(bd,j ) and ICP(bdjk ). This is the 
idea used in the recursive abzorithm. It is known that if there is a ray (e.g., X(SJ (1 ))) separating 
ICP(bdlj ) from ZCP(bdJn) for every j, 1 < J < n, then P 1s weakly visible from e (e. g., see [12]). 
Our ultimate goal, therefore, is to compute s,(1) and Sj (n) for every J and check their relative order 
based on Lemma 10. Clearly, our main problem is to compute all the s] (1) s and s, (n) s. The algorithm 
for computing the SJ (1 ) s and Sj (n) s con­ sists of two phases. Phase 2.A uses Lemma 10 to com­pute 
the internal convex paths on certain subchains of bd(P) (hence at every recursion level, either it succeeds 
in comput­ing ICP(C) for a subchain C of &#38;f(P), or it concludes that P is not weakly visible from 
e). After the first phase is com­pleted, if P is still not known to be non-weakly visible from e, then 
the algorithm proceeds with Phase 2 .B. For every j, Phase 2.B constructs K P(bd13 ) and K P(bdJm) (by 
us­ing the internaf convex paths obtained in Phase 2.A) and reports s,(1) and SJ (n). We need to characterize 
ICP(bd,3 ) before going to the two-phase algorithm. For bd,j, i < J, we say ICP(bd,j ) is in order if 
the vertices of ICP(bd,j ) are in increasing order of vertex indices in the walk of ICP(bd,J ) from v, 
to V3. For a segment s = ?Ja Ob, a < b, let r(s) be the ray starting at V. and containing s. The following 
lemmas enable us to compute the internal convex paths efficiently. Lemma 11 Suppose P is not known to 
be non-weakly vis­ ible from e. For i < j, if ICP(bd,j) is m order and makes only right turns, then for 
two consecutive segments v~vb and ~ on ICP(bd,J), a < b < c, cr(r(m)) < cr(r(~)). Proof. If er(r(~)) 
~ m, then the lemma is obviously true because ICP(bd,j ) is in order and makes only right turns. If a(r(~)) 
< m, then either cr(r(~)) < cv(r(~)) or CY(r(VbV~)) > O (T(VaVb)) + T (since ICP(bd,~) makes only right 
turns). But cs(r(~)) > a(r(~)) + m and ICP(bd,J ) being in order imply that the locaf condition (ii) 
tested in the preprocess is satisfied at Ub, a contradiction. 0 Corollary 1 Suppose P w not known to 
be non-weakly vis­ible from e. For z < j, if ICP(bd,J) is m order and makes only right turns, then the 
polar angles of the segments on ICP(bd,j ) are m sorted order. Proof. An immediate consequence of Lemma 
11. 0 Lemma 12 Suppose P is not known to be non-weakly vis­iblefrom e. Fori,j, andk,1si<j<ksn,ifboth 
ICP(bd,J) and ICP(bdJk) are in order and make only right turns, then ICP(bd,k) is in order and makes 
oniy right turns. Proof. Omitted. See the full paper. 1 Lemma 13 Suppose P w not known to be non-weakly 
vis­ible from e. For i < j, if ICP(bdtj) is in order and makes only right turns, then ZCP(bd,J) can be 
partitioned into at most two subpaths C and C such that C (resp., C ) as completely on the convex hull 
of C (resp., C ). Proof. Let 1 be the horizontal line tangent to ICP(bdt, ) (let Z touch ICP(bd,J ) at 
v.), such that ICP(bd,, ) V. is above 1. By Corollary 1, the polar angles of the segments on ICP(bd,a) 
(resp., ICP(bdaJ)) are all ~ rr (resp., ~ m). Hence, ICP(bd,~) (resp., ICP(bdaj )) is completely on the 
convex hulf of ICP(bd,Q) (resp., ICP(bdaj )). 0  5.2 Phase 2.A This phase consists of three steps: Step 
c.1, Step c.z, and Step c.3. Its algorithmic outline and recurrences for the time and processor complexities 
are similar to those of Phase 1.A. Given input (C, ICI, d) to each recursive 70 : :r Vzj : ..:.$ Befj 
.,. Vw Aft j  ::..... ,., ...+r* \ 3 ..a 1 ., . t t r .. ,  ­en Figure 6: An example for illustrating 
Lemma 14. call, where C is a subchain of bdln, either an answer no (indicating that P is already known 
to be non-weakly visible from e) or ICP(C) is returned. Alf internaf convex paths in this phase are stored 
in rank trees. Here we only discuss the computation in Step c.3. In Step c.3, a chain C = bd,t is partitioned 
into g = (rn/d)1i3 subchains Cl, Cz, . . . . C,, where ICI = m and s < t.There are 0(g3 ) processors 
available. After the recur­sive calls for the C, s, if P is not known to be non-weakly visible from e, 
then ZCP(C1 ), ICP(C2 ), . . . . ICP(Cg) are alf available. Let v=, be the common vertex of C, and C,+l, 
for each j = 1, 2 . . . . g 1. For each v.,, let Befl (resp., Aftj) denote the subchain of C before (resp., 
after) v=,, that is, l?e~j = bd~,, (resp., Aftl = bdz, ~). One important opera­tion in this step is to 
find s., (s) and s=, (t) for each v=,. This is because if s=, (s) and s.,(t) are in correct order with 
e=, _l and ezj (cf. Lemma 10) for each Vzj, then there is a ray sep­arating every pair of ICP(C, ) and 
ICP( CJ ), which makes the computation of ZCP(C) possible. Note that ICP(BefJ ) and ICP(AftJ ) are in 
generaf not explicitly available for the computation of s,, (s) and S*J (t). We only explain how to use 
Aftjtocompute s=, (t)(the case for s., (s) is sidar). The following lemma is useful in computing the 
sZ, (s) s. Lemma 14 Suppose that P is not known to be non-weakly visible from e and that every ICP(Ck) 
is an order and makes ordy right turns. For a v=,, let r be the ray starting at VZ, and going through 
VI, and let r be the ray on line /(vz, Vn) which starts at v=, and does not contain Vn (see Fag. 6). 
For any i E {j+ 1, ~ +2, . . . . g}, if the intersection of the left half-plane ~p(r) of r and the right 
half-plane rtp(r ) oj r intersects ICP(C, ) VZJ , then P is not weakly visible from e. Proof. Omitted. 
See the fufl paper. E! For example, in Fig. 6, ICP(C, ) v,, intersects ffp(r) n rtp(r- ) in such a way 
that a vertex VW on ICP(C, ) v,, is contained in lfp(r) n rtp(r ). Let T* be the ray starting at v., 
and going through vW. Then en does not intersect the left half-plane of r . Hence P is not weakly visible 
from em. Observe that in Phase 2.A, if P is not known to be non­weakly visible from e, then alf the ICP( 
ck ) s have the prop­erties stated in Lemmas 11 and 12 (that all the ICP(Ck ) s are in order and make 
only right turns can be easily proved by induction by using Lemma 12). Therefore, we can check whether 
each ICP(C, ) v., intersects ifp(r) n rtp(r ) in O(log m) time using O(g) processors. We compute the 
s=, (t) s as follows. We first do the check­ing based on Lemma 14 for every VZJ (in O(log m) time us­ 
ing 0(g2 ) processors). Suppose P is still not known to be non-weakly visible from e, then we compute 
the common tangent between v=, and ICP(C, ) for each C, ~ Aftj, by using the ray starting at v= and containing 
VI v=, as a ray separating v=, from lCP(ti ). This is easily computed in ICP(bd&#38; ) ICp(bdab ) O(log 
m) time using O(g) processors for each C,. Suppose among the O(g) common tangents so obtained, the tangent 
between v=, and K P(C,J ) is the one first encountered if we use a ray originating at v,, to scan around 
V.J clockwise, by starting at ~. Then s,] (t) is the common tangent V.$ Ub between v., and KP(C,J ) (Vb 
is on K P(C,, )). There­ fore, each S,j (t) is computable in O(log m) time using 0(g2 ) processors. 
 Given s., (s) and sZ, (t) for each v.,, if s,, (s) and s., (t) are in correct order with ezj-l and e.j 
(cf. Lemma, 10), then the ray r(sz, (s)) (starting at v=, and containing s,,, (s)) Figure 7: Illustrating 
Lemma 15. separates l?e~j from AftJ, and hence it separates lCJD(C, ) of root( T), and so on, level by 
level, until the leaves of T from lCP(C~ ) for each C, ~ Be$J and each ck ~ Aft3. After are reached. 
Because the height of T ia O(log n), we need T(sZ3 (s)) is available, we can compute the common tangent 
to process each level of T (in most part of the procedure) in between each pair of lCP(C, ) and ICp(ck 
) in O(log m) time O(I) time, in order to achieve an O(log n) time algorithm. using O(g) processors by 
using [8, 5]). Let u # root(T) be an internal node of T. Let the chains i Next, using the O(g ) common 
tangents so obtained, we associated with u, lch(u), and rch(u) be respectively bd~~, build a complete 
b:nary tree of internal conuez paths whose bdab, and bdbc, 1 < a < b < c. The main computation leaves 
are associated with Cl, C2, . . . . Cg, respectively The of Phase 2.B is based on the lemma below. WLOG, 
we root of the tree is associated with bdst = C and it stores assume that up to the level of u, P is 
not known to be ZCP(bds, ) (in a rank tree). non-weakly visible from e. The complete binary tree of internal 
convex paths above is denoted by TC. The root of Tc is denoted by root (Tc ) Lemma 15 Let the common 
tangent between lCP(bdl~) and the left (resp., right) child of an internal node u of and ICP(bda.) touch 
ICP(bdl~) at VQ and ICP(bd~~) at Tc is denoted by lch(u) (resp., rch(u)). The information v., the common 
tangent between lCP(bdla) and ~@(bdab) associated with each node of Tc is as follows. root (T ) is touch 
ICP(bdla) at VW and ICP(bda6) at v., and the common associated with bd, t and it stores ICP(bd, ~). For 
an internal tangent between K p(bdab) and ~CP(bdbc) touch ~CP(bdab) node u, the subchain of C associated 
with u is the union at v=) (see Fig. 7). Then the common tangent between ICP(bdla) and a vertex on bd~b 
touches ZCP(bdl~) on ICP(bdWa) (with w ~ and tangent of the subchains associated with the descendent 
leaves of u. Suppose that the subchain associated with u is bdac and q), the common between the subchains 
associated with Zch(u) and rch(u) are respec-~CP(bdlb) and a uertez on bdt,~ touches ~CP(bd16) either 
on v. tively bdab and bdbc, a < b < c. Observe that ICP(bdab) ICP(bdqb) (= ICP(bdg~ ) U lZ2Z U I@(bd.b)) 
(when c ICP(bdb.)) or on ICP(bdz,b) (when v. C KX (bdab)). ICP(bdac) (resp., ICp(bdb.) ZCP(bd~.)) consists 
of at most one connected component. The information stored Proof. Omitted. See the full paper. 0 at 
/ch(u) (resp ., rch(u)) is ~CP(bdab) lCP(bda.) (resp., We call ICP(bdqa ) in Lemma 15 the ieft internal 
con­ lCP(bdbc) ICP(bdaC)), represented by a rank tree. The vex path to the chain (i.e., bdac) associated 
with u and de­ height of Tc is O(log m). This tree structure has been used note it by LICPU. Likewise, 
LI@lchftiJ = lCP(bd~~) and in [9] for triangulating a one-sidedmonotone polygon (in [9], LICP,Ch(u) = 
lCP(bdqt,) (when v, = KT(bdb.)). Observe each node of the tree stores a portion of the convex hull for 
that LICPtCh(U) and LICPTch(U) are disjoint except possibly its associated subchain; see [9] for the 
definitions and the at VW. For convenience, we also let ICPti denote ICP(bda.). details). The construction 
of Tc is done by an algorithm in The computation based on Lemma 15 involves the fol­ [9, 5], in O(log 
m) time using 0(g3 ) processors. lowing main operations: (i) computing the common tan- In total, the 
procedure for Step c.3 requires O(log m) gent between two internal convex paths, (ii) splitting an time 
and O(g3 ) processors. internal convex path into two subpaths, and (iii) combining two internal convex 
paths together to form another path. We need to perform each of these operations in O(1) time for most 
part of the algorithm. Obviously, an appropriate At the root of the recursion tree of Phase 2.A, if P 
has been data structure for representing the internal convex paths is decided to be non-weakly visible 
from e, then the algorithm essential in this process. stops. Otherwise, we proceed with Phase 2.B to 
compute We can no longer use rank trees to represent the internal Sj(l) and Sj(n) for every j. WLOG, 
we just show how convex paths because of their logarithmic heights. Instead, to compute the Sj (1) s 
(the computation for the SJ (n) s is we represent the internal convex path stored at each node 5.3 Phase 
2.B similar). of T by an array. The conversion of the rank tree represen- In Phase 2.A, we have constructed 
a complete binary tation into the array representation for the internal convex tree of the internal convex 
paths (cf. Step c.3). We denote paths is easy to do in O(log n) time using O(n/ log n) pro­this tree 
by T. T has O(n/d) = O(n/ log n) nodes. The cessors. We henceforth assume that the internal convex root 
of T stores ICP(bdl ~). Each non-root node uses ;~ rank path stored at each node of T is represented 
by an array. tree to store at most one connected portion of the internal The computation on a node u 
of T involves lCPU and convex path for the subchain of bdln associated with that LICPU, which need to 
be represented in such a way that node. Hence there are totally O(n/ log n) internal convex enables us 
to compute their common tangent in 0(1) time. paths stored at the nodes of T. Recall that lch(u) (resp., 
rch(v)) stores the portion of The algorithmic structure of Phase 2.B is the same as ICPlch ., (resp., 
ICP,Ch(u) ) that is not on ICP~. Only the structure of tree T. The procedure follows a top-down root(T 
has its internal convex path, i.e., ICP(bdl~), stored paradigm. It starts at root(T), then goes to the 
two children in a single array. ich(root(T)) may have one portion \ of 1CP(&#38;21 ~p, ) stored in root(Z 
). The left child of lch(root(7 )\ may have one portion of lCP(bdl(nJ1) ) stored in lch(root(T)), which 
may again have a portion stored in root(T). In generaJ, a node u may have a portion of ICPU stored in 
each of its ancestorsin T. That is, ICPU is obtained from the O(logn) arrays stored at its ancestors. 
Therefore, we represent ICPU by using O(logrz) subarrays. Let ICP be represented by AU(I), AU(2), . . 
. . A.(k), in order, where each Au(i) is asubarray of an array stored at an ancestor of u. Each A (i) 
is specified by two pointers, one pointing to the first element of Au(i) and the other pointing to the 
last element of Au(i). Suppose those 2k pointers are available in the beginning of the computation at 
u, whereuis aninternal node of T. Inthe process at u, we split ICPti at vz~, where vz~ (resp., vz~~) 
on ~Cpkh(u) (resp., ~Cp..h(u))k the endpoint of the common tangent between ICPICh[U) and ICPrch(U), as 
follows. Let V,J be contained in Au(i) for some z. Then Au(i) is split at v=) into two subarrays A: an 
d A{, such that Vz) is the last element of A: and vzl~ is the first element of A:. Let the representation 
of ~CP~Ch(U) be the union of lCPICh(0) (1 ICPU (represented by O(log n) pieces from u) and ~@~ch(U) 
lCPu (one single piece stored at ich(u)). That is, lCP~ch(a) is represented by Au(l), AU(2), . . . . 
A~(i 1), AL, and Blch(ti), in order, where ~~ch( ~ ) is the array representing lCPtch( ti) lCPti. The 
similar thing is done for ~CP,ch(ti). We associate with ICPU k size parameters sizeu( 1 ), szzeti(2), 
. . . . size (k), where sizeti(i) = lAti(l)l + . . . + 1A.(i) [. Using the size parameters, we can quickly 
access the j-th vertex on ICPU for any y (say, in 0(1) time us­ ing O((log n)112 ) processors). When 
ICPU is split to form lCPlch(.) and ~CPr&#38;(u), the size parameters for the rep­resentation of ICP.ch(u) 
n ICPti can be easily updated (in 0(1 ) time using O(log n) processors) because we just need to subtract/add 
a same number from/to all the parameters in the list for rch(u) and then add a new parameter (for lCP~~h(U) 
 ICPU) to the beginning of the list. The update on the parameters for ich(u) is even easier (only a new 
term is added to the end of the parameter list). It can be shown that L]CPU is aJso represented by O(log 
n) subarrays. Hence the split and combine oper­ations on LICPU are also the same as on ICPU. With these 
representations for the ICPU s and LICP. s, the common tangent between every pair of ICPU and LICPU, 
at each level of T (in most part of the algorithm), can be computed in 0(1) time and O(n/ log n) processors 
by using [1]. Acknowledgement. The author would like to thank Pro­fessor Mikhail Atallah for his great 
support and encourage­ment to this research, and for many inspirational discus­ sions.  References 
<RefA>[1] M. J. Atallah and M. T. Goodrich. Parallel algorithms for some functions of two convex polygons, 
AZgorzth­mica, 3 (1988), pp. 535 548. [2] D. Avis and G. T. Toussaint. An optimal aJgorithm for determining 
the visibility polygon from an edge, IEEE Trans. C omput., C-30 (12) (1981), pp. 910-914. [3] B. K. Bhattacharya, 
A. Mukhopadhyay, and G. Toussaint. A linear time algorithm for computing the shortest line segment from 
which a polygon is weakly externally visible, Proc. WADS, 1991, Ottawa, Canada, pp. 412-424. [4] B. 
Chazelle and L. J. Guiba.s. Visibility and intersec­tion problems in plane geometry, Dwc. Comput. Gee., 
4 (1989), pp. 551-581. [5] D. Z. Chen, Efficient geometric algorithms in the EREW-PRAM, Proc. 28-th Annuai 
Allerton Conj. Commun., Contr., and Comput., 1990, pp. 818-827, [6] Y. T. Ching, M. T. Ko, and H. Y. 
Tu. On the cruising guard problem~, Technical Report, 1989, Institute of Information Science, Academia 
Sinica, Taipei, Taiwan. [7] R. Cole and M. T. Goodrich. Optimal parallel algo­rithms for polygon and 
point-set problems, Proc. ~-th Annual ACM Symp. Comput. Gee., 1988, pp. 211-220. (To appear in Algorithrnica.) 
[8] M. T. Goodrich. Finding the convex hull of a sorted point set in parallel, IPL, 26 (1987/88), pp. 
173-179. [9] M. T. Goodrich. Triangulating a polygon in parallel, J. of Algorithms, 10 (1989), pp. 327-351. 
[10] M. T. Goodrich. Planar separators and parallel poly­gon triangulation, to appear in the 2~-th Annual 
ACM STOC, 1992, Victoria, Canada. [11] M. T. Goodrich, S. B. Shauck, and S. Guha. ParaL lel methods for 
visibility and shortest path problems in simple polygons (Preliminary version) , Proc. 6-th Annual ACM 
Symp. Comput. Gee., 1990, pp. 73 82. [12] L. Guibas, J. Hershberger, D. Leven, M. Sharir. and R. Tarjan. 
Linear time algorithms for visibility and shortest paths problems inside triangulated simple polygons, 
AZgorithmica, 2 (1987), pp. 209-233. [13] S. K. Ghosh, A. Maheshwari, S. P. Pal, S. SaJuja, and C. E. 
V. Madhavan. Characterizing weak visibility polygons and related problems, Tech. Rep., No. IISc­CSA-90-1, 
1990, Dept. Comput. Sci. and Auto., Indian Institute of Science. [14] P. J. Heffernan and J. S. B. Mitchell. 
<Structured vis­ibility profiles with applications to problems in sim­ple polygons, Proc. 6-th Annual 
ACM Symp. Comput. Gee., 1990, pp. 53-62. [15] Y. Ke. Detecting the weak visibility of a simple poly­gon 
and related problems, Manuscript, Dept. of Com­put. Sci., The Johns Hopkins University, 1988. [16] C. 
P. KruskaJ, L. Rudolph and M. Snir. The power of parallel prefix, IEEE Trans. Comput., C-34 ( 1985), 
pp. 965-968. [17] R. E. Ladner and M. J. Fischer. Parallel prefix com­putation, JA CM, 27 (4) (1980), 
pp. 831-838. [18] D. T. Lee and A. Lin. Computing the visibility poly­ gon from an edge, Tech. Rep., 
Northwestern Univ., 1984. [19] D. T. Lee and F. P. Preparata. An optimal algorithm for finding the kernel 
of a polygon, JA Cflf, 26 ( 1979), pp. 415-421. [20] M. H. Overmars and J. van Leeuwen. Maintenance of 
configurations in the plane, J. Comput. and Syst. Set., 23 (1981), pp. 166-204. [21] F. P. Preparata 
and M. I. Shames. Computational Ge­ ometry: An Introduction. Springer-Verlag, New York, 1985. [22] J.-R. 
Sack and S. Suri. An optimal algorithm for detecting weak visibility of a polygon , IEEE Trans. Comput., 
C-39 (10) (1990), pp. 1213-1219. [23] G. T. Toussaint. A linear-time algorithm for solving the strong 
hidden-line problem in a simple polygon, Pattern R.ecognztion Zetters, 4 (1986), pp. 449 451, [24] C. 
K. Yap. Parallel triangulation of a polygon in two calls to the trapezoidal map, Algortthmtca, 3 (1988), 
pp. 279-288.</RefA>  
			

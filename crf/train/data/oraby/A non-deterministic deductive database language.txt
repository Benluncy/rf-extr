
 A Non-deterministic Deductive Database Language* Yeh-Heng Sheng UniSQL, Inc. 9380 Research Blvd. Kaleido 
II, Ste. 220 Austin, TX 78759 (execu!sequoia! unisql!sheng@cs. utexas.edu) Abstract A non-deterministic 
deductive database language IDLOG that employs tuple-identifiers in DATALOG (with nega­tion) was proposed 
in [She90b] to enhance the expressive power of deductive database languages. It was shown that a subset 
of ID LOG programs defines the class of all com­putable deterministic queries. In this paper, we investi­gate 
the non-deterministic part of IDLOG. As discussed in [ASV90], the use of non-deterministic database languages 
is motivated using both pragmatic and theoretical con­siderations. There are natural non-deterministic 
queries whose implementation using deterministic languages is un­intuitive and inefficient. One typical 
example is sam­pllngqueries, i.e., queries that randomly choose certain samples from a set of tuples, 
such as Find an arbitrary set of employee samples that contains exactly N employ­ees from each department 
(assuming each department has at least N employees) . Another consideration in favor of non-determinism 
is optimization. Intuitively, a non­deterministic program gives a certain degree of freedom in the computation 
of a query, which can be exploited in op­timization. We show how IDLOG defines sampling queries and how 
it can be used to optimize DATALOG programs. Also discussed is the expressive power of non-deterministic 
IDLOG. Introduction A non-deterministic deductive database language IDLOG that employs tuple-identifiers 
in DATALOG (with negation) was proposed in [She90b] to enhance the expressive power of deductive database 
languages. It was shown that a subset of IDLOG programs defines the class of all computable deterministic 
queries. ' Most of the work was done at the State Umverslty of New York at Stony Brook Permission to 
copy without fee all or part of this material is granted provided that the copies are not made or distributed 
for direct commercial advantage, the ACM copyright notice and the title of the publication and its date 
appear, and notice is given that copying is by permission of the Association for Computing Machinery. 
To copy otherwise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 0-89791 -425-2 
/91/0005 /0188 . ..$1 .50 IDLOG is non-deterministic in the sense that we may get different answers 
for the same query, depending on the assignments of tuple-identifiers (tid s for short) in each relation. 
In this paper, we investigate the non­deterministic part of ID LOG. As discussed in [ASV90], the use 
of non­deterministic database languages is motivated using both pragmatic and theoretical considerations. 
There are natural non-deterministic queries whose imple­mentation using deterministic languages is unintu­itive 
and inefficient. One typical example is sam­pling queries, i.e., queries that randomly choose cer­tain 
samples from a set of tuples, such as Find an arbitrary set of employee samples which contains ex­actly 
N employees from each department (assuming each department has at least N employees) . Any par­ticular 
set that contains N students from each depart­ment will satisfy the first query. Deductive database languages, 
such as DATALOG, lack tools to define such queries. Recently, various non-deterministic database languages 
have been proposed for defining non-deterministic database queriesl [ASV90, AV87, AV88, KN88, MS88]. 
Among these proposals, one important non-deterministic mechanism is the chotce operator [KN88]. The choice 
operator is a very intu­itive non-deterministic mechanism. The semantics of the choice operator is basically 
based on the minimal­model semantics, which gives it the advantage of mak­ing use of many existing evaluation 
strategies. How­ever, the choice operator can not easily define sam­pling queries which ask for multiple 
samples (see Ex­ample 5). Sampling queries can be easily defined in our language. For example, the following 
IDLOG pro­gram defines the sampling query: Find an arbitrary set of employee samples which contains exactly 
2 em­ployees from each department . select-two.emp( Name) ---ernp[2](Name, Dept, N), N<2 1 Some of these 
languages can define database updates. Our attention in th]s paper, however, is on the query aspect of 
these languages. where the literals ernp[2] (Name, Dept, N) and N < 2 specify that the two tuples that 
have tid O or 1 are to be considered in the computation of the query. We will show that IDLOG provides 
a basic framework for defining a more general notion of choice operators. Another consideration in favor 
of non-determinism is optimization. Intuitively, a non-deterministic pro­gram yields a certain degree 
of freedom in the com­putation of a query, which can be exploited in opti­mization [ASV90]. For example, 
consider the follow­ing DATALOG program: a//.depts(Dept) + ernp(Name, Dept) In order to compute all.depts, 
for each department d, only one tuple that contains d in the second column needs to be considered. Argument 
positions, such as Name, were called existential in [RBK88]. It has been shown in [RBK88] that the detection 
of such existen­tial arguments is in general undecidable. However, to optimize such programs, non-deterministic 
mecha­nisms can be used that provide users with explicit con­structs for optimization. One of the purposes 
of the choice operator was to provide such an explicit con­struct. The previous DATALOG program can be 
re­cast into the following equivalent program with choice operator: al/.depts(Dept) + errzp(Name, Dept), 
 choice((Dept), (Name)) where the choice operator choice (( Dept), (Name)) non-deterministically chooses 
one employee from each department. The DATALOG program can also be re­cast into the following equivalent 
IDLOG program: ali-depts(Dept) + ernp[2](Name, Dept, O) where the literal ernp[2Jj (Name, Dept, O) specifies 
that only one particular employee that has tid O in each de­partment will be considered. In this paper, 
we define a new notion of existential arguments, called 3-exist ent ial arguments, and pro­vide an explicit 
language construct for specifying such arguments in programs. The number of intermedi­ate redundant tuples 
in query evaluation can there­fore be greatly reduced. The problem of identifying 31-existential arguments 
in a DATALOG program is undecidable (Theorem 3). However, we note that the sufficient test for identifying 
existential arguments in [RBK88] works for 3-existential arguments as well. We also explore the expressive 
power of non­deterministic IDLOG. Generzc Turing machinesz in­troduced in [HS89, HS90] provide a convenient 
tool for us to show the expressive power of ID LOG. We show that the set of all non-deterministic queries 
defined by stratified IDLOG programs is equivalent to the set of all computable non-deterministic queries. 
The main contribution of this paper includes the following: 2Generic Turing ~achines were later renamed 
as domain t r­ing machines in [HS90]. We propose a non-deterministic deductive lan­guage that can easily 
define sampling queries3. The language generalizes DATALOG with choice operator. We introduce a new notion 
of existential argu­ments, and discuss its applications in optimizing DATALOG programs. We show that 
stratified IDLOG programs define all computable non-deterministic queries. This suggests that tuple identifiers 
may provide a powerful alternative in enhancing the expressive power of deductive database languages. 
 The rest of this paper is organized as follows. In Sec­tion 2, IDLOG is briefly described; Section 3 
discusses non-deterministic database queries; The way IDLOG is used in optimizing DATALOG programs is 
shown in Section 4; Section 5 describes the expressive power of non-deterministic ID LOG; a concluding 
remark is given in Section 6. For brevity, we will omit all the proofs (they can be found in [She90a]). 
2 Basics In this section, we review the notion of ID-relations, and the syntax and semantics of IDLOG. 
2.1 ID-relations In this paper, we only consider flat re!atzons, i.e. rela­tions containing no complex 
objects such as sets and lists. Function symbols are excluded as we114. Con­sider a countably infinite 
set U, called the universal do­main. An uninterpreted dorna~n (u-domain for short) is a finite subset 
of U, and the interpreted domain is the set N of natural numbers O, 1, 2, . . .. Suppose m, n > 0, and 
D is a u-domain. The types defined in the following are O, 1 sequences. A relatton of type S1. . . . 
.Sm over D is a (possibly infinite) subset of D1 x . . . x Dm such that for i = 1, .... m, Di = Difsi 
= O, and D,=Nifs~= 1.Suppose forj = 1,n,rj isafinite relation of type aj over D. A database of type (al, 
. . .. an) with u-domain D is denoted by (u-domain=D; rl, . . .. m). Intuitively, an ID-relation of a 
relation r is obtained from r by augmenting each tuple in r with its tid that is determined according 
to the way tuples in r are grouped. We define an ID-function of a relation r as a one-to-one and onto 
function from r to the set {O, 3As shown in [She90a], the language can also be efficiently implemented 
4Although we are primarily interested in programs with no general function symbols, the ID LOG progrmns 
we define here can be easily extended to allow them. . . .. Irl 1}. A sub-relation of a relation r grouped 
by a set s of attributes of r is a subset of r that contains all the tuples in r which have the same 
value on each attribute in s. Let [t]$ be the sub-relation of r grouped by s that contains the tuple 
t. Now, suppose r is an n-ary relation of type a, and s is a subset of {1, . . .. n}. An ID-relation 
of r on s is an (n + 1)-ary relation of type a .1 over the same set as r, and its every tuple is composed 
of a tuple t in r and a tid which is assigned by an ID-function of the relation [t].. Example 1 Let r 
= {(a, c), (a, d), (b, c)}, then the sub-relations of r grouped by the first attribute are: {(a, c), 
(a, d)}, and {(b, c)} Therefore, there are two ID-relations of r on {1}: {(a, c, 1), (a, d, O), (b, c, 
O)}, and {(a, c, O), (a)d, 1), (b, c,O)}. 0  2.2 IDLOG: Syntax and Semantics Consider a two-sorted first-order 
logic language [End72] with sorts u and i. Constants of sort u are ele­ments of U and constants of sort 
i are O, 1, . . .. Each in­terpretation I of this language contains two uniuerses, namely u-universe 
and i-universe, where the latter is intended to be the set N. Equality symbols (for both sorts) are assumed 
in this language. We also assume the existence of a special predicate succ (or sort (i, i)) with the 
intended meaning: SUCC(A, B) iff B = A + 1. More complicated arzthmetzc predicates, such as +, ~ *, / 
(of sort (i, i, i)), and < (of sort (i, i)), can be defined by IDLOG programs (defined later) using the 
predicate SUCC. Sorts of predicates are also written as O, 1 sequences denoting attributes of sort u 
and sort i respectively. For convenience, we will not mention the sorts of variables and predicates if 
they can be in­ferred from the context. An IDL OG language L is a such language with additional ID-predicates 
. Let s be a (possibly empty) subset of {1, . . .. n}. For each ordinary n-ary predicate symbol p of 
sort a, an ID­version of p on s is a predicate symbol of sort a . 1, denoted by p[s]5. The set of all 
ID-predicates in an IDLOG language L is the set of all ID-versions of or­dinary predicates in L. Hereinafter, 
unless stated oth­erwise, we will ignore arithmetic predicates, for their meaning is fixed. IDL OG ant 
erpret ations are extensions of first-order logic interpretations. Suppose 1 is an IDLOG interpre­tation, 
and p is a predicate. The set p] is the relation assigned by 1 to p. An IDLOG interpretation 1, in addition 
to the usual assignment of a relation to each 5As pointed out by Richard Hull, among all the ID­predicates, 
those of the form p~ (with no grouping attributes) are most primitive. That is, all other ID-predicates 
can be de­fined through them. ordinary predicate, assigns to each ID-predicate p[s] an ID-relation of 
pr on s. An atom (resp. a literal) is called an ID-atom (resp. an ID-literal) if it contains an ID-predicate, 
and a non-ID-atom (resp. a non-lD­literal) otherwise. An IDL OG clause is a universally quantified sentence 
of the form (W X1 . . . V Xk )(A +-BI A... A Bn ), where the Bj s are any literals, and A is a non-ID-atom 
containing no succ or equality. An IDLOG program is a finite set of IDLOG clauses. Throughout this paper, 
we assume that each use of an arithmetic predicates is safe [Zan86] which is guar­anteed through a sufficient 
condition: for each literal 1 containing an arithmetic predicate in the body of a clause r, a sufficient 
number of arguments of 1 must be positively bound in the body of the same clause, i.e., each of them 
either is a constant or appears in a pos­itive literal containing no arithmetic predicates in the body 
of r. For example, in the following program, q(a, 1) pl(X, N) -q(X, N), +(N, L, M) p2(X, N) -q(X, N), 
+(L, M, N) the first occurrence of + is not allowed, since there are infinitely many solutions for the 
equation 1 + L = M, while the second occurrence of + is allowed since there are only finite number of 
solutions for the equa­tion: L + M = 1. Thus, for the arithmetic predicate +, allowed combinations of 
bound (b) and unbound (n) arguments are bbb , bbn , bnb , nbb , and nnb (note that this is only a sufficient 
condition for ensuring safety of +). Similarly, we can define some sufficient numbers for all other arithmetic 
predicates. Consider an IDLOG program P. The Herbrand uni­verse of P, is the union of N and the set of 
all con­stants of sort u in P (if there is no constant of sort u in P then a new constant will be added). 
Hence­forth, when mentioning formulae, we will assume each is of the right sort, Let Hp be the set of 
all predi­cates in P and their corresponding ID-versions or or­dinary predicates. The Herbrand base of 
P consists of ground atoms constructed from all predicates in Hp, and constants in the Herbrand universe 
of P. A Her­brand interpretation of P is a subset of the Herbrand base of P which satisfies the requirement 
of being an IDLOG interpretation, i.e. relations assigned to or­dinary predicates and their ID-versions 
stand in right relationship. From now on, we will focus on Herbrand interpret ations. Recently, finding 
an appropriate declarative seman­tics for logic programs (DATALOG with negation and function symbols) 
has attracted much attention [ABW88, GL88, Prz88b, Prz88a, Ge188, VGRS88]. The following is the main 
result about perfect mod­els of IDLOG programs. Theorem 1 ([She90b]) For every model N of a strati­jied 
IDLOG program P, there exists a perfect mode! M of P such that M < N. Thus, every stratified IDLOG program 
has at least one perfect model. D The corresponding result in [Prz88b] for stratified logic programs 
can be thought of as a special case of the above theorem. The perfect-model semantics for IDLOG programs 
can therefore be similarly defined.  3 Non-deterministic Database Queries In this section, we first 
define non-deterministic IDLOG queries, and give a brief overview of some non­deterministic database 
languages. Then we show how sampling queries can be defined in ID LOG. 3.1 Non-deterministic IDOLG Queries 
The following definition of queries is an extension of the one defined in [CH80, Cha81]. Some terminology 
is borrowed from [HS89] and [AV88]. An elementary relation type is a relation type containing no 1 s 
(i.e. all domains are uninterpreted). Suppose O is a finite subset of U, and for i ~ O, ai is an elementary 
relation type. A (non-deterministic) qtiery f of type E = (al, . . .. an )+ao/O is a binary relation 
between databases of type ~ and finite relations of type a. that satisfies the condition: if (r, r) c 
f then the relation must be over the union of O and the u-domain of r. For each (r, r) ~ f, the database 
r is called an input database of f, and the relation r is called an answer of the query f on input r 
(or, for short, an answer off(r)). Note that since the set O and each u-domain are finite, there are 
only finitely many possible answers for each particular input database. A query is determinwttc if for 
each appropriate input, there is at most one answer. For convenience, we will also think of a query as 
a func­tion from databases to sets of relations. Let C be a finite subset of U. A query f of type E+ao/O 
is C­generic if it satisfies the following: r E f(r) iff u(r) E f (a(r)) for every permutation a over 
U such that Vz E C, a(x) = z (here u is naturally ex­ tended to relations and databases). Note that each 
C-generic query of type Zi+ao/O is also of type E+ao/C. Thus, we will omit the type postfix when mentioning 
generic queries (C-generic queries for some C). A query f is computable iff it is generic and recursively 
enumerable. Note that when f is deterministic, f is computable iff it is generic and Turing computable 
(parttal recursive). Following [H S89], we briefly describe how Z urtng of type ii+ao. A TM A4 computes 
f if the following conditions are satisfied. First, it is assumed that C and distinguished symbols O 
, l , , , ( , ) , [ , and ] are included in the tape-alphabet of M. An input database with u-domain D 
is placed into an ordered list, where each uninterpreted constant in D C is encoded as a string of O 
s and 1 s. If h4 halts, it must hold on its tape the encoding of a relation of type a. over D U C. Finally, 
the operation of M must be in­dependent of the encoding used for the uninterpreted constants in D C, 
and also independent of the order in which the input is presented. Suppose 7 is a stratified IDLOG program. 
An input predicate of P is any ordinary predicate p such that p does not appear in the head of a clause 
in P, and p or its ID-version occurs in the body of a clause; an output predicate of p is an ordinary 
predicate that appears in the head of a clause in P. Note that the arithmetic predicates are not counted 
as either input or output predicates. Likewise, there is no need to pay special attention to arithmetic 
predicates when talking about finite models, since every use of computed predicates is assumed to be 
safe. A clause r is related to an output predicate q of a program p if the head predicate of r appears 
either in a clause defining q or, recursively, in a clause related to q. The program portion related 
to q in P, denoted P/q, is the set of all clauses in P that are related to q, Now assume q (of sort ao) 
is an output predicate of P, and pl (of sort al), , . .. pn (of sort an) are input predicates of P. Let 
D = {dl, ., ., dm} be a u-domain, and r = (u-domain=D; rl, , . .. rn) be an input database for P. The 
program P/qu{pj(t) :1 ~ j ~ n, t G rj, &#38; pj appears ~~ p/fl} U{udom(di) : i = 1, ..., m} is called 
a database program of P w.r.t. the output predicate q and the input database r, written dbp(p, q, r). 
Throughout this paper, we assume, in addition to the usual axioms of standard logic, the following axioms 
[Rei83] for the database program dbp(P, q, r): ' Equality Ax~oms: the usual reflexivity, commuta­tivity, 
and transitivity of equality symbols, plus the principle of substitution of equal terms, ' Untque Name 
Aztoms: for each i # j, di # dj, e Domain Closure Axiom: VUX (V {X = a:ac D, or ais an uninterpreted 
constant in P/q}). Let PERF&#38; be the set of all finite perfect (Herbrand) models of the database program 
D = dbp(P, q, r). Then P defines an IDLOG query q of type (al, . . .. an)+ao as follows: machines (-T~ 
s) are used to compute deterministic {q :1 E PERF&#38;}, if PERF&#38; # 0 q(r) = queries. Suppose f is 
a deterministic C-generic query undefined, otherwise { Notice that query q is C-generic, where C is the 
set of all uninterpreted constants in T (actually, the part of P that is related to q). We can similarly 
define queries defined by other deductive database languages. A program is q-equivalent to another program 
if they define the same query q. Example 2 Consider a clause man(X) V woman(X) +---person(X) and the 
queries man and woman. These queries can be defined in IDLOG as follows: sez.guess(X, male) + person(X) 
se8.guess(X, ~ernale) e person(X) man(X) + sez-guess[l](X, male, 1) woman(X) 4---sez.guess~l](X, female, 
1) The relation sex-guess contains every possible guess (male or female) of a person s sex; sez-guess[l](X, 
male, 1) (resp., sez-guess[l](X, female, 1)) means that the guess ser.guess(X, male) (resp., sex-guess(X, 
male)) is true (l). Suppose r = {(a), (b)}, and the input database is r = (u­domain= {a, b}; r). Now, 
the interpretation for the predicate man in each perfect model of the corre­sponding database program 
is one of the following: 0, {man(a)}, {man(b)}, and {man(a), man(b)}. There­fore, the query man is evaluated 
to man(r) = {fJ, {(a)}, {(b)}, {(a), (b)}}, so is the query woman. 0  3.2 Overview Database languages, 
such as first-order relational cal­culus and DATA LOG, lack the ability to define queries that are non-deterministic 
in nature. Recently, vari­ous non-determinist ic database languages have been proposed for defining database 
queries and updates [ASV90, AV87, AV88, MS88]. In the following discus­sion, we will focus on query aspects 
of these languages. A fairly direct way to have a non-deterministic database language is to allow disjunctions 
in clause heads. As shown in [Prz88b], perfect-model seman­tics can be defined for such programs (denoted 
by DATALOGIV). However, DATALOG V does not provide a convenient mechanism for defining sam­pling queries, 
and it is unlikely that the language enhances the expressive power of DATALOGIV in defining deterministic 
queries. Another direct way of having a non-deterministic database language is to consider the class 
of all logic programs based on stable models [GL88, SZ90]. Because IDLOG actu­ally defines all computable 
non-deterministic queries (shown in Theorem 6), every query defined by a non­stratified logic program 
based on stable model se­mantics can also be defined by a stratified IDLOG program [She90a]. In the rest 
of this section, we will only discuss two non-deterministic mechanisms, namely the non-deterministic 
inflationary semantics [AV88, ASV90] and the choice operator [KN88, NT89]. 3.2.1 Non-deterministic Inflationary 
Seman­tics We will discuss two closely related non-deterministic database languages, each of which has 
DATALOG-like syntax. The semantics of both languages is based on a non-deterministic inflationary semantics. 
This means that the intended models of programs are obtained by applying program clauses bottom up, each 
clause is instantiated one at a time, and facts are added to the output until no additional facts can 
be inferred (no facts are ever deleted). Notice that choice avail­able in consecutive instantiations 
of rules introduces non-determinism, and therefore the output varies de­pending on this choice. The language 
D-L (a Declarative Language) intro­duced in [AV88] has DATALOG syntax extended by allowing (1) negative 
literals in the body, and (2) more than one positive literal in the head (connected by the logical AND). 
Variables appearing in the head but not in the body are interpreted as the source of in­vented values, 
i.e., instantiations of such values are new constants not appearing in the program or in the current 
computation of the semantics. The ran­dom assignment of new values to such variables is an­other cause 
of non-determinism. Queries defined by DL programs are understood w.r.t. the inflationary jizpoints [GS85, 
KP88] of these programs instead of perfect models as it was in the DATALOG case. An N-DA TAL 0(7 program 
[ASV90] resembles a DL program except that negative literals are allowed in the head of each clause, 
and each variable occurring in the head of a clause has to appear positively bound in the body as well. 
Negations in heads of clauses are in­terpreted as deletions. An instantiation of a clause can only be 
fired if its head is consistent, i.e., it contains no literal together with its negation. Notice that 
allowing negations only in the head (but not in the body) does not introduce any non-determinism [ASV90], 
Example 3 Consider the following DL program: man(X) + person(X), 1 zooman(X) tooman(X) + person(X), 
7 man(X) Suppose the input database r contains person(a) and person(b). Then, under the non-deterministic 
infla­tionary semantics, man(r) = woman(r) = {0, {(a)}, {(b)}, {(a), (b)}}. In contrast, under the deterministic 
inflationary semantics, man(r) = woman(r) = {(a), (b)}. 0 The non-deterministic inflationary semantics 
is im­portant in exploring the expressive power of database languages. The object of this paper, however, 
is to provide a general non-deterministic database language as a simple extension of DATALOG based on 
the minimal-model semantics and perfect-model seman­tics. By staying within this semantics paradigm, 
many existing evaluation strategies for logic programs can be used for evaluating IDLOG programs with 
only slight modifications. 3.2.2 The Choice Operator The choice operator choice introduced in [KN88] 
(see also [NT89]) provides users with an explicit non­ deterministic construct. In the following discussions, 
the terminology used slightly differs from [KN88]. Consider the following DATALOG program P with choice 
(or DATA LO@ program for short) ( [KN88]): seiect.ernp(Name) -ernp(Name, Dept), choice((Dept), (Name)) 
P computes the set of all employees that con­ tains exactly one employee from each department. The choice 
operator choice (( Dept), (Name)) non­ deterministically chooses one employee from each de­ partment. 
That is, let r be the relation that contains all tuples (Dept, Name) satisfying the body (without the 
choice operator) of the clause. Then the choice operator chooses a subset rl from r such that rl con­ 
tains all departments and satisfies the functional de­ pendency Dept + Name . Let s call such a set rl 
a funciionai subset of the relation r w.r. t. the at­ tributes Dept and Name. In defining the semantics 
of DATALOGC programs, each DATALOGC program P is first translated into a DATALOG program P by 1. replacing 
each occurrence of a choice operator choice (~, ~) in some clause r E P by a lit­ eral extChoicei (X, 
Y), where extChoicei is a new predicate symbol, called a choice-predicate, and 2. for each such occurrence, 
adding the following choice-clause: extChoicei(X, Y) + body where body is the body of r without the choice 
operator. To define the semantics of choice properly, we might impose the following syntactic restrictions 
on DATALOGC programs: in a DATALOGC program P, (cl) every clause contains at most one choice operator, 
(C2) every clause containing a choice operator is not related to the head predicate of another clause 
that contains a choice operator. i.e., for any two clauses in P of the form: [1] p(. ..) + .... choice(. 
..) [2] q(. . .) +--..., choice(. . .) the clause [1] @ P/g, and the clause [2] # P/p.  Notice that 
C 1 above does not really limit the expres­sive power of DATA LOGC. The reason why we need C2 is because 
the semantics defined in [KN88] does not seem to be appropriate for all DATALOGC programs (see [She90a]), 
but only for the subset of DATALOGC programs satisfying the above conditions. Then each intended model 
N of P is constructed as follows: ' Construct the unique minimal model Al of Pc. ' for each choice-predicate 
extChoicei in a clause head + body, extChoicel (~, ~) in Pc, assign to ext Choice~ a functional subset, 
say Si, of the relation ext Choicei f w.r.t. X U F. ' Construct the unique minimal model of the DATALOG 
program containing each non-choice­clause in Pc and every fact extChoicei(t), where tESi. The resulting 
set is an intended model of the DATALOGC program P. For example, the following DATALOGC program is man-equivalent 
and woman­equivalent to the IDLOG program in Example 2. sez-guess(X, male) + person(X) sez-guess(X, female) 
+ person(X) sez(X, Y) + sez-guess(X, Y), choice, (Y)) man(X) +--sex(X, male) woman(X) + sez(X, female) 
 Thus, IDLOG can be thought of as a general frame­work for implementing the choice operator in DATA-LOG: 
Theorem 2 For every DA TALO@ program P and every output predzcate q of P, if P satisfies the con­ditions 
(Cl) and ((2 2), then there exists a stratified four-stratum IDLOG program Q such that P and Q are q-equivalent. 
0  3.3 Sampling Queries In this section, we show how sampling queries can be defined in IDLOG. Sampling 
quertes are (non­deterministic) queries that randomly choose samples from a set of tuples, such as Find 
an arbitrary set of employee samples that contains exactly N employees from each department (assuming 
each department has at least N employees) , and Find an arbitrary cafe at the intersection of Blvd. St. 
Germain and Blvd. St. Michel [ASV90] . When the number of samples to be selected is exactly one, sampling 
queries can be naturally defined by the choice operator: Example 4 Consider the sampling query Find an 
arbitrary set of employee samples that contains exactly one employee from each department [K N88]. It 
can be defined by the DATALOGC program: select.ernp(Name) - ernp(Name, Dept), choice((Dept), (Name)) 
It can also defined by the following IDLOG program: seiect-ernp(Name) + ernp[2JJ(Name, Dept, O) D However, 
general sampling queries usually ask for multiple samples, which cannot be easily defined by DATALOGC 
programs: Example 5 Consider the sampling query Find an arbitrary set of employee samples that contain 
exactly two employees from each department (assuming each department has at least two employees) . Notice 
that the following DATALOGC program does not really de­fine this query: ernpl(Name, Dept) -ernp(Name, 
Dept), choice((Dept), (Name)) ernp2(Name, Dept) e ernp(Name, Dept), choice((Dept), (Name)) seiect.two-ernp( 
Namel) + ernpl(Namel, Dept), ernp2(Name2, Dept), Namel # Name2 In the above program, every occurrence 
of choice is independent from the other. There are some intended models of this program that contains 
exactly two stu­dents from each department, while others may not con­tain any student from a certain 
department. Although the purpose can be achieved by a modified version of this program in a two-sorted 
logic program as shown in [She90a], a considerable amount of overhead in defin­ing this sampling query 
may not be avoidable. For example, for samples of size n, we have to choose one employee from each department 
n times, and then per­form n(n 1)/2 tests of inequalities. The same query can be more easily defined 
by the IDLOG program: seiect.two.ernp( Name) -emp[2](Name, Dept, N), N<2 where each tuple with tid O 
or tid 1 in each sub-relation of emp grouped by Dept is chosen.6 0 The inadequacy of defining general 
sampling queries by the choice operator motivates the need of having multiple-choice operators, such 
as choice2 choosing two samples, and choice3 choosing three samples. Yet, each such multiple-choice operator 
requires a differ­ent interpretation based on the DATALOGC seman­tics. However, IDLOG can be thought 
of as a natural framework for expressing these operators. 61ndeed, as shown in [She90a], the condition 
N < 2 can be used to generate an optimization information which ensures that only two tuples of the relation 
emp will be used in the evaluation.  4 Optimizing DATALOG Pro­grams One important issue in optimizing 
deductive database programs is eliminating redundant solutions. For ex­ample, consider the following 
DATALOG program [KN88] P: p(x) +--q(x, z), Z(z, Y), y(w) In order to compute p, we need not compute y 
beyond determining whether y is non-empty. Moreover, for a given tuple (X, Z) in q, only one tuple in 
z containing Z in the first column needs to be considered. Argument positions, such as Y and W were called 
existential in [RBK88]. Definition 1 Suppose P is a DATALOG program containing no facts, and q is an 
output predicate of P. Suppose also p(~, Y) is a literal in the body of a clause r in P. Then the argument 
position correspond­ing to Y in p(~, Y) is called an existential argument w. r. t. q if the following 
holds: Let a new clause p (~, Y ) + p(~, Y) be added to P, and let p(~, Y) be replaced by p (~, Y ) in 
r. Further, let any occurrence of Y in the head predicate of r be replaced by Y . Then, the new program 
is q-equivalent to P. Suppose q is the head predicate of r. Then an argu­ment of q is existential if 
the argument is existential in all occurrences of q in the bodies of clauses in P. It has been shown 
in [RBK88] that the detection of existential arguments is in general undecidable. The adornment algorithm 
(a sufficient test) provided in [RBK88] for identifying existential arguments is baaed on the property 
that if a variable Y appears in a body literal and does not appear anywhere else in the clause, except 
possibly in an existential argument of the head, then the argument position corresponding to Y is ex­istential. 
Except the arguments in input predicates, each argument identified as existential by this algo­rithm 
can be eliminated without affecting the query defined by the underlying output predicate, which is basically 
an operation of pushing projections . Example 6 [RBK88] Consider the following program: [1] q(x) -a(x, 
Y) [2] a(x, Y) + p(x, z), a(z, Y) [3] *(X, Y) + p(X, Y) According to the algorithm, the second argument 
Y of a in [1] will be identified as existential because Y does not appear anywhere else, which implies 
that the occurrences of Y in the heads of [2] and [3] are exis­tential. Now the second argument Y of 
a in the body of [2] is also identified as existential since it does not appear anywhere else except 
in the existential argu­ment of the head. Similarly, the second argument of p in [3] is existential. 
The program can be recast into the following q-equivalent program: q(X) -a (X) a (x) +-p(x, z), a (z) 
a (X) + p(X, Y) In the following, we introduce another definition of existential arguments. Intuitively, 
the difference be­tween the new definition and the previous one is the new relation used for replacing 
the relation containing existential arguments. Under the new definition, the relation (pus] (~, Y, O) 
in the following definition) con­sists of exactly one tuple (from every sub-relation of the relation 
to be replaced), while under the previ­ous definition, the relation (p (~, Y ) in Definition 1) contains 
all tuples . Definition 2 Suppose P is a DATALOG program containing no facts, and q is an output predicate 
of P. Suppose also p(~, Y) is a literal in the body of a clause r in P, and s contains the argument positions 
corresponding to ~. Then the argument position cor­responding to Y in p(~, Y) is called an existentia~ 
argument w.r. t. q if P is q-equivalent to the IDLOG program obtained from P by replacing the literal 
p(~, Y) in r by the ID-literal pus](~, Y, O). 0 For ease of discussion, existential arguments defined 
by Definition 1 will be mentioned as V-existential ar­guments, while the ones defined by Definition 2 
are called 3-existential arguments. As shown in the fol­lowing example, the two notions are different. 
Example 7 Consider the program P given by [1] q, -z(c) [2] q, 4-x(a) [3] Z(Y) + p(Y) [4] p(b) + u(X) 
[5] p(c) + y(x) The query ql defined by P returns TRUE if and only if the input for predicate y is not 
empty; the query q2 defined by P always returns FALSE. We will show that the argument position corresponding 
to Y in the body of clause [3] is V-existential but not 3-existential w.r.t. ql, and 3-existential but 
not V-existential w.r. t. q2 . 1. The argument is V-existential w.r.t. ql since P is ql-equivalent to 
the program P1: q~ t z(c) q2 +--~(a) Z(Y ) -p (Y ) p (Y ) -p(Y) O) -Y(x) P(c) + Y(x) But, since the 
query q2 defined by P1 re­turns TRUE on non-empty inputs, P is not q2­equivalent to P1. Therefore, the 
argument is not V-existential w.r.t. qz. 2. Let the following IDLOG program be P2. ql -X(c) q2 +-z(a) 
X(Y) + p~(Y, o) ~(b) -Y(X) p(c) +--y(x) Depending on which tuple ((b) or (c)) is assigned tid O in p~, 
the query ql defined by P2 may re­turn TRUE or FALSE on non-empty inputs (i.e., the query ql is not deterministic). 
Therefore, it is not 3-existential w.r. t. ql. However, the query q2 defined by P2 always returns FALSE 
no mat­ter what the input is. The argument is hence 3-existential w.r.t. qz. 0 The definition of 3-existential 
arguments suggests the following optimization strategy for DATALOG programs: every literal containing 
an 3-existential ar­gument can be replaced by an ID-literal mentioned in Definition 2. This may greatly 
reduce the number of redundant tuples. Unfortunately, the problem of detecting 3-existential arguments 
is in general unde­cidable as well. Theorem 3 The problem of identifying 3-existential arguments zn DA 
TALOG programs is undecidable. Despite the dissimilarity between 3-and V-existential arguments, there 
is a correlation between them: Theorem 4 Every V-existential argument identified by the adornment algorithm 
in [RBK88] is also an 1­existeniiai argument. l For example, the program P at the beginning of this section 
can be recast into the following p-equivalent IDLOG program: p(x) -q(x, z), Z[l](z, Y, o), y~(w, o) This 
suggests the following optimization strategy, where the first two steps are taken from [RBK88]: 1. Use 
the adornment algorithm in [RBK88] to iden­tify existential arguments, and transform the pro­gram accordingly 
(w.r.t. a certain output predi­cate). 2. Eliminate each identified existential argument ap­pearing in 
an output predicate.  3. Suppose p is an input predicate, p(~) is a literal in the program, and X1, 
. . .. Xn are existential arguments in p(~). Then replace p(~) by the ID-literal p[s](~, O), where s 
corresponds to ar­gumentsin Y {Xl, . . .. Xn}. 4. The resulting program can then be optimized by Algorithm 
D. 1 in [She90a].7  Example 8 The program in Example 6 can be fur­ther recast into the following q-equivalent 
program P: ~(x) e a (x) a (x) + p(x, z), a (z) a (X) t p[l](X, Y, O) Note that the second clause of this 
program can actu­ally be discarded without affecting the query q defined by this program as shown in 
[RBK88]. But this is be­yond the scope of this paper. 0 With this optimization strategy, ID-predicates 
can be used to optimize DATALOG programs to a cer­tain degree. Yet, more importantly, they provide users 
with an explicit construct for specifying 3-existential arguments which cannot be effectively detected. 
One of the motivations for introducing the choice opera­tor to DATALOG is also to provide users with 
an explicit construct for removing redundant solutions. Our results in the previous section suggest that 
the choice operators are really designated for 3-existential arguments but not V-existential arguments. 
The rela­tionship between choice and cut in top-down evalua­tion was also discussed in [KN88]. It is 
known that every DATALOG program with cut has an equiva­lent DATALOGC program. Since IDLOG subsumes DATALOGC, 
it means that cut can be expressed in IDLOG as well.  5 The Expressive Power of Non-deterministic IDLOG 
Due to limited space, in this section, we just list some results about the expressive power of IDLOG 
in expressing non-deterministic queries. We make use generic Turing machines [HS89] to show that the 
class of queries defined by stratified IDLOG pro­ grams is equivalent to the class of all computable 
non­deterministic queries. Theorem 5 ([HS89]) The class of queries computed by input-order independent 
generic Turing machines M equivalent to the class of computable deterministic queraes. 0 7The tid o in 
the previous step can be used to generate an optimization information which can be used to ensure that 
only one tuple of the relation p will be used in the evaluation. Lemma 1 The class of non-deterministic 
queries computed by input-order independent NGTM s is equivalent to the class of computable non-deterministic 
queries. Theorem 6 The class of non-deterministic queries dejined by stratified IDLOG programs is equivalent 
to the class of computable non-deterministic queries. fl 6 Conclusion In this paper, we studied the 
non-deterministic part of ID LOG. Our language generalizes DATA LOG with choice operator in terms of 
defining sampling queries and optimizing DATALOG programs. A new notion of 3-existential arguments is 
introduced. IDLOG pro­vides an explicit construct for specifying such argu­ments in programs such that 
the number of inter­mediate redundant tuples in query evaluation can be greatly reduced. We showed that 
the problem of iden­tifying Z1-existential arguments in a DATALOG pro­gram is undecidable, but noted 
that the sufficient test for identifying V-existential arguments given in [RBK88] works for 3-existential 
arguments as well. We have also shown that stratified IDLOG programs de­fine all computable non-deterministic 
queries.  Acknowledgments The author is greatly indebted to Michael Kifer for valuable discussions 
and suggestions which consider­ably improved this paper. Thanks are also due to David Scott Warren for 
his helpful comments. References <RefA>[ABW88] K.R. Apt, H.A. Blair, and A. Walker. Towards a Theory of Declarative 
Knowl­edge. Foundations of Deductive Database and Logic Programming (cd.), 1988. [ASV90] S. Abiteboul, 
E. Simon, and V. Vianu. Non-Deterministic Languages to Express Deterministic Transformation. Proceed­ings 
of ACM Symposium on Principles of Database Systems, pages 218-229, April 1990. [AV87] S. Abiteboul and 
V. Vianu. A Transaction Language Complete for Database Update and Specification. Proceedings of ACM Sympostum 
on Principles of Database Sys­tems, pages 260 268, March 1987. [AV88] [CH80] [Cha81] [End72] [GL88] [GS85] 
[HS89] [HS90] [KN88] [KP88] [MS88] [NT89] S. Abiteboul and V. Vianu. Procedural and Declarative Database 
Update Language. Proceedings of ACM Symposium on Prin­ciples of Database Systems, pages 240 250, March 
1988. A.K. Chandra and D. Harel. Computable Queries for Relational Databases. Jour­nal of Computer and 
System Sciences, 21(2):156-178, October 1980. A.K. Chandra. Programming Primitives for Database Languages. 
Proceedings of ACM Symposium on Principles of Pro­gramming Languages, pages 50-62, 1981.  H.B. Enderton. 
A Mathematical Introduc­tion to Logic. Academic Press, 1972. M. Gelfond and V. Lifschitz. The Stable 
Model Semantics for Logic Programming. Proceedings of the Fiflh Logic Programming Symposium, pages 1070-1080, 
1988. Y. Gurevich and S. Shelah. Fixed-Point Extensions of First-Order Logic. In Pro­ceedings of 26th 
Annual Symposium on Foundations of Computer Science, pages 346-353. IEEE, 1985. R. Hull and J. Su. Untyped 
Sets, Inven­tion, and Computable Queries. Proceed­ings of ACM Symposium on Principles of Database Systems, 
pages 347-359, March 1989. R. Hull and J. Su. Algebraic and Calcu­lus Query Languages for Recursively 
Typed Complex Objects, 1990. to appear in JCSS. R. Krishnamurthy and S. Naqvi. Non­deterministic Choice 
in Datalog. Technical Report ACA-ST-029-88, MCC, Austin, TX 78759, March 1988.  P.G. Kolaitis and C.H. 
Papadimitriou. Why Not Negation By Fixpoint? Proceed­ings of ACM Symposium on Principles of Database 
Systems, pages 231-239, March 1988. C. Maindreville and E. Simon. Modelling Non Deterministic Queries 
and Updates In Deductive Databases. Proceedings of International Conference on Very Large Databases, 
pages 395 406, 1988. S. Naqvi and S. Tsur. A Logical Language for Data and h nowledge Bases. Computer 
Science Press, 1989.  [Prz88a] [Prz88b] [RBK88] [Rei83] [She90a] [She90b] [SZ90] [Ge188] [VGRS88] [Zan86] 
T.C. Przymusinski. On the Declarative and Procedural Semantics of Logic Programs. Journal of Automated 
Reasoning, 1988. T.C. Przymusinski. On the Declarative Se­mantics of Deductive Databases and Logic Programs. 
In J. Minker, editor, Foun­dations of Deductive Databases and Logic Programming. Morgan Kaufmann, Los 
Al­tos, CA, 1988. R. Ramakrishnan, C. Beeri, and R. Krish­namurthy. Optimizing Existential Datalog Queries, 
1988. Draft. R. Reiter. Towards a Logical Recon­struction of Relational Database The­ory. In M.L. Brodie, 
J. Mylopoulos, and J. Schmidt, editors, On Conceptual Mod­elling: Perspectives from Artificial Intel­ligence, 
Databases and Programming Lan­guages. Springer-Verlag, 1983. Y. Sheng. A Non-deterministic De­ductive 
Database Languages with Tuple­identifications. PhD dissertation, Septem­ber 1990. Y. Sheng. IDLOG: Extending 
the Ex­pressive Power of Deductive Database Lan­guages. Proceedings of A CM SIGMOD In­ternational Conference 
on Management of Data, June 1990. D. Sacca and C. Zaniolo. Stable Models and Non-Determinism in Logic 
Programs with Negation. Proceedings of A CM Sym­posium on Principles of Database Systems, 1990. A. Van 
Gelder. Negation aa Failure Using Tight Derivations for General Logic Pro­grams. In J. Minker, editor, 
Foundations of Deductive Databases and Logic Program­ming, pages 149 176. Morgan Kaufmann, LOSAltos, 
CA, 1988. A. Van Gelder, K.A. Ross, and J.S. Schlipf. Well-Founded Semantics for General Logic Programs. 
Technical Report UCSC-CRL­88-16, University of California, Santa Cruz, University of California, Santa 
Cruz, CA 95064, March 1988. C. Zaniolo. Safety and Compilation of Non-Recursive Horn Clauses. Proceedings 
of of the 1st Expert Database Conf., 1986.</RefA>  
			

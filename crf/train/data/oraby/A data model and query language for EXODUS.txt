
 A Data Model and Query Language for EXODUS Mchael J Carey Davtd J DeWttt Scott L Vandenberg Computer 
Sciences Department Universtty of Wlsconsm M&#38;son, WI 53706 ABSTRACT In thus paper, we present the 
desrgn of the EXTRA data model and the EXCESS query language for the EXODUS extensible data- base system 
The EXTRA data model u&#38;des support for complex objects wrth shared SubobJects, a novel mur of object- 
and value- orrented semantics for data, support for persrstent objects of any type tn the EXTRA type 
lattrce, and user-de&#38;ted abstract data types (ADTs) The EXCESS query language provuies facrlrnes 
for query- ing and updatrng complex object structures, and it can be extended through the addrnon of 
ALIT functrons and operators, procedures and Qnctwns for mampulaang EXTRA schema types, and generic set 
finctzons EXTRA and EXCESS are intended to serve as a test vehicle for tools developed under the EXODUS 
extensible database system project 1. INTRODUCTION When we began the EXODUS project [Care86, Care871 
over two years ago, we purposely avolded centermg the pm@ around a new data model and query language 
There were several reasons for thus decuaon Rrst, we strongly doubted that a smgle data model and query 
language would adequately serve the wide vanety of apphcanons that seem to need database technology (gust 
as no sm- gle programmmg language IS suitable for all uses) We therefore began by carefully reviewing 
the data stmctunng and processmg reqmrements of a representatwe sample of emergmg application areas, 
deslgmng EXODUS (m a moE or less bottom-up fation) to be a tootit for use as a basis m constructmg a 
wtde variety of target database facfittes Also, we felt that, should a new standard data model emerge 
and be embraced by the database commu~ty (as the relanonal model was m the 1970 s), the EXODUS toolkn 
would enable us to rapidly develop a system based on thus new data model While a number of new data models 
have been proposed 111 the past few years, there appears to be no consensus on the horizon A number of 
database researchers seem to beheve that ObJect-onented database systems are the future Fsh87, Khos87, 
-187. Hom87, A&#38;87, Bane87, Mae861, and several flavors of ObJect-onented models have been ldenhfied 
[D1tt86] However, there is httle con- sensus as to what an object-onented database system should be, 
such systems today range from ObJeCt-onented pmgmmmmg languages with persistence to full database systems 
based on data Pemuss~onto copy wthout fee all or part of this matenal IS granted provided that the copses 
are not made or dlstrlbuted for duect commercial advantage, the ACM copyright notlce and the title of 
the pubhcatlon and Its date appear, and notIce 1s gwen that copymg 1s by permlsslon of the Assoclatlon 
for Computmg Machmery To copy otherwse, or to repubhsh requres a fee and/or specltic permlsslon 0 1988 
ACM 0-89791-268-3/88/OCO6/0413 $1 50 models that would have been called semanuc data models two years 
ago In fact, the former kmd of ObJect-onented DBMS almost seems like a step back to the days of navlgahonal 
data mampulation languages, as it IS not obvious how one wdl support ad-hoc quenes (or opnmlze accesses 
effecnvely) for such systems [Bloo87, Ullm871 Another duechon m data model evolutton, one which has spawned 
such efforts as [Codd79, Dada86, Sche86, Schw86, Rowe87], is to extend the re1atlona.l model m some way 
A com- mon goal of these efforts (and of our work as well) IS to provide better support for complex objects 
and new data types than that offered by the relational model, while snll retammg such unportaut features 
as a powerful, user-fnendly, data mampulanon language One approach to dang with complex objects (also 
known as structural ObJect-onentatIon [D1tt86]) is to provide procedures as a data type [Ston87a] Another 
approach IS to pemnt relation-valued attnbutes [Dada86, Sche86] A thud approach IS to take a func- honal 
view of data [Sh1p81, Mano86, Bato87] In ad&#38;hon, a com- mon theme among many of these efforts IS 
to extend the database system s data defimuon factines with support for some form of type mhentance Now 
that a number of the components of EXODUS are near- mg complenon, we have turned our attennon to the 
process of selectmg a target data model to use as a demonstmhon vehicle for the system Smce no one data 
model seemed exactly nght to us, and we have been unable to obtam detatls regardmg several promis- mg 
commercial next genemhon data model efforts, we (somewhat reluctantly) decided that we should design 
our own data model and query language for demonstratmg the capabtines of the EXODUS system Thus paper 
presents the EXTRA data model and the associ- ated EXCESS query language, which are the results of our 
design effort Readers fanuhar with the data modelmg literature will nxogmze the result as a synthess 
and extemon of ideas from other data models and systems, mcludmg GEM [Zam83], POSTGRES [Rowe87], &#38; 
models [Dada86, Sche861, DAPLEX [Sh~pBl], ORION [Bane87], Tm.lhs/Owl [S&#38;86], 0, [Lec187], STDM [Cope84], 
and STDM s descendant, Gemstone [Mate861 Our most important extensions mclude support for complex objects 
based on a novel mixture of obJect and value semantics, a user- frtendly, hgh-level query language reflecMg 
thus RIlXtUtG faCihnes to allow objects of any type to be made persistent ard accessed via the query 
language, and an integmhon of user-defined types and operahons with the query language at two levels, 
for both abstract data types and for conceptual schema-level types The remamder of 011s paper 1s orgamzed 
as follows Section 2 presents the data modehng facfines of EXTRA, mcludmg a number of examples In Secnon 
3, we present the EXCESS query language, mcludmg its facilihes for querying complex objects, performmg 
I EXTRAstands for EXtenslble Types for Relaoons and Atmbutes EX-CESS 1s short for EXtenstble Calcolus 
wth Enmy and Set Support updates, and compuung aggregates Secuon 4 dtscusses the support provtded m EXTRA 
and EXCESS for userdefined types and opera- bon.3 Sechon 5 compares our proposal wnh a number of other 
recently proposed data models and query languages Fmally, Sec- uon 6 presents our conclustons and our 
plans tegardmg future research and unplementahon work 2 THE EXTRA DATA MODEL In the EXTRA data model, 
a database is a collechon of named perststent objects These objects can be as simple or as complex as 
desired. EXTRA does not constmm the type structum of the named (or top level ) oblects in the database 
EXTRA separates the defimuon of types from the declarauon of then mstances. and tt pro- vides a type 
system based on a type lamce with mulhple mhen- tance The type system mcludes tuple, set, and array as 
type con- stmctors that may be composed arbitranly to fonn new types EXTRA also provtdes support for 
user-de&#38;d abstract data types We wtll elaborate on each of these features m thts sectron, and we 
wllI dlustrate them by iterahve retlnement of a simple example database 2 1. The Basx EXTRA Type System 
In EXTRA, the defimhon of a type and the declarauon of mstances of that type are completely separated 
from one another Thts makes tt possrble for a database to include more than one col- lecuon of mstances 
of a gven type, whmh can be quite useful in sctenttfic and engmeenng apphcauons bhm83, Kemp871 Wlule 
thrs separanon is common in pmgrammmg languages, it is less common m the database world [Bloo87] As an 
example, the com- mands m Figure 1 deilne a new schema type called Person, which is a tuple type Two 
sets for stonng Person mstances are then created, the Students set and the Employees set (We will explam 
the own ref syntax shortly, rt can be tgnoted for the purposes of the curmnt dlscusston For now, the 
Students and Employees sets can be thought of as relauons ) define type Person ( ssnum mt4, name chari 
I. street char[20], city char[lOl, ZlP mt4. birthday Date > create Students (ownrefPerson) create Employees 
( own ref Person ) Figure 1 Creatmg schema types and mstances EXTRA provides a vanety of base types 
and type constructors for defimng schema types, some of whtch are used m Ftgum 1 Predefined base types 
mclude integers of vanous sizes, single and double-prectaon floatmg pomt numbers, booleans, character 
stnngs, and enurrerahons EXTRA also supports the addmon of new base types through an abstract data type 
(ADT) faculty slmtlar to those of [Ston86, Ston87b] hke the Date type m Ftgure 1. ADT support will be 
covered m a later secuon The type constmctom of EXTRA include tuple (e g , Person 1s a tuple type), fixed 
length arrays, van- able length arrays, sets, and references We will have mom to say regarding reference. 
set, and array type constructor later on, when we descnbe EXTRA s support for complex objects define 
type Student ( float4, gt char[30] > inherits Person define type Employee ( lobutle CharPOl, dept char[fOl, 
manager cm I, Salary it4 1 rnhertts Person create Students ( own ref Student ) create Employees ( own 
ref Employee ) Figure 2 Cmatmg subtypes and then mstances The example of Figure 1 is tmreahsuc m the 
sense that we wtll probably want to associate more mformauon wtth Student and Employee oblects than that 
whtch IS contamed m a Person object Ftgure 2 mtlnes our example, tllustratmg type mhentance m EXTRA and 
a mom mahstrc declarahon of the Students and Employees sets The Student tuple type mhents all of the 
attnbutes of the Person tuple type, and m addmon it has a grade pomt average @pa) attnbute and a department 
(dept) attnbute The Employee tuple type adds the attrtbutes Jobhtle, dept. manager, and salary to those 
of the Person tuple type A tuple type may also mhent attnbutes from more than one type, as the general 
form of the mhentance clause 1s inherits type1 , 07-4 If a type mhents two (or mom) attnbutes with the 
same name, a conflmt anses If these attnbutes are mhented from a smgle common supertype. conflict resolutton 
umtes them into a single attnbute for the new type - smcc the confhcMg attnbutes have the same souree, 
they also have the same meamng However, If a name confltct arises between attnbutes from different sources, 
no attempt is made to handle the problem automaucally Instead, we require the definer of the type to 
resolve the conflict explicitly via renam- mg For example, suppose we wtsh to create a new type called 
WorkStudyStudent as a subtype of both the Employee and Stu- dent types of Ftgure 2 Thts would be d&#38;lowed 
due to a name conflict under our rule since the dept attnbute would be mhented from two sources wnh two 
dtfferent meamngs the Student type s dept attnbute speafies a student s major, whtle the Employee type 
s dept attnbute specifies the department where an employee works Figure 3 shows how this conthct can 
be resolved via mnammg POSTGRES would lgnom this conflict because the conihctmg dept attnbutes are of 
the same data type [Rowe87], wlule TAXIS would simply dtsallow the confltct [Nix0871 EXTRA is closest 
to ORION [Bane871 m tts handhng of conflicts, except that we provide no automanc resolunon In the absence 
of explicit renammg, ORION would select one of the two dept deilmttons automancally, based on the order 
of entnes m the mhents clause, dmppmg the other one define type WorkStudyStudent ( weeklyHours mt4 malorDept 
Student dept. JObDept Employee dept ) Inherits Student, Employee Figure 3 An example with multiple mhentance 
2 2 Modehng Complex Gbiects m EXTRA A complex oblect is an ObJeCt that IS composed of a number of component 
Objects, each of which may m turn be composed of other 414 COmpOnCnt Objects In general, an object can 
be a Component of more than one object EXTRA provides four type constmctors in addition to the tuple 
type constructor to support complex Object modelmg the ref type constructor, the own type constructor, 
the set (or { 1 ) type constructor, and the array type constructor define type Student ( float4. gt ref 
Department mherrts Person define type Employee ( JObtItle CharPOl, dept ref Department, manager ref 
Employee, salary int4 ) mherlts Person create Students ( own ref Student ) create Employees ( own ref 
Employee ] Figure 4 Reference attnbute example The example m Figure 4 shows the schema of Figure 2 redefined 
using ref attnbutes for the dept attnbute of the Student type and for the dept and manager attnbutes 
of Employee These are hke reference attnbutes m GEM [Zam83], wtth each Student ObJeCt COntalmng (a tI?ferenCe 
to) Its COrtWpOXIdmg Department object The referenced department object is reqmred to exist else- where 
m the database (or else the value of the reference must be null ) In addmon, the referenced object must 
be of type Depart- ment or else some subtype of the Department type define type Department ( name chti 
I, floor mt4, numemps mt4, employees ( ref Employee ) create Departments ( own ref Department ) Figure 
5 Combmmg sets and references Another type constructor that EXTRA provides for mcdehng complex object 
types is the set constructor,~whose use has already been illustrated for creatmg the eqmvalent of a n9ahon 
m EXTRA EXTRA allows sets of any data type to be defined/created, and such sets can then contam 0bJeCt.S 
of the specified type and also any of its subtypes Sets of base types, constructed types, and reference 
types are all possible m EXTRA Thus leads to a very powerful facihty for modelmg complex objects, as 
nested relations (ala &#38; data models) can be supported via sets of tuples, and sets with shared SubObJeCts(ala 
[Bane87 and L.ec187]) can be supported via sets of references As an example, Figure 5 shows the delimuon 
for the Department type and the creahon of a perststent set (Departments) of objects of thus type The 
defimhon of the employees attnbute of the Department type spmfies tt as bemg a set of references to objects 
of type Employee Thus, for a given department, the employees attnbute effecnvely contams all of the employees 
that work for the department While reference attnbutes and their mteration with the set type constructor 
permit the development of complex object (graph) structures, there are cases where the database designer 
wishes to treat an object and rts components as a smgle ObJect that simply happens to have a complex 
value structure There are also related cases where the components of an ObJect need to be full-fledged 
ObJects, but where the ObJect should snll be treated as a whole, as in ORION s composrte ObJects [&#38;m87] 
To support these Qfferent cases, EXTRA prowdes three different kmds of attnbute value semanucs own attnbutes, 
ret attnbutes, and own ref attnbutes An own attnbute IS snnply a value, not a first-class object, it 
lacks Idennty m the sense of [Khos86] By default, all attnbutes are taken to be own attnbutes unless 
otherwlse specified An own ref attn- bute IS a reference with the added constramt that the referenced 
ObJect is owned by the refenmcmg obJect3, thus. if the referencmg ObJect IS deleted, the referenced own 
ref object is deleted as well Finally, a ref attnbute IS simply a reference to another (mdepen- dent) 
object. as described earher, v&#38;out cascaded deletion seman- ttcs In addmon to then semantic. nnportance. 
own and own ref pmvlde EXTRA with mformahon that can potentmlly be exploited for performance reasons 
(e g , for clustermg) The combmation of set and array type constructors. together with ref, own ref and 
own modes for attnbutes. yields a flexible and powerful facIhty for modehng complex obJect shuct~~ The 
database designer can tior a design appropnately, rather than adaptmg It to one particular semantics 
for modehng complex obJects For example, we could extend our Employee type with an additional Eeld fot 
keepme track of employees cNdren by addmg the Eeld defimhon luds ( own Person ) Thus says that the luds 
attnbute of an Employee IS a set of tuples of type Person 4 Note that these Person mstances are tuple 
values, and not tuple objects They do not have obJect rdennfy as objects do, and therefore they cannot 
be referenced from elsewhere m the database via a reference attn- bute In addihon, If an employee IS 
deleted, so are his or her hds Thu provides a capab&#38;y very snmlar to that provided by &#38; data 
models [Dada86, Sche86] If the luds attnbute were m&#38;ad declared to be of type ( own ref Person ) 
, the deletion semantics would be the same, but chddren could then be referenced from else- where m the 
database (by ref attnbutes of other Objects) As with compostte objects m ORION [Kun87], however, a Person 
mstance m the luds set of one Employee mstance cannot be III the hds set of another Employee mstance 
snnultaneously To overcome tins hnu- tanon, the luds attnbute could be defined snnply as ( ref Person 
) , m which case sharmg is pernutted and the delehon of an employee instance WIU not automahcally delete 
the luds As we ~IU see m the next sectton, despite their semanhc &#38;fferences. own, ref, and own ref 
attnbutes are all treated umformly m the EXCESS query language for query snnphclty Thus, casual users 
can ignore the distmctton, vtewmg attnbutes simply as other objects, as m most ObJect-onented data models 
[Lec187, Hom87, Andr87, Bane87, Miue87] In addmon to sets and references, fixed and vanable-length arrays 
are provided and anz useful for modeling complex ObJects Vanable-length arrays are msertable . meamng 
that array elements can be mserted or deleted anywhere m the array, such an array can be viewed as a 
sequence or an mdexable hst An array type con- stmctor can be used anywhere a set constructor can be 
applied. which means that (for example) one can have vanable-length arrays of objects Thus IS useful 
for modehng complex objects where order 1s Important (e g , documents) a Note AlI ObJects must have a 
home as M 0Wl1 ret mmponmt of some 2Space lumtahcms prevent us from folly addressmg the mtegnty unpbcahons 
other Object m order to enst tn the database Named, p%s.tst%tt. top-level ObJecU of EXTRA, but referentA 
mtegnty and null values wdl be handled m a mmmer sre sutomatdly msde. own ref components of the database 
m wluch they are smlar to GEM [Zm83] We also mtend to support keys, the spec~cahon of crested. lb ensures 
that automahc garbage collechon 1s not needed whtch wll be assoctated wtth set mstattczs sulce own 1s 
the default, tlus 1s eqttlValent to %ds ( Person ) ,a 415 2.3 Other AttrIbute Types define type Person 
In addition to the faclhaes described thus far, EXTRA pm vides support for two other kmds of attnbutes 
attnbutes of va.nous types defined by users (I e, user-defined ADTs), and attnbutes defined m terms of 
other values m the database, or denved attn- butes As an example of an ADT attnbute, If we wished to 
mclude a ptcture of each employee in the database, we could extend our deEmnon of the Employee type by 
speclfymg an attnbute face picture for stonng th.~s mformatron Includmg tis m the delimoon of the Employee 
ObJeCt type says that each Employee Hrlll have a face attnbute of type hctnre, which IS a user-defined 
ADT for stor- ing bit-map Images We will descnbe EXTRA s ADT faclhtles (and dlstmgmsh them from schema 
types) m more detail m Se&#38;on 4, basIcally, though, an ADT can be used wherever any of EXTRA s bullt-m 
types can appear As for denved attnbutes, EXTRA allows object attnbutes to be defined via quenes m the 
EXCESS query language Thus facfilty tiows objects to appear to contam certam mformanon which, rather 
than bemg stored, can be computed on demand from the current database state As we wfl discuss m Secuon 
4, denved attnbutes m EXTRA are snmlar to the denved or procedural data nottons of other data models, 
and they are supported through a facility for associahng both EXCESS funchons and procedures with EXCESS 
types For example, we could extend our Person type defimtton by deEmng a denved age attnbute, which could 
be referenced Just as if it were a real attnbute, as follows define Person fun&#38;on age returns mt4 
( retrieve (Today - thus birthday) )  In tis example, thus 1s a special range vanable that IS nnphatly 
bound to the Person mstance to whtch the iimchon IS applied, Today is a top-level database object of 
type Date conamng today s date, and the mums operator IS a Date operator that computes the dlffer- ence 
m years between two Dates We urlll say more about EXCESS functtons and procedures m Sectton 4, after 
the EXCESS query language has been described 2 4. Data Mode1 Summary To summarize, an EXTRA database 
IS a collecuon of named persistent ObJfXtS of any type EXTRA separates the nohons of type and mstance, 
thus, users can collect related ObJects together in semantically meanmgful sets and arrays, wluch can 
then be quened, rather than having to settle for quenes over type extents as m many data models (e g 
, [Shp81, Bane87, L&#38;87. Mylo80, Rowe871) EXTRA provides tuple, set, fixed-length array, and vanable-length 
army as type constructors In addihon, there are three kmds of values, own, ref, and own ref (although 
casual users such as query wnters need not be. concerned wtth Uus Qstmcnon) Combined with the other type 
constmcto~, these provide a powerful set of factihes for modelmg complex object types and their SemanUcs 
Finally, EXTRA pmvldes support for user-defined ADTs and for denved attnbutes Figure 6 llh~strates some 
of the sort of database structures that can be defined m EXTRA , showmg how one could create Students, 
Employees, and Departments relations, a named object for accessmg the best employee directly, an array 
for keepmg track of the top ten employees, a calendar object represented as a nested array of ADT vames 
of type Day), and an obJeCt for stonng the current date The next sectlon will explain how such a database 
can be quened and updated via the EXCESS query language s Whde Fqyxe 6 does not show at, named non h~ple 
types may also be defined. For example. define type Month array [ ] of Day would let create Calendar 
array [l 121 of Month be used to create the calendar Object m OUT ex ample ( int4, name cw 1% street 
char[20], w char[lOl, Z P mt4, birthday Date define type Student ( float4. ret Department )Inherits Person 
define type Employee ( JObtItle. chiwt201. dept ref Depamnent, manager ref Employee, salary it4 ktds 
( own Person } 1 Inherits Person define type Department ( name chid I, floor int4,. manager ret Employee, 
employees ( ref Employee ] ) create Students ( own ref Student ) create Employees ( own ref Employee 
) create Departments ( own ref Department ) create StarEmployee ref Employee create TopTen array [1 lo] 
of ref Employee create Calendar array [ 1 121 of array [ ] of Day create Today Date Figure 6 A complete 
employee database example 3. THE EXCESS QUERY LANGUAGE While some may queshon the need for a general-purpose 
query language m a database system designed to support emerging auohcanon areas such as CAD/CAM, we believe 
that the inclusion -rr-of such a language is indeed Justified Functtonahty like assoctatlve searchmg 
can be important in any applrcatlon domam, even CAD/CAM For example, rf reuse of design components IS 
to become a reality, designers will need to be able to query the data- base of design objects in order 
to see if an appropnate component alread) exists In ad&#38;hon, a full-function query language makes 
It possible for the same database system to be used for both busmcss and engmeermg data, supportmg quenes 
such as those needed 3 compute design costs or to order parts for assembhng a design object [Ston87c] 
Lastly, associahve query languages are nnportant because they are amenable to query optlmlzatlon techniques 
In thus sectlon we present the design of the EXCESS query language mle EXCESS IS based on QUEL [Ston76], 
WC have borrowed Ideas from the QUEL extensions developed for GEM [Zam83] and POSTGRES [Rowe87, Ston87b] 
as well as work on SQL extensions for handhng &#38; data [Dada86, Sche86] Sahcnt features of the EXCESS 
language include a uniform treatment of all kmds of sets and arrays, mcludmg nested sets, a type-oncntcd 
treatment of range vanables, a clean, consistent approach to aggre- gates and aggregate functions, and 
an update syntax that supports 416 the constructron of compltx ObJeCtSwith shared suboblects In the 
remainder of thrs sectron, we will descnbe each of the major features of the EXCESS query language Our 
examples will be based on the employee database 111 Frgure 6 3 1 Set Query Basics EXCESS provtdes a umform 
syntax for formulatmg quenes over sets of ob,ects, sets of tefcrences, and sets of (own) values For example, 
consider the followmg EXCESS query range of D IS Departments retrieve (E name) from E m D employees where 
D floor = 2 Thrs query Ends the names of all employees who work m depart- ments located on the second 
floor The rmttal range statement specifies that the range vanable D 1s to be bound to the set of department 
oblects 111 the Departments set, thts is the convenhonal (QUEL) use of a range vanable The phrase from 
E In D employees m the query specifies that the range vanable E IS to be bound to the set of employees 
for each department that satisfies the selechon predicate D Eoon=2 Since D employees 1s a set of Employee 
references, thts illustrates how sets of references can be eastly mampulated vta EXCESS quenes As another 
example, the followmg query Ends the names of the chtldrcn of all employees who work for a department 
on the second floor range of E IS Employees retrieve (C name) from C m E krds where E deptfloor = 2 
Despite the fact that E krds is a set of values rather than a set of ObleCt&#38; thtS query looks the 
same as the previous example beCaUSe all sets are treated alike in EXCESS quenes (Mmor differences do 
anse for updates, though, as we will descnbe shortly ) EXTRA also allows the creation of named persistent 
ObleCts as single mstances of any type (e g , Today and StarEmployee m Figure 6) Such oblects can be 
referenced dnectly m the EXCESS query language For example retrieve (Today) retrieve (StarEmployee name, 
StarEmployee salary) retrieve (TopTen[ I] name, TopTenil] salary)  3.2 Range Variables and Their Types 
EXCESS provides several tiferent mechamsms for specrfy- mg the set of objects over whmh a vanable is 
to range Most are smllar to the mechamsms of GEM [Zam83] and POSTQUEL IBowe87], but EXCESS also provides 
support for umversal quantrEcahon (to stmphfy certam kmds of set queries) The. snn- plest form of range 
statement has the tradnronal QUEL syntax, I e , range of <Vanable> IS <Range-SpeciEcahon> For thrs form 
of range vanable. the &#38;ange-SpectEcatton> must rdenttfy either a named, perststent set (e g , Employees), 
array (e g , TopTen), or subrange of an array (e g , TopTen[2 51) Unless msmcted by lower and upper bounds, 
arrays am treated as sets (except for duphcate semanttcs on updates) Thus, the statement range of E IS 
TopTen results m E rangmg over all objects m the TopTen array, whtle the statement range of E IS TopTen[2 
51 resmcts E to rangmg over the 2nd through 5th ObJeCtS As far as the user 1s concerned, it 1s immatenal 
whether the set or array contams Oblects. references, or values Also, like GEM, an rmphcn range vanable 
is provided for each set or array specrEed m the target list or m the quahEcatton of a query Thus, our 
earlier query mvolvmg chrldnm of second floor employees could have been wntten as retrieve (C name) from 
C m Employees hds where Employees dept Boor = 2  EXCESS also provides a path syntax in order to stmphfy 
the task of formulatmg quenes over nested sets of ObJeCtS [Shrp81, Cope841 As an example, the statement 
range of C IS Employees lads means that for each employee obJect m the Employees set, C will iterate 
over all the chrldren of the employee If one of the elements of a path is a single ObJeCt, it is treated 
as a singleton set. Thus, the statement range of C is Depamnents manager lads results m C rangmg over 
the manager s chtldren for each department Whrle the Erst form of range statement IS used stnctly for 
associahng a range vanable wrth a persistent, named set or array, the mmammg forms are used for assocra 
mg a range vanable with any set or array One such form of range statement has the syntax from <Vanable> 
m <SetSpecrEcanon>[ flype>] Here, cSet_Speciflcaho~ may be a persmtent, named set or array (e g , Employees, 
TopTen, or TopTen[2 5]), an attnbute defined usmg a set or arw type constructor (eg, E krds or Departments 
employees), or a set formed by takmg the umon (+). mtersecuon (*), or tiference (-) of two or more sets 
(e g , TopTen + StarEmployee or Students - Employees ) In an EXCESS query, each range vanable has an 
associated type, and the query may only refer to attnbutes assocrated with thts type In many cases, the 
appmpnate type can be mferred easily from the query For example, 111 our quenes mvolvmg chtldmn of second 
floor employees, the type of the vanable rangmg over the Employees set 1s Employee, the type of the elements 
m the set If the set over whrch a vanable ranges IS the umon, mtersectton, or difference of two or more 
sets (e g , from P m Students - Employ- ees ), It IS requned that the sets share a common supertype If 
thts supertype is umque, then the type of the range vanable IS mferred to be the most specific common 
supertype of the sets types If no umque supcrtype exists, then the normally opnonal aype> speciEcahon 
in the range syntax must be used to ldenhfy the parttc- ular supertype relevant to the query The last 
form of range statement m EXCESS 1s used to specify a umversally quanttEed range vanable, as EXCESS range 
vanables am otherwme existenhally quanttfied (as m QUEL) The syntax for thrs form of range statement 
IS forall <Vanable> In <Set_SpecrEcatron>[ 4I ype>] Its use IS rllu.strated m the follow- mg query, whtch 
remeves the names and ages of all htghly patd employees whose cNdren are all under 5 years old retrieve 
(E name, E age) from E III Employees where E salary > 1OOWO and (foralf C m E luds C age c 5) Umversal 
quannEcahon snnphEes the speaEcatron of quenes where it is desired that all elements of a set or array 
sahsfy some property Otherwrse, such quenes must be specified usmg an awk- ward combmatron of aggregates 
(probably makmg them mom difficult to optmnxe) In cases where a range vanable ranges over an array or 
a subrange of an array, rt may be useful to remeve the mdex of each oblect that sahsfies the query (as 
well as the ObleCt itself) In such cases, the range statement cVanable> speciEcanon can be aug- mented 
wnh an index varrable for each desired dtmensron As an example, the query retrieve (1, E name) from E[I] 
m TopTen where E sty = Berkeley wrll retneve the name of each TopTen employee living in Berkeley along 
with the employee s TopTen array index 3.X Objects as Results In the precedmg secnon, the result of each 
example query was a set of tuples for whtch the type of each attnbute was own In gen- eral, however, 
the result of a query can be a set of oblecta or a set of tuples m whrch one or more attnbutes is an 
oblect (ref or own ref) As an example, consider the followmg query whmh, for each employee makmg over 
$100,000, returns the name of the employee and hts or her department range of E IS Employees retrieve 
(E name, E dept) where E salary > 1CKlCMXl If tbrs query were embedded m a programmmg language, then 
the 417 ObJect idenufier for each department could be bound to a host van- able for subsequent mampulanon 
However, m the case of an ad- hoc query (where retrieve tiy means pnnt), pnntmg the obJect Identifier 
of each department is not acceptable Smce there does not seem to be a single nght answer to the question 
of what to prmt, the solunon we have adopted IS that when a retrieve query mtums an ObJect as the result 
of an ad-hoc query, the system wdl pnnt each own attnbute of the ObJect (recursively, If It IS a structured 
attn- bute) Thus, the above query IS equivalent to range of E IS Employees retrieve (E name, E deptname. 
E deptfioor) where E salary > IOOOOO w-0r.G [over Yl Iby Zl [from cVanable> m <Set-&#38;e&#38;canon>] 
[where Q]) The execution of an aggregate can be vlewed log~ally as follows First, the quahficanon Q is 
applied to each element ranged over by the range variable (I e , a selecnon 1s performed) The resultmg 
set of values 1s then proJected on the attnbute(s) specified m Y. with duphcates (if any) being ehmmated 
m the process, If no over Y clause is specified, duplicate ehmmanon IS not performed 6 If a by Z clause 
has been specified. the set is then pamnoned usmg the Z atmbute(s) as a key Note that if Z=Y, then each 
tuple forms its ownpart&#38;on, ifno byclausels speclfied,thenthere~sJustonepar-tiuon (m which case the 
aggregate is being used as a scalar aggre- To facihtate the specificanon of deep remeval operabons, fields 
in the target hst of a remeve query can be tagged wnh a *I operator to m&#38;cate that the obJect plus 
all of its component (own ref as well as own) ObJects are to be recursively remeved This capabihty will 
be especially useful for those applications (e g , CAD/CAM) that need to extract an Object and all of 
its component ObJects from the database wnh a single Emeve statement 3 4 EXCESS Jam Quenes Like GEM, 
EXCESS provides three types of Joins functronal ~0m.v (or nnplicit moms, using the dot notation), exphcrt 
zdentlty ~ortw, where enhttes are dtrect.Iy compared, and tradltlonal relatronal value-based morns A 
number of our examples have involved func- tional loins As a further example, consider the following 
query retrjeve (Employees dept name) where Employees city= Madson This query selects the employees hvmg 
m Madtson and then finds the name of their departments usmg the Department reference attn- bute of the 
Employee type as an unphcit Join atulbute The same query can also be expressed using an exphat idennty 
Jom retrieve (D name) fi-om D m Departments, E m Employees where E dept IS D and E city = Ma&#38;son 
In thts form, the value of the reference attnbute E dept 1s dmzctly compared with the range vanable D 
usmg the 1s operator The 1s operator is useful for comparmg references. returmng true if two references 
refer to the same obJect Thus, IS is a test for ObJect equahty rather than (recursive) value equahty 
in the sense of [Banc86] An Isnot opexiuor IS also provided for convemence m testmg that two references 
do not refer to the same obJect As in GEM, these am the only comparison operators apphcable to refer- 
ences It IS expected that most loins m EXCESS Will be functional JOmS, aS the impOrta% mhtIonshlpS betWen 
entmes cm be expressed duzctly through reference attnbutes, most other JOUS am expected to be expbat 
idennty ~olns However, tradlnonal value- basedJOlnS am also supported m the EXCESS query language, as 
In GEM For example, the followlng query finds the names of all per- sons hvmg in the same city as Jones 
retrieve (PI name) from Pl,P2 m (Students + Employees) where Pl cny = P2 city and P2 name = Jones 3.5 
Aggregates and Aggregate Functions Smce aggregates add important computanonal power to a query language, 
we felt that It was important to address them care- fully m EXCESS In deciding how to integrate aggregates 
mto the EXCESS query language, we have tned to prov:de an mtumve semanncs for aggregates and range vanable 
bmdmg We have also tned to make a clear dlstmcnon between the attnbutes used for par- tmomng, the attnbutes 
being aggregated, and other query attnbutes The following syntax 1s used for expressmg EXCESS aggregates 
and aggregate funcnons gate) Fmally, the operation agg-op is applied to the attnbute(s) specified by 
X, yielding one result value for each pamnon Both X and Z must be subsets of Y For agg-op, EXCESS provides 
all of the usual bmlt-m aggregates (e g , sum, count. avg, max, and mm) As a first example, the followmg 
EXCESS query wdl tind the average salary of all employees retrieve (avgsal = avg(E salary from E in Employees)) 
In order to fulfill our design goal of a clear, consistent rule for range vanable bmdmg, we use Pascal-hke 
scopmg rules for range vanables First, a range vanable declared m the outer query can be used w&#38;m 
an aggregate, however, If the same vanable 1s rede- clared wlthm the aggregate, the effect 1s to define 
a new range van- able Second, smce aggregates can be viewed as self-contamed queries, all range oanables: 
declared mslde an aggregate are smctly local to that aggregate expressIon These rules cons~dembly improve 
the semanncs of range vanables m aggregates over QUEL A consequence is that the result of an aggregate 
must be bound exphcjtly to the remamder of an aggregate query For example, the followmg query finds the 
name of each employee plus the average salary of all employees who work for hrs or her depaxtment range 
of EMP IS Employees retrieve (EMP name, avg(E salary by E dept from E m Employees where E dept IS EMP 
dept)) In dus example, the vanable E ranges over the Employees set withm the aggregate funcnon In order 
to bmd the results of the aggregate funcnon to the outer query, the clause E dept is EMP dept must be 
included In QUEL, tis bmdmg could be accompbshed unphatly by using a single range vanable for the entire 
query A final example wdl illustrate the separanon of aggregation and partmomng atmbutes, It wdl also 
show how one can operate on atmbutes from one level of a complex obJect whde pamnomng on attnbutes from 
other levels The followmg query remeves the name of each employee, for each employee, it also remeves 
the age of the youngest child among the chtldren of all employees workmg m a department on the same floor 
as the employee s depamnent range of EMP IS Employees retrreve (EMP name, mm(E luds age by E deptfloor 
from E m Employees where E dept.floor = EMP deptfloor)) In dus example, the vanable E ranges over Employees 
witbm the scope of the mm aggregate, and E w&#38;m the aggregate IS connected to EMP declared m the range 
statement via a Join on Employee dept floor The query aggregates over Employee luds, a set-valued attnbute, 
and pamtions the data usmg an attnbutc of Employee dept. which IS a single-valued reference atrnbute 
 418 3 6 Updates m EXCESS EXTRA provides four commands for updatmg a database insert, copy, replace, 
and delete The rnsert command takes an object and adds a reference to tt to a collecnon (set or array) 
The copy command IS stmdar to the insert command except that It Creates a new Object, either by making 
a copy of an extstmg ObJect or by using values supplied as parameters to the command To make a copy of 
an existmg ObJect, the own components of the object are copted recursively. new objects are created mcurstvely 
for all components of type own ref, and references are stmply copted for components of type ref Thus, 
the ongmal object and the copy wdl share component ObJects referred to by attrtbutes of type ref For 
both insert and copy, if the target collectton does not already exist, it must first be explicitly created 
usmg a create command The followmg example tllustrates the use of the copy com-mand to create a new employee 
ObJect and add it to Employees set. The effect of thts update is to add Smith to the Employees set. and 
to have mm work for Jones m the Computer Sctence Department. copy to Employees (name= Smnh . street = 
1210 W Dayton St , ctty = Madtson , bnthday = l/1/64 . dept = D, manager = M, Jobtnle = programmer , 
salary = 5OOCNJ) from D m Departments, M m Employees where D name = Computer Sciences and M name = Jones 
 The followmg msertton query completes the hmng process by addmg a reference to Smnh to the employees 
attnbute of the Com- puter SCienCe ObJeCt in the Departments set * Insert mto D employees Q from D m 
Departments, E m Employees where E name= Smtth and D name = Computer Sctences To add a chdd of Smith 
s to the database, the followmg query would be used copy to E hds (namc.= Anne , street = E street, city 
= E city, ZIP = E cny. hrthday = 10/10/7!? ) from E m Employees where E name = Smtth Since any object 
can be owned by only one own ref referencmg object. the following Insert command wdl fad create overpaid 
(own ref Employee) range of E is Employees insert mto ovetpard Q where E salary > IOOWO The problem 
hem is that employee oblects am already owned by the Employees set object. However, tlus would work tf 
overpard were created as {ref Employee) . altemanvely, it would work with copy to used m place of Insert 
mto (thereby copymg each employee object) Support IS also provided for updates to arrays For example, 
the following query wtll put the employee wtth the hrghest salary m the first postnon of the TopTen array 
(declared m Figure 6) range of E IS Employees msert into TopTen [l] Q where E salary z= max (X salary 
from X in Employees) An Insert or copy operatton on a fixed length array IS perfonncd by replacement 
begmmng at the spectfied index pos~tmn If there ts more than one employee wnh the maxllnum salary, those 
employ- ees wrll be mserted startmg at TopTen[Z] Updates on vanable length arrays are perrormed by msernng 
(or begmnmg) at the spectEed positron (wrth the keyword last berg pmvrded to mdtcate the end of the array) 
It would be mce to also ensure that the employees attriiute of tbe appmp- ate department obJe.ct IS updated 
whenever an employee IS hued or fired Usmg the extenslbdlty feature desmbed III Seam 4, it IS possible 
to define a HweEmp~yee PIW~IIE that fmapsulates the apprqmate pan of update queues as * s&#38;e mm-msnd, 
419 The replace command 1s used to mod@ objects For exam- ple, replace E (salary = E salary * 1 1) from 
E m Employees where E name = Jones wllJ gwe Jones a 10% nuse Lastly, to dlustrate the use of the delete 
operator, the followmg pan of EXTRA update quenes would be used to Ere Smnb delete E Tom E m D employees, 
D I~I Departments where D name = Computer Scrences and E name = Smnh delete E from E m Employees where 
E name = Smtth The delenon semanacs for own values and own ref 0bJect.s am that (1) they are deleted 
when then owner IS deleted, and (n) deletmg them causes them to be removed from the database as well 
as from the comammg object Thus, when Smnh is deleted from the Employees set, hts object is deleted from 
the database and lus clul- dren am recursively deleted (Deletmg a ref object deletes only the reference 
itself, and not the Object ) 4 EXTENSIBILITY IN EXTRA AND EXCESS A goal of the EXTRA data model and EXCESS 
query language was to provide users wrth the abrhty to defme new types, along with new funchons and operators 
for mampulatmg them EXTRA supports two kmds of type extensmns schema types and abstract data types (ADTs) 
Schema types were the subject of Sec- non 2, where we described how new schema types can be con- structed 
from base types md other schema types usmg the EXTRA type constructors In thm sectton, we descnbe how 
the. set of base types can be extended by addmg AM s We then consider schema types agam, descnbmg how 
fimchons and procedures wntten m EXCESS can be assocmted with schema types and how data abstractton can 
be aclueved We &#38;stmgmsh between these two kmds of type extensrons because of the &#38;fferent facthttes 
that are provided for lmplementmg them ADTs are wntten m the E pro- grammmg language [Rtch87]. usmg the 
type system and general- Purpose Prog rammmg facrhnes provided by E Schema types am created usmg the 
type system provrded by the EXTRA data model and the higher-level but mom resmctrve pmgrammmg facthttes 
offered by the EXCESS query language Fmally, we &#38;scuss how EXCESS may be extended wtth new set functtons 
(e g , new aggre- iita@ 4 1 Abstract Data Types New base types can be added to the EXTRA data model vta 
the EXTRA abstract data type facthty To add a new ADT, the per- son responstble for addmg the type. begms 
by wnnng (and debug- gmg) the code for the type m the E programmmg language E 1s an extension of C++ 
[Stm86] that has been designed and IS currently bemg implemented as part of the EXODUS pto~ect E wrll 
serve as the tmplementatton language for access methods and operators for EXTRA/EXCESS, the target language 
for the query compler, and (most importantly for our purposes here) the language m whrch base type extensrons 
wtll be defined E extends C++ wrth a number of features to ad programmers m database system programmmg, 
mcludmg dbclasses for persrstent storage, class generators for implementmg genenc classes and funcnons, 
iteratom for use as a control abstractton m wntmg set operattons, and built-m class gen- eratom for typed 
tiles and vanable-length arrays [bch87] Suppose that we wanted to add complex number as a new ADT First, 
we would need to Implement the ADT as a dbclass (much hke a C++ class) m E Figure 7 gtves a slrghtly 
slmphEed E mterface defimhon for the Complex dbclass The hidden Internal representanon of an ObJect of 
thts dbclass stores the real and ma- gmary components of complex numbers The Complex dbclass also pmvtdes 
a number of public funchons and pmcedures (known as member fonchons m C++ terms) In addmon to then exphcn 
argu- ments, all member funcnons have an imphcn Erst argument, thrs, which IS a reference to the object 
to which the function IS bemg applied The Complex dbclass has two constructor member func- nons for tmnahzmg 
newly created complex numbers, one that uses externally-supplied values9 and another that assumes a default 
tm- ttal value (e g , O s) In addmon, the dbclass has member funcnons to add and multtply pans of Complex 
numbers, and member func- tions to extract the real and imaginary parts of a Complex number Finally, 
the dbclass also has a Prmt member funchon The EXCESS query language interface requnes a Prmt member 
functron for all ADTs dbclass Complex ( float realPart, ImagPart, pubhc Complex(float&#38; float&#38;), 
Complex( ), Complex Add(Complex&#38;), Complex Multrply(Complex&#38;), float Real( 1, float ImagmaryC 
), vord Pnnt( 1, Figure 7 Contents of /usr/exodusAtb/adts/complex h Once a new data type has been implemented 
m E and fully debugged, it must be regrstered wnh the system so that the parser can recogmze tts functtons 
and the query comptler can generate appropnate E code To mgtster the new ADT Complex, the Imple- mentor 
of the type would enter the following (assummg that complexh contams the Complex interface defimnon and 
that complex e contams the E code that implements Q define adt Complex ( interface = /usr/exodus/ltb/adts/complex 
h, code = /usr/exodus/hb/adts/complex e ) Thus tells EXTRA/EXCESS where to End the definition and unple- 
mentation of the type The system use3 the deEmnon to extract the function name and argument type mformanon 
needed for query parsing and type. checkmg Types mcluded m the pubhc pornon of the detimnon must also 
be registered EXTRA base types, of course The implementanon fde (or list of fdes, m general) wilt be 
compiled and stored by the system for use when quenes that reference the Complex type are encountered 
After Complex has been regtstemd as a new ADT, tt can be used hke any other base type m EXTRA/EXCESS 
schemas, quenes, and updates The default notatton for member function mvocatlon IS sun~lar to that of 
C++ and E (but ( ) may be omitted for func- tions with no explicit arguments) For example, rf CnumPau 
IS an object m the database ~th two complex-valued fields vall and va12 (or a range vanable bound to 
such an ObJect), then the expression CnumParr vat1 Real wdl mvoke the member function that extracts and 
returns the real pomon of the vall Eeld Slmdarly, the expres- slon CnumPau vail Add(CmnnParr val2) wdl 
add the vall and va12 fields together, producing a result of type Complex Since some users may pmfer 
a mom symmetnc function call syntax, EXCESS will also accept thts expression in the form Add(CnumParr 
vail , CnumPatr val2) In addmon to supportmg standard ADT fun non invocation, we follow the lead of [Ong84, 
Ston86, Ston87b] and support the registranon of operators as an alternative function invocation syn- 
tax For example, to define + as a mEx operator synonym for the Add member funcnon of the Complex dbclass, 
we would enter g Tlus consmtor IS mvoked when a Complex ObJeCt IS created and argu- mentr are speded 
e g when the target bst for a copymcludes an entry of the form n complexValue = (25 0. 10 0) define adt-op 
+ I Infix for Complex Add With thts defimtton, the previous eYample s addmon can be rewnt- ten more naturally 
as CnumPair vail + CnumPan val2 ExisMg EXCESS operators can be overloaded, as dlustrated here In addl- 
non, it IS possible to mtroduce new operators (any legal EXCESS ldennfier or sequence of punctuanon characters 
may be used) For new operators, we require the precedence and assoctanvny of the operator to be specified, 
much as m [Ston87b] Prefix operators can also be defined, and the number of arguments that an operator 
can have IS not restncted However, fimcnons wnh three or more argu- ments cannot be deftned as mEx operators, 
and funcnons that am overloaded wtthm a single dbclass may not be detined as operators In order to ensure 
that ADTs Et mto the EXTRA query language 111 much the same way as budt-m base types do, we resmct the 
form and funcnons of their dbclasses somewhat In pamcular. we reqmre that they be true abstract data 
types - then data pomon must not be pubhc We also mqune funcnon (and thus operator) results to be returned 
by value to ensure that expresstons behave m the expected manner And, whde procedures are permitted to 
have side effects, stde effects are currently forbidden for funcnons so that query results wrll not be 
dependent upon query pm&#38;cate evaluanon order lo ADT funcnons and operators may be used anywhere that 
bunt-in base type functtons and operators may appear m queries, but ADT procedum calls may only appear 
in update query target hsts By default, equality and asstgmnent operators for ADTs am predeftned with 
bit-wise companson/copy semanttcs (as m C++ and E), if dus IS mappropnate for a gtven type, the implementor 
of the type can replace the default deEmnons by explratly ovemdmg them m the E dbclass deEmnon Fmally, 
It IS important that the query optumzer be gwen sufficient mformanon to recogmze the apphcabthty of alternative 
access methods and Join methods when opnmtzmg quenes mvolv- mg ADTs We wdl follow an approach stmtlar 
to that outlmed m [Ston86, Ston87b] for addressing thts Issue, wtth a few differences First, optimizer-specific 
mformanon will not be specified via the EXCESS/EXTRA interface Instead, it wdl be gven m tabular form 
to a unhty responsible for managmg opnmlzer mformatlon The EXCESS query optnmzer, which will be constructed 
using the EXODUS ophmtzer generator [Grae87], will do table lookup to determine method apphcabthty for 
ADTs (so that ADTs can be easdy added dynamically) These tables wdl be slmdar to the access method templates 
of [Ston86], but expression-level opttmtzer mformanon (e g , associanvity, commutattvity, complementary 
funcnon paus, etc ) wdl also be represented m tabular form at thts level Second, ADT funchons and operators 
wdl be treated w- formly for query opnmlzation purposes Tlus IS different than [Ston87b], where operators 
but not functions are optlmlzed tird, we wdl support the addition of both new access methods and new 
JOm methods (wntten by expert users, or database implementors ) to the DBMS through the rule-based opttmtzatron 
techmques detaded m [Grae87] 4 2 EXTRA Schema Types, Functrons, and Procedures Schema types, which were 
described m Sectton 2, are defined using the type system provided by the EXTRA data model In addi- tion, 
we provide facthttes analogous to member funcnons of ADTs for defhung EXCESS functions and procedures 
to operate on schema types However, the fact that they are defined usmg the EXTRA type system and the 
EXCESS query language means that query optmuzanon techmques can be applied to them EXCESS functions and 
procedures am mhented thmugh the type latnce 111 a manner slmllar to mhentance for attnbutes, gvmg EXTRA 
an obJect-oncnted flavor The goal of these faCihtieS 1s to provide Sup-port for denved data, for wntmg 
stored commands (as m the IDMJOO query faclhty rIDM500]), and for data abstracbon of the kmd described 
by Weber [Webe78]  4.2 1. EXCESS Functions As illustrated m an example m Section 2 3, assoclatmg func- 
uons with schema types provides a mechanism for defimng denved attnbutes Such funaons can be defined 
via a smgle EXCESS query of arbitrary complexity, mvolvmg other pomons (possibly dertved) of the Object 
being operated on and/or other named data- base ObJects For example, we could associate a fun&#38;on 
with the Employee type to return the floor that an employee works on as fol- lows define Employee function 
floor returns mt4 ( retrieve (tis deptfloor) )  Such fimctlons can then be used in quenes Just hke regular 
attn- butes, e g retrieve (Employees floor) where Employees name = Smith retrieve (Employees name) where 
Employees floor > 10 EXCESS fimcfions can also have arguments other than their imph- clt this argument 
For example, we could define the followmg func- non and query define Employee function youngerK&#38;(maxAge 
mt4) returns mt4 ( retrieve (count(C fom C in tis luds where C age < maxAge)) retrreve (Employees name, 
Employees youngermds(l0)) Ths example, mvolvmg a function that counts the number of clul- dren under 
a certam age that an employee has, Illustrates several pomts First, It shows how funcuon arguments may 
be defined and used Second, It shows that a funaon can be defined m terms of other functions (Recall 
that age was defined as a Person function m Se&#38;on 2 3) EXCESS functton and procedure arguments are 
passed by reference A functton may return a result of any type, mcludmg a schema type, a set of some 
schema type, etc Updates through functtons are not permitted By way of companson, EXCESS funtions are 
semi- lar to functions m DAPLEX [Shp81] and IRIS [Fish871 They can also be viewed as a sunphfied form 
of POSTGRES procedure attn- butes [Ston87a], m pamcular, they are ltke parametenzed pm- cedure attnbutes 
We do not support true procedure attnbutes, or EXCESS as a data type, because procedure attnbutes are 
not needed for representmg complex ObJect stmctures m EXTRA as they are m POSTGRES Also, smce such attnbutes 
are known only to be of type POSTQUEL m POSTGRBS, and may contam an arbl- trary senes of POSTQUEL quenes, 
they are problemauc with respect to type-safety and knowmg what to expect when wntmg apphcanon pmgrams 
mvolvmg such attnbutes 4.2 2. EXCESS Procedures In addmon to funcnons, we support the defimhon and mvoca- 
uon of EXCESS procedures These differ from funcnons in that they have side effects, they can mvolve a 
sequence of EXCESS commands @stead of a smgle command), and they do not return muIts As an example, suppose 
that we wshed to wnte a pfo- cedure for the Employee schema type to move an employee from one department 
to another We might detine such a procedure as follows define Employee procedure ChangeJob(oldDept, newDept 
Department) ( delete E fom E in oldDept employees where E IS Uus insert mto newDept employees (this) 
replace (this dept = newDept) > Then, If we wanted to move all of the employees in the Database Systems 
department mto the Knowledge Base Systems department, we could use our new procedure to do the Job as 
follows Emp ChangeJob(Emp dept, NewDept) from Emp m Employees, NewDept in Departments where Emp dept 
name = Database Systems and NewDeptname = Knowledge Base Systems As tis example shows, procedures are 
called usmg a syntax suntlar to that of the EXCESS update commands Smce not all procedures may be naturally 
associated with a single EXTRA schema type, and some might argue that the example above is a case m point, 
we also support procedures that am not bound to a pamcular type (We support this option for functions 
as well ) For example, the procedure above could altematlvely be defined as define procedure ChangeJob(emp 
Employee, old, new Department) , with Database Systems employees bemg passed m exphcnly This kmd of procedure 
IS sumlar m flavor to the stored commands of the IDM database machme [IDMSOO] However, it IS much more 
general, as we support the use of a where clause for bmdmg procedure parameters and we mvoke the procedme 
for all possible bmdmgs (instead of Just once, with constant parameters) Aslde from their syntacbc differences, 
the maJor difference between procedures that are associated with an EXTRA schema type and those that 
are not type-specific 1s a matter of mhentance semanhcs In the type-specific case, we may choose to redefine 
the ChangeJob procedure for some subtypes of Employee, such as WorkStudyStudent, but not for others, 
hke NightEmployee Then, If ChangeJob 1s mvoked on elements of a set contammg instances of Employee and 
its subtypes, WorkStudyStudent s ChangeJob will be used for WorkStudyStudent mstances, whde Employee 
s ChangeJob wdl be used for Employee and NIghtEmployee mstances That IS, procedures can be mhented via 
the mhentance mechamsm outhned in Sechon 2 If ChangeJob 1s not associated with a parhcular type, while 
its det%ution may be overloaded, a sm- gle deftmuon (1 e , the defimnon apphcable to the Employee type) 
wdl be statically selected for such a query Tlus is slmllar to the dlstmction between virtual member 
functions and regular member tichons m C++ [Stro86] 43.3. Achieving Data Abstraction We plan to provide 
an authonzanon mechamsm along the lmes of the System R [Cham75] and IDM [IDMSOO] protecuon sys- tems 
Both mdlvldual users and user groups (mcludmg a special all-users group) wti be recogmzed, and protecuon 
umts will be specified via EXCESS quenes Grantable/revocable nghts ~111 mclude the ablhty to read and 
modify specified ObJeCtS or m&#38;vldual attnbutes, the abdrty to invoke specified functions and procedures, 
the ablhty to define new funaons and procedures for specified types. etc This protection system wdl serve 
two purposes First, It wdl act as an authonzatton mechamsm for protectmg database obJe%ts agamst unauthorized 
access and modificafiow, as IS typical Second, It WIB provide a means for achlevmg data abstraaon (I 
e , encapsulanon) for EXTRA schema types For example, one could choose to grant access to a qven schema 
type only via its EXCESS functions and procedures, effectively makmg the schema type an abstract data 
type m its own nght (In fact, IDM stored commands are recommended for regulatmg database amvlty in a 
similar way [IDMKKI] ) Features such as the modules of [Webe78] or the ObJect semantics of an ObJeCt-OneIItCd 
data model can thus be captured via a smgle, more general mechamsm 4.3 Generic Set Operations The fmal 
form of extension that we Intend to support m the EXCESS query language 1s a faclhty for addmg new, user-defined 
set functions to the language At a logical level, such a function can be viewed as takmg a set of elements 
of some type Tl as its argu- ment and renunmg an element of type T2 as its result. Tl can be any type 
that satisfies certain constramts, while T2 must be either a specific type or the same type Tl Aggregate 
funcnons am a classy example here The mm fimcuon takes a set of values of any type. on which a total 
order 1s defined, returmng the smallest element of the set The count function takes a set of values as 
its argument, returmng the number of elements m the set (i e , an mteger result) One could lmagme adding 
new functions of this sort, such as median or std-devlauon for use m statlstlcal apphcatlons Support 
for tlus form of extension has been mcluded m POSTGRES, but m a limited form In parhcular, one could 
mtm- duce a me&#38;an aggregate iimcuon for sets of m~gers, but not one that works for any totally ordered 
type [Ston87b] The EXCESS approach to such extensions IS based on features promded by the E programming 
language [Rzh87] E provides a faclhty for wntmg genenc limcuons, and It supports the speclficatlon of 
constramts on the genenc type (e g , any type that has boolean 1essJhan and equals member funaons) E 
also provides a construct, called an lterator funcnon, for returmng sequences of values of a grven type 
Implementmg a new aggregate. FLU mvolve wntmg a genenc E function with one argument, an lterator that 
yields elements of an appropnately constramed type T, the genenc funcnon should pro- duce a result of 
either the same type T or else some base type This function can then be regstered with EXCESS and used 
with any type that meets 1t.9 constramts 5 COMPARISON WITH OTHER WORK The EXTRA data model and EXCESS 
query language designs represent a synthesis and extension of ideas drawn from a number of other data 
models (both past and present) The data structunng facihues of the EXTRA data model are probably closest 
to those of Gemstone [Mlue86], as Gemstone provides both tuple and array constmctors, and data 1s orgamzed 
mto user-mamtamed extents rather than system-mamtamed type extents EXTRA s ref notion was based on GEM 
reference attnbutes [Zam83], and own ref IS closely related to weak entities m the E-R model [Chen76] 
and composite objects m ORION [Bane871 EXTRA also goes beyond these systems m certam ways, however In 
particular, to our knowledge, EXTRA s mix of own, ref, and own ref attnbutes yields a relatively umque 
mix of (structural) object- and value- onentation Neither Gemstone nor Onon have support for own attnbutes 
(except perhaps m implementmg theu small atomic types) And whde GEM had both own and ref attnbutes, 19 
type system was less nch and sets of references were not permitted The EXCESS query language IS related 
to those of DAPLEX [ShlpSl], GEM [Zam83], &#38; systems [Dada86, Sche861, and POSl GRES [Rowe871 Imphcit 
moms were taken directly from GEM, and ongmated m DAPLEX The FYCFYS treatment of quenes over nested sets 
is sirmlar m flavor to that of M;2 query languages, although the path syntax for handhng deeply nested 
quenes was influenced by DAPLEX and the early STDM paper [Cope84] Our handhng of range vanables was heavily 
mlluenced by that of POSTGRES [Rowe871 In addmon, EXCESS goes beyond its predecessors m several respects 
Our mix of ObJect- and value-onented semantics, again, IS umque among query languages that we have examined 
Also, EXCESS pmvldes a cleaner treat- ment of arrays than we have seen elsewhere The only point for comparison 
here IS POSTQUEL, which only operates on one-dimensIonal arrays of base types Companng EXCESS to POST- 
QUEL m general, we feel that ormttmg procedures as mstance-level field values leads to cleaner and mom 
conslstent query language semantics Fmally, ADT and access method extensibihty m EXTRA/EXCESS were heavily 
mfluenced by the work of Stone- braker [Ong84, Ston86] and the resultmg exten%on faclhties m POSTGRES 
[Ston87b] Our work here differs mostly m mmor respects Because ADTs m our system are wntten E, the system 
s internal language, addmg ADTs IS perhaps sunpler here Another difference IS that we view ADT operators 
as synonyms for function calls rather than somethmg to be handled differently for query optunization 
purposes Lastly, our app-oath to user-defined set functions is more general than the correspondmg POSTGRES 
approach to user-defined aggregates With respect to schema types, our support fur EXCESS fimctlons IS 
snmlar to the functions of DAPLEX [Shlp81] and IRIS [l%h87], and also to the parametenzed procedures 
of POSTGRES [Ston87a] Our approach to user-defined procedures 1s rooted m the stored commands of the 
IDM database machme [IDMSOO], as IS our approach to encapsulation through authonzauon, but EXCESS procedures 
are a much more general mechamsm 6 SUMMARY AND FUTURE WORK In dus paper we have presented the design 
of the EXTRA data model and the EXCESS query language EXTRA and EXCESS represent a synthesis and extension 
of many ideas fmm other data models, mcludmg GEM, &#38; models, DAPLEX, ORION, POSTGRES, Gemstone, and 
0 Our extensions mclude complex object support based on an I d erestmg mix of ObJect- and value- onented 
semantics, a user-fnendly, high-level query lahguage that captures these semanttcs. support for the storage 
and mampulatlon of a database of persistent obJeCts of any type., notJust sets of tuples, and support 
for user-defined types, funcuons, and procedures, both at the abstract data type level and at the conceptual 
schema level An implementation of Uus data model and query language will serve as a demonstration velucle 
for the EXODUS extensible ddta- base system pmJect The implementanon of a parser for EXTRA and EXCESS 
is nearly complete. and a data dictionary has been designed using the EXTRA data model so that d can 
be. exammed using EXCESS quenes Our plans for conbnued work on EXTRA and EXCESS include a number of interesting 
problems and Issues At the logical level, smce we would hkc the system to be useful for CAD-type apphcatlons, 
we need to extend the model with some form of ver- sion support and a facility for check-out and check-m 
of ObJeCtS In ad&#38;non, we need to address the problem of couphng the system with a general-purpose 
pmgrammmg language (probably E) We also need to add support for mtegnty constramts, mcludmg user- specified 
keys, Eferenhal mtegnty, and perhaps more general sup- port as well Finally, we will face type evolution 
issues at two Ic\ - els - for ADTs, and for EXTRA schema types At the next level down, we need to design 
a query algebra upon which to construct a query optumzer usmg the EXODUS optmuzer generator [Grac87], 
and we need to carefully design the tables for hnkmg ADTs to access methods and Join methods Finally. 
there. are a number of mterestmg >roblems to be worked out in deslgmng the physical level of lh~ system, 
mcludmg object mdexmg, support for small versu Jrgc sets and arrays, object clustermg, and the possibihty 
of enhar,,ng performance through explicit rephcmon of shared obJecti ACKNOWLEDGEMENTS Dunng the process 
of designing EXTRA and EXCESS we were fortunate to have the opportumty to &#38;cuss our ideas w1t.h a 
number of knowledgeable Visitors, mcludmg Francols Bancllhor, Carlo Zamolo, Dave Maier, and Won Kun These 
mdivlduals helped us to clanfy our design for the EXTRA type system and the semantics of our query language, 
and they provided us wnh a wealth of mformanon and advice on object-onented database sys- tems While 
these individuals should not be blamed for the results of our efforts, we thmk it 1s fan to say that 
the design would not be nearly as good were It not for their generous help We would also 422 hke to thank 
Joel Rtchardson for helping us clanfy the semanttcs of the EXTRA data model and for drscussrons regardmg 
extensrbthty issues Thrs research wds partially supported by the Defense Advanced Research ProJects Agency 
under contract NOfXJi4-85-K- 0788, by the Nattonal Scrence Foundabon under grant IRI-8657323, and by 
grants from the Mtctoelectromcs and Computer Technology Corporatron and Digital Equipment Corporanon 
REFERENCES <RefA>[Andr87] T Andrews and C Hams, Comhmng Language and Database Advances m an ObJect-Onented 
Development Envuon- merit, Proc 2nd OOPSLA Conf, Orlando, FL, 1987 [Banc86] F Banaliron and S Khoshafian, 
A Calculus for Com- plex ObJects, Proc PODS Conf, Cambndge, MA, March 1986 [Bane871 3 Battertee et al, 
Data Model Issues for ObJect-Onented Apphcattons, ACM Trans Ofice Info Sys S(l), Jan 1987 [Bato871 D 
Batoty, Prmctples of Database Management System Extenstbdity, Da&#38;use Eng , June 1987 [Bloo87] Bloom, 
T, and Zdomk, S , Issues m the Design of ObJect-Onented Database Programming Languages, Proc 2nd OOPSLA 
Co@, Orlando, FL. 1987 [Cam861 M Carey et al, The Archttectum of the EXODUS Extensible DBMS, Proc Int 
l Workshop on Object-Oriented Database Systems, Pactfic Grove, CA, Sept 1986 [Care87] M Carey and D 
DeWrtt, An Overvrew of the EXODUS Project, Dumbuse Eng , June 1987 [Cham75] D Chamberim et al, Vtews, 
Authonzatron, and Lock- mg in a Rclahonai Database System, Proc Nat 1 Computer Conf, Amhelm, CA, 1975 
 [Chen76] P Chen. The Entrty-Relattonsiup Model -Toward a Umfied View of Data, ACM Trans Database Sys 
l(l), March 1976 [Codd79] E Codd, Extendmg the Relattonai Model to Capture More Meamng, ACM Trans Database 
Sys 4(4), IJec 1979 [Cope841 G Copeland and D Marer, Makmg Smalltalk a Data- base System, Proc SIGMOD 
Conf , Boston, MA, 1984 [Dada861 P Dadam et al, A DBMS Prototype to Support Extended NFa Relauons An 
Integrated Vtew of Fiat Tables and Iheramhres, Proc SIGMOD Conf, Washmgton, DC, 1986 [Dttt86] K Drttnch, 
ObJect-Onented Database Systems The Notton and the Issues, Pm Infl Workshop on Object-Ormted Da&#38;me 
Systems, Pacrfic Grove. CA, Sept 1986 Fish871 D F~shman et al, Ins An ObJect-Onented Database Management 
System, ACM Trans Ojtice Info Sys 5(l), Jan 1987 [Grae87] G Gfaefe and D Dewitt, The EXODUS Opumtzer 
Gen- erator, Proc SIGMOD Conf. San Franctsco, CA, May 1987 [Horn871 M Hommk and S Ziomk, A Shared, Segmented 
Memory System for an ObJect-Onented Database, ACM Truns Office Info Sys 5(l), Jan 1987 [IDMSOO] HIM 
500 Software Reference Manual, versron 14, Bntton-Lee Inc. Los Gatos, CA [Kemp871 A Kemper and M Waiirath, 
An Analysis of Geomemc Modelmg m Database Systems, ACM Camp Surveys 19(l), Match 1987 [Khos86] S Kboshatian 
and G Copeland. ObJect Identrty, Proc of the 1st OOPSLA Conf, Portland, OR, Sept 1986 [Khos87] S Khoshafian 
and P Vaidunez, Sharmg, Persistence, and ObJeCt Onentahon A Database Perspeettve, DB-106-87, MCC, Apr 
1987 [Krm87] W Krm et al, Composite ObJect Support in an ObJect- Onented Database System, Proc 2nd OOPSLA 
Conf) Orlando, FL 1987 [IUau85] A Kiausner and N Goodman, Muitnelauons -Seman-trcs and Languages, Proc 
11th VLDB Conf, Stockholm, Sweden, 1985 [Kiug82] A Kiug, Eqmvaience of Reiabonai Algebra and Rela- tlonai 
CaicuIus Query Languages Havmg Aggregate Funchons, J ACM 29(3), July 1982 [Lecl87] C Lecluse et al, 0 
, an ObJect-Onented Data Model, Proc SIGMOD Conf, Ciucago. k, 1988 [Lohm83] G Lohman et al, Remotely-Sensed 
Geophysical Data- bases Exoenence and Imohcauons for Generahzed DBMS, Proc SIGMOD Conf, San Jose,CA, 
1983 [Mate861 D Mater et al, Deveiopment of an ObJect-Onented DBMS, Proc 1st OOPSLA Conf, Portland, OR, 
1986 [Man0861 F Manola and U Dayai, PDM An ObJeCt-OnCnted Data Model, Proc Int l Workshop on Object-Onented 
Database Sys , Astlomar, CA, Sept 1986 [MyloSO] J Mylopouios et al , A Language Facility for Destgmng 
Database-Intenstve Apphcattons, ACM Trans Database Sys 5(2), June 1980 [N1xo87] B Nixon et al, Impiementahon 
of a Compiler for a Semanhc Data Model Expenences with TAXIS, Proc SIGMOD Conf , San Francrsco, CA, 1987 
[Ong84] J Ong et al, Tmpiementahon of Data Abstrachon m the Relattonai Database System INGW, SIGMOD Record 
14(l), March 1984 [Rtch87] J Rtchardson and M Carey, Programmmg Constructs for Database System Impiementahon 
m EXODUS, Proc SIGMOD Conf, San Franctsco, CA, May 1987 [Rowe871 L Rowe and M Stonebraker, The POSTGRES 
Data Model, Proc 13th VWB Conf, Bnghton, Engiand, 1987 [Scha86] C Schaffert et al , An Introductton to 
Tmi.i~s/Owl, Proc 1st 0OPSL.A Co@, Portland, OR, Sept. 1986 [Sche86] H -J Schek and M Scholl, The Relattonai 
Model wnn Relatton-Valued Attnbutes, Informatzon Sys 1 l(2). 1986 [Schw86] P Schwatz et al, Extenstbrhty 
m the Statburst Database System, Proc Infl Workshop on Object-Onented Database Sys , Paafic Grove, CA, 
1986 [SinpSl] D Shtpman, The Functronai Data Model and the Data Language DAPLEX, ACM Truns Database Sys 
6(l), March 198 1 [Ston76] M Stonebraker et al , The Design and Impiementatton of INGRES. ACM Trans Database 
Sys l(3), Sept 1976 [Ston86] M Stonebraker, Incluston of New Types m Relattonai Database Systems, Proc 
2nd Data Eng CoM, Los Angeles, CA, Feb 1986 [Ston87a] M Stonebraker et al, Extending a Database System 
wh Procedures, ACM Truns Database Sys 12(3), Sept 1987 [Ston87b] M Stonebraker et al, Extendabthty in 
POSTGRES, Da&#38;&#38;e Eng , June 1987 [Ston87c] M Stonebraker, uersonai commumcatton, 1987 [Stro86] 
B Stmustrup, The C++ Progrummtng Language, Ad&#38;son-Wesley, Readmg, MA, 1986 [Uiim87] J Uiiman, Database 
Theory -Past and Future, Proc PODS Conf, San Dtego, CA, March 1987 [Webe78] H Weber, A Software Engmeenng 
View of Database Systems, Proc 4th VWB Conf, 1978 [Zam83] C Zamolo, The Database Language GEM, Proc SIG- 
MOD Conf, San Jose, CA, 1983</RefA>   
			
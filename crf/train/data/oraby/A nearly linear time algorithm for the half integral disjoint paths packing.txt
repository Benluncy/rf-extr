
 A Nearly Linear Time Algorithm For The Half Integral Disjoint Paths Packing* Ken-ichi Kawarabayashi 
 § Bruce Reed ¶I Abstract We consider the following problem, which is called the half integral k disjoint 
paths packing. Input: A graph G, k pair of vertices (s1,t1), (s2,t2),..., (sk,tk) in G (which are sometimes 
called terminals). Output : Paths P1,...,Pk in G such that Pi joins si and ti for i =1, 2,...,k, and 
in addition, each vertex is on at most two of these paths. We present an O(n log n) time algorithm for 
this prob­lem for .xed k. This improves a result by Kleinberg [21] who gave an O(n 3) algorithm for this 
problem. (1+e) In fact, we also have algorithms running in O(n) time for any e> 0 for these problems, 
if k is up to o((log log n)2/15) for general graphs, up to o((log n/(log log n))1/4) for planar graphs, 
and up to o((log n/g/(log log n/g))1/4) for graphs on the surface, where g is the Euler genus. Furthermore, 
if k is .xed, then we have linear time algorithms for the planar case and for the bounded genus case. 
We also obtain O(n log n) algorithms for several opti­mization problems related to the bounded unsplittable 
.ow problem when the number of terminal pairs is bounded. These results can all carry over to problems 
involving edge capacities. 1 Introduction In the vertex-(edge-) disjoint paths problem, we are given 
a graph G and a set of k pairs of vertices in G, and we have to decide whether or not G has k disjoint 
vertex-(edge-) disjoint paths connecting given pairs of terminals. This is certainly a central problem 
in algo­rithmic graph theory and combinatorial optimization. See the surveys [13, 39]. It has attracted 
attention in *This work was done as a part of an INRIA-NII collaboration under MOU grant, and partially 
supported by MEXT Grant-in-Aid for Scienti.c Research on Priority Areas New Horizons in Computing National 
Institute of Informatics, 2-1-2, Hitotsubashi, Chiyoda-ku, Tokyo, Japan. Research partly supported by 
Japan Society for the Promo­tion of Science, Grant-in-Aid for Scienti.c Research, by C &#38; C Foundation, 
by Kayamori Foundation and by Inoue Research Award for Young Scientists. §Email address: k keniti@nii.ac.jp 
¶Canada Research Chair in Graph Theory, McGill University, Montreal Canada and Project Mascotte, INRIA, 
Laboratoire I3S, CNRS, Sophia-Antipolis, France IEmail address: breed@cs.mcgill.ca the contexts of transportation 
networks, VLSI layout and virtual circuit routing in high-speed networks or internet. A basic technical 
problem here is to inter­connect certain prescribed channels on the chip such that wires belonging to 
di.erent pins do not touch each other. In this simplest form, the problem mathemat­ically amounts to 
.nding disjoint trees in a graph or disjoint paths in a graph, each connecting a given set of vertices. 
Let us give previous known results on the disjoint paths problem. If k is as a part of the input of the 
problem, then this is one of Karp s original NP-complete problems [18], and it remains NP-complete even 
if G is constrained to be planar (Lynch [26].). The seminal work of Robertson and Seymour says that there 
is a polynomial time algorithm (actually O(n3) algorithm) for the disjoint paths problem when the number 
of terminals, k, is .xed. Actually, this algorithm is one of the spin-o.s of their groundbreaking work 
on Graph Minor project, spanning 23 papers, and giving several deep and profound results and techniques 
in Discrete Mathematics. The time complexity was improved by Reed, who gave an O(n2) algorithm for the 
disjoint paths problem. In this multi-commodity .ow question, the com­modities at the sources s1, through 
sk are di.erent and the demand at each ti is for a speci.c commodity. This is the type of question we 
need to resolve when sending information through the information highway network and so has become increasingly 
of interest to computer scientists (see, for example the work of Chekuri et al. [5, 6, 7, 4] and of Tardos 
and Kleiberg [23, 24, 21, 22]) The unsplittable .ow problem, which generalizes the disjoint paths problem 
is also motivated by these prac­tical issues. In one basic version of this problem, we are given a graph, 
a set of k pairs of vertices in G and a nonnegative demand fi associated with each given pair of terminals. 
We now have to decide whether or not it is possible to choose a single path for each pair of termi­nals 
so that the cumulative demand sent by these paths through any vertex is at most 1. So the vertex disjoint 
paths problem is one of the special cases of this prob­lem. The other special case which is of great 
interest is that all demands are at most 1/2. This is the bounded unsplittable .ow problem, which often 
behaves very dif­ferent from the disjoint paths problem. For example, the natural multi-commodity .ow 
relaxation of the problem provides very strong information for designing approx­imation algorithms when 
all demands are at most 1/2, but the relaxation seems to be very weak when the de­mands are as large 
as 1 (see [15]). Thus by imposing this mild relaxation, one can get fairly dramatic changes on the global 
structure of the routing problem. Indeed there are many such .ow type problems for which the half integral 
version can be at least approximately solved although the integral version is intractable([25, 27]). 
A similar situation holds with respect to the k-disjoint path problem. The proof of correctness of Robertson 
and Seymour s algorithm requires almost all of the graph minors project spanning 22 papers and more than 
500 pages. Its running time has the form O(f(k)n3), where f is an extremely rapidly growing function. 
Actually this function f depends on the size of grid minor in Robertson-Seymour structure theorem. It 
is believed to have very large bounds. (To quote David Johnson [17], for any instance G =(V, E) that 
one could .t into the known universe, one would easily prefer |V |70 to even constant time, if that constant 
had to be one of Robertson and Seymour s. He estimates one constant in an algorithm for testing for a 
.xed minor H to be roughly 2 . 2222.(2.T(|V (H)|)) , where 2 . n denotes a tower 222 ... involving n 
2 s.) We now contrast this with the solution to the following problem: Problem: Half-integral Disjoint 
Paths Packing. Input: A graph G, k pair of vertices (s1,t1), (s2,t2),..., (sk,tk) in G (which are some­times 
called terminals). Output : Paths P1,...,Pk in G such that Pi joins si and ti for i =1, 2,...,k, and 
in addition, each vertex is on at most two of these paths. It is known that the half-integral packing 
of the dis­joint paths problem is still NP-complete, see [27]. But, Kleinberg [21] gave a polynomial 
time algorithm for the half-integral disjoint paths packing when the number of terminals, k is .xed. 
He gave an O(n3) algorithm for this problem. The correctness of his algorithm is much simpler than that 
of Robertson and Seymour s. Further­more, the constants in Kleinberg s algorithm are much smaller, and 
he can actually provide polynomial time algorithms provided k is at most O((log log n)2/15). In this 
paper, we shall give a nearly linear time algorithm for this problem. Our algorithm takes a divide and 
conquer approach to the problem rather than iteratively deleting vertices (as is the case for the Kleinberg 
s algorithm). This allows us to solve the problem much quickly. 1.1 Our Main Result We prove the following 
re­sult. Theorem 1.1. There is an O(n log n) algorithm for the half-integral disjoint paths packing for 
.xed k, that is, the number of terminals is .xed. This improves a result by Kleinberg [21] who gave an 
O(n3) algorithm for this problem. As with Kleinberg s algorithm, our algorithm can also handle k which 
grow slowly with n. Theorem 1.2. There is an algorithm running in O(n(1+e)) time for any e to decide 
the feasibility of the half-integral disjoint paths packing on an arbitrary n­vertex graph with k = o((log 
log n)2/15). The approximation ratio o((log log n)2/15) de­pends on the bound of the tree-width f(k) 
that forces a k × k grid minor. Currently, the best known bound is 202k5 by [40]. But if a given graph 
is planar, then the situation is di.erent. Robertson, Seymour and Thomas [40] proved that any planar 
graph with tree-width at least 6k has a k × k-gird minor. This together with our method implies the following 
much better result. Theorem 1.3. There is an algorithm running in O(n(1+e)) time for any e to decide 
the feasibility of the half-integral disjoint paths packing on an arbitrary n­vertex planar graph with 
k = o((log n/(log log n))1/4). In addition, if k is .xed, then the running time is O(n log n). It is 
likely that our problem for a planar graph is NP-complete too when k is as a part of input, as is the 
case for the disjoint paths problem. We can also give a similar result for graphs on a .xed surface, 
i.e, a bounded genus graph. Let g be the Euler genus of the surface, and suppose G is embedded on this 
surface. Demaine et al. [10] proved that such a graph with tree­width at least 6kg has a k × k-grid minor. 
Using this result, we can obtain the following theorem. Theorem 1.4. There is an algorithm running in 
O(n(1+e)) time for any e to decide the feasibility of our problem for the half-integral disjoint paths 
pack­ing on an arbitrary n-vertex graph that is embed­ded on a .xed surface with genus g and with k = 
o((log (n/g)/(log log (n/g)))1/4). In addition, if k is .xed, then the running time is O(n log n). Reed 
et al. [33] proved that for planar graphs, there is a linear time algorithm for the disjoint paths problem 
for .xed k. As discussed in Reed [32], they also obtained a linear time algorithm to solve this problem 
on graphs embedded in a .xed surface. Combining these techniques and results, we can actually give a 
linear time algorithm for Theorems 1.3 and 1.4. Our proof method for Theorem 1.1 can be used to design 
O(n log n) algorithms for the following problem too. 1. Not only half-integral, but also that all demands 
on vertices have at most 1/2. 2. Not only vertex capacities problem, but also edge capacities as long 
as all demands on edges are at most 1/2. 3. Find the minimum 2 = c = 1 such that there are k collection 
of paths that connect the speci.ed pairs and send a demand of at most c through each vertex.  Since 
our proof can be easily modi.ed for these problems, so we omit proofs. 2 Overview Our algorithm di.erentiates 
between two di.erent kind of inputs which it treats di.erently: either a given graph G has bounded tree-width 
or else it has a large tree­width. In the .rst case, one can apply dynamic pro­gramming [3, 1, 30] to 
a tree-decomposition of bounded tree-width. This case will be discussed in Section 5. In the second case, 
there is a huge grid minor by the result in [35, 40, 12, 30]. Now, we shall use this grid minor as a 
crossbar structure . Let us see how to use the grid minor. We can think of a k × k grid minor as a union 
of k2 disjoint trees Ti,j for k = i, j = 1 such that when we contract each tree Ti,j, then it becomes 
a k×k grid such that the image ti,j of Ti,j (that is, the vertex obtained from Ti,j by contracting it 
into a single point.) is adjacent to ti-1,j ,ti+1,j ,ti,j-1,ti,j+1. Suppose we have a4k × 4k grid minor 
and 2k paths from the terminals to images of the vertices on the top and bottom rows which are pairwise 
non-adjacent and internally disjoint from the image of the grid. Within the grid minor, we can .nd paths 
between the endpoints of the paths using no vertex more than twice and using the endpoint of each path 
only once. Combining these with the paths from the terminals to the grid minor gives the desired half-integral 
disjoint paths packing. Actually it turns out that given a big enough grid minor for which there is no 
small cut separating the terminals from this grid minor, we can still .nd the desired paths. This was 
already proved by Kleinberg [21]. A separation (A, B) is that G = A.B, and there are no edges between 
A-B and B - A. The order of the separation of |A n B|. Theorem 2.1. Suppose M is a 2k2 × 2k2 grid minor. 
Let S be 2k terminals for the half-integral disjoint paths packing. If there is no separation (A, B) 
of order at most 2k - 1 such that A contains all the 2k terminals, and B contains all but at most k2 
images of M, then a desired half-integral disjoint paths packing exists. Indeed, we can actually .nd 
the desired set of paths in linear time. Even if there is a small cutset that separates the 2k terminals 
and this grid minor, we will be able to reduce the problem. We can obtain the following result from Theorem 
2.1. Theorem 2.2. Suppose M is a 2k2 × 2k2 grid minor. Let S be 2k terminals for the half-integral disjoint 
paths packing. If there is a separation (A, B) of order at most 2k - 1 such that A contains all the 2k 
terminals, and B contains all but at most k2 images of M, then the half­integral disjoint paths packing 
is feasible in G if and only if it is feasible in G' that can be obtained from G by deleting B - A and 
replacing the graph A n B by the clique of size |A n B|. Theorem 2.2 gives us a reduction. So once we 
have a huge grid minor, either we can make a smaller graph or we can conclude that the desired half-integral 
disjoint paths packing exists. This was Kleinberg s key idea (his approach is a simplication of Robertson 
and Seymour s algorithm for the integral case). We instead adopt a divide and conquer approach. In order 
to do so, we cannot just apply a reduction to any grid we need to apply a reduction to a grid which is 
attached to a speci.c highly connected part of the graph. We describe the new result we need below, and 
give the details in the full version. Our approach to the half-integral disjoint paths packing is to 
attempt to construct a tree decomposition of bounded tree-width of a graph obtained from G by repeatedly 
applying such reductions. We can then use dynamic programming to solve the half-integral disjoint paths 
packing on it in linear time. Speci.cally, we will have a bound 6B on Ws n Wt for adjacent nodes s and 
t of T and each Wt has at most 8B vertices, where B will be determined later. The only reason we fail 
to construct the tree decomposition is because we .nd a large grid minor joined to S.T by |S.T | paths, 
in which case we can output that the desired half-integral disjoint paths packing does exist. Indeed, 
we can actually .nd the desired set of paths in linear time. This paper is organized as follows. In Section 
3, we discuss brambles, grids, and tree width. In particular, we present a linear time algorithm which 
for certain high order brambles ß .nds a minor of a large grid which is controlled by this bramble (de.nitions 
are given in the next section). This is a theorem of independent interest which has a number of other 
applications. In Section 4, we shall describe our algorithm. In Section 5, we shall deal with the tree-width 
bounded case. In the full version, we give a full proof of Theorem 2.2, which is lengthly. 3 Tree Width, 
Grids, and Brambles 3.1 Tree-width and Bramble A bramble is a set of trees every two of which intersect 
or are joined by an edge (thus a clique model is a bramble whose elements are disjoint). The order of 
a bramble ß, denoted ord(ß), is the minimum size of a transversal of its elements (that is, a set H of 
vertices intersecting the vertex set of each tree of ß). Clearly every clique model of order l is a bramble 
of order l. Also for any set W of vertices, the set ßW of trees of G containing more than half the vertices 
of W is a bramble since any two such trees intersect. We now characterize graphs which have no brambles 
of order l, using tree decompositions. A tree decomposition of a graph G consists of a tree T and a subtree 
Sv of T for each vertex v of G such that if uv is an edge of G then Su and Sv intersect. For each node 
t of the tree, we let Wt be the set of vertices v of G such that t . Sv. We let Ht be the graph obtained 
from the subgraph of G induced by Wt by adding an edge between x and y if there is some s such that x, 
y . Ws n Wt. The width of a tree decomposition is the maximum of |Wt| over the nodes t of T . It is not 
hard to see that for every bramble ß and every tree decomposition there is a node t such that Wt is a 
hitting set for ß. This implies that the tree width of G is at least the maximum order of a bramble. 
Seymour, and Thomas [42] showed that this bound is tight, proving: Theorem: The maximum order of a bramble 
in G is equal to its tree width. 3.2 Grid minor and Wall One of the most impor­tant result concerning 
the tree-width is existence of grid­minor or a wall. Let us recall that an r-wall is a graph which is 
isomorphic to a subdivision of the graph Wr with vertex set V (Wr)= {(i, j) | 1 = i = r, 1 = j = r} in 
which two vertices (i, j) and (i ' ,j ') are adjacent if and only if one of the following possibilities 
holds: (1) i ' = i and j ' .{j - 1,j +1}. (2) j ' = j and i ' = i +(-1)i+j .  We can also de.ne an 
(a × b)-wall in a natural way. It is easy to see that if G has an (a × b)-wall, then it has an (a × b)-grid 
minor, and conversely, if G has an (a × b)-grid minor, then it has an (a/2 × b)-wall. Let us remind the 
reader that the grid (or grid minor) is now common. Let us recall that the (a × b)-grid is the Cartesian 
product of paths Pa × Pb. The main result of Graph Minor V [35] says the following. Theorem 3.1. For 
any r, there exists a constant f(r) such that if G has tree-width at least f(r), then G contains an r-wall 
W . The best known upper bound for f(r) is given in [12, 30, 40]. It is 2205r . The best known lower 
bound is T(r2logr), see [40]. For r =3, 4, this bound is improved by Birmel´e, Bondy and Reed [2]. 3.3 
Grid Minor controlled by the given bram­ble We also need the following key theorem, which will be proved 
in the Appendix. This theorem is close to Theorem 3.1, but we actually show that we can .nd such a grid 
minor which is not separated from T by any small order cutset. To be more precise, we need a de.­nition. 
We say a k × k grid minor M is controlled by a bramble T if T has order at least k and for every set 
X of fewer than k vertices the unique component of G -X containing one element of T is the unique component 
of G - X containing a row (and hence a column) of M. Theorem 3.2. For any k, there is an f(k) such that 
for any D = f(k), there is a linear time algorithm, given any bramble ßX of order f(k) for some vertex 
set X of vertices which either has size at most D or is V , construct a 2k2 × 2k2 grid minor M controlled 
by given bramble ßX of high enough order. Theorem 3.2 will be proved in the full version of this paper. 
We need to make clear how the bramble in Theorem 3.2 will be given. When we perform Theorem 4.1 below, 
we need to .nd many spanning trees (in linear time), and if the output 2 happens, then it follows that 
these trees consist of our bramble. For the proof of Theorem 3.2, we actually need a large set which 
is well-linked (for the de.nition of well-linked, see [31]. Roughly, there is a large set X such that 
for any two vertex sets X1,X2 of order exactly l in X, there are l disjoint paths from X1 to X2 such 
that those paths intersect X only at the endpoints. Then order of this well-linked set is |X| + l.) As 
pointed out in the Appendix, we can .nd it if either ß is ßX for some small set X or for X = V (G). This 
theorem is quite powerful. It is one of the keys for our algorithm for a .xed minor recognition in O(n 
log n) and a separator theorem for H-minor-free graphs in O(n log n). See [20]. 4 Algorithm Reed [29] 
gave an O(n log n) algorithm to construct a tree decomposition of width at most 4k for a graph of tree 
width k. Extending his approach, we attempt to construct a bounded width tree decomposition of a reduction 
of the input graph for which the solution to the half-integral disjoint paths packing is the same as 
for the original input graph. If we fail to do so, we actually .nd the desired paths. To adapt this approach, 
we need the following result. Theorem 4.1. (Reed, [29]) For any .xed integer k, there is a linear time 
algorithm which, given a graph G, either: to split has large order or it has small order. In the second 
case, it is easy to carry out the desired split. In the .rst case, we have a huge grid minor controlled 
by the bramble ßX . Then we perform a reduction by way of this huge grid minor. We are now ready to describe 
our algorithm. As we pointed out, we shall alternate two iterations. Each iteration has two phases as 
we saw two possibilities above. In the very .rst iteration, we choose a set of 5B roots arbitrarily subject 
to the condition that they contain all 2k terminals S . T for the half-integral disjoint paths problem. 
Iteration 1: Splitting Roots For this iteration, the input is a tree decomposition all of whose internal 
nodes have bounded number of vertices (at most 8B) and such that the bound 6B on |Ws nWt| holds for all 
edges st. We assume momentarily that there is only one leaf t such that Wt has size bigger than 8B. D 
whose intersection with the roots is C. If there is, 1. .nds a cutset X of G with |X|= k such that no 
2 component of G - X contains more than vertices, or 3 |G - X| Then we output that either a desired paths 
exist, or a new tree-decomposition that is a re.nement of the 2. determines that for any set X of vertices 
of G with old tree-decomposition, all of whose internal nodes have |X|= k, there is a component of G 
- X which bounded number of vertices (at most 8B), and such that contains more that 1 2 |G - X| vertices. 
the bound 6B on |Ws n Wt| holds for all edges st, and Speci.cally, we construct the decomposition itera­tively. 
In every iteration, we construct a tree decompo­sition all of whose internal nodes have bounded number 
of vertices (at most 8B) and such that the bound 6B on |Ws n Wt| holds for all edges st of T . Actually, 
there are two kind of iterations which we shall alternate. One is concerning splitting roots of each 
leaf, and the other is concerning splitting the vertices of each leaf. Here, by a root Rt of a leaf t 
of the tree T , we mean that Ws n Wt for the edge st of T . In each 2i - 1th iteration, we extend the 
tree decomposition all of whose internal nodes have bounded number of vertices (at most 8B) and such 
that the bound 6B on |Ws n Wt| holds for all edges st, and the bound 5B on |Ws n Wt| holds for all edges 
st, where t is a leaf of T , by splitting root of each leaf. In each 2ith iteration, we extend the tree­decomposition 
by splitting each leaf into, roughly, half such that the bound 6B on |Ws nWt| holds for all edges st 
of T . Then the size of the leaf of the new decom­position is now, roughly, at most half of the leaf 
of the previous one. In the 2i - 1th iteration, the maximum i size of Wt for a leaf t is max((|V | after 
4log n iterations, each such leaf node is of size at  3 4 the bound 5B on |Ws n Wt| holds for all edges 
st, where t is a leaf of T . Here is a description. This iteration has two phases: either (a) we split 
the roots of Wt, or (b) we perform a reduction. If we succeed (a), then we output the result and go to 
the Iteration 2. Otherwise we go to (b). The phase (b) allows us to delete half of Rt, which negates 
our need to split the roots into smaller sized pieces. In the phase (a), we .rst attempt to .nd a set 
X of at most B vertices such that no component of G(Wt)-X contains more than two-thirds of the vertices 
of Rt . Note that there is a partition of Wt into two pieces so that each piece has at most two-thirds 
of the vertice of the root Rt if and only if there is no piece with more than two-thirds of the vertices 
of the root Rt . This is tight, since there may be a partition of Wt into three pieces so that each component 
has exactly one-thirds of the vertice of the root Rt . We can either do so or determine that no such 
set exists in linear time by computing the following: For every partition of the root Rt of the leaf 
Wt into A, D and C, .gure out whether or not in Wt, there is a , 8B). It follows that cutset R of size 
at most B - 1 that separates A from most 8B. we detect a smallest cutset. This can be clearly done in 
In each iteration there are two possibilities. Either time O(|Wt|), since there are at most 6B vertices 
in Rt, the bramble ßX for the set X of vertices we are trying so we have only 36|R| choices, and for 
each choice, we just perform a B disjoint a -b paths algorithm for .xed value k. See [16]. If we succeed 
then we replace t in T with a star with center t * and one leaf for each component of G(Wt)-X. There 
will be an edge of our new tree decomposition between t * and s. Wt* will be Rt . X. This is small enough 
that Ht * has at most 8B vertices. For the leaf l of the star corresponding to some component U of G(Wt) 
- X, Wl will be U . X and so Wl n Wt * will be X . (Rt nU) which has size at most 5B by our choice of 
X. Then the phase (a) is done, so we output the result and go to the Iteration 2. Otherwise, we perform 
the phase (b) below. Now we perform the phase (b), which makes a reduction. If we fail to .nd the desired 
X in the phase (a), then the bramble ßRt has order at least B. We then apply a linear time algorithm 
which .nds a 2k2 × 2k2 grid minor M controlled by this high order bramble ßRt (as we are free to make 
B as large as we like), as described in Theorem 3.2. Let us observe that for any small cutset Z, the 
unique component of G - Z containing most of the grid minor M also contains more than two-thirds of the 
vertices of Rt . Now we can conclude that either there are no separations (A, D) of order at most 2k 
- 1 such that A contains all the vertices in S . T , and D contains all but at most k2 images of the 
grid minor M, or there is such a separation (A, B), in linear time. Together with Theorem 2.1, if there 
are no such separations, this would imply that there is a half­integral disjoint paths packing through 
the grid minor M, with respect to the terminals in T . So, we are done. On the other hand, suppose there 
is such a sepa­ration (A, D). Then, by Theorem 2.2, we can easily replace A n D by the clique of order 
|A n D|, and this operation does not change the feasibility of our problem. We now throw away all the 
vertices in D - A. Since the grid minor M is controlled by the bramble ßRt , so D has more than two-thirds 
of the vertices in Rt. This allows us to throw away more than one-thirds of the vertices of Rt. So, we 
can actually delete half of Rt, which negates our need to .nd X as we used it to split the roots into 
smaller sized pieces. Hence our purpose to make the root two-thirds of the original Rt is already achieved. 
This .nishes the phase (b), and we output it. Then go to the Iteration 2. Iteration 2: Splitting Each 
Leaf After Iteration 1, we come to this iteration. For this iteration, the input is a tree decomposition 
all of whose internal nodes have bounded number of vertices (at most 8B), and such that the bound 6B 
on |Ws n Wt| holds for all edges st, and the bound 5B on |Ws n Wt| holds for all edges st, where t is 
a leaf of T . Again, we assume momentarily that there is only one leaf t such that Wt has size bigger 
than 8B. This comes from the Iteration 1. Then we output either a desired paths exist, or a new tree-decomposition 
that is a re.nement of the old tree-decomposition, all of whose internal nodes have bounded number of 
vertices (at most 8B) and such that the bound 6B on |Ws n Wt| holds for all edges st. Here is a description. 
Again, this iteration has two phases: either (c) we split the vertices of the leaf or (d) we make a reduction. 
If we succeed (c), then we output the result and go to the next Iteration 1. Otherwise we go to (d). 
The phase (d) allows us to throw away half of the vertices of Wt, which negates our need to split the 
leaves into smaller pieces. In the phase (c), we attempt to .nd a set Y with at most B vertices such 
that no component of G(Wt) - Y contains more than two-thirds of the vertices of Wt. We can either do 
so or determine that for every Z with at most B vertices, some component of G(Wy)-Z contains more than 
half the vertices of Wt, in linear time, by the separator theorem, Theorem 4.1. If we .nd such a Y then 
we proceed as in the .rst iteration with Y in the place of X. If this phase is successful, we are done. 
This phase ensures that our condition on the size of Wl for a leaf l holds. In addition, the number of 
roots for the new leaf has at most 6B vertices since after the Iteration 1, the number of roots for each 
leaf is at most 5B vertices. Then the phase (c) is done, so we output it and go to the next Iteration 
1. Otherwise, we perform the phase (d) below. Now we perform (d), which makes a reduction. If we fail, 
we proceed in a similar fashion in the phase (b), but considering ßWt rather than ßRt . Such a bramble 
can be found from the proof of Theorem 4.1, see Reed [29]. Much the same occurs in the phase (d). Since 
the bramble ßWt is huge enough, so we will .nd a 2k2 × 2k2 grid minor controlled by ßRt , which allows 
us to perform a reduction removing half the vertices of Wt. This negates our need to .nd Y , as we used 
it to reduce the size of the Wt. Let us observe that for any small cutset Z, the unique component of 
G - Z containing most of the grid minor M also contains more than half the vertices of W t by our choice 
of ßRt . So if there is a separation (A, D) of order at most 2k - 1 such that A contains all the vertices 
in S . T , and D contains all but at most k2 images of the grid minor M, then as we did in the phase 
(b), we can throw away all the vertices in D - A (and replace A n D by the clique of order |A n D|). 
This allows us to throw away more than half of the vertices in Ht since by our choice of ßWt , D contains 
more than half of the vertices in Wt. Then go to the next Iteration 1 for the new leaves. Of course, 
if there are no such separations, then the desired half-integral disjoint paths packing does exist. 
This completes the description of the Iteration 2. In summary, we can do all the two iterations in linear 
time, and in each phase, either we can make a re.nement of the tree-decomposition or reduce a size of 
our graph. Actually, in the second case, we throw away more than half of the vertices of the leaf. We 
shall do these two iterations for all leaves simultaneously. We can do it, except the only issue we need 
to deal with is that we can do all the reductions at once in linear time. This would allow us to construct 
a desired tree­decomposition in O(n log n) time. We can do this because with a few technical complications 
we can ensure that the only interaction between the cuts is on the internal nodes of the tree decomposition 
and this is a bounded tree width graph so we can .nd all the cuts in polynomial time. The details will 
be discussed in the full version. So, in conclusion, we shall get a tree-decomposition of bounded width. 
Actually the tree width is at most 6B by our construction. Then we shall use Dynamic Programming approach. 
This will be discussed in the .nal section. 5 Algorithms on Tree Decompositions We can apply dynamic 
programming to solve problems on graphs of bounded tree width, in the same way that we apply it to trees(see 
e.g. [1]), provided that we are given a bounded width tree decomposition. Since we also consider the 
case when k is asapart of input, we will use the following recent result by Perkovi´c and Reed [28] Theorem 
5.1. The followings hold: 1. There exists an algorithm that, given a graph G and an integer m, .nds a 
tree-decomposition of G of width w = 202m 5 , if G has no m×m grid minor. 2 + w)O(m +w) The running time 
is n(m2. 2. There exists an algorithm that, given a planar graph G and an integer m, .nds a tree-decomposition 
of G of width w = 6m if G has no m × m grid minor. 2+w) The running time is n(m2 + w)O(m . 3. There exists 
an algorithm that, given a graph G on a .xed surface with Euler genus g and an integer m, .nds a tree-decomposition 
of G of width w = 6m/g, if G has no m × m grid minor. The running time 2 + w)O(m +w) is n(m2. Note that 
the tree-width bound in the second theorem and third theorem follow from [40] and [10], respectively 
. If the tree-width is small, then as suggested by Reed [30], the k disjoint paths problem can be solvable 
even when k is as a part of input. So let us put this theorem here. Theorem 5.2. Suppose G has tree-width 
at most w. Then there is an f(w)O(n)-time algorithm to decide the k disjoint paths problem for some function 
f of w. Actually, we can also construct the f(w)O(n)-time algorithm for our problem by mimicking the 
above algorithm for the disjoint paths problem. Let us state this theorem here. Theorem 5.3. Suppose 
G has tree-width at most w. Then there is an f(w)O(n)-time algorithm to decide the half-integral disjoint 
paths packing. Moreover, we can actually .nd the desired paths in linear time. Note that if we have a 
4k × 4k grid minor and 2k paths from the terminals to images of the vertices on the top and bottom rows 
which are pairwise non-adjacent and internally disjoint from the image of the grid, then the desired 
paths exist, and we can actually detect these paths in linear time. So for both tree-width small case 
and the tree-width large case, our algorithm can detect the desired paths in linear time, if they exist. 
For the tree-width large case, we only need a 2k2 × 2k2 gird minor. Hence when the tree-width is small 
(up to 2k2 = m), then Theorems 1.2, 1.3 and 1.4 hold by putting m =2k2 in Theorem 5.1. Acknowledgment 
This work was partially done when Bruce Reed was visiting Tohoku University in Sendai. He would like 
to thank Professor T. Nishizeki, T. Tokuyama, and their labs for their hospitality. References <RefA>[1] S. 
Arnborg and A. Proskurowski, Linear time algo­rithms for NP-hard problems restricted to partial k­trees, 
Discrete Appl. Math. 23 (1989), 11 24. [2] E. Birmel´e, J.A. Bondy and B. A. Reed, Tree-width of graphs 
with no 3 × 3 grid minor, preprint. [3] H. L. Bodlaender, A linear-time algorithm for .nding tree-decomposition 
of small treewidth, SIAM J. Com­put. 25 (1996), 1305 1317. [4] C. Chekuri, S. Khanna and B. Shepherd, 
Edge-disjoint paths in planar graphs, Proc. 45th Ann. IEEE Symp. Found. Comp. Sci., 2004, pp. 71 80. 
[5] C. Chekuri, S. Khanna and B. Shepherd, Edge-Disjoint Paths in Planar Graphs with Constant Congestion. 
38th ACM Symposium on Theory of Computing (STOC), 2006. [6] C. Chekuri, S. Khanna and B. Shepherd, Multicom­modity 
.ow, well-linked terminals, and routing prob­lems. 37th ACM Symposium on Theory of Computing (STOC), 
2005. [7] C. Chekuri, S. Khanna and B. Shepherd, The All-or-Nothing Multicommodity Flow Problem. 36th 
ACM Symposium on Theory of Computing (STOC), 2004. [8] E. D. Demaine and M. Hajiaghayi, Graphs excluding 
a .xed minor have grids as large as tree-width, with com­binatorial and algorithmic applications through 
bidi­mentionality, in Proceeding of the 16th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA, 
2005), 2005, 682 689. [9] E. D. Demaine, F. Fomin, M. Hajiaghayi, and D. Thilikos, Subexponential parameterized 
algorithms on bounded-genus graphs and H-minor-free graphs, J. ACM 52 (2005), 1 29. [10] E. D. Demaine 
and M. Hajiaghayi, Fast algorithms for hard graph problems: Bidimensionality, minors and local tree-width, 
Proc. 12th Internat. Symp. on Graph Drawing, Lecture Notes in Computer Science 3383, Springer, 2004, 
pp. 517 533. [11] E. D. Demaine, M. Hajiaghayi, and K. Kawarabayashi, Algorithmic graph minor theory: 
Decomposition, ap­proximation and coloring, Proc. 46th Ann. IEEE Symp. Found. Comp. Sci., Pittsburgh, 
PA, 2005, pp. 637 646. [12] R. Diestel, K. Yu. Gorbunov, T. R. Jensen, and C. Thomassen, Highly connected 
sets and the excluded grid theorem, J. Combin. Theory Ser. B 75 (1999), 61 73. [13] A. Frank, Packing 
paths, cuts and circuits a survey, in Paths, Flows and VLSI-Layout B. Korte, L. Lov´asz, H.J. Promel 
and A. Schrijver. Eds. Berlin: Springer-Verlag 1990, 49-100. [14] H. Gabow, Finding paths and cycles 
of superpolylog­arithmic length, STOC 04, 407 416, Chicago, Illinois, USA. [15] N. Garg, V. Varzirani 
and M. Yannakakis, Primal-dual approximation algorithms for integral .ow and multicut in trees with applications 
to matching and set cover, Proc. ICALP 1993, 64 75. [16] T. Ibaraki and H. Nagamichi, A linear time algorithm 
for .nding a sparse k-connected spanning subgraph of a k-connected graph, Algorithmica 7, (1992), 583 
596. [17] D. Johnson, The Many Faces of Polynomial Time, J. Algorithms, 8, (1987), 285 303. [18] R. M. 
Karp, On the computational complexity of combinatorial problems, Networks 5 (1975), 45 48. [19] K. Kawarabayashi 
and B. Mohar, Approximating chro­matic number and list-chromatic number of minor­closed and odd minor-closed 
classes of graphs, Proc. 38th ACM Symposium on Theory of Computing (STOC 06), (2006), 401 416. [20] K. 
Kawarabayashi, Z. Li and B. Reed, Fast recognition and optimization algorithms for minor-closed graph 
families, preprint. [21] J. Kleinberg. Decision algorithms for unsplittable .ow and the half-disjoint 
paths problem. Proc. 30th ACM Symposium on Theory of Computing, 1998. [22] J. Kleinberg. Single-source 
unsplittable .ow. Proc. 37th IEEE Symposium on Foundations of Computer Science, 1996. [23] J. Kleinberg, 
E. Tardos. Disjoint paths in densely embedded graphs. Proc. 36th IEEE Symposium on Foundations of Computer 
Science, 1995. [24] J. Kleinberg, E. Tardos. Approximations for the disjoint paths problem in high-diameter 
planar networks. Proc. 27th ACM Symposium on Theory of Computing, 1995. [25] S. Kolliopoulos and C. Stein, 
Improved approximation algorithm for unspilittable .ow problems, FOCS 1997. [26] J.F. Lynch, The equivalence 
of theorem proving and the interconnection problem, ACM SIGDA, Newsletter, 5, (1975), 31 65. [27] M. 
Middendorf and F. Pfei.er, On the complexity of the disjoint paths problem, Combinatorica, 13 (1993), 
97 107. [28] L. P´erkovi´c and B. Reed, An improved algorithm for .nding tree decompositions of small 
width; Interna­tional Journal on the Foundations of Computing Sci­ence., 11, (2000), 81 85. [29] B. Reed, 
Finding approximate separators and comput­ing tree width quickly; STOC 1992, Victoria B.C., 1992. [30] 
B. Reed, Tree width and tangles: a new connectivity measure and some applications, in Surveys in Com­binatorics, 
1997 (London) , London Math. Soc. Lec­ture Note Ser. 241, Cambridge Univ. Press, Cambridge, 1997, pp. 
87 162. [31] B. Reed, Mangoes and blueberries, Combinatorica 19 (1999), 267 296. [32] B. Reed, Rooted 
Routing in the Plane, Discrete Applied Mathematics 57, 1995, 213 227. [33] B. Reed, N. Robertson, A. 
Schrijver and P. D. Seymour, Finding disjoint trees in planar graphs in linear time. Graph structure 
theory (Seattle, WA, 1991), 295 301, Contemp. Math., 147, Amer. Math. Soc., Providenc, RI, 1993. [34] 
B. Reed, Rooted Routing via Graph Minors, to appear. [35] N. Robertson and P. D. Seymour, Graph minors. 
V. Excluding a planar graph, J. Combin. Theory Ser. B 41 (1986), 92 114. [36] N. Robertson and P. D. 
Seymour, Graph minors. X. Obstructions to tree-decomposition, J. Combin. Theory Ser. B 52 (1991) 153 
190. [37] N. Robertson and P. D. Seymour, Graph minors. XIII. The disjoint paths problem, J. Combin. 
Theory Ser. B 63 (1995), 65 110. [38] N. Robertson and P. D. Seymour, Graph minors. XVI. Excluding a 
non-planar graph, J. Combin. Theory Ser. B 89 (2003), 43 76. [39] N. Robertson and P. D. Seymour, An 
outline of a disjoint paths algorithm, in: Paths, Flows, and VLSI-Layout, B. Korte, L. Lov´asz, H. J. 
Pr¨omel, and A. Schrijver (Eds.), Springer-Verlag, Berlin, 1990, pp. 267 292. [40] N. Robertson, P. D. 
Seymour and R. Thomas, Quickly excluding a planar graph, J. Combin. Theory Ser. B 62 (1994), 323 348. 
[41] A. Shrijver, P. Seymour and P. Winkler, The ring loading problem, Siam J. Discrete Math. 1, (1998), 
147 152. [42] P. Seymour and R. Thomas, Graph searching and a min-max theorem for tree-width, J. Combin. 
Theory Ser. B 58 (1993), 22 33. [43] A. Srinviasan, Improvded approximations for edge­disjoint paths, 
unspittable .ow and related routing problems, FOCS 1997.</RefA>  
			


 Chapter 37 A General Approximation Technique for Constrained Forest Problems* $ Michel X. Goemans t 
David P. Williamson Abstract We present a general approximation technique for a large class of graph 
problems. Our technique mostly applies to problems of covering, at minimum cost, the vertices of a graph 
with trees, cycles or paths satisfying certain requirements. In particular, many basic combinatorial 
optimization problems fit in this framework, including the shortest path, minimum spanning tree, minimum­weight 
perfect matching, traveling salesman and Steiner tree problems. Our technique produces approximation 
algorithms that run in 0(n2 log n) time and come within a factor of 2 of op­timal for most of these problems. 
For instance, we obtain a 2-approximation algorithm for the minimum-weight per­fect matching problem 
under the triangle inequality. Our running time of O(n2 log n) time compares favorably with the best 
strongly polynomial exact algorithms running in 0(n3 ) time for dense graphs. A similar result is obtained 
for the 2-matching problem and its variants, We also derive the first approximation algorithms for many 
NP-complete problems, including the non-fixed point-to-point connection problem, the exact path partitioning 
problem and complex location-design problems. Moreover, for the prize-collecting traveling salesman or 
Steiner tree problems, we obtain 2­approximation algorithms, therefore improving the previ­ ously best-known 
performance guarantees of 2.5 and 3, re­spectively [4]. Introduction Given a graph G = (V, E), a function 
.f : 2 -+ {O, 1} and a non-negative cost function c : E -+ Q+, we ~earch partially supported by DARPA 
contract Nooo14­89-J-1988. t Department of Mathematics, MIT, Cambridge, MA Ozl 39. Additional support 
provided by Air Force cent ract AF0SR-89­0271. t Laboratory for Computer Science, MIT, Cambridge, MA 
02139. Additional support provided by an NSF graduate fellowship. consider the integer program: Min ~ 
C,X, e~E subject to: (1P) Z(6(S)) > f(s) O#scv z. E {0,1} eGE where 6(S) denotes the set of edges having 
exactly one endpoint in S and x(F) = ~eEF z~. The minimal solutions to (1P) are in fact incidence vectors 
of forests. We shall therefore refer to the graph problem associated with (IP) as a constrained forest 
problem. Let (LP) denote the linear programming relaxation of (1P) obtained by relaxing the integrality 
restriction on the variables z. to z. >0. If a heuristic algorithm for an optimization prob­lem delivers 
a solution guaranteed to be within a factor of a of optimal, it is said to have a perfor-­mance guarantee 
of cI. Furthermore, if it runs in polynomial time, it is called an a-approximation al­gorithm. In this 
extended abstract, we present a 2­approximation algorithm for constrained forest prob­lems associated 
with many functions ~. Our algo­rithm runs in 0(min(n2 log n, rnrzcr(m, n))) time. For the sake of the 
analysis, we implicitly construct a feasi­ble solution to the dual linear program to (LP), and we prove 
that the value of our approximate integral primal solution is within a factor of 2 of the value of this 
dual solution. Therefore, for many functions ~, the ratio between the optimal values of (1P) and (LP) 
is upper bounded by 2. This result can be contrasted with the various logarithmic upper bounds on the 
ratio between the optimal values of general integer covering problems and their fractional counterparts 
(Johnson [14], LOV5SZ [19] and Chvzital [5]). The integer program (1P) can indeed be interpreted as a 
very special type of covering problem in which we need to find a minimum-cost set of edges that cover 
all cutsets 6(S) corresponding to sets S with ~(S) = 1. Several graph problems can be formulated as con­strained 
forest problems. This applies to the shortest 307 path problem, the minimum spanning tree problem, the 
Steiner tree problem, the generalized Steiner tree problem and many more complex problems such as the 
non-fixed point-to-point connection problem [18]. A (non-exhaustive) detailed list of problems that fit 
into this framework is presented in Section 2. Moreover, an approximation algorithm for a constrained 
forest prob­lem can be turned into an approximation algorithm for the related problem involving cycles 
or paths, instead of trees, when the cost function satisfies the triangle inequality. This observation 
allows us to consider ad­ditional problems such as the traveling salesman prob­lem, the minimum-weight 
perfect matching problem, Hamiltonian location problems [16] and many other problems. In general, our 
technique applies to many NP-complete problems arising in the design of commu­nication networks, VLSI 
design and vehicle routing. We shall describe some of these problems in Section 2. Our algorithm can 
be characterized in several ways. It is an adaptive greedy algorithm in which, at every iteration, the 
edge with minimum reduced cost is selected. It is adaptive in the sense that the reduced costs are updated 
throughout the execution of the algorithm. It can also be seen as a primal­dual algorithm in which, alternately, 
primal and dual updates are performed. Our approximation algorithm generalizes many classical exact and 
approximate algorithms. When applied to the spanning tree problem, it reduces to Kruskal s greedy algorithm 
[15]. For the st-shortest path problem, our algorithm specializes to the variant of Dijkstra s algorithm 
that uses hi-directional search (Nicholson [20]). The algorithm is therefore exact in these two cases. 
For the Steiner tree problem, we ob­tain the minimum spanning tree heuristic whose many variants have 
been described in the literature (see [28]). In the case of the generalized Steiner tree problem, our 
algorithm simulates Agrawal, Klein and Ravi s 2­approximation algorithm [1]. Their algorithm was in­strumental 
in motivating our work. Our algorithm is, however, conceptually simpler since neither the algo­rithm 
itself nor its analysis require contractions, re­cursive calls to construct the forest or subdivisions 
of edges. In Section 3, we describe our approximation al­gorithm for a large class of constrained forest 
prob­lems and present its analysis. In Section 4, we show that the approximation and proof techniques 
have even wider applicability by obtaining approximation algo­rithms for other problems such as the prize-collecting 
traveling salesman problem. Finally, Section 5 deals with implementation issues. In the next section, 
we present an illustrative but GOEMANS AND WILLIAMSON non-exhaustive list of problems that can be approxi­mated 
using our technique and we summarize our re­sults. 2 Description of problems and results The minimum-weight 
perfect matching prob­lem. The minimum-weight perfect matching prob­lem is the problem of finding a minimum-cost 
set of non-adjacent edges that cover all vertices. This prob­lem can be solved in polynomial time by 
the origi­nal primal-dual algorithm discovered by Edmonds [7]. The fastest strongly polynomial time implementation 
of Edmonds algorithm is due to Gabow, Galil and Spencer [11]. For m = Q(nl+ ) (a > O), the run­ning timel 
is O(mn) while, for m = O(n), it is 0(n2 log n). On the other hand, for integral costs bounded by C, 
the best weakly polynomial algorithm runs in O(m na(m, n) log n log nC) time and is due to Gabow and 
Tarjan [12]: - These algorithms are fairly complicated and, in fact, too time-consuming for large instances 
that arise in practice. This motivated the search for faster approximation algorithms. Reingold and Tar­jan 
[23] have shown that the greedy procedure has 4 0585 for gen­ a tight performance guarantee of ~n eral 
non-negative cost functions. Supowit, Plaisted and Reingold [24] and Plaisted [22] have proposed an 0(min(n2 
log n, m logz n)) time approximation al­gorithm for instances that obey the triangle inequality. Their 
algorithm has a tight performance guarantee of 2 log~(l .5n). As shown by Gabow [10], an exact scaling 
algorithm for the maximum-weight matching problem can be used to obtain an (1 + l/n )-approximation algorithm 
(a ~ O) for the minimum-weight perfect matching problem. Moreover, if the original exact algorithm runs 
in O(f(m, n) log C) time, the result­ing approximation algorithm runs in O(m/X + (1+ a)~(m, n) log n). 
Vaidya [26] obtains a (3+ 2c)­approximation algorithm for minimum-weight perfect matching instances satisfying 
the triangle inequality. His algorithm runs in O(n2 logz 5 n log(l/c)) time. Our algorithm for approximating 
weighted match­ing instances that satisfy the triangle inequality is based upon our approximation algorithm 
for the con­strained forest problem with ~(S) being the parity of [S[, i.e. ~(S) = 1 if [Sl is odd and 
O if ISI is even. The algorithm returns a forest whose components have 1Throughout thk abstract, n denotes 
the number of vertices while m denotes the number of edges. even size. This forest can be transformed 
into a per­fect matching with no increase of cost by duplicating every edge of each tree, shortcutting 
to obtain a col­lectionof cycles of even length and keeping the best matching out of the two matchings 
defined by every cycle. This overall procedure gives an approximation algorithm for weighted perfect 
matching which runs in 0(n2 log n) time and has a performance guarantee of 2 ;. The T-join problem. Given 
an even subset T of vertices, the T-join problem consists of finding a minimum-cost set of edges that 
has odd degree at vertices in T and even degree at vertices not in T. Edmonds and Johnson [9] have shown 
that the T­join problem can be formulated by the linear program (LP) with ~(S) = 1 if IS n TI is odd 
and O otherwise. Moreover, any constrained forest for this function J can easily be transformed into 
a T-join by the removal of edges. This operation does not increase the cost of the solution. Using our 
approximation algorithm for the constrained forest problem, we obtain a (2 ~)­ ,-, approximation algorithm 
for the T-join problem. The generalized Steiner tree problem. The gen­eralized Steiner tree problem is 
the problem of find­ing a minimum-cost forest that connects all vertices in Ti for i = 1, . . . . p. 
Agrawal et al. [1] derived the first (2 ~)-approximation algorithm for this prob­ lem, where k = Ui=l, 
,pTi . When p = 1, the problem reduces to the classical Steiner tree problem. For a long time, the best 
approximation algorithm for this problem had a performance guarantee of (2 fi) (for a survey, see Winter 
[28]) but, very recently, Ze­ likovsky [29] obtained an ~ approximation algorithm. An improved $approxirnation 
algorithm based upon Zelikovsky s ideas was later proposed by Berman and Ramaiyer [3]. The generalized 
Steiner tree problem is also a constrained forest problem. Here, f (S) = 1 if there exists i E {l, ..., 
p}with O#Sn Ti#Ti and O otherwise. In this case, our general approximation algorithm reduces to Agrawal 
et al. s algorithm [1]. Prize-collecting problems. The prize-collecting traveling salesman problem is 
a variation of the classi­cal traveling salesman problem (TSP). In addition to the cost on the edges, 
we have also penalties on the ver­tices and the goal is to find a tour on a subset of the vertices that 
minimizes the sum of the cost of the edges in the tour and the vertices not in the tour. Without loss 
of generality, we consider the version in which a 309 prespecified root vertex has to be in the tour. 
This is a special case of a more general problem introduced by Balas [2], The prize-collecting Steiner 
tree problem is defined analogously. Vertices with zero penalty corre­spond to the optional vertices 
in the original Steiner tree problem while vertices with high penalty corre­spond to the terminals. Bienstock, 
Goemans, Simchi-Levi and Williamson [4] developed the first approximation algorithms for these problems. 
Their performance bounds are 5/2 for the TSP version (assuming the triangle inequality) and 3 for the 
Steiner tree version, These approximation algorithms are not very efficient, however, since they are 
based upon the solution of a linear programming problem. These problems do not fit in the framework of 
problems considered so far. However, the ideas used in approximating the constrained forest problem also 
ap­ ply in this setting and lead to (2 &#38;)-approximation algorithms for both the prize-collecting 
TSP (under the triangle inequality) and the prize-collecting Steiner tree problem. Moreover, these algorithms 
are purely combi­natorial and do not require the solution of a linear pro­gramming problem as in [4]. 
They run in O(n2 log n) time. Point-to-point connection problems. In the point-to-point connection problem, 
we are given a set C= {cl,... ,CP} of sources and a set D = {all, . . .,dP} of destinations in a graph 
G = (V, E) and we need to find a minimum-cost set F of edges such that each source-destination pair is 
connected in F [18]. This problem arises in the context of circuit switching and VLSI design. The fixed 
destination case in which Ci is required to be connected to di is a special case of the generalized Steiner 
tree problem where Ti = {ci, di}. In the non-fixed destination case, each component of the forest F is 
only required to contain the same number of sources and destinations. This problem is NP-complete [18]. 
The non-fixed case is also a constrained forest problem where ~(S) = 1if ISnCl # ISnDI and O otherwise. 
For this problem, we obtain a (2 ~)­approximation algorithm. Partitioning problems. We also consider 
parti­tioning problems where we need to find a minimum­cost collection of vertex-disjoint trees, paths 
or cycles that cover all vertices. Different problems are obtained by imposing requirements on the size 
of each compo­nent. These and related NP-complete problems arise in the design of communication networks, 
vehicle rout­ing and cluster analysis. These problems generalize the minimum-weight perfect matching 
problem (each com­ponent must have size exactly 2), the traveling sales­man problem, the Hamiltonian 
path problem and the minimum spanning tree problem. We focus our attention on the two classes of problems 
where each component must have exactly k vertices or at least k vertices. When each component is required 
to be a tree, we obtain the exact tree partitioning problem and the !ower capacitated tree partitioning 
problem. The lower capacitated cycle partitioning problem is in fact a variant of the 2­matching problem. 
More precisely, the cases k = 2, 3 and 4 correspond to integer, binary and triangle-free binary 2-matchings 
respectively. The lower capacitated cycle partitioning problem is NP-complete for k ~ 5 (Papadimitriou 
[21] for k >6 and Vornberger [27] for k = 5), polynomially solvable for k = 2 or 3 (Edmonds and Johnson 
[8] and Cunningham and Marsh [6]), while its complexity for k = 4 is open. The lower capacitated tree 
partitioning problem is the constrained forest problem corresponding to ~(S) = 1 if O < ISI < k and O 
otherwise. We obtain a (2 ~ )-approximation algorithm for this problem for any k. This algorithm differs 
somewhat from the general algorithm presented in the next section. Furthermore, assuming the triangle 
inequality, this algorithm can be turned into a (2 ~)-approximation algorithm for the lower capacitated 
cycle partitioning problem and a (4 $ )-approximation algorithm for the lower capacitated path partitioning 
problem. Our technique also allows us to approximate the exact tree, cycle and path partitioning problems 
for instances that satisfy the triangle inequality. For this purpose, we consider the constrained forest 
problem with ~(S) = 1 if S +! 0 (mod k) and O otherwise. In this case, each component of a feasible forest 
has a number of vertices which is a multiple of k. By per­forming a similar trick as for the perfect 
matching prob­lem, any approximation algorithm for this constrained forest problem can be turned into 
approximation al­gorithms for these exact partitioning problems. The approximation algorithm developed 
in the next section leads to (4(1 *)(1 ~)) -approximation algorithms for all three exact partitioning 
problems. Location-design and location-routing problems. Many network design or vehicle routing problems 
re­quire two levels of decisions. In the first level, the location of special vertices, such as concentrators 
or switches in the design of communication networks, or depots in the routing of vehicles, need to be 
decided. There is typically a set of possible locations and a fixed cost is associated with each of them. 
Once the locations GOEMANS AND WILLIAMSON of the depots are decided, the second level deals with the 
design or routing per se. These problems are called location-design or location-routing problems [17]. 
Several of these problems can also be approximated using our technique. We illustrate the ideas involved 
on one of the simplest location-routing problems. In this problem [16, 17], we need to select depots 
among a subset D of vertices of a graph G = (V, E) and cover all vertices in V with a set of cycles, 
each containing a selected depot. The goal is to minimize the sum of the fixed costs of opening our depots 
and the sum of the costs of the edges of our cycles. In order to approximate this NP-complete problem, 
we consider a constrained forest problem on an augmented graph G = (V , E ). G = (VU D , E ) is obtained 
from G by adding a new copy u of every vertex u E D and adding edges of the form (u, u ) for all u c 
D. Edge (u, u ) has a cost equal to half the value of the fixed cost of opening a depot at u. The constrained 
forest problem is defined by j(S) = 1 if 0 # S ~ V and O otherwise. Duplicating and shortcutting the 
forest obtained from a variation of our general approximation algorithm can be shown to result in a (2 
 ~)-approximation algorithm for this location-routing problem. The same approach works also if, as in 
the lower constrained cycle partitioning problem, every cycle is required to have at least k vertices. 
In this case, j(S) =lif O#Sc Vor O<lSn Vl< k, and O otherwise.  3 The Algorithm 3. I Description We 
present the main algorithm in Figure 1. The algorithm takes as input an undirected graph G = (V, E), 
edge costs C. >0 for all e E E, and a proper function f : 2 -+ {O, 1}. The algorithm produces aa output 
a set of edges Ft whose incidence vector of edges is feasible for (1P). A function ~ is said to be proper 
if the following properties hold: [Nulll ~(o)= O; [Symmetry] f(S) = f(V S) for all S G V; and [Disjointness] 
If A and B are disjoint, then f(A) = ~(B) = O implies f(A U 1?) = O. These properties hold for a wide 
variety of problems, including the functions given in Section 2 for the T­join problem, the exact tree 
partitioning problem, the non-fixed point-to-point connection problem, and the generalized Steiner tree 
problem. Input: An undirected graph G = (V, E), edge costs C, ~ O, and a proper function ~ Output: A 
forest F 1 F*O 2 Comment: Implicitly sety.s+O fordl SCV 3 C+{{ W}: VEV} 4 For each vc V 5 d(v) -0 6 
While 3C c C:f(C) = I 7 Find edgee= (i)j) with i6CP6c,~GCg Ec , CP # C~ that minimizes ii = ~ ~~\~~$q~ 
8 F+-FU{e} 9 For all v G C, E C do d(v) ~ d(v)+ 6. ~(c,) 10 Comment: Implicitly set yc + gc + 6. f(C) 
for all cc c.. 11 c+ Cu{cpucq) {C,} {c,} 12 F + {e c F : For some connected component N of(V,F {e}), 
f(N) =1} Figure 1: The main algorithm The basic structure of the algorithm involves main­taining a forest 
F of edges, which is initially empty. The edges of F will be candidates for the set of edges to be output. 
The algorithm loops, in every itera­tion selecting an edge (i, j) between two distinct con­nected components 
of F, then merging these two com­ponents by adding (i, j) to F. The loop terminates when ~(C) = O for 
all connected components C of F; since f(V) = O, the loop will finish after at most n 1 iterations. 
The set F of edges that are output consists of only the edges of F needed to meet the connectivity requirements. 
If an edge e can be removed from F such that $(C) = O for all components C of F e, then e is omitted 
from F . The approximation properties of the algorithm will follow from the way we choose the edge each 
iteration. The decision is based on a greedy construction of an implicit dual solution to the dual of 
(L P). This dual is SCv subject to:  (D) S .66(S) YS20 O#scv. In each iteration the algorithm tries 
to increase yc for each active component C (i.e. component C for which j(C) = 1) by a value 6 which is 
as large as possible without violating the packing constraints ~ ys ~ Ce. Finding such a 6 will make 
a packing constraint tight for some edge (i, j) between two distinct components; the algorithm will then 
add (i, j) to F and merge these two components. An alternate view of this process is that the algorithm 
tries to find the edge (i, j) between distinct components with the minimum reduced cost 6. Let Zip be 
the cost of the optimal solution to (LP), and let ZIP be the cost of the optimal solution to (1P). Obviously 
Z~P s Z~P. Let A be the set of terminals in V; that is, A = {v E V : f({v}) = l}. Then we will prove 
the following theorem. Theorem 3.1 The algorithm in Figure 1 produces a set of edges F whose incidence 
vector of edges is feasible for (1P), and such that Hence the algorithm is a (2 fi) approximation algorithm 
for the constrained forest problem for any proper function f J We note that a surprising consequence 
of this the­orem is that very few of the 2n values of a proper func­tion ! need to be known to construct 
an approximate solution to (1P). We only need to know the value of ~ for each v c V, for at most n 1 
new components formed by merging, and for at most 2(n 1) compo­nents formed by removing edges e from 
F. 3.2 Analysis We now need to show that the algorithm has the properties we claim. We will begin by 
showing that the algorithm produces a feasible solution, and then we will turn to proving that the solution 
is within a factor of (2 A) of the optimal solution. We assume throughout the ensuing discussion that 
F k the set of candidate edges selected by the algorithm, F is the forest output by the algorithm, and 
that x is the incidence vector of edges of F). Observation 3.2 If ~(S) = O and j(l?) = O for some BsS,then 
~(S B) =O. Proof: By the symmetry property of ~, f(V S) = f(S) = O. By disjointness, .f((V S) U B) 
= O. By symmetry again, ~(S B) = f((V S) U B) = O. Lemma 3.3 For each connected component N of F , 
f(N) = O. Proof: By the construction of F , N ~ C for some component C of F. Now, let el, . . . . e~ 
be edges of F such that ei c 6(N) (possibly k = O). Let iVt and C Ni be the two components created by 
removing ei from the edges of component C, with N ~ C Ni. Note that since ei @ F , itmust be the case 
that ~(Ni) = 0. Note also that the sets N, N1, N2, . . . . N~ form a partition of C. So then j (C N) 
= ~(U~=l Ni) = O by disjointness. Because ~(C) = O, the observation above implies that ~(N) = O. Theorem 
3.4 The incidence vector x is a feasible solution to (1P). Proof: Suppose not, and assume that x (8(S)) 
= O for some S such that ~(S) = 1. Let NI, ....NP be the components of F . In order for z (6(S)) = O, 
it must be the case that for all i, either S n N, = 0 or SnNi=N~. Thus S= Nil U.. .N,, forsomeil, ik., 
ik. By the lemma above, however, f(Ni ) = O for all i, so ~(S) = O by the disjointness off. This contradicts 
our assumption that j(S) = 1, Therefore, Z must be a feasible solution. Now we will show that the algorithm 
has the approximation properties that we claim. To prove this, we use the dual solution y implicitly 
constructed by the algorithm (see steps 2 and 10 in Figure 1). Note that the algorithm does not need 
to compute y; it is only important for the analysis. The theorem below follows straightforwardly from 
the algorithm s construction of y and F, and from the fact that d(i) = ~~ iE~ ys at the beginning of 
each iteration. Theorem 3.5 The vector y is a feasible solution to (D), Furthermore, c, = ~s,e,J(~) y,s 
for each e E F. Because y is a feasible dual solution and ys > 0 only if f(S) = 1, it follows that ~scv 
yS ~ Z~P. Thus the approximation properties of the algorithm are implied by the following theorem. Theorem 
3.6 ~eEF, c. < (2 A) ~scv YS Proof: We know from Theorem 3.5 that We can rewrite the double sum as ~Scv 
YS . I{e E 6(S) : e E F }1. To prove the theorem, we will show by induction on the main loop that ~ysl{eG6(S): 
eEF }lS(2-~)~ vs. SCv SCv GOEMANS AND WILLIAMSON Certainly the inequality holds before the first iteration 
of the loop, since initially all ys = O. Consider the set C of components at the beginning of some iteration 
of the loop. The left-hand side of the inequality will increase by z 61{e c6(C) : e E F }1 Ccc: f(c)=l 
in this iteration. If we can prove that this increase is bounded above by the increase of the right-hand 
side, namely (2-&#38;. I{c Ec:f(c) == 1}1, then we will be done. The basic intuition behind the proof 
of this result is that the average degree of a vertex in a forest of at most ]Al vertices is at most 
2 fi. To begin, construct a graph H by considering the active and inactive components of this iteration 
as vertices of H, and the edges e~ 6(C) such that C ECand eE F as the edges of H. Remove all isolated 
vertices in H that correspond to inactive components. Notice that H is a forest. We claim that no leaf 
in H corresponds to an inactive vertex. To see this, suppose otherwise, and let v be a leaf, CU its associated 
inactive component, e the edge incident to v, and C the component of F which contains CV. Let N and C 
 N be the two components formed by removing edge e from the edges of component C. Without loss of generality, 
say that Cu < N. The set N Cu is partitioned by some of the components of the current iteration; call 
these cl,. ..,ek. Since vertex v is a leaf, no edge in F connects C. to any Ci. Thus by the construction 
of F , ~(UC, ) = O. Since f(G) = O also, it follows that ~(N) = O. We know ~(C) = O, so by Observation 
3.2 ~(N C) = O as well, and thus by the construction of F , e @ F), which is a contradiction. In the 
graph H, the degree du of vertex v corre­sponding to component C must be I{e E 6(C) : e E F } [. Let 
N. be the set of vertices in II corresponding to active components, so that IN. I = I{C E C : f(C) = 
1} 1. Let N~ be the set of vertices in H that correspond to inactive components. Then UEN. UEN= UN, VGN, 
< 2(IN.1+ IN,I 1) 21N,I = 21N.I 2. This inequality holds since H is a forest with at most INa I + lNi 
] 1 edges, and since each vertex corresponding to an inactive component has degree at least 2. Multiplying 
each side by 6, we obtain 6~VEIVa V < 6(21N.I 2), or since the number of active components is always 
no more than IAl. Hence the theorem is proven. W This completes the proof of Theorem 3.1. Extensions 
 The algorithm described in the previous section can be extended in a number of ways to handle other 
functions $ and even other somewhat different integer programming problems. We outline a few of these 
extensions in this section. 4.1 More general functions ~ We can weaken the conditions for a proper function 
f and obtain a modified (2 ~)-approximation algorithm for the constrained forest problem. It turns out 
that under certain assumptions we can eliminate the sym­ metry condition. In addition, we need one more 
as­sumption in order to make the analysis work: namely, that if sets A and B are disjoint, f(A) = 1, 
f(l?) = O, and f(A Ull) = O, then f(C) = O for all C ~ (Au13). The modified algorithm will be presented 
in the full version of the paper. A number of new problems can be approximated under these weaker conditions. 
For example, we can approximate the lower constrained ,tree, path, and cycle partitioning probIems. For 
these problems f(S) = 1iff O< ISI < k. Note that f isnot symmetric: if IV I = 2k, then for any set S 
of size k +1, f(S) = O, but f (V S) = 1. As a further example, suppose we have a set of customers A 
that must be connected to facilities in set B, and we wish to find the minimum-cost set of edges such 
that each customer is connected to a facility, and at least k customers are in each connected component. 
If we set f(S) = 1 for Ssuch that SnA#0and either ISnAl < kor S fl B = 0, then f obeys the new conditions 
and we can approximate this problem, Note that this problem also does not obey the symmetry condition 
on j, even when k = 1: if V= {al, az, b}, A= {al, a2}, B = {b}, then f({al, b}) = O, but f({az}) = 1. 
 4.2 Non-negative functions j Using techniques from Goemans and Bertsimas [13], we can provide approximation 
algorithms for many functions f : 2 + N. Suppose f satisfies f(0) = 0, f(S) = f(V S)for all S ~ V, and, 
ifAand B are disjoint, then max{f(A), f(B)} ~ f(A U B). Suppose also that f assumes at most p different 
non­zero values, p. = O < pl < ... < pP. Let (1P ) denote the integer program (1P) with the z. c {O, 
1} constraint replaced by the constraint Xe E N. Then we can show that there is an approximation algorithm 
for (1P ) that comes within a factor of 2 ~~=1 ~ of optimal. Notice that at worst the values of f will 
be O, 1,2,3,. ... f~ax = maxs f(S), so that the performance guarantee will be at most ~~~~ ~ = O(log 
fm.x). The performance guarantee will also be no worse than 2p. The algorithm for (1P ) works by performing 
p iterations of our main algorithm. In iteration i, set g(S) = 1 if f(S) ~ pp+l i, 9(S) = O otherwise, 
and call the main algorithm with function g. By the properties off, g will be a proper function for the 
main algorithm. When the algorithm returns F , we make (pP+l.-i Pp g) copies of each edge, and add them 
to the set of edges to be output. The proof that constructing a set of edges in this way comes within 
a factor of 2 ~~=1 * of optimal is essentially the same as the proof used by Goemans and Bertsimas. We 
can potentially reduce the number of calls to our main algorithm by using a scaling technique introduced 
by Agrawal et al. [1] which requires [log ~maX] + 1 iterations and results in a performance guarantee 
of (2110gfmaxj + 2). One application of allowing f~ax > 1 is the generalized Steiner tree problem in 
which each pair of vertices i, j must be connected by Tij edge-disjoint paths. In this case we want f(S) 
= maxie.s,j gs rij (For this particular problem, Agrawal et al. [1] also showed how to reduce this general 
case to the O-1 case), 4.3 The Prize-Collecting Steiner Tree and TSP The main algorithm can be extended 
to (2 &#38;)-approximation algorithms for the prize-collecting Steiner tree and traveling salesman problems. 
The al­gorithm for the Steiner tree version is given in the ap­pendix, The main difference between these 
algorithms and our main algorithm is that the sum of the penalties of vertices in a component is used 
to determine when a component becomes inactive. This information is also used to determine the edges 
in the final solution. De­tails will be provided in the full version of the paper.  5 Implementing the 
Algorithm In this section, we discuss ways to implement the main algorithm efficiently. We briefly describe 
a naive algo­rithm that takes O(rrwm(m, n)) time. We then out­line an 0(n2 log n) algorithm, which is 
asymptotically faster for dense graphs. We neglect the time taken to compute ~ from this discussion, 
since we can compute $(C) in O(n) time for all the problems we have consid­ered in this paper, and since 
we need to perform this computation at most O(n) times. Some of the implementation details are obvious. 
For example, we can maintain the components C as a union-find structure of vertices. Then all merging 
will take at most O(ncr(n, n)) time overall, where a is the inverse Ackermann function [25]. The two 
main algorithmic problems arise from selecting the edge that minimizes 6 at each iteration, and from 
finding the edges in F that belong in F . We consider each of these problems separately. As a naive approach 
to finding the minimum edge, we can simply use O(rncr(m, n)) time each iteration to compute 6 for each 
edge and to check whether or not the edge spans two different components. Other loop operations take 
O(n) time, resulting in a running time of O(rrwm(m, n)) for the main loop, since there are at most n 
 1 iterations. By being somewhat more careful, we can reduce the time taken to find the minimum edge 
in dense graphs to O(n log n). We need three ideas for this reduced time bound. The first idea is to 
introduce a notion of time into the algorithm, We let the time T be O at the beginning of the algorithm, 
and increment it by the reduced cost 6 each time through the main loop. The second idea is that instead 
of computing 6 for an edge every time through the loop, we can maintain a priority queue of edges, where 
the key of an edge is the time T at which its reduced cost is expected to be zero. If we know whether 
the components of an edge s endpoints are active or inactive, and assume that the activity (or inactivity) 
will continue indefinitely, it is easy to compute this time T. Of course the activity of a component 
can change, but this occurs only when it is merged with another component, and only edges incident to 
the component are affected. In this case, we can recompute the key for each incident edge, delete the 
element with the old key, and reinsert it with the new key. The last idea we need for the lower time 
bound is that we only need to maintain a single edge between any two components. If there is more than 
one edge between any two components, one of the edges will always have a value of 6 no greater than that 
of the others; hence the others may be removed from considerate ion altogether. Combining these ideas, 
we get the following algo­rithm for the main loop: first, we calculate the initial key value for each 
edge and insert each edge into the queue (in time O(rn log n)). Each time through the 100P, we find the 
minimum edge (i, j) by extracting the minimum element from the queue. If i E CP and j ~ Cq, we delete 
all edges incident to CP and C~ from the queue. For each component C, different from CP and Cq we update 
the keys of the edges from Cp to Cr and C~ to Cr, select the edge that has the minimum key value, then 
reinsert it into the queue. Since there are at most n components at any point in time, each it­eration 
will have O(n) queue insertions and deletions, yielding a time bound of O(n log n) per iteration, or 
0(n2 log n) for the entire loop. To compute F from F, we iterate through the components C of F. Given 
a component C, we root the tree at some vertex, put each leaf of the tree in a separate list, and compute 
the ~ value for each of the leaves. An edge joining a vertex to its parent is discarded if the ~ value 
for the set of vertices in its subtree is O. Whenever we have computed the f value for all the children 
of some vertex v, we concatenate the lists of all the children of v, add v to the list, and compute f 
of the vertices in the list. We continue this process until we have examined every edge in the tree. 
Acknowledgements The authors would like to thank David Shmoys for extensive comments on a draft of this 
paper. References <RefA>[1] A. Agrawal, P. Klein and R. Ravi, When trees col­lide: An approximation algorithm 
for the generalized Steiner-problem in networks , Proc. 2.3rd A CM Syrnp. on Theory of Computing, 134 
144 (1991). [2] E. Balasj The prize collecting traveling salesman problem , Networks, 19, 621-636 (1989). 
[3] P. Berman and V. Ramaiyer, An approximation algo­rithm for the Steiner tree problem , these proceedings 
(1992). [4] D. Bienstock, M.X. Goemans, D. Simchi-Levi and D.P. Williamson, A note on the prize collecting 
traveling salesman problem , to appear in Math.Prog. (1991). [5] V. Chv&#38;tal, A greedy heuristic for 
the set-covering problem , Math. oper. Res., 4, 233-235 (1979). [6] W.H. Cunningham and A.B. Marsh III, 
A primal algorithm for optimum matching , Math.Prog. .%uZy, 8, 50-72 (1978). [7] J. Edmonds, Matching 
and a polyhedron with O-1 vertices , J. Res, NBS, 69B, 125-130 (1965). [8] J. Edmonds and E.L. Johnson, 
Matching: A well-[27] O. Vornberger, Complexity of path problems in solved class of integer linear programs 
, Proc. Calgary graphs , Ph.D. Thesis, Universit at-GH-Paderborn Intern. Conf. on Combinatorial Structures 
and Their (1979). Applications, R.K. Guy et al., Eds., Gordon and [28] P. Winter, Steiner problem in 
networks: a survey , Breach, 89-92 (1970). Networks, 17, 129-167 (1987). [9] J. Edmonds and E.L. Johnson, 
Matching, Euler tours [29] A. Z. Zelikovsky, An 11/6-approximation algorit hm and the Chinese postman 
, Math. Prog., 5, 88-124 for the Steiner problem on networks , Proceedings of (1973). the 4th Czechoslovak 
Symposium on Combinatorics [10] H.N. Gabmv, A scaling algorithm for weighted (1990). matching on general 
graphs , Proc. 26th ACM Syrnp. on Foundations of Computer Science, 90 100 (1985),  [11] H.N. Gabow, 
Z. Galil and T.H. Spencer, Efficient im­plementation of graph algorithms rising contraction , J. ACM, 
36, 540-572 (1989). [12] H.N. Gabow and R.E. Tarjan, Faster scahng algo­rithms for general graph mat 
thing problems , Tech. Report CU-CS-432-89, University of Colorado, Boul­der (1989). [13] M.X. Goemans 
and D.J. Bcxtsirnas, Survivable net­ works, linear programming relaxations and the parsi­monious property 
, Working paper OR 216-90, MIT (1990). [14] D .S. Johnson, Approximation algorithms for combi­natorial 
problems , J. Cornput. System Sci., 9, 256­298 (1974). [15] J.B. Kruskal, On the shortest spanning subtree 
of a graph and the traveling salesman problem , Proc. AMS, 7, 48-50 (1956). [16] G. Laporte, Y. Nobert 
and P. Pelletier, Hamiltonian location problems , Eur. J. Oper. Res., 12, 82-89 (1983). [17] G. Laporte, 
Location-routing problems , in Vehicle routing: Methods and studies, B.L. Golden and A.A. Assad, Eds., 
Elsevier, 163-197 (1988). [18] C.-L. Li, S.T. McCormick and D. Simchi-Levi, The point-to-point delivery 
and connection problems: complexity and algorithms , to appear in Disc. Appl. Math, (1991). [19] L. 
LOV&#38;Z, On the ratio of optimal integral and fractional covers , Disc. Math., 13, 383-390 (1975). 
[20] T.A. J. Nicholson, Finding the shortest route between two points in a network , Cornput, J., 9, 
275 280 (1966). [21] C.H. Papadimitriou, in: G. Cornu6jols and W. Pulley­blank, A matching problem with 
side constraints , Disc. Math., 29, 135-159 (1980). [22] D.A. Plaisted, Heuristic matching for graphs 
satisfy­ing the triangle inequality , J. of Algorithms, 5, 163­179 (1984). [23] E. M. Reingold and R.E. 
Tarjan, On a greedy heuris­tic for complete matching , SIAM J. Cornput., 10, 676-681 (1981). [24] K. 
Supowit, D. Plaisted and E. Reingold, Heuris­tics for weighted perfect matching , Proc. I.l!th ACM Synap, 
on Theory of Computing, 398-419 (1980). [25] R.E. Tarjan, Efficiency of a good but not linear set union 
algorithm , J. ACM, 22, 215-225 (1975). [26] P.M. Vaidya, personal communication (1991). </RefA>Appendix Input: 
An undirected graph G = (V, E), edge costs C,j ~ O, and a root vertex r Output: A tree F which includes 
vertex r 1 F+% 2 C+{{v}:vev} 3 For each v c V 4 Unmark w 5 d(v) + o 6 W({v}) + o 7 Ifv=r 8 A({v}) -0 
9 else 10 A({v}) + 1 11 While 3C c C : J(C) = 1 12 Find edge e = (i, j) with t c CP E C, j 6 C q E C, 
CP # Cq that minimizes 61 = fi~~~~~$~ 13 Find ~ c C with ~(~) = 1 that minimizes 62 = z ,ec n-, W(c) 
14 6 = min(61, &#38;) 15 For all C c C 16 w(c) + w(c) + 6. A(c) 17 Forallug C,~C 18 d(?J) + d(v)+ 6 A(c, 
) 19 If6=6z 20 A(c) +­ o 21 Mark all unlabeled vertices of ~ with label ~ 22 else 23 F+ FIJ {e} 24 C-cu{c, 
ucj} {c t} -{c ,} 25 W(CF u Cq) = W(cp) + ~(cq) 26 Ifr Gcp Ucq 27 A(CP u c,) = o 28 else 29 J(CP Ucq) 
= 1 30 F is derived from F by removing as many edges as possible but so that the following two properties 
hold: (1) every nnlabelled vertex is connected to r; (2) if vertex v with label C is connected to r, 
then so is every vertex with label C ~ C. Figure 2: The algorithm for the Prize-Collecting Steiner 
Tree Problem 
			

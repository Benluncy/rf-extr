
 Fable: a programming-language solution to IC process automation problems Harold L. Ossher Brian K. 
Reid Stanford University Abstract The Stanford University Center for Integrated Systems is em- barking 
on an ambitious project to formally characterize in-tegrated circuit fabrication processes, and to provide 
a degree of automation of research and prototyping activities in the IC fabrication facility. A crucial 
component of this project is the ability to represent an IC fabrication "recipe" in a repeatable, transportable, 
device-independent lhshion. We have designed the language Fable for this puzpose: it offers some novel 
approaches to abstraction and modularity. We describe the problem, explain why we were forced to devise 
a new language rather than use an existing language, describe important properties of the Fable lan- 
guage, and give several examples. 1. Introduction The manufacture of integrated circuits (IC's) is a 
slow, highly- technical process, characterized by a sense of magic and super- stition. ThLs paper describes 
a computer system, built around a special-purpose programming language, that will provide many needed 
imt)rovements to this fabrication process. The first part of this paper explains the problem, since the 
intended audience of computer scientists may not know much abont the details of IC manufacturing. The 
second p,'irt of this paper explains the com- puter system that is being designed to solve the problem. 
The 'daird part gives some further details of the F'able language that is the heart of that computer 
system.  2. Background: integrated circuit fabrica- tion To make an integrated circuit, one first prepares 
a set of masks that represent the physical configuration of the various layers of the IC. These masks 
arc prepared by the IC designer, not the IC manufacturer. Typically about 7 to 15 overlaid masks are 
used to specify the design of a si.gle IC. To effect the nmnulacture, a waJbr of pure silicon (a disk 
about 4 inches in Permission to copy without fee all or part of tl~is material is granted provided that 
the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and 
the title of the publication and its date appear, and notice is given that copying is by permission of 
the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific 
permission. &#38;#169; 1983ACMO-89791-108-3/83/O06/O137 $00.75 137 diameter and thick enough to be 
sturdy) is subjected to a series of steps that includes etching, baking, dissolving, ion bombard- ments, 
blasting with plasmas, exposure to dopant gases, oxidation, annealing, and so forth, each step controlled 
by one of the prepared masks. The visible surface of a finished wafer is nor- mally a grid of small patterned 
rectangles, each of which is the body of a single integrated circuit: the wafer is sawn into pieces and 
each piece is then mounted in a suitable package with small wires connecting it to the package's pins. 
2.1. Terminology Persons involved in manufacturing IC's refer to that process as fabrication rather than 
as manufacturing. This is especially true in a research fast turnaround environment. The collection of 
machines on which fabrication is perfomzed is called a line. The procedure to execute a particular fabrication 
sequence is called a process, and its written form is called a recipe. A recipe is listed on a run sheet, 
where it is customarily enumerated as a numbered sequence ofsteps. One typically talks of fabricating 
wafers, rather than IC's (or chips); one often refers to the circuits as devices. The fabrication process 
typically takes several weeks when done manually; high-speed autonmted fabrication facilities can manufacture 
finished wafers in a few days of processing. It is not uncommon for a high-volume industrial fabrication 
process to take several months to complete a wafer. Research laboratories are typically concerned with 
fast turnaround fabrication, for which the primary concern is the length of time that it takes to fabricate 
a single wafer. Manufacturing operations are more concerned with throughput than with elapsed time; their 
goal is to make each wafer as cheaply as possible.   2.2. Technologies and processes Different kinds 
of integrated circuits require different processing steps during the fabrication. Sometimes the steps 
are different because the circuits are being realized in different tech- nologies, e.g. NMOS (N-channel 
Metal-Oxide Silicon). CMOS (Complementary Metal-Oxide Silicon), or Bipolar. Sometimes the steps arc different 
because the fineness of detail (the so-called feature size) varies, and therefore the relative geometries 
of width and depth of the various layers are different. Often the steps are different because of constant 
improvements in the fabrication methodology itself. In an industrial enviromnent it can take many weeks 
or months to convert a line fiom one process to another. Only by extensive trial and error, with destructive 
testing at every step. is this conversion achieved. Industrial lines are not ,always stable: the specter 
of "losing the recipe", in which the line stops produc- ing circuils that work despite the best efforts 
of its engineers to keep the line constant, haunts Silicon Valley. Fast turnaround lines in research 
facilities are capable of more rapid conversion front one process to another, since the conversion rarely 
requires physical changes to the machines (but just adjustment of their settings) and the research staff 
typically have memorized the peculiarities of their individual machines. Nevertheless, it can take days 
or weeks to convert a fast tur- naround line from one process to another, especially if that change is 
to accommodate a radically different feature size. 2.3. Specific problems One of the pressing needs 
in a research line for fast tur-naround fabrication is the ability to use the same line for multiple 
purposes, with conversion time as short as possible, Ideally the same line would be time-shared, with 
multiple independent fabrication processes running at the same time. Each machine would be reconfigured 
as needed when it became time to use that machine in a particular process. Stability and repeatability 
is crucial in all fabrication. It is important in volume manufacturing so that prices can be kept down, 
and it is important in research fabrication so that reliable and repeatable experiments can be performed. 
It is extremely difficult to transport a recipe from one line to another: it is not sufficient to put 
the run sheet in an envelope and mail it to the new site. There is a great deal of context that is not 
specified or even implied in the run sheet; the act of convert- ing a line to a particular process consists 
primarily of setting up the implied context for the recipe. It would be of tremendous value to the research 
community, and possibly even of value to the secrecy-oriented manufacturing community, to be able to 
transport recipes easily from one line to another. There is a great need to be able to produce integr~/ted 
circuits on demand, rather than manufacturing great quantities of them at once and storing them in a 
warehouse. To produce a particular circuit on denmnd, one must be able to reconstruct the processing 
environment and processing sequence that succeeded in manufac- turing it in the first place. This amounts 
to the ability to transport a recipe through time as well as through space. 3. The Stanford Computer 
Supported Fast Turnaround Project The Integrated Circuits laboratory at Stanfot~d has a com-prehensive 
fast turnaround fabrication facility [12]; Stanford is one of a very few universities tO be so equipped. 
This laboratory facility is used for research in fabrication technology, for training engineers in fabrication 
techniques, and for fast turnaround production of circuits designed by systems designers in associated 
laboratories. Its close physical proximity to the Computer Systems Laboratory (next dooO, and the increasing 
interdependence of our research efforts, have made it attractive for computer systems designers to involve 
themselves in solving problems in the IC lab, while the IC lab assists the systems designers in production 
and testing of special circuits. We are therefore building an elaborate computer support sys- tem for 
the IC lab. We intend it to be a showpiece of various kinds of software technology, including local networking, 
graphics, distributed computation, and man/machine interfaces. This computer support will include the 
following major sub- projects: Automatic, semi-automatic, or manual control of the fabrication facility, 
as needed.  Integration of process.simulation with process control. One of the major research interests 
of the IC lab is the develop- ment of computer programs that simulate various aspects of the fabrication 
process, or of fabricated devices. "Ihere is currently no coupling between actual fabrication and the 
simulation of it.  Development of a capability for transporting recipes in space and time.  Computerized 
management of the laboratory to permit multiple, simultaneous, independent uses.  Database and data 
processing support. An idea central to many of the above areas is the represen- tation of recipes: that 
is, of the set of instructions that the com- puter follows to achieve automation or simulation. By developing 
a notation or language in which to describe fabrication processes, we can then represent the fabrication 
controllc~ and simulators as virtual machines that execute programs written in that lan- guage. Sections 
4 onwards are devoted to a detailed discussion of the requirements and design of the recipe language. 
With our recipe language in .hand, we will make the overall structure of the laboratory software be quite 
like the overall struc- ture of a traditional time-sharing system operating on a microcoded machine. 
There will be several active processes (in the computer science sense of the word; let's borrow from 
Ada [6] and call them tasks) competing for laboratory resources; each of those tasks will be executing 
a program coded in this represen- tation language. A master scheduler, algorithmically similar to the 
job scheduler on a time-sharing system, will assign tasks to processing machines. "Each processing machine 
can then be automatically controlled as needed, or perhaps manually con-trolled according to instructions 
displayed on a video screen nearby. Traditional algorithms for resource allocation and priority scheduling 
will work perfectly: any piece of fabrication machinery that is for some reason not available can be 
removed from the scheduler's free list, and all tasks will continue as long as there exists an available 
piece of equipment capable of executing the requisite abstract operations. To ensure that a recipe can 
indeed be ported through time or space, we must ensure that its representation genuinely contains all'of 
the necessary, context. By systematically resetting all fabrica- tion machines to an illegal state at 
the end of each task step (much to the horror of the IC lab engineers, we suspect), we can guarantee 
that if the automatically controlled fabrication works at all, it is working because the digital representation 
of the recipe contains the necessary information and not because of global con- text in the fabrication 
line. We put that trick in the same category as the designers of the Vax architecture specifying that 
the zero page would never be mapped, which guarantees that all references to null pointers are immediately 
fatal. 4. Requirements of the recipe language q~e nature of the problem and the proposed system described 
above dictate the following fundamental requirements of the lan- guage for specifying recipes: Completeness. 
It must be possible to express any conceiv- able recipe in the language. This should hold true even with 
dramatic and unforeseen changes in technology.  Readability. A recipe must be clear and easy to follow, 
yet complete, rigorous and unambiguous. This is particularly important as the readers of recipes will 
be l~brication en- gineers, not computer ~ientists.  Safeo,. l'~abrication processes make use of deadly 
gasses, high tcmpcratures and delicate equipment. It must not be possible for an error in a recipe to 
lead to disaster.  Portability. It is particularly important that a recipe developed at one site can 
be used at another, similar site. Portability through time is equally important: it must be possible 
for a recipe developed now to be used years in the future, despite changes in technology.  Dynamic modifiability. 
A fabrication proccss can run for weeks or even months. It must be possible to change details of a recipe 
while that recipe is being used. It must also be  138 possible for qualified engineers to make ad 
hoc changes to a running process in order compensate for errors or un- expected occurrences. Suitabilityforprocessing 
by otherprograms. The system as a whole is intended to contain expert systems and other programs that 
assist engineers in designing recipes and in compensating for errors. These programs must be able to 
treat recipes as data in a convehient manner. In order to meet the above fundamental requirements, the 
recipe language must necessarily have certain features: Appropriate Domain of Discourse The objects 
dealt with in a recipe are physical objects; the processes specified in a recipe are physical processes. 
A means is needed to specify such objects and processes conveniently.  Abstraction mechanisms. The most 
effective way of ensur- ing that a language is clear and readable, apart from good syntax, is to provide 
appropriate abstraction mechanisms; the most effective way of ensu ring portability is by means of levels 
of abstraction. The abstraction mechanisms need to be tailored to the domain of physical objects and 
processes.  Verification and run-time checking. Recipes, like programs, are likely to contain errors. 
The most effective way of en- suring that erroneous recipes do not have devastating effects is through 
rigorous specification of the conditions under which each operation can be performed safely. Checking 
that an operation is never performed unless these conditions are satisfied can be done either by formal 
verification or by run-time checking.  tlandling of equipment malfunctions. Fabrication equi-pment, 
like all physical equipment, is likely to malfunction periodically in the midst of a process. A complete 
recipe language must be able to specify how equipment malfunc- tions can be detected, and what recovery 
action should be taken.  Source-level interpretation. The property of dynamic modifiability and the 
requirement that process specifica- tions be capable of manipulation by other programs, sug- gest a source-level 
interpreter.  Suitable run-time support. The nature ofthe system and the requirement of dynamic modifiability 
place many special requirements on the run-time support.  Each of these features is now discussed further, 
in order to detelxnine more detailed requirements for the recipe language. Then existing languages are 
examined in the light of these re-quirements, and our proposed language, Fable, is introduced. 4.1. Appropriate 
domain of discourse The recipe language must be able to name and describe the entities that occur in 
the fabrication environment. "Itais environ- ment is, however, likely to change quite drmnatically with 
ad- vances in technology. If the language is not to become obsolete, its mechanisms must not be tied 
to current technology and fabrication practice; they must be general mechanisms for specifying pllysical 
objects and processes. It is convenient to divide the physical objects dealt with in fabrication processes 
into two categories: equipment and material. :Equipment is the machinery that makes up the fabrication 
facility, such as furnacos; material is the ingredients that go into the finished product, such as silicon 
wafers, and the finished product itself. "lqae distinction between equipment and material is more one 
of usage than of nature: in a fabrication process that produces some piece of equipment, the product 
is considered to be material, as distinct fiom the equipment making up the fabrication line. "lt~e recipe 
language must thus be able to name and to specify equipment and material conveniently, and to dis- tinguish 
between them. An important concept in the domain of physical objects is that of location.A fabrication 
facility will have various locations where objects can be placed: a recipe must be able to name them, 
to specify transferral of objects between them, and to interrogate the location of an object. The primary 
function of the recipe language is to specify physical processes. These consist of sequences of physical 
opera- tions, so two mechanisms are needed: A means of specifying fundamental physical operations such 
as turning a knob or pressing a button.  Facilities for constructing more complex operations or full 
recipes out of such operations. Frequently the recipes will have to be able to specify many operations 
being performed concurrently, with precise timing and communication.  There are also many special requirements 
of the run-time sys- tem. Though related to the recipe language, they are more system issues than language 
ones, and are considered separately in sec- tion 4.6. 4,2. Abstraction mechanisms In Computer Science 
usage, abstraction is a technique for separating the specification of an entity from its implementation. 
It allows the entity to be treated as a black box; users of the entity are interested only in its functionality, 
and all details of how this functionality is achieved are hidden fiom them. Maximal advantage is obtained 
from this technique by using it at many levels: the implementation of a large and complex black box is 
specified in terms of the functionality of smaller, less complex black boxes. The complete description 
of an entity there- fore consists of an hierarchy of sub-descriptions. One of the most attractive features 
of a good abstraction mechanism is that the hierarchical structure of the description mirrors the hierarchical 
structure of the entity itself. An abstraction mechanism suited to a particular problem domain is a mechanism 
that allows the functionality and im-plementation of entities in that domain to be specified separately 
and conveniently, and that is structured in such a way that the structure of a complex description mirrors 
the structure of the entity described. The structured programming revolution was primai-ily due to the 
identification of a small but sufficient set of procedural and data abstractions, and their incorporation 
into programming languages. In addition to these, the recipe language requires good abstraction mechanisms 
for equipment, material and physical processes. Consider equipment first. A piece of equipment can be 
characterized by certain attributes. These are listed below, il- lustrated with reference to a common 
kitchen stove. Components. Subsidiary pieces of equipment that fo~n part of it. Since a component of 
a piece of equipment is itself a piece of equipment, each piece of equipment is an hierar- chy. For example, 
a stove might consist of an oven and four cookers. Fach cooker, in turn, consists of the actual burner 
and of a control knob.  Locations. Places where other physical objects can be placed. For example, the 
surface of a burner on which a pot can be placed is a location.  State values. Values that characterize 
the state of the machine. For example, the state of a burner can be charac- terized by its mean surfime 
temperature, the state of a con- trol knob by its setting.  Operations. The operations that can be performed 
with its aid, and their effects on state values. For example, the operation that can be performed on 
a control knob is to turn it to the desired setting; the effect of this operation is to alter the knob's 
setting.  Functional relationships between components. How opera- 139 tions performed on one component 
affect other com-ponents. The operation of turning a control knob, described above, obviously affects 
the knob's setting. But, if the stove is functioning correcdy, it also affects the temperature of the 
associated burner. Fxluipment has other physical properties, of course, such as size, mass, color, shape 
and spatial arrangement of components. These are unimportant from the point of view of a recipe, however, 
which is concerned with behavior rather than appearance, but they can be included in the state if a complete 
characterization is desired. Different pieces of equipment often contain some similar or even identical 
components. For example, two different kinds of stoves may both contain burners that are functionally 
identical, even if slightly different in appearance. And a great many pieces of equipment will contain 
such components as knobs, switches and gauges; these will, in general, perform vastly different func- 
tions, but they will be similar in nature. This illustration reveals that we commonly think of equipment 
as falling into classes, and that our understanding of the structure of a complex piece of equipment 
is aided by identifying the classes to which its com- ponents belong. Members of a class are not necessarily 
identical, but they do have some common characteristics. The class approach has an important corollary: 
two members of a class may be used in vastly different contexts. For example, one knob may control the 
temperature of a burner on a stove, another may control the volume of a stereo. It is therefore vital 
to be able to specify the characteristics of a class in isolation, without any reference to the context 
in which its members will be used, This implies that the functional relationships between com-ponents 
(the last characteristic above) cannot be specified within the descriptions of the details of the components. 
The above considerations suggest the following requirements for an abstraction mechanism for equipment: 
 It must provide a means of specifying all the characteristics of equipment listed above.  It must allow 
a complex piece of equipment to be described in terms of its components, each component being treated 
as a black box. The entire description will thus be an hierar- chy, mirroring the hierarchy of components. 
 It must allow the specification of classes of equipment, and the identification of a specific piece 
of equipment as a mem- ber of a class. A mechanism must be provided for specify- ing differences between 
members of the same class.  It must allow components to be described in isolation, yet must document 
their interaction.  Material has similar characteristics to equipment 1, though it will generally have 
no operations and no functional relationships between components. A similar abstraction mechanism is 
there- fore appropriate for material; in fact the same mechanism will suffice, provided equipment and 
material can be distinguished. The fundamental abstraction in the case of fabrication processes themselves 
is the operation. It is important to be able to specify an abstract operation, and then implement it 
in terms of simpler operations. This is the standard procedural abstraction familiar to all modern programmers. 
Four primary levels of operations stand out, listed here bottom-up: The concrete level "llae operations 
at this level are those that can be performed directly on the equipment, such as turn, ing a knob or 
pushing a button. They are fundamental, in that they cannot (or need not) be specified in terms of simpler 
operations. The equipment level The operations at this level are abstract operations supported by the 
fabrication equipment, such as heating or baking. "llaey are ultimately implemented in terms of concrete 
operations, though the specification may have many sub-levels involving abstract operations at the equipment 
level.  The material level, The operations at this level are abstract operations whose object is to 
achieve certain effects on the material being processed, such as putting a coating of oxide of a certain 
thickness on a wafer. They are ultimately specified in terms of operations at the equipment level, though 
the specification may have many sub-levels involv- ing abstract operations at the material level.  The 
process level The operations at this, highest level are entire fabrication processes. They are described 
in terms of abstract operations at the material level.  These levels are not arbitrarily chosen. They 
reflect the innate structure of a fabrication process, and hence contribute to clarity. They also have 
an effect on portability. If two fabrication facilities have identical specifications at any level, then 
all higher level specifications can be transferred between them without difficulty. As portability is 
particularly important, let us consider some common cases. Similar facilities might have identical equipment 
levels, even if the actual equipment differs slightly. If standar- dization is practiced, different facilities 
intended for the same purpose should certainly have identical material levels, even if the physical 
equipment differs greatly. And even if standardization is not practiced, transferring a recipe from facility 
A to facility B can be done in whichever of the following ways is most convenient: Adding a level in 
which A's abstract material operations are implemented in terms of B's abstract material operations. 
This method is best if the material levels of A and B are similar.  Adding a level in which A's abstract 
equipment operations are implemented in terms of B's abstract equipment opera- tions. This method is 
best if the equipment levels of A and B are similar.  Rewriting the implementation of A's material level, 
in order to implement A's abstract material operations in terms of B's abstract equipment operations. 
This method involves the most work, but is best if the descriptions of the two facilities differ widely. 
 Rewriting of the equipment .level as a whole is another possible solution, but is likely to be much 
more complex and time-consuming than any of the above. Transferring a recipe divided into the above levels 
remains a non-trivial task, certainly, but is considerably simpler than rewrit- ing the entire recipe 
from scratch. Note that it is greatly enhanced by standardization and by careful choice of the abstract 
opera- tions at each level. The above considerations suggest the following requirements for an abstraction 
mechanism for fabrication processes: It must allow the specification of operations at the four levels 
listed above.  It must allow sub-levels within each level, so that the im- plementation of a complex 
operation can be structured.   4.3. Verification and run-time checking Errors in a recipe are much 
more serious than ordinary pro- gramming errors, because their physical effects can be devastat- ing: 
fabrication of integrated circuits involves high temperatures and deadly gases. So before a physical 
operation is performed, and while it is being.performed, it is essential to check that it can be performed 
safely. 1The terms equipment and material were defined at the beginning of The recipe language must 
provide a mechanism for specifying section 4.1. 140 rigorously the conditions under which eachand every 
operation can be performed safely. "lhe actual checking can be done by formal verification, which determines 
in advance that no opera- tion is ever performed when unsafe, or the ran-time system can check conditions 
immediately before executing each operation. Formal verification of large and complex systems is not 
yet a viable technique, so run-time checking will be relied upon for the present. 4.4. Handling of equipment 
malfunctions Traditional applications programs are written assuming work- ing hardware. Even systems 
programs, such as operating systems, often fail if the hardware malfunctions. This is acceptable in most 
environments, because computers are very reliable, and computa- tions can usually be begun again if something 
goes wrong. nieian with whom it is interacting. In order to achieve this type interaction, it must include 
a sophisticated user inter- face. It must interact with the fabrication equipment, sensing its state 
in order to detect equipment malfunctions, and, ul- timately, controlling it directly.  It must perform 
the run-time checking specified in a recipe.  It must interact with the process engineers responsible 
for the design of recipes, providing them with good tools for examining and modifying recipes at run-time. 
It must also allow them to override the recipe under special cir-cumstances, and to assume control of 
the fabrication process themselves.  "Ihe situation in a fabrication environment is different. The fabrication 
equipment is much more likely to malfunction, and a physical process cannot usually be begun over again, 
because per- manent changes may have been made to some of the material involved. Furthermore, a malfunctioning 
piece of equipment.can be dangerous. The recipe language must contain a mechanism for specifying how 
malfunctions can be detected, and what recovery action should be taken. The run-time system must continually 
check for malfunctions, and initiate the appropriate recovery action when necessary. 4.5. Sou rce-level 
inte rp retation An important requirement of the recipe language is that recipes be modifiable at rtm 
time. The most common and impor- tant type of modification is changing the details of operations. This 
type of modification is much easier to achieve in an inter- preted system than a compiled one, as it 
does not require time- consuming compilation and linking. A related issue is that of maintaining consistency 
of all representations era recipe in the long temp. In a compiled system. a recipe must be maintained 
in three forms: source, compiled and linked. Maintaining the consistency of these representations is 
a complex and error-prone task. qqais task is much simplified in the ease of an interpreted system, where 
only one representation need be maintained. The requirement that a recipe be suitable for manipulation 
by other programs, such as expert systems, also argues for source- level interpretation. Such programs 
do not want to deal either with strings of characters or strings of bits; they need as clear and concise 
a representation of the semantics of a recipe as possible. This is provided by an internal form close 
to the source: precisely the form used by an interpreter. A final reason for preferring an interpreted 
system is that it can more easily provide the special ru n-time support described in the next section. 
The sole disadvantage of interpreted languages is that their programs run less efficiently than compiled 
ones. In the case of recipes this is immaterial, as the speed of execution of a recipe is constrained 
by the physical processes involved, which lake ex- tremely long times in computer terms. All Uaings considered, 
therefore, source-level interpretation is clearly indicated. 4.6. Suitable run-time support The run-time 
system supporting the recipe language has many special requirements: It must interact with technicians 
extremely well. One ex-ample of the requirements in this regard is that it must tailor the detail of 
its displays to the experience of the tech- 5. Existing languages Now that the requirements of the recipe 
language have been identified, it is important to consider whether any existing fan-, guage fulfills 
them. ]here are four categories of languages that need to be considered: Algorithmic Languages, such 
as ADA, CLU or Pascal [6, 11, 9],  Simulation Languages, such as Simula or GPSS [3],  Numerical Control 
Languages, such as APT [14, 7],  Existing Recipe languages. We shall consider each of these in turn. 
5.1. Algorithmic languages Appropriate domain of discourse. Algorithmic languages do not contain explicit 
mechanisms for naming and specifying physi- cal objects or physical operations, as they deal exclusively 
with data objects. However, this problem can be circumvented by the notion of modeling, in which the 
physical objects are modeled by data objects, and operations on the physical objects are modeled by operations 
on these data objects. The question arises of whether this leads to sufficiently clear and readable specifications. 
Structured programming has taught us that clarity is best ach- ieved by ensuring that the specification 
of an entity has, as far a as possible, the same structure as the entity itself. The ability to create 
arbitrarily structured data objects in modern languages al- lows this to be achieved. There are two problems, 
however. The first is that certain notions in the domain of physical objects have no direct analogy in 
the domain of data objects. An example is the notion 0fa location, mentioned in section 4.:1. The closest 
analogy is a variable, and it is certainly possible to model a location by means of a variable, and placing 
an object at the location by assignment. But this is rather confusing, especially in a context where 
ordinary data variables are also used. What is more, one might often need to remember the location at 
which an object is placed. In computer languages, this is done by means of pointers or addresses, which 
will be excessively confusing. Modeling a location by means of a variable is simply not as clear as having 
a means of specifying a location directly. "lhe second problem is to do with the specification of a large 
and complex collection of equipment. Such equipment is static, and the specification nmst be statically 
encoded in the recipe, not read in as data. Algorithmic languages are notoriously poor at allowing the 
specification of complex, structured constants. Algorithmic languages also do not usually have constructs 
for ~ecifying time and timing of operations conveniently, llowever, those that allow parallelism often 
have constructs that can be used for this purpose. Abstraction mechanisms. Modern algorithmic languages 
do provide general abstraction mechanisms, that can be used in any 141 domain. However, they are designed 
specifically for the domain of data and procedural abstraction, and arc not necessarily as con- venient 
in other domains. This needs to be examined by observ- ing to what extent they satisfy the requirements 
stated for equi- pment and fabrication process abstraction mechanisms in section 4.2. Data abstraction 
mechanisms provided by modern program- ming languages characterize-the efitities with which they deal 
(data types) in terms of attributes. Frequently, only operations are specified, as in CLU [11]. Sometimes 
other attributes, such as variables, constants, exceptions and associated types are also al- lowed, as 
in ADA [6]. The most common situation is to hide all components (i.e. subsidiary types) in the implementatio 
n , as in CLU. ADA is an example of a language that allows components to be made visible outside an abstraction, 
by allowing the nesting of package specifications. No programming language, of course, deals with the 
concept of a location, as tiffs is applicable only to the physical world. Thus, existing abstraction 
mechanisms do not allow all the characteristics of equipment listed in section 4.2 to be speci fled conveniently. 
But the chief and vital difference between abstractions in the domain of equipment and the domain of 
data types is that of interaction of components. Even in ADA, where components are visible, execution 
of an operation performed on one can never have a direct effect on any other, because they are independent 
and are defined independently, and the definition of one com- ponent is unable even to reference any 
other component. The only way in which one component can be made to effect another is via an operation 
or variable at a higher level at which both are defined. To illustrate this, consider the operation of 
turning the control knob of a cooker. The only way to specify that an effect of this operation is to 
change the temperature of the associated burner is to move the operation from the knob to the cooker, 
perhaps call- ing it set-temperature. One can then spccify that performing the set-temperature operation 
of the cooker affects the temperature of the cooker's burner, as well as the setting of the cooker's 
knob. qlais dissociates the operation from the knob entirely, however, so that it is nowhere specified 
that the way to set the temperature of the cooker is to turn its knob. So one needs to specify that the 
implementation of the abstract operation set-temperature is ach- ieved by turning the knob. The unfortunate 
situation now arises that the operations set-temperature and turn knob, though ap- parently identical, 
actually have different effects! This anomaly is due to the fact that the introduction of set-temperature 
is artificial; it is needed because the components of equipment do in fact affcct each other, but the 
language provides no mechanism for specifying this. Note: one may wish to define the operation set-temperature 
as above for the purposes of abstraction and information hiding; it is indeed a good abstract operation 
to associate with a cooker. llowever, the implementation should merely specify that it is ach- ieved 
by turning the control knob. The specification of the opera- tion can certainly indicate that the temperature 
of the burner will be affected, but, apart from this, no mention of the temperature should be made; it 
is the concrete operation of turning the knob that actually affccts the temperature, not the abstract 
one. Thus, data abstraction mechanisms do not come close enough to .satisfying the requiremcnLs of equipment 
abstraction mechanisms to be used conveniently. Procedural abstractions are adequate in the domain of 
fabrication processes, except that they do not allow the four levels of operations to be identified ex- 
plicitly. Verification and run-time checking. Most algorithmic lan- guages do not have facilities to 
aid verification, and do not per- form run-time checking (except of a fcw, system-defined errors, such 
as overflow). There is certainly no mechanism for the user to specify run-time chccks convcniently, except 
in languages such as Algol W [15] and Euclid [10] that have asserl statements. tlandling of equipment 
malfunctions. Ilandling of equipment malfunctions is so completely out of the domain of algorithmic languages, 
that most of them provide no mechanism suitable for doing it. qhey do, however, provide the general mechanism 
for coding tasks to perform it. Such tasks would have to be written explicitly by the designer of a recipe, 
which is a great deal of error-prone work. Of course, he could be provided with a library of tasks and 
procedures to help him, but he will not be able to escape the coding entirely. The one exception is PL/1 
[5]. The on statement is a con- venient means of specifying what constitutes a malfunction and what recovery 
action to take, though the run-time system would have to be extended to perform the monitoring. Source-level 
interpretation. The existing algorithmic lan- guages that are source-level interpreted unfortunately 
do not have some of the other important features listed above. The most notable is LISP [16], which is 
severely lacking in good abstraction mechanisms and seldom gives rise to clear and readable programs. 
Smalltalk [8] is better in that it does provide good general abstraction mechanisms, but it is very slow, 
not generally available, and its syntax leaves much to be desired. Suitable run-time support. The run-time 
systems of algorith- mic languages are not designed for the environment in which the recipe language 
will be used, and hence do not provide many of the special facilities required. In most cases, however, 
the run-time systems could be adequately and gracefully extended by writing library routines to provide 
these facilities. Conclusions. Algorithmic languages are Turing-equivalent, and as such can be used to 
specify any algorithm or recipe. The above remarks, however, should be sufficient to indicate that they 
cannot do so conveniently, As stated by Hoare [4], "The most valuable feature of a programming lan- guage 
is that it provides the programmer with a con- ceptual framework which enables him to think more clearly 
about his problems and about effective methods for their solution; and it gives him a nota- tional technique 
which enables him to express his thoughts clearly." We therefore rule out the use of any existing algorithmic 
language for the specification of recipes.  5.2. Simulation languages Appropriate domain of discourse. 
Simulation languages, as they deal with equipment, do provide special purpose constructs for naming and 
specifying it. However, they are not interested in physical details of a machine, nor even in its hmctionality, 
only in modeling the amount of time it takes to perform its processing. An illustration of this is their 
treatment of queuing. They all have excellent mechanisms for specifying queuing and for analyzing the 
behavior of queues, but none of them has a means of specify- ing a physical queue, where the waiting 
objects are actually placed. From the point of view of simulation, this does not mat- ter; but from the 
point of view of rigorous specification of an actual recipe, it is important. A similar difficulty arises 
in the treatment of time. Simulation languages have the notion of system time, during which physical 
processing actually takes place, and durations in system time are easy to specify and are well handled, 
tlowever, as pointed out by Dahl in [3], intervals of system time are instantaneous in com- puter time. 
In other words, the simulation languages are not con- cerned with specifying exactly what occurs during 
an interval of system time, only with determining or estimating the length of 0ae interval. This is not 
to ~ay that details of processing absolutely cannot be specified in a simulation language; just that 
the languages are 142 not designcd for such specification, and would require some al- teration to facilitate 
it. Abstraction mechanisms. Simulation languages do provide abstraction mechanisms that allow the specification 
of the properties of equipment that are important to a simulation. Simula, in particular, has an excellent 
means of specifying classes of objects. The properties specified are the abstract or math-ematical properties, 
however. There is no better a mechanism for specification of physical propertics than in algorithmic 
languages; for example, the same problem with locations occurs in the ease of simulation languages. Verification 
and run-time checking. These are not provided by existing simulation languages, though the languages 
could be gracefully extended to include them. Ilandling of equipment malfunctions. Since simulations 
do not deal with actual machinery, no facilities for equipment monitoring are provided. It could be specified 
in much the same way as in the case of algorithmic languages. Suitable run-time support. The simulation 
environment is quite different from the actual fabrication environment. So, as in the case of algorithmic 
languages, the run-time systems of simula- tion languages do not provide the facilities required, but 
they could be extended to do so. Conclusions. Simulation languages come closer to satisfying the requirements 
of the recipe language, as they do deal with equipment and physical processes. But they do so from a 
point of view that is sufficiently different to make them inadequate for the rigorous specification of 
recipes. 5.3. Numerical control languages A number of languages exist for specifying the machine shop 
operations necessary for the production of some part; their development is reviewed in [t4]. The most 
common is APT [7], and, indeed, most of the others are derivatives or subsets of it. At first sight, 
these languages seem like good candidates for a recipe language, but they have the following disadvantages: 
They are extremely domain specific. Some are suitable for use in controlling only one specific type of 
machine. Others are more general, but still restricted to machine-shop tools, or at best to numerically 
controlled machines. None of them has a mechanism .for specifying recipes to be per- formed by human 
beings, and none of them is rich enough to describe the wide variety of integrated circuit fabrication 
equipment. Even the more general languages, such as APT itself, need changes made to the system when 
a new type of machine has to be controlled, Specifically, a post-processor has to be Written lbr that 
machine. The post-processor is not a part program written in APT; it is a computer program that has to 
interface with the remainder of the APT system.  They were designed in the 1960s, before many breakthroughs 
in programming languages. As a result, their syntax is poor. they do not provide sophisticated abstraction 
mechanisms, and part programs are difficult to read. They resemble assembly langungcs more closely than 
modern high-level languages: in that sense they are languages for controlling, rather than describing. 
 They are able to specify the processing to be performed by only one machine in isolation. They contain 
no mechanism for specifying complex, parallel processes.  Although numerical control languages m'e thus 
clearly inade- quate to the task of representing complex recipes, some of the concepts underlying them 
are useful and instructive. In particular, the four levels of operations mentioned in section 4.2 are 
discern- ible in APT. 5.4. Existing recipe languages Automated IC fabrication facilities do exist, and 
they must have some means of representing recipes. These systems are proprietary, and we are not aware 
of any publications on them. We have information on two of them, however: the Hewlett- Packard PCS system, 
and the Xerox Cholla system [2, 1]. The fol- lowing remarks are based on these. In these languages, a 
recipe is a file of numbers or identifiers, each representing a processing step. A step may be a simple 
step that can be performed directly, in which case the number or iden- tifier references an assembler 
routine to control its performanee~ Alternatively, a step may be a compound one, in which case the number 
or identifier references another file, containing the sub- steps. A primitive hierarchical scheme is 
therefore possible, and by careful use of the step-numbering schemes and careful division of the full 
run sheet into appropriate hierarchical levels a certain amount of abstraction is possible. These recipe 
languages thus resemble simple assembly lan- guages with an elementary subroutine facility. In the industrial 
environment in which they are used, where portability and readability are sometimes considered drawbacks 
(because they might aid piracy), they serve a valuable purpose. But in an en- vironment in which portability 
and readability are paramount, they are clearly inadequate.  6. The Fable language As indicated in the 
preceding section, no existing language is entirely adequate for the proper representation of recipes. 
We have designed, and are in the process of implementing, a recipe language which satisfies all the requirements 
discussed in section 4. In the interests of limiting the problem to manageable size, this language, Fable, 
has been designed specifically for the represen- tation of IC fabrication processes; however, we suspect 
that its fundamental ideas could be used equally well in other manufac- turing processes. Fable is in 
one sense a programming language like Pascal or Ada [9, 6], in that it specifies the sequential behavior 
of an abstract machine. It differs from all existing programming lan- guages, however, in that the abstractions 
that it deals with are physical rather than mathematical. The abstract machine whose behavior it sequentially 
controls is implemented in terms of fur- naces and acid baths rather than multipliers and floating point 
adders, but the basic principles are quite similar. The essential properties of Fable are similar to 
those of recent programming languages such as Ada, Mesa, Clu, or Alphard [6, 13, 11, 17]. It contains 
good facilities for data and procedural abstraction, including parameterized data types, and it supports 
expressions, statements, and routines similar to those found in ordinary programming languages. Statements 
divide into several categories. Line operation statements effect the actual control of the fabrication 
equipment. Program control and data manipulation statements correspond closely to the statements found 
in ordinary programming languages; all the common con- trol structures, including exception handling, 
are provided. Task control statements include fork, abort, wait, inhibit interrupts, and critical sections. 
Fable is modular and structured, so recipes can, and should, be written in the style advocated by structured 
programming. In addition to these properties shared widl modern program- ming languages, l,'able contains 
many special features to make it satisfy the requirements of a recipe language. For convenience, these 
are now dcseribed under the same headings as were used in ,section 4. 143  6.1. Appropriate domain of 
discourse cooker burner knob Fable contains constructs for nmning and spccifying equi-pment, material 
and locations directly. It also allows the basic, concrete operation,s that can be performed by equipment 
to be specified and named conveniently. The characterization of equi-pment is discussed in more detail 
in the next section. Mechanisms are provided for specifying time, both as dura-tion and as time of day. 
A variety of wait statements are available, allowing the programmer to .specify that a process must wait 
for a certain length of time, until a .~ecific time, or until a specific condition is satisfied. This 
allows the programmer to specify precise timing of operations. Communicating concurrent processes can 
be specified. In or-der to model most closely the situation in a fabrication facility operated by technicians, 
communication is effected by means of interrupts and exceptions. Concurrent processes can also consult 
.and update shared variables; mechanisms are provided for ensur-ing mutual exclusion when necessary. 
Interrupts and exceptions can be inhibited for short periods. Most of the time, interaction between the 
Fable system and the technicians is performed automatically by a sophisticated user interface (see section 
6.6). Sometimes it is necessary, however, to specify such interaction explicidy in a recipe; Fable provides 
a mechanism for doing so. 6.2. Abstraction mechanisms Fable provides a unique two-dimensional structuring 
and abstraction mechanism, called an abstraction grid. This mechanism was motivated by the requirements 
listed in section 4.2: in particular, the necessity for modularity on the. one hand, and for the sub-division 
of a recipe into levels on the other, sug-gested a two-dimensional mechanism. The abstraction grid mechanism 
is general, and applicable to domains other than the specification of recipes. It is, however, ira.possible 
to describe and justify it fully here; just those aspects of it most hnportant from the point of view 
of Fable are presented. An abstraction grid consists of a two-dimensional matrix of modules, each module 
being a collection of a small number of closely related definitions. The rows of the grid are called 
views, and the columns groups. The modules making up a view specify a number of different entities at 
a particular level, such ~s all the equipment in a line at the concrete level (section 4.2). The modules 
making up a group specify a number of different views of the same entities, such as the equipment and 
concrete views of a furnace. The example of a cooker2 will be used as an illustration throu-ghout this 
discussion (a more comprehensive example in the domain oflC fabrication appears in appendix A). Fig. 
6-1 shows the structure of a grid defining a cooker and its components at the equipment and concrete 
levels; the modules shown contain definitions associated with the equipmenL As indicated in the figure, 
a module is identified by its group and view. It is not necessary for each view to contain modules from 
,all groups (or, equivalently, for each group to contain modules from all views), so the grid may be 
sparse. [:or example, no equipment view of burner is shown in fig. 6-1_.because a burner is such a simple 
component that no abstract view of it ksrequired. An abstraction grid is more than just a mMrix of modules: 
structure is imposcd on the views and groups. Iheh view represents a level of abstraction, and so views 
are structured ac-cording to the relationships between these levels. Groups are structured according 
to the innate structure of the entities they define. 2A cooker is a con:poncnt of the ~;implckitchen 
stove introduced in scction4.2.It consistsof a burner mada control knob. group group group v ! module 
cooker I I module knob [equipment view] I i [equipment view] i g module cooker | module burner I module 
knob [concrete view] i [concrete view] I [concrete view] a i Figure 6-1: An Abstraction Grid Defining 
a Cooker Levels of abstraction are partially ordered, and the view struc-ture is the directed acyclic 
graph (DAG) representing this partial ordering. Every view that is not at the lowest level has to be 
implementedin terms of a lower-level view; each module in such a view therefore has to have an associated 
body describing its im-plementation. For example, the structure of the views in fig. 6-1 ksshown in fig. 
6-2(a). Bodies are required for the equipment views of cooker and knob. In general, a single view may 
have implementations specified in terms of more than one lower-level view; in this case, each module 
has a separate body for each im-plementation. equipment cooker view I concrete burner' knob view group 
group (a) Views (b) Groups Figure 6-2: Structure of the Cooker Grid The group structure varies widely, 
as it is dependent on the innate structure of the entities being defined, qlais structure is, however, 
almost always hierarchical. For example, since a cooker consists of a burner and a knob, the structure 
of the groups in fig. 6-1 is the simple hierarchy shown in fig. 6-2(b). Groups thus serve the same purpose 
as constructs such as packages and clusters in modern programming languages. For various reasons, static 
nesting. is not used to specify the structure of views and groups. Instead, separate specifications called 
directoriesdefine and doculnent the structure. The modules making up the grid can then be specified independently, 
separately and in arbitrary order. A module can refer to other modules across group and view boundaries, 
subject to restrictions specified in the directories. This provides a great deal of flexibility. Of particular 
importance is the fact that a module can, in general, be implemented in terms of any or all of the following: 
e A module in'the same group but a lower-level view. A module in the ~me view but another group.  A 
module in a lower-level view and another group.  As a result of the group an view structures, the first 
method provides refinement on the basis of abstraction level, and the second on the basis of innate structure. 
The third method is less structured, and its use should be confined to very simple cases. In the cooker 
example, the equipment view of cooker can be u'nple-mented in reruns of the concrete views of cooker 
and burner, but the equipment view of knob. "lhis amounts to treating knob as a black box. 144 The abstraction 
grid mechanism allows arbitrary views and groups to be defined. [:able, however, requires each recipe 
to contain certain specific views, corresponding closely to the levels mentioned in section 4.2. Process, 
material and equipment views are required, corresponding exactly to the process, material and equipment 
levels. The concrete level is replaced by three views, as described below. Additional views are also 
permissible. A typical piece of IC fabrication equipment can potentially be controlled either manually 
by technicians, or automatically by a computer system. It can thus be thought of a presenting two different, 
concrete views to the world: a technician view and a computer view. These views differ in the components, 
state values and concrete operations they reveal. The technician view consists of components such as 
kpobs and buttons, it displays state values by means of lights and gauges, and its concrete operations 
include turning knobs and pushing buttons. The computer view, by con- trast, consists of wires, it makes 
state information available via these wires, and its operations are sending and receiving of a variety 
of signals. For each type of equipment that might be controlled both manually and automatically, both 
these views must be specified. The technician and computer views, though different, do not differ greatly, 
as the equipment is likely to have similar, if not identical, functionafity irrespective of how it is 
controlled. F_ach operation in one view is likely to have an analogous operation in the other. This assumption 
makes it possible, and inviting, to abstract away from the physical details to a low-level view of the 
equipment that is independent of the controlling agent. ]'his view is referred to as the standard view. 
Fig. 6-3 shows the partial ordering of all the views that Fable requires to appear in a recipe. process 
view I material view I equipment view I standard view technician ,clew computer view Figure 6-3: Partial 
Ordering of Views in a Recipe The abstraction grid is a general structuring and abstraction mechanism, 
and determines the overall structure of a Fable recipe. Specific abstraction mechanisms are also provided 
for equipment, material, data and processes. The fundamental equipment abstraction mechanism is the equipment 
type, just as the fundamental data abstraction mechanism in algorithmic languages is the data type. An 
equi- pment type can be thought of as the set of all items of equipment having certain characterislics: 
specification of these characteristics defines the type. The etluipnmnt type mechanism allows these characteristics 
to be specified directly attd conveniently. The kinds of characteristics that can be specified in Fable 
are precisely those listed in section 4.2. [:able requires all equipment types, including the types of 
components, to be defined in isolation: in fact, they are often defined in different modules of the abstraction 
grid. Interactions betwcen the components of art equipment type cannot, therefore, bc specified in the 
definitions of the components. Fable provides a mechanism for specifying theft1, instead, in the definition 
of the patent equipment type ilself. The interaction is thus dependent on the types of both the components 
and their parent. This is an accurate reflection of reality, in which the same types of com- ponents 
can interact differently in different pieces of equipment. In addition to equipment types, Fable allows 
the specification of parameterized equipment classes. A class may be thought of as a set of types, All 
the types in the set have eet~tain common characteristic, but other characteristics may differ, as indicated 
by the parameters. This mechanism allows the'construction of hierarchies of classes, giving important 
insight into the nature of the equipment under consideration. Fable also provides abstraction mechanisms 
for material, data and processes. Material types and classes are similar to equi- pment types and classes, 
but are less complex, as they do not allow the definition of operations and functional relationships 
be- tween components. Data types and c!asses provide a means of defining paramcterized abstract data 
types. Operations, procedures and functions are the standard process and procedural abstraction mechanisms. 
All the specific abstraction mechanisms in Fable interact closely with the general abstraction grid mechanism. 
They have specification parts that appear in the modules of a grid, and im- plementations that appear 
in the associated module bodies. These modules and their bodies can be located in various views, as appropriate, 
and additional views can be introduced if neces- sary. 6.3. Verification and run-time checking The verification 
and run-time checking facility in Fable is probably more extensive than in any other language. Fable 
con- tains numerous constructs to help the system detect errors in a recipe, especially errors that could 
be dangerous. These constructs include preconditions and postconditions for each operation, specifying 
the conditions that must hold before the operation is performed, and those that should hold upon its 
completion. An invariant construct, a generalization of the notion of loop in- variants, facilitates 
the specification of conditions that must hold either all the time that the fabrication line is operating, 
or con- tinually while an operation is being performed. A standard asser- tion mechanism is also included, 
to be used at the recipe designer's discretion. Most of the conditions in the constructs mentioned above 
are conditions on the state of the equipment in the fabrication line. The Fable interpreter will maintain 
an internal model of the state of the line, and update that model on every operation. Precon-ditions 
(postconditions) will cause specific state values within this model to be checked immediately before 
(after) the associated operatio=ls are performed. Invariants will cause the state values to be checked 
every time they change. 6.4. Handling of equipment malfunctions The state model to be maintained by 
the interpreter will also be used to detect equipment malfunctions. At any instant, it will represent 
the state of the fabrication line as it should be, based on the operations that have been performed. 
This should correspond exactly to the actual physical state of the equipment: if it does not, the equipment 
has malfunctioned. Once the sensors have been installed that wilt enable the Fable system to sense the 
physical state automatically, the system will continually check the correspondence between the state 
model and the measured physical state, and f,nise an exception ira discrepancy is detected. Such exceptions 
will be trapped and dealt with as specified in the recipe. 145  6.5. Source-level interpretation References 
Fable is an interpreted language. The interpreter will operate on an internal form of a Fable recipe 
that will be closely related to the source, and, like the language itself, will be modular and designed 
with run-time modifiability in mind. All operations will be referenced indirectly through transfer vectors, 
allowing the implementation of an operation to be changed at run time with minimal effort. "lhe transfer 
vectors will be extensible, allowing new operations to be added at run-time as well. Deletion of operations 
will be permitted, resulting in null transfer pointers; these will be trapped by the system, and the 
user given the opportunity correct the errors. The interpreter will thus support the most common forms 
of run-time modification efficiently and well. Many other changes will also be permitted at run time, 
and their effects will be local- ized as a result of modularity. Any change to the body of a module will 
have no ramifications outside that module. Any change to the specification of a module might affect other 
modules that use it; the system will keep track of these, make what adjustments it can automatically, 
and highlight changes that must be made by the user. 6.6. Suitable run-time support The interpreter 
will interact with the technicians in the fabrication facility via a sophisticated, graphical user interface. 
In addition to the actual recipe, the internal form of a Fable program will contain information for use 
by the user interface. For ex-ample, it will specify how much detail should be displayed to each specific 
technician, on the assumption that more experienced technicians require less detailed instructions. The 
run-time system will give authorized users (not neces-sarily all technicians, but certainly the engineers 
responsible for the design of recipes) access to all details of a recipe and of the current state model, 
and will 'allow them to make manual changes to the state values. It will also allow them to perform operations 
not in the recipe, and will record them; if requested, it will even incorporate them into the recipe 
for future use. In addition, the run-time system will handle maintenance of the state model, perform 
run-time checking, and keep continual watch for equipment malfunctions, as described above. 7. Conclusion 
The process of fabricating integrated circuits is an extremely complex and sensitive one. The project 
described in this paper is intended to aid fabrication engineers and technicians in dealing with its 
complexity, by providing them with sophisticated com- puter support especially tailored to their environment. 
Central to this project is the issue of specifying recipes completely and precisely. Fable is a language 
designed ~specially for the specification of recipes. Unlike programming languages, it provides constructs 
and abstraction mechanisms tailored to the domain of physical objects and processes. It is intended to 
facilitate transporting of recipes from one fabrication facility to another, an operation that is otherwise 
extremely time-consuming and costly, if not impos- sible. Fable is still in a state of flux, and its 
implementation is far from complete, so it is too early as yet to evaluate its success. However, it is 
sufficiently flexible and powerful that we are con- fident it will go at least some way towards solving 
the important and difficult problem of recipe specification. 1. Brotz, Douglas. Cholla run sheet representations. 
Personal communication to B. Reid, May 1982. 2, Clare, Chris. H-P PCS run sheet files. Personal communica- 
tion to B. Reid, April 1982. 3. Dahl, O.J. Discrete Event Simulation Languages. In Programming Languages, 
Genuys, F., Ed.,Academic Press, 111 Fifth Avenue, New York, NY10003, 1968. 4. Hoare, C.A.R. Record Handling. 
In Programming Languages, Genuys, F., Ed.,Aeademic Press, 111 Fifth Avenue, New York, NY10003, 1968. 
 5. 1BM System/360 Operating System: PIll (F) Language Refer. ence Manual IBM Data Processing Division, 
1970. 6. J.D. Ichbiah, et al. "Preliminary Ada reference manual." SIGPLAN Notices 14, 6 (June 1979), 
Part A. 7. liT Research Institute. APTPart Programming. McGraw-Hill, New York, 1967. 8. Ingalls, D.H.It 
The Smalltalk-76 Programming System Design and Implementation. Xerox Palo Alto Research Center, 1976. 
 9. Jensen, K. and Wirth, N. Pascal User Manual and Report. Springer-Verlag, New York, 1974. 10. Lampson. 
B.W., et al. Report on the Programming language Euclid. Tech. Rept. CSL-81-12, Xerox Paid Alto Research 
Cen- ter, October, 1981. 11. Liskov, B.H., Synder, A., Atkinson, R. and Sehaffert, C. "Abstraction mechanisms 
in CLU." Comm. ACM 20, 8 (August 1977), 564-576. 12. Meindl, J. A Fast Turn Around Facility for Very 
Large Scale Integration (VLSI). Tech. Rept. FM-195-78, Stanford University IC lab, July, 1981. 13. Mitchell, 
J.G., Maybury, W. and Sweet, R.E. Mesa language manual. Tech. Rept. CSL-79-3, Xerox Palo Alto Research 
Cen- ter, April, 1979. 14. Olesten, N.O. Numerical Control Wiley Interseience, New York, 1970. 15. 
Sites, R.L. Algol W Reference Manual. Tech. Rept. STAN-CS-71-230, Stanford University, February, 1972. 
 16. Teitelman, W. lnterlisp Reference Manual Xerox Paid Alto Research Center, Paid Alto, California, 
1978. 17. W.A. Wulf, R.L. Landon, and M. Shaw. "An introduction to the construction and verification 
of A1,PI 1A R D programs." II,:EE Transactions on Software Engineerhtg SE-2 (1976).  146 Appendix A. 
A brief example This example consists of a few representative fragments of a Fable recipe specifying 
an NMOS fabrication process: The full recipe would be far too long and complex to include here; even 
in the fragments presented, a great deal of detail has been omitted. The following directories define 
the structure of the recipe fragment: view directory is process material equipment standard technician 
global end view directory; group directory is FFAF furnace general end group directory; The view directory 
defines the views required by Fable, and the additional view global, which contains definitions that 
are used by modules in all the other views. The group directory defines the group FTAF (Fast Turn Around 
Facility), and two subgroups. In what follows, each view contains an FTAF module, defining the Facility 
at the appropriate level of abstraction. In certain of the views, the tq'AF module refers to details 
defined in one or more of the subgroups. The modules making up the recipe fragment are now presented 
top-down. Consider the process view first: . module FTAF [process view] is run sheet NMOS19; end module; 
module body FTAF [process view] is use FTAF [material view] open: use general [global view] open: mn 
sheet body NMOS19 is material wafers: WAFERS (9); begin gate-oxidation (wafers); Si3N4-densification 
(wafers); end NMOS19; en(l'module body; In this, top-level view, the Facility consists of named run 
sheets; only one, NMOSIg, is shown. The implementation of a run sheet is a procedure made up of operations 
defined in the material view of FTAF. module FTAF [material view] is use general [global view] open; 
operation gate-oxidation (wafers: WAFERS); operation Si3N4-densification (wafers: WAFERS); en~fmodule; 
module body FTAF [material view] is use FTAF, furnace [equipment view] open; use general [global flew] 
open; vari.able setting: array (1 to 5) of TEMPI'RATURE; operation Si3N4-densification (wafers: WAFERS) 
is begin with furnace(5) do boat.load(wafers); prepare(950 degC, (O2: 135)); setting(5) : = temp-setting; 
tum-on(O2); slow-push; bake(60 min); {Dry 02 densification} slow-pull; end with; end Si3N4-densification; 
end module body; 1he material view of the Facility thus consists of high-level operations intended to 
achieve certain effects on wafers. Each such operation is implemented as a sequence of operations that 
can be performed by the Facility's equipment, as defined in the equipment view, module FTAF [equipment 
view] is use furnace [equipment view] open; equipment furnace: array (1..5) of FURNACE; .. end module; 
module furnace [equipment viewl is use general, furnace [global view] open; equipment type FURNACE is 
component boat: BOAT; state variable letup-setting: TEMPERATURE: operation prepare (temperature: TEMPERATURE; 
flow-settings: FLOW-SETI'INGS); operation turn-on (gas: GAS); operation turn-off(gas: GAS); operation 
slow-push; operation slow-pull; operation bake (t: time); end FURNACE; equipment type BOAT is operation 
load(wafers; WAFERS); end BOAT; end module; This is the first view in which one of the subgroups of 
FTAF appears. The Facility is defined to consist of 5 furnaces (and other equipment not shown here), 
each of the type defined in the furnace group. A FZIRNACE at this level of abstraction consists of a 
single component, boat, a single state variable, letup-setting, and several operations. The implementation 
of the equipment view in terms of the standard view is as follows: module body furnace [equipment view] 
is use furnace [standard view] open; use general, furnace [global view] open; equipment type body FURNACE 
is operation turn-on (gas: GAS) is begin gas-controller (gas).turn-on; end turn-on; operation turn-off(gas; 
GAS) is begin gas-controller (gas).turn-off; end turn-off; end FURNACE: encl'module body; The equipment 
and standard views of the FTAF group itself are identical, so no implementation of I.TAF is needed. The 
im- plementation of FURNACE consists of defining each of the characteristics of FURNACI:, defined in 
the equipment view in terms of the characteristics delincd in the standard view. Some are identical in 
both views, however, and so require no implemen- 14.7 ration; only the operations prepare, turn-on and 
turn-offneed be implemented. The latter two are shown; note that the implemen- tations arc in terms of 
the operations of gas-controller, one of the components of FURNACE. module FTAF [standard viewl is use 
furnace [standard view] open; equipment furnace: array (1.,.5) of FURNACE; end module; module furnace 
[standard view] is use furnace ]equipment view]: use general, furnace ]global view] open; equipment type 
FURNACE is component boat: BOAT; component temp-controller: TEMP-CONT ]equipment view]; component gas-controller: 
array (GAS) of GAS-CONT; operation slow-push; operation slow-pull; operation bake (t~ time); end FURNACE; 
equipment type GAS-CONT is state variable flow: FLOW-SETrING; operation set(flow: FLOW-SETtING); operation 
turn-on; operation turn-off; end GAS-CONT; end module; The standard view of FURNACE contains more components 
than did the equipment view. This is not surprising, as the stan- dard view is a lower-level view, in 
which more detail is revealed. The difference between the definitions of the components temp-controller 
and gas-controller is interesting. "lhe first specifies that the equipment view of TEMP-CONT must be 
used; the second specifies no view, so the standard view of GAS-CONT is used by default. This means that 
the implementation of the equi- pment view of FURNACE (or of any entity that refers to the the standard 
view of FURNACE) must use the equipment view of temp-controller, thereby treating temp-controUeras a 
black box, but may use the standard view of gas-controller directly. This is done because a temperature 
controller is somewhat more complex than a gas controller. The standard view must now be implemented 
in terms of the technician view: module body furnace [standard view] is use furnace [technician view] 
open; use general, furnace ]global view] open; equipment type body FURNACE is operation slow-push is 
remove (endcap, on-end-of tube): remove (elephant, on elephant.hook); place (boat, in elephant); replace 
(elephant, on-end-of tube); remove (push-rod. in push-rod-store); insert (push-rod, through elephant.hole); 
insert (push-rod.hook, in boat.eye); push-slowly (push-rod); remove (push-rod.hook, in boat.eye); pull- 
fast (push-rod); replace (push-rod, in push-rod-store); remove (elephant, on-end-of tube); hang (elephant, 
on elephant-hook); end slow-push; end I'~URNACE; end module body; The technician view defines all the 
operations used in the above implementation (though only a few of the definitions are shown): module 
FFAF [technician view] is use furnace [technician view] open; equipment furnace: array (1..5) of FURNACE; 
 end module; module furnace ]technician view] is use general ]technician view] open; use general, furnace 
[global view] open; equipment type FURNACE is component boat: BOAT; component endcap: ENDCAP; component 
elephant: ELEPHANT; component elephant-hook: HOOK (ELEPHANT); component push-rod: PUSH-ROD; component 
push-rod-store: STORE (PUSII-ROD); component table: SURFACE; component temp-controller: TEMP-CONT; component 
gas-controller: array (GAS) of GAS-CONT; component tube: TUBE; basic operation place (boat, loc: location) 
is effect boat.loe := loe; end place; basic operation remove(endcap, on-end-of tube)is preconditions 
endcap.loc= on-end-of tube; effect endcap.loc := on table; end remove; ... end FURNACE; equipment type 
ENDCAP is state variable loc: location; end ENDCAP; end module; module general [technician view] is 
equipment class HOOK (equipment contents x) is equipment location on: x; end HOOK; en~l'module; The 
definition of FURNACE in this, lowest-level view is the most detailed of all, including many components 
that come into play only when a FURNACE is being controlled by technicians. Note that this definition 
of FURNACE refers to the general group, which defines a number of common components such as hooks, knobs 
and gauges. These components are of interest only to technicians, which is why they are specified only 
in the tech- nician view. Finally, the global definitions used in various of the modules above are as 
follows: module general ]global view] is data type TEMPERATURE = real units degC; material type WAFER 
= primitive; material class WAFERS (n: integer) = array (1..n) of WAFER; end module; module furnace [global 
view] is data type gas = (02, HCI, AO; data type FLOW-SETTINGS = array (GAS) of integer.; end module 
 148  
			
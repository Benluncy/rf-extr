
 DECIDING BRANCHING TIME LOGIC E. Allen EMERSON 1 and A. Prasad SISTLA 2 1. Computer Sciences Department, 
University of Texas, Austin, TX 78712 2. Electrical and Computer Engineering Dept., Univ. of Massachusetts, 
Amherst, MA 01003 Abstract: In this paper we study the full branching time logic {CTL*} in which a path 
quan- tifier, either A ('for all paths =} or E ('for some path=}, prefixes an assertion composed of arbitrary 
combinations of the usual linear time operators F ('sometime'}, G {=always'}, X {=nexttime'), and U (=until=). 
We show that the problem of determining if a CTL* formula is satisfiable in structure generated by a 
binary relation is decidable intriple exponential time. The decision procedure exploits the special structure 
of the finite state ~automata for linear temporal formulae which allows them to be determinized with 
only a single exponential blowup in size. We also compare the expressive power of tree automata with 
CTL* augmented by quantified auxiliary propositions. 1. Introduction A number of systems of branching 
time temporal logic have been proposed for reasoning about ezistential properties of concurrent programs 
(e.g., potential for deadlock along some future} in addition to universal properties (e.g., inevitability 
of service along all futures). The modalities of these logics are of the general form: ei-ther A (=for 
all paths = ) or E ('for some path') followed by a combination of the usual linear time operators F {'sometime'), 
G {'always=}, X ('nexttime.), and U {'until'). In many such logics restrictions are placed on how the 
linear time operators can combine with the path quantifiers. For example, in the logic UB of [BMP81], 
A or E is always paired with a single occurrence of F,G, or X. While these restrictions can reduce the 
complexity of reasoning in a logic, they can also significantly limit the logic's expressive power. For 
instance, a property as-sociated with fairness such as =along some future an event P occurs infinitely 
often = can be formulated as EGFP; however, this formula involves a nesting of F in- side G violating 
the restrictions of UB's syntax and is provably (el. [EH83]) not equivalent to any UB formula. IThe first 
author was partially supported by NSF Graut MCS-8302878. 2The second author was partially supported 
by NSF Grant MCS-8105553. Permission to copy without fee all or part of this material is granted provided 
that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice 
and the titJe of the publication and its date appear, and notice is given that copying is by permission 
of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or 
specific permission. &#38;#169; 1984 ACM 0-89791-133-4184/004/0014 $00.75 In this paper, we study the 
full branching time tem- poral logic CTL* of [EH83] in which a path quantifier, A or E, can prefix an 
assertion composed of unrestricted combinations (i.e. involving arbitrary nestings and boolean connectives) 
of the linear time operators F,G,X, and U. CTL* subsumes a number of logics from the literature including 
the systems of [MPT9], [LA80], [GPSS80], [BMP81], [EH82], [CES83], as well as the Com-putation Tree Logic 
of [CE81]. (It is also closely related to the logic MPL of [AB80]; see below.} We interpret CTL* formulae 
over R-generable models {cf. [EM83]) -i.e., structures generated by a binary relation like those used 
in [FL79] and [BMP81]. We show that satisfiability for CTL* with this semantics is decidable in triple 
ex-ponential time. Somewhat surprisingly, for some time it was not known if there was a decision procedure 
of elementary complexity for full branching time logic interpreted over this very natural class of structures. 
In [AB80] a logic, MPL, is defined which has a very similar syntax to CTL* but somewhat different semantics. 
While a double ex-ponential decision procedure is given for MPL interpreted over structures which violate 
the R-generability condition, for semantics (corresponding to) R-generable structures, [AB80] gives only 
a nonelementary decision procedure and states that the existence of an elementary procedure is open. 
Recently, other researchers ([PS83], [VW83]) have, independently, announced four exponential decision 
procedures for the R-generable case. Our procedure is thus exponentially faster. We can give a faster 
decision procedure, in part, because we uncover some structural properties of branching time and linear 
time logics which had gone heretofore unnoticed. To get our decision procedure, we first show that = 
given any CTL formula f0 we can derive an eqmvalent formula fl of length O([f0[ ) in which the depth 
of nesting of path quantifiers is at most two. This establishes a nor- ]4 real form for CTL* which is 
essentially conjunctions and disjunctions of subformulae of the form AP0 , AGEP0 , and EP0 where P0 is 
a pure linear time formulae (i.e. Po con- tains no nested path quantifiers). We then argue that fl is 
satisfiable iff it has an infinite tree-like model where the branching at each node is bounded by [fit" 
This enables us to reduce the satisfiability problem to the emptiness problem for finite automata on 
infinite trees (IRA69]): For each subformula AP0 , AGEP0 , or EP0 , we build a complemented pairs tree 
automaton of size at most double exponential in [P0[" These tree automata are then combined using a cross 
product construction to get a com- plemented pairs tree automaton for fl of size at most double exponential 
in [fl[ which accepts infinite trees that define models of fr By the results of [ST81] the emptiness 
problem of this tree automaton is decidable in time ex-ponential in its size, i.e., in time triple exponential 
in If01. As a corollary, we also obtain a small model theorem since an automaton accepts an infinite 
tree iff it accepts a finitely generable tree obtained by "unwinding" a finite tree ([RA69], [HR72]). 
Building the tree automata for AGEP0 or EP0 is straightforward. However, design of the tree automaton 
for AP0 is much more subtle. A tableau construction can be applied to P0 to get a nondeterministic (Buchi) 
automaton A 1 on infinite strings (where acceptance is defined by repeating a designated set of states 
infinitely often) recognizing {x: x t. P0} with N -~- exp(Ip01 ) states. A seemingly natural next step 
would be to program the tree automaton to simply run A 1 down every path from the root of the input tree 
to check that P0 indeed holds along every path. In fact, for this tree automaton to work correctly, the 
string automaton must be deterministic. It is well known that the subset construction ([RS59]) cannot 
in general be used to determinize finite automata on in-finite strings; instead, the "classical" method 
for deter- minizing such an automaton involves application of McNaughton's construction [McN66] and yields 
an equiv-alent deterministic string automaton with a number of states that is double exponential in N. 
However, we show that A 1 has a special structure derived from the tableau which allows us to obtain, 
by means of a rather delicate construction, an equivalent deterministic automaton with a number of states 
only single exponential in N. This in turn enables us to construct the tree automaton for AP0 of the 
desired size. Lastly, we compare the expressive power of branch- ing time logic with tree automata. We 
show that CTL* (resp., UB) with quantification over auxiliary propositions is as expressive as pairs 
(resp., Buchi) tree automata. The remainder of the paper is organized as follows: In Section 2 we give 
some preliminary definitions. Then in Section 3 we discuss the normal form and tree-like models. Section 
4 shows how the tableau for a linear time formula defines a Buchi automaton and describes its spe- cial 
structure while Section 5 shows how to determinize it with only a single exponential blowup. The design 
of the tree automata is given in Section 6, and, the concluding Section 7 gives our expressiveness results. 
2. Preliminaries: Definitions and Terminology 2.1 Syntax and Semantics. We inductively define a class 
of state formulae (true of false of states) and a class of path formulae (true or false of paths): $1. 
Any atomic proposition P is a state formula. $2. If p,q are state formulae then so are p A q, -,P. $3. 
If p is a path formula then Ep is a state formula. PI. Any state formula p is a path formula. P2. If 
p,q are path formulae then so are p A q, "-p. P3. If p,q are path formulae then so are Xp, (p U q). 
The set of state formulae generated by the above rules forms the language CTL*. Other connectives are 
intro-duced as abbreviations in the usual way: p V q ab-breviates -~(~p A ~q), p =~ q abbreviates -~p 
V q, Ap ab- breviates ~E-~p, Fp abbreviates true U p, Gp abbreviates -~F-~p, etc. (Note: ]p] denote the 
length of p.) We define the semantics of a CTL* formula with respect to a structure M .= (S, R, L) where 
S is a nonempty set of states, R is a nonempty, total binary relation on S, and L is a labelling which 
assigns to each state a set of atomic propositions true in the state A fullpath (al,a2,a3,...) is an 
infinite sequence of states such that (ai,ai+l) E R for all i. We write M,a t- p (M,x l- p) to mean that 
state formula p (path formula p) is true in structure M at state a (of path x, respectively). When M 
is understood, we write simply a I. p (x t, p). We define t. inductively using the convention that x 
---- (al,a2,a3,...) denotes a path and x i denotes the suffix path (ai,ai+l,ai+2,..-): $1. a t. P iff 
p E L(s) for any atomic proposition P $2. at.p A q iff a l. p and at.q a l- =p iff not (a l- p) $3. a 
t. Ep iff for some fullpath x starting at a, x t. p P1. x t, p iff a 1 I. p for any state formula p P2. 
x I-p A qiffx I-p and x I-p x l- --,p iff not (x I- p) P3. x I.Xp iff x 2 I. p x I- (p U q) iff for 
some i ~ 1, x i l- q and for all j ~ 1 [j ~ i implies xJ l- p] We say that state formula p is valid, 
and write t. p, if for every structure M and every state a in M, M,a I- p. We say that state formula 
p is satisfiable if for some structure IV[ and some state s in M, M,a l- p. In this case we also say 
that M defines a model of p. We define validity and satisfiability similarly for path (i.e., linear time) 
formulae. Note that in determining whether x I- P0 only the truth values of the atomic propositions actually 
appearing in P0 matter. We can thus view a fullpath x -~ ala2a3... ]5 as an infinite string of sets of 
atomic propositions of P0 (so each a i E PowerSet(AtomicPropositions(P0) ) ). 2.2 Definitions. The Fischer-Ladner 
Closure of Po, FL(pJ, is the least set of formulae such that (I) Po E FL(p o) (2) if p A q E FL(Po) 
then p,q E FL(p o) (3) if -p E FL(p o) then p E FL(p o) (4) if (p U q) E FL(p o) then p,q, X(p U q) 
E FL(Po) (5) if Xp E FL(p o) then p E FL(p o)  Note: IFL(Po) [ ---- O(lPoI) The Extended Fischer-Ladner 
closure of PO, EFL(pJ, is the set FL(P0) U {-~p: p E FL(P0)} A set s _C EFL(P0) is maximal provided that 
Vp = "~q E EFL(P0), at least one of q,-~q E s.A set s C EFL(P0) is consistent provided that (1) Vp ---- 
-~q E s at most one of q, -~q E s (2) (p A q) E s iff p E s and q E s -~(p A q) E s iff -~p E s or -~q 
E s  (3) (p U q) E s iff q E s or p, X(p U q) E s -~(p U q) E s iff -~q,-~p E s or -~q,-~X(p U q) E 
s  there exists a run r on x such that the above,airs con-dition is false, ~.e., iff for all pairs 
,i E [l:k] (3GREEN i flashes implies ~RED i flashes) along r. Let F n = {bo,bl,...,bn.l} be an alphabet 
over n dis- tinct symbols b0,...,bn. 1. Then/~ may be viewed as an in. finite n-sty tree T, where the 
empty string X is the root node and each node t has as its successors the nodes tbo,...,tb n. A finite 
(infinite) path through T n is a finite (reap., infinite) sequence x ~ to,tl,t2,.., of nodes such that 
for all i, ti+ 1 is a successor of t i. An infinite n-sty E-tree is a labelling ~ which maps T n -) `U. 
A finite automaton A on infinite n-ary `u-trees consists of a tuple (`U,S,6,So) plus an acceptance condition 
similar to a string automaton except that 6 : S X `U-> PowerSet(Sn). A run of A on ,U-tree ~ is a function 
p : T n --~> S such that for all s E T n (p(sbo),...,p(sbn.1)) E 6(p(s),~b(s)). We say that A accepts 
input ,U-tree ¢ iff 3 a run p of A on ~b such that V path x starting at the root of Tn, if r ----- plx, 
the sequence of states A goes through along path x, then the string acceptance con-dition (as above) 
holds along r. The tableau for P0 is a labelled, directed graph T----~ (V,R) where the set of nodes V 
---- {s C EFL(Po): s is maximal and consistent} and R ~-~ {arcs s --* t: s,t E V and for each formula 
Xp E EFL(p 0) [X~ E s iffp E tl}. Remark: We use the symbols 3 and V which are read "there exist infinitely 
many" and "for all but a finite number', respectively. We also write i.o. to abbreviate "infinitely often', 
f.o. to abbreviate "only rmitely often', and a.e. to abbreviate "almost everywhere" (meaning "at all 
but a finite number of instances"). We also write cap(n) to mean e n for Some c ~ 1 and use exp'(n) to 
ab- breviate exp(exp(n)), etc. 2.3 Finite Automata on Infinite Strings and Trees. There is an extensive 
literature for finite automata on infinite strings and on infinite trees, and the reader is referred 
to [McN66], IRA69], IRA70], [HR74] as well as [ST81]. For now, we briefly review the following definitions: 
A finite automaton A on infinite strings consists of a tuple (`U,S,6,So) - where `U is the finite input 
alphabet, S is the finite set of states, 6: S X `U-> PowerSet(S) is the transition function, and s O 
E S is the start state -plus an acceptance condition as described subsequently. A run r A on infinite 
input string x ~-ala2a3.., is an in- finite sequence r = SoSlS2S3... of states such that Vi ~ "0 6(si,ai+l) 
_~ {Si+l}. For a Buchi automaton acceptance is defined in terms of a distinguished set of states, GREEN, 
(think of a green light flashing upon entering any state of GREE.N): x is accepted iff there exists a 
run r on x such that ~ GREEN flashes along r. For a pairs automaton we have a finite list ((RED1,GREENi) 
,..., (REDt,GREENt)) of pairs of sets of states: x is accepted iff there exists a run r on x such that 
for some pair i E [l:k] (-~RED i flashes and ~GREEN i flashes) along r. Finally, a complemented pairs 
automaton accepts x iff 3. Normal Form and Tree Models 8.1 Theorem. Given any CTL* formula f0 we can 
con- struct a corresponding formula fl composed of conjunc- tions and disjunctions of subformulae of 
the form AP0 , EP0 , or AGEP0 where P0 is a pure linear time formula such that (1) fl is satisfiable 
iff f0 is satisfiable and (2) If1[ ----O(If01 ). Moreover, any model of fl can be used to define a model 
of f0 and conversely. Proof sketch. We first drive negations inward using DeMorgan's laws and dualities 
such as -~Fp~_G-~ p. We then introduce "fresh" atomic propostions for each "deeply" nested subformula 
of the form Ap or Ep. For example, f0 ----E(GEFAFP A FAGR) becomes E(GEFQ1 A FAGR) A AG(Q 1 ~ AFP) which 
becomes E(GQ2 A FAGR) A AG(Q 1 ~ AFP) A AG(Q 2 ~-EFQ l) which finally becomes E(GQ2 A FQ 3) A AG(Q 1 
~ AFP) A AG(Q 2 ~ EFQ 1) A AG(Q 3 ------ AGR) ~-f2" It is easy to see that a model of f0 defines a model 
of f2 by extending the labelling so that QI is true exactly at the states where AFP holds, etc. Conversely, 
a model of f2 must be a model of f0" Note that that If2[ ~" O([f0[)" Finally, we use the validities AG(Q 
---- Ep) -------AG(-Q --A-up) and AG(Q ----- Ap) ~-(A[G(Q =~ p)] A AGE(-~Q =* -~p)) to get fl, of length 
about 2 "If21 ---- O(Ifol). By carefully unwinding an R-generable model, we can also show 8.2 Theorem. 
For any formula fl of CTL* in the above normal form, if fl is satisfiable, then it has an infinite tree-like 
model where each node is of outdegree < If1[" Moreover, each Ep subformula of fl is satisfied along a 
designated path of the tree-like model. 16 4. The Tableau as s, Nondeterminlstle Finite Automaton The 
tableau T for a linear time formula Po defines the transition diagram of a nondeterministic finite automaton 
.~ on infinite strings which accepts {x:xl-Po } by letting the arc u--~v be labelled with AtomicPropositions(v). 
A run r of .A on input x ----ala2a3.., is an infinite sequence r -~ sosls2s3.., of tableau nodes such 
that Vi ~ 0 6(si,ai+l) ~ {si+l} where 6 is the transition function of A. (Actually, s o is not a tableau 
node but the unique start state defined so that 6(so,a ) -~ {tableau nodes u: POE u and AtomicPropositions(u) 
~-AtomicPropositions(a)}.). Note that Vi ~ 1 AtomicPropositions(si) I-- AtomicPropositions(ai). Any run 
of A would correspond to a model of Po (in that, Vi ~ 1, x i t, {formulas p: p E si}) except that eventualities 
might not be fulfilled. To check fulfillment, we convert A into an equiv-alent nondeterministic Buchi 
automaton, Ai: First, we say that the eventuality (p U q) is pending at state s of run r provided that 
(p U q) E s and q ~ s. Note that run r of .~ on input x corresponds to a model of Po iff not(3 eventuality 
(p U q), (p U q) is pending a.e. along r) iff (V eventuality (p U q), (p U q) is not pending i.o. along 
r). The Buchi automaton A 1 is then obtained from A by aug- menting the state with an m+l valued counter. 
The counter is incremented from i to i+l (rood(m+1)) when the i th eventuality, (Pi U qi), is next seen 
to be not pend- ing along the run r. When the counter is reset to 0, flash GREEN and set the counter 
to 1. ~f m-~0, flash GREEN in every state). Now observe that 3 GREEN flashes iff Vi E [hm] ((Pi U qi) 
is not pending i.o.) iff every pending eventuality is sometime fulfilled iff x I- Po" Moreover, A 1 still 
has N -~ exp(Ipo[ ) O(]Po[ ) ---- exp(Ipol) states. The tableau has the following special structure: 
4.1 Lemma. If Sl,S2,t are nodes of T such that Sl,S 2 are both immediate predecessors of t, and AtomicPropositions(sl) 
_-- AtomicPropositions(s2) , then s 1 ~ s 2. Proof. We argue by induction on the structure of formulas 
in Sl,S 2 that p' E s I iff p' E s 2, for all p' E EFL(Po). The basis case of atomic propositions follows 
directly by assumption. Suppose p' E s 1. If p' ---- -~p then p t~ sl- By induction hypothesis, p t~ 
s2- So -~p E s 2 by maximality. If p' -~- p A q E s I then consistency of s I implies p,q E s 1. By 
induction hypothesis, p,q E s 2 so, again, by consistency pAqEs 2. If p' ---- Xp E s 1 then, by definition 
of the tableau, p E t and so Xp E s 2. Finally suppose p' ~ (p U q) E s 1. By consistency, either q E 
s 1 or p,X(p U q) E s 1. If q E s t then, by induction hypothesis, q E s 2, so consistency implies p 
U q E s 2 also. If p,X(p U q) E s I then by induction hypothesis, p E s 2. By definition of the tableau, 
(p U q) E t and also X(p U q) E s 2. By consistency then, (p U q) E s 2. We just showed that p' E s I 
implies p' E s 2. By symmetry, p' E s I iff p' E s 2. 13 The automaton A 1 inherits from the tableau 
a similar special structure so that, essentially, different runs on the same input cannot merge: 4.2 
Theorem. If rl-~(So,Sl,S2,...) and r2-~(to,tl,t2,...) are two runs of A 1 on input x, and rl,r 2 "intersect" 
after having read the same finite prefix of x (technically, 3k s k .~ tk), then rl,r 2 coincide up to 
the point of intersection (technically, Vj ~ k sj ~- tj). Given a Buchi automaton A l for linear time 
formula Po' ---- "~Po with N ---- exp(Ipo']) ~- exp([Pol) states, we will show in the next section how 
to construct an equivalent deterministic pairs automaton A* of size (exp(N 2) states, N 2 pairs). Since 
A* is deterministic and A* accepts x iff x k "~Po, we may view A* as a deterministic complemented pairs 
automaton which accepts x iff x I- PO" This will allow us to construct the desired tree automaton for 
APo. 5. How to Determin|se the Buehi Automaton 5.1 The Run Tree. The set of all runs of the nondeter- 
ministic Buchi automaton "~1 on input x may be viewed as an infinite Directed Acyclic Graph (DAG) of 
width ~ N ~. exp(JP01 ) where the nodes on level i of the DAG represent the possible states A l could 
be in after having read the first i symbols of x. Since by Theorem 4.2 no two runs on x can merge, it 
is actually a tree. However, a run can dead end, (e.g. if -~Fp E a node on level i and p appears in i+1 
st input symbol). Observe that, while there may be an infinite number of runs in this tree, there are 
at most N distinct runs of infinite length; the rest are finite. (In the sequel, we will say that a P-node 
of the run tree is one corresponding to a state of A 1 where /ll'S GREEN light flashes.) 5.2 Intuition. 
The dfa A* is based on the subset con-struction -it builds the tree of all runs on input x, a level at 
a time -plus some machinery to do, roughly, a depth first search of the run tree looking for an infinite 
run along which there are infinitely many P-nodes. The problem is complicated by the possibility that 
there may be infinitely many P-nodes in the run tree but only a finite number of them on any one path. 
Up to N markers are used in order to follow each active run. Associated with each marker i are N pairs 
of lights: <i,0~,...<~i,N-l). There are thus a total of N 2 pairs of lights. The need for multiple pairs 
of lights per marker is explained subsequently. Intuitively, A* operates as follows. As each symbol of 
x is read, the next level of the run tree is built from the current level which will shortly become the 
new current level. (Only two levels are kept in memory at one time.) Each state of the current level 
is the tip of an active run which is associated with some marker i. Note that some runs split apart and 
others die out. Whenever (the) run 17 (associated with marker) i splits, one alternative is fol- lowed 
by marker i and the other alternatives are assigned "free" (i.e., currently unused) markers Jr"Jk. We 
then say that the runs just started up, Jl,'",Jk, spawn off run i. When and if run i dies, its marker 
becomes free for use with another run that may later start up. Since there are at most N active runs 
at any level, the N markers can be re-cycled indefinitely so that each active run is always as- signed 
a marker. We want each marker i to follow an infinite run if possible. However, run i may split apart 
many (even in- finitely many) times. Some branches may be infinite and others finite. How does A* know 
which of the alternatives is infinite and should be followed? If there were a way for A* to know this, 
one pair of lights per run would suffice. For we could then simply have, for each run i, the pair of 
lights <i,0> flash GREEN whenever marker i encoun-tered a P-node and flash RED whenever run i encoun-tered 
a dead end. See Figure 1. (The RED flashes are needed to ensure that an infinite number of "non-collinear 
= P-nodes do not cause erroneous acceptance.) However, there is in general no way for A* to know which 
alternatives to follow because this depends on the suffix of the input yet to be read: one suffix might 
make alternative A infinite and alternative B finite while another suffix might do the opposite. Since 
A* is deter- ministic, on some inputs it may repeatedly make poor decisions in which case the above rules 
can lead to false results. For example, in Figure 2, A* erroneously rejects because both <1,0> and <2,0> 
flash RED as well as GREEN i.o.. The problem is that the single infinite path in the run tree has been 
parsed into infinitely many finite pieces rather than a single infinite piece. The solution is to have 
any run i which dead ends backup -but as little as pos- sible -by taking over the "youngest = surviving 
run j which previously spawned off i. For example, in Figure 3 because =father = run 1 is older than 
its "son" run 2 (it was "born" earlier), when run 1 dead ends it takes over its youngest son, run 2. 
The rules for the backup require that .4* flash RED on pair <2,0>, <2,1> since run 2 is totally obliterated 
when run 1 takes it over. A* also flashes RED on the pair <1,0>. This ensures that A* will not falsely 
accept due to GREEN flashes on <1,0> caused by non-collinear P-nodes detected by run 1 prior to backups. 
Then, A* flashes GREEN on the pair <1,1> iff a P-node has been seen on the finite path from the site 
of the previous backu p of run 1 to the site of the current backup (indicated by *'s). Consider the simple 
case where the width, N, of the run tree is at most 2. Then for any input x, one of two situations obtains: 
(l)After a certain depth, A* always makes "good" decisions and run 1 never again has to backup. Then 
pair <1,0> will ~ver again flash RED. It will flash GREEN i.o. iff 3 P-nodes along the run 1. (2) A* 
makes infinitely many =poor = decisions so that run 1 backs u~oi.o, in which case <1,~ flashes RED i.o. 
Then 3 P-nodes along run 1 fff 3 GREEN flashes of <1,1>. In general, when the width N _> 2, we have N 
pairs of lights and associated stages of backups for each marker i. (By convention, when marker i is 
pushed from a node to a successor node without any actual backup we have a stage 0 backup of run i. P-nodes 
detected in this way are =recorded= via GREEN flashes of <i,0>.) Roughly, an- cestor run i takes over 
descendent run j in a backup of stage m when the highest stage of previous backups of run i which must 
be =undone = is m-1. See Figure 4. P-nodes detected by run i on the path between consecutive stage m 
backup points are recorded via GREEN flashes of <i,m>. 6.3 Implementation. To perform these backups, 
A* does not have to re-read portions of the input. Instead, .4* is able to remember enough information 
in various =flag bits = to simulate re-reading of input as needed. The =data structure = used in implementing 
A* is the spawn-ing tree which is defined as follows: 1. There is one node, labelled i, for each active 
run i. Thus, there are at most N nodes. 2. If run i has spawned, in order, runs Jl,'",Jk then node i 
has sons, in order from left to right, Jk,'",Jl" (Note: if two or more sons are spawned simul-taneously, 
order them using some fixed convention.) 3. Each node i is labelled with its name as well as  a. birth[i] 
- a single bit = 1 iff a P-node has ever been seen along i since its birth b. bstage[i] -a O(iog N bit) 
counter -~-m, the maximum of the stage numbers of the backups of h, the father run of i, which have occurred 
at descendents of the point where i spawned off from h. c. backup[i]-an array o/N bits: backup[i][k]----I 
iff a P-node had been seen along i since its last stage k backup. d. fbirth[i] -a single bit = 1 iff, 
at the time i spawns off from its father h, h has seen a P- node since its birth. e. fbackup[i] -an 
array of N bits: fbackup[il[k ] ----1 iff, at the time i spawns off from its father h, h had seen a P-node 
since its last stage k backup. f. state[i] -a O(Io 9 N bit) counter ~-k iff the current state associated 
with run i is state k.  See Figure 5 for an example of the spawning tree and how it represents active 
runs. The spawning tree provides all needed information for performing backups, controlling the lights, 
and associated bookkeeping operations. Moreover, it can be represented using O(N 2) bits. The following 
"pseudo-code = describes the im-plementation in greater detail: Flash GREEN on G-,0> pairs with P-nodes: 
18 Note: In these figures, I ~ ~ denotes a P-node. 1 @ ~ % I ' \ ~t ~'t ~,t ~ ~X ~IL~ 2~1I I~coeptsbecau~e 
' i backups allow I [ : run 1 to follow ' ~ I " the infinite path 121; 1 ! Figure3 Er~neously ~jects 
 because <2,0>, <1,0> _ I ~th flash RED i.o. (a) C~tly accepts I ~~i~. ) F, gure2 (b) Correctly rejects 
because <2,0> flashes RED i.o. Figure 1 ~ 3 ~ A run tree (at left) and Its corresponding spawning tree 
(above). 2 3 (a) A path parsed by stage 2 backups + I 5 (b) A stage 4 backup. Note nested stage 1, 2, 
3 backups, Figure 4 IC..,X. n 1 k 1 k¢=j IB A stage n backup of run t Figure 5 FIgure 6 19 for each 
active marker i if state[i] is a P-node then flash GREEN on <i,0> birth[i[ := 1 backup[i] := (1,...,1) 
 end Read input symbol Pre-compute successor states of each current state associated with a node of the 
spawning tree. In the spawning tree, cross-out all nodes corresponding to markers with no successor. 
Backup as needed: Repeat the following until all crossed-out nodes deleted. Find a topmost crossed-out 
node: i Pre-order walk the subtree rooted at i to try to find the first non-crossed-out node: j if j 
exists then Run j is the "youngest" surviving descendant of i Let i backup to take over run j as described 
below if j does not exist then delete the subtree rooted at i from the spawning tree flash RED on <k,0>,...,<k,N-l> 
for all k in subtree return all such k to the pool of available markers End of repeat (At this point, 
all remaining runs have ~ 1 successors) for each active run i if i has a single descendant, advance marker 
i to it if i has several descendants sl,...,s k then assign i to s 1 assign "free" markers i2,...,i k 
to s2,...,Sk, respectively for each i' E {i2,...,i k) add i' as a leftmost son of i in the spawning tree 
let bstage[i'] :-~ 0 let fbackup[i'] := backup[i] let fbirth[i'] := birth[i] end end We now describe 
how to do a backup of run i. Refer to Figure 6 as needed. Suppose the current node, A, associated with 
marker i has no successors, there is a descendant run of i which survives beyond depth{A), and i is not 
taken over at this depth by a backup of an ancestor run. Let run j be the *youngest m (as determined 
above) descendant run of run i which survives beyond depth(A). Let the sequence of descendant runs of 
i that are ances-tors of j be i = ko,kl,...,k t -~ j. {Possibly, I ~ I so that k I ~-j; if i > I then 
runs kl,...,k/. 1 dead end at depth{A) just as does run i). Run i will take over run j (as well as runs 
kl,...,k/_l) in a backup of stage bs ~-I + bstage[kl] hy performing the actions numbered below. Note 
that node B is the current node of run j, node C is the first node of run kl, and node D is the deepest 
node of run i which has a descendent node {namely, some immediate successor of B) at a depth greater 
than depth{A). We say that, for this backup of run i, node A is the dead point, node B is the advance 
point, node C is the backup point, and node D is the branch point. We also say that the backup occurs 
at location node C at time depth(A). (1) Flash RED on ~i,bs-l~, ~i,bs-2~,...,~i,0~ since for each m < 
bs, the most recent previous stage m backup of run i has failed in that its backup point does not live 
on any infinite path. (2) Flash RED on <k,N-l>,...,<k,0> for each run k whose node is encountered in 
performing the preor- der walk from (but not including) i to {and including) j in the spawning tree because 
each such run dies at depth(A). (Each of kl,...,k I = j is such a k but there may be more.) (3) Flash 
GREEN on <i,bs> iff fbackup[kl][bs] Off between the time of the previous stage bs backup of i and this 
new stage bs backup point, run i has seen a P-node; note that the new stage bs backup point is the first 
node of run kl). (4) For each m E [1:/], let t m :-~- .V t~irth[k a] so that  n~[2:m I for each such 
m, t m ~- | iff on the path from where k m is born back to run i, a P-node occurs. {Note that t I ~-0; 
for m ~ I, this path includes exactly the following segments [first node of kl: last node of k I before 
k 2 splits off] [first node of k2: last node of k 2 before k 3 splits off]... [first node of km.l: last 
node of kin_ l before k m splits off]). (5) Let run i resume at the current node of the run j .-~ run 
k I which has just been taken over: Flash GREEN on ~i,0~ iff t I V birth[j]. {6) We must now adjust birth[[l, 
backup[i[ for where run i resumes (the "old" current node of j, node B): birth[i[ := fbirth[kl] V t I 
V birth[j] corresponding to the path, reading backwards, [the current node of j ---- k/: the first node 
of j ~ k/] [the last node of kt. 1 before k I splits off: the first node of kl] [the last node of i before 
k 1 splits off: the first node of i] For n ~ bs, backup[i][n] := fbackup[kl][n] V t I V birth[j] For 
n = bs, backup[i][bsl :-~ t t V birth[j]. (7) Now i may get some new sons k which were sons of the kl,...,k 
/ ~" j. We must collapse the spawning tree properly to install these new sons, and for each new son k 
of i, update fbirth[k], fbackup[k]: for n :---- 1 to ! add the oldest surviving son of k a as a son of 
i add the youngest surviving son of k a as a son of i end {When the above loop is done, the oldest group 
of sons of i will be those that were there originally, still present in their original order. The next 
oldest group of sons will be those of k 1, with the oldest having been added first, the youngest last. 
So the youngest son of i will be the youngest surviving son of k l, provided it exists.) Delete all the 
nodes on the walk from {but not including) i to {and including) j from the spawning 20  5.4.4 Theorem. 
For any input x, 3 a run r of A 1 along tree. This has collapsed the tree and installed i's which 3 P-nodes 
iff 3 a pair <i,j> of .4* which flashes new sons k. GREEN i.o. and RED f.o.. To adjust fbirth[k], fbaekup[k] 
where k is a surviv- ing son of kin, 1 < m < I: fbirth[k] := fbirth[kz] V t m V fbirth[k] correspond- 
ing to the path, reading backwards, [the last node of k m before k is born: the first node of km] [the 
last node of km. l before k m is born: the first node of kl] [the last node of i before k 1 is born: 
the first node of i] for n ~ bs, fbackup[k][n] := fbackup[kl][n] V t m V fbirth[k] for n ---- bs, fbackup[k][bs] 
:---- t m V fbirth[k]  (8) We must ensure that for each son k of i, bstage[k] ----the maximum stage 
of backup of run i, which has occurred at a descendents of the point where k split off from i. If k is 
an older sibling of k I (so k was a son of i present before this backup), let bstage[k] ----max{bs, bstage[k]} 
to reflect the fact that i took over k I at a descendant of k via a stage bs backup. If k is a son just 
added to i, let bstage[k] ---- 0 to reflect that no backups of i have yet occurred below where k splits 
off from the "new, backed up" i. 6.4 Correctness.  6.4.1 Proposition. If a stage n backup of run i occurs 
then (using the notation of Figure 6) we have the follow- ing: (a) For each m < n, a stage m backup of 
i has previously occurred whose branch point is a descen- dant node of D. (b) Each backup of run i that 
has previously occurred whose branch point is a descendant node of D is of stage m < n. (c) Moreover, 
each such branch point lies on no infinite path. (d) For some d, depth(C) < d < depth(A), the width 
of the run tree at depth d is at least n+l.  5.4.2 Proposition. Every infinite run r is eventually as- 
signed a marker i that follows it (allowing for backups) forever. This marker never has to make more 
than a stage N-1 backup to follow r. 5.4.3 Proposition. Suppose that, for run i, (1) At time t there 
is a stage n backup with backup point C,  (2) At time t' > t there is a stage m backup with backup 
point C',  (3) For every backup occurring at time t" E (t:t'), the backup point C ° is a descendent 
of C, and  (4) m _~ n Then C' is a descendent of C. Proof. (=*:) By proposition 5.5.2, any infinite 
run r in the run tree of -41 on an input x, will eventually be as- signed, by A*, a marker i, which it 
keeps forever allowing for backups of i. After that point, we consider run r parsed by the backups of 
marker i. We have the following cases: stage N-1 backups of i along r or -~ stag~N-1 backups of i along 
r and stage N-2 backups of i along r or ... ~ stage ~-1 backups, ~ stage N-2 backups,..., and -~ stage 
1 backups of i along r. If the last case obtains, then there are only finitely many backups of any stage 
of marker i as it follows the path r. After the last backup, marker i is always pushed for- ward directly 
to the next node of r, and <i,0> flashes GREEN every time a new P-nocle is encountered on r. If there 
are infinitely many such P-nodes, then plainly <i,0> flashes GREEN i.o.; furthermore, after the last 
backup, <i,0> will never again flash RED so it flashes RED f.o.. For the other cases, let j be the maximal 
j' such that stage j' backups of run i. Then for all j" E (j:N), there are only finitely many stage 
j" backups of run i. So after some time, there will never again be a RED flash of the <i,j> pair. Consider 
the suffix of r after that time. It is parsed by the infinitely many stage j backups of i into in- finitely 
many contiguous segments. Infinitely many of these segments will contain P-nodes iff ~ P-nodes along 
r. Hence, at infinitely many of the stage j backups, a P- node will be detected in the segment from the 
previous to the current backup point. Accordingly, the pair <i,j> will flash GREEN each such time and 
hence i.o.. (~:) When j----0 we note that if <i,0> flashes GREEN i.o., RED f.o., then (by construction 
of A*) the marker i never backs up after the last RED flash. So at a certain node, say v, in the run 
tree, marker i is assigned and is thereafter always pushed forward without backing up. Since there are 
infinitely many GREEN flashes, (by construction of the A*) there is an infinite path r' starting at v 
followed by marker i with no backups which has in- finitely many P-nodes along it. Since there is a finite 
path r from the root to v, r concatenated with r' is the desired infinite run with infinitely many P-nodes 
along it. Otherwise assume j > 0 and <i,j> flashes GREEN i.o., RED f.o. That there is a last RED flash 
of <i,j> means that there are no more backups taken by marker i of stage j' > j. Consider the GREEN flashes 
occurring after the last RED flash of <i,j>. For each n, at the n th such GREEN flash of <i,j>, marker 
i backs up (via a stage j backup) with a backup point that is some node v a. 21 After being assigned 
to node vn, marker i is never taken over by an ancestor marker i' (because if it were, <i,j> would again 
flash RED). For each n, vn+ 1 is a descendant of v n (because it is reached from v n without any backups 
of stage j' > j and repeatedly applying Proposition 5.5.3) and there is a P-node on the finite path from 
v= to vt+ 1. Let r be the finite path from the root to v r Then r con- catenated w~-th (Vl,V2,V3,...) 
is the desired infinite run along which there are infinitely many P-nodes. 13  6. Programming the Tree 
Automata We can reduce the satisfiability problem for a nor- mal form CTL* formula fl to the emptiness 
problem for finite automata on infinite trees: For each subformula AP0 , AGEP0 , or EP0 , we can build 
a complemented pairs tree automaton of size at most (exp2([poD states, exp(Ip0D pairs). These tree automata 
can then be combined using a cross product construction to get a complemented pairs tree automaton for 
fl of size (exp2([flD states, exp([flD pairs) which accepts an infinite [fll-ary G-tree (where E .~ PowerSet(AtomicPropositions(fl))) 
iff it defines a model of fl as described in section 3. By the results of [ST81] emptiness of the fl 
automaton is decidable in exp3(lflD time. The tree automaton for an AGEp 0 subformula (resp., EP0 subformula) 
starts up at each node (resp., the root node) of the tree the Buchi string automaton for P0 and runs 
it down the designated path for EP0 to ensure that P0 actually holds along it and can be implemented 
in size (exp(lP0]) states, IP0l pairs). To build the tree automaton for an AP0 subformula, we first construct 
the deterministic complemented pairs string automaton of size (exp2(Ip0[) states, exp([p0D pairs) as 
described in section 5 for the linear time subformula P0" The tree automaton for an Ap 0 subformula then 
simply runs the deterministic string automaton for P0 down every path from the root. Since the tree automaton 
is deterministic, it accepts iff for all paths x in the input tree the deterministic string automaton 
accepts iff AP0 holds at the root of the input tree. This tree automaton will be of size (exp2(lp01) 
states, exp(lP01) pairs). Remark: The string automaton for P0 must be deterministic in order to get the 
tree automaton for AP0. To see this, consider two paths of the tree xy and xz which start off with a 
common prefix but eventually separate to follow two different infinite suffixes y and z. It is possible 
that P0 holds along both paths, but in or- der for the nondeterministic string automaton to accept, it 
might have to "guess" while reading a particular sym- bol of x whether it will eventually read the suffix 
y or the suffix z. The state it guesses for y is in general different from the state it guesses for z. 
Consequently, no single run of a tree automaton based on a nondeterministic string automaton can lead 
to acceptance along all paths. 7. Expressiveness Results We wish to relate the "expressive power" of 
tree automata with branching time logics. A precise com-parison is difficult since (i) the logics can 
be interpreted over structures which are trees with nodes of infinite out.. degree whereas the automata 
take input trees of fixed, finite outdegree, and (ii) the tree automata can distinguish between, e.g., 
the leftmost and the rightmost successor node whereas the logics cannot. To facilitate a com-parison, 
we therefore restrict our attention to (i) struc- tures corresponding to infinite binary trees and (ii} 
sym- metric binary tree automata with a transition function 6: S × E-~ PowerSet(S × S) for which (t,t') 
E ~s,a) iff (t',t) E 5(s,a). We can then show that CTL* augmented with existential quantification over 
atomic propositons (EQCTL*, for short) is exactly as expressive as symmetric pairs automata on infinite 
binary trees. Moreover, if we similarly augment UB of [BMP81] (recall that in UB, A or E is paired with 
a single F, G, X, or U), the resulting logic (call it EQUB) corresponds to symmetric Buchi automata on 
infinite binary trees. An EQCTL* formula is of the form 3Qr..3Qmf where f is a CTL* formula and the Qi 
are atomic proposi- tions appearing in it. The semantics is that, given a struc- ture M -~ (S,R,L), M,s 
l- 3Qr..3Qmf iff there exists a structure M' -~-(S,R,L') such that M',s I- f where L' ex-tends L by assigning 
a truth value to each Qi in each state of S. EQUB is defined similarly. 7.1 Theorem. EQCTL* is exactly 
as expressive as sym- metric pairs automata on infinite binary trees. Proof. Given any EQCTL* formula 
fl ~-3Qr..3Qmf(Pi,...Pn) with free atomic propositions P1,...,Pw we can construct an equivalent formula 
g(P1,...,Pn) of $2S with free set variables Pi,...,Pw For ex- ample, EFP! could be translated into a 
formula 3P(PATH(P) A 3x(x E P AxE PI} where PATH(P) ab- breviateskEPAVy(yEP~(yb 0EPVyb 1 EPA ((yb 0 E 
P A yb I E P))). By [RA69] we can therefore con- struct a pairs automaton A which accepts an infinite 
bi- nary G-tree with E ----PowerSet(Pl,...,Pn) iff fl holds at the root of the corresponding structure. 
Since fl does not distinguish between left and right subtrees, we can assume without loss of generality 
that A is symmetric, i.e., if A it- self is not symmetric we can obtain an equivalent automaton A' which 
is. For the converse, let A be a symmetric pairs automaton on infinite binary trees. For simplicity, 
we as- sume that the input alphabet is (or is coded as) E = PowerSet({P1,... , P,}) for some list of 
atomic propostions P1 ..... Pw We can design an EQCTL* formula which is true at the root of a binary 
G-tree iff A accepts the tree: Let {ql,'",q,} be the state set of A. Associate with each qi an atomic 
proposition Qi" Intuitively, Qi holds at node s iff .d is in state qi at s. Any truth assignment to the 
Qi defines a candidate run of .d on the input tree. This is an actual run provided all transitions are 
consistent with the transition function ~ of A. We can easily write a formula 22 run(Q1,...,Qm) which 
ensures such consistency. For ex-ample, if 6(qi,{Pi,P2}) ----{(q2,q3), (q3,q2)} then AG( (QI A P1 A P2 
A ~P3 A...A ~Pa) =* (AX(Q2 V Q3) A FEXQ 2 A EXQ 3) ) is a conjunct of run(Ql,...,Qm). Now let the acceptance 
condition of A be given by the list ((REDi,GREEN1),...,(REDk,GREENk)) of pair's of sets of states (i.e., 
lights). If, for example, RED i ---- {ql,q2} and GREENi ----{q3, q4} then the assertion that RED i flashes 
f.o. and GREEN i flashes i.o. along a path can be ex-pressed by the path formula flash i ---- ~GF(Q 1 
V Q2) A GF(Q 3 V Q4)" Thus, the EQCTL* formula 3Qr..3Qm( run(Qr..Q m) A A(flash 1 V...V flash k) is equivalent 
to A. 0 7.2 Theorem. EQUB is exactly as expressive as sym-metric Buchi automata on infinite binary trees. 
Proof. Let fl = 3Qr.-3Qmf(PI,-",Pa,QI,"-,Qm ) be an EQUB formula with free propositions Pi,...,Pn. Then 
f(p1,...,Pn,Q1,...,Qm) by itself is UB formula with free propositons Pi,...,Pn,Q1,...,Qm. Let S2S1. 5 
be the second order language of two successors with one class of set variables ranging over only finite 
sets, another class of set variables ranging over infinite sets, and explicit second or- der quantification 
allowed only for variables of the first class. We can construct from f an equivalent formula g(p1,...,Pn,Q1,...,Qm) 
in $2S1. 5 (where the free variables are of the second class) because quantification over finite sets 
suffices to express all the modalities of UB (e.g., AFP 1 can be expressed as =there exists a finite 
subtree all of whose frontier nodes satisfy Pi=). It is known ([RA83]) that for every formula g(Pi,...,Pn,Qi,...,Qm) 
of S2Si.5, there is an equivalent Buchi automaton over binary S'- trees where Z" = PowerSet(P1,...,Pn,Ql,-..,Qm}). 
By in- troducing additional nondeterminism to =guess = the truth assignments to the Qi, we can obtain 
from A a Buchi automaton B on E-trees with E -~- PowerSet({Pl,...,Pa}). The automaton B accepts exactly 
those trees correspond- ing to models of 3Qr..3Qmf(P1,...,Pn,Qi,...,Qm). As be- fore, we can assume without 
loss of generality that B is symmetric. The proof of the converse, parallels the correspond- ing part 
of the proof of the previous theorem: Let A be a symmetric Buchi automaton. This formula run(Ql,...,Qm) 
is actually in UB syntax. To express the acceptance con- dition, that along every path, there are infinitely 
many occurences of states in GREEN we can write AGAF(V{Q 1 : qi E GREEN}). 0 8. Bibliography [AB8O] 
Abrahamson, K., Decidability and Expressive- ness of Logics of Processes, PhD Thesis, Univ. of Washington, 
1980. [BMP81] Ben-Ari, M., Manna, Z., and Pnueli, A., The Temporal Logic of Branching Time. 8th An- nual 
ACM Syrup. on Principles of Program- ming Languages, 1981. [CE81] Clarke, E.M., and Emerson, E.A., Design 
 [CESS3] [EC821 [EH82] [EH83] [EM831 [FL79] [GPSS80I [I-m72] [LAS0] [McN66] IMP791 [Iv 741 [PN77] 
[PN81] [PSS3l [RA6Q] and Synthesis of Synchronization Skeletons using Branching Time Temporal Logic, 
Proceedings of the IBM Workshop on Logics of Programs, Springer-Verlag Lecture Notes in Computer Science 
#131, 1981. Clarke, E.M., Emerson, E.A., and Sistla, A.P., Automatic Verification of Finite State Concurrent 
Programs: A Practical Approach, POPL83. Emerson, E.A., and Clarke, E.M., Using Branching Time Logic to 
Synthesize Synchronization Skeletons, Science of Com- puter Programming, vol. 2, pp. 241-266, 1982. Emerson, 
E. A., and Halpern, J. Y., Decision Procedures and Expressiveness in the Tem- poral Logic of Branching 
Time. 14th Annual ACM Syrup. on Theory of Computing, 1982. Emerson, E.A., and Halpern, J.Y., 'Sometimes' 
and 'Not Never' Revisited: On Branching versus Linear Time. POPL83. Emerson, E.A., Alternative Semantics 
for Temporal Logics, Theoretical Computer Science, vol. 26, pp. 121-130, 1983. Fischer, M.J., and Ladner, 
R. E, Proposi- tional Dynamic Logic of Regular Programs, JCSS vol. 18, pp. 194-211, 1979. Gabbay, D., 
Pnueli, A., et al., The Temporal Analysis of Fairness. 7th Annual ACM Syrup. on Principles of Programming 
Languages, 1980. Hossley, R., and Rackoff, C, The Emptiness Problem For Automata on Infinite Trees, 
Proc. 13th IEEE Syrup. Switching and Automata Theory, pp. 121-124, 1972. Lamport, L., =Sometimes = is 
Sometimes mNot Never.= 7th Annual ACM Symp. on Prin- ciples of Programming Languages, 1980. McNaughton, 
R., Testing and Generating In- finite Sequences by a Finite Automaton, Infor- mation and Control, vol. 
9, 1966. Manna, Z., and Pnueli, A., The modal logic of programs, Proc. 6th Int. Colloquium on Automata, 
Languages, and Programming, Springer-Verlag Lecture Notes in Computer Science #71, pp. 385-410, 1979. 
Meyer, A.R., Weak Monadic Second Order Theory of Successor is Not Elementary Recur- sive, Boston Logic 
Colloquium, Springer- Verlag Lecture Notes in Mathematics #453, 1974. Pnueli, A., The Temporal Logic 
of Programs, 19th Annual Syrup. on Foundations of Com- puter Science, 1977. Pnueli, A., The Temporal 
Logic of Concurrent Programs, Theoretical Computer Science, V13, pp. 45-60, 1981. Pnueli, A. and Sherman, 
R., Personal Com- munication, 1983. Rabin, M., Decidability of Second order  23 IRA70] [RAS3]  [RS59] 
[ST811 [Wo821 5rws3] Theories and Automata on Infinite Trees, Trans. Amer. Math. Society, vol. 141, pp. 
1-35, 1969. Rabin, M., Automata on Infinite Trees and the Synthesis Problem, Hebrew Univ., Teeh. Report 
no. 37, 1970. Rabin, M., personal communication. Rabin, M. and Scott, D., Finite Automata and their Decision 
Problems, IBM J. Research and Development, vol. 3, pp. 114-125, 1959. Streett, R., Propositional Dynamic 
Logic of Looping and Converse (PhD Thesis), MIT Lab for Computer Science, TR-263, 1981. (a short version 
appears in STOC81) Wolper, P., A Translation from Full Branch- ing Time Temporal Logic to One Letter 
Propositional Dynamic Logic with Looping, unpublished manuscript, 1982. Vardi, M., and Wolper, P., Yet 
Another Process Logic, CMU Workshop on Logics of Programs, Springer-Verlag, 1983.  
			
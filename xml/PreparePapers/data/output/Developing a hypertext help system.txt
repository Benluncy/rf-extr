
 Developing a Hypertext Help System: A Cooperative Effort Between a Software Developer and a Technical 
Writer by Phil Herold, SAS Institute (saspjh@unx.sas.tom) and Carla Merrill, SAS Institute (sasczm@mx.sas.tom) 
Introduction We developed Helplus*, a hypertext help application that runs under the X Window System 
on Hewlett Packard*, Sun*, and IBM RISC System/6000* workstations. Helplus is modelled after Microsoft 
Windows* help. Helplus is unusual for a help system because it is a server program that manages multiple 
help files concurrently, each in its own X window. These help files can be attached to applications and, 
therefore, invoked through the applications. However, they can also be invoked as stand-alone programs 
through Helplus. This means, in effect+ that one instance of Helplus can run multiple help files for 
applications, with or without the applications themselves running. Helplus can also be used to create 
and run a help file (or a hypertext file for some other purpose) as an independent application. For example, 
with only one instance of Helplus running, a user can have concurrent access to Helplus windows containing 
tutorials, orientation information, and other online information that may not be associated with a particular 
application. Our development experience with Helplus is interesting for two reasons: 1. Starting with 
a simple-minded hypertext widget in the public domain, we created an attractive, highly usable, fuU­featnred 
hypertext server application (compiler and viewer) in only three months. 2. We developed an atypical 
but extraordinarily effective method of interface design.  Permission to copy without fee all or part 
of this material is granted provided that the copies are not made or distributed for direct commercial 
adwmtage, the ACM copyright notice and tie titie of the publication end ita date appear, end notice is 
gtien that copying is by permission of ihe Association of Computing Machine~. To copy ofherwiae, or to 
republish, requires a fee andor speeific permission. DOC 94-10~4 Bsnff, Albertq Canada @ 1994 ACM 0-89791+81 
-6/94/0010...$3.50 These two elements are inextricably related, for without our design methodology we 
could never have stated with so little and achieved so much in so short a time. As it turned out, what 
Helplus became far exceeded our original objectives. We begin by describing our project and the structure 
of the help system we created. We conclude with a discussion of our interface design methodology, using 
examples that show how our interactive method led to the evolu~on of the system s structure. +kuM i-i 
. I,ypwbk-lw.li 1+ Sple ,Iu tit. x whim S.pwm It,d Ins ax mtrnlp siuvsi and 03plrfx Itnlp I&#38;x Illdl 
it hax Hmqilnd. I&#38;n lib. WIlx! !<la!Mlab,lc! }qplwll!!d iltl<!lllullia,l !4,@xllk 0, par! D1:,,, 
applidio,t wch aS II= I rnuh[s {ldi,w I lolp +ib). CMIISi. ,m~.l~,i .dtcr MKIWWJHWi.da!w w 11+, and 
pm.*f. .imil.,, meti,m,.,,.h as tk ability w, ,wI,.,-,I,w rq)k, ddinc honk, m.nkx, ,.ixv UWI hdp 51cs, 
JI SJmavigatc wittin the hidp file [1ICIP I Iistwr. Content.$. wword Search&#38;s ind Srwm S.quc.nc*s). 
 The original motivation for creating Helplus was to provide online help for Emulus*, SAS Institute s 
enhanced 3270 emulator for X Window System platforms, Before Helplus, Emulus was a sophisticated and 
polished product that was ready to be marketed except for one missing piece: its online help system. 
Specifically, as of September, 1993, Emulus had no help available for the Help buttons on its dialog 
windows or for the Help item on its menu bar. Furthermore, there was no hypertext help system (compiler 
and viewer) owned by SAS Institute that could support online help development for Emulus. The challenge 
for Phil HeroId, the developer of Emulus, was to create online hypertext help for Emulus and do it in 
time to meet the December, 1993 ship date for EnrIulus. With Carla Memill, the writer of the hardcopy 
Emulus user s guide, the project of creating a help system for Emulus began that September. At the start 
of the project, the plan was to provide help that was internal to the Emulus code. After about a month 
of work-j however, the project changed course with the decision to create the Helplus server. As a result 
of this decision not only were online help files for Emulus and Helplus written, but also the Helplus 
Programming Reference online document. Because Helplus became a separate product, this online reference 
was written to support both internal and external customers who want to create their own Helplus files. 
If you ever need to create a help system, a hypertext application, or an application for the X Window 
System, the specifics of our project provide some instructive examples. If you ever need to design a 
successful interface in record time, our methodology provides a dramatic example. Our conjecture is that 
at some point, most programmers and technical writers will be staring a similar project in the face 
(or, they may have worked through one already). Perhaps our experience can make their s a bit smoother 
or corroborate the effectiveness of some of the solutions we used to get the job done. The Development 
Environment at SAS Institute Development situations are rarely ideal. We had some important advantages 
that helped us as well as a few difficult hurdles to overcome. On the plus side, the developer had a 
senior-level position, permitting him to be both the designer and coder of the help system. This dual 
role ensured continuity and made it quicker for him to implement changes. In addition, there were no 
code reviews or other procedural structures that had to be built into the development schedule. From 
a quality perspective, the commitment was there because the developer was also the author of the emulator 
product that needed the help system. Having the writer of the emulator user s guide involved early in 
development of the help system was also am advantage. There was no learning curve required for the technical 
information. Furthermore, the information already existed in hardcopy, and it had been reviewed for technical 
accuracy. This preparation freed the writer to concenlbate on the design of the hypertext system for 
the online help. In addition, experience with coding online hypertext documentation enabled her to begin 
using the help program while it was being developed. By trying OU1.the code as soon as it was ready, 
the writer could evaluate the look and feel of the interface and suggest improvements. On the one hand, 
with the writer testing the help program and creating the help text, the developer was free to focus 
on the construction of the interface. On the other hand, with the new code available to try out early 
in the design phase, the writer could provide feedback about the interface that the developer could act 
on right away. Our hardware and software environment was superior, consisting of networked Hewlett Packard 
9000 Series 700 workstations. The speed and capacity of these machines coupled with the UNIX* and X Window 
System environments provided fast processing and easy access to one another s files--two factors that 
we relied on heavily . All of these elements played key roles in the success of the project, But the 
downside was there aa well. There were two @q diffictities which, by themselves, would not have been 
critical. However, acting together they threatened the feasibility of the entire project. First was the 
need to create all of the code (compiler and viewer). There simply was no reliable code available at 
SAS Institute that even began to meet the needs of the Emulus help system. Second was the ridlcnlously 
brief time period available to us for creating and testing the help system: three months. Initial Design 
Decisions Given the constraints of the project situation, two design decisions were made right away: 
a) Windows help would be the model for the help system, in terms of both the user interface and the structure 
of the help files. b) Public domain code for a hypertext widget would serve as a starting point for the 
viewer that had to be written. We chose Windows help for several reasons. It is clearly a standard in 
the industry. In addition, several other emulator programs on the PC platiorm use Windows help for their 
help systems, and we knew that management was con;id&#38;ing porting Emulus to the PC plafform in the 
future. The decision to select a model to imitate was critical. It eliminated the need for an extensive 
design phase and provided a working example to use as a standard of comparison for success. We can recommend 
this approach for a project that has similar constraints. The next sections show how Helplus was able 
to evolve rapidly once the Windows help model was selected. Starting Points for the Emulus Help System 
The initial objective was to create a hypertext help system as part of Emulus. By taking a bare-bones 
approach, we were not overwhelmed at the start with too many requirements for our help system. For the 
developer, however, experience with X Window System applications was critical. Having written Emtdus 
(a 3270 emulator under The X Window System) the developer had experience with: * Xlib: a C subroutine 
library that application programs (X clients) use to interface with the window system by means of a stream 
connection. XLIB is used for primitive operations like managing X resources and graphics, including drawing 
text strings (which Helplus does). Xt: X Intrinsic is a toolkit layered on top of The X Window System 
that uses object-oriented programming techniques to supply a consistent architecture for constructing 
and composing user interface components, known as widgets.  Motif A toolkit that defines a set of widgets 
and their behavior, for example, dialog windows, push buttons, and menus.  Since both the viewer and 
compiler had to be created, we assumed there would not be enough time to support the same level of functionality 
that Windows help provides. Decisions had to be made about which Windows help tags and formatting capabilities 
would be supported: 1. Which aspects of the Windows help user-interface should be included? 2. Which 
Windows help project file sections and options should be supported? 3. Which Windows help RTF tags should 
be supported?  These decisions affected the implementation of both the compiler and the viewer. The 
Initial User Interface for the Emulus Help System The Windows help menu bar and button bar were selected 
for initial implementation, although it was not clear how many of the menu items (File, Edit--Copy and 
Anrzorate, Bookmark, Help--Help for Help) and buttons (Contents, Back, History, Search, <<, >>) we would 
have time to support. The help window s appearance was: white background, black text, and green text 
for links. The initial font was a fixed, system-type font. The Initial File Structure for the Emulus 
Help System Like Windows help, we planned to use a project file that lists all of the topic files by 
name. The topic fries themselves contain the help text and hypertext links coded with RTF tags. The compiler 
is invoked on the project file and compiles the information sequential y in each of the named topic files. 
 We also took a bare-bones approach to supporting Windows-like options in the project file. Only minimal 
support was needed in any case, since we assumed we would not have time to implement much more than standard 
hypertext links for our help system. The project fde options supported initially were: ROOT=, TITLE =, 
CONTENTS=. REPORT=. The REPORT option turned out to be a valuable asset. For example, if the compiler 
could not resolve a 1~ it reported the file and link that failed to compile. As part of some later bug-fixes, 
error messages were added that reported the incorrect tagging that created the original bug. These additions 
helped the writer quickly identify tagging errors. As the help topic files increased in size, this error 
notification saved a lot of development and writing time. For example, the compiler now reports when 
either a \page tag or brace ({) is missing. A further refinement of the compiler s reporting capabilities 
is the link map created with the XREF report option. (Windows help does not provide a link map as output 
from compilation.) The Initial Topic File Tags for the Emulus Help System The basic needs of our hypertext 
system required support for Windows help link tags to topic windows (\uldb and Mike) and to popup windows 
(\ul). These tags were the first tags supported in the compiler s code. The topic fiie definition tags 
supported first were the context string definition tag (#{ Mootnote contextstring } ) and the title tag 
($ {\footnote windowtitle } ). Once we created several topics, the need to implement the s,equence browsing 
tag (+{ Vootnote sequenced}) and the keyword definition tag (K{ Mootnote keywordlist } ) became clear. 
(Later in the project, the writer asked for more formatting capabilities, including support for fonts 
and graphics,) The menu items and buttons on the button bar were set up in skeleton form first. They 
appeared in the viewer, but had no function. We felt we could always remove them if time did not allow 
us to support their functionality. To save time, the buttons were implemented differently from Windows 
help. Although some buttons appear by default (such as the Back and History buttons), Windows help allows 
the help fiie author to specify macros to create a button for the button bar. The author can specify 
the text o:n the button and the function to be executed when a user selects the button, Given our schedule 
constraints, the developer chose not to implement the full Windows help macro language capability at 
dl, but rather to provide some butlons by default (such as the Back and History buttons) on each help 
view. Other buttons appear only if the author includes particular kinds of tags and options in the help 
files. For example, if the help project file specifies a CONTENTS= option, then the Contents button appears. 
Similarly, if the help topic files contain at least one browse sequence, then the page forward (>>) and 
page backward (<<) buttons appear. F;inally, if the help topic files define at least one keyword, then 
the Search button appears. However, the help file author does not have the capability to add any other 
buttons to the help file. The Initial Writing Decisions for the Emulus Help Text After the fiist three 
weeks of the project, the compiler and viewer were working. At that point, the writer started coding 
topic files that provided help for the Emulus dialog windows. The help topic for a dialog window appears 
if a user selects the dialog s Help button. The help topics for the Ernulus dialog Help Ibuttons were 
written first for stxategic reasons: The most important objective to accomplish for Emulus was to make 
these Help buttons live. If we failed to provide help for them, they would remain grayed-ont (a user 
would not be able to select them). If Emulus shipped with dead Help buttons on its dialog windows, it 
would be obviously incomplete, and the quality of the product wotdd be compromised. On the other hand, 
if help were available for each of the Help buttons on its dialog windows, Emulus could still be shipped, 
even though our schedule later failed to permit additional development of the help system. As it turned 
out, the help information for the dialog windows was the core information for the procluct. Writing the 
help topics for these windows first allowed supplemental topics for the help system to be written straightforwardly. 
This method can be applied in general to the development of online help systems. It is based on the idea 
that the core information for a pruduct is the information that is referred to (or linked to) by other, 
more introductory information about the product. B,y developing the core information first, the writer 
knows the depth and breadth of the basic information that can later be linked to at the introductory 
level to provide further explanation. For Emulus help, the core information established the boundaries 
of its hypertext information web. The methodology of identifying core information and writing topics 
for this information fiist is one th:at the writer 237 recommends as an efficient approach to creating 
well­structured hypertext information webs. Overview of the Compiler and Viewer We knew we wanted to 
emulate Windows help in both the appearance and the internal design of our help system. The developer 
also knew the capabilities of the public domain widget that would serve as the starting point for the 
viewer. Given these initial conditions, decisions had to be made about whether to assign a particular 
task to the compiler or to the viewer, the format of their input and outpu~ and how particular tasks 
(such as searching) should be implemented. These decisions and their implementations influenced the evolution 
of the help system into a separate product. We planned to make our help system s viewer part of Emulus 
(that is, another Emulus dialog window), but we wanted the compiler to be a separate application. Later, 
decisions about the help system and its form required the viewer to be separate as well. The compiler, 
however, started out as a separate application and remained so. Development of the Helplus Server Program 
Six weeks into our project (about half-way), the help system had bitmap (bitonal) support, a highly-readable 
and attractive proportional font for the tex~ and many menu and button features in place. WMr hindsigh~ 
we now know that our very different perspectives were both moving toward the same realization. Our help 
system was developing an identity of its own. When the idea of making it a distinct prodnct came up during 
a brief conversation, that idea app~ed to both of US immediately and seemed the logical next step from 
our individual perspectives. From the writer s point of view, the help system now had generic capabilities 
(for example, font and graphics support) that clearly could be useful in help files for other applications. 
SAS Institute had no designated or proprietary native help system in its computer environment that was 
available for developing online help. Ye4 the writer saw a distinct need for such a system for the internal 
tools used for development. The standard help vehicle for these tools was the UIWX manual page, which 
is a far cry from hypertext online help like Windows help. Our help system seemed a perfect vehicle for 
moving to hypertext, online help at SAS Institute. In addition, the writer had been focusing on the help 
system itself by writing help for help, and thk process made it seem as though the help system was, indeed, 
a distinct entity. From the writer s perspective then, it seemed quite reasonable that it should become 
one. The developer welcomed the idea of making the help system a separate product primarily as a way 
of insulating Emulus from the newly developed help system code. Originally, of course, the help viewer 
was a pmt of Emulus, with the compiler being a separate UNIX application. This design was the easiest 
to get going, and it allowed the viewer to take advantage of code that was already in EmuIus. From the 
developer s point of view, however, there were also disadvantages to this initial approach: It ~eatly 
increased the executable size of Emulus. It made Emulus more volatile late in its development cycle. 
Emulus was ready for production (beta versions had already been shipped). If the new code caused the 
help viewer to crash for some reason, Emulus would crash too. This situation was not optimal. Once we 
were well into the development of Helplus as an independent program, we realized that there were other 
limitations to our original help system that, with hindsight would have made it clearly less acceptable: 
 It did not allow for Emulus help to be viewed independent y of running Emnlus. It was not a general 
help system, like the Windows help model is. Separating our help system from Emulus seemed to be the 
right move to make. However, the problem of how to make the help system an independent application had 
to be resolved. Why a Server Implementation? Even after we decided to externalize the help viewer from 
Emulus, having the help system run as a server was not an obvious solution. Our original inclination 
was to exorcise the viewer code from Emulus and make it a stand-aJone program for viewing help files. 
In this case, a user would get a new copy of the viewer program each time it was invoked (either through 
an application or from the UNIX prompt). The suggestion to implement it as a server actually came horn 
a colleague who had already developed one. A server is a program running in the background, waiting for 
other processes (clients) to ask for service. In the case of our help system (Helplus), the client could 
be an application or Helplus itself (if Helplus is invoked from the UNIX prompt when it is already up 
and running). After considering a server implementation, we realized it would satisfy our concerns about 
insulating Emulus from the help system s code And, once the server code was implemented, we found it 
provided additional benefits. Our experience showed thati A server allows sharing of resources (help 
fiie data and picture data) when multiple instances of Helplus are invoked. Help file data is the memory 
devoted internally to data structures that map the help file information. In Helplus this can be quite 
considerable since the entire help file is brought in to memory and left there. (This is no longer true 
with the next release of Helplus. The help file is kept on disk and only brought in piece by piece as 
the user selects topics.)  A server allows for faster startup of a Helplus client, since the server 
is already mnuing and in memory. In addition, if the help file is already being viewed, it is not reread 
from disk.  A server allows changes in bookmarks or annotations to be easily broadcast to other instances 
of the same help fiie view. For example, if a user is viewing the same topic in multiple Helplus viewer 
windows and adds or deletes an annotation or bookmark, all of the Helplus viewer windows are updated 
at the same instant.  How the Server Implementation Influenced Subsequent Development Once Helrdus came 
into existence as a server urozram, two . A-. of its features affected the direction of our development 
process. First, the independence of Helplus files made us rethink the purpose of the Emulus help file. 
Because users could now view this help file without starting and using Emulus, we realized that we could 
expand the file to give it tutorial capability. To this end, we added topics with more detailed descriptions 
of Emulus features (extensive detail is not typical of online application help). We reasoned that users 
in the middle of working with Emnlus were not likely Ed Blair at SAS Institute gave us this suggestion 
and a sample of server code. to want to take the time to read detailed descriptions. However, we could 
now give them the opportunity to explore this information when they had mc~re time, by viewing the help 
file by itself. Helplus allowed us to make more information available to users should they want to access 
it, without forcing them to wade through it while using Emulus (when they typically need quick help). 
Also important was the addition of screen captures of Emulus dialog windows. We captured all of the dialogs 
and linked each one to a View Window button thtit we created. This button appeared at the top of each 
topic that described a dialog window. (These are the topics that are accessed when the user selects the 
Help button on Emulus dialogs.) With this structure in place, the user could select the View Window button 
to see the dialog window wELle reading a description of it in the topic window. In true tutorial fashion, 
the user could view the Emulus dialogs while learning how to use them, without the overheaul of starting 
Emulus itself. To make the topics for the Emulus dialog windows more available, we created an Emrdus 
Windows topic for them in the help file s table of contents. When selected, this topic displays a list 
of the Emulus dialog windows. By selecting from the list, the user can jump to the topic description 
for a window and use the View Window button to see the Emnlus dirdog window. We wanted to let users know 
that they could get to a dialog window description without going through Emulus (that is, selecting the 
Help button in the Ernulus dialog window). Because the Esmdus help file could be used independently of 
Emulus, we added Trademarks and Additional Documentation topics. The information for these topics was 
taken directly from the hardcopy book. However, we used links for the trademark text, which can vary 
among trademarked items. Each trademarked item is followed by a registered trademark (R) or a trademark 
(TM) button. When selected, a button displays a popup that contains the specific trademark text for that 
item (see the figure below). We decided to create the Additional Documentation topic because we earlier 
implemented support for an italic font (for our syntax descriptions). The italics gave us the format 
we needed for a proper display of references. Fili Fdil I%mk,rmrk HPII> MS ?hisisa I +kr d Lrwh.nao k 
UI WW IrsAitttk. k, i. 11$..WA. SM 239 We believe that the server implementation improved the breadth 
and depth of the information we were able to provide for Emnlus help. In addition, by expanding the information 
for tutorial purposes we also increased its accessibility, giving users several ways to get to the same 
information. The second feature of the Helplus server that influenced the scope of our project was its 
separation into a distinct product. At the point in the project when we created the server, we had no 
assurance that Helplus would actually be marketed by SAS Institute as a product. Nonetheless, we decided 
that it would be wiser to prepare Helplus for this contingency. If Helplus were to be sold separately, 
it would be offered as a hypertext system for developing and displaying online information on X Window 
System plafforms. As a development system, we gave Helplus the following support: Documentation, in the 
form of an online programming reference (another Helplus file) Error messages Link mapping Navigation 
aids (help for help) Object file code Of particular interest to writers is the link mapping that we 
provided through the Helplus compiler. Our support for link mapping is unique and, we believe, an extremely 
useful development tool. The writer felt that a good development system had to accommodate updating and 
maintaining the help information. There would undoubtedly be situations in which Helplus files akeady 
in use would require changes. However, it would be very difficult for someone other than the original 
writer to work with a set of topic files for an already existing help file. The difficulty would be in 
knowing the target fde in which a link resolves. For example, if a writer has to change a link ID or 
link tex~ it is also necessary to go to the place where that link is resolved and change the ID and link 
text there as well. AS with Windows help, our topic files themselves do not indicate where a link is 
resolved. When the writer brought this issue to the developer s attention, he saw a fast and elegant 
way to satisfy the writer s concern. Because the decision was made upfront to have the compiler resolve 
links, the compiler already contained the information for a link map. It was necessary only to make this 
information explicit. In fact it took just a few hours to add an XREF option to the compiler. When specified, 
this option creates a .xref file at compilation. The .xref file displays a formatted list of the topics 
that contain links. The file location and line number of each topic are given, and under each topic, 
the links it contains are listed. For each li~ its line number and link text are provided. In addition, 
the file containing the target of the linlL and the line number of the target are listed. Armed with 
the information in the .xref file, a writer who changes the text or ID for a link can quickly locate 
the target of that link and make corresponding changes to the target text. One important use of the XREF 
option that we foresee applies to translation of help files for non-native speakers. To preserve the 
structure and meaning of the information, translators will need to know where to fiid the targets of 
the link text they translate. The .xref file will make this critical task straightforward and efficient. 
 In addition to provide support for the development of Helplus files, we felt that a more friendly interface 
was needed for users opening a Helplus file. If a site developed a number of Helplus fries and made them 
available to users, we wanted to provide an open file dialog for those files. To accomplish this, the 
developer created a generic Helplus window that appeam if a user types helplus at the UNIX prompt. Although 
users can also open a Helplus file by typing help lus filename at the UNIX prompt, this requires that 
users know the name of the Helplus file they want to open. Assuming that users will always have this 
knowledge seemed unfriendly to us. The addition of the initial Helplus open window provided a consistent 
and friendly GUI for both invocation and usage. Interface Design: Concurrent Use, Development, and Testing 
of the Help System Starting with just a few requirements for our help system gave us a chance to focus 
on using the system we were creating. We had a chance to become comfortable with the coding approach 
and the look and feel of the interface, and we established an efficient daily cycle for writing, compiling, 
evaluating, and changing. Once we reached that level, we could plan for and implement enhancements more 
confidently. On the other hand, if someone had initially presented us with a TODO list of all the features 
Helplus eventually included, it would have been difficult to envision how to accomplish them all. Although 
we began with a bare-bones approach, the final form of the user interface for Helplus contained a number 
of features, many of them standards of the Windows help model. Features included:  Links for topic windows 
and popup windows, including tags for making graphics into links and using the default text color (black) 
for links A non-scrollable window title area at the top of the window Three fonts: proportional base 
font, proportional italic font, fixed font Support for color graphics in pixmap (XPM) format Menu bar 
items (including associated dialog windows): File (Open and Close items), Edit (Copy and Annotate items), 
Bookmark (Define and select horn a list of defined bookmarks), Help (Using Help and About Helplus) Buttons 
on the button bar (including associated dialog windows): Contents, Back, Search, History, and browse 
buttons (<<) and (>>) We eventually created three Helplus files. The Emnlus help file includes a glossary 
(described more in a moment), screen captures of the Emulus dialog windows with associated hypertext 
descriptions, and a graphic of the main Emulus window. In addition to the Emulus help file, we created 
a help file for Helplus, accessible from the Help menu bar item at the top of any Helplus window. This 
fiie explains how to navigate within a Helplus window (for example, how to use the buttons and menu bar 
items, and how to identify links). Finally, we created the Helplus Programming Reference, a Helplus file 
that explains how to create Helplus files. As we stated previously, our support of the features implemented 
in these files did not result from an initial set of requirements for which a design had been speci.i5ed. 
Rather, we created many of these features either as responses to deficiencies and bugs we noticed during 
development or as enhancements to improve usability. We think it is interesting that we ended up supporting 
many more features than we thought would be possible at the start of the project. This result is interesting 
because it was our methodology that gave us the time and inspiration for enhancing the product. The lesson 
we learned is that you can compensate for a lack of time spent on upfront design. By using an efficient 
and interactive development cycle, a writer and developer can evaluate and change the look and feel of 
an application on a daily basis. These changes will be focused on specific elements of the application 
that are noticed during its actual rise. Such an approach to application design is less vulnerable to 
irrelevant or unrealistic requirements. Instead, it creates a very selective environment in which changes 
are considered only if they address a specific need that appears during the use of the application. While 
it is preferable to have time for design, it is not always possible. If a project schedule does not allow 
time 240 for design, and if the development team is small, we can recommend our methodology as a way 
of compensating for time constraints. Finally, even if you do have time for design in the early stages 
of your project, our methodology can help you evaluate your design during development. Description of 
Daily Methodology The key factor in our method was having someone (in our case, the writer) actually 
use the interface while it was being developed. Although the writer s primary motive in using the help 
system was to start working on the help text as soon as possible, a side-effect of early application 
use was testing and evaluation of the interface. To edit tihe displayed version of the help text she 
was writing, the writer had to compile the help fries and use the interface. Since the developer was 
working on the code for the application during this time, he was available and interested in working 
with the writer to fix bugs and discuss improvements. Another important factor in our methodology was 
quick response time. The writer compiled and displayed the current help file on an average of three times 
per day (and t%xpently many more times per day). This rapid turnover allowed new elements to be tested 
as soon as they were ava.ikable. It also revealed bugs early. The writer s motivation for fkequent compilation 
was to edit small amounts of text at a time, rather than several days or a week s worth of writing. Online 
editing is more reliable when done in small increments. In addition, the writer wanted to verify the 
appearance of the text frequently. If changes were required, they could be made to existing text and 
incorporated into any new text immediately. The unintended but additional benefit of frequent compilation 
and display was the constant evaluation of the usability of the interface. As the amount of compiled 
help information grew, more attractive and efficient ways of presenting it became clear through repeated 
viewing and actual use of the compiled help file. If this editing phase had been postponed until tbe 
end of the writing cycle (as it typically is for hardcopy books), ways to improve the interface would 
have been less a~ppmen~ and there would have been little or no time to make and test improvements. Completing 
the writing and editing of a chunk of information each day turned out to be an important requirement 
for application development in our situation. We would use this approach again and can recommend it for 
similar situations. The developer s fast response to requests for changes was a critical factor in the 
evolution of the help system. T&#38; developer waa available full-time on the project and gave his attention 
entirely to it. He was willing to address problems immediately, allowing the writer to continue developing 
the help text. Sometimes this meant delaying his current work on the project and fixing bugs or making 
241 pixmaps that the writer needed to compile and edit the help text. Good communication between the 
developa and writer and cordldence in each other s ability made this flexibility possible. The following 
figore and legend illustrate the daily cycle we followed:  13El 1. While continuing to design and code 
the application, the developer makes the latest code and tags (compiler and viewer) available to the 
writer. 2. The writer uses any new tags for new text and re-tags old text to tske advantage of any new 
enhancements. The writer compiles the most recent version of the help file and displays and edits it. 
Editing includes checking the format, gramrrdspelling, style, and links. 3. The writer tells the developer 
about any bugs in compilation and display of the information. Any deficiencies or enhancements to the 
interface are discussed, based on the most recent display. 4. The developer changes the code to fix 
bugs and implement enhancements, including the support of new tags. The developer tests the new code. 
 The developer gave the writer the latest working version of the compiler and viewer, transferring code 
changes to the writer s working dkectories. The developer also created scripts that allowed the writer 
to invoke the compile process with a single command. These shortcuts made up for the writer s unfamiliarity 
with UNIX and the syntax of the help system s compiler command. Development Changes (Fonts, Graphics, 
Glossary) Font support was one of the important interface developments that came early because of our 
daily methodology. We began with a fixed, system-style font. The readability of this font was not good, 
but a fixed font was required for the tabular information that was an essential part of the Emulus help 
file. Since we had to have the tables, we were committed to using a fried font. However, each time we 
looked at the displayed text we became more dissatisfied with its appearance. While searching for a better 
fixed font, the developer explored the proportional fonts available. As an experiment, he changed to 
a proportional, Windows help-like font. Although the tables did not format comectly, the appearance of 
the rest of the help text improved dramatically. In fact, the difference between the available fixed 
fonts and the new proportional font was so great that neither one of us wanted to return to a fixed font 
at all. We decided to use the proportional font while investigating what it would take to support a fixed 
font that could be invoked with a tag and used just for the tabular information. The issne for the developer 
was whether to follow the Windows help method of allowing font specification in help topic files. This 
method requires defining fonts in a font table. From the developer s point of view, font support was 
easier to implement through X resources. He added X resources to specify fixed fonts for topics and popups, 
and supported tags (\f 1 and \plain) to delimit text within the font. With the success of proportional 
and fried font support, the writer quickly saw a need for italic font while writing the syntax descriptions 
for Emulus commands and key translations. Support was then provided for an italic font, again using X 
resources and tags (W? and \plain). The writer used the tags promptly and edited the displayed text. 
Bugs were reported and freed, and the tags stabilized quickly. Once the help system became Helplus (an 
independent server program), an additional, strategic use was made of the italic font in the Trademarks 
and Additional Documentation topic. Had an italic font not been available, the display of book titles 
could not have been done correctly and attractively. The evolution of font support shows how the elements 
of a GUI interact and stimulate awareness of further improvements that can be made. Repeated use of the 
GUI during development increases and refines this awareness. The development of graphics support in our 
help system makes this point even more emphatically. The only graphic present in the early versions of 
the help system was the paper clip, which appears as a graphic link when a help topic has a corresponding 
annotation. The paper clip was created as part of the viewer. After using the paper clip, the writer 
saw a need for buttons that could function as links and that would appear as pointers in front of items 
in the help file s contents topic. Visually, the writer felt that the display of green for every topic 
link in the contents was unattractive. At the writer s reqnest, the developer investigated supporting 
bitmaps in the help topic files. The developer used a Hewlett-Packard program, Vueicon*, to create a 
bitmap and supported it with a \bml tag. Initially, the writer wanted only an arrow button that would 
always be left justified and point toward the right (in this case, preceding an item in the table of 
contents). Once the buttons were in place, the improvement in the appearance of the contents topic was 
significant. At the same time, the success of the new selectable buttons inspired the writer with an 
idea for implementing the glossary. Having reviewed some glossaries done for Windows applications, the 
writer created a similar design for the Emulus help system. The design called for letters of the alphabet 
arranged in three rows, to appear in each glossary topic window. The glossary topics themselves were 
individual letters of the alphabet. Each topic displayed its letter as the window title and contained 
the list of Emulus glossary terms that start with that letter. Each term was a link to a popup. The popup 
contained the definition for the term. Under the list of terms, in the same position in each topic window, 
were the rows of letters. Each letter was a link to its topic window. For example, if the user selected 
the A tkom the row of letters, the A glossary topic appeared in the window. This implementation allowed 
the user to go to any letter of the glossary from any glossary window. The only difficulty was visual. 
The letters arranged in rows were not evenly spaced because the font was proportional. In addition, the 
letters were all green, because they were links. Together with the list of glossary terms in the window, 
there was just too much green in the window. A solution to both the formatting and color problems was 
to have uniformly sized buttons for each letter. Grey buttons with black text would be much more attractive 
than the overwhelming green. The difficulty with this solution was that implementation of the bitmaps 
used for the arrow buttons allowed only left justified bitmaps appearing in the first column. The glossary 
buttons requested by the writer would need to appem next to one another in three rows. In creating these 
glossary buttons, the developer (sensing correctly that our use of graphics would increase) decided to 
take a more general approach. The changes the developer made to the hypertext widget to support graphics 
were extensive. Together with the glossary buttons, the developer implemented tags for left-justified, 
centered, and right-justified bitmaps and enabled bitmaps to appear in the text line. (A picture of the 
Emulus glossary s P topic window is shown below.) HII: l+ h.kr-r~k Just as the developer suspected, this 
new flexibility led directly to further innovations in our use of graphics. For example, to explain the 
X Window System interface of the emulator, the writer created a topic called Emulus Window Elements, 
planning to use a bitmap of the main emulator window with callouts that identified each element of the 
window. The callouts, also listed below the window, would be links to popups or topics that explained 
the elements in detail. The difficulty in this case was creating the bitmap with callouts. The developer 
had been using graphics tools that created bitmaps of icon or smaller size only. The bitmap needed for 
this topic would be much larger. After a good deal of effort, a bitmap was created. Unfortunately, it 
was disappointing visually. The developer was not satisfied with the results and felt that a color version 
of the emulator window was neecled. A related issue concerned pictures of the buttons used in the Emulus 
dialog windows. Bitmaps of these buttons were created for the writer to use in the help text, but they 
were not acceptable in the grey and black format. We felt this format would confuse users into thinking 
the buttons were selectable when, in fact, they were only illustrations of the buttons used in the Emulus 
application. They were supposed to be explanatory devices for the active buttons, not the active buttons 
themselves. The developer felt that, if a color format could be used for these buttons, we could solve 
this problem as well. Oiven these needs, the developer decided it would be worth the time to investigate 
supporting color pixmaps. His willingness to take on yet another big code change was motivated by the 
results our efforts had produced so far. Because we were using each enhancement as soon as it was coded, 
we were seeing dramatic improvements in the interface on an almost daily basis. Seeing what we had already 
achieved encouraged us to continue thinking innovatively about making what we had even better. Support 
for pixmaps was provided by using XPM routines to process X Window System pixmaps. The major concern 
was to ensure that these routines were available on all of the target platforms for Emulus (they were). 
An important result of the new graphics support was the developer s discovery of a fast way to create 
pixmaps of screen captures using tools available on the system. With these tools he could make pixmaps 
of Emulus windows and window elements, like buttons, more quickly than previously. Specifically, he used 
XV* to capture screens and save them as .ppm fries, used a .ppm-to-.xpm conversion utility, and then 
used Vueicon to edit the .xpm file as necessary. Concurrent development of our help system as the Helplus 
server product opened an even wider range of possibilities for our use of graphics and made our need 
for them more pressing. (We discussed this point in the previous section.) When the development of graphics 
was finished, we had gone from a single-use paper clip graphic that was internal to the viewer, to compiler 
and viewer support of RTF tags for placing full-color pixmaps and bitonal bitmaps, linked or unlinked, 
in left, righ~ or center positions, or in non­scrollable window titles. This result was one of our most 
visible achievements with Helplus, and it was one we never envisioned having the time to produce. We 
believe it provides some of the strongest evidence for the usefulness of our working methodology. Our 
daily use of the interface and constant, interactive evrduation of it greatly refined our understanding 
of what makes an interface attractive and usable. Reflections on the Past and Future of Helplus When 
we finished the projec~ Helplus was extremely well­received at our company. It has since become a strategic 
internal tool and in the short (and perhaps long) term, Helplus will serve as the native help system 
for the SAS System* running on UNIX hosts. In this article we have tried to explain the reasous for such 
a successful outcome to a Project that was carried out under difilcult circumstances. What follows are 
some reflections on key elements in the project that each of us feels contributed to our success and 
can be of value to others faced with similar circumstances. From the Develoue~ Looking back, I don t 
think I would change the way approached the project tlom a design point of view. Oiven our time constraints, 
we had to have a system that was working quickly, so that the writer could begin using it. That meant 
it had to be adaptable to the changes we would have to make as we went along, uncovering bugs and making 
improvements to the interface. The biggest change we made, creating a server product, was feasible only 
because of the system s adaptability. I credit the adaptability of the system to some good decisions 
initially: @ Keeping the compiler as a separate application. b) Using the compiler to resolve links 
and report tag errors. c) Supporting graphics and fonts with tags interpreted by the compiler. Aside 
from creating a good help system for Emulus, the most important thing we achieved with Helplus was a 
very attractive and usable interface for a help application in a UNIX environment. When management took 
a look at Helplus, they liked what they saw and were willing to devote resources to developing Helplus 
for additional uses at SAS Institute. My experience with Helplus has made clear to me what I can do for 
an even better design and implementation in the next release. And, now I have the time and resources 
to devote to the design phase that this more powerfnl release of Helplus needs. As of this writing, the 
next version of Helplus has already gone a long way toward meeting the goal set for i&#38; full compatibility 
with Windows Help RTF files. As for writing help text for the project, I realized the value of having 
a writer for that task. Although I could have written the text myself (I had written the MAN page for 
Emulus), I know I could not have written it as well. Nor could I have spent the time I did focusing on 
the program­ming part of the project if I rdso had to write the text. And, of course, the writer s testing 
and evaluation efforts contributed a lot to the quality of the interface we developed. It was also valuable 
to bounce ideas off someone very familim with the application, and so I think our interactive methodology 
was a big factor in the project s success. In terms of the experience required for a project like this, 
I think it is crucial for the writer to already know about the product that is to be documented (our 
writer had already written the user s guide for Emulus). It is also important for the writer to understand 
the features and presentation style of an online hypertext system. Our writer s experience with creating 
what she calls a hypertext web out of the information is something I was unfamiliar with. Finally, although 
our writer did not have as much experience with using the X Window System as I would have liked, I was 
able to compensate for that by providing the necessary assistance. For myself, I found that I was not 
as familiar with our model, the Windows help system, as I needed to be. As we continued to add tag support 
to Helplus, I had to play catch­up with the Windows programmer s references during much of the project. 
Fr om the Writer I a~ee completely that my experience with Emulus and with writing hypertext help was 
critical for this project, given the time constraints we had. I learned a lot more about writing good 
hypertext applications from this project, too. Because we were constantly trying to improve the interface, 
I found myself designing link methodologies that I had never used before (for example, the Emulus glossary 
topic). It was also important for me to have the hardcopy Emulus user s guide available. Since I had 
written that book I knew where and how all of the topics were described. I was frequently able to use 
chunks of text horn that book for the help text. However, I learned something important about using a 
hardcopy text as the basis for creating online text. That lesson is that the same textural descriptions 
are often not appropriate for two different presentation media. I found that I typically had to modify, 
separate, and even rewrite the hardcopy descriptions. To take advantage of the best Helplus user interface 
features required a dramatically different textual treatment than I had used in the hardcopy book. The 
developer knew at the start of the project that simply transferring the MAN page from Emulus to the help 
system, with a few links added, would not be an optimal help system. Similarly, my daily writing experience 
showed me that I could not get a high-quality, hypertext help system just by transferring the hardcopy 
book to an online format and adding a few links. In addition, I came up with a solution to a problem 
that I had always faced with hypertext projects, namely, given the set of information you want to put 
online, which part of that information should you begin with? I had never found a text or article about 
hypertext design that addressed this problem. For me, this is an important design problem because the 
way you develop links as you create the hypertext web depends on how much detail you have available to 
amplify knowledge through a link. I realized during this project that, at least in the case of a well-defined, 
windowed and menu driven application, the core information (the most information-rich text) is going 
to be the text that explains the details of the application s interface. Any additional information, 
whether it is introductory , provides examples, or explains how to extend the use of the application, 
is going to require links to this core information to amplify ideas and explanations. Since the Helplus/Emulus 
experience, identifying the core information before beginning a hypertext project and starting with that 
information has become a cardinal rule for me. Coming to this understanding, which turned out to be a 
fortunate by-product of our project, provides a real step forward in my ability to design and write hypertext 
information. As we discussed earlier in this article, 1 relied heavily on the Microsoft is a registered 
trademark of Microsoft error-reporting capabilities of the compiler. As more tags Corporation. were supported 
and my tagging became more complex, I asked for more and better emor reports. The developer s fast response 
in saving in adding me time. error reporting was I also relied on him an to important factor help me 
identify The SAS System is a registered trademark of SAS Institute. tag err~s. He has a much better eye 
for ex~nining cod~ than I do, and his help saved me a lot of time on a number of occasions. I also benefitted 
from the shortcuts the Sun is a registered trademark of Sun Microsystems, Inc. developer created for 
me, for example, a compiling script that allowed me to invoke the comuiler. with a single word without 
worrying about where the latest versions of the UNIX is a registered trademark of AT&#38;T. compiler 
and project files were located. Vueicon is a trademark of Hewlett-Packard Company. To a large extent, 
I attribute the attractive and usable interface we achieved to the developer s commitment to fast turnaround 
time for fixing bugs a;d supporting new tags, Windows is a tiademark of Microsoft Corporation. and to 
a willingness to consider my ideas for interface changes. Even though he perhaps cared more about Helplus 
than another developer might have (because he wrote Emulus), I have worked with developers who owned 
products XV is copyright by John Bradley and the University of and yet were much less responsive to requests 
for changes Pennsylvania, 1989, 1992. from writers. If the developer had viewed our roles as independent 
and had separated himself from what I was doing, we rarely, if ever, would have exchanged ideas about 
the interface. In addition, I probably would hSIVe ended up writing most, if not all, of the help text 
before ever compiling it and viewing it. For the reasons expressed earlier, I believe that in this case 
the interface would not have evolved from much more than a fixed font, single­color link presentation 
with no graphics support. I think this not because the improvements we made were always my ideaa (they 
certainly were not), but because it was our interactive evaluation of the interface that frequently inspired 
the ideas that came to us. Finally, as I say, it waa the developer s immediate response in implementing 
our ideas that made such rapid evolution of the interface possible. It also inspired my confidence in 
his ability to provide the code for just about any idea we came up with. And, I came to count on his 
willingness to try my suggestions. If I were ever involved in a simiiar project, I would hope to establish 
this kind of working, relationship again, which I think was so effective for the Helplus project. Trademarks 
Emulus and Helplus are trademarks of SAS Institute. Hewlett-Packard is a registered trademark of Hewlett-Packard 
Company. IBM RISC/System 6000 is a registered trademark of International Business Machines, Inc. 
			
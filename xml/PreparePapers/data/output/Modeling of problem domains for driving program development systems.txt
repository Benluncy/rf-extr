
 Permission to make digital or hard copies of part or all of this work or personal or classroom use is 
granted without fee provided that copies are not made or distributed for profit or commercial advantage 
and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, 
to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; 
1981 ACM 0-89791-029-X $5.00 . A concise notation for describing the methodologies porated by the semantic 
functions. Hence, the must be developed. This description must drive the model is powerful enough and 
arises naturally pds so that the development and analysis of the just as grammars are very natural for 
modeling program are tuned to the methodology. the translation process. . A library of methodologies, 
each designed to provide aid within a precisely defined problem domain must be created. These methodologies 
must be organized to begin guiding program development in very general problem domains and, if necessary, 
progress to very specific problem domains. Not much is known about programing in various problem domains 
though our intuition and collective knowledge points to the existence of patterns of programming in several 
well defined problem domains. Problem domains of interest fall into a variety of &#38;2?.%@ categories 
such as data oriented program­ming, distributed programming, real time program­ming, simulations, etc. 
. Suitable design notations and techniques for analyzing program design must be incorporated by the pals. 
o The design of the pds/pe components is impor tant since the programmer must be permitted flexible 
use of these components by means of a command language, 2. ~RIAD DESCRIPTION We are currently involved 
in the design and implementation of a pds called TRIAD. TRIAD consists of a set of tools which are the 
program developer, the analyzer, a data base of system maintained program components and a data base 
for the development histories of programs. Using a command language, the programmer can interact with 
the interface in order to use the tools (see Figure 1). The design of the tools and the inter­face will 
facilitate flexible use of the tools and thus provide the programmer with a friendly programming environment. 
In TRIAD we use attributed grammar forms [BAB179, GINS77, KENE79, W791, to model pro­gram development 
according to a-particular methodology. In other words, attributed grannnar forms will encode methodologies 
tailored to re­ create patterns of programming in well-defined problem domains. The TRIAD analyzer is 
facili­ tated by the use of a precise description of program development based on a methodology. TRIAD 
also maintains a history of a program from its abstract, functional form to its concrete, implementation 
form. This history (or refine­ment tree) reflects a methodology description (denoted as attributed grammar 
form) of the programmer s choice. Each refinement tree, therefore, belongs to a family of trees reflec­ 
ting a methodology and the analysis routines of TRIAD exploit this knowledge to provide useful messages 
during all stages of program develop­ment and program modification. The effectiveness of the TRIAD analyzer 
in providing useful feedback to the programmer during the development process, is entirely based on the 
fact that the program development itself can be systematically represented in a machine analyzable form 
using attributed grammar forms. The attri­butes and rules for evaluating these attributes in the attributed 
grammar forms permit the analyzer togenerate messages based on a global data flow analysis of the program 
s refinement tree. In the long run, program verification can be incor- The library of methodology descriptions 
could, of course, be previously created by a project supervisor to effectively aid in the development 
of programs specific to an applica­tion area. We are examining existing methodologies in order to create 
a set of methodology descriptions for precisely defined problem domains. Our initial work is in characterizing 
problem domains in the data processing area which is known to have fairly standard problem specifications. 
To summarize, we use attributed metaforms as a unifying model for a pals, to facilitate the interactive 
analysis of program development and the integration of various existing tools. We view such an integrated 
pds facility, based on existing analysis techniques and tools, to be more effective than its individual 
component parts for developing reliable software. Also, this pds does not preclude the integration of 
more sophisticated tools as they are developed. The integrated pds facility is being constructed now 
for production use during all phases of the soft­ ware life cycle and expected to be available for use 
in the near future. Library of Data Base of Data Base of Methodology Program System Descriptions Refinement 
Maintained (M.D.) Trees Modules .  CylM \ ~__ _T  , q~R p.e. interface m I Programmer s -1 Response 
w TRIAD -prompts, messages, refinement trees Figure 1: Overview of the TRIAD pds 3. FOCUS OF THE PAPER 
In this paper, we first present grammar forms for modeling program development according to a methodology. 
We then briefly illustrate how the pds uses this model. The paper focuses on the design of the &#38;rammar 
~orm methodology descriptions (gfmd) for guiding program ~evelopment In problem domains within the general 
category of data pro­cessing. We present grammar forms that adequately model the majority of program 
development activities of a major data processing organization. In addition, we summarize our experimental 
results based on an analysis of a variety of data processing programs. 29 4. GRAI@Wl FORMS Most existing 
methodologies are based on the process of abstraction and/or refinement. These dual processes are viewed 
as (context-free) con ceptual tools for the programmer and are designed to limit the complexity of program 
development. Here we shall talk about the refinement process only, though our discussion carries over 
to the dual process of abstraction. The development of a program by the process of refinement (that 
is, of replacing a code sequence by other code sequences) gives rise to a tree, though the order of program 
development and hence the creation order of the tree may be arbitrary. In other words, separately developed 
subtrees may be combined as a tree, thereby enabling both top down and bottom-up development as required 
by the methodology. Since the tree representation facilitates the maintenance of a variety of historical 
infor­mation regarding program development, we use trees as the primary objects in our system. We call 
the trees refinement trees. A program has many refinement trees. TRIAD can encourage the programmer to 
develop refinement trees with desirable properties by providing templates (by means of a context free 
grammar) which the programmer can use to generate the trees. The symbOls of this grammar are prompts 
to which the programmer responds. The programmer s responses to prompts are termed interpretations of 
the symbols . See Figure 2. Both the prompts and their interpretations may have certain semantic attributes. 
However, we shall ignore the semantic aspects of program development here. Grammar FmmDe finition ,[GINS77] 
A cmntext-free grammar+ G = (V,Z,P,S) is a four-tup-le where V is a finite vocabulary, Z is a finite 
terminal vocabularyandZ ~Y; and P is a finite set of production wules of the form X+ awhere Xis in V 
Z and a is i~ V.*,, Sis the start symbol and S is in V Z. Since G has a finite vocabulary it is, by itself, 
imadequa%e for modeling a program refkne ment tree whose node-s may be labeled b,y strings belonging 
to an infinite set --the design language. Hence, we augment the context free grammar as shown below. 
A grammar form is a master grammar that is a template or form for other grammars, that have a similar 
form . The interpretation grammars are obtained by allowing substitutions of terminal serings for terminals 
and nonterminals for nonterminals. See example in Figure 2. Although the substitution of strings of terminals 
for terminals is arbitrary, only distinct non terminals may replace distinct nonterminals. This somewhat 
nonintuitive restriction becomes under­stood only when we examine the shape of the derivation trees. 
The restriction on nonterminal substitution ensures that the interpretation grammars have similar derivation 
trees to that of the master grammar. t It is assumed that the reader is familiar with standard terminology 
dealing with the use of context free grammars for parsing programs [AH077]. More formally a (context-free) 
grammar form G is a four-tuple (G,/~,V,S) where i) G = (V,Z,P,S) is a context-free grammar, ii) M is 
an infinite set of substitutions, and iii) V and S are infinite vocabularies with S : ~. For each u in 
M, a) u(a) is a finite set in S*, a in Z; b) M(X) is a finite set in V-S, X in V-Z; and c) if Xand Yare 
in V-Z where X#Y, then U(X) n P(Y) = 0. We will follow the convention that a grammar form will simply 
be referred to by its underlying grammar G, while M, V and S are understood. An interp?ietation grammar 
G1 = [V1,Z1,P1,S1) of G is a grammar such that i) P(V) =VI ii) U(Z) = Z1 iii) p(V-E) = VI -Xl iv) PI 
~ {p(X) + p(a)+ ~X+ u in P} and v) S1 { p(s). It is important to notice that PI is only a finite subset 
of all possible substitutions into production rules. Also we do not need to use inter­pretations of all 
the production rules in P to obtain P 1. Example of a Grammar Form Description of a Method­ !?@S.Y We 
choose to illustrate (Figure 2) the use of grammar forms by partially describing JACKSON methodology. 
JACKSON techniques for resolving structure clashes can be described using attri­ butes and semantic functions 
which we do not do here.  5. .EXPERIENCE IN U:SLNG GFMD Zn order to umde~stand the Gssues involved 
in creating well tailored ~grammar form .descniptions to the pals., we first restricted ourselves tu 
ageneral problem cat%gory where the = of processing problams an% the ~atterns of their solutions arising 
in practice were well understood. One such processing experience is summarized next. An effort was initiated 
in 1976 by the Manage­ment Systems and Services Division of Westinghouse Electric Corporation located 
at Westinghouse s Tele Computer Center, in Pittsburgh, Pennsylvania [WEST79] to standardize the development 
of data processing programs. Based .on previous data processing experience, nine skeleton programs were 
created as listed in Figure 3. Each skeleton consisted of skeletal control with documentation indicating 
how the skeleton was to-be completed by supplying more code. In two years, approximately 180 pro­grams 
(or 100% o f the division s new programs) were developed using these skeletons. It waa found that the 
use of program skeletons with docu­mentation on how to supply details regarding a specific problem, in 
fact reduced program develop­ment costs in the long run. Of course, there was an initial cost overhead 
involved in teaching the programmers the use of the skeletons. 30 1. <input I structure> <pro ram> 1 
<program body name> <output I sturcture> 4. <program <process b dy name> r description> 2a. <input <partition 
structure> i ascription>* b. <output <partition s ructure> [ ascription>* 5. <initi 1 part> <process 
<process description> I description> <final art> 3a. <partition <partition ascription> ! ascription>* 
b. <partition partition ascription> [ ascription 6,a. <initial initial part> Ipart code b. <final final 
part> I part code 6.c. <process process de cription> i description code Figure 2a. A partial JACKSON 
GFMD. Note that for the sake of conciseness in presenting the grammar form productions, regular expression 
notation (*) is used. Terminal symbols are underlined. These productions (or templates) generate valid 
JACKSON methodology structures and specify some of the techniques for generating the structures as shown 
in Figure 2b. proq wri : master f le update d input .9Awcture: prograrn ~ody me: output st$ueture: transaction 
and master new master file ?odu;:ce;s ,eec paxtikion desc.: partition dese. : initial part: .: final 
~art: par 1ition deser.: transaction master initialize process all finalize product* program products 
progra I I I I partition desc.: partition desc. : initial part: process dese. : inal art: L product* 
product* HLL code HLL code HLL code 1-I [ I partition desc.: par+)tion dese.: pa~~ition dese.: partiti~n 
dese. : match no match i 1 ::&#38;--, , :Pj:; de6c partition desc.: par+z.tion desc.: . . transactions* 
transactions* active inactive Figure 2b. The JACKSON GFMO productions are interpreted in JACKSON notation 
to create the above refinement tree which reflects the methodology pre­ scribed in Figure 2a. The pds 
prompts are in italics and denote the grammar form terminals and non-terminals of Figure 2a. The inter­pretations 
for the non-terminals are in the JACKSON design language where 0 denotes alternatives, * denotes iteration. 
The interpre­tation of each terminal symbol is actual code in some ~igh level implementation language 
(HLL). NAME FUNCTION Extract Table -Selected input records are pro- File cessed and the results placed 
into an incore table. Convert Data -Input records are converted File into records to be sorted. Sort 
Table File -Records from an incore table are used to form records to be sorted. Edit Transaction -Input 
records are subjected to File a number of validation tests which check for format errors. Update Master 
Transaction records are used File to update a master file. Edit Sort File Sorted input records are matched 
with a master file for purposes of validating the input records. Create Detail Using the complete sort 
key Report create a report dealing with the lowest level entity in a hierarchical relationship. Create 
Summary Create a report by stnmnarizing Report one or more lower levels of a hierarchical relationship 
present in a sorted file. Create Detail Jointly produce a detail and and Summary summary report. Report 
Figure 3. Program Design Methodology Skeleton Programs Development of Program Input/Output Steps SELECT1 
data based on membership in an ordered relation SELECTL data based on membership in two different compatible! 
ordered rela­tions SELECT3 data based on membership in two different incompatible! ordered rela tions 
 Figure 4a. Descriptions of the gfmd primitives New gfmd name gfmd SELECT and FABRICATE CONTROL BREAK 
VALIDATE UPDATE Figure 4.b. Combinations of gfmd primitives 32 Our work on isolating fundamental program 
development patterns was initially based on the Westinghouse experience summarized above. Our progress, 
based on an analysis of a variety of programs, is described below. GFMO Primitives The majority of programs 
in the data processing problem category are based on a simple intuitive model of programming -select 
the required data and process it. In fact, JACKSON methodology focuses on describing data first and this 
helps explain the popularity of the methodology in data processing establishments. The select process 
model was exploited in isolating the primitive gfmds listed in Figure 4a, This list is by no means complete. 
The formatting of the output of a program is closely related to the SELECT primitive used in developing 
the program as will be illustrated later. Using systematic combinations of the primitives in Figure 4a, 
four new methodologies were created as described in Figure 4b. These four gfmds develop the same programs 
as the nine skeleton (Westinghouse) programs which, in turn, were used to generate 180 different programs. 
This suggests that the primitives are fundamental in some sense and can be combined in simple ways to 
yield gfmds for precisely defined problem domains in the data processing problem category. Figure 5 illustrates 
how the gfmd primitives, SELECT1, SUMMARIZE and WRITE can be combined to create the CONTROL BREAK gfmd 
(Figure 4b). The control break problem is a stancfard problem in file processing where the hierarchically 
organized input data determines the predicates in the nested iterations which comprise the program body. 
Development of Program Processing Steps SUM3fARIZE1 property of data in a single equivalence class VERIFY 
that,data is correct MODIFY data WRITE data isolated based on a SELECT-PROCESS model SELECT primitive 
gfmd PROCESS primitives SELECT3 SUl@iARIZE1 , WRITE SELECT1 SUWRIZE1, WRITE SELECT2 VERIFY , WRITE SELECT2 
MODIFY, WRITE to form methodologies for processing 180 programs. 1. control br k program> I input file 
name> <process entity> <output structure, I 2. input file name> I storage structure> <entity structure 
name> 3. <entity str cture name> + <nested entity> entity field d scrip tion> 4. <entity field, description> 
, <field name> field des ripticm> <k y?> 5. process entity> I <ini for WH LE <predicate> QQ <process 
nested <use data p ocessed .acc ss ~ use proc ssed entity> entity> for nested entity> iterator> data 
for entity> 6. <process nes ed entity> <process r entity> SELECT1gfmd OUTPUf  7. <output s ructure> 
<printed re ort file> <output file>  8. <printed re ort file>  1 I<report eading> .pagi atiom entity 
name> <print f elds>* higher entity report?> 9. <higher ent ty report> I .entit name> <higher entity 
report> Figure 5a. CONTROL BREAK methodology description using SELECT1 primitive. control break program: 
GENERATE SfiES REPORT 1 (9%: f!~ name: proces! entity: =.,.,.: (see Figure 5.d (see Figure 5 .C I for 
details) for details)1 1 storag structure: entity structure nmne: flat file customer m;~%fls~r entit,y 
stkcture nme: name : orderll lescr. : esj%,m; yes enti tu strt!cture me: $armunt no z e M descr. : 
iekl descr. : E ield name: quantity ie ld deem. : key ?: no Figure 5.b. The interpretation details for 
input file name. Annotations for Figure 5.b. 1. The user is prompted by the pds with the grammar variable 
input file name: . The riser supplies an in terpretaion sales file . If the structure of the sales file 
has bee defined in a data dictionary much of the remainder of the refinement tree for this node could 
automatically be generated by the pds with the ap approving or disapproving as the tree is generated. 
 2. TWO points of clarification are. needed at this point in the tree. The most significant is the ability 
of the grammar farm model to simplf y derivational sequences. For example, A + B + C can be shortened 
to A~C. In this case A is entity structure name, B is entity field description, and C is field nom?, 
field desc?., keq?. The second point concerns the way we drew the refinement to save space, i .e. , 
 field name: field descr. : is equivalent to fie d me: field !ieecr . : k ?:. L key ?: 3. The interpretation 
at this point is skipped as a means of simplifying tbe diagram.  An inter­ 4. The ap interpretation 
of yes is used by the system to generate another production. pretation of no would prevent the generation 
of a further refinement as occurs in the lowest level of this figure. output tructure (cent d from Figure 
5 .b) : output ~file?: no ~rinted r port file?: yes I higher entity~ report?: PepO1>theadin,q : pcmgin! 
at ion: entitzy nmc: order &#38;K::@ %!!.: yes :@; printlfield: printl field: higher ent]ty report?: 
entit. name: customer order count E$amOunt yes I printi fie2d: printi field: higher entity r~port?: 
enti t,y name: sales file order count E$amount no Figure 5.c. The interpreted refinement tree for the 
output structures. Annotations 1. Report heading and pagination details were omitted in the hope of 
simplifying the figure. 2. The interpretation item count causes process code to be generated which 
counts the number of items.  process entity: (cmt d from Figure 5 .b) sales file initialize for enti 
t,q: NH LE predi ate: O process n . ted entity: use data processed _ SET EOF FOR SALES FILE not end of 
CUSTOMER for nested entity: READ FIRST REC sales file ORDER COUNT E$ANOUNT INITIALIZE ALL TEMPORARIES 
 use processed data for entity: 6)PRINT ORDER COUNT Z$AMOUNT initialize Ifor entity: WHI!LE predi~atr: 
&#38; process m s ted entity: use datalpmcessed &#38; SWITCH OLD CUSTOMER{), not end of OBOER for nested 
entity: NEW CUSTOMER#; customer Z 1 Z$ANOUNT @ INITIALIZE ALL TEMPoRARIES EXCEPT SALES FILE , TEMPORARIES 
 use processed data for entity: @ PRINT ORDER COUNT, Z$ANOUNT initialize for entity: WR LE predi ate: 
&#38; process nested entity: use data iproeessed SWITCH OLD OROER#, not end of NO for nested entity: 
NEw ORDER#; order entity Z 1 2$ANOUNT @ INITIALIZE ORDER TEMPORARIES I access itervztm:use J for OD 
procesood ta entity: READ NEXT REC PRINT ITEM COUNT, Z$AMOUNT Figme 5.d. The interpretation details 
for the body of the control break program. Annotations 1. Information formed bile processing the entire 
sales file (i. e., all the customers) is used at this point. This ammmts to printing a summary for the 
entire sales file.  2. 81 represents te rminal code for the counting of the number of orders.  lZ$AMOUNT-represents 
the terminal code ceded to win up the dollar anr.x t jnst formed for the order. The accmnulative effect 
of thi* statement in the customer loop is to produce the total dollar amount for each customer. 3. As 
in comment 1 the waler count and dollar ammmt can be printed but in this case it is for each customer 
ot the entire sales file.  4. 11 at this le el counts the number of items in each order.  Figure 5a 
gives the templates for developing programs using the CONTROL BREAK methodology. The SELECT1 gfmd, illustrated 
in Figure 5a, consists of templates which channel the development process in order to describe, as shown 
in Figure 5b, the hierarchical structure present in data. The remaining SELECT1 gfmd templates develop 
the control structure, as shown in Figure 5d, necessary for selecting the data to be processed. The non 
terminals <use data processed for nested entity> and <use processed data for entity> should be interpreted 
using a SUMMARIZE process as illustra ted in Figure 5d. (This interpretation could be, enforced by the 
semantic aspects of the methodology and is ignored here.) Generally speaking, the SELECT gfmd primitives 
dictate the control struc­ture of a program. The PROCESS primitives are embedded into this control structure. 
In the case of the CONTROL BREAK gfmd, the PROCESS primitives (too simple to describe using templates 
here) are SUMMARIZE and WRITE. Figure 5d gives the develop­ment and interpretation of the body of the 
program. Figure 5C illustrates the use of the output struc­ture templates to specify the points in the 
nested iterations of the program control structure where the WRITE statements are to be inserted. The 
formatting of the output is dictated by the control structure of the program body which in turn is dictated 
by the SELECT1 primitive. Combinations of gfmda for Program Development Fairly complex programs can be 
developed using the four gfmd s, given in Figure 4b, in some sequence. To use these gfmd s in sequence, 
however, a linking mechanism must sometimes be inserted. One such mechanism is illustrated (Figure 6) 
using another standard problem which is taught in a technique oriented file processing course at the 
Computer and Information Science Department (The Ohio State University). The problem is described next. 
Two files are to be processed. The first file consists of orders for products placed by customers and 
comprises the transaction file. The second file consists of the products stocked by the company and is 
called the product master file. This problem is a version of the familiar validation of a transaction 
file using standard data stored in a master file. The results of this validation should produce two reports 
--an exception report which contains error messages as well as some summary data, and a valid transaction 
report which lists valid transactions and summary data for the valid trans­actions. An output file containing 
records formed by adding master data to each transaction record is also produced. The transaction file 
in the specific problem contains lines from sales orders arranged so that all the orders for a particular 
product appear together in the file. This was accomplished by sorting the original order file with product 
number as the primary key. The master file contains product information. See Figure 6a. TWO methodologies 
--the VALIDATE (given in Figure 6b) and the CONTROL-BREAK are linked to develop the refinement tree for 
this problem. We call this new methodology the VALIDATION REPORT . The =struction of the VALIDATION REPORT 
gfmd is given in Figure 6c. The VALIDATE gfmd guides the programmer into developing a program which reads 
each transaction record, verifies and marks it with an error code, and then writes the transaction onto 
a temporary file. The SORT program, or the linking mech­anism, inputs the error coded transactions and 
orders them according to valid or invalid, and error type. This hierarchically organized data is the 
input to the CONTROL BREAK program which prints out the required summary reports. The details of the 
actual development are obvious and are not given here. Conclusions Drawn From a Preliminary Analysis 
of Student Programs Fourteen different student programs for the VALIDATION REPORT problem described above 
were collected. The programs were written by computer science majors taking a second course in PL/~ and 
were acquainted with structured progra~ing techniques. Prior to assigning the problem, JACKSON methodology 
was discussed and its use was required in developing the program turned in. In order to analyze the programs, 
the problem specifications were re-written (Figure 7) in terms of a) relationships present in data that 
must be considered by the program control struc ture in order to select data and b) processes that must 
operate on the selected data. We assume that the success of a process depends on two factors a) correct 
implementation statements for the process-on and b) the placement of the implementation statements of 
the process at correct points in the control structure of the program. Our observations are summarized 
below. <transaction <master file> file> Product Order Data Data [Q VALIDATION REPORT Extended Transaction 
File  CT Figure 6a. Validation report problem. validate program> II 1 1. program <output> <define files> 
body> SELECT2 gfmd 2. <define files> I name oft transaction <name of master file> file>  4. name of 
ma ter file> II 3. .mxne of trans ction file> .tkey> key ord ring> <mke y > key ord ring> 5. .progra 
body> I .i itial part> NHILE <~ EOF Iin D!3 <form validation un!t and process it> Q_ <final Part> transaction 
file> 6. <form validation un t and process it> F .tkey~ rekey> ~ flush aster> ~ deal with tr nsaction> 
 deal transaction> I 7. &#38;lush master> 8. with  I I <read hew &#38; .tkey~mkey> &#38; <no m tch> 
EI!SE aa~ch> <process un-needed master> master>  9. <no m tch~ NH LE <same trans ction key> ~ .no mat 
h process> <read next t ansactiOn> L  10. match ppcess> 1  ~ same transaction key> ~ <validation process> 
<read next transaction> ~ Skeleton VERIFY efmd 11. validation process> I I+ single record tests?> 12. 
<single record test?> I1  IF field i of .relat[ional .field[j of ~ <mark !rror ~ valid process> transaction> 
operator> master> transact ion>l I Figure 6.b. VALIDATE gfmd UsinS SELECT1 and VERIFT Primitives VA. 
.n. m.n., .-- . -. . pro am I I validate program sort control break [program VALIDATE gfmd CONTROL 
BREAK gfmd I validate program  control break program code for sorting output file of VALIDATE [ El 
a [ Figure 6.c. VALIDATION REPORT methodology sing VALIDATE and CONTROL BREAR gfmds, 36 1. Transaction 
file is an ordered relation. the order is ascending by Product Number, Order Number, and Line Number, 
 1.1 There ca be several transactions for each product in the transaction file. 2. Master file is an 
ordered relation. The order is ascending by product number, 3. Partition transactions into valid transactions 
and invalid transactions. 4. Partition invalid transactions by error type.  Figure 7a. Relationships 
to be Considered in Validation Report Problem. 1. Validate transaction product numbers. 2. Validate 
transaction unit prices. 3. Form valid transaction report summaries. 3.1 z of valid transaction quantity 
fields. 3.2 Count the number of valid line items. 3.3 z of valid transaction dollar amounts. 4. Construct 
and output an extended record for each valid transaction record (record type 5) . 5. Construct and output 
two extended records for each invalid transaction record. (One record type 5, the other record type 
O.) 6. Generate 1 line for the valid transaction report for each valid transaction. 7. Generate 1 line 
for the exception report for each invalid transaction. 8. Form exception report summaries.  8.1 Z of 
invalid transaction quantity fields by error type. 8.2 Count the number of invalid line items by error 
type. 8.3 z of invalid transaction dollar amounts by error type. Figure 7.b. Processes Requirements in 
the Valida­tion Report Problem. Control Structures of Programs As expected the control structures of 
all the sample programs were entirely dictated by the need to select data based on relationships 1 and 
2 (Figure 7a.) in the input file. How­ever, there was a wide variation in the details of the control 
structures used. A large variety of correct ways of implementing the selection of data was actually reflected 
in these 14 programs. While all the students provided the needed outer loop shown in Figure 8a., a major 
variation occurred in the control structures used within the body of this outer loop to identify the 
three major program branches which are: 1) TKEYWIKEY, 2) TKEY+!KEY, and 3) TKEY=MKEY. These branches 
were defined using NIFT, statements as in either a nesting of Figure 8.b. or a linear sequence of IF 
state­ments as in Figure 8.c. A second major varia­tion in the control code dealt with the use of a loop 
(no match loop, see Figure 8.d. ) within the TKEY+fKEY branch and/or the use of a loop (match loop, see 
Figure 8.e.) within the TKEY= MKKY branch both of which implement the multiple transactions per product 
relationship (1.1 in Figure 7a.). Using the nesting or lack of nesting as variable 1 and the presence 
or absence of the match and no match loops as variable 2, Figure 8.f. defines 8 categories of control 
code and a count of the number of student programs occuring in each category. Hence, based on the preliminary 
study, we find that even if a methodology such as JACK-SON is followed by the students, there is a large 
amount of variation in the control structures of the resulting programs. Actually, JACKSON methodology 
attempts to provide more explicit guidance for develop ment than many other general purpose methodologies. 
/READ first T kc and i-f Rec A %WSILE loop body --T A b Figure 8a. Common Outer Loop in Student Programs 
TKEY<IWEY TKKY=MKEY branch branch I =./ 1 Figure S.b. Nested IF Approach to Branch Identifi­cation TKEY 
T > EY TKXY>MXXY branch % *. ekI TKEY T NKEY TKEY=NREY branch Figure 8,c, Linear IF Approach to Branch 
Identi­fication 37 Setup loop predicate B WSILE No T same match product process J 43 IF 1 Read next 
msc u Figure 8.d. No Match LOOP Found in TSSY<MKEY Branch of Some Programs Set up loop predicate Q Read 
Next /3 Figure 8.e. Match Loop Found in TRRY=MKEY Branch of Some Programs Figure 8.f. Count of Student 
Progzams by Control Code Category. Success of Processes Recall that in order to successfully realize 
 a required process specification the implementa tion statements must be correct and the statements must 
be correctly located or embedded in the control structure of the program. A large number of the programs 
did not successfully realize all the processes called for by the specifications. In the study we concentrated 
on implementation and location errors and ignored errors which appeared to be caused by imprecise problem 
specifications. The major causes for the incorrect imple­mentation of a process were 1) missing a required 
statement(s), or (2) using an incorrect operator(s) and/or operand(s) within a statement. The major causes 
for the incorrect placement of process implementation statements in the control struc­ture were 1) process 
code located in the wrong branch(s), or 2) incorrect placement of process code in relation to a loop 
structure, or 3) missing branch, i.e. , predicate missing from the control code. From the tabularized 
results in Figure 9, it is evident that most implementation errors were caused by the omission of statements. 
Because in many cases the student was able to successfully implement a similar process we feel that the 
reason for missing processes was failure to understand the problem specifications. From the tabularizes 
results in Figure 9, we conclude that students appear to make more errors in the placement of a process 
than in its actual implementation. That is, even though the control structure in the program is correct, 
the process statements were placed incorrectly. 6. CONCLUSIONS Our collective programming experience 
points to the existence of patterns of programming though few attempts have been made to systemati­cally 
identify these patterns. Based on the Westinghouse experience we claim that in fact patterns of programming 
exist in the data pro­cessing area and exploiting these patterns to provide the programmer with improved 
support results in reduced development costs and improved maintainability and reliability. We have shown 
that the grammar form model presented here is, in fact, adequate to encode methodologies for channeling 
program development in order to re-create programming patterns in well defined problem domains. A few 
methodology encodings are adequate to guide program development for a large variety of programs. This 
is because each methodology is flexible enough within the problem domain, and, in addition, methodologies 
can be combined in systematic ways. Based on a preliminary analysis of student programs we find that 
a) general methodologies are not very successful in limiting the design choices and hence there is a 
great amount of variation in the resulting correct control structures of the programs, b) more errors 
are made in the placement of process implementation statements within the control structure of the program 
than in the actual imple­mentation of the process. As we have illustrated using the CONTROL BREAK and 
VALIDATION RRPORT methodologies, grammar forms are very successful in channeling program development 
so that a specific control structure for the program is developed. The correct points in this control 
structure where specific process statements could be located are also marked and are used to guide the 
programmer in correct placement of processes. The implementa­tion details of the processes themselves, 
in 38 many cases, are left to the programmer. However, this is errors. verifying where More our the 
programmer makes the least extensive controlled experiments claims above are currently in progress. Obviously, 
implementations for a exist. given problem many correct Existing methodologies attempt to discipline 
program development so that there are fewer variations in the implementation of a given problem. This 
promotes ease of maintenance and reliability. Here we advocate the use of methodologies for precisely 
defined problem domains. We show that such methodologies generate a specific control structure for a 
problem. In addition, the methodologies guide the placement of the process statements. We expect such 
tailored methodologies to channel development so that there can be very few possible implementations 
for a gitien problem. This should facilitate program maintenance and reliability even more than general 
purpose methodologies. Finally, a precise model for encoding program development methodologies facilitates 
automation and system enforcement of standardized program development. Whilethesarne standardi zation 
can be attempted through education, such an attempt probably will not be as effective. This is because 
the programmer may not recognize a standard pattern of development as such until much effort has been 
expended. We also expect a system driven by precise, domain oriented methodology descriptions to be more 
effective since the responses of the system will also be domain oriented and hence more intuitive for 
the programmer. 7. ACKNOWLEDGEMENT The authors would like to acknowledge the valuable assistance provided 
by Lucy Wright in analyzing programs and tabulating data. Process Number Where Successful of Programs 
the recess Was Unsuccessful  Reasons I@ 1 : c Fa zion 3 ur  >f . i yQ ca ~ Ss Y­. 1. VALIDATE 
Numbers Transaction Product o 2. VALIDATE Transaction Unit Prices 0 3.1 Z of Fields Valid Transaction 
Quantity 6 8 2 1 1 2 3.2 Count Items of the Number of Valid Line 6 8 2 2 4 3.3 X of Valid Amounts Transaction 
Dollar 6 8 2 2 2 2 4. Construct Record for and Output Each Valid an Extended Transaction 13 1 1 5. Construct 
Records action and Output 2 for Each Invalid Extended Trans­ 13 1 1 6. Generate 1 Line of Transaction 
Report Valid Transaction the for Valid Each 8 6 2 4 7. Generate 1 Report for Transaction Line Each of 
the Invalid Exception 10 4 2 2 8.1 E of Invalid Transaction Quantity Fields by Error Type 3 11 4 1 6 
8.2 Count Line of the Number Items by Error of Invalid Type 6 8 3 1 4 8.3 Z of Invalid Amounts by Transaction 
Error Type Dollar 0 14  14 Figure 9. Results of Student Program Study 8. 2EFERENCES [RAMA79] Ramanathan, 
J. and Blattner, M., [AH077] [BALZ79] [BARS79] [CHEA79] [DOD80] [FLOY72] [GINS77] [JACK75] [JENS75] [KENN79] 
[LIsK77] [POPE77] Aho, A. V. and Unman, J. D., Principles of Compiler Design, Addison Wesley, 1977. Balzer, 
R. and Goldman, N., Principles of Good Software Specification and Their Implications for Specification 
Languages, Proceedings of IEEE Conference on Specification of Reliable Software, Cambridge, MA, April 
1979. Barstow, D. R., Knowled8e-Based Program Construction, Programming Language Series, T. E. Cheatham 
(cd), The Computer Science Library, North Holland, 1979. Cheatham, T. E., Townley, J. A., and Holloway, 
G. H., A System for Program Refinement, Proceedings of the 4th International Conference on Software Engineering, 
Munich, Germany, 1979, pp. 53-62. Stoneman Environment Requirements, Department of Defense, February 
1980. Floyd, R. W., Toward Interactive Design of Correct Programs, IFIP Conference, 1971, Amsterdam, 
The Netherlands, 1972, pp. 7-10. Ginsburg, S., A Survey of Grammar Forms -1977, Sixth Int 1 Symp. on 
Math Foundations of Computer Science, TatranskaLomnica, Czechoslovakia, 5-9, 1977. Jackson, M. A., Principles 
of Program -~ Academic press, New yOrk, 1975. Jensen, K. and Wirth, N., PASCAL User Manual and Report, 
Springer-Verlag, New York, 1975. Kennedy, K. and Ramanathan, J., A Deterministic Attribute Grammar Eval 
uator Based on Dynamic Sequencing, ACM Transactions on Programming Languages, July 1979, Vol. 1, No. 
1. Liskov, B., Snyder, A., Atkinson, R. and Schaffert, C., !Abstraction Mechanisms in CLU, CACM 20, 8 
(August 1977), pp. 564-576. Popek, G. J., Horning, J. T., Lampson, B. W., Mitchell, J. G., and London, 
R. L., Notes on the Design of EUCLID, Proceedings of an ACM Conference on Language Design for Reliable 
Software, Ed., D. B, Wortman, March 1977. [ROMA77 ] [ROSS77] [SHAW77 ] [STAy761 [TEIC77] [TEIT80] [TEIT77] 
[WARN74] [WEST79] Program Forms and Program Form Analysis, AFIPS Conference Proceedings for the National 
Computer Conference, New York City, 1979. Roman, Gruia-Catalin, An Argument in Favor of Mechanized Software 
Production, IEEE TSE, Vol. SE-3, No. 6, November 1977. Ross, D. T. and Schoman, K. E., Jr., Structured 
Analysis for Requirements Design, IEEE Transaction on Software Engineering, Vol. SE3, No. 1, January 
 1977. Shaw, M., Wulf, W. A., and London, R. L., Abstraction and Verification in Alphard: Defining 
and Specifying Interaction and Generators, Communications of the ACM, August 1977, Vol. 20, No. 8. Stay, 
J. F., HIP~and Interactive Program Design, IBM Systems Journal, 1976. Teichroew, D. and Hershey, E. A. 
III, PSL/PSA: A Computer-Aided Technique for Structured Documentation and Analysis of Information Processing 
Systems, IEEE Transactions on -Software Engineering, Vol. SE-3, No. 1 January 1977. Teitelbaum, T. and 
Reps, T., The Cornell Program Synthesizer: A Syntax Directed Prograrmaing Environ­ment, Department of 
Computer Science, Cornell University, Ithaca, N.Y., 1980. Teitelman, W., A Display Oriented Programmer 
s Assistant, Xerox Pare, March 1977. Warnier, J. D., Logical Construction of programs, Van Nostrand, 
New York, 1974. Westinghouse Corporation, Program Design Methodology Evaluation Survey, Pittsburgh, PA, 
1979.  
			
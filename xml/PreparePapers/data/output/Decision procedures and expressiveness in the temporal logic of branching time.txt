
 I)ccision lhocedares a id Expressiveness in (he Teml)or:tl l,ogic of I~ranching Time E. Allen Fmerson 
I and Joseph Y. llalpern 2'3 1. Computer Sciemes Dept., Univer~io' cJ'Tc.n;~; Ausliu, T,Y7,£712 I hilt 
Laboratoo'tS)rCumlmtcrScience, Cambridge, MA02139 3. Aikeu Conll)llh?lion I.at,oratoo; Harvard UuiversiO; 
Cambridge, MA02138 Abstr(.cl: In this paper we consider tile Col]q)Uhlti~ii Tree l.ogic (CTI.) proposed 
in [CF.] which e:,tct!ds the Unified Ihandting Time logic (UI0 ~f [BMP] by adding an uutil operator. 
We cslahlish that C fl. has the small property hy showing thai any satisfiable CTI. fi.)rmulac is sati 
;fiahle in a snlall finite model obtained flom a small "pscudo-modeV resulting fi'om tile Fischer. l.adt~er 
quotient conslruction. We then give ;m ~:xponcntial lime alg,uithm Ibr deciding satisfiahility in CTI., 
and extend the axiomatizatiou of UB given in [BMI'] to a complete axiomati/;ition fi)r CII.. I.asIly, 
wc study tile relative expressiv~ power of a family of temporal logics ohtaincd by extending or restricting 
the syntax of UB and CI'L. I. Inlroduclion Temporal logic is a forrnalic.m for reasoning al)out corrcctllCSS 
properties of concurrent programs ([Pn], [I.a]). In pr2ctice, it has been found usefid to have an until 
operator p U q which asserts that q is bound to happen, and until it does p will hold (cf. [GPSS]). In 
this paper we consider file Computation Tree logic (CTI.) proposed by Clarke and Elllel'SOll [CI:,] which 
extends the Unified Branching Time Logic tUB) of Beth-Ari, Manna, and Pnucli [BN1P] by adding such an 
tmtil operator. We give an exponential time algorithm for deciding satisfiability in CTI., and extend 
tile axiomatization of UB given in [BMP] to one for CTL. 'lqm first author was partially supported by 
NSF Grant NICS79-08365. The second author was partially supported by NSF Grant b1CS80- 10707 and a grant 
from tile National Science and I:ngineering Research Council of Canada. Permission to copy without fee 
all or part of this material is granted provided that the copies are not made or distributed for direct 
commercial advantage, the ACM copyright notice and the title of the publication and its date appear, 
and notice is given that copying is by permission of the Association for Computing Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. &#38;#169; 1982 ACMO-89791-067-2/82/O05/0169 
$00.75 Our first step is tt, establish that CI'I. has the small model property: if a formula is satisfiable, 
then it is satisfiable in a small finite model. The standard way of proving such results for modal logics 
is to "collapse" a (possihly inlinite) model by idcnti~'ing states according to an equivalence rclatiou 
&#38;small finite index, and then showing that Ihe resulting finite quotient structure is still a model 
for the formula in question. This technique is used, for example, by Fischer and 1.adncr to show that 
lq)l. has the small model pli)l~i'rty (of. [[:l ]). We ,>how that any n~eth~,d of Iiying to phro~e the 
small m,>del p:opcvly direclly by using a qm)licnt COIIStl'tlclioI1 IllllSt fail when aM)lied to I J 
B or C I'l.. I h)wever, wc can also show thai Ihe ):ischcr.I adncr quotient >,lructur¢ ohtained flom 
a CTI. model may be ~,icwed as a :;mall "pscudo- nlt)dcl" wh)d~ contains enou?,h hlfi)rnlation to he 
Ll,l\%Otllld into a genuine (and still small} model. Both our ,dgorilhnl for dcchling satisfiahilith, 
and ot:r completeness proof are based on tryiug to coup;truer this i)scudo-modcl. Our approach is ?;itnilar 
to that u,~ed in [BIll' I to shov, the corrc:q~onding results for I)1'1)1., v, hich sug~,ests that the 
p~,cudo-model phel~omenon may be a general one which is applicable to a xaricty of temporal Jogics. We 
Ihcn reprove these results by using the fixpoint characterizations (cf. [EC]) of the temporal operators 
to construct a tableau which rnay itself be considered a small pseudo-model. Our first nlethod Call be 
viewed as a "top-down" hi,preach, ~hile tile tahleau mcllmd is "bottom-up". Although hoth decision procedures 
given have the same worst-case complexity of c×poncntial time (which is provably the hest we can do), 
the tableau incthod is likely to be hotter in practice. (Another tableau-based algorilhm [br s;iti>fiability 
in UB was proposed in [BM I']. l towever, that algorithm claims that certain satksfiable fommh/e arc 
unsatisfiable. I~en-Ari [BA] states that a corrected version is Ibrthcoming.) We also study fl3e expressive 
power of temporal logics obtained by 169 extending or restricting UB. In UB a path quantifier, either 
A ("tbr all 5. If p is a path finmula then Ap is a state formula (which says all paths satisfy p). paths") 
or E ("for some path"), is always paired with a single state quantifier, either F ("for some state"), 
G ("for all states"), or X ("for the next state"). Thus, the UB syntax allows the assertions EFp ("for 
some computation path, there is a state on the path where p holds") and I'Gp ("for some computation path, 
for all skates on the path, p holds"). If we extend the syntax to allow ,~';sertions such as E[l:p A 
Gq] ("for some computation path, there is a state on the path where p holds and for all states on that 
same path, q holds") where a path quantifier is paired with a Boolean combination of state quantifiers, 
we obtain the language we call UB +. Similarly, CI'L + is obtained hy extending CTI, to allow a path 
quantilier to prefix a Boolean combination of the state quantifiers t=, G, X or U. Finally, UP, is obtail;ed 
by restricting the UB syntax to allow only the pairs EX and EF (AG and AX can be obtained by negation) 
and corresponds to the nexttime logic of Manna and Pnueli [MP]. We show that these kmguages om be arranged 
in the following hierarchy of expres:,ive power: UB- < UII < UB + < CTL _= CTL +. The rest of the paper 
is organized as fi)llows: Section 2 gives the :syntax and semantics of CTI, + (and by suitable restriction, 
of all the other languages). Section 3 shows why quotient constructions must fail for UB and CI'L and 
defines the technical machinery of llintikka suuctures (cl: [BMP]) and pseudo-Hintikka structures necessary 
for our constructions. In Sections 4, 5 and 6 the first proofs of the small model theorem, the decision 
procedure, and completeness of the axiom system, respectively, are given. These results are reproved 
in Section 7 using tableau techrriques. Finally, in Section 8 we give our expressibility results. 2. 
Syntax and Semantics 2.1 Syntax: We define below a language which extends UB and CFL in order to provide 
a fl'amework for the expressiveness results of section 8. We start with a set of primitive (or atomic) 
formulae ~0 = {P,Q,...}. We then inductively define a class of state formulae and a class of path formulae: 
1. Each primitive formula is a skate fonmda. 2. lfp, q are state formulae, then so are (p A q)and ..rip. 
 3. If p is a state formula, then Fp and Xp are path formulae (which intuitively say that at some state 
(resp. the next state) on the path p holds). 4. If p is a path formulae then El., is a state fnnnula 
(which says some path satisfies p).  6. If p, q are state formulae then (p U q) is a path formula (which 
says there is some state on the path which satisfies q, and all states betbre it satisfy p, i.e. p holds 
untdq). 7. lfp, q are path formulae, then so are p A q and ..rip.  We use the abbreviations p V q for 
~(~p A -nq), p =, q for "~p V q, p -~ q for (p ~ q) A (q ~ p), and Gp for ~F~i). The size of formula 
p, written IP], is its length over the alphabet {-,,A,(,),E,A.F,U,X} O~ 0. The state formulae generated 
by rules l-4, rules 1-5; and rules 1-6 correspond exactly to UB, UB, and CTL, respectively. Define UB 
+ to be the state formulae generated by rules 1-5, 7 and CTI, + to be the state formulae generated by 
rules 1-7. 2.2 Structures: A structure M = (S,L,R) consists of a set S of states, an assignment L of 
formulae to states, and a binary relation R C_ S X S. (Think of I,(s) as the formulae true at state s). 
A path is a sequence (s o, s 1, ...) of states such that (s i, si+l) 6 R that is maximal (i.e., either 
infinite or whose last state has no R-successor). We can view a structure as a labelled directed graph 
whose nodes are the states. Node s is labelled by the formulae in L(s), and there is an arc from s to 
 t iff(s,t) 6 R. The size of a structure M = (S,L,R) is the cardinality of S. 2.3 Models: Given a structure 
M = (S,L,R), we want to define the notion of trulh in M via the relation I=. Given a state s (resp. path 
x) in M, and a state forumla p (resp. path formula p') we write M,s I== p (resp. M,x I-= p'), which lneans 
p is true of state s (p' is true of path x) in M. We define f= inductively as Ibllows: M1. For a primitive 
fommla P, M,s I== P iffP 6 L(s). M2. lfp, q are state formulae, M,s I= p A q iffM,s ~= p and M,s I== 
q; M,s I= ---ap iff bl,s I e= p. M3. Ifx = (So, sl,... } is a path, then M,x ~= Fp iff for some s i on 
x, M,s i I= p: M,x I== Xp iff M,s I I= p. M4. M,s ~ Ep if for some path x starting at s, M,x l=: p. M5. 
M,x I== Ap if for all paths x starting at s, M,x I== p. M6. M,x I= (p U q) if for some initial prefix 
(s0,...,sk) of x, M,s k I= q and M,s i I= p for all i < k. M7. lfp, q are path forrmdae, M,x t-.= p A 
q iff M,x I= p and M,x I= q; M,x ~ -3p iffM,x ~ p. A model is a structure M = (S,I,,R) such that R is 
total and for all states s 6 S and all state formulae p, M, s I== p iffp 6 l,(s). Note that in a model 
M = (SJ,,R), L is completely determined by the primitive formulae in Its).  2.4 Remark: For technical 
reasons, we have used L here, an assignment of forlnulae to states, rather than tile InOle usual rt, 
an assignment of states to fommlac (cf. [BHP], [BMP]). It is easy to see that this slight change does 
not affect any of the results. Of COUl'Se, I= is still defined in the usual way. We also follow [BMP] 
and ICE] in requiring that in a model R be total. This restriction can be removed without affecting any 
of the main theorems (cf. Section 6.3) 2.5 I}efinition: A state formula p is satisfiable (rcsp. valid) 
iff for some model (rcsp. all models) M = (S,I.,R) and some (resp. all) s E S, M,s I= p. Similarly for 
path fommlae. We write I= p if p is valid. Note that p is satisfiable iff~p is not valid. The following 
lemma shows that the temporal operators may be viewed as fixpoints of appropriate fimctionals (see [EC]). 
For example, EFp is a tixpoint of f(z) = p V EXz. This forms the basis of flae tableau construction of 
section 7. 2.6 Lemma: '1'he lb!lowing fonnulac are valid: 1. ~-Fp ~ (IrueU p) 2. I= hl:p ~ p V EX(I!I:p) 
 3. I= AFp ~ p V AXAFp 4. t--= F(p U q) ~ q V (p A EXE(p U q)) 5.~ A(pUq)_=qV(pAAXA(pUq)). Proof: 
hnmediate from the definitions in 2.3. N{}te that hy part l, it fifllows that 2 and 3 are just special 
cases of 4 and 5 obtained hy taking p to be Irue, We include tile special cases for UB here and in future 
lemmas and theorems just so that it is clear how to modify our results for CII. so Ihat they also hold 
for UB, II For the next five sections we focus our attention on LIB and CTI.. 3. llinlikka Slructttres 
anti the Quotient Construclion 3.1 I}cfinitinn: A tlintikka structuw (for P0) is a structure M = (S,I.,R) 
with R total (and P0 E I.(s) for some s E S) wllich satisfies the following constraints: HI. ~p E l.(s) 
~ p ~ l.(s) 1-I2. m"np 6 l.(s) ~ I) E l.(s) H3. p A q E l.(s) ~ p,q E L(s) H4. "-n(p A q) E I.{s) =¢. 
~p E I.(s) or ~q E l.(s) tt5. l:.]:p {7 I.(s) =* p C I (s) or ;{XH:p C l.(s) H6. -nl:JCp (l.(s) =¢, "-,p, 
-nF.XI!Fp C l.(s) H7. AFp E I.(s) ~ p C l.(s) or AXAVp C l.(s) HS. mAl:p E I.(s) ~ --np, "nAXAFp C l.(s) 
H9. E(p U q) E l.(s) ~ q E 1.{s) or p, EXE(p U q) E Iris) H10. mli(p U q) E I.(s) ~ ~q, ~p E l.(s) or 
~q, ~EXI'2(o U q) £ L(s) H1 l. A( 13 U q) E l.{s} =~ q E l.(s) or p, AXA(p U q) 6 1.(s) f112. "nA(p U 
q) E L(s) =~ "nq, "rip (L(s) or ..nq, ~AXA(p U q) E l,(s) 1113. EXp E 1 (s) =,~ 3t((s.t} E R and p E 
l,(t)) HI4. -nEXp £ l.(s) =* Vt((s,t) E R =* ---,p E l.(t)) t115. AXp E l.(s) => Vt((s,t) E R ~ p £ L(t)) 
t116. ~AXp £ I.(s) -~ 3t((s,t) E R and --,p E L(t)) I t 17. EFp E L(s) =~ for some path x starting at 
s and some state t on x, p E l.(t) H18. AFp 6 l.(s) => for all paths x starting at s alld some state 
t on x, p ({ L{t) 1 I19. E(p U q) £ 1_(~,) ~ lbr some path x starting at s, some state t on x, and all 
states t' before t on x, q E 1t0 and p E l.(t') 1120. A(p U q) £ L(s) ~ for all paths x starting :at 
s, for some t on x and all states t" hcfine t on x, q E 1..(t) and p E l.(t'). 3.2 l'rOlmsition: (cf, 
[BM1L Theorem 1]). A model for p is a Hintikka structure for p. Conversely, a Itintikka structure (S,I.,R) 
can be extended to a model (S,I .',R), where 1.(s) C_ l.'(s) for all s 6 S. 3.3 l}efinition: We define 
the generalized Fischer-l.adner closure (cf. [FI.]) of a CTL formula P0, written FL(P0), as the least 
set of formulae t l containing P0 such that 1. --npEIf=,p6lI 2, pAqEtt~p, qEH 3. EFp C H => p, F.XEI:p 
E It 4. AFp C It ~ p, AXAFp E tl 5. E(pUq) Ett~q,p,F.XE(pUq)EH 6. A(p U q) C It =~. q, p, AXA(p U 
q) C H 7. EXpCH=~i 3EH 8. AXpClI~pEH 9. p E H, p not ofthc form ~q =a. ~p E H.   3.4 I,emnm: (cf. 
[1:1.], [BMI'], [BHP])/Fl.(p) I ~ 21pl. Proof: An easy induction on ]p[ shows that file least set closed 
under rules 1-8 has size < IPl. Closing off under role 9 at most doubles the size of the set. II 3,5 
The Quotient Construction: One elegant way to establish that a propositional temporal logic has die small 
model property is to use a quotient construction. 12t M = (S,I.,R) he a model of p, let H be a set of 
fommlae, and let ~1t be an equivalence relation on S defined via  st ~11 s2 iff for all q E IL M,s 1 
I= q iff M,s 2 ~ q. Use [s] to denote {t 6 S[ t ~.ll s}. Then tile quotient structure of M by ~11 is 
defined to be tile stnlcture M/~ii = (S',I/,R') where S' = {[s]l s E S}, R' = {([sl,[t]}l (s,t) E R}, 
and L'([s]) = L(s) f-I 1t. We remark that although ]Fl.(p)] ..< 2]p], fllere are at most 21°1 ~I"I.Q)}equivalence 
classes. l:ischcr and I.adner showed that for a PD1. lbrmula p, if M is a model for p, then M/~i..14p) 
is a tlintikka structure for 13 with the property that satisfiability is preserved fi?r formulas in Fl.(p); 
i,e. for 171 q 6 Fl_(p), M,s ~= q iff M/~_-.Fi q)).[s] I== q. Unfortunately no such quotient construction 
will directly show that UB (or CTL) has the small model property. The fi)llowing theorem is analogous 
to those in [Prl, St] showing that the property of h)oping is not expressible in PDI ,. 3.6 Theorem: 
For a finite set H of UB (or CTI,) formulas, the operation of fonning the quotient structure by ~-11 
does not preserve satisfiability for the formula AI:P. In particular, thcrc is a model M which satisfies 
AFP such that lbr every finite set It, M/~it is not a I lintikka structure for AFP. Proof: Note that 
in the structure depicted below, whcre M,s 0 I-- P and M,s i I:= --rip for i > 0, wc clearly have M,s 
i 1= AFP for all i > 0:   ~, ~ ,- ...< < ..-,~ ~ ~ ...  ,6, S¢ S d Yct, if H is any finite set, we 
must have s i ~lt sj for some i > j > 0. Tiros M/_~ii looks like: Now if AFP q~ H, then clearly M/-2-:i! 
cannot be a ]]intikka structurc for AFP. And if AI:'P 6 H, then we must have AFP 6 L([si]), which violates 
H18, so again M/~ll is not ;I Hintikka structure for AFP. II Nonctheless, the quotient structure M/--Fi(p) 
does provide useful information. It is easy to check that M/~FL(p ) satisfies all the constraints of 
l)efinition 3.1 except possibly 1118 and 1.t20 (which. as shown in the preof of '['heorem 3.6, it does 
not in general satisfy). In'.,tcad, M/~vi (p) satisfies another important property which will allow us 
to view it as a "pbetldo-lllodel" tha cau he "UllWOtlnd" into a genuine moo'el. To make these ideas precise, 
we need the following definitions. 3.7 I)cfiuilion: Given a directed acyclic graph (dag), an interior 
/resp. fi'onticr) node of the graph is one which has (rcsp. does not ha~e) a successtm The root of a 
dag is the unique node (if it exists) fiom which all other nodes are reachable. A fi'agment M = (S,I.,R) 
is a structure whnsc graph is at finite dag whose interior nodes satisfy H1- 16, and whose frontier nodes 
satisfy 1t1-12. Given M 1 = (St,hi.R1) and M 2 = (S2,1,2,R2), we s;B M 1 is cmttaim'd in M 2 and write 
M 1 (~ M 2 iffS I C£ S 2, 1. t = 1.21S l and I{ 1 = R 2 n (s I x st). Wesay M l is embe~hled in M 2, 
and write M 1 .< M2, iff M 1 C M 2 and (sl,s2) 6 :R 2 f-l (S t X (S 2 -Si)) implies 51 has no Rl-SUCCCSSOr 
(i.e. the only arcs from nodes of M l to nodes of M 2 begin at fiontier nodes Of Ml). 3.8 Lemma: I.ct 
M = (S,I.,R) be a model for PO, and let M" = M/=Fi..(p0) = (S',I,'R'). Suppose AFq (resp. A[p U q]) 6 
L'([s']). Then there is a fragment N rooted at [s'] contained in M' such that for all the fiontier nodes 
t of N, q E l_'(t) (resp. and for all interior nodes u of N, p 6 l/(u)). Proof: We give the proof for 
AFq. The proof for Alp U q] is similar. We first assume that in the original structure M, each node has 
a finite number of successors. (The case where some node has an infinite number of successors is considered 
at the end of the proof.) Choose s 6 [s']. Then it is easy to see that embedded in M there is a fragment 
rooted at s of the form claimed by the lemma. Simply take all nodes dn paths starting at s up to (and 
including) the first node containing q in its label. This must be a finite dag; otherwise, by Koenig's 
Lemma, tt18 would be violated. If the labels on the nodes are all distinct, then this fragment is also 
contained in M' and we are finished. If not, we will systematically eliminate "duplicate" nodes from 
this fragment until we finally obtain a fragment which is contained in M'. We proceed as follows. Defne 
the depth of a node t, d(t), in a dag as the length of the longest path fiom the root to t. Then suppose 
that we have two distinct nodes t 1 and t 2 with identical labels, L'(tl) = L'(t2), such that d(tt) _) 
d(t2). We let the deeper node t 1 replace the sh~dlower node t 2 to get a new flagmcnt; i.e. we replace 
each arc (u,t 2) by the arc (u,t 1) and eliminate all nodes no hmgcr reachable fi'om the root, as shown 
in the diagram below. Note that t 2 itself is no longer reachable from the root. so it is eliminated. 
, ,,. : : The resulting graph is easily seen to still be a fragment reeled at s such that for all frontier 
nodes t, q 6 I?(t). We continue this process until the labels on all the nodes are distinct. This process 
must terminate after a finite number of steps since the original fi'agment was finite. The resulting 
fragment is contained in M" and meets the conditions of the lemma. If the original structure M had one 
or more nodes with an infinite number of successors, we construct a structure m' with no such nodes 
proof is straightforward and is omitted here. (Note, however, that as follows: For each node t and each 
furmula of the furm AXq' or substantial t3:;e is made of file fact that a fiagment is acyclie.) EXq' 
in l_(t) I') Fl.(P0), choose an arc (t,u) C R such that q' ¢ l.(u), Eliminate the edges not chosen. Let 
the resulting relation be R" and let M" = (S,L,R"). Each node of M" has only a finite number of successors 
(<-IP0I), and it is easy to check that we can cany out die above construction using M" instead of M since 
1-t18 still holds (although in general M" is not a model for P0 since the eliminated arcs may have been 
necessary for fulfilhnent of formulae such as EFp). I 3.9 Ilefluition: A pseudo-[lintikka structure (fur 
PO) is a stnT,:mre M := (S,I.,R'~ ~dlh R total (such that P0 ¢ 1.(s) for some s E S) whichl satisfies 
111-17, 1119 and for all s 6 S It 18', AFp 6 L(s) implies there is a fl-agmcnt N rooted at s contained 
in M such that for all fiontier nodes t of N, p E I.(t). 1120". A(p U q) (l.(s) implies fllere is a 
flagment N rooted at s contained in M snch that fur all fl'onticr nodes t of N, q g l.(t) and fur all 
interior nodes u of N, p ¢ L(u). 4. A Small Model Theore.t for CTL 4.1 Theorem: l.et P0 be a CT1. furnmla 
with IP0i = n. Then the fullowing are equivalent: (a) pois satisfiable (b) there is a pseudo-Hinfikka 
structure for P0 of size < 2 n (e) there is a Ilintikka structure for Po ofsize < n8 n (d) P0 is satisfiable 
in a model of size < n8 n. Proof: (a) ~ (b) folk)ws fi-om l.emma 3.8, (c) ~ (d) follows from the proof 
of Propositkm 3.2, and (d) ~ (a) is immediate. It remains to prove (b) ~ (c). We need the following definition: 
 4.2 I)efiuitio,: Let M be a structure, s a state in M, and p (L(s) where p is an eventuality fommla, 
i.e. p is of the form EFq, AFq, E[q' U q], or A[q' U q]. We say p is fulfilled in M for s if HI7, 1-118, 
tt19, or I-t20, respectively, holds fur p and s. We will construct a finite Himikka structure fur P0 
by "unravclling" the pseudo-Hintikka structure M for P0. For each node s of M and for each eventuality 
fummla p 6 l.(s), there is a fragment I)AG[s, p] which certifies that p is fulfilled fi)r s. We show 
how to use these DAGs to c(mstruct for each node s of M, a fiagment FRAG[s] such that every eventuality 
fommla in l.(s) is fulfilled within FRAG[s]. We then splice together these FRAGs to obtain the desired 
finite Hintikka structure, This is described in detail below. The fullmdng lemma says that if an eventuality 
formula is not fulfilled in a fi'agment then the conditions required to fillfill it are propagated down 
to appropriate frontier nodes of the fl'agment. The 4.3 I,emma: l.et M be a fragment, s a state in M, 
and p an eventuality fi)rnlula ill I.(S). Either p is fiflfilled in M for s or (a) lfp is of the furm 
EFq (resp., E[q' U q]), then there is a path ill M from s to a flontier node t such that EFq 6 L(t) (resp., 
l![q" U q] E l.(t) and q" 6 I,(t') for every slate t' on the path). Moreover, if M is embedded in M' 
and EFq (resp. E[q' U q]) is fulfilled in M' fur t, then EFq (resp. E[q' U q]) is fulfilled in M' for 
s. (b) lfp is of the furm AFq (resp., A[q" U q]), then for every path in M from s to a frontier node 
k either q 6 l.(t') for some t' on tile path, or AFq 6 I,(t') fur all t' on the path (resp., either q 
El.(t') for some t' on the path and q' 6 I.(t") for all t" on the path fi'om s before t', or q', A[q' 
U q] E I.(t") for every t" on the path). Moreover, if M is embedded in M" and AFq (resp., A[q' U q]) 
is fulfilled in M' fur all frontier nodes t of M, then AFq (resp., A[q' U q]) is fultilled in M' fors. 
4.,4 Lemma: I.et M be a psendo-Hintikka structure of size N 0, s a state of M, and p an eventuality formula 
in l.(s). Then we can find a fragment, '_)AG[s,p], with < N O interior nodes and root s (i,e. labelled 
L(s)) th which p is fulfilled for s. Proof: That we can find I)AG[s, AFq] (resp., DAG[s, aIq' U ql]) 
follows directly fiom H18' (resp., H20'). For DAG[s, EFq], note that if EFq ¢ L(s) then by H17 we can 
find a path in M starting at s to some state t with q ¢ l.(t). Choose a shortest such path. Its lengtll 
must be < N O (otherwise, some state must be repeated and there would be a shorter path). Take the path 
from s to t and for every state other than t, add enough successors to ensure that 1[13 and H16 are satisfied. 
The resulting graph defines DAG[s, EFq] and it is easy to check that all other coi~ditions are satisfied. 
The consmlction fur DAG[s, l![q' U q]l is similar. I In the proof of tile Dllowing lenmm we explain how 
to construct FRAGs fi'om DAGs. 4.5 Lemma: Suppose s is a state in a pseudo-llinfikka structure M of size 
N 0. Then we can find a fl'agment, FRAG[s], with < [l.(s)lN02 interior nodes and root s (i.e. labcllcd 
l.(s)) such that all eventuality fornnflae in I.(s) are fulfilled fius in I:RAKi[s]. Proof: We construct 
FRAG[s] in stages, l.et ql,...,qk be a list of all eventuality furmulae in L(s). We will build a sequence 
of flagments M0 < M 1 _< ... < M k = FRAG[s] all with root s such that. for each j, Mj has at most jN~ 
interior nodes, at most N O fiontier nodes, and (i) every node of M" is containcd in some fragment 
qt,...,qj are all ftdfillcd fi)r s in Mj. embedded in M", and We define the sequence inductively. I,ct 
M 0 consist of s with just enough successors to ensure 1-113 and 1116 are satisfied. Mj+ l is obtained 
by extending the frontier of Mj as follows: Ifqj+ t is fulfilled for s in Mj, let Mj+ 1 = Mj. Otherwise, 
suppose qj+l is of the form EFq. Then, by Lemma 4.3, there is a frontier node t of Mj, with EFq E l,(t). 
Let Mj+ 1 be the rcsult of rcplacing t by (a copy ol) I)AG[t. EFq]. Since EFq is fulfilled for t in Mj+1, 
by l,cmma 4.3, EFq is fulfilled for s in Mj+ 1. To cnsurc that Mj+ 1 has at most N O frontier nodes, 
let Mj+ 1 be obtained from Mj by identifying any two frontier nodcs with the same labels. A similar construction 
works if qj+l is Elq' U ql. If qj+ 1 is AFq, then let tl,~..,t m be all the frontier nodes of Mj such 
that AFq £ L(ti). By induction, m < N 0. Let Mj+ 1 be the result of replacing each tii by DAG[t i, AFq] 
and again identifying any frontier nodes with the same labels. Mj+ 1 satisfies the required properties: 
clearly, Mj+ 1 has < N O frontier nodes. By l.emma 4.3, qj+l is fulfilled for s in Mj +1. Finally, M 
j+ 1 has < (j + 1)N~ nodes since Mj has < jN~ nodes (by induction) and each of the at most N O DAGs attached 
to IVlj to form Mj+ 1 has at most N a nodes. A similar construction works if qj+l is A[q' IJ q]. I The 
proof of the next lemma shows how to construct a finite pseudo-ltintikka structure for P0 from FRAGs. 
4.6 Lemma: l,et M be a pscudo-Hintikka structure for P0 of size N 0. Then there is a llintikka structure 
M" for P0 of size < IP01N0s. Proof: We first replace l_(s) by L(s) n FI-(p 0) for each state s in M. 
The restflting structure M' is still a pseudo-I lintikka structure for P0 of size N 0. Wc construct M" 
by splicing together FRAGs from M'. For each node s of M', FRAG[s] will have at most onc occurrence in 
M". The construction is performed, inductively, in stages, l,ct M 1 be FRAG[s] for some state s of M' 
with P0 £ l,(s). In general, to obtain Mi+ 1 from M i, do the following: for each fionticr node s of 
M i, if there is an interior node s' of M i such that l,(s) = l_(s') and FRAG[s'] is embedded in M i 
then identify s and s': otherwise, replace s by (a copy of) FRAG[s]. The construction baits at i = the 
least m such that the frontier ofM m is empty. 'Fake M" = M m. It is straightforward to check that M" 
satisfics all the requirements for a Hintikka structure for PO with the possible exception of having 
unfulfilled evcntualities (i.e., violations of ttl7-20). To see that this cannot happen, observe that, 
by the construction of M", (ii) cach frontier node of every fragment is the root &#38;still another fragment. 
So suppose AFq E s for some node s of M". By (i), s is contained in somc fragment FRAG[s']. If AFq is 
fulfilled for s in FRAG[s'] we are done. Otherwise, by l,imlma 4.3, AFq £ t for every frontier node t 
of FRAG[s'] such that q does not uccur somewhere on each path from s to t. By (ii), each such t is the 
root of FRAG[t] embedded :in M" and AFq is thus futfillcd for t in M". Using Lemma 4.3 we can easily 
show that AFq is also fulfilled for s in M". The argument that e~cntualities of the form A[p U q], E[p 
U q], or EFq are fulfilled is similar and left to the reader. To sce that M" is of the required size 
note that it consists of at most N O FRAGs, each containing at most IPoIN~ nodes. | Returning to the 
proufofTheorem 4.1, ~e note that we can take N O = 2 n to obtain the result. II 5. A I)ecisio, I'rocetl,re 
for Salisfiahilily in CTL 5.1 Theorem: There is an algorithm for deciding whether a CIL formula is satisfiable 
~hich runs in deterministic time 2 c:~ for sorne constant c > 0. Proof: Given a fonntfla P0, we try to 
construct a pseudo-Hintikka structure for P0 of size _< 2 Fpol. The algolithnl is similar to Pratt's 
algorilhm fi,r deciding satisfiability of PI)I. formulae (cf. [Pr2]). We proceed as follows: 1. Define 
s (2 FL(P0) to be maximalif for every fi,rlnula of the fo;m ~q 6 Fl.(P0), either ~q 6 s or q 6 s. I.et 
S O = {s[s .C. Fl.(P0), s maximal}. For each s 6 S 0, define I.(s) = s. Define a relation R on S o X 
S o such that for ,.'very s, t E S 0, (s,t) 6 R iff (a) AXpEs~pCkand (o) ~EXp 6 s ----* "rap 6 t  2. 
Let S t --{s E S01 s satisfies Hl-12}. 3. Let S 2 = {s 6 Sll s has an R-successor}. Note that 1< is 
a total relation on S 2 all of whose states satisfy tt1-12, 14, 15. 4. For each s £ S 2, if EXp (resp., 
~AXp, l'Fp, AFp, E[p U q]. A[p U q]) E s, check that 1t13 (resp., H16, H17, H18", t119, H20") holds. 
If not, eliminate s and all arcs leading to and from s. Next, eliminate any s which has no P,-successors. 
Repeat this step until no more nodes can be eliminated. 5. Let S 3 be file remaining states. Then Po 
is satisfiable iff for some s E S 3, Po 6 s.  (later: lhe algo~ithl~l above is correct and olin he 
implcmellted to run in tilne 2 cn for st,me constant c>0 where n = IP01. Proof: To see that the algorithm 
is conect, note that it deletes any node s which violates any of the conditions I-t1-17, 18', 19, 20'. 
Thus, when it terminates (S3,I.,R) is it pseudn-Hintikka SllUcture (or S 3 is empty). So if p0 (E s fin" 
some s E S 3. P0 is satisfiable by Theorem 4.1. Cunvcrscl~, if P0 is satisfiable, say by.M, let M' = 
M/~.l..l(p0 ) = (S'.I.',IU). M' is a pscudo-llintikka structure for P0, and fi)r all s' £ S', I.'(s') 
is maximal. 1.et f : S' ~ S O via f~s') = l?(s'). '1 hen it is easily checked that (s.t) E R' ~ if(s), 
f(t)) £ R as defined in step I of tile algoritilm. Thus the image elM' under fis contained in M = (S3,1.,R). 
We can also check that ifs' £ S', then ffs') E S O will not be eliminated by steps 2, 3, or 4, so that, 
in fact, Rs') £ S 3. (l'his can be argued by induction on tile order in which nodes of S O arc eliminated. 
For instance, ifAFp E s where s E S O and for some s' E S', s'= f(s'), then s cannot be eliminated due 
to a violation of H18' bccause the image under f of the appropriate fi'agment contained in M' is a fragment 
contained in M. The details are straightforward and left to the reader.) It follows that for some s E 
S 3, wc will have P0 E s. Now we consider implementation details Since ]Fl.(P0) I $. 21P01 (= 2n), S 
O has < 22n naembers. Step 1 can clearly bc done in time quadratic in the size ofS 0, while steps 2 and 
3 can be done in lincar time. Step 4 will be repeated at most IS21 times. Thus, it suffices to establish 
that each check in step 4 can be done in time polynomial in tbe number of nodes remaining in the graph. 
'll~e case of EXp or ~AXp is straightforward. We sketch the algorithm for Alp U q} below: 1. Mark all 
nodes s for which q, A[p U q} E s. 2. Mark all unmarked nodes s with p, A[p U q} E s such that for each 
p' E s of the form EXq' or "nAXq' there is a marked R-successor s' of s with q' E s or ~q' E s,  respectively. 
Repeat this step until no more nodes can be marked. 3. Eliminate all unnlarked llodcs t such that Alp 
U q} E t. We leave ~t to the reader to check that this algorithm is correct and has the desired complexity. 
Similar algorithms work for Al:q, EFq, and E[p U ql. I 5.2 Retnark: "ll3e proof that detcrministic exponential 
time is a lower bound for PI)L ([FI,]) carries over directly to UB (and hence both UB and CTL). 'llms 
the decision procedure .given above is essentially the best we can get. 6. A Compkqe Axiomatizalion for 
CTL 6.1 Consider the following axioms and rules of inference: Axioms: Axl. All (substitution instances 
o0 tautolngiesof propositkulal logic Ax2. t.]:p = E[tme U p} Ax3. At:p = A[tmeU p} Ax4. EX(pVq)~EXpVEXq 
Ax5. AXp-- ~EX ~p Ax6. I",(p U q) = q V (p A EXE(p U q)) Ax7. A(pUq)~qV(pAAXA(pUq)) Ax8. EXtrue A AXtrue. 
Rules of hference: R1. p ~ q I-- EXp ~ EXq R2. r ~ (-aq A EXr) I-- r ~ -aA[p U q] R3. r ~ [~q A AX(r 
V "~l~[p U Cl])] I--- r ~ ~l~[p U q] R4. p, p ~ q I.- q (modus ponens). These axioms and rules of inference 
are clearly sound and are also complete as shown beh)w. If we replace p by true in Ax6, Ax7, R2, and 
R3 above and use the equivalences in Ax2 and Ax3 we get a complete axiomatization of UB equivalent to 
the one given in [BMP]. (For example, Ax7 becomes AFq --q V AXAFq.) 6.2 Theorem: The above set of axioms 
and rules of inference is complete for CfL. Proof: Wc say that a formukt p is provable, and write I--. 
p, if there exists a finite sequence of formulae, ending with p, such that each fonnula is an instance 
of an axiom scheme or follows from previous fonnulas by one of the in fcrence rules. A formula p is consistent 
if not I--- ~p, i.e., if-~p is not provable. We want to show that any valid CTI. formula is provable. 
It suffices to show that any consistent fonnula is satisfiable. So suppose P0 is a consistent CFL formula. 
We try to construct a model for P0 just as in the proof of 'l]lcorcm 5.1. For each s £ S 0, define the 
fonnula Ps as the conjunction of the formulae in s; i.e. Ps = "AqCsq" Note tbat since s is maximal° ifq 
E FL(p 0) then q £ s iff I--- ps =~ q . We will show that if a state s E S o is eliminated in Mgorithm 
5.1, then Ps is inconsistent. Once we have shown this, we can argue as follows: It is easy to check 
by propositional reasoning that for any q £ FL(P0 ) we have (*) I--- q = V{s[q£s.p sconsistent} Ps, and 
I--" true ~ V{slsCSo,PsConsistent} Ps' In particular, I-- P0 ~ V{slp0Es.p s consistent} Ps, so if P0 
is consistent, some Ps is consistent. This particular s will not be eliminated in the course of our construction. 
Thus, at the end we will be left with a pseudo-Hintikka structure for P0, so by Theorem 4.1 P0 is satisfiable. 
We now show, by induction on when a state is eliminated, that if state s is eliminated then F-- "nps: 
1. It is easy to check that if s is eliminated in step 2, then Ps must be inconsistent due to Axb7 and 
the fact that for each q £ FL(P0 ), either I--- Ps ~ q or F-- Ps =~ --nq. 2. Claim: if (s,0 ¢ R as constructed 
in step 1, Ps A EXPt is inconsistent. Proof: If AXpEsand~pEt, then t---ps ~AXp and I-- Pt ~ ~P. By R1, 
I--- EXPt =*, EXmp, Thus, I-- (Ps A EXPt) ~ AXp A EX~p. But by Ax5 it follows that AXp A EX-~p, and hence 
Ps A EXp,, is inconsistent The proof in the other case is similar. 3. Claim: lfPs is consistent, then 
s is not eliminated at step 3.  Proof: t-- Ps ~ Ps A EXtme (by Ax8) Ps A EX(Vpt consistent Pt) (by 
*, RI) Ps A (Vptconsistent EXPt} (by Ax4) Vptconsistem (Ps A EXPt) (by A~I). 'llms, if Ps is consistent, 
Ps A l~XPt'must be consistent for some t with Pt consistent. By 2 above, (s,t) 6 R. By the induction 
hypothesis, t is not clintinated and s wi!l have an R-successor. Thus Ps will not be eliminated by step 
3. 4. Claim: lfPs is consistent, then s is not eliminated at step 4. Proof: (a) If EXp 6 s, then by the 
same reasoning used above t---- Ps ~ V{tlp t consislem, pet} (Ps A EXPt). Thus, for some consistent t 
with p 6 t, (%0 6 R, so s satisfies H13. (b) A similar proof shows that if ~AXp 6 s, s sati{fies H16. 
 (c) Suppose s is eliminated at step 4 on acco,mt of H19 failing at s with respect to E[p U q]. We will 
show that Ps is inconsistem. Lct V =- {t[ E[p U q] £ t and t is eliminated at step 4 because HI9 fails 
for E[p U q]}. By assumption,  sEV. Since H19 fails, t-Pt ~ "~q for each t £ V. Let r = Vt6 v Pt. Note 
we also have I,....- r ~ --,q. We want to show I-- r ~ AX(r V ~E[p U q]). It suffices to show that for 
each t 6 V, I--" Pt ~ AX(r V -~E[p U q]). Suppose not. Then Pt A EX(~r A E[p U q]) is consistent. But 
~r _= Vt,¢v Pt', so by Ax4 Pt A EX(Pt. A E[p U q]) is consistent for some t' ¢ V. It follows that both 
Pt A EXpt. and Pt' A E[p U q] are consistent. The former implies (t,t')E R by 2 above, while the latter 
implies E[p U q] E t' since one of E[p U q], ~l?,[p U q] £ t by maximality. But if E[p U q] E t' and 
t' ¢ V, then 1-119 must hold for t'. Since (t,t')6 R, H19 must also hold for t contradicting the fact 
that t £ V. Thus I---r ~ --aq A AX(r V ~E[pUq]). By R3, I---r~l![pUq]. Since sEV, I--Ps ~r, so by R4, 
I-- Ps ~ ~E[p U q]. By assumption we have E[p U q] 6 s, So Ps mtlst be inconsistent, as desired. A similar 
argument shows that if EFp 6 s and s is eliminated at step 4 because }t17 is not satisfied, Ps is inconsistent. 
(d) Suppose s is eliminated at step 4 on account of H20' failing at s with respect to Alp U q]. Again 
we show that Ps is incoqsistcnc Let W = {tl t is eliminated at step 4 because 1-120 flails for Alp U 
q]}. By assumption, s E W. Note that by Ax7, I-- Pt =~ AXA[p U q] A ~q for cach t 6 W. I,et r = Vt 6 
w Pt. Clearly t--- r =,~ ~q. We want to show I--- r =~ EXr. It suffices to show that for each t ¢ W, 
I--pt~ EXr. Givcn t E W, let E t = {ql EXq 6 t} LJ {-~ql ~AXq 6 t} and let A t = {ql AXq E t} U {~q] 
~EXq E t} For each q' 6 E t, definc fq, = q' A (Aq, E A t q") and let Xq. = {t'[ (t,t') E R, q" E t'}. 
It is easy to check that (i) t-Pt ~ EXfq. and (ii) I-- fq, ~ V t, 6 Xq, Pt'.  Note also that for each 
t' E Xq., Alp Uq] E t' (since AXA[p U q] E t). Now, if for each q' ¢ E t there is a t' 6 Xq, such that 
Alp U q] satisfies H20' at t', then we can show that Alp U q] satisfies 1120' at t as well, which contradicts 
the assumption that t E W. (The dcUdls of this proof are much likc tltose of Lemma 3.8, so wc omit them 
here.) So it must be that for some q' E E t and for all t' E Xq.. we have t' 6 W. For this q', Xq, C 
W, By (ii) above, it follows that I-- fq. =*~ r. Using (i), we obtain I-- Pt ~ EXr. Thus, I-- r ~ ~q 
A EXt. By R2, I-- r ~ ~A[p U q]. Since s £ W, I-- Ps ~ r and thus I-- Ps ~ ~A[p U q]. It follows that 
Ps is inconsistent. A similar argument applies ifAFq E s. We have now shown that only states s with Ps 
inconsistent are eliminated, thus completing our proof. I  6.3 Remark: As we mentioned in 2.4, the condition 
that R be total can be ren:ovcd from our definitions of model, tlintikka structnre, and pseudo-tlintikka 
structure. But in this case, l,emma 2.6.3 must be modified to read I= AFp ~_ p V (AXAFp A EX tree). The 
clause EXtnw must also be added in 2.6.5, H7, HI1, and Ax7 and rcmovcd from Ax8. We can then eliminate 
step 3 in both 5.1 and 6.2. All other results go through unchanged. 7. Tableau Techniques 7.1 Comtntcting 
the Tableau: The algorithm for deciding satisfiability prcsented in 5.1 has a worst-case running time 
of 2 cn. This is the best we can do in light of the remarks in 5.2. However, its average-case performance 
is also 2 cn since the first step involves creating all the subsets of 1:l.(Po). Just as for I)PDI. (of. 
[BItP]) there is a "boltom-ulfl' procedure for constructing a pseudo-I lintikka structure which is likely 
to perform better in practice. We say that an elementary formula is one of the form I', -.ap, EXp, AXp, 
-aEXp, or 'aAXp. We classify each nonelemenlaJyfi~rmulaeas either a con!unctive formula a ~ a t A a 2 
or a disjunctive formulae/3 '81 V '82. Clearly, p A q is an a-formula and --a(p A q) (which is equivalent 
to ~p V -,q) is a fl-formula. A temporal operator is classilied as either a or '8 based on its fixpoint 
characterization (cE [EC]) as in l.emma 2.6. Thus, AFp -~-p V AXAFp is a ,8-formula and ~AFp ~,~p A ~AXAFp 
is an a-formula. The table below summarizes flae classification of nonelenrentary formulae as either 
a or '8: u-pAq a t -p a2-q ot -.-.a ~p a l -p a2 - p a -~ EFp et I - ~p ot 2 - ~EXEFp a-~Al:p a 1 - ~p 
a 2 - ~AXAFp ,8 ~(p A q) t81 - "rap '82""~q ,8 EFp 'st- P '82- EXEFp ,8 AFp '81 - P ,82" AXAFp ,8 Elp 
U q] ,st- P &#38;- p, l:xl~[p u q] B Alp Uql t81- q '82" P, AXA[p O q] ,8 ~E[p U q] #t -"q, ~P '82" ~q, 
~ EXtt~lp O q] ,8 ~A[p U q] &#38; "-'q, ~P /32 ~q, ~aXa[p U ql Given a fi)rmula Po, we proceed to build 
a structure in stages. 1. l.abel the "root" node by {Po}- 2. Inductively assume we have constructed 
a graph with nodes labelled by subsets of I:1.(p0). At each node certain tbnnulae in the label are marked 
"expanded". For every  fi'ontier node labelled by I'C Fl..(p0), choose some nonelementary fi~rmula q 
which is not marked, and expand it according to the lable above: ifq is an ~-formula, create one son 
of this node labelled by F L.I {a 1, a2} and mark q. If q is a fl-fonnula, create two sons of Ihis node, 
one labelled F U {ill } and the nther F U {,82}. In the label of each son, mark q. As usual, any two 
nodes with the same label and the same formulae marked expanded are identified, Thus, there are at most 
24n nodes where n = IP0f 3. If all the nonelcmentary fonnulae at a node are marked, this node is called 
a state. Let EXql ..... EXqk, "mAXq+ l, .... ~AXqm. AXr l ..... AXr i ..... '-,EXri+ 1 ..... ~EXr n be 
the nonatumic elementary formulae in the label of a state s. Create m+ 1 sons of s, labelled by {r 1 
..... r i, ~ri+ 1 ..... ~r n, qj}, j = 1 ..... k, {r l ..... r i, ~ri+ 1 ..... ~r n, ~qj},j=k+l ..... 
m, {r 1 ..... r i, ~ri+ 1 ..... ~rn}, respectively. 4. Repeat steps 2 and 3 until no more nodes can be 
added. From this structure we create a lableau, M'=(S,I.,R). S consists of exactly those nodes which 
were states in the construction above. For s 6 S, l.(s) is file label on s. For s,t 6 S, (s,t) 6 R iff 
there is a path from s to t in the above graph which does not go through any other states. For a node 
labelled by F, define Ps = ArEr r. Once we have constructed the tableau, we just repeat steps I, 4, and 
5 of Algorithm 5.1. As in 5.1, if there is a state containing P0 wlfich is not eliminated, we have constructed 
a pseudo-llintikka structure for P0, so P0 is satisfiable. For the converse, we can show as in 6.2 that 
ifa state is eliminated then t-- '"Ps. (Note that this will also give us another proof of the completeness 
of the axiomatization presented in 6.1.) Not surpd:dngly, the details of fl3is proof are similar to those 
in 6.2; we omit them here. II 8. Expressive.ess 8.1 Theor,.,m: AFp is not expressible in UB. Proof: B3 
the proof of Theorem 3.6, we know that no quotient constructitm works for AFP. Yet the Fischer-l.adner 
conslnmtion does apply to UB since we can directly embed UB into 1)1)1~ by using the translation: EXp 
~ <R>p and EFp + <R*>p. Thus AFP could not be equivalent to a UB formtfla. I  8.2 Theorem: E(FP A GQ) 
is not expressible in UB. Proof.' We will define inductively two sequences of models M 1, M2, M 3 .... 
and N 1, N2, N 3 .... such that for all i, we have M i, s i I= E[FP A GQ] and N i, s i I= ~E[FP A GQ]. 
We will show that UB is unable to distinguish between the two sequences nfmodels, i.e., for all UB formulae 
p with/pie_i, M i, s i I= p iff N i, s i I= p. To see that the result folk)ws suppose that E[Fp A Gq] 
is equivalent to some UB formula p. Then Mip I, slr,[ I= p iffNip I, Sip I I == p contradicting file 
fact that Mip I, slr'l I== E/FP A GQ] and Nip I, Sip I I= mE[FP A GQI. "111e details of the proof arc 
given beh)w. Define M1, N t to have the graphs shown below: % t.. where s 1 I= ~PAQ, v 1 I= PAQ, t 1 
~ ~PAQ, and w 1 I= PA~Q. Suppose we have defined M i and N i. Then Mi+ 1 has the following graph SiI, 
I where si+ 1 I= -~P A Q, ti+ l I= ~P A Q, ui+ 1 [e:= p A ~Q, M], M I' are copies of M i, and Ni'is a 
copy o['N i. Ni+ l is defined similarly. except that M I is replaced by N I, a copy of N i. It is straightfi)rward 
to show by induction on i that I.M i, s i I= E[FP A GQ] (since the path fllrough Mi. 1 satisfies FP A 
GQ) and Ni,s i I:= ~I~[I:P A GQI (since the state tl i prevents the possibility of a path satisfying 
VP A GQ going through Mi'or Ni'. 2. Each path in M i and in N i ends in a self-loop through some state 
tj. We now show by induction on [p[, that for all LIB lbrmulae p. if IPl -< i then (**) Mi, sil:==piffNi, 
sil== p. Since I= AXq ~ "aEX ~q and I= AFq ~. ~EG ~q we can take EX, EG, and EII: as the primitive temporal 
operators in our induction. The cases where p is an atomic formula, a conjunction Pl A P2, or a negation 
~PI are easy and left to the reader. lfp is of the form EXq, Mi ~1, Si+l I= EXq iff Mi.~_l, sl=q, whcresisti+l, 
Ui~l, ors i, iff Ni+l,sl=q, wheresisti+l, Ui+l, ors], (scc below for details) iff Ni÷l,Si+ 1 I= F, Xq. 
 The first two cases of the third equivalence are obvious from the definitions of Mi+ 1, Ni+l; when s 
= s i, we have Mi+ 1, s i I== q iff M i, s i ~ q iff N i, s i ~ q (by the inductio8 assumption) iff Ni+ 
1, sl I== q) Ifp is of the fonn EGq. Mi+ 1, si+ 1 I =: EGq iff there is a path in Mi+ 1 startitlg at 
si+ 1 all ofwhose nodes satisfy q iff Mi+ 1, %+1 I=: q and Mi+ 1, tit- l I== q (by (2)above) iff Ni+ 
l, si+ 11== q arid Ni+ 1, ti+ l I-= q (by the induction hyl)othesis) iff Ni+ l, si+ 1 I= EGq.  Finally, 
suppose p is of the Ibrm EFq and Mi+l, %+1 I= El:q. Then Mi+ 1, s I == q for some state s in Mi+ 1. There 
are several cases to consider: a. lf s = Si+l, then Ni+l, sif t I== q by the induction assumption.  
b. lfs = ti+ t or ui+ 1. then Ni+l, s I = q since the world "below" ti+ 1 or ui+ 1 looks the same in 
Mi+ t and Ni+ 1.  c. If s is in M I' or Nil then s is also a state in Ni+ 1, so Ni+ 1, s I= q.  d. 
lfs is some s' in M I then there is a corresponding s" in Mi: and thus in Ni+ 1, such that Ni+ 1, s" 
I=: q.   In each case we conclude that Ni+ 1, si+ 1 I == EFq. The converse is identical (upon interchanging 
the roles of M and N). This completes the proof&#38;(**) and the thet~rem follows. II The folh,wing result 
for branching time is anal(,gous to the corresponding result for linear time due to Kamp (cf. [Ka]). 
   8.3 "l'hcor,~m: E(p U q) is nnt expressible in UB + . Proof: We define two (doubly-indexcd) sequenccs 
of models Mki and Nki. The graph of each model is just a st raight line: > ) ) ~ ) ~.-. -% 5,. .% s, 
s_~ For Mki we have sjI=PA~Q ifj~i+ tkforsomet sj I == P A Q ifj = i + tk for some even t sj~PA~Q ifj 
=i+tkforsomeoddt For Nki, sj I= P A ~Q ifj ~ i + tk for some t sj I= -'-aid A mQ ifj = i + tk for some 
even t sj 1= P A Q ifj = i + tk for some odd t Thus. for both Mki and Nki, P A ~Q is true at all states 
not congruent to i mod k. P A Q and ~P A ~Q alternate being true at states congruent to i mod k. Since 
P A Q is true first in Mki, while ~P A ~Q is true first in Nki, we have Mki, st) I == E[P U Q]. However, 
by a straightforward induction, we can show for all UB fimnulae p that if Ipl <_ i, Mki, s o I= p iffNki, 
s o I= p. The proof uses the observation that Mki, s o I== p iff Nki, s k I== p. We omit tbc details 
here. Now we can argue just as in the previous thcorcm that E[P U Q] is not equivalent to any UB fonnula. 
Moreover, since UB + reduces to UB in Mki and N~ (since there is only one path, we have E(p A q) ~ Ep 
A Eq, etc.) E[P U Q] is not equivalent to any UB + formula. II Although Theorem 8.2 shows that UB is 
less expressive than UB +, this result does not extend to CTL as the following theorem shows (cf. [EC, 
Theorem 5.1]). 8.4 Theorem: For all CI'L + formulae p, there is a CTL formula p' such that I-= p ~ p'. 
Moreover, }P'I .~ 2tpll°glPl. Proof: We describe an algorithm for tr:mslath~g a C'~ I. + fonnula P0 
into art equivalent CT1. formula p~. We can assume without loss of generality that A and F do not occur 
in P0 since Aq ~ ~E ~q :lnd Fq ~ true U q. We can then reduce the problem to one of translating a CTI.+ 
formula with at most one E by recursively applying the algorithm to nested subfonnulae containing an 
E. So we can assume P0 is of the form Eq0 where q0, a path formula, is a Boolean combination of subformulae 
of the form p U q, ~(p U q), Xr, and ~Xr, where p, q, and r are CTI. formulae (found by recursivc applications 
of the algorithm). Observe that the following equivalences hold: 1. ~ "-aXr ~ X~r 2. I= ~(p U q) ~ 
[(p A "~q) U (~p A ~q)] V G -~q  3. I= E(p V q) ..~ Ep V Eq 4. I= X(p A q) _= Xp A Xq  5, ~G(p A q) 
~Gp AGq 6. ~ E(Aj= 1,..., n (pj U q)) A Xr 1 A Gr2) VJC{L...,n} [AiEJ qi A r 2 A EX(r 1 A E(Aj(~j Pi 
U qi A Gr2) ]  7. I== E(Aj= 1,..., n (p) U qj) A Gr) _= V{E(Aj pj A r U (q~r(1) A HAj~r(i ) pj A r U 
  (q~(2) A E(Aj~:~rO)art2 ) pj A r U (q~(3) A ...U(%(,,) A EGr))))))) : is a permutation of {I ,...,n}} 
Intuitively, the right side of the last equivalence is a disjunction over all the possible orders in 
which the qi's can be satisfied along the path. We pr~xced as follows. Using DcMorgan's l.aws, drive 
negations inv, ard until q0 is composed of conjunctions trod disjunctions of formulae of the fonn p U 
q, -l(p U q), Xr, and ~Xr. After applying equivalences 1 and 2, we can assume q0 is made up of disjunctions 
and conjunctions of formulae of the form p U q, Xr], ;rod Gr 2. Wc put this into l)isjunctive Normal 
Form and apply cquiwdcnces 3, 4, anti 5. We have now 'reduced the problem to one of translating a formula 
Ik I' where q" is of the form Aj= l.....n (Pj U qj) A Xr 1 A Gr 2. Using equivalence 6, wc can eliminate 
the Xr term horo consideration. Finally, using equivalence 7 gives us a formula in CTI.. Note that using 
equivalence 7 introduces a factorial blowup in the sign of the for,nula. We can show that this is the 
worst blowup that happens in the translation process. Since n! = O(2 n log n), we carl show that [P'l 
_<. 2h~ll°gfN. We omit details here. II 'lhus we get the following hierarchy of branchi{lg time logics 
 (where < indicates "strictly less expressive than" and ~ indicates "exactly as expressive as"): UB" 
< UB < UB + < CI'I, -~ CTL +. Finally, putting together Theorems 8.4 and 5.1 we get 8.5 Theorem: 'lllere 
is a decision procedure for satisfiability of 2cnlog(n) CTL +fonnulas which runs in time 2 for some 
c ) 0. Acknowledgements We would like to thank Kata Carbone for the fine job of typing the manuscript. 
Referct:ccs [BA] M. Ben-Ari, person;d communication. [BHP] M. Ben-Ari, J. Y. Ilalpern, and A. PntJeli, 
Finite models of detenuinistic propositional dynanlic logic, iCAI.P 1981, pp. 249-263. A revised version 
appears as: l)cterministic propositional dynmnic logic: finite models, complexity, and completeness, 
MIT/I.CS/TM-190, 1981. [BMPJ M. Ben-Ari, Z. Manna, and A. Pnueli, The temporal logic of branching time, 
I;OPI. 1981, pp. 164-176. [Ctq E.M. Clarke and E. A. Emerson, lJcsign and synthesis of synchronization 
skeletons using branching time temporal logic, l¥oceedings of the Workshop on I.ogics of Programs, Ed. 
l).Ko;,en, Springcr-Verlag, 1982 (to appear). A revised version appears as Harvard University TR-I2-81, 
1981. [EC] E.A. Emerson and E. M. Clarke, Characterizing correctness properties of parallel programs 
as fixpoints, ICAI,P 1980, pp. 169-181. [GPSS] D. Gabbay, A. Pnueli, S. Shelah, and J. Stavi, On the 
temporal analysis of fairness. POPI. 1980, pp. 163-173. [Ka] H.W. Kamp, Tense logic and the theory of 
linear order, Ph.D. thesis, UCLA, ]968. [KP] D. Kozen and R. Parikh, An elementary proof of the completeness 
of PDI., TkeorelicaI Conlputer Science, 14:1, pp. 113-118, 1981. 179 {I.a] L. Lamport, "Sometimes" 
is sometimes "not never", POPL 1980, pp. 174-183. [MP] Z. Manna and A. Pnueli, The modal logic of programs, 
1CAI.P 1979, pp. 385-410. [Pn] A. Pnueli, The temporal logic of programs, FOCS 1977, pp. 46-57. [Prl] 
V.R. Pratt, Applications of modal logic to progranlming, MI'I'/I_.CS/'I'M-116, 1978. [Pr2] V.R. Pratt, 
Models of program logics, FOCS 1979, pp. 115-122. [5;11 R.S. Street(, Propositi,mal dynamic logic of 
k3,}pillg ;,lid convei~;e, I:h.l). thesis, M.I.T., 198l.   
			
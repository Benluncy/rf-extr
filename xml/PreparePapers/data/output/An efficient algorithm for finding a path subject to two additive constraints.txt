
 An Efficient Algorithm for Finding a Path Subject to Two Additive Constraints* Turgay Korkmaz Marwan 
Krunz Spyros Tragoudas Dept. of Elec. 8z Comp. Eng. Dept. of Elec. &#38;: Comp. Eng. Dept. of Elec. &#38; 
Comp. Eng. University of Arizona University of Arizona Southern Illinois University Tucson, AZ 85721 
Tucson, AZ 85721 Carbondale, IL turgay&#38;#169;ece, arizona, edu krunz@ece, arizona, edu spyros@ongr, 
siu. edu Abstract One of the key issues in providing end-to-end quality-of-service guarantees in packet 
networks is how to determine a feasible route that satisfies a set of constraints while simul- taneously 
maintaining high utilization of network resources. In general, finding a path subject to multiple additive 
con-straints (e.g., delay, delay-jitter) is an NP-complete prob- lem that cannot be exactly solved in 
polynomial time. Ac-cordingly, heuristics and approximation algorithms are often used to address to this 
problem. Previously proposed algo- rithms suffer from either excessive computational cost or low performance. 
In this paper, we provide an efficient approx- imation algorithm for finding a path subject to two addi- 
tive constraints. The worst-case computational complexity of this algorithm is within a logarithmic number 
of calls to Dijkstra's shortest, path algorithm. Its average complexity is much lower than that, as demonstrated 
by simulation re-suits. The performance of the proposed algorithm is justified via theoretical performance 
bounds. To achieve further per- formance improvement, several extensions to the basic al- gorithm are 
also provided at low extra computational cost. Extensive simulations are used to demonstrate the high 
per- formance of the proposed algorithm and to contrast it with other path selection algorithms. keywords: 
Multiple constrained path selection, QoS rout- ing, scalable routing. Introduction Integrated network 
services (e.g., ATM, Intserv, Diffserv) are being designed to provide quality-of-service (QoS) guar- 
antees to various applications such as audio, video, and data. Many of these applications have multiple 
QoS requirements in terms of bandwidth, delay, delay-jitter, loss, etc. One of the important problems 
in QoS-based service offerings is how to determine a route that satisfies multiple constraints *This 
work was supported by the National Science Foundation under Grant ANI 9733143 and Grant CCR 9815229. 
Permission to make digital or hard copies of all or part of this work for personal or classroom use is 
granted without fee provided that copies are not made or distributed for profit or commercial advant 
-age and that copies bear this notice and the full citation on the first page. To copy otherwise, to 
republish, to post on servers or to redistribute to lists, requires prior specific permission and/or 
a fee. SIGMETRICS 2000 6 00 Santa Clara, California, USA &#38;#169; 2000 ACM 1-58113-194-1/00/0006...$5.00 
 (or QoS requirements) while simultaneously achieving ef- ficient utilization of network resources. This 
problem is known as QoS-based (or constraint-based) routing , and is being extensively investigated in 
the research community (e.g., [4, 8, 13, 22, 24, 25, 33, 37]). In general, routing consists of two basic 
tasks: distribut- ing the state information of the network and searching this information for a feasible 
path with respect to (w.r.t.) given constraints. In this paper, we focus on the second task, and assume 
that the true state of the network is available to every node (e.g., via link-state routing) and that 
nodes use this state information to determine an end-to-end feasible path (see [17] for QoS routing under 
inaccurate informa-tion). Each link in the network is associated with multiple QoS parameters. Link parameters 
can be roughly classified into additive and non-additive [2, 34]. For additive con-straints (e.g., delay), 
the cost of an end-to-end path is given, exactly or approximately, by the sum of the individual link 
parameters (or weights) along that path. In contrast, the cost of a path w.r.t, a non-additive constraint 
(such as band- width) is determined by the value of that constraint at the bottleneck link. Non-additive 
constraints can be easily dealt with as a preprocessing step by pruning all links that do not satisfy 
the requested non-additive QoS values [35]. Hence, in this paper we will mainly focus on additive constraints. 
The underlying problem of path selection subject to two ad- ditive constraints can be stated as follows. 
Definition 1 Multiple Constrained Path Selection (MCP): Consider a network that is represented by a directed 
graph G = (V, E), where V is the set of nodes and E is the set of links. Each link (u, v) E E is associated 
with two nonnega- rive additive QoS values: wl(u,v) and w~(u, v). Given two constraints ca and c2, the 
problem is to find a path p from a source node s to a destination node t such that wi(p) < ci, where 
wi(p) a,,~ (u,~)ep wi(u, v) and i = 1, 2. = The MCP decision problem is known to be NP-complete [16, 
23]. In other words, there is no efficient (polynomial- time) algorithm that can surely find a feasible 
path which si- multaneously satisfies both constraints. A related yet slightly different problem is known 
as the restricted shortest path (RSP) problem, in which the returned path is required to satisfy one 
constraint while being optimal w.r.t, another pa- rameter. Any solution to the RSP problem can also be 
ap- plied to the MCP problem. However, the RSP problem is also known to be NP-complete [1, 16]. Both 
the MCP and RSP problems can be solved via pseudo-polynomial-time al- 318 gorithms in which the complexity 
depends on the actual with a nonfinear cost function to solve the MCP problem. values of the link weights 
(e.g., maximum link weight) in addition to the size of the network [20, 23]. However, these algorithms 
are computationally expensive if the values of the link weights and the size of network are large. To 
cope with the NP-completeness of these problems, researchers have re- sorted to several heuristics and 
approximation algorithms. One common approach to the RSP problem is to find the k-shortest paths w.r.t, 
a cost function defined based on the link weights and the given constraint, hoping that one of these 
paths is feasible and near-optimal [15, 18, 19, 31]. The value of k determines the performance and overhead 
of this approach; if k is large, the algorithm has good perfor- mance but its computational cost is prohibitive. 
A similar approach to the k-shortest paths is to implicitly enumerate all feasible paths [3], but this 
approach is also computation- ally expensive. In [36] the author proposed the Constrained Bellman-Ford 
(CBF) algorithm. Although this algorithm exactly solves the RSP problem, its running time grows ex- ponentially 
in the worst-case. The authors in [30] proposed a distributed heuristic solution for RSP with message 
com- plexity of O(n3), where n is the number of nodes. This complexity was improved in [21, 38]. In [20] 
the author presented two e-optimal approximation algorithms for RSP with complexities of O(loglog B(m(n/e) 
+ loglog B)) and O(m(n2/e) log(hie)), where B is an upper bound on the so- lution (e.g., the longest 
path), m is the number of links, and e is a quantity that reflects how far the solution is from the optimal 
one. Although the complexities of these e-optimal algorithms are polynomial, they are still computationally 
expensive in large networks [28]. Accordingly, the author in [28] investigated the hierarchical structure 
of such net- works and provided a new approximation algorithm with better scalability. Although both 
the RSP and MCP problems are NP-complete, the latter seems to be easier than the former in the context 
of devising approximate solutions. Accord-ingly, in [23] Jaffe considered the MCP problem and pro- posed 
an intuitive approximation algorithm to it based on minimizing a linear combination of the link weights. 
More specifically, his algorithm returns the best path w.r.t, l(e) de.~ awl (p)+flW2 (p) by using Dijkstra's 
shortest path algorithm, where a, fl E Z +. The key issue here is to determine the appropriate a and 
~ such that an optimal path w.r.t, l(e) is likely to satisfy the individual constraints. In [23] Jaffe 
de- termined two sets of values for a and fl based on minimizing an objective function of the form f(p) 
= max{w1 (p), Cl} + max{w~(p),c2}. For the RSP problem, the authors in [6] proposed a similar approximation 
algorithm that dynami-cally adjusts the values of cr and ft. However, the compu- tational complexity 
of their algorithm grows exponentially with the size of the network. Chen and Nahrstedt proposed an interesting 
heuristic algorithm that modifies the problem by scaling down the values of one link weights to bounded 
integers [7]. They showed that the modified problem can be solved by using Dijkstra's (or Bellman-Ford) 
shortest path algorithm and that the solution to the modified problem is also a solution to the original 
one. When Dijkstra's al- gorithm is used, the computational complexity of their al- gorithm is O(xZn2); 
when Bellman-Ford algorithm is used, the complexity is O(xnm), where x is an adjustable pos-itive integer 
whose value determines the performance and overhead of the algorithm. To achieve a high probability of 
finding a feasible path, x needs to be as large as 10n, resulting in computational complexity of O(n4). 
In [14] Neve and Mieghem used the k-shortest paths algorithm in [9] The resulting algorithm, called TAMCRA, 
has a complexity of O(knlog(kn) + k3Km), where K is the number of con- straints. As mentioned above, 
the performance and over-head of this algorithm depend on k. Other works in the literature were aimed 
at addressing special yet important cases of the QoS routing problem. For example, some researchers focused 
on an important subset of QoS requirements (e.g., bandwidth and delay) [35]. Several path selection algorithms 
based on different combinations of bandwidth, delay, and hop-count were discussed in [5, 26, 27] (e.g., 
widest-shortest path, shortest-widest path). In addi- tion, new algorithms were proposed to find more 
than one feasible path w.r.t, bandwidth and delay (e.g., Maximally Disjoint Shortest and Widest Paths) 
[32]. Another approach to QoS routing is to exploit the dependencies between the QoS parameters and solve 
the path selection problem assum- ing specific scheduling schemes at network touters [26, 29]. Specifically, 
if Weighted Fair Queueing (WFQ) scheduling is being used and the constraints are bandwidth, queueing 
delay, jitter, and loss, then the problem can be reduced to a standard shortest path problem by representing 
all the con- stralnts in terms of bandwidth. Although queueing delay can be formulated as a function 
of bandwidth, this is not the case for the propagation delay, which is the dominant delay component in 
high-speed networks [10].  Contributions and Organization of the Paper Previously proposed algorithms 
suffer from either excessive computational complexities or low performance. In Sec- tion 2, we provide 
an efficient approximation algorithm for the MCP problem under two additive constraints. Our al- gorithm 
is based on the minimization of the same hnear cost function awl(p)-Fflw2(p) presented in [23]. This 
formulation is similar to that used in the Lagrange relaxation technique. However, in this technique, 
finding the appropriate multi-pliers (i.e., the values of ~ and fl) would typically proceed using expensive 
search mechanisms (e.g., hnear program-ming, subgradient optimization) [1]. Instead, using either (or 
= k,fl = 1) or (o~ = 1,fl = k), we provide a binary search strategy to find the appropriate value of 
k within a logarith- mic number of calls to a hierarchical version of Dijkstra's al- gorithm. The binary 
search is performed in the range [1, B]. Using an efficient implementation of Dijkstra's algorithm with 
complexity of O(m -4- nlog n) [1], the worst-case com- plexity of the proposed algorithm is O(log B(m 
+ n log n)). Its average complexity is observed to be much less than that. The space complexity is O(n). 
The proposed algorithm al- ways returns a path p. If p is not feasible, then it has the following properties: 
(a) wj(p) < cj, and (b) wi(p)is within a given factor from a feasible path f for which wi(f) is mini- 
mum, where the pair (i, j) is either (1, 2) or (2, 1). By proper interpretation of the bounds in (a) 
and (b), we also present two extensions to our basic algorithm in Section 3 to achieve further improvement 
in routing performance at small extra computational cost. Simulation results, which are provided in Section 
4, demonstrate the high performance of our algo- rithm and contrast it with other path selection algorithms. 
Conclusions and future work are presented in Section 5. 2 Basic Approximation Algorithm For MCP Before 
presenting our solution to the MCP problem, we first describe a hierarchical version of Dijkstra's shortest 
path algorithm that is used iteratively in our algorithm. In ad- 319 dition to finding one of the shortest 
paths w.r.t, l(e) ~ o~wa(e) +/3w2(e), this hierarchical version determines the minimum w~ 0 and w20 among 
all shortest paths. To carry out these tasks, some modifications are needed in the re-laxation process 
of the standard Dijkstra's algorithm (lines 4-14 in Figure 1). The standard Dijkstra's algorithm main- 
Relax(u,v) 1 if d[v] > d[u] + l(u, v) then 2 d[v] := d[u] + l(u, v) 3 7r[v] := u 4 w~[~] := w~[~] + 
w~(~, ~) 6 mi~_~ [~] := w~[~] r mi~_w~[~] := w~[~] 8 else if d[v] = d[u] + l(u, v) then 9 if min_w~ iv] 
> min_wl [u] + wl (u, v) then 10 min_wl[v] := min_wx[ul + w~(u, v) 11 end if 12 if min_w2[v] > min_w~[u] 
+ w2(u, v) then 13 min_w2[v] := min_w2[u] + w2(u, v) 14 end if 15 end if BaslcApproximation(G(V, E), 
s, t, cl, e2) // Find a path p from s to t in the network G = (V, E) //such that wl(p) =wl[t] < cl and 
w2(p) = w2[t] < c2. set Z(e) := wa(e) + ~o~(e) Ve e E 2 Execute hierarchical Dijkstra's algorithm with 
link weights {l(e) : e E E} 3 ifw2[t] < c2 and w~[t] < ca then 4 return SUCCESS 5 end if 6 if wait] > 
cl and w2[t] > c2 then 7 return FAILURE 8 end if 9 ifmin_w2[t] < c2 then 10 Execute Binary_Search(i = 
1, j = 2) /* Phase 1 */ 11 else if min_wl[t] < cl then 12 Execute Binary_Search(i = 2, j = 1) /* Phase 
2 */ 13 end if end Basic.Approximation Figure 2: Approximation algorithm for finding a feasible path 
subject to two additive constraints. Figure 1: Relaxation procedure for the hierarchical version of Dijkstra's 
algorithm. thins two labels for each node [12]: d[u] to represent the estimated total cost of the shortest 
path from the source node s to node u w.r.t, the composed weight l(e), and rr[u] to represent the predecessor 
of node u along the shortest path. The hierarchical version of Dijkstra's algorithm main- thins additional 
labels: wl[u] and w~[u] to represent the cost of the shortest path w.r.t, the individual weights, and 
labels min_wa[u] and min~.wz[u] to represent the minimum wa and w2 weights among all shortest pathsJ 
The standard relaxation process (lines 1-3 in Figure 1) tests whether the shortest path found so far 
from source node s to node v can be improved by passing through node u. If so, d[v] and r[v] are updated 
[12]. Under this condition, we add the update of wl[v], w2[v], min_wl[v], and min_we[v]. In addition, 
if the cost of the shortest path found so far from node s to node v is the same as that of the path passing 
through node u, then min_wl iv] and min_w2 iv] are also updated if passing through node u would improve 
their values. Our algorithm, shown in Figure 2, first executes the hi- erarchical version of Dijkstra's 
algorithm with link weights l(e) = w~(e) + w2(e) ¥e E, i.e., a = 1 and /3 = 1. If p is feasible, then 
the algorithm terminates. Otherwise, p is not feasible and several other cases need to be considered. 
If both wl(p) > c~ and w2(p) > c2, then it is guaranteed that there is no feasible path [23], so the 
algorithm terminates. If min_w~[t] < cl or min_w2[t] _< c2, then there might be a fea- sible path that 
can. be found using different values of a and /3. The challenging problem is how to determine appropriate 
values for c~ and/3 as fast as possible so that a feasible path can be quickly identified. Finding these 
appropriate values can also be formulated as a Lagrangian multipliers problem. But in this case, the 
search would typically proceed using ~Notice that win is a node label, whereas wi(.) indicates the weight 
of a link or the cost of a path. computationally expensive methods (e.g., enumeration, lin- ear programming, 
subgradient optimization technique) [1]. Instead, we carefully refine the search required by the La- 
grangian problem and provide a binary search strategy for a and/3 that is guaranteed to terminate within 
a logarithmic number of calls to Dijkstra's algorithm. If rain_wait] _< cl or min_w2[t] _< c2, then the 
algo-rithm executes the binary search presented in Figure 3 with (i = 1, j = 2) or (i = 2, j = 1). These 
two cases are called Binary_Search(i, j) 1 k_min := 1 2 k_max := n. max{tot(e) I e e E} 3 while( k_min 
<= k_max ) do  4 k := Nk_mi k_max I 5 Set l(e) := kw,(e) + wj(e) Ve e E 6 Execute hierarchical Dijkstra's 
algorithm with link weights {l(e) : e E E} 7 ifwl[t] _< ca and w2[t] < c~ then 8 return SUCCESS 9 end 
if 10 if rain_wilt] _< ej then 11 k_rnin := k + 1 /* k will be increased */ 12 else 13 k_max := k - 1 
/* k will be decreased */ 14 end if 15 end while end Binary.Search Figure 3: Binary search for our approximation 
algorithm. Phase 1 and Phase 2, respectively. In Phase 1, the algo- rithm executes the binary search 
using link weights l(e) = kwi(e) + w2(e) Ve E E, i.e., c~ = k and /3 = 1. In Phase 2, the algorithm executes 
the binary search using link weights l(e) = wl(e) + kw2(e) Ve E E, i.e., a = 1 and ~ = k. If the returned 
shortest path w.r.t, l(e) is not feasible, the al- gorithm repeats the hierarchical Dijkstra's algorithm 
with a different k in the range [1, B] up to a logarithmic number of times, where B = n. max{wj(e) I 
e E E}, which is an upper bound on the total cost of the longest path w.r.t, link weight wj. Lemma 1 
in Section 2.2 shows that a binary search argument in the above range can be used to deter- mine an appropriate 
value for k. Furthermore, we show (in Lemma 2) that if the binary search fails to return a fea- sible 
path, then it returns a path p such that wj(p) _< cj and wi(p) < wi(f) + (wi(f) -wj(p))/k, where f is 
some feasible path and (i,j) are either (1,2) or (2, 1). This is a reasonable scenario for searching 
fast for a feasible path that satisfies one of the constraints and that is very likely to sat- isfy the 
other constraint. According to this bound, k needs to be maximized; the above binary search tries to 
achieve this goal. In addition to maximizing k, the algorithm may attempt to minimize the difference 
(wj(f)-wj(p)) to make the approximation bound tighter. This is an extension to the basic algorithm that 
is presented in Section 3.  2.1 How the Basic Algorithm Works The systematic adjustment of k is illustrated 
in the exam- ples in Figures 4 and 5 for the two different phases. The shaded area indicates the feasibility 
region. Black dots rep- resent the costs of different paths from source node s to destination node t. 
Each line in the figure shows the equiv- alence class of equal-cost paths w.r.t, the composed weight. 
The approximation algorithm determines a line for the given value of k, and then moves this line outward 
from the origin in the direction of the arrow. Whenever this line hits a path (i.e., black dot in the 
figure), the algorithm returns this path which is the shortest w.r.t, the composed weight at the given 
k. The approximation algorithm in [23] makes a good guess for k (e.g., k = 1) and returns a path based 
on this k. How- ever, if this path is not feasible, then the algorithm in [23] cannot proceed. As shown 
in Figures 4 and 5, the likelihood of finding a feasible path is much higher if one tries different values 
of k. The advantage of our algorithm over the one in [23] is that ours searches systematically for a 
good value for k instead of fixing it in advance. If the returned path p is not feasible, then the algorithm 
decides to increase or decrease the value of k based on whether min_wj(p) _< cj or not. Figure 4 illustrates 
Phase 1 where the returned path c2 c2 0 0 0 k=l cl wl(p) 0 k=4 el wl(p) (a) (b) Figure 4: Searching 
for a feasible path in Phase 1. with k = 1 satisfies c2 but not cl. The algorithm executes the binary 
search with i = 1 and j = 2 and returns a fea- sible path when k = 4. Figure 5 illustrates Phase 2 where 
the returned path with k = 1 satisfies cl but not c2. In this case, the algorithm executes the binary 
search with i = 2 c2 0 0 k= 1 cl wl(p) 0 k=4 cl wl(p) (a) (b) Figure 5: Searching for a feasible path 
in Phase 2. and j = 1, and finally returns a feasible path when k = 4. If the binary search fails, then 
the basic algorithm stops even though there might be a feasible path in the network. In Section 3, we 
illustrate such a case and provide possible remedies to it based on a scaling extension. 2.2 Binary 
Search Lemma 1 Suppose that each link e E E is assigned a weight l(e) = kwi(e) + wi(e), where k is an 
integer, and the pair (i,j) is either (1, 2) or (2, 1), dependingon the phase. Dur-ing the execution 
of the binary search, if the algorithm can- not find a path p for which l(p) is minimum and wj(p) < cj, 
then such a path p cannot be ]ound with larger values of k. Proof of Lemma 1: The binary search is apphed 
to find the largest k such that there exists a shortest path p w.r.t, l(e) = kwi(e) + wj(e) with wj(p) 
< cj. Assume that k = 2r for some integer r. Let ~P be the set of all paths from s to t w.r.t, l(e) and 
let p be a path that the algorithm selects during the binary search. When k ---- 2r, since all edges 
are assigned weights l(e) = 2rwi(e) + wj(e), we have  l(p) = 2 w,(e) + eEq In order to prove the lemma, 
it suffices to show that if  ~ w~(e) > cj eEP then the algorithm should never search for a path p' 
that satisfies the cj constraint by assigning l(e) = rwi(e)+wj(e). By explicitly checking min_wj[t] in 
line 10 of Figure 3, the algorithm guarantees that ~eq wj(e) > cj for all short- est paths q E P, where 
l(q) = l(p). Thus, it suffices to show that if the algorithm assigns weights l(e) = 2two(e) + wj(e) and 
fails to find a feasible path w.r.t, constraint cj, then no path p' for which 2rw,(e) + W(e) > 2rw,(e) 
+w/e) (1) eEp I eEp will satisfy both two(e) + w/e) < rw,(e) + w/e) eEp I eEp and eEp t 321 when the 
value of k is reduced to r. In other words, it is useless to weight with the rule l(e) = rwi(e)+ wj(e)in 
order to search for a path p' whose ~eep' 2rwi(e) + wj(e) is not minimum but satisfies the c i constraint. 
Since path p violates the cj constraint, in order for path p' to satisfy this constraint, we must have: 
 Zw (e) - Z o. eEp eEp t Observe that Equation (1) can be rewritten as eEp I eEp / eEp e6p ! From (3) 
and (2), we have w,(e)- Z > 0 (4) e6p I eEp Based on (2) and (4), we know that the right-hand side and 
the left-hand side of the inequality (3) are positive. Thus, it can be implied that \e6Io I e6p e~p e6p 
t from which we conclude that  + w (e) > rw,(e) + w (e) eEp t eEp This, in turn, implies that p' will 
not be selected by the algorithm, which concludes the proof. 2.3 Performance Bounds Lemma 2 If the 
binary search fails to return a feasible path w.r.t, both constraints, then it returns a path p that 
satisfies the cj constraint and whose wiO cost is upper bounded as follows: w (p) _< w,(f) + (wj(f) -wj(p))/k 
where f is a feasible path, k is the maximum value that the binary search determines at its termination, 
and the pair (i,j) is either (1, 2) or (2, 1), depending on the phase. Note that the worst-case approximation 
bound for Lemma 2 is obtained when k = 1 and wj(p) = O. In this case, the bound will be wi(p) S wi(f) 
4- wj(f) S Cl + c2 (6) Since this bound is obtained in the first step where the algo- rithm starts with 
k = 1 and thereafter decides which com- posite cost function needs to be used in the binary search, it 
holds for the overall algorithm. The worst-case scenario of wi(p) = cl + c2 occurs when the only feasible 
path happens to be on the far corner of the feasibility region and the other paths have w~ (p) -4- wz(p) 
> c~ + c2. In most cases, feasible paths are scattered all around the feasibility region, allowing the 
algorithm to return a larger k, which in turn results in a tighter bound than (6). In addition, wj(p) 
is often greater than zero, further tightening the bound. Proof of Lemma 2: Let f be a feasible path 
for which wi(f) is the smallest possible among all feasible paths, where i is either 1 or 2, depending 
on the phase. Furthermore, assume that f is not dominated by any other feasible path. (We say that a 
feasible path dominates another path if it has shorter costs w.r.t, both wl0 and w20 weights.) This implies 
that wj(f) > wj(f') for any other feasible path f'. We know that wi(f' ) cannot be more than cj and it 
is less than wj(p); otherwise, the algorithm would have returned f'. Assume that the path p is infeasible. 
Since it is the shortest path, we have kwi(p) "t- wj(p) < kwi(f) "4" wj(f). (7) In addition, the path 
p satisfies the constraint cj. From (7), we can write a bound on wi(p) as follows wi(p) < wi(f) "4- (wj(f) 
-- wj(p))/k These approximation bounds provide some justification to the appropriateness of the basic 
algorithm. They also can be used to obtain heuristic solutions for the MCP problem, as described next. 
 3 Extensions of the Basic Algorithm 3.1 Finding a Path with the Closest Cost to a Con- straint From 
Lemma 2, it is clear that one way to improve the per- formance of the basic algorithm is to minimize 
the difference (wj(f) -- wj(p)), which can be achieved by obtaining a path p for which wj(p) is as close 
as possible to cj. This can be done with the following modification to the basic algorithm of Section 
2. Without loss generality, we assume that i = 1 and j = 2. Note that this extension must be used only 
if the returned path is not feasible with both min_wl[t] _< cl and min_w2[t] < c2. For the given k, 
a DAG (directed acyclic graph) that contains all possible shortest paths w.r.t l(e) is constructed. In 
fact, this can be done during the execution of the hierar- chical Dijkstra's algorithm at no extra cost. 
A path p from this bAG is selected in such a way that w2(p) is maximized, but it is still less than or 
equal to c2. Although a path p with the maximum or minimum w20 weight can be found in the DAG, it is 
not easy to find a path p for which w2(p) is as close as possible to c2 in polynomial-time. However, 
very efficient heuristics can be developed based on the fact that we can compute the maximum and the 
minimum w20 from the source to every node and from every node to the desti- nation. Let the following 
labels be maintained for each node u: M[u], m[u], /kt[u], and ~t[u]. Labels M[u] and m[u] in-dicate, 
respectively, the maximum and minimum w20 from the source to every node u. Labels /~t[u] and ~t[u] indicate, 
respectively, the maximum and minimum w20 from every node u to the destination. Labels M[u], m[u], /~t[u] 
and ~t[u] are determined by using a simple forward and back- ward topological traversal algorithm [1]. 
Considering the pairwise sum of these labels as follows, we can estimate a non-additive weight o'(u, 
v) for every link (u, v) in the DAG to indicate how close w20 of the paths passing through the link (u, 
v): 3.2 Scaling e2 - (M[u] + w2(u, v) + M[u[v]), c2 - (M[u] + w2(u, v) + ~[u[v]), or(u, v) = min_non_neg 
c2 (m[u] + w2(u, v) + MEu[v]), e~ -(m[~] + w~(~, ~) + ~[~[~]), - [ +~ where min_non_neg returns the 
minimum nonnegative value. Then, the closest path to c2 can be found via a simple graph traversal algorithm 
as follows. Starting from the source node s, the algorithm selects the link (s, u) with the minimum a. 
It then goes to node u and again selects the link (u, v) with the minimum o'. The algorithm keeps selecting 
links with minimum o" until it reaches t. Figure 6 depicts an example of how a DAG of shortest paths 
is constructed. The original network is shown in Fig- ure 6(a). Suppose a path p is to be found from 
s to t such that wa(p) < Cl = 10 and w2(p) < c2 = 10. Consider the (a) (b) Figure 6: An example of a 
network and the resulting DAG containing the three shortest paths from s to t. case when k = 1, i.e., 
the algorithm minimizes w~ (p)+w2 (p). There are three shortest paths from s to t: pl = (s, 1, t) with 
wl(pl) = 7 and w2(pl) = 11, p~ = (s,2, t) with wl(pz) = 11 and w2(p2) = 7, and p3 = (s,l,2, t) with wl(p3) 
= 9 and w2(p3) = 9. For these shortest paths, both min_w~[t] = 7 and min_w2[t] = 7 are less than the 
respective constraints, so we can apply the above extension. The corresponding DAG which contains all 
these shortest paths is shown in Figure 6(b). By traversing forward and backward on this DAG, we compute 
the labels M[u], re[u], ~r[u], and ~[u] M=5 M=6 m=5 ~t=4 ~=0 ~=o ~=2~ =I M=7 ~=2 m=5 ~=2 (a) (b) Figure 
7: Finding the closest path to c2. (see Figure 7(a)). After calculating a for each link as shown in 
Figure 7(b), the algorithm first selects link (s, 1), followed. by link (1, 2), and finally link (2, 
t). Thus, the closest path p3 is found. Since this heuristic step tends to minimize the additive difference 
in the approximation bound presented in Lemma 2, the returned path p is very likely to satisfy both cl 
and c2. In some pathological cases, an approximation algorithm that is based on a linear composite cost 
function fails to return a feasible path irrespective of how the composition is formed. We illustrate 
this situation by an example. Consider the network in Figure 8(a). Suppose a path p is to be found from 
s to t such that wl(p) < cl = 10 and w2(p) < c2 = 10. As shown in Figure 8(b), there are three paths 
from s to 15. c2=10 9 0 , .... 0 2 6 117 " wl(p) (a) (b) Figure 8: A scenario in which the basic algorithm 
fails to find a feasible path from s to t. t: Pl = (s,l,t) with wl(pl) = 2 and w2(pz) = 15, p~ = (s,2, 
t) with wl(p2) = 9 and wz(p2) = 9, and p3 = (s,3, t) with wl(p3) = 17 and w2(p3) = 2. Only p2 is feasible. 
Our approximation algorithm (e.g., Phase 2) returns a path based on the minimization of the composed 
weight l(p) = wl (p)+kw2(p). To return the feasible path p2, the algorithm needs to find an appropriate 
value for k such that l(p2) is less than both l(pl) and l(p3). Hence, the value of k needs to be greater 
than 7/6 to satisfy (l(p2) = 9 + 9k) < (l(pl) = 2 + 15k) and also less than 8/7 to satisfy (l(p2) = 9 
+ 9k) < (l(p3) = 17 + 2k). However, it is impossible to find a value for k such that 7/6 < k < 8/7. To 
address such pathological cases, we provide an exten- sion to our basic algorithm based on the scaling 
in [7]. A new weight w~(e) is assigned to every link in the original graph as follows: | c2 where x 
is an adjustable positive integer in the range [1, e~]. The problem reduces to finding a path in the 
scaled graph such that w~(p) _< Cl and w;(p) < x. It has been shown that a solution in the scaled graph 
is also a solution in the original one [7]. If we scale the network in Figure 8(a) by x = 3 (the scaled 
graph is shown in Figure 9(a)), then our basic x=3 I - ~ 2 3 (~ ___~_~(~ (5,2)~ 2 ~ .31 0 o 2 ,7 wl(p) 
'~ (a) (b) Figure 9: Scaling the network in Figure 8 by x = 3 allows the algorithm to find a feasible 
path. algorithm can find the feasible path p2 using the composed 323 weights lip ) = wz(p) + kw~(p) with 
k = 3, since l(p2) = 18 is less than both l(p~) = 20 and l(p3) = 23. Scaling often increases the number 
of shortest paths in the graph. If we apply our basic approximation algorithm to the scaled graph, t:he 
algorithm will consider more shortest paths (in the scaled graph) in each iteration of the binary search. 
It is intuitively true that the algorithm will termi- nate with a better (i.e., larger) value of k. It 
is important to note that in contrast to the algorithm in [7], the value of x does not effect the complexity 
of our algorithm. Choosing x as small as possible may increase the number of shortest paths as desired, 
ttowever, this also decreases the number of paths for which w~(p) < x, i.e., the algorithm may not return 
a feasible path. The tradeoff between the value of x and the associated performance improvement after 
scaling by x is shown in Figure 10. Here, we measure the perfor- mance of the path selection algorithm 
by the success ratio (more on that is discussed in Section 4). C2=utlifonl~[5(30,560 ] c2=tmiform~6(x),6601 
0,92~ I _+. ~~x I --8g~,'~,~.~, 0.9865 0.921E =o J i o,g855 0.921 0.9205 0.9841 1~ 1~ 200 2~ 100 200 
300 X x Figure 10: Performance of the path selection algorithm for different values of the scaling factor 
x. When the basic algorithm fails to return a feasible path, we scale the graph using different values 
of x and run the algorithm again. Clearly, one needs to select an appropri-ate value for x to improve 
the performance. The following lemma shows that a binary search argument can be used to determine an 
appropriate z in the range [1, c2]. Lemma 3 If the algorithm cannot find a path p for which w~(p) < x 
in the scaled graph by x, then such a path cannot be found in a graph that is scaled by x' < x. Proof 
of Lemma 3: Let the graph G be scaled by x = 2r for some integer r, and let "P be the set of all possible 
paths in the scaled graph. If the algorithm fails to return a path p for which ~¢ep [_w.aLz.k~..~'] < 
2r, then / c 2 l -- eEP | C2 In order to prove the lemma, it suffices to show that if (9) is true then 
the algorithm should never search for a path p' for which w~(p') ~-~' ~eep' ,['~-~2£]¢~ , < r -when the 
links of the graph are scaled down by x = r. Since we know that we can rewrite (9) as   2 ~/---.--~l 
> 2r Vp I ~ ~ (11) r=:+.,1 eEp: from which we conclude eEp# I C2 This, in turn, implies that no path 
pl E ~ will be selected by the algorithm, and the claim is true. 4 Simulation Results and Discussion 
In this section, we contrast the performance of our basic al- gorithm with Jaffe's second approximation 
algorithm [23], Chen's heuristic algorithm in [7], and the first e-optimal al- gorithm in [20]. In [23] 
Jaffe presents two approximation algorithms for the MCP problem based on the minimization of w~(p) + 
dw2(p), where d = 1 in the first algorithm and d = X/Cl/C2 in the second. Of the two approximations, 
the latter provides better performance, and hence it will be used in our comparisons. As a point of reference, 
we also report the results of the exact (exponential-time) algorithm, which considers all possible paths 
in the graph to determine if any of them is feasible. The performance has been measured for various network 
topologies. For brevity, we report the results for one of these topologies under both homogeneous and 
heterogeneous links. 4.1 Simulation Model and Performance Measures In our simulation model, a network 
is given as a directed graph. Link weights, the source and destination of a con- nection request, and 
the constraints Cl and c2 are all ran- domly generated. If the path selection algorithm returns a feasible 
path for a connection request, we count this request as a routed connection request. In order to contrast 
the performance of various path selection algorithms, we use a measure called the success ratio (SR), 
which shows how often an algorithm finds a feasible path [7]: Total number of routed connection requests 
SR= Total number of connection requests Another important performance aspect is the computational complexity. 
In here, we measure the complexity of path se- lection algorithms by the number of performed Dijkstra's 
iterations. While the algorithm in [23] requires only one it- eration, the algorithm in [7] always requires 
x 2 iterations, where x is an adjustable positive integer. The number of it- erations in our algorithm 
varies in the range [1,log B], where B is the upper bound on the longest path according to one of the 
link weights. For our algorithm, the average number of Dijkstra's iterations (ANDI) per connection request 
is mea- sured and compared with the constant number of Dijkstra's iterations in the other algorithms. 
4.2 Results Under Homogeneous Link Weights We consider the network in Figure 11, which has been mod- 
ified from ANSNET [11] by inserting additional links. Link weights are randomly selected with wz (u, 
v) ~ uniform[O, 50] and w2(u,v) ~ uniform[O,200]. The same network was used in [7]. For different ranges 
of cl and c2, Table 1 shows the SR of various algorithm based on twenty runs; each run is based on 2000 
randomly generated connection re-quests. For our algorithm, the ANDI for each range in Table 1 is given 
by 2.49/2.63/2.23/1.61/1.21, respectively. The number of feasible paths, and thus the SR, increases as 
324 Range of cl and c2 Cl ~ uniform[50, 65] c2 ~ uniform[200,260] cl ~ uniform[75,90] c2 ~ uniform[300,360] 
Cl ~ uni f orm[lO0,115] c~ ~ uniform[400,460] c 1 ~ uniform[125,140] c2 ~ uniform[500,560] Cl ~ uniform[150,165] 
c2 ~ uniform[600,660] Exact Our Alg Jaffe's Chen's e-optimal Ix = 2) Ix = I0) (~ = 1) (¢ = 101 0.2594 
0.2590 0.2505 0.1935 0.2554 0.2524 0.2099 0.5220 0.5190 0,4906 0.3004 0.5003 0.5057 0,3479 0.7595 0.7535 
0.7088 0.3308 0.7216 0.7430 0.4703 0.9219 0.9145 0.8674 0.3308 0.8787 0.9079 0.5639 0.9868 0.9819 0.9524 
0.3308 0.9609 0.9805 0,6281 Table 1: SR performance of several path selection algorithms (homogenous 
links). 10 2 I 2J 4 Figure 11: An irregular network topology. the constraints get looser. As this happens, 
the ANDI in our algorithm goes down. The overall average complexity per connection request is about two 
iterations of Dijkstra's algorithm. In terms of SR, our algorithm performs very close to the exact one. 
The results show that our algorithm provides significantly superior performance to Jaffe~s approximation 
algorithm. To compare our algorithm with Chen's heuristic algorithm [7] and the e-optimal algorithm [20], 
we need to properly set the values of x and ¢, respectively. In theory, as x goes to infinity and as 
 goes to 0, the performance of the corresponding algorithms approaches that of the exact one. However, 
since the complexities of these algorithms de- pend on x and , large values for x and small values for 
 clearly make the corresponding algorithms impractical. To get as close as possible to achieving about 
the same average computational complexity of our algorithm, we set x = 2 and = 10. With x = 2, the performance 
of Chen's al- gorithm lags significantly behind ours. Even if we increase x to 10, making the computational 
requirement of Chen's algorithm several times that of our algorithm, its perfor-mance still lags behind 
ours. For c = 10, both our algorithm and the e-optimal algorithm have roughly the same aver-age complexity; 
with our algorithm providing better per-formance. More specifically, it improves the success rate of 
the -optimal algorithm by about 50%. The -optimal al- gorithm uses a dynamic-programming approach that 
main- tains a scaled cost array with size of (n/ ) at each node and it can determine paths whose scaled 
cost is less than (n/ ). As we increase the values of cl and c2, more of longer paths become feasible, 
but the e-optimal algorithm cannot deter-mine them unless gets very small. For example, the per- formance 
of the -optimal algorithm becomes close to that of our algorithm when = 1. However, in that case, the 
average complexity of our algorithm is about 10% of that of the -optimal algorithm. 4.3 Performance 
Under Heterogeneous Links The uniformity of link weights in a network may severely im- pact the performance 
of a path selection algorithm. Hence, before drawing any general conclusions, we need to examine the 
performance in a network with heterogeneous links. For this purpose, we consider the same network in 
Figure 11. We divide the network into three parts, as shown in Figure 12. Each link is associated with 
two weights wl and w2, which ................................... ',. 5 ; """ .............. 17 , "'. 
31 .'"  Figure 12: Network topology with heterogeneous link weights. are determined as follows: if u 
is a node that belongs to the upper part of the network, then wl (u, v) ,,~ uniform[70, 85] and w2(u, 
v) ,,~ uniform[l, 5]; if ~ is in the middle part, then w,(u, v) ,.~ uniform[45, 55] and w2(u, v) N uniform[45,551; 
and if u is in the lower part, then wl (u, v) .., uniform[l, 5] and w2(u,v) ~ uniform[70,85]. The source 
node is ran-domly chosen from nodes 1 to 5. The destination node is randomly chosen from nodes 22 to 
30. For different ranges of Cl and c2, Table 2 shows the SR of various algorithms based on twenty runs; 
each run is based on 2000 randomly generated connection requests. For our algorithm, the ANDI is 4.03/4.59/4.55/4.52/2.75 
for the var- ious ranges in Table 2. Under heterogeneous link weights, the performance of an approximate 
or a heuristic path se-lection algorithm, in general, is not as good as in the case of homogeneous links. 
One can attribute this performance degradation to the "symmetric" nature of the constraint functions, 
which favor links with homogeneous character-istics. Our algorithm still provides superior performance 
to Jaffe's approximation algorithm. To compare our algorithm with the others, as discussed in the homogeneous 
case, we need ~nge of cl and c2 Exact Our Alg Jaffe's Chen's e-optimal (x = 3) (x = 10) (e = 1) (e = 
10) 1 ~ uniform[200,215] c 2 ~ uniform[200,215] 0.1278 0.1146 0.0829 0.0740 0.0964 0.1276 0.0742 "~ 1 
~ uniform[215,230] c 2 ~ uniform[215,230] 0.1739 0.1568 0.1210 0.0927 0.1494 0,1739 0.1067 c 1 ~ uniform[230,250] 
c 2 ~ uniform[230,250] 0.2841 0.1906 0.1678 0.1081 0.2160 0.2841 0.1508 I ~ uniform[250,300] c ~ ~ unlform[250,300] 
0.4572 0.3236 0.2771 0.1131 0.4113 0.4559 0.2891 t ~ uniform[300,360] _c ~ ~ uniform[300,360] 0.8709 
0.6704 0.5805 0.1131 0.7590 0.8535 0.6260 Table 2: SR performance of several path selection algorithms 
(heterogenous links). to properly set the values for x and e. To achieve about the same average computational 
complexity of our algorithm, x and are set to 3 and 10, respectively. With these values, these algorithms 
lag behind our algorithm. Their perfor- mance gets better as x increases and decreases. However, in 
that case, their computational complexities become at least 10 times that of our algorithm. Conclusions 
and Future Work QoS-based routing subject to multiple additive constraints is an NP-complete problem 
that cannot be exactly solved in polynomial time. To deal with this problem, we pre-sented an efficient 
approximation algorithm that uses a bi- nary search strategy. Our algorithm is supported by per- formance 
bounds that reflect the effectiveness of the algo- rithm in finding a feasible path. We studied the performance 
of the algorithm via simulations under both homogeneous and heterogeneous link weights. Our results show 
that the proposed algorithm outperforms existing ones in complex- ity and/or performance. We also presented 
two extensions to our basic algoritlhm that can be used to further improve its performance at little 
extra computational cost. The first extension, which is motivated by the presented theoretical bounds, 
attempts to find the closest feasible path to a con- straint. The other extension, namely scaling, improves 
the likelihood of finding a feasible path by perturbing the lin- earity of the search process (or equivalently, 
changing the relative locations of the paths in the parameter space). Our basic approximation algorithm 
runs a hierarchical version of Dijkstra's algorithm up to log B times, where B is an upper bound on the 
longest path w.r.t, one of link weights. When scaling is used, the algorithm runs Dijkstra's algorithm 
up to log c2 log B times. These worst-case complexities are rarely used in practice. I:n fact, simulation 
results indicate much better average complexities for the basic algorithm. The space complexity of our 
algorithm is O(n). The proposed algorithm assumes a flat network and com- plete knowledge of the network 
state. In practice, the true state of the network is not available to every source node at all times 
due to network dynamics, aggregation of state information (in hierarchical networks), and latencies in 
the dissemination of state information. Our future work will fo- cus on investigating the MCP problem 
in the presence of inaccurate state information and the tradeoffs between the accuracy of the path selection 
process and that of topology aggregation (for spatial scalability) and/or the frequency of advertisements 
(for temporal scalability). Another aspect that we plan to investigate is that of renegotiation. When 
our algorithm fails to return a feasible path, it always returns a path which is close to satisfying 
the given constraints. Hence, we plan to investigate how such a path can be ad- vantageously used in 
the renegotiation process to achieve further performance improvements. References [1] R. K. Ahuja, T. 
L. Magnanti, and J. B. Orhn. Network Flows: Theory, Algorithms, and Applications. Prentice Hall, Inc., 
1993. [2] A. Alles. ATM internetworking. White Paper, Cisco Systems, Inc., May 1995. [3] Y. P. Aneja, 
V. Aggarwal, and K. P. K. Nalr. Shortest chain subject to side constraints. Networks, 13:295-302, 1983. 
[4] G. Apostolopoulos et al. QoS routing mechanisms and OSPF extensions. Technical Report draft-guerin-qos- 
routing-ospf-05.txt, Internet Engineering Task Force, April 1998. [5] G. Apostolopoulos, R. Guerin, S. 
Kamat, and S. K. Tri- pathi. Quality of service based routing: A performance perspective. In Proceedings 
of the AOM SIGOOMM '98 Conference, pages 15-26, Vancouver, British Columbia, Canada, August-September 
1998. [6] D. Blokh and G. Gutin. An approximation algorithm for combinatorial optimization problems with 
two pa- rameters. IMADA preprint PP.1995-14, May 1995. [7] S. Chen and K. Nahrstedt. On finding multi-constrained 
paths. In Proceedings o/the 1CC '98 Con- ference, pages 874 -879. IEEE, 1998. [8] S. Chen and K. Nahrstedt. 
An overview of quaJity- of-service routing for the next generation high-speed networks: Problems and 
solutions. 1EEE Network, 12(6):64-79, Nov-Dec 1998. [9] E. I. Chong, S. R. Sanjeev Rao Maddila, and S. 
T. Morley. On finding single-source single-destination k shortest paths. In the Seventh International 
Conference on Computing and Information (ICCI '95), pages 40- 47, July 5-8, 1995. [10] D. Clark et al. 
Strategic directions in networks and telecommunications. ACM Computing Surveys, 28(4):579-690, 1996. 
 326 [11] D. E. Comer. lnternetworking with TCP/IP, volume I. Prentice HHMI, Inc., third edition, 1995. 
[12] T. H. Cormen, C. E. Leiserson, and R. L. Rivest. Intro-duction to Algorithms. The MIT press and 
McGraw-Hill book company, sixteenth edition, 1996. [13] E. Crawley et al. A framework for QoS-based routing 
in the Internet. Internet draft, IETF, July 10, 1998. (draft-ietf-qosr-framework-06.txt). [14] H. De 
Neve and P. Van Mieghem. A multiple quality of service routing algorithm for PNNI. In Proceedings of 
the ATM Workshop, pages 324 - 328. IEEE, May 1998. [15] D. Eppstein. Finding the k shortest paths. In 
Proceed-ings of the 35th Annual Symposium on Foundations of Computer Science, pages 154 -165. IEEE, Nov. 
1994. [16] M. R. Garey and D. S. Johnson. Computers and Intractability, A Guide to the Theory of NP-Completeness. 
Freeman, San Francisco, 1979. [17] R. Guerin and A. Orda. QoS routing in networks with inaccurate information: 
Theory and algorithms. IEEE/A CM Transactions on Networking, 7(3):350 -364, June 1999. [18] L. Guo and 
I. Matta. Search space reduction in QoS routing. In Proceedings of the 19th 1EEE International Conference 
on Distributed Computing Systems, pages 142 - 149. IEEE, May 1999. [19] G. Y. Handler and I. Zany. A 
dual algorithm for the constrained shortest path problem. Networks, 10:293-310, 1980. [20] R. Hassin. 
Approximation schemes for the restricted shortest path problem. Mathematics of Operations Re- search, 
17(1):36-42, 1992. [21] K. Ishida, K. Amano, and N. Kannari. A delay-constrained least-cost path routing 
protocol and the synthesis method. In Proceedings of the Fifth Inter- national Conference on Real-Time 
Computing Systems and Applications, pages 58 - 65. IEEE, Oct. 1998. [28] A. Orda. Routing with end-to-end 
QoS guarantees in broadband networks. IEEE/A CM Transactions on Net- working, 7(3):365-374, 1999. [29] 
C. Pornavalai, G. Chakraborty, and N. Shiratori. QoS based routing algorithm in integrated services packet 
networks. In Proceedings of ICNP '97, pages 167-174. IEEE, 1997. [30] H. F. Salama, D. S. Reeves, and 
Y. Viniotis. A dis- tributed algorithm for delay-constrained unicast rout-ing. In Proceedings of the 
INFOCOM '97 Conference, volume 1, pages 84-91. IEEE, 7-11 April 1997. [31] C. C. Skiscim and B. L. Golden. 
Solving k-shortest and constrained shortest path problems efficiently. Ann. Oper. Res., 20(1-4):249-282, 
1989. [32] N. Taft-Plotkin, B. Bellur, and R. Ogier. Quality-of-service routing using maximally disjoint 
paths. In the Seventh International Workshop on Quality of Ser- vice (IWQoS '99), pages 119 -128, London, 
England, May/June 1999. IEEE. [33] R. Vogel et al. QoS-based routing of multimedia streams in computer 
networks. IEEE Journal on Selected Areas in Communications, 14(7):1235-1244, September 1996. [34] Z. 
Wang. On the complexity of quality of service rout- ing. Information Processing Letters, 69(3):111-114, 
1999. [35] Z. Wang and J. Crowcroft. Quality-of-service routing for supporting multimedia applications. 
IEEE Jour-nal on Selected Areas in Communications, 14(7):1228-1234, September 1996. [36] R. Widyono. 
The design and evaluation of routing al- gorithms for real-time channels. Technical Report TR- 94-024, 
University of California at Berkeley &#38; Interna- tional Computer Science Institute, June 1994. [37] 
X. Xiao and L. M. Ni. Internet QoS: a big picture. IEEE Network, 13(2):8-18, March-April 1999. [22] A. 
Iwata et al. ATM routing algorithms with multi- ple QOS requirements for multimedia internetworking. 
1EICE Trans. Commun., E79-B(8):999-1006, August 1996. [23] J. M. Jaffe. Algorithms for finding paths 
with multiple constraints. Networks, 14:95-116, 1984. [24] K. Lee et ai. QoS based routing for integrated 
multi-media services. In Proceedings of the GLOBECOM '97 Conference, volume II, pages 1047-1051. IEEE, 
1997. [25] W. C. Lee, M. G. Hluchyi, and P. A. Humblet. Routing subject to quMity of service constraints 
in integrated communication networks. IEEE Network, pages 46-55, July/August 1995. [26] Q. Ma and P. 
Steenkiste. On path selection for traffic with bandwidth guarantees. In Proceedings of the IEEE International 
Conference on Network Protocols (ICNP '97), pages 191 -202, 1997. [27] Q. Ma and P. Steenkiste. Routing 
traffic with quality- of-service guarantees in integrated services networks. In Proceedings of NOSSDAV 
'98, July 1998. [38] J. Zhou. A new distributed routing algorithm for sup- porting delay-sensitive applications. 
In Proceedings of ICCT '98, pages $37-06(1-7). IEEE, 22-24 Oct. 1998.   
			
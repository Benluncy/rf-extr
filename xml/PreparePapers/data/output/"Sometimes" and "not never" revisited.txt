
 Permission to make digital or hard copies of part or all of this work or personal or classroom use is 
granted without fee provided that copies are not made or distributed for profit or commercial advantage 
and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, 
to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; 
1983 ACM 0-89791-090-7 $5.00 generated by a binary relation like those used in the logics of [FL79] and 
[BMP811. We give a more refined basis for comparing expressive power that avoids these technical difficulties. 
It does turn out. that expressibility results corresponding to Lamport s still hold. However, it should 
be emphasized that these results apply only to the two particular systems that he defines. Sweeping conclusions 
regarding branching versus linear time logic in general are not justified on this basis. We will argue 
that there are several different aspects to the problem of designing and reasoning about concurrent programs. 
While the specific modalities needed in a logic depend on the precise nature of the purpose for which 
it is intended, we can make some general observations regarding the choice between a system of branching 
or linear time. We believe that linear time logics are generally adequate for verifying the correctness 
of pre-existing concurrent programs. For verification purposes, we are typically interested in properties 
that hold of all computation paths. It is thus satisfactory to pick an arbitrary path and reason about 
it. However, there are applications where we need the ability to assert the existence of alternative 
computation paths as provided by a branching time logic. This arises from the nondeterminism -beyond 
that used to model concurrency -present in many concurrent programs. In order to give a complete specification 
of such a program, we must ensure that there are viable computation patha corresponding to the nondeterministic 
choices the program might make. (h example is given in section 6.) Neither of Lamport s aystema is entirely 
adequate for such applications. In order to examine these issues more carefully, we define a language, 
CTL*, in which a universal or existential path quantifier can prefix an arbitrary linear time asaertion. 
CTL* is an extension of the Computation Tree Logic, CTL , defined in [CE81] and studied in [EH82]. This 
language subsumes both of Lamport s interpretations and allows us to compare branching with linear time. 
Moreover, the syntax of CTL* makes it clear which interpretation is intended. The paper is organized 
as follows: In section 2 we summarize Lamport s approach and discuss its limitation. In section 3 we 
present the syntax and semantics of CTL*. We also define some natural sublanguages of CTL* and compare 
their expressive power in Section 4. In particular, we show that (cf. Theorem 4.1) a language substantially 
less expressive than CTL* still subsumes both of Lamport s interpretations. Section 5 then shows how 
CTL* can be embedded in MPL [AB80] and PL [HKP80]. Finally, section 6 concludes with a comparison of 
the utility of branching and linear time logic. 2. LAMPORT S APPROACH AND ITS LIMITATIONS For the reader 
s convenience we summarize Lamport s approach here (we do take the liberty of slightly altering his notation): 
 2.1 Definition. A structure M = (S,X,L) where ----- - . S is a nonempty set of states, X is a nonempty 
set of .-paths, i.e., a .- . nonempty aet of nonempty sequences of states, and L is a labelling which 
assigns to each state a set of atomic propositions true in the state. We use s,t,s ,tl, . . . etc. to 
denote states in S and / X,Y9X >Y1*... etc. to denote sequences of states (with repetitions allowed) 
over S. A path x is a . - nonempty sequence of states. We say that a path is of length k, and write [xl 
= k, if it consists Of 1 + k states. Thus , if x is finite then [xl = k for some k ~ O, and x has the 
fOrm (50, .. ..sk ). If x is infinite then [xl = @ and has the form (so, s~, s~,... ). If x can be either 
finite or infinite it is sometimes convenient to write x = (sO, . . ..sk.. ) or even x = (si) where, 
implicitly, O <i < 1+1x1. We use first(x) to denote the first - state, of x, and last(x) to denote the 
last o> . state, sk, o f x. If x is infinite, last(x) does not exist. If [Xl > 0, we define x = (sl, 
. . ..sk) .); 0= otherwise x = x. We define the suffixes of x, x x, xm+l = (Xm) . If y # x is a suffix 
of x then y is a prope~_ suffix of x. The prefixes and proper prefixes of x are defined similarly. If 
x is a . finite sequence and y is a sequence, then the concatenation of x and y, written XYY ia the 
 sequence obtained by appending Y to x. (E.g., if x = (al,s2) and y = (s3,s4,s5) then xy = (s1,s2,s3,s4,s5). 
Similarly, if x = x s is a finite path and y = SY is a path then the fusion . of x and y, written X Y, 
is the path X SY (the fusion is undefined if last(x) # first(y)). Remark: Various constraints can placed 
on the set of paths X. In particular, Lamport [LA80] requires that X be suffix closed meaning that if 
x . - - -. <X then x f&#38; X. Similarly, we say that X is fusion closed (cf. [PR79]) if Xlsyl < X and 
x2sy2 -. k-X imply xlsy2 ~ X, We also say that X is limit - . closed (cf. [AB80]) provided that if there 
is an - --­infinite sequence of paths YOXO, YOYIXI, YOYIY2X2, . . . ~X and each yi is nonempty then 
the limit path c x. In the subsequent sections, we shall alao consider the case where X is required to 
YOY1Y2. . . be ~ ~nerable meaning that there is a (total, .. -­nonempty) binary relation R such that 
X consists precisely of the infinite sequences (s0,s1,s2, . . . ) such that (s i,si+l) ~ R for all i. 
This is a natural condition which has been assumed in many previous papers including [FL79], [EC80], 
[BMP81], and [EH82]. It is shown in [EM81] that the above three closure properties are exactly equivalent 
to R-generability. These closure properties are important in ensuring that certain commonly accepted 
identities are valid (see sections 4,5 and [Eli81]). 2.2 Syntax. Lamport inductively defines the syntax 
of a class of temporal formulae: - .- - --­ 1. Any atomic proposition P is a temporal formula. 2. 
If p,q are temporal formulae then so are pAq ( conjunction ), and p ( negation ). 3. If p is a temporal 
formula then so are  []p (meaning always p ) and >p (meaning sometimes p ).  2.3 Semantics. A temporal 
formula s meaning depends on whether it is interpreted as a formula of branching time or a formula of 
linear time. For the branching time interpretation, we write M,s I=B p to indicate that formula p is 
interpreted as true in structure M at state s. We define I B inductively: P iff PC L(s) 2. M,s . BP~ 
qiff M,s [=B Pand M,s (=Bq M,s p iff not( M,s [=B p) . B 3. M,s [1P iff d path XE Xwith first(x) = s 
B ~n~O, M,first(xn) I=Bp M,s ->p iff V path X6 X with first(x) = s B %~0, M,first(xn) I=BP Similarly, 
for the linear time interpretation we write M,x I=L p to indicate that in structure M formula p is true 
of path x. Again, we define I=L inductively: 1. M,x I=L P iff Pc L(first(x)) 2. M,x [7P ~ q iff M,x 
[=L PandM,x l% q M,x I=L p iff not (M,x I=L P)  3. M,x /=L []p iff Vn~O, M,xn IT p M,x [=L >p iff % 
>0, M,xn I=L p . For both interpretations, the modality <>p is introduced as an abbreviation for []-p 
and the other logical connective are introduced as abbreviations in the usual way. Note that in the branching 
time interpretation, a formula is true or false of a state whereas in the linear time interpretation, 
a formula is true or false of a path. Thus, we cannot directly compare the expressive power of linear 
time with branching time. In an attempt to overcome this difficulty, Lamport extends I=B and I L to entire 
models: 2.4 Definition. Given structure M = (S,X,L) temporal formula p is ~-valid under the b-ranching 
. time integretation, written M I=B p, provided that - ----­for every state s ~ S, M,a I=B p. Similarly, 
p is M-valid under the linear time interpretation, --- --- ----- ______ ____ _______ . . . . . ­written 
M I=L p, provided that for every path x CX, M,x l=Lp. Next, Lamport defines his notion of equivalence: 
2.5 Definition. Formula p under interpretation X is strongly gqu&#38;v:Ae_n~-to formula q under interpretation 
Y, written p ss q, provided that for every structure M, M I=xp iffM [=yq Using this formalism, Lamport 
argues that linear time and branching time have incomparable expressive power: 2.6 Theorem ([LA80]). 
<>P in branching time is not strongly equivalent to any assertion of linear time. 2.7 Theorem ([LA80]). 
->[]P in linear time is not strongly equivalent to any assertion of branching time. We have several criticisms 
of the formalism. Note that defining a formula as true or false of an entire model causes useful information 
to be lost. For example, in the branching time interpretation although there is a model M with states 
S,S such that M,s I=B ->P ~ P and M,s I=B -(->P A -P), there is no model M such that M I=B ->p ~ p. Similar 
remarks apply for the linear time interpretation. Thus, we get 2.8 Proposition. In linear time or in 
branching time, ->P ~ P s~ ~a@~. This shows that s 1s too coarse an equivalence relation in that it 
classifies satisfiable formulae as equivalent to false. Moreover, since the same notation is used for 
both branching and linear time formulae, it is not clear from the syntax which interpretation is intended. 
This has the effect of obscuring the essential difference between the two interpretations, namely, that 
linear time formulae make assertiona about paths and branching time formulae make assertions about states. 
It also causes difficulties when translating from English into the formalism. We also disagree with Lamport 
s conclusion that linear time logic is superior to branching time logic for reasoning about concurrent 
programs. Lamport gives two specific arguments to justify this claim: 1. To establish certain liveness 
properties of a concurrent program, it is frequently necessary to appeal to some sort of fair scheduling 
constraint such as strong eventual fairness (which means that if a process is enabled for execution infinitely 
often, then eventually the process must actually be executed). This constraint can be expressed in linear 
time logic by the formula (->[] ENABLED) V ->EXECUTED. However, it is not expressible in branching time 
logic. 2. In proving  a Program correct, it is often helpful to reason using the principle that, along 
any path, either property P is eventually true or is always false. This amounts to assuming an axiom 
of the form ->P V []-P wh~ch is M-valid for all models M under the linear time interpretation, but not 
under the branching time interpretation. The first observation is certainly true for the particular systems 
that Lamport has defined. However, by using a branching time logic with appropriate operators (such as 
the infinitary quantifiers used in [EC801) these assertions can be easily expressed. Indeed, by adding 
enough modalities to a branching time logic, any assertion . of Lamport s linear time can be expressed 
as described in section 4. In regard to the second point, it is true that the given formula is valid 
(i.e., true in all models) under the linear time interpretation but not under the branching time interpretation. 
However, the formula is not a correct translation of the principle into the formalism under the branching 
time interpretation. We believe that this is an instance of the confusion caused by the use of the same 
syntax for both interpretations. Again, it is possible to write a formula in a branching time system 
which accurately renders the principle as shown in section 3. 3. A UNIFIED APPROACH In this section 
we exhibit a uniform formalism for comparing branching with linear time that avoids the technical difficulties 
of Lamport s and allows us to examine the issues more closely. To illustrate our approach, we describe 
a language, CTL*, which subsumes Lamport s branching and linear time systems as well as UB [BM??81] and 
CTL ([EH82], [cE81]). CTL* is closely related to MPL [AR80]. (CTL* is also used in [cEs831. ) In CTL* 
we allow a path quantifier, either A ( for all paths ) or E ( for some paths ), to prefix an assertion 
p composed of arbitrary combinations of the usual linear time operators G ( always ), F ( sometimes ), 
X ( nexttime ), U ( until ), as well as the infinitary state quantifiers of [EC80], ? ( infinitely often 
), ~ ( almost everywhere ). 3.1 Syntax. We inductively define a class of state formulae (true or false 
of states) and path formulae (true or false of paths): S1. Any atomic proposition P is a state formula. 
S2 . If p,q are state formulae then soare p~ q, p S3 . If p is a path formula then Ap, Ep are state formulae 
PI. Any atomic proposition P is a path formula P2 . If p,q are path formulae then soare p~ q, p P3a. 
If p is a state formulae then Gp, Fp are path formulae P3b. If p is a path formulae then Gp, Fp are path 
formulae P4a. If p,q are state formulae then Xp, (p U q) are path formulae P4b. If p,q are path formulae 
then Xp, (p U q) are path formulae P5a. If p &#38;s a state formula then Fp, Gp are path formulae P5b 
. If p is a path formula then~p, tip are path formulae Remark: The other truth-functional connective 
are introduced as abbreviations in the usual way. As we shall see, .we could take the view that Ap  
abbreviates E-p, Fp abbreviates (true. U p), Gp abbreviates F-p, %~fa:breviates G@}~~~ ~ Fp), and 8P 
abbreviates -. Thus , we could give a substantially more terse syntax and semantics for our language 
by defining all the other operators in terms of just the primitive operators E, X,U, -, and A. Also, 
we could consider state formulae as a special case of path formulae whose truth value depends on the 
first state of the path and thus view all formulae as path formulae. This is essentially what is done 
in PL (cf. [HKP80]) and also leads to a slightly easier formulation of the syntax and semantics. Howe 
ve r, like Abrahamson [AB80] , we consider the distinction between quantification over states and over 
paths an important one that should be maintained. Moreover, this approach makes it easier to give the 
syntax of each of the sublanguages that we consider. The set of state formulae generated by the above 
rules forms the language CTL*. We, also consider a number of other languages generated by some combination 
of the above rules: The set of path formulae generated by rules Pl,2,3b gives the language L(F, G), and 
the set of state formulae generated by rules S1-3, P3a yields the language BT. As tie shall see, L(F,G) 
corresponds precisely to Lamport s linear time interpretation and BT corresponds precisely to Lamport 
s branching time interpretation. The set of path formulae generated by rules Pl,2,3b,4b corresponds to 
the language L(F,G,X,U) used in many applications (cf. [GPSS80], [Mw81]). The set of state formulae generated 
by rules S1-3, P3a,4a corresponds to the language CTL used in [CE81]. We define the language ECTL to 
be the set of state formulae generated by rules S1-3, P3a,4a,5. We can then define BT , CTL+, and ECTL+ 
to be the set of state formulae generated by adding the rule P2 to the rules for BT, CTL, and ECTL, respectively. 
CTL+was considered in [EH821 and ECTL+ is essentially the language studied in [EC80] . Both ECTL and 
ECTL+ provide us with an ability to make assertions about fair computations. 3.2 Semantics. We write 
M,s 1= p (M,x {= p) to mean that state formula p (path formula p) is true in structure M at state s (of 
path x, respectively). When M is understood, we write simply s 1= p (x 1= p). We define 1= inductively: 
S1. s 1=Piff P6 L(s) S2 . s I=p A q iffsl=pandsl=q s [=-p iff not (s 1= p) S3 . s /=Ap iff for every 
path xE X with first(x) = s, X[=p s 1= Ep iff for some path x~ X with first(x) S,x[=p . P1. x 1= p 
iff P e L(first(x)) P2. x 1=P~ qiff x 1=pand X[=q x l=-P iff not (X I=p) P3a. x 1= Gp iff for all i 
LO, first(xi) 1= p x 1= Fp iff for some i~O, ~irst(xi) 1= p P3b. x [= Gpiff for all i >0, X1 I=p x I=FP 
iff for some i > 0, xi [=p P4a. x 1= Xp iff [xl > 0 and first(xl) 1= p x 1= (P U q) iff for some i > 
0, first(xi) 1= q and for all j J_O [ j<i implies first(xj) 1= p] P4b. x [= Xp iff Ix( >0and X1 1=p x 
1= (PfJq) iff for some i >0, xi I=q -. and for all j >0 [ j<i implie; xj [=p] P5a. x I=Yp iff 1x1 =@and 
for infinitely many distinct i, first(xi) [= p x l=~piff for all but a finite number of i, first(xi) 
1= p P5b. x [=~p iff 1x1 =~and f or infinitely many distinct i, xi [= p x I=%p iff for all but a finite 
number of i, Xil=p , It is easy to check that all the equivalences mentioned in the remark in section 
3.1 hold. Observe that the following equivalences establish the claimed correspondences between Lamport 
s linear time and L(F,G) and between Lamport s branching time and BT: M,x l~L [1P iff M,x [= GP M,x [=L 
->p iff M,x 1= Fp M,S {=B []P iff M,S 1= AGp M,s I=B ->P iff M,s 1= AFP Note that under the linear time 
interpretation the formula discussed in the previous section, ->P v [I-P, corresponds to the L(F,G) formula 
FP V G-P which is clearly valid. Under the branching time interpretation it corresponds to AFP V AG-P 
which is not valid. However, the valid BT+ formula A(FP V G P) (obtained by simply prefixing the L(F,G) 
formula with A) does capture the intended principle. Clearly, a direct comparison of linear time (i.e. 
path) formulae with branching time (i.e. state) formulae is impossible. As we have seen, Lamport s approach 
of defining a formula as true or false of an entire structure leads to technical problems . How then 
can we compare linear time with branching time? Since in program verification applications, there is 
an implicit universal quantification over all possible futures when a linear time assertion is used, 
we associate with every path formula p the state formula Ap and ask whether this is expressible in a 
given branching time logic. Thus, we have the following definition: 3.3 Definition Given any language 
L of path formulae we define the language of associated state formulae B(L) = {Ap : p 6 L}. (Note that 
B(L) is not closed under negation or disjunction (cf. [AB80] ).) On this basis, we can compare any linear 
time logic L with branching time logic B by first converting L into the associated branching time logic 
B(L). This time, however, equivalence of the branching time formulae is measured by the usual notion: 
 3.4 Definition. Given state formulae p,q we say that p is equivalent to q, written p z q, provided that 
for every structure M, for every state s of M, M,. (=P iff M,s I=q. It is easy to check that z is an 
equivalence relation which refines ~g and avoids the problems of Proposition 2.8. In fact, we have the 
following results which clarify the relation between s and =s : 3.5 Proposition. For any path formula 
p, p SS Ap. Proof : Let M = (S,X,L) be an arbitrary structure. We show M [= p iff M [= Ap. If M [= p 
then for all x6X, M,x [=p. Sofor all s~S, M,. 1= Ap and thus M [= Ap. Conversely, if M [= Ap then for 
all ae S, M,. [= Ap and for all XC X starting at s, M,x 1= p. Since each x &#38; X starts at some s s, 
M,x [=P for all x6X. Thus, M 1= P. O 3.6 Proposition. For any state formulae p,q, p ~a q iff AGp E AGq. 
 Proof: (=>:) Assume P s q. It will suffice to show that M,s 1= AGp implies M,. 1= AGq because, by a 
symmetric argument, we can then conclude AGp E AGq. So suppose M,s 1= AGp where M = (S,X,L) is an arbitrary 
structure and s < S. Define X = {x ~ X : x starts at s}. If X is empty, then trivially M,s 1= AGq as 
desired. Otherwise, define M = (S ,X ,L ) with S = {s ~ S : s appears on some x e X } and L = L/S. Note 
that for any state formula r, M,. /= AGr iff M ,s != AGr iff Vs e S , (M ,s [= r). Taking r=p, we get 
kfs ~S , M ,s 1= P. Since p ~s q, VS &#38; S , we have M , s I=q. Now take r=q, to see that M,s 1= AGq 
as desired. (<=:) Assume AGp ~AGq, i.e. M,. 1= AGp iff M,. [= AGq for all M and s in M. It will suffice 
to show that M 1= p implies M 1= q as a symmetric argument will yield p SS q. NOW suppose M 1= p where 
M = (S,X,L). Then Vs &#38; S, we have M,s 1= p whence ~s E S, we also have M,s 1= AGp. Since AGp = AGq, 
~S ~S, M,s [= AGq and M,s 1= q. Thus M 1= q as desired. D 3.7 Corollary. For any path formula p and state 
formula q, p ES q iff AGAp s AGq. Finally, we compare the expressive power of two branching time languages 
as follows: 3.8 Definition. We say that L2 is at least ~s­ex~ressive as L1, written Ll ~ L2, provided 
that .-. ----. for every p 6 LI there exists q~ L2 such that p s q. We say that LI is exactly as expressive 
as L2, . written Ll = L2, provided L1 ~ L2 and L2 ~ L1. Finally, LI is strictly Qss_ expressive ~~:. 
L2 , written L1 < L2, provided L1 ~ L2 and L1 ~ L2. Using this formalism, in the next section we compare 
the relative expressive power of the branching time languages defined above. We show that the following 
picture describes their relative expressive power: B(L(F, G,X,U)) < ~CTL* B(L(:G)) <AECTL+ ECTL BT+ BT 
 where any two languages not connected by a chain of < a and s s are of incomparable expressive power. 
4. EXPRESSIVENESS EESULTS In proving our expressibility results, we asaume that all structures are R-generable. 
Without such an assumption even rudimentary equivalences such as EFEFP s EFp do not necessarily hold. 
Our inexpressibility results are stronger than those Lamport obtains in that ours apply in the case of 
R-generable structures as well as a~ffix-clOsed structures whereas his apply only to suffix-closed structures. 
Our first result shows that Lamport s linear time system is expressible in the branching time logic ECTL+: 
 4.1 Theorem. B(L(F,G)) ~ECTL+. Proof: This proof involves a complicated induction on the structure 
of B(L(F,G)) formulae. Details are left to the appendix . 0 However, if we add the nexttime operator 
the situation changes: 4.2 Theorem. The formula A[F(P ~ XP)] is not equivalent to any formula q ~ ECTL+. 
Proof: We inductively define two sequences M1,M2,M3, . . . and Nl, N2, N3, . . . of models as follows. 
Define Ml,Nl to have the grapha shown below d,&#38; where in Ml, al I=P, bl I=P, dl l=-p and inNl~ al 
1=P, and dl 1= P. Suppose we have defined Mi and Ni. Then Mi+] and Ni+~ have the following graphs where 
in both Mi+l and Ni+l, ai+l 1= p> bi+l 1= p> and M~, N; are copies of Mi, Ni, respectively. It should 
be clear that (1)for all i, Mi,ai I= AIF(P ~ XP)] and Ni,ai 1= A[F(P A XP)]. We will also show that (2) 
For any ECTL+ formula p there is a CTL formula q which is equivalent to p over these two sequences of 
models. That is, for all i and all states s in Mi, Mi,s [= p s q, and similarly for Ni. (3) For any 
CTL formula p, with Ipl < i, Mi,ai I=P iff Ni,ai I=P. To see that the result follows, auppoae that A[F(P 
A XP)I is equivalent to some ECTL+ formulae p. Then by (2) above, there is a CTL formula p equivalent 
to p over these models. Now (pJl = i for some i. Then Mi,ai 1= A[F(P A XP)] which, by supposition and 
(2), implies Mi,ai [= p . By (3) this implies Ni,ai (= p , which implies, again by supposition and (2), 
that Ni,ai [= A[F(P A Xp)]. But this contradicts the fact (1) above that Ni,ai [=-A[F(P A XP)]. The details 
of the proof for (2) and (3) are provided in the appendix. D Similar combinatorial techniques can also 
be used to prove tbe following two theorems: + formula E[fp A ~Ql s 4.3 Theorem. The ECTL not equivalent 
to any formula q &#38; ECTL. Proof: Left to the appendix. o 4.4 Theorem. The ECTL formula E~P is not 
equivalent to any formula q ~ CTL+. Proof: Left to the full paper. o Theorem 4.4 also follows from the 
results of [EC80] which depend on recursion-theoretic techniques. Howe ve r, such techniques will not 
suffice to establiah Theorem 4.3. Thus , the combinatorial proof techniques used here seem to provide 
a sharper tool than does recursion theory in applications such as this. The following theorem shows that 
existential quantification over paths cannot be expressed with only universal quantification as provided 
in the languages of the form B(L(-)): 4.5 Theorem. The BT formula EFp s ot equivalent to any B(L(F,G,X,U)) 
formula. Proof: Suppose EFP s Aq for some linear time formula q over F,G,X,U. Since EFp is satisfiable, 
it must be that q is satisfiable. Thus M,x 1= q for some structure M = (S,X,L) with X = {x}. Add a successor 
s to s = first(x) which satisfies P to get a new structure. That is, let M = (S ,X ,L ) where S = s u 
{s }, x = x ~ {ss }> L (s) = L(s) for se S and L (s ) = {P}. Then M ,s 1= EFP eince blocking will not 
concern us here. and, by the supposed equivalence, M ,s 1= Aq. But The syntax of MPL is as follows: then 
M ,x [= q and also M,x 1= q, a contradiction. 1. Any atomic proposition is a formula. o portion of the 
diagram below CTL + follows The 2. If p,q are formulae then so are p, p ~ q, <>P, from the results in 
[EH82]. Xp, and p U q. We take []p to be an abbreviation for <>-p. 5. RELATION TO PL AND MPL A structure 
M is a triple (S,X,L) as before. We assume that the reader is familiar with PL An MPL formula is true 
or false of a triple M,x,y (see [HKP80] for details). We can translate CTL* where M is a structure (S,X,L), 
x ~ X, and y is a into PL in the following way: To each CTL* finite prefix of x (called a stage). If 
y,z are .- -­ structure M = (S,X,L), we associate the PL stagea or paths, we write y < z if y is a prefix 
of structure Mt = (S, (=,R) where the set of paths of z. We define (= inductively as follows: atomic 
program A, RA , is equal to X, and for any 1. M,x,y I=P iff PC L(last(y))atomic proposition P, Mt,s 1= 
P iff M,s [=P. We 2. M,x,y 1= p ~ q iff M,x,y I=p and M,x,y [=q can then give a translation of a CTL* 
formula p into an equivalent PL formula pt. We define the M,x,y 1= p iff not(M,x,y 1= p) translation 
inductively, taking the primitive 3. M,x,y I=p U q iff ~z(y~z~x and M,x,z l=q* temporal connective of 
CTL to be E, X, and U and ~w(y <w <z => M,x,w 1= p)) (c,f. the remark in Section 3.1): M,x,y 1= Xp 
iff 3z(M,z,x 1= p and y~z~xand-~(y<w <z))Pt = p for atotic propositions p 4. M,x,y [= <>p iff 3x (x E 
X, y~x , (-P)t =-(et) and M,x ,y 1= P)t=pt~qt (PA q) (p Uq)t = qt v (Pt ~f.qt) While no restrictions 
are placed on the set of (Ep)t =:-(<A>pt) paths X in defining the semantics of MPL, we must (Xp) t = 
false ~f_ p t to that are --- restrict our attention structures (Note this is equivalent to suffix closed 
as well as fusion closed in order to (~pt)) translate CTL* into MPL. These reatrictiona are necessary 
since there are CTL* formulae (e.g., Then by a straightforward induction on the EGXtrue ~ EXEGXtrue ~ 
EFEFp A EFp) which are satisfiable only in structures that are neither structure of CTL+ formulae we 
can show ­  5.1 Proposition. For all x ~ X, M,x 1= p iff Mt,x whereas every suffix closed nor fusion 
closed MPL l=pt and forallsc S, M,s l=piff Mt, (s) [= pt. formula is satisfiable in a structure that 
is both Note (p U q)t s qt or (pt suf qt) since the U suffix closed and fusion closed. This latter fact 
. operator considers the current path while the sufarises from the use of stages in defining the . 7. 
operator only depends on proper suffixes. Ep is a semantics of MPL and is proved in state formula; since 
in PL we have only path 5.2 Lemma. An MPL formula is satisfiable iff formulae, we force the truth of 
the formula to it is satisfiable in a structure that is suffix depend only on paths starting at the first 
state. closed and fusion closed. Since MPL has not been widely discussed in the Proof: Left to the 
appendix. D literature, we briefly review its syntax and If y is a stage of x, write x/y to indicatesemantics 
here before describing the translation the suffix of x obtained by deleting all but thefrom CTL* into 
MPL (see [AB80] for more details). last state of the prefix y, i.e. y (x/y) = To simplify the exposition, 
we take the liberty of x. Then we get elightly altering Abrahama on s notation. In particular, we use 
the temporal connective <>, U, 5.3 Lemma. If M = (S,X,L) and X is suffix and X instead of their duals 
[1, w, and y, closed and fusion closed then for all MPL formulae respectively. We also omit the H operator 
and view pandx~X all paths as simply sequences of states corresponding to legal sequences of transitions 
M,x,y 1= p iff M,x/y, first(x/y) 1= P Proof: A straightforward induction on the structure of p suffices. 
Note that we need fusion closure of X in order to show that M,x/y,first(x/y) 1= <>P imPlies M,x,Y [= 
<>P. Details are left to the reader. n The preceding lemma shows khat, in a suffix closed and fusion 
closed structure, we can essentially omit mention of the stages. Thus, we will write M,x (= p as an abbreviation 
for M,x,first(x) [= p. We can then translate a CTL* formula p to an MPL formula pt simply by replacing 
all occurrences of E by <>. We now get: 5.4 Theorem. Given a structure M = (S,X,L) where X is suffix 
closed and fusion closed, and path xGX, if p is a CTL* path formula then M,x 1= p iff M,x 1= pt and if 
p is a CTL* state formula then M,first(x) 1= p iff M,x 1= pt~ What do these translations tell us about 
the existence of decision procedures for CTL*?. Note that a CTL* formula p is satisfiable in a structure 
M iff the corresponding PL formula pt is satisfiable in the structure Mt. Moreover, by the definition 
of Mt in terms of M, p is satisfiable in a structure M meeting certain restrictions on its set of paths 
X (e.g., suffix closure or R­generability) iff iff pt is satisfiable in~ a structure Mt where RA meets 
the same restrictions. However, the definition of PL allows arbitrary sets of paths in the structure, 
and the original work [HKP801 on decidability of PL formula does not consider the question of restrictions 
on the sets of paths. It is true that we can modify the algorithm given in [HA821 to check if a formula 
is satisfiable in a structure where RA iS suffix closed and/or fusion closed. Alternatively, using Lemmas 
5.2 and 5.3 and Theorem 5.4 together with the fact ([AB80]) that there is an algorithm for testing satisfiability 
of MPL formulae which runa Zcn in deterministic time 0(2 ), we get 5.5 Theorem There is an algorithm 
to decide if a CTL* formula p is satisfiable in a structure which is suffix closed, fusion closed, and 
for harder. It is the limit closure constraint which causea difficulties. For instance, there is no analogue 
of lemma 5.2 for limit closure in the case of MPL. Consider the formulas <>GXtrue and ;;;;hr::r;n ;;:eeo~22 
ih~ p irst)0 tate f ome ath , Proof: We simply check if pt is satisfiable. But , the problem of 
deciding if a formula is satisfiable in an R generable structure seems much . - . []G<>Xtrue given by 
Abrahamson ([AB80], p. 110). . --If M = (S,X,L) then M,x,y 1= <>GXtrue iff there is --­an infinite path 
in X extending y and M,x,y 1= []G<>X~ru_e_iff every finite path extending y can in turn be extended by 
another path in X. It is eaey to check that _____ []G<>Xtrue is <>GXtrue~ satisfiable in a structure 
that is suffix closed and fusion closed but not limit closed. However, as Abrahamaon points out, his 
decision procedure will generate structures that are not limit closed for certain formulae satisfiable 
in limit closed structures, and there is no obvious modification of his algorithm for MPL to force it 
to generate limit closed models whenever possible. Similarly, there is no obvious modification of the 
[HA82] algorithm to force RA to be limit closed. Thus, the problem of finding an elementary time algorithm 
to decide if the CTL* formula p is satisfiable in a limit closed (or R-generable model) remains open. 
We remark that in [AB80] a complete axiomitization is given for MPL which also applies to CTL*, provided 
we restrict our attention to structures which are suffix closed and fusion closed. The problem of finding 
a complete axiomatization which applies to R-generable structures remains open. 6. CONCLUSION We believe 
that linear time logics are generally adequate for verifying the correctness of pre-existing concurrent 
programs. For verification purposes, we do not usually care which computation path is actually followed 
or that a particular path exists because we are typically interested in properties that hold of all computation 
paths. It is thus satisfactory to pick an arbitrary path and reason about it. Indeed, Owicki and Lamport 
[OL80] give convincing evidence of the power of this approach. In these situations, the simplicity of 
linear time logic is a strong point in its favor, and we see only one advantage in considering the use 
of a branching time logic. Namely, linear time logics, as interpreted over branching time structures, 
are not closed under negation. While it may be possible to prove that a property holds for all executions 
of a correct program, if a program is incorrect because the property does not hold along some execution, 
it will be impossible to disprove the property for the program as a whole. As Abrahamson [AB80] notes 
It is out of the question to attempt to disprove a property when we can t even state its negation. Furthermore, 
there are other situations for which we want the ability to explicitly assert the existence of alternative 
computation paths and must use some system of branching time logic. This arises from the nondeterminism 
-beyond that used to model concurrency -present in many concurrent programs. Consider an instance of 
the mutual exclusion problem where each process Pi is functioning as a terminal server. At any moment, 
Pi (nondeterministically) may or may not receive a character. A key attribute of a correct solution is 
that it should be possible for one particular Pi to remain in its noncritical section, NCSi, forever 
(awaiting but never receiving a character from the keyboard) while other Pj continue to receive and process 
characters. It should also be possible for Pi to receive a character and then enter its trying region, 
TRYi. From there it eventually enters the critical section, CSi, where the character is processed before 
returning to NCSi. But, no matter what happens, once Pi is in NCSi it either remains there forever or 
eventually enters TRYi. To express this property. one can use a branching time logic formula involving 
a term (intended to hold whenever is in NCSi) of the form EGi_n_N~_S-i ~ EFinTRYi pi ---­ ~ A(GinNCSi 
V FinTRYi). However, using Theorem 4.5, this is provably not expressible in linear time logic, i.e., 
in a language of the form B(L(-)). , The natural candidate formula, A(GinNCSi .. ... V F$KCQ\i), allows 
a degenerate model where all paths satisfy FinTRYi and no path satisfies . ----GinNCSJ. . - . This ability 
to existentially quantify over paths is particularly useful in applications such as automatic program 
synthesis from temporal logic specifications (cf. [CE81], [EC82]) where very precise and thorough specifications 
are needed. Of course, it is possible to successfully synthesize a wide class of interesting programs 
using only linear time logic (cf. [MW81], [w082]); but, as the remarka above demonstrate, some means 
external to the logic must be used if we wish to ensure the existence of alternative computation paths. 
We also note that explicit path quantification can be helpful in ensuring that a program exhibits an 
adequate degree of parallelism (i.e., that it can follow any one of a number of computation paths and 
is not a degenerate solution with only a single path). 7. APPENBIX Proof of Theorem 4.1: We firat define 
the set of basic formulae, B, as follows: 1. Any propositional formula (i.e. boolean combination of atomic 
propositions) is a B formula. 2. If pl, . . ..pn are propositional formulae then  P1 U (P2 U ... (pn_l 
UGPn). ..) is a B formula which we abbreviate [PI, . . ..Pnl. Intuitively, [Pi,...,Pnl means that there 
is a finite segment (possibly of length O) where PI holds , followed by a segment where p2 holds, ..., 
followed by a segment where pn_l holds , and then pn holds ever after. 3. If p is a propositional formula 
then GFp ia a B formula. 4. If p is a propositional formula,and  [Pg, . . ..po no 1,..., [P&#38;.. 
.,P:ml, [cl~>. ..)q:ol$ Frl, ..., Frn are B formulae, then F(p A [p:, . . ..p.ol A...A [P~>..., P:ml 
A x[q~, . . ..q~ol /l Frl A...A Frn) is also a B formula. (hy of the terms in the conjunction may or 
may not be present.) Let ~+ be the closure Of B under conjunction and disjunction. Note that the formulae 
of B+ can be written in conjunctive or disjunctive normal form, where the literals are formulae of B. 
Claim. For every linear time formula over F and G, there is an equivalent formula of B+. Proof of Claim: 
First note that given any linear time formula over F and G, we can use deMorgan s laws and duality (e.g. 
Fp = G-P) to drive the negations inward until only the atomic propositions appear negated. Since B+ contains 
the propositional formulae and is closed under conjunction and disjunction, it then suffices tO show 
that if p C B+, then Fp and Gp are equivalent to some B+ formula. For Fp note that, since F(ql V q2) 
E Fql V Fq2, it suffices to ahow Fp is equivalent to some +B formula just when p is a conjunction of 
formulae in B. This follows directly from 4 above  of terms in [PO A qo, . . ..pi that F(ql ~ GFq2) 
= Fql and the observation k A qjk~. >pn A qm] is consistent provided that if p ik A qjk appears ~ 
GFq~. before pih A qjh then ik ~ ih and jk ~ jh. NOW Similarly, since G(ql ~ q2) ~Gql ~ Gq2~ it observe 
that suffices to show GP is equivalent 0 ome formula just when p is a disjunction of formulae in [PI), 
. . ..Pnl A [qo, . ..>qml = (where V {[PO A qo, . . ..pik A qjk, . . ..en A qml ~+ B. This follows using 
the observation below with consistent ordering of terms}. p and the q~ are Propositional Ormulae): Thus 
, we can aasume (if p has no F s) that p G(p V Vi[P~,...~P~i 1 V VjFqj V VkGFq~ ) is of the form q A 
[po, .. ..pn] A Ai GFri by ~ again using the fact that E[q V q ] e Eq V Eq . Gp V Vi[P , P$>. ..~P: 
1 VVkGFq~ V But VXFq: V i V~,j[i(qj A XGP ) V F(qj ~ X[P ,P&#38;,P~i] E[q A [Po, ..., Pnl A Ai GFri] 
s q A E[po U EIPl U . . . EIPn_l U E[GPn A Ai Glki] ...]]. Intuitively, the first line of the right 
hand side takes care of the case that no qj is ever This is an ECTL+ formula as desired since GF s ~. 
true, and the second line covers the case that some In general, p has the form is true infinitely often. 
The third line j corresponds to all qj being true onlY finitelY q A [Po,..., enl A Frl A... A Frm A 
Ah GFsh often: the last time any qj is true, either GP or where q is propositional. Observe that one 
of the [pi, ..., pi.] will be true at the next state. This would be ~ B+ formula except that q = Ep 
s qj in some GFqj may not be a propositional formula. qA If q in GFq is not a propositional formula, 
v. EIPO U EIPI U . . . E[pj U E[Pjs.. .,Pn] A ri Ipj note that q still must be in the form of 4 above 
A Ak+i Frk A Ah GFShl...ll since it is the argument to F. Note also the (Intuitively, we are disjuncting 
over which ri gets equivalence below: satisfied first and in which segment pj this occurs.) E([pj, . 
. ..Pn] A ri A Ak+zi rk A Ah GF(P ~ [pO, O..,P~o] ~...~ [P&#38;O .,P;ml ~ 8GFsh) has one fewer F so we 
are almost ready to k:>ooo)qkol~ Frl ~...~ Frn) = apply the induction hypothesis. Only one problem GFp 
~ F([p~, . . ..p~ ]) ~...~ F([P&#38;.. .,P~m]) ~ remains: one of the conjuncts forming ri might be a 
F([q~, . . ..q~o]! ~ GFrl ~...~ GFrn formula of the form X[qo, . . ..qm]. Note that the following equivalences 
hold: By repeatedly applying this equivalence, we can get down to the case where GF only takes a propositional 
formula as an argument. This GFs s XGFS completes the proof of the claim. D [Po, . . ..Pnl ~ Vj(pj A 
X[pj>..., pnl) It remains to show that if p is a B+ formula, Fr.arj V XFrj then Ep is equivalent to 
an ECTL+ formula. Since Xql A xq2 = x(ql A q2). E(q V q ) E Eq V Eq , it suffices to Prove the By repeatedly 
applying these equivalences, we can result in the case where p is a conjunction of B rewrite [pj, ..., 
Pn] A ri A Ak+ Frk A Ah Fsh formulae. We proceed by induction on the number of as a disjunction of formulae 
of the form p A Xq formula of the form Fr (corresponding to rule 4 where p is a propositional formula 
and q is a B+ above) which appear as any subformula in p. formula. But E(P A Xq ) s P A ExM , and q 
If p has no F s, then it is of the fOrm will have less F s than the original p. By q A [P~, . . ..P~ol 
/1. .A [P~J...~P~ I ~ i GFri induction, we are done. O where q is propositional. We fir~t show that a 
proof of Theorem 4.2 (continued:) We now conjunction of formulae of the form [Po, . . ..Pnl is argue 
by induction On IPI, that fOr all CTL equivalent to a disjunction of such formulae. Given formulae p, 
[Po, . . ..enl. [ql), . . ..qm] we say that the ordering (*) if IPI <i then (Mi,ai I=P iff Ni,ai I=P). 
Note that (*) trivially implies if Ipl < i then - (Mi+l,ai 1= P iff Ni+l,ai 1= p) which in turn can be 
seen to imply (**) if [PI ~ i then (Mi+l, bi+l 1= P iff Ni+l, bi+l 1= P). We take EXq, E[q U r] and 
A[q U r] aa our primitive operators in the induction since any CTL formula is equivalent to one using 
only these modalities. The argument proceeds in cases based on the structure of the CTL formulae p. 
The cases where p is an atomic proposition, a conjunction q ~ r, or a negation q are easy and left to 
the reader. If p is of the form EXq then, Mi+l,ai+l [=EXq iff . Mi+l!bi+l l=qor Mi,ai I=q orNi,ai q iff 
Ni+l,bi+l 1= q (by **) or Mi,ai 1= q o: Ni,ai [=q iff Ni+l,ai+l 1= EXq. If p = E[q Ur] then, Mi+l,ai+l 
l= E[q Url iff (1) Mi+l,ai+l I=r or (2) Mi+l,ai+l [= q, Mi+l,bi+l 1=r or (3) Mi+l,ai+l l=q, Mi+l,bi+l 
!=q, Mi, ai I= E[q Ur] or (4) Mi+l,ai+l I=q, Mi,ai l=E[q Url or (5) Mi+l,ai+l l=q, Ni,ai l= E[qUrl 
 iff (1) Ni+l,ai+l I=r (by (*)) or (2) Ni+l,ai+l l=q, Ni+l,bi+l I=r (by (*), (**) resp. ) or  (3) 
Ni+l,ai+l [= q> Ni+l>bi+l 1= q (by (*), (**) resp.), Mi,ai l= E[qUr] or  I = q (by (*)), Mi,ai 1= E[q 
u r] or (4) N i+l,ai+l (5) Ni+l,ai+l [=q (by (*)), Ni,ai l=E[q Url  iff i+l,ai+l l= E[q Ur]. In the 
last case, if p = A[q U r] then, A[q U r] iffMi+l,ai+l ! (1) Mi+l,ai+l [= r or (2) Mi+l,ai+l 1= q, Mi+l,bi+l 
1= r, Mi,ai l=A[q U r], Ni,ai [=A[q Ur] or  (3) Mi+l,ai+l 1= q, Mi+l,bi+l 1= q, Mi,ai l= A[q Url, Ni,ai 
l=A[q Ur]  iff (1) Ni+l,ai+l 1= r (by (*)) or (2) Ni+l,ai+l I=q, Ni+l,bi+l l=r (by (**)), Mi,ai 1=A[q 
Ur], Ni, ai 1=A[q u r] or  (3) Ni+l,ai+l 1= q, Ni+l, bi+l /= q (by (**)), i,ai /=A[q Ur], Ni,ai I=A[q 
Ur]  iff i+l ai+l 1= [q u ] It remains to establish our claim that CTL and ECTL+ are of equivalent 
expressive power on the two sequences of models. For any ECTL + formula Eq, q can be placed in disjunctive 
normal form. Since E(q V q ) s Eq V Eq and 6P ~ bp s &#38;(P ~ P ), it suffices to show the equivalence 
for any ECTL+ formula of the form pl = E[p ~ $ ql A . ..A ~qn /1 %] where Ep,ql, . . ..qn are CTL+ formulae. 
TO show this, we observe that every maximal path in one of the structures M~ or Ni ends in a self-loop 
at the state d. Using c to denote either ai or bi, we thus have that Mi,c 1= pl iff Mi,c 1= Ep and Mi,d 
1= ql /1... A qn A r. Moreover, Mi,d [= ql A...A qn A r iff M.i,c l= EFAG(ql A... A qn A r). Thus, Mi,c 
1= PI iff Mi,c [= Ep A EFAG(ql A...A qn A r) and similarly, for Ni. The latter formula is in CTL+. By 
[EH82], we know that for any CTL + formula q there exists an equivalent CTL formula q. So we are done. 
O Proof of Theorem 4.3: We inductively define two sequences of models Ml,M2,M3, . ..e and N1,N2,N3, . 
. . such that for all i, Mi,ai 1= E[FP A ?Q] and Ni,ci l=-E[%P /l~Q1. We show that ECTL iS unable to 
distinguish between the two sequences of models, i.e. for all ECTL formulae P with IPI < i, Mi,ai 1= 
p ~ff Ni,ci 1= p. The result follows since if E[f! p A FQ] were equivalent to some ECTL formula P of 
length i then we would get a contradiction: Mi,~ [= P iff Ni,ci 1= p while Mi,ai 1= E[~p A FQ] and Ni,ci 
[=-E[~P A ~Q]. We define Ml, Nl to have the graphs shown below: 138 that L (t) = L(h(t)). Now define 
M = (T ,X ,L ). M,; to ~ c, c\* olba, ~d, b, where al [=P~ Q; bl [= P ~ Q,c1 I=P ~ Q, and dl 1= p ~ Q. 
Assume we have defined M{ ,N+ . Then Mi+l, Ni+l have the graphs below: where ai+l l= PA-Q, b i+~ l=-p 
A Q, ci+~ 1= P A Q, and di+l 1= P A Q. Details are given in the full paper. o Proof of Lemma 5.2: Suppose 
M = (S, X,L) and M,x,y 1= p. Let Xl {z~X[y~z}andMl= (S,X1,L). It is easy to check that Ml,x,y [= p. TO 
simplify the notation, assume for now that Xl is countable (the case where Xl is uncountable is considered 
below) and consists of the distinct paths x=x0,xl,x2,x3, . . . . We now unwind Ml into a tree-like model. 
Define a set T = {tij I i,j ~ O} fresh of states distinct from S. we WiII inductively define a set of 
paths X = {YO, Yl, Y2, ...} over T which is fusion closed along with a mapping h:T --> S as follows: 
Suppose X. = (so, s1, . . ..sk.. ) (which could be finite or infinite) . Then define y. = (tO(),t()l, 
. ..tOk).) and . h(toj) = sj for all j. We can extend h so that if y = (Uo, . . ..um.. ) then h(y) = 
(h(uo), . . ..h(um)) .). Note that h(yo) = XO, Now suppose we have constructed the paths yi for all j 
< i so that h(yj) = xi. We now define yi = (tk:,j) where for all j < 1-+ [xil kj is the least k such 
that the length j stage of Xk is also a stage of xi. Now , extend h so that h(yi) = Xi. Let T consist 
of those states of T which occur in yi fOr sOme i. Also let L be a labelling of states in T such Then 
we can show, by a straightforward induction on the structure of formulae, that for any formula q, if 
[wI ~_ [yl then M ,z,w I=q iff M,h(z),h(w) I=q. Next define X = {xi I xc X }. Using the observations 
that no state occurs twice along any path, and that two paths have a state in common iff they have a 
common prefix including the state, it is easy to check that X is fusion closed and suffix closed, Let 
M = (T ,X ,L ). Then we can argue by induction on the length of formulae q, that for x~X , M ,x,y 1= 
q iff M ,x,y 1= q. Thus, M,, is a fu,ion closed and suffix closed model of P. If xl is not countable, 
a similar argument goes through (although we seem to need the well ordering principle -which is equivalent 
to the axiom of choice -to order the paths first). O  8. REFERENCES [AB80] Abrahamson, Expressiveness 
PhD Thesis, K., of Univ. Decidability Logics of of Washington, and Processes, 1980. [BMP81] Ben-Ari, 
M., Manna, The Temporal Logic of Annual ACM Symp. Programming Languages, Z., and pnueli, Branching Time. 
on Principles 1981. A 8~~ of [cE81] Clarke, and Skeletons E. M., Synthesis using and Emerson, of Branching 
E. A,, Design Synchronization Time Temporal Logic, Logics Lecture 1981. Proceedings of the of Programs, 
Notes in Computer IBM Workshop on Springer-Verlag Science //131, [cES83] Clarke, E. M., Emerson, E. A., 
and Sistla, Finite Practical 1983. A. P., Automatic State Concurrent Approach, this Verification Programs: 
POPL conference, of A [EC80] Emerson, E. A., and Clarke, E. M., Characterizing Correctness Properties 
of Parallel Programs as Fixpoints. Proc. 7th Int. Colloquium on Automata, Languages, and Programming, 
Lecture Notes in ComPuter 1981. Science #85, Springer-Verlag, [EC82] Emerson, E. A., Branching Time Synchronization 
TR-208, Univ. of in SCP) and Clarke, Logic to Skeletons, Texas, 1982. E. M., Using Synthesize Tech. Report 
(to appear [EH82] Emerson, E. A., Decision Procedures the Temporal Logic 14th Annual ACM Computing, 1982. 
and Halpern, J. Y., and Expressiveness in of Branching Time. Symp. on Theory of [EM81] [FL791 [GPss80] 
[HA82] [H081] [HKP80] [LA80] [MW81] [0L801 [PN77] [PN81] [PR57] [PR671 [RU71] [w081] [W082] Emerson, 
E. A., Alternative Semantics for Temporal Logics, Tech. Report TR 182, Univ. of Texas, 1981. (To appear 
in TCS) Fischer, M. J., and Ladner, R. E, propositional Dynamic Logic of Regular Programs, JCSS VO1. 
18, pp. 194-211, 1979. Gabbay, D., Pnueli, A., et al., The .. Temporal Analysis of Fairness. 7= Annual 
ACM Symp. on Principles of Programming Languages, 1980. Halpern, J. Y., Deterministic Process Logic is 
Elementary, to appear in FOCS, 1982. Hailpern, B., and Owicki, S., MOdular Verification of Concurrent 
Programs Using Temporal Logic, Stanford TR, 1981. Harel, D., Kozen, D., and parikh, R., Process Logic: 
Expressiveness, Decidability, and Completeness, 12th Annual ACM Symp. on Theory of Computing, 1980. Lamport, 
L., Sometimes is Sometimes Not Never. 7th Annual ACM Symp. on Principles of Programming Languages, 1980. 
Manna, Z., and Wolper, P., Synthesis of Communicating Processes from Temporal Logic Specification, IBM 
Workshop on Logics of Programs, Springer Verlag Lecture Notes in Computer Science #131, 1981. Owicki, 
S., and Lamport, L., Proving Liveness Properties of Concurrent Programs, Computer Systems Laboratory, 
Stanford Univ., 1980. Pnueli, A., The Temporal Logic of Programs, 19th Annual Symp. on Foundations of 
Computer Science, 1977, Pnueli, A., The Temporal Logic of Concurrent Programs, Theoretical Computer Science, 
V13, pp. 45-60, 1981. Prior, A., Time and Modality, Oxford Univ. Press, London, 1957. Prior, A., Past, 
Present, and Future, Oxford Univ. Press, London, 1967. Rescher, N., and Urquhart, A., Temporal Logic, 
Springer-Verlag, Berlin, 1971. Wolper, P., Temporal Logic can be more Expressive, 22nd Annual Symp. on 
Foundationa of Computer Science, 1981. Wolper, P., Specification and Synthesis of Communicating Processes 
Using an Extended Temporal Logic (Preliminary Version) , 9th Annual ACM Symp. on Principles of Programming 
Languages, 1982.   
			
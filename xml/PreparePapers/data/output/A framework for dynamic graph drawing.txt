
 A Framework for Dynamic Graph Drawing* (Extended Abstract) R. F. Cohen* G. Di BattistaO R. Tamassia 
I. G. TollisO P. Bertolazzi Abstract In this paper we give a model for dynamic graph algorithms, based 
on performing queries and up­dates on an implicit representation of the draw­ing. We present dynamic 
algorithms for draw­ing planar graphs that use a variety of drawing standards (such as polyline, straight-line, 
orthog­onal, grid, upward, and visibility drawings), and address aesthetic criteria that are important 
for readability, such as the display of planarity, sym­metry, and reachability. Also, we provide tech­niques 
that are especially tailored for important subclasses of planar graphs such as trees and series-parallel 
digraphs. Our dynamic drawing al­gorithms have the important property of perform­ing smooth updates of 
the drawing. Of special geometric interest is the possibility of performing point-location and window 
queries on the implicit represent ation of the drawing. 11 Overview and Model I)rawing graphs is an 
important problem that combines flavors of computational geometry and graph theory. Applications can 
be found in a variety of areas includ­i ng circuit layout, network management, software engi­ r~eering, 
and graphics. For a survey on graph drawing, see [11]. While this area has recently received increas­ing 
attention (see, e.g., [2,8,14,15,19,26]), the study of *Research supported in part by the National Science 
Founda­t ion under grant CC R-9007851, by the U.S. Army Research Of­fi ce under grant DAAL03-91-G-o035, 
by the Office of Naval Re­search and the Defense Advanced Research Projects Agency un­der contract NOO014-91-J-4052, 
ARPA order 8225, and by Cadre Technologies, Jnc. *Dept. of Computer Science, Brown LJniversit y, Providence, 
 R.L 02912 1910 0Dipart. di Informatica e Sistemistica, Universit&#38; di Roma La Sapienza , Via Salaria 
113, 00198 Rome, Italy  Dept. of Computer Science, The University of Texas at Dal­las, Richardson, TX 
75083 0688 IASI CNR, Viale Manzoni 30, 00185 Rome, Italy Permission to copy without fee all or part 
of this material is granted provided that the copies are not made or distributed for direct c ommercird 
advantage, the ACM copyright notice and the title of the publication and its date appear, and notice 
is given that copying is by permission of the Association for Computing Machinery. To copy other­wise, 
or to republish, requires a fee and/or specific permission. drawing graphs in a dynamic setting has been 
an open problem. Previous work [21] only considers trees and presents a technique that restructures the 
drawing of a tree in time proportional to its height, and hence linear in the worst case. The motivation 
for investigating dynamic graph drawing algorithms arises when very large graphs need to be visualized 
in a dynamic environment, where ver­tices and edges are inserted and deleted, and subgraphs are displayed. 
Several graph manipulation systems al­low the user to interactively modify a graph; hence, techniques 
that allow fast restructuring of the drawing would be very useful. It is important that the dynamic drawing 
algorithm does not alter drastically the struc­ture of the drawing after a local modification of the 
graph. In fact, human interaction requires a smooth evolution of the drawing. In this paper we present 
dynamic algorithms for drawing planar graphs under a variety of drawing stan­dards. We consider polyline, 
straight-line, orthogonal, grid, upward, and visibility drawings together with aes­thetic criteria that 
are important for readability, such as the display of planarity, symmetry, and reachability. Also, we 
provide techniques that are especially tailored for important subclasses of planar graphs such as trees 
and series-parallel digraphs. Our dynamic drawing al­gorithms have the important property of performing 
smooth updates of the drawing. In the following we denote with n and m the number of vertices and edges 
of a given graph. A drawing r of a graph G maps each vertex of G to a distinct point of the plane and 
each edge (u, v) of G to a simple Jordan curve with endpoints u and v. We say that I is a polyline drawing 
if each edge is a polyg­onal chain; r is a straight-line drawing if each edge is a straight-line segment; 
r is an orthogonal drawing if each edge is a chain of alternating horizontal and verti­cal segments. 
A grid drawing is such that the vertices and bends along the edges have integer coordinates. Planar drawings, 
where edges do not intersect, are es­pecially important because they improve the readabil­ity of the 
drawing. A planar embedding specifies the circular order of the edges around a vertex in a planar drawing. 
Hence, different drawings may have the same planar embedding. Note that a planar graph may have an exponential 
number of planar embedding. An up-ward drawing of an acyclic digraph has all the edges flowing in the 
same direction, e.g., from bottom to top. Planar upward drawings are attracting increasing the­oretical 
and practical interest [2,6,8,10,19,28,38]. A visibility representation maps vertices into horizontal 
segments and edges into vertical segments that inter­sect only the two corresponding vertex segments. 
 We assume the existence of a resohitton rule that implies a finite minimum area for the drawing of a 
graph. Two typical resolution rules are (a) requiring integer coordinates for the vertices, or (b) a 
minimum distance 6 between any two vertices. When a resolution rule is given, it is meaningful to consider 
the problem of finding drawings with minimum area. Planar draw­ings require Q(n2) area in the worst-case 
[9]. It has recently been shown that every planar graph admits a planar straight-line grid drawing with 
0(n2) area [15, 26]. However, there exists a family of planar acyclic digraphs that require exponential 
area in any planar straight-line upward drawing [8]. Here we describe a framework for dynamic graph drawing 
algorithms. At a first glance, it appears that updating a drawing may require Q(n + m) time in the worst 
case, since we may have to change the coordi­nates of all vertices and edges. Our approach is to consider 
graph drawing problems in a query/update setting. Namely, we aim at maintaining an implicit representation 
of the drawing of a graph G such that the following operations can be efficiently performed: Drawing 
queries that return the drawing of a sub­graph S of G consistent with the overall drawing of G. We aim 
at an output-sensitive time complex­ity for this operation, i.e., a polynomial in log n and k, where 
k is the size of ,S . Ideally, the time complexity should be 0(,4 + log n). A special case of this query 
(S = {w}) returns the coordinates of a single vertex w.  Point-location queries in the subdivision of 
the plane induced by the drawing of G. Such queries are defined when the drawing of G is planar.  Window 
queries that return the portion of the drawing inside a query rectangle.  Local update operations, e.g., 
insert and delete ver­tices and edges, and update the (implicit) repre­sentation of the drawing accordingly. 
 . Global update operations, such as combining two graphs into one, or replacing an edge of a graph 
by another graph. There are two types of quality measures in dy­namic graph drawing: the aesthetic properties 
of the drawing being maintained, and the space-time com­plexity of queries and updates. There is an inherent 
tradeoff between the two. For example, it is very easy to maintain the drawing of a graph where the vertices 
are randomly placed on the plane and the edges are drawn as straight-line segments. However, the aes­ 
thetic quality of the drawings produced by this sim­ ple strategy is typically not satisfactory. On the 
other hand, if we want to guarantee optimal drawings with respect to some aesthetic criteria, e.g., planarity, 
sym­ metry, etc., the update/query operations may require high time complexity. In the following we present 
tech­ niques with polylogarithmic query/update time that maintain drawings that are optimal with respect 
to a set of aesthetic criteria. The rest of this paper is organized as follows. In Section 2 we present 
an algorithm for dynamically drawing series-parallel digraphs. In Section 3 we describe a dynamic technique 
for upward drawings of rooted trees. In Section 4 we present a family of al­ gorithms that maintain various 
types of drawings for planar st-graphs, including polyline upward drawings, and visibility representations. 
Finally, Section 5 gives conclusions and open problems. 2 Series Parallel Digraphs A series-parallel 
dzgraph is an acyclic digraph with one source and one sink recursively defined as: a single di­rected 
edge, or the series composition of two series­parallel digraphs, or the parallel composition of two series-parallel 
digraphs. We use the following method, called A-algorithm, to construct planar straight-line upward grid 
drawings of series-parallel digraphs. The algorithm modifies the embedding so that all the tran­sitive 
edges are embedded on one side, say, the right side. We call such embedding right-pushed. The A-algorithm 
recursively produces a drawing 17 of a series-parallel digraph G inside a bounding tri­angle A(r) that 
is isosceles and right-angled. The hy­potenuse of A(r) is a vertical segment and the other two sides 
are on its left. The height of A(r) is the length of the hypotenuse, from now on called the right side 
of A(r). In a series composition, the sub drawings are placed one above the other. In a parallel compo­sition, 
the subdrawings are placed one to the right of the other and are deformed in order to identify the end 
vertices, guaranteeing that their edges do not cross. The algorithm is outlined below. Details can be 
found in [3]. Modify the embedding of G into a right-pushed embedding.  If G consists of a single edge, 
it is drawn as a ver­tical segment of height 2, with bounding triangle having width 1 (see Fig. 1a). 
 If G is the series composition of G and G , the drawings I and I of GI and G are recursively constructed 
and combined by translating I so that its source is identified with the sink of G (see  Fig. 1.b). 
The bounding triangle A(I ) is obtained by extending the bottom side of A(I ) and the top side of A(I 
). If G is the parallel composition of G and G , the drawings P and I of G and G are recursively constructed. 
We consider the rightmost outgoing edge (s , u) of the source s of G and the right­ most incoming edge 
(v, t ) of the sink t of G (see Fig. 1.c). Let &#38; be the line through u that is par­allel to the bottom 
side of A(lV), and A. be the line through v that is parallel to the top side of A(P). Also, let H be 
the vertical line extending the right side of A(I ). We call prescribed region of IY the (infinite) region 
to the right of ~, &#38;, and AV. First, we translate I anywhere inside its prescribed region. Then 
we identify the sources and sinks of G and G by moving them to the intersections .s and t of the right 
side of f with the lines extending the bottom and top sides of P. In the drawing r produced by the 
A-algorithm, the source (resp. sink) of G is placed at the bottom (resp. top) vertex of A(17), and the 
other vertex of A(I ) is not occupied by any vertex of G. Also, the rightmost outgoing edge of the source 
and the rightmost incoming edge of the sink lie on the right side of A(I ). We obtain an O(nz)-area drawing 
by specializing the placement of r in a parallel composition so that A(P ) touches A(I ). For instance, 
we translate I so that the left vertex of A(I ) lies on the right side of A(P) and half-way between 
u and v. Notice that in both series and parallel compositions the height of A(I ) is equal to the sum 
of the heights of A(I ) and A(I ). Hence, the height of A(I ) is exactly 2rn, and the area of the drawing 
r is mz. A series-parallel digraph G is naturally associated with a rooted binary tree T, which we call 
SPQ-tree of G (also known as decomposition tree or parse tree). A node p E T represents a subdigraph 
of G, called the pertinent digraph of p, and denoted by Gv. If p is a leaf, then GP is a single edge. 
Otherwise, GP is obtained by the composition (series or parallel) of the pertinent digraphs of the children 
of p. The nodes of T are of three types: S-nodes, P-nodes, and Q-nodes. Tree T is defined recursively 
as follows: If G is a single edge, then T consists a single Q-node p. If G is created by the parallel 
composition of series-parallel digraphs G and G!!, let T and T t be the SPQ-trees of G and Gtt, respectively. 
The root of T is a P-node and has subtrees T and T . (The order of the subtrees is arbitrary.) If G is 
created by the series composition of series-parallel digraphs G and G t, where the sink of Gt is identified 
with the source of Gtt, let Tt and Tt be the SPQ-trees of G! and G , respectively. The root of T is an 
S-node and has left sub tree T and right sub tree T . For a node IL we define A(p) the bounding triangle 
to be the triangle enclosing the drawing of GW without considering the translation of the terminals of 
GP per­formed at ancestors of p in T. The reference point, of A(p) is the intersection of the right and 
bottom sides. If Z is a (z, y)-pair, then x(Z) returns the ~-value and y(Z) returns the y-value. In order 
to maintain the drawing of a series-parallel digraph G represented by SPQ-tree T with root p, we keep 
the following values for a node p: width(~) The width of A(p). Note that the height of A(v) will be 
2. width(p). position(p) The offset of the reference point of A(p) relative to the reference point of 
A(p). (We assume that the reference point of A(p) is at (0,0).) The following values are relative positions 
in A(p) considering the reference point of A(,u) to be at (O, O): lefichdd(p) The location of the reference 
point of the bounding triangle of the left child of p. This value is undefined for a leaf.  rightchiid(p) 
 The location of the reference point of the bounding triangle of the right child of p. This value is 
undefined for a leaf.  sourceright(~) The location of the drawing of the vertex connected to the rightmost 
outgoing edge from the source of Gfl. b sourcelefl(p) The location of the drawing of the vertex connected 
to the leftmost outgoing edge from the source of GP.  sinkright(~) The location of the drawing of the 
vertex connected to the rightmost incoming edge to the sink of GP.  sinkiefl(~) The location of the 
drawing of the vertex connected to the leftmost incoming edge to the sink of GP.  Table 1 shows the 
equations to calculate these val­ues. The following lemma characterizes the linear de­ pendence between 
the values stored on T. Lemma 1 Consider a node p and an ancestor v in SPQ-tree T. Then x(leftchild(v)) 
can be expressed as: a . width(p) + b . x(sourceright(p)) + c . w(sourceleft(p)) +d. z(sinkright(p)) 
+ e ~~(sinkleft(p)) + ~ for some a, b,c, d,e, and f. The other ualue.s x(rightchild(v)), ~(sourceright(v)), 
~(sourceleft(v)), z(sinkright(v)), z(sinkleft(v)) and width(v) can be expressed similarly. Additionally, 
the value of x(position(p)) can be expressed as: z(Position(v)) + at . width(p) + b . ~(sourceright(p)) 
+ +c %(sourceleft(p)) + d ~z(sinkright(~)) + e . r(sinkleft(p)) + f [ Type Value x s leflchild o s 
raghtchild o s source right x(sow-ceright(,a )) s sourcelefl z(sourcelefi(,a )) s sink right z(sinkright(p 
)) s sinklefi x(sinkleft(~ )) P leflchild width(p ) P r;ghtchikt o P source right x(.sourceright(,a )) 
P sourcelefi z(sourcelefi(p )) P sink right z(sinkright(p )) P sinklefl z(sinkleft(p )) sor P width width(p 
) + zuidth(p ) All position x(position(v)) + z(leflchikt(v)) Table 1: The equations to calculate the 
values for a node p and ,u . If p is the root, then position(p) = (O, O). If p and sinkright (p) = sinklefi(p) 
= (O, O). The calculations Ieflchild in the calculation of posit; on. for some a , b , c , d , e , and 
f . Similar equations hold for y-values. A series-parallel digraph G can be represented by a SPQ-tree 
T such that if node u is the parent of p and v and p are of the same type, then p is the left child of 
v. In the following, we will assume that this property, called chain invariant, holds, and we refer to 
the maximal subpaths in T of nodes of the same type as chains. We call r an S-chain if it consists of 
S-nodes and a P-chain if it consists of P-nodes. Let r = (P1, ,u2, . . . . ,u,_l) be an S-chain. The 
skeleton of r, denoted skeiet on(I ), is the digraph con­sistmg of r edges ei = (vi_ 1,v? ) , 1 ~ i s 
r, where vo and VI are the source and sink of the pertinent digraph of the left child of pl, and vi, 
2 < i < r, is the sink of the pertinent digraph of pi_l. For i = 1, ..., r 1, node pi is called the 
proper node of vertex vi. Note that vi is the join-vertex used in the series composition at node pi. 
Hence, each S-node is the proper node of a unique vertex, and each vertex distinct from s and t has a 
unique proper node. We equip the tree T with a secondary data struc­ture for maintaining the S-chains 
and their skele­tons. Namely, we store with each S-chain r = (Pi, P2, ~, P~-1) the poles vo and v, of 
its skeleton, and a balanced binary tree 7?, called routing tree, where the i-th leaf of %! (1 < i < 
r) represents edge e, of skeleton and the i-th internal node (1 < i < r 1) represents proper vertex 
vi of skeleton and the cor­ responding node pi. The routing trees allow to find in O(log m) time the 
proper S-node of a vertex v and the first and last nodes of the S-chain containing a node p. A similar 
technique of augmenting dynamic trees with balanced trees can be found in [13]. We keep T in a data structure 
based on dynamic Y o1 2. width(p ) g(sourceright(p )) g(sourcelefi(p )) y(sinkright(p )) + 2. width(p 
) y(sinklefl(p )) + 2. width(p ) width(p ) width(p ) +-(y(sinkright(p )) + y(sourceright(p ) ))/2 y(sourceright(~ 
)) + g(rightchihl(,a)) y(sourcelefi(p )) + y(rightchiki(p)) y(sirzkright(p )) + y(rightchikl(p)) y(sinkleft(~ 
)) + y(rightchikl(p)) dwsition(~)) + y(MchW~)) p that is the left child of its parent v and has children 
is a Q-node, then sourceright(p) = soumelefi(p) = (O, 1) for a right child are similar, substituting 
r-ightchild for trees [27] and dynamic expression trees [5]. Edges of T are considered to be directed 
from the child to the parent. Each edge is said to be either solid or dashed. There is at most one solid 
edge entering any node (from its children). Therefore, every vertex is on exactly one path of solid edges 
(of length O or more). We refer to these paths as solid paths. A solid path II is represented as a balanced 
binary tree BrI, so that T is then stored as a collection of these path trees. The first and last nodes 
of a path II are called the head and tail of II. We maintain the invariant, called the path invari­ant, 
that the head u and tail r of each solid path store the actual values of lefichild(cr), rightchild(u), 
sourceright (a), sowrce~efi(u), sinkright (u), sinklefl(u), ieftchiid(r), rightchild(r), sourceright(r), 
sourcelefl(r), sinkright (r), sinlidejl(r). Additionally, we store at a the value of position(u) assuming 
that position(r) = (O, O). Let II be a solid path from a to r. The leaves of tree Bn are the nodes of 
II in left-to-right order from u to T. Each internal node ~ c BH represents the sub­path of II between 
its external descendants tail(q) and head(q). We store at q the 6-tuples which describe the relationships 
bet ween the values at u and 7 (see Lemma 1). Consider a series-parallel digraph G containing vertex 
v represented by SPQ-tree T containing node v. Let p and q be query points. In this abstract we show 
how to perform the following five dynamic operations: the drawing queries Draw(v) and Dra wSubgraph(v), 
which draw a vertex v and a subgraph G., respectively; the auxiliary query Offset (v) that returns the 
coordi­nates of the reference point A(v); the point-location query -Locate (v, p) that finds the face, 
edge, or vertex of subgraph G containing query point p; and the win­dow query Window (v, p, q) that draws 
the portion of subgraph Gv contained in the query window defined Then d = d + d + width(p). by lower-left 
corner p and upper-right corner q. The separate (node () Given the root ~ of a binary full description 
of these operations is omitted due to tree, divide the tree into two trees with roots ~ space considerations. 
and < , where ~ is the root of the left subtree and Now, we show how to perform operation Draw(v). < 
is the root of the right subtree. The first step is to obtain a solid path from proper(v) roiatelefi(node 
q) (rotateright(node q)) Per­to the root of T. If such path contains dashed edges, form a left (right) 
rotation at node q. The new then we convert it into a solid path by changing dashed (a, b) pairs of the 
nodes after the rotation are com­ edges to solid and solid edges to dashed such that any puted similarly 
to the join operation. node continues to have at most one incoming solid edge. Operation Draw(v) is 
then realized by issuing This is done with the following operations, derived from e~pose (proper(v)) 
and then returning the sum of dynamic trees [27]: position and rightchild at the head of the returned 
splice (path II) This operation assumes that II is path. We use biased search trees [1] to represent 
the a solid path ending at p # p. Convert the dashed path-trees, where the weight of leaf # of a path-tree 
edge leaving p to solid and convert the solid edge is the number of nodes in the subtree of T rooted 
(if it exists) entering the parent v of ~ to dashed. at p. With this biasing, we can implement expose 
Let II be the solid path containing v. To imple­and conceal with O(log m) elementary tree operations. 
ment sp/ice(II) we need to convert edge (sib(p), v) Hence, operation Draw(v) takes time O(llog m), where 
from solid to dashed (sib(p) denotes the sibling m is the size of graph containing v (the si:ze of T 
is also of node p). Let II be the resulting solid path O(m)). Operation Oflset (p) is realized similarly: 
we starting at v. We obtain II by splitting 13nj. We call ezpose (p) and then return the value of position(p). 
complete spiice by concatenating Bn and BII1l. Operation DrawSubgraph(v) is performed by calling expose(p) 
 Convert to dashed the solid edge en-Draw on the terminals of G. and then calling Oflset (v) tering p, 
if such edge exists. Create a solid path in order to determine the position of A(v). We then from p to 
the root by converting to solid all the visit GM and compute the positions in 0(1) amortized dashed edges 
(v , v ) of such path, and convert-time per vertex and edge. ing to dashed the edges (sib (v ), v ). 
Operation Operation Locate(v, p) consists of the following expose (p) consists of a sequence of splice 
opera-steps for a graph G represented by SPQ-tree T with tions on the solid paths containing the nodes 
on root p: the path from p to p. 1.If v is not the root of its tree then call expose on conceal(p) 
 Restore the original type (solid or the parent of v in order to make v the tail of a dashed) of the 
edges entering the nodes on the solid path. path from p to p. This operation is the inverse 2. Find 
the deepest node p of T such that p is con­ of ezpose, and also consists of a sequence of splice tained 
in A(p), but not in A(p ) and A(p ) for operations. the children p and p of p. To implement concatenations 
and splits of the bal­ 3. Node p is an S-node: The face containing p is anced binary trees representing 
solid paths, we use the represented by the closest P-node ancestor v of p following elementary tree operations, 
each taking O(1) with p a descendant of the right chilld of v . If no time: such node is found then return 
the external face. join (node ( , < ) - Given the roots ( and ~ of 4. Node p is a P-node with source 
s and sink t:If pis two binary trees representing solid paths II and at Draw(t) then return t.Otherwise, 
suppose ,u is II , combine the trees into a new tree by creating a in the region of A(p) (A(p ) U A(p 
)) that also new root < with left child ~ and right child ~ . The contains the reference point of A(p). 
The other values for < can be found in 0(1) time from the case is symmetric. Define R(u) to be the triangle 
values stored at ~ , ( , head(~ ), tail(~ ), head(~ ), formed by Draw(s), sinklefi(p), and sinkright(p). 
and tail(~ ) using the equations from Table 1. Find the deepest descendant v of p such that s For example, 
suppose u , r , u , Ttt are the head is the source of Gv and p is in R(v)I (see Fig. 2). and tail of 
II and II and # is the left child of If p is on an edge of R(v) connected to s, then P-node u and p is 
the sibling of T . Let d, d , return the edge. If v is an S-node, then follow the and d be the values 
such that: procedure in step 3. Otherwise return v. 5. Node p is a Q-node: If the parent v of p is a 
P­width(~ ) = width(u ) + d node then return v . Else v is a S-nc, de and follow width(r ) = width(u 
) + d the procedure of step 3. widfh(~) = ?mWl(u) + d Each of these steps can be realizecl in O(log m) 
time, where G has m edges. Due to space limitations of this abstract most of the details are omitted. 
As an example, consider step 2. Suppose we are given a path II with head u and tail ~. Let Bn be the 
path tree for II with root { and children ( and < . Let p be contained in A(7). We want to find the deepest 
node v of II such that p is contained in A(v) but p is no contained in A(p) for child p of v on II. Using 
the 6-tuples stored at ~ and the equations from Table 1, we can determine in 0(1) time if p is contained 
in A( taii(q )). If so, then v is in the subpath represented by #, otherwise u is in the subpath represented 
by q . By repeating this process, we can find v in O(d) time, where d is the depth of v in l?n. Let II 
be the path connected to v through a dashed edge. If p is contained in A(taii(II )) then continue the 
search on II . Otherwise return v. An immediate consequence of our biasing the path trees is that this 
can be done in a total of O(log m) time. To implement operation Window we keep the data structure of 
[31] to maintain the planar embedding of G. In particular given a face f of G in an upward embedding 
of series-parallel digraph G, we can find two lists of edges and vertices that comprise the left and 
right boundary of f. Suppose p = (zP, VP) and g = (z~, y~) are points with Xp < Xq and yP < yq, and let 
W be the window defined by p and q. Operation Wtndow(v, p, q) is re­alized as follows: If W does not 
intersect A(v) then return an empty drawing. Otherwise, let p. = (~$, y.) be a scan point. Initialize 
p. top, and do the following, clipping to W: Perform Locate (v, p.). Let f be the returned face. Find 
the edge e that is to the right of p. on the boundary off. Draw the edges and vertices along the boundary 
of f until leaving W.  Repeat step 1, continuing around the boundary of W, drawing the faces of G that 
intersect the boundary of W.  Find the node w with A(v) to the right of p., A(v) completely contained 
in W, and A(v ) intersects W, where v is the parent of v. Find Oflset(v). Use the sequential algorithm 
to draw Gv.  Repeat step 3 for each maximal bounding triangle contained in W.  We implement the search 
of the list for face f in step 1 by performing binary search on the location of the vertices on the boundary. 
Each Draw call takes O(log m) time, so step 1 takes 0(log2 m) time. Each search in step 3 can be performed 
in O(log m) time by a method similar to the searches performed by op­eration Locate. Therefore, operation 
Window can be implemented in 0(log2 m) time. Theorem 1 There exists a fully dynamic data struc­ture for 
maintaining on-line a drawing r of a series­parallel digraph G such that 11 is a planar straight-line 
upward grid drawing with 0(n2) area; the space require­ment is O(n); local and global updates take O(log 
n) time; drawing queries take time O(k + logn) for a series-parallel subgraph, and O(k log n) for an 
arbitrary subgraph; point location queries take O(log n) time; window queries take O(k logz n) time; 
where n is the current number of vertices of G, and k is the size of the subgraph reported by a drawing 
or window query. 3 Trees In this section, we investigate the dynamic drawing of rooted ordered trees. 
Assume that edges are directed from the child to the parent. We consider upward draw­ings of trees with 
the following aesthetic properties: 1. Nodes of the same depth should be drawn on the same horizontal 
line. 2. The left-to-right ordering of the children of a node is preserved in the drawing. 3. A node 
is centered over its children. 4. A tree and its mirror image are drawn as reflec­tions of each other. 
A subtree is drawn the same way regardless of where it occurs in the tree.  An algorithm to draw a tree 
with these properties is given in [24]. Their algorithm constructs drawings of 0(n2) area in O(n) time. 
We give a fully ~ynamic algo­rithm with the same worst-case area bound. However, in general the drawings 
produced by the algorithm of [24] are less wide than those produced by our algo­rithm. Note that finding 
drawings of minimum width that satisfy the above properties is NP-hard [29]. For our drawing of trees, 
we use a coordinate sys­tem where the positive y direction points down. Let T be a tree. For a node p 
in T, let TP be the subtree rooted at p. Let Cl(p) be a bounding rectangle that surrounds the drawing 
of TP. The reference point of D(p) is the intersection of the left and top sides. The D-algorithm is 
as follows: For a single node A, D(J) is a 2 x 1 rectangle. Node A is drawn at offset (1, O) of D(J). 
. Consider a node v with children pl, . . . . Pd. For 2 ~ i < d, we translate p; such that the top left 
corner of D(pi) and the top right corner of DI(pi_ 1) coincide. We then translate this drawing such that 
the top of the bounding rectangles of the children of v is at offset 1 from the top of D(v). The width 
of D(v) is the sum of the width of the DI(pi), 1 < i < d. The drawing of v is at offset (O, 0.5w), where 
w is the width of D(p). Lemma 2 Given an n-node tree T, the Cl-algorithm constructs in O(n) time a drawing 
of T that satisjies properties 1 4 and has 0(n2)-area. d width(p)= ~ width(p,) ?=1 ieve~(p, ) = level(p)+ 
1 t 1 reference = reference(p) + ~ width(pj ) Table 2: The equations to calculate the values of width 
and relative of a node p and the values of reference and level of the children pl, . . . . Pd of p. If 
p is the root, then reference(p) = (O, O). If p is a leaf, then width(p) = 2. In order to maintain the 
drawing of a tree T we keep the following values for a node p: width(~) The width of D(p).  level(p) 
 The level of p in its tree. The y­position of the drawing of p will be 2 ~level(p)+ 1.  reference(p) 
 The x-position of the reference point of D(p) in the drawing of G. The y-position of the drawing of 
p will be 2. level(p).  Table 2 shows the equations to calculate these val­ues. Lemma 3 Consider a 
node p and an ancestor v in tree T. Then the values width(v), level(p), and reference (p) can be e~pressed 
as: width(v) = width(p) + a level(p) = level(v)+ b reference(p) = reference(v) + c  for some a, b, and 
c. As in the previous section, we partition T into solid and dashed paths. For each node v on solid path 
11 with child p on II, we keep two auxiliary paths called the left and right dashed paths IIl(v) and 
IIr (v) represented by path trees Bl(v) and Br (v). The nodes of IIL(v) (11~ (v)) are associated with 
the children of v to the left (right) of p in left-to-right order. If v is the head of II then IIt(v) 
contains nodes for all the children of v and II,(v) is empty. At each internal node q of the dashed trees, 
we store width(q) the sum of wtdth for the nodes of the subpath represented by q. Operation sphce(II) 
now requires that the dashed paths get split and concatenated as well as the solid paths. The values 
stored at the root of the path trees are used to calculate the 3-tuple of the path created by operation 
join. As with solid paths, we store the path trees representing dashed paths in weight biased trees. 
Even with this additional complexity, we can perform operations expose (p) and conceal(p) in O(log 71) 
time for a tree with n nodes. We provide drawing queries, window queries, and update operations that 
link trees, cut trees, and evert a tree at a node (changing the parent/child relationships along the 
path from the node to the root). The full description of these operations is omitted due to space considerations. 
Theorem 2 Th&#38;e exists a fully dynamic data struc­ture for maintaining on-line a drawzng ~ of a rooted 
tree T such that r w a planar straight-hne upward grid drawing with 0(n2) area; r displays symmetries 
and isomorphic subtrees; the space requirement is O(n); local and global updates take O(log n) time; 
draw­ing queries take time O(k + log n) for a subtree, and O(k logn) for an arbitrary subgraph; window 
queries take time O(k log n). where n is the current number of vertices of T, and k is the size of the 
subgraph reported by a drawing or window query.  4 Planar Graphs In this section we present dynamic 
techniques for draw­ing planar graphs. First, we discuss upward drawings of planar st-digraphs, and next 
we extend the results to undirected planar graphs. Planar st-graphs, which include series-parallel graphs 
as a special case, were first introduced by Lempel, Even, and Cederbaum [20] in connection with a planarity 
testing algorithm, and they have subsequently been used in a host of applica­tions, including planar 
graph embedding ~!,7,3 1], graph drawing [6,8], and planar point location [12,17,23,37]. A planar st-graph 
G is a planar acyclic directed graph G with exactly one source vertex s and exactly one sink vertex t,which 
is embedded in the plane such that s and t are on the boundary of the exter­nal face. We show how to 
dynamically maintain up­ward drawings and visibility representations of planar st-digraphs. First, we 
dynamize the polyline drawing method of [8], which has the important property of displaying symmetries 
and isomorphisms of subgraphs. Next, we dynamize the techniques of [6,33] for con­structing visibility 
representations. Note that we do not consider straight-line drawings because they may require exponential 
area [8]. Theorem 3 There exusts a fully dynamic data struc­ture for maintaining on-line a drawing r 
of a planar st-digraph G such that 1 is a planar po,lyline upward grid drawing with 0(n2) area and at 
most m bends, where m ~ 2n 5 is the number of transitive edges of G; I displays symmetries and isomorphic 
compo­nents; the space requirement is O(n); local and global updates take O(log n) time; drawing queries 
take time O(k + log n) for a component, and O(k log n) for an arbitrary subgraph; where n is the current 
number of vertices of G, and k is the size of the subgraph in a drawing query. Sketch of Proof: We consider 
two total orders, de­noted <L and <R, on the set VU EU F, where V is the set of vertices, E is the set 
of edges, and F is the set of faces of G. Such orders were used in [32]to perform reachability queries 
in a dynamic environment . Using the results in [8], we have that if G has no transitive edges, a planar 
upward grid drawing of G is obtained by assigning to each vertex v x-and y-coordinates equal to the ranks 
of v in the restriction to V of <L and <R, respectively. The method is extended to general pla­nar st-digraphs 
by inserting a dummy vertex (a bend) along each transitive edge. We represent orders <L and <R by means 
of two balanced binary trees TL and T~. The leaves of 7L are associated with the elements of V U E U 
F, sorted from left to right according to <L, and similarly for TR and <R. Each node of such trees stores 
a weight equal to the number of leaves in its subtree that are associ­ated with either a vertex or a 
transitive edge. Clearly, the data structure uses O(n) space. After an update O(1) edges become or cease 
to be transitive, and each such edge can be identified in O(log n) time. Also, the weights can be updated 
in 0(1) time per rotation. Since the orders <L and <R can be dynamically main­tained in time O(log n) 
per update operation [32], we conclude that updates take O(log n) time. To answer drawing queries, the 
x-coordinates of a vertex v can be computed in O(log n) time by access­ing the leaf A of TL associated 
with v and accumulating the weights of the left siblings of the nodes on the path from ~ to the root 
of TL. The y-coordinates of v can be computed similarly using tree TR. For a transitive edge e, the coordinates 
of the bend of e are obtained by an analogous procedure. Drawing queries for a com­ponent ,S are answered 
by first computing the position of the poles of ,5 , and then traversing the component and computing 
coordinates in amortized O(1) time per vertex and bend. 1 The concept of visibility plays a fundamental 
role in a variety of geometric problems and applications, such as art gallery problems [22], motion planning 
[18], and graph drawing [6,34]. A visibility representation O for a directed graph G maps each vertex 
v of G to a horizontal segment O(v) and each edge (u, v) to a vertical segment @(u, v) that has its lower 
endpoint on ~(u), its upper endpoint on e(v), and does not intersect any other horizontal segment. Besides 
having many applications, visibility representations are also of intrinsic theoretical interest, and 
their combinatorial properties have been extensively investigated [33,35,36, 40] . Theorem 4 There exists 
a fully dynamic data struc­ ture for maintaining on-line a visibility representation @ of a planar st-digraph 
G such that @ has integer coordinates and 0(n2) area; the space requirement is O(n); local and global 
updates take O(log n) time; draw­ing queries take time O(k log n);where n is the current number of vertices 
of G, and k is the size of the sub­graph in a drawing query. Sketch of Proof: We recall that in a planar 
st­digraph the incoming edges of each vertex appear con­secutively around the vertex, and so do the outgo­ing 
edges [33]. The face separating the incoming and outgoing edges of vertex v in the clockwise direction 
is called Iefl(v) ~ and the face separating them in the counterclockwise direction is called right(v). 
Also, the boundary of each face f consists of two directed paths enclosing f, each starting from the 
unique low­est vertex low(t) and ending at the unique highest vertex high(f). A visibility representation 
for G can be constructed by the following variation of previous sequential algorithms [6,25,33]. 1. Compute 
a topological ordering Y(v) of the ver­tices of G. 2. Compute a topological ordering X(f) of the ver­tices 
of the directed dual graph D of G (the edges of D are oriented from left to right). 3. Draw each vertex-segment 
~(v) at ordinate Y(v) and between abscissae X(lefl (v)) and X(right(v)) 1. 4. Draw each edge-segment 
O(e) at abscissa X(left(e)) and between ordinates Y(iow(e)) and Y(high(e)).  We use the ordering <L 
on G and D to dynamically maintain the topological orderings X and Y. Hence, the position of a vertex-or 
edge-segment can be com­puted in O(log n) time. D Finally, we extend our results to undirected planar 
graphs. Theorem 5 There exists a semidynamic data struc­ture for maintaining on-line a drawing ~ of a 
bicon­nected planar graph G such that I is a planar poly­line grid drawing with O(n2) area and at most 
2n 5 bends; the space requirement is O(n); insertions of ver­tices and edges take O(log n) time (amortized 
for edge insertions that modify the embedding); drawing queries take time O(k log n); where n is the 
current number oj vertices of G, and k is the size of the subgraph in a drawing query. Sketch of Proof: 
We maintain on-line an orientation of G into a planar st-digraph. This can be done using the techniques 
of [31] for embedding-preserving inser­tions, and the techniques of [7] for arbitrary insertions. D With 
a similar approach, we can derive from the data structure of Theorem 4 a semi-dynamic data structure 
for maintaining on-line visibility representa­tions and orthogonal drawings of biconnectecl planar [4] 
graphs. The space and time complexity is the same as in Theorem 5. [5]  5 Conclusions and Open Prob­lems 
[6] The contributions of this paper can be summarized as follows: We have devised a model for dynamic 
graph drawing algorithms, based on performing queries and [7] updates on an implicit representation of 
the drawing, and we have shown its applications. We have presented several efficient dynamic drawing 
algorithms for trees, [8] series-parallel digraphs, planar st-digraphs, and gen­eral planar graphs. These 
algorithms adopt a variety of representations (e.g., straight-line, orthogonal, visi­bility), and update 
the drawing in a smooth way. Fi­ [9] nally, we have shown that the implicit representation of the layout 
used by our algorithms for trees and series­parallel digraphs also supports point-location and win­dow 
queries. [10] Open problems include: Lower the complexity of window queries in trees and series-parallel 
digraphs to O(k + logn). Extend the techniques for planar st-[11] digraphs and general planar graphs 
to support point­location and window queries. Develop dynamic algo­rithms for planar straight-line drawings 
of general pla­nar graphs. The techniques of [1 5,26] appear difficult to [12] dynamize. Dynamically 
maintain orthogonal drawings with the minimum number of bends. The static algo­rithm of [30] is based 
on network flow techniques for [13] which no dynamic methods are known. Devise dynamic algorithms to 
test whether a digraph admits an upward planar drawing. Static algorithms that perform this test are 
known only for triconnected digraphs [2]and [14] for single-source digraphs [19]. Semidynamic planarity 
testing can be done with O(log n) query and insertion time [7]. Recently, a fully dynamic planarity testing 
technique with 0(n2/3) query and update time has [15] been discovered [16].  References [16] [1]S.W. 
Bent, D.D. Sleator, and R.E. Tarjan, Biased Search Trees, SIAM J. Computing 14 (1985), 545-[17] 568. 
 [2] P. Bertolazzi and Cl. Di Battista, On Upward Draw­ing Test ing of Triconnected Digraphs, Proc. A 
Citf [18] Symp. on Computational Geometry (1991). [3] P. Bertolazzi, G. Di Battista, R. Tamassia, and 
I.G. Tollis, How to Draw a Series-Parallel Digraph, Rome, Manuscript, 1991. [19] N. Chiba, T. Nishizeki, 
S. Abe, and T. Ozawa, A Linear Algorithm for Embedding Planar Graphs Us­ing PQ-Trees, J. of Computer 
and System Sciences 30 (1985), 54-76. R.F. Cohen and R. Tamassia, Dynamic Expres­sion Trees and their 
Applications ,) Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), 52-61. G. Di Battista and R. Tamassia, 
Algorithms for Plane Representations of Acyclic Digraphs, Theoret­ical Computer Science 61 (1988), 175 
198. G. Di Battista and R. Tamassia, Incremental Pla­narity Testing, Proc. 30th IEEE Symp. on Founda­tions 
of Computer Science (1989), 436 441. G. Di Battista, R. Tamassia, and I.G. Tollis, Area Requirement 
and Symmetry Display in Drawing Graphs, Proc. ACM Symp. on Computational Ge­ometry (1989), 51 60. D. 
Dolev, F.T. Leighton, and H. Trickey, Planar Em­bedding of Planar Graphs, in Advances in Compu t­ing 
Researchj VOJ. 2, F.P. Preparata, cd., JAI Press Inc., Greenwich, CT, 1984, 147 161. P. Eades and X. 
Lin, How to Draw Directed Graphs, Proc. IEEE Workshop on Visual Languages (VL 89) (1989), 13-17. P. 
Eades and R. Tamassia, Algorithms for Automatic Graph Drawing: An Annotated Bibliography, Dept. of Computer 
Science, Brown Univ., Technical Report CS-89-09, 1989. H. Edelsbrunner, L.J. Guibas, and J. Stolfi, 
OptimaJ Point Location in a Monotone Subdivision, SIAM J. Computing 15 (1986), 317-340. D. Eppstein, 
G.F. Itahano, R. Tamassia, R.E. Tarjan, J. Westbrook, and M. Yung, Maintenance of a Miu­imum Spanning 
Forest in a Dynamic Plane Graph, .7. of Algorithms 13 (1992), 33-54. M. Formann, T. Hagerup, J. Haralambides, 
M. Kauf­mann, F.T. Leighton, A. Simvonis, E. Welzl, and G. Woeginger, Drawing Graphs in the Plane with 
High Resolution, Proc. IEEE Symp. on Foundations of Computer Science (1990), 86-95. H. de Fraysseix, 
J. Path, and R. Pollack, How to Draw a Planar Graph on a Grid, Combinatorics (1990), 41-51. Z. Galil, 
G.F. Italiano, and N. Sarnak, Personal Com­munication, 1991.  M.T. Goodrich and R. Tamassia, Dynamic 
Trees and Dynamic Point Location, Proc. 23th ACM Symp. on Theory of Computing (1991), 523-533. L. J, 
Guibas and F.F. Yao, On Translating a Set of Rectangles, in Advances in Computing Research, vol. 1, F.P. 
Preparata, cd., JAI Press Inc., Greenwich, CT, 1983, 61 77.  M.D. Hutton and A. Lubiw, Upward Planar 
Drawing of Single Source Acyclic Digraphs, Proc. ACM-SIAM Symp. on Discrete Algorithms (1991), 203-211, 
 [20] A. Lempel, S. Even, and I. Cederbaum, An Algo-[38] C. Thomassen, Planar Acyclic Oriented Graphs, 
rithm for Planarity Testing of Graphs, in Theory of Order 5 (1989), 349 361. Graphs, Int. Symposium (Rome, 
1966), Gordon and [39] J. VaJdes, R.E. Tarjan, and E.L. Lawler, The Recog-Breach, New York, 1967, 215 
232. nition of Series Parallel Digraphs, SIAM J. on Com­ [21] S. Moen, Drawing Dynamic Trees, IEEE Software 
puting 11 (1982), 298 313. 7(1990), 21-28. [40] S. K. Wismath, Weighted Visibility Graphs of Bars [22] 
J. O Rourke, Art GaJJery Theorems and Algorithms, and Related Flow Problems, Algorithms and Data Oxford 
University Press, 1987. Structures (Proc. WADS 89) (1989), 325-334. [23] F.P. Preparat a and R. Tamassia, 
Fully Dynamic Point Location in a Monotone Subdivision, SIAM J. i?,..... Computing 18 (1989), 811-830. 
c. t :- L ../. : [24] E. Reingold and J. Tilford, Tidier Drawing of Trees, . : IEEE Trans. on Software 
Engineering SE-7 (1981), u K 223-228. . (1 G .... [25] P. Rosenstiehl and R. E. Tarjan, Rectilinear 
Planar ....+ t u Layouts of Planar Graphs and Bipolar Orientations, (a) .., ; @ \\: Discrete &#38; 
Computational Geometry 1 (1986), 343- *, ...... y .,.?.. 1= 353. (c) s.. [26] W. Schnyder, Embedding 
Planar Graphs on the  4.,.. G Grid, Proc. ACM-SIAM Symp. on Discrete Algo-,... t . ... / rithms (1990), 
138 148. ... . .... -.. . .,. Dynamic Trees, J. Computer Systems Sciences 24 [27] D.D. Sleator and R.E. 
Tarjan, A Data Structure for ..... G (1983), 362-381. G [28] K. Sugiyama, S. Tagawa, and M. Toda, Methods 
for (b) Visual Understanding of Hierarchical Systems, IEEE q ..... Trans. on Systems, Man, and Cybernetics 
SMC-I 1 s ....... (d) (1981), 109-125. ...... [29] K. J. Supowit and E.M. Reingold, The Complexity 
of Drawing Trees Nicely, Acts Informatica 18 (1983), Figure 1: Geometric constructions in the A-algorithm: 
377-392. (a) base case; (b) series composition; (c) parallel com­ [30] R. Tamassia, On Embedding a Graph 
in the Grid position; (d) parallel composition with the right­with the Minimum Number of Bends, SIAM 
J. Com­ pushed transitive edge. puting 16 (1987), 421 444. [31] R. Tamassia, A Dynamic Data Structure 
for Planar Graph Embedding, Proc. 15th ICALP, LNCS 317 (1988), 576-590. [32] R. Tamassia and F.P. Preparata, 
Dynamic Mainte­nance of Planar Digraphs, with Applications, Algo­rithmic 5 (1990), 509 527. [33] R. Tamassia 
and I. G. Tollis, A Unified Approach to Visibility Representations of Planar Graphs, Discrete &#38; Computational 
Geometry 1 (1986), 321-341. [34] R. Tamassia and I.G. Tollis, Planar Grid Embed­ding in Linear Time, 
IEEE Trans. on Circuits and Systems CAS-36 (1989), 1230 1234. [35] R. Tamassia and I.G. Tollis, Tessellation 
Representa­tions of Planar Graphs, Proc. 27th AnnuaJ Allerton Conf. (1989), 48-57. [36] R. Tamassia and 
I.G. Tollis, Representations of ClraPhs on a Cylinder, SIAM J. on Discrete Mathe­matics 4 (1991), 139 
149. [37] R. Tamassia and J.S. Vitter, ParaJlel Transitive Clo­ sure and Point Location in Planar Structures, 
SIAM Figure 2: Finding the face containing a query point p. J. Computing 20 (1991), 708-725. If p is 
in a shaded region then its face is found at a descendant P-node. 
			

 Approximate Distance Oracles for Geometric Graphs Joachim Gudmundsson* Christos Levcopoulos t Giri Narasimhan 
t Michiel Smid f Abstract Given a geometric t-sp~.nner graph G in E d with n points and m edges, with 
edge lengths that lie within a polynomial (in n) factor of each other. Then, after O(m÷nlog n) preprocessing, 
we present an approximation scheme to answer (1 + e)- approximate shortest path queries in 0(1) time. 
The data structure uses O(nlogn) space. Introduction The shortest-path (SP) problem for weighted graphs 
with n vertices and m edges is a fundamen- tal problem for which efficient solutions can now be found 
in any standard algorithms text. The ap- proximation version of this problem has been stud- ied extensively, 
see [1, 11, 14]. In numerous al-gorithms, query versions frequently appear as sub- routines. In such 
a query, we axe given two vertices and have to compute or approximate the shortest path between them. 
The latest in a series of re- sults for undirected weighted graphs is by Thorup and Zwick [23]; their 
algorithm computes (2k - 1)-approximate solutions to the query version of the SP problem in O(k) time, 
using a data structure that takes (expected) time O(kmn l/k) to construct and utilizes O(kn 1+1/k) space. 
It is not an approx- imation scheme in the true sense because the value k needs to be a positive integer. 
Since the query time is essentially bounded by a constant, Thorup and Zwick refer to their queries as 
approximate dis- ~IYe'partment of Computer Science, Utrecht University, P.O. Box 80.089, 3508 TB Utrecht, 
the Netherlands. E-maih joachim@cs.uu.nl. Supported by The Swedish Foundation for International Cooperation 
in Research and Higher Education. tDepartment of Computer Science, Lund University, Box 118, 221 00 Lund, 
Sweden. E-mail: chris~os@cs.lth.se. $ School of Computer Science, Florida International University, Miami, 
FL 33199, USA. E-maih giri@~iu.edu. §School of Computer Science, Caxleton University, 1125 Colonel By 
Drive, Ottawa, Ontario, Canada KIS 5B6. E-maih michiel@scs, carlet on. ca. tancg oracles. We focus on 
the geometric version of this prob- lem. A geometric graph has vertices correspond- ing to points in 
R d and edge weights from a Eu- clidean metric. Again considerable previous work exists on the shortest 
path and related problems. A good survey can be found in [19]. Also see [2, 7, 8, 9]. Note that none 
of the existing results answer shortest path queries in constant time, with subquadratie space and preprocessing 
time. We consider geometric graphs that are t-spanners for some (possibly large) constant t. A graph 
G = (V, E) is said to be a t-spanner for V, if for any two points p and q in V, there exists a path in 
G between p and q of length at most t times the Euclidean distance between p and q. Given a geometric 
t-spanner G --(V~ E) on n ver-tices and rn edges, we consider the problem of find- ing (1 + e)-approximate 
solutions to shortest path length queries. We present an algorithm that pre- processes G in O(nlogn + 
m) time, after which such queries can be answered in O(1) time, for any given real constant e > 0. Also, 
a (1 + e)- approximate shortest path can be reported in time proportional to the number of its edges. 
We re-mark that many "naturally occurring" geometric graphs are t-spauners, for some constant t > 1, 
thus justifying the interest in the restricted inputs considered in this paper. For example, Keil and 
Gutwin [18] have shown that the Delaunay trian- gulation of a set of points in the plane is a t-spanner 
for t --~. We impose yet another restriction on our inputs, i.e., that the interpoint distances be confined 
to a polynomial range. While this too can be argued to be true of most "naturally occurring" geometric 
graphs, we axe working to eliminate this restriction. We believe that the data structure presented can 
be applied to a large number of problems. In this paper we give several examples. For example, consider 
the problem of approximating a shortest obstacle-avoiding path between two vertices in a planar polygonal 
domain with obstacles, having a total of n vertices. In accordance with the spanner constraints imposed 
above, we consider restricted planar polygonal domains, which we will refer to as t-rounded domains. 
A polygonal domain P is said to be t-rounded if for any two vertices p and q, the length of the shortest 
obstacle-avoiding path between p and q is at most t times the Euclidean distance between them. The concept 
of t-roundedness is similar in spirit to that of domains with fat obstacles or with bounded aspect ratio 
obstacles, see [13, 21]. We show how to preprocess a planar t-rounded domain in O(n log n) time, such 
that approximate shortest path length queries can be solved in O(1) time for any two vertices of the 
domain, and in O(log n) time for any two points in the plane. We also consider interesting query versions 
of closest pair problems and show how to answer such queries efficiently. Finally, we significantly improve 
on the time complexity of algorithms to compute the approximate stretch factor of geometric graphs. The 
main data structure used is a series of "cluster graphs" of increasing coarseness each of which helps 
an.qwer queries for different size edges. The idea of cluster graphs to speed up geomet- ric algorithms 
was first introduced by Das and Narasimhan [12] and later used by Gudmundsson et al. [15] to design an 
efficient algorithm to com- pute (1 q- e)-spanners. In this paper, we develop two interesting tools. 
First an O(mlogn)-time algorithm for construct- ing a (1 +e)-spanner of a given geometric t-spanner. 
If the ratio between the longest and shortest edge in the given graph is polynomially bounded then a 
(1 + c)-spanner can be built in time O (m + n log n). Secondly, we design a tool to bucket edge lengths 
without using the floor functions. We believe that these tools (especially the latter) are of indepen- 
dent interest as general devices to speed up geo- metric algorithms. Our model of computation is the 
traditional algebraic computation model with the added power of indirect addressing. We will use the 
following notation. For points p and q in R d, IPq] denotes the Euclidean distance between p and q. If 
G is a geometric graph, then ~G(P,q) denotes the Euclidean length of a shortest path in G between p and 
q. Hence, G is a t-spanner for V if 5G (P, q) ~< tlpql for any two pointsp and q of V. IfP is a path 
in G between p and q having length A with 6C(p,q) <<. A <~ (l+e)JC(p,q), then P is a (1 +c)- approximate 
shortest path for p and q. A subgraph G' of G is a t~-spanner of G, if ~c' (P, q) <<. t~Sc(P, q) for 
any two points p and q of V.  2 A bucketing tool In this section, we develop an algorithmic tool that 
will be used repeatedly later in this paper. THEOREM 2.1. Let V be a set of n points in ~d that are contained 
in the hypercube (O, nk) d, for some-positive integer constant k. We can prepro- cess V in O(nlogn) time 
into a data structure of size O(n), such that for any two points p and q of V, with Ixyl >1 1, we can 
compute BINDEX(p, q) ----- [log [Pql] in 0(1) time. Observe that BINDEX(p, q) is the unique non- negative 
integer i such that the distance IPql is in the interval [2/, 2i+1), and that 0 ~< BINDEX(p, q) ~< [(1/2) 
log d + k log nJ. In a computation model that has the floor and logarithm function as unit-time operations, 
such a query can clearly be an.qwered in O(1) time. In the purely algebraic model, a query can be answered 
in O(loglogn) time. The main result of this section is a data structure in the stronger model that additionally 
has indirect-addressing as a unit-time operation. We start by presenting this data structure for the 
one-dimensional case. In Section 2.2, we show how to use this result to solve the d-dimensional case. 
2.1 The one-dimensional case In this subsec- tion, we assume that V is a set of n real num-bers in the 
interval (0, nk). For any two elements x, y E V with Ix - y[/> 1, we have BINDEX(X, y) = [log Ix -- YlJ, 
which is an integer between zero and Lk log n]. We assume w.l.o.g, that n is a power of two. Let To be 
the perfectly balanced binary search tree whose leaves store from left to right--the intervals [j, j 
+ 1), 0 <~ j < n k. With each node u of To, we store the interval I(u), which is the union of the intervals 
stored at the leaves in the subtree rooted at u. Observe that I(u) has the form [a, b), for some real 
numbers a and b, where b -a is a power of two. We distribute the elements of V over the leaves of To. 
That is, we store each element x of V in the unique leaf whose interval contains x. This tree To has 
n k leaves, and each of them stores a possibly empty subset of V. Let T be the tree obtained from To 
by performing the following compression steps as long as possible: Delete the subtree rooted at any node 
u for which the interval I(u) does not contain any element of V. For any node u having only one child 
v, delete u and make v the child of u's parent. The resulting tree T does not depend on the order in 
which the compression steps are made. Also, T has at most n leaves, and each internal node has exactly 
two children. Hence, T has a total of at most 2n --1 nodes. Since the height of To is O(klogn), which 
is O(Iogn), because k is a constant, the height of T is also O(log n). We show how the compressed tree 
T can be constructed in a top-down manner, without first constructing To. In a generic step, we have 
a subset V ~ of V and an interval [a,b), where b -a is a power of two, such that V t _C [a, b), and we 
want to compute the compressed tree T(V ~) for V ~. If b - a = 1 or V~contains only one element, then 
T(V') consists of only one node u storing the interval I(u) := [a, b) and the elements of V. Ifb-a>12, 
IV' I >12 and V' C [a, (a + b)/2), then T(V ~) is the output of the recursive call for V * and the interval 
[a, (a -t- b)/2). If b-a >t 2, IV' I >~ 2 and W C [(a + b)/2,b), 830 then T(W) is the output of the recursive 
call for V' aad the interval [(a + b)/2, b). Otherwise, W is partitioned into sets V1J := v': x < (a 
+ 5)/2} and := {x V': x ~ (a + b)/2}. In this case, T(V') consists of a node u storing the interval I(u) 
:= [a, b) and whose left (resp. right) subtree is the output of the recursive call for the set V[ and 
the interval [a, (a +b)/2) (reps. the set V~ and the interval  [(a + b)/2, 5)). The complete compressed 
tree T = T(V) is built by running this algorithm on the set V and the interval [0, nk). We can easily 
extend the algorithm such that each node u stores the non-negative integer i such that the interval I(u) 
has length 2 i. The running time to build this tree is O(nklogn) = O (n log n). Let us see how we can 
use this tree to answer queries. Let x and y be two elements of V with I x -- Yl /> 1. Recall that we 
want to compute the integer BINDEX(X, y) --[log [x --YGJ-We may assume w.l.o.g, that x < y. We observe 
that BINDEX(x, y) is the exponent of the length of the largest interval whose length is a power of two 
and that fits in the interval [x, y]. Let u be the lowest common ancestor of the leaves of T that store 
x and y. (Note that x and y axe stored at different leaves.) Let a/> 0, b >/2, and j >t 1 be the integers 
such that I(u) = [a, b) and b-a = 2 j. Observe that x E [a,a-t-2 j-l) andy E [a+2 j-l,b). If at least 
one ofx and y is '~r" away from the mid-point c :--a + 2J-1 then j differs from BINDEX(X,y) by a "small" 
additive constant. It may happen, however, that both x and y are "close" to c. Let us assume that Ic 
- xl < 19 - el. Then lY - cl < lY - =l < 21y -et. Hence, if fl is the exponent of the largest interval 
whose length is a power of two and that fits in the interval [c, y], then j' differs from BINDZX(x, y) 
by a "small" additive constmat. This suggests that we find the lowest common ancestor v of the leaves 
of T whose intervals contain c and y. This does not, in general, give us a good approximation to jl, 
because c and y can be "close" to each other in the interval I(v). Assume, however, that c is an element 
of V. Let w be the right child of u. Hence, I(w) = [c, b), c is stored in the leftmost leaf of the subtree 
rooted at w, and y is stored in the subtree of w. Consider again the lowest common ancestor v of the 
leaves storing c and y. The nodes on the path starting in w and ending in v store the intervals [c, b), 
[c, c + 2J-2), [c, c + 2J-3),..., [c, c + 2J'+l), where j' is as above. (Note that this does not necessarily 
hold if c does not belong to the set V.) This suggests the following data structure for solving our query 
problem. Let V r be the union of V and the set of all mid-points of the intervals I(u) over all internal 
nodes u of T. Observe that W contains at most 2n -1 elements. We build a new compressed tree T ~ using 
the algorithm given above, but for the set V t. Given two elements x and y in V with Ix-y[ 1> 1 and x 
< y, we first test if y-x = 1 or 1 < y-x < 2. In the first case, we have BINDEX(X, y) = 0, whereas BINDEX(X, 
y) = 1 in the second case. Assume that y-x /> 2. We first compute the lowest common ancestor u of the 
leaves of 2°' that store x and y. Let c be the mid- point of the interval I(u). If Ic - x[ ~< lY -cl, 
then we compute the lowest common ancestor v of the leaves storing c and y. Let j be the positive integer 
such that I(v) has length 2J. (Since y -c i> 1, the elements y and c are stored at different leaves ofT.) 
Then 25-1 ~< [y-c[ < 2 j and, hence, 2J-1 < lY - xl ~< 2 i+1. This implies that j -1 BINDEX(x, y) ~< 
j + 1. Since we know the values of j (it is stored with node v) and 2 i (it is the length of the interval 
I(v)), we can now easily compute BINDEX(x,y) in 0(1) time. We cannot use this data structure if [c - 
x[ > lY-cl- In order to handle this case, we also build a compressed tree using intervals of the form 
(a, b] instead of [a, b). To summarize, we have shown that after an O(nlogn)-time preprocessing, we can 
reduce the problem of computing BINDEX(x,y) to answer- ing two lowest common ancestor queries in a tree 
having size O(n), plus an O(1)-time computation. Harel and Tarjan [17] have shown that any tree can be 
preprocessed in linear time such that low- est common ancestor queries can be answered in O(1) time. 
(See also Schieber and Vishkin [22], Gnsfield [16] and Bender and Farach-Colton [5].) Hence, we have 
proved Theorem 2.1 for d = 1. 2.2 The d-dimensional ease Now assume that V is a d-dimensional set of 
points. Let p ----(Pl,P2,---,Pd) and q = (ql,q2,---,qd) be any two points of V with [pq[ ~> 1, let j 
be such that IPj-qjl is maximum, and let i = [log [pj -qjl~. Since IPj- qjl <~ IPql <~ v/-dlp~-qjl, 
we have 1 i ~< BINDEX(p, q) ~< ~ log d q- i. This suggests the following solution. For each g, 1 ~< 
£ ~< d, we build the data structure presented above for the set of e-th coordinates of all points of 
V. Given two distinct points p and q of V, we compute the index j such that tpj-qjl is maximum. Then 
we use the suggested algorithm to compute the integer i = [loglpj -qjH- Note that this algorithm also 
gives us the value 2 i. Given i and 2 i, we then compute BIND~X(p,q) in O(loglogd) time, and Theorem 
2.1 follows. It should be clear that the theorem also holds if we allow queries with elements x, y E 
V such that Ix - Y[ ~> 6, for some fixed constant 6 > 0. 3 Pruning dense spanners Let G = (V,E) be a 
geometric graph that is a t-spanner for V, for some (possibly large) real constant t > 1. We denote the 
number of vertices and edges of G by n and m, respectively. In this section, we will show how to compute, 
for any given positive real constant e, a (1 + e)-spanner of G having only O(n) edges. Our construction 
uses the fair-split tree and the well-separated pair decomposition (WSPD) of Callahan and Kosaxaju; see 
[6]. LEMMA 3.1. Let A and B be two finite sets of points that are well-separated w.r.t, a separation 
constant s, let x and p be points oS A, and let y and q bepoints orB. Then (i) lxYl (x+2/s).lxql, (ii) 
Izyl < (1 + 41s). Ipql, and (iii} Ipxl (2is). Ipql. 3.1 A general algorithm Recall that G = (V, E) is 
a ~-spanner of V with n vertices and rn edges. Our goal is to compute a sparse (1 + ~)- spanner G t of 
G. We start by computing a WSPD {Ai,Bi}, 1 ~< i <~ £, for V, with separation constant s =-4(1 + (1 +c)t)/c 
and e = O(n). Let G' = (V, E') be the graph that contains for each 1 ~< i ~< ~, exactly one (arbitrary) 
edge (xi, yi) of E with xi E Ai and Yi E Bi, provided such an edge exists (for this index i). For each 
edge (p, q) of E, there is a path in G r between p and q having length at most (1 + e)[Pql. (This can 
be proved by induction on the length of the edges of E.) Hence, the graph G ~ is a (1 + E)- spanner of 
G. We now show how the graph G ~ can be con-structed efficiently. To compute the WSPD, we use the algorithm 
of Callahan and Kosaxaju [6]. Given this WSPD, it is clearly sufficient to compute for each edge (p, 
q) of E, the index i such that p E Ai and q E Bi. Arya et al. [3] have shown that, after an O(n)-time 
preprocessing of the split tree that gave rise to the WSPD, this index can be computed in O(log n) time. 
Hence, the entire graph G p can be computed in O(nlogn + mlogn) = O(mlogn) time. THEOREM 3.1. Given a 
geometric graph G with n vertices and m edges, which ks a t-spanner for V, for some real constant t > 
1, we can compute, in O(mlogn) time, a (1 + c)-spanner of G having O(n) edges. 3.2 A special case We 
assume that the distance between any two distinct points of V is in the inter- val [1,nk), where k is 
a positive integer constant. Consider the t-spanner G = (IT, E). We will show how a sparse (1 +e)-spanaer 
of G can be computed in O(n log n + m) time. The length-grouping step: Let ~0 := 2(i+t04~))" Consider 
the covering of [1,n ~) by the intervals 1i := [(1 + ~0)~,(1 + eo)i+l), 0 ~< i = O(logn). For each vertex 
p E V, we partition p's adjacency list using these intervals. That is, the edge set E(p) is partitioned 
into subsets Ei(p), 0 ~< i =- O(logn), where Ei(p) := {(p,q) e E(p) - IPq] E Ii}. By Theorem 2.1, this 
length-grouping step can be performed in O(n log n + m} time. The angle-grouping step: Let 0 < 0 < zr/4, 
such that E cosO- sinÜ ~ 1 2t[1 -t- 6)" (3.1) Consider a collection C1, O2,..., Ca of simplicial cones 
of angular diameter 0, all having their apex at the origin, and that cover IRa; see Yao [24]. In this 
second step, we further partition each subset Ei(p), p e V, 0 <~ i --O(logn), into h subsets Eij(p), 
1 ~< j ~< h, where Eij(p) :-- {(p,q) E Ei(p) : q -p E Cj}. It is clear that this step can be carried 
out in O(n log n + m) time. At the end of this second step, we have par- titioned each set E(p) into 
O(log n) subsets. If q and r are any two points from the same subset, then IpqI < (1 + e0)lpr], Ipr] 
< (1 + eo)ipql, and the angle between the line segments pq and pr is at most 0. The preliminary pruning 
step: Let G ~ = (V, E ~) be the subgraph of G that is obtained by picking exactly one (arbitrary) edge 
from each non- empty set Eij~). It is clear that G' has O(nlogn) edges and that it can be computed in 
O(nlogn) time. To prove that G ~ is a (1 + e)-spanner of G, we use the following geometric lemma, which 
is similar to Lemma 2 in Arya and Staid [4]. Recall that 0 < O < ~r/4. LEMMA 3.2. Let p, q and r be three 
points in ~a such that p ~ q, p ~ r, and the angle between pq and pr is at most O. Let r ~ be the orthogonal 
projection of r onto the line through p and q, and assume that Ipr'] <. ]Pql. Then Irql ~ Ipql-(cos0- 
 sin0)lprl. LEMMA 3.3. The graph G' ks a (1 + e)-spanner of G. Proof. It is sufficient to prove that 
gG' (P, q) ~ (1 + e)ipq I for each edge (p, q) of the graph G = (V, E). The complete proof, which is 
by induction on the lengths of the edges in E, will be given in the full paper. Here, we present one 
case of the proof. Assume that (p, q) is not a shortest edge of E. Furthermore, a~sume that 6G,(z,y) 
<~ (1 + ~)lxyl for each edge (x, y) of E that is shorter than (p, q). If (p, q) is an edge of E', then 
it is clear that 5G'(P,q) ~ (1 +e)]pq[. So assume that (p,q) is not an edge ofE t. Let r be a point of 
V such that (p, r) is an edge of E I that is in the same subset of the partition of p's adjacency list 
as (p, q). Recall that ]Pql < (1 +~0)lpr], ]pr I < (1 +so)tpq], and the angle between pq and pr is at 
most 0. Let r' be the orthogonal projection of r onto the line through p and q. Similarly, let q~ be 
the orthogonal projection of q onto the line through p and r. Let us assume that lpr'l ~< lpql. Applying 
the fact that G is a t-spanner for V, inequality (3.1) and Lemma 3.2, we obtain ga(r,q) <~ t]rq I <~ 
tlpql --t(cos0 -- sin0)lpr I < tlpq I _ t(cos0 -- sin0)[pq[ 1+~0 ' <~ tlpql- l+c0 IPql, where the last 
inequality follows from our choice of E0. Hence, each edge on the shortest path in G between r and q 
has length less than IPq[. Therefore, by the induction hypothesis and the fact that G is a t-spa.nner 
for V, we have JG,(r, q) <~ (1 q-e)JG(r,q) <. t(1 -t-e)lrql. Applying Lemma 3.2 and inequality (3.1), 
we get 5 G, (r, q) ~< t(1 + e)lpq[ - t(1 + e)(cos 0 - sinO)lpr I ~< t(l+e)~q[-t(l+e) 1 2t(l+e) t~1. 
Hence, ~G'(P, q) < Iprl + gG,(r, q) <<. t(1 + e)lpql - = t(1 + e)[pq[ - (t(1 + e) - e/2 -1)lprl t(1 
+ e) -e/2 -l~pqlt, < t(1 + e) lpql 1 +eo ~< (1 + e)lpql,  where the last inequality follows from our 
choice for co. The final pruning step: The idea of this final step is to apply the general pruning algorithm 
of Section 3.1 to the graph G' = (V,E'). Since G' is a ((1 + e)t)-spanner for V, we have to take s = 
4(1 + (1 + e)2t)/e for the separation constant in the WSPD for V. The results of Section 3.1 imply that 
this yields a graph G" having O(n) edges and that is a (l+e)-spanner of G'. Hence, G" is a sparse (1 
+ e)2-spanner of our original t-spanner G. Since G' has O(n log n) edges, however, the running time is 
O(n log 2 n). We show below that we can use the special structure of the graph G' to improve the running 
time. We start by computing the split tree T and the corresponding WSPD {Af, Bf}, 1 <~ f <~ e, for V, 
with separation constant s = 4(1 + (1 + E)2t)/z and l = O(n). The graph G" that we want to compute contains 
for each f, 1 ~< f ~< ~, exactly one (arbitrary) edge (p, q) of E' with p EAf and q E Bf, provided such 
an edge exists. By Theorem 3.1, G" is a (1 + e)-spanner of G'. It remains to show how G" can be computed 
efficiently. Let f be an index with 1 ~< f ~ ~, and let p be a point of A I. We first show how to decide 
if there is an edge (p, q) in E e with q E BI. We fix an arbitrary point b of BI. By Lemma 3.1, we have 
[pbl/(1 + 2/s) <~ IPq[ <~ (1 + 2/s)[pb[, for any q E B[. Hence, if i is the index such that Ipbl e Ii 
= [(1 + e0) i, (1 + e0)i+l), then there are a eonstant number of indices i' for which there is a point 
q E Bf with Ipql e I¢. Let i ~ be such an index, and let 1 ~< j ~< h. Each edge (p, q) of E' with Ipql 
~ Ii, and q -p e C 1 is contained in the subset Ei'i(P). Since Ei,j(p) contains at most one edge of E 
~, it follows that the number of edges (p, q) in E t for which q may be in B/ that we have to consider 
is bounded by a constant. Moreover, if we know the value of the index i, then these candidate points 
q can be found in 0(1) time. Consider such a candidate point q. Let u be the node of T that represents 
the set Bf, and let v bethe leaf ofT that stores q. Then q E Bf if and only if v is in the subtree of 
u. Hence, we can decide in 0(1) time if q E B I. This concludes the description of the four steps that 
compute a sparse (1 + e)2-spanner G" of the input t-spanner G. If we replace ~ by e/3 in the entire construction, 
then we obtain the following result. THEOREM 3.2. Let V be a set o.f n points in R d such that all interpoint 
distances are in the interval [1,nk), where k is a positive integer constant. Given a geometric graph 
G with vertex set V and having rn edges, which is a t-spanner for V, for some constant t, we can compute 
a (1 + e)-spanner of G having O(n) edges, in O(nlogn + m) time. Approximate shortest path queries Let 
G = (V, E) be a geometric graph that is a t- spanner for V, for some constant t > 1. We assume that the 
number of edges of G is O(n). Let D be the length of the longest edge in G, let ~ be a positive real 
constant, and let k be a positive integer constant. In this section, we will show how to preprocess G 
into a data structure such that for any two points p and q in V with IPql > D/nk, we can compute a (1 
+ v)-approximation to the shortest-path distance in G between p and q. This data structure will be based 
on the cluster-based implementation of the greedy spanner algorithm of Das and Narasimhan [12] and Gudmundsson 
et al. [15]. Therefore, we start by describing the main ideas of this algorithm. We may assume w.l.o.g. 
that D = n k. The greedy algorithm computes a (1 + e)-spanner G t of the t-spanner G. The basic version 
of this algorithm works as follows. The graph G t is initialized to (V, @), and the edges of E are sorted 
according to their lengths. Then, the algorithm examines the edges of E one by one, in this sorted order. 
When the algorithm examines the edge (p, q), it decides if there is a path between p and q in the current 
graph G ~ whose length is at most (1 + 6)[pq[; the edge (p, q) is added to G' if and only if such a path 
does not exist. The final graph G r is a (1 + z)-spa.nner of G- To obtain a fast implementation, we choose 
real constants p and X with 1 ~< ~ < p, and partition E into Eo := {(P,q) E E : IPql <~ ,X} and E~ := 
{(p, q) e E : ~-xA < Ipql <<. p%]', 1 ~< i = O(log n). 834 After the graph G ¢ has been initialiued 
to (V, E0), the remaining subsets Ei, i >/ 1, are pro- ceased one after another. At the beginning of 
the phase in which Ei is processed, the algorithm con- structs a cluster graph H of the current graph 
G ~, which is dynamically maintained during this phase. Informally, this cluster graph H approximates 
the current graph G r, in the sense that for any two points p and q for which [pq] is approximately equal 
to pi~, ~H(P,q) approximates ~G'(P,q), which in turn approximates 6G (p, q). Moreover, for two such points 
p and q, the value of 6H(P, q) can be com- puted in O(1) time. When the algorithm processes edge (p, 
q) of Ei, it uses the current cluster graph H in its decision whether or not to add thi.q edge to the 
current graph G ~. That is, (p, q) is added to G ~ if and only if ~H~P,q) > (1 A- e)]pq I. If this edge 
is added, then H is updated so that it is a valid clus- ter graph for the new graph G'. The final graph 
G ~ is a (1 + e)-spanner of G, and the overall algorithm runs in O(nlogn + ~-:.~>~1 [Eil) : O(nlogn) 
time. 4.1 The cluster graph Let L > 1 be a real number, and consider the graph O r at the moment when 
the greedy algorithm has just processed all edges of E whose length is at most L. Das and Narasimhan 
prove that ~G,(X,y) ~ (1-4-e)]xYl, for all edges (x,y) e E with Ixyl <~ L. Let ibethe integer such that 
p~-I A < L ~</~A. Das and Narasimhan, and Gudmundsson et aL choose an arbitrary real constant 1 t~ with 
0 < ~ < 1/4, and use it to define the cluster graph H for G ~. This cluster graph has the points of V 
as its vertices, and it has O(n) edges. Moreover, 1. For all p, q e V, 5G' (P, q) <~ 5H (P, q)- 2. For 
allp, q E V with ~G'~P,q) > (1-2a)P i-lj~,  < (1+ i--d (P'q) 3. For all p, q E V and any real number 
£ with 0 < £ ~< (l+e)pi)~, it takes O(1) time to decide if gH(P, q) ~< £. IThey use the notation 5 instead 
of ~. 4.2 Using the cluster graph for approxi-mate shortest path queries Let p and q be two points of 
V such that ]Pqt > A, and let i be the posi- tive integer such that/~i-1~ < IPql <~ t fiX. Consider the 
graph G r and the corresponding cluster graph H at the moment when the greedy algorithm has just processed 
all edges of Ei. Assume that we have chosen the constant tt such that/~ > t. Furthermore, assume that 
IPql <~ #iA/t. Then the following holds. SG(P, q) ~< gG' (P, q). This holds because G' is a subgraph 
of G.  6C' (P, q) <~ gH (P, q). This is one of the general properties of the cluster graph, see Section 
4.1.  ~H(P,q) <. (1 +~)((1+ lSa)l(1--2a))gG,(p,q). Since 5a'(P,q) >i IPql > p~-~ > (I-2cr)~ti-lA, this 
follows from the general prop- erties of the cluster graph, see Section 4.1. Jc'(P,q) ~ (1 + e)~a(p,q). 
To prove this, first observe that JG(P,q) <~ tlpq[ <~ fti)t. Hence, each edge on the shortest path in 
G between p and q has length at most /~i$. The claim then follows from the general properties of the 
cluster graph, see Section 4.1. Combining these inequalities, it follows that i+ 18at , , dG~v,q) <~ 
JH(P,q) <~ (1 +e) 2 1"--2-~aOGtp, q), provided that ~i-lA < IPql <<. ~%/t. Hence, by choosing the constant 
a such that 0 < a < 1/4 and ((1+ 18~)/(1-2ct)) <~ l+e, the value ~H(P,q) (which can be computed in O(1) 
time) is a (1 +e) a- approximation to the length of the shortest path in G between p and q. Hence, we 
have shown the following. For any constant A with 1 ~< A < #, if p and q are two points with IPql > A, 
and if i is the positive integer such that pi--1)t < IPq[ < ~tiA, then we can compute a (1 + e)-approximation 
to go(P, q) in O(1) time, provided that (i) we know the index i and (ii) IPqf <<. ltiX/t. We have seen 
in Section 2 how the index i can be computed. Condition (ii) says that the distance IPql must be in the 
"initial" part of the interval (#i-lA, piA]. This condition can be met if we apply this construction 
using a constant number of values for A. The details will be given in the following subsection. 4.3 
The data structure We choose constants tt and a such that p > t, 0 < a < 1/4 and ((1 + 18c~)/(1 -2a)) 
~< 1 + e. For any j, 0 ~< j ~< [log~/log(p/t)J, let Aj := (~/t)L For each such j, we run the greedy spanner 
algorithm on the t-spanner G, using the subsets E~ := { (p, q) E E: [pq[ <~ Aj} and E~ := {(p,q) E E: 
pi-lAj < ]pq} <~ #iAj }, 1 ~< i ~< I + [k logt~ n. logt~ AjJ. Our data structure consists of the collection 
of cluster graphs HJi, 0 <~ j <~ [logtz/log(#/t)j, 1 ~< i <~ 1 + [klog~n-log~A/J, where //~ is the cluster 
graph at the moment when the greedy algorithm (using Aj) has just processed all edges of the subset E{. 
Let us see how this data structure can be used to answer approximate shortest path queries. Let p and 
q be two points of V with Ipql > 1. Let i be the positive integer such that tt i-1 < [Pql <~ #i, and 
let j be the positive integer such that Aj < Ipql]p i-1 <~ (#/t)Aj. Then pi-lAj < IPq] <~ lti)'j/t and 
the results of Section 4.2 imply that A := 6H~ (p, q) can be computed in O(1) time and satisfies ga(P, 
q) A ~ (1 + ¢)2Ja(p,q). By replacing e by e/3 in the entire construction, we get a (1 + e)-appro~hmation 
to ciG(p, q). THEOREM 4.1. Let V be a set of n points in R d, and let G = (If, E) be a t-spanner for 
V, for some real constant t > 1, having O(n) edges. Let D be the length of the longest edge in G, let 
e be a positive real constant, and let k be a positive integer constant. We can preprocess G in O(n log 
n) time, such that ]or any two points p and q in V with IPql > D/nk, we can compute, in O(1) time, a 
(1 + e)-approzimation to the shortest-path distance in G between p and q. In the full paper we show that, 
by some general properties of cluster graphs, a (1 + e)-approximate shortest path can be computed in 
time propor- tional to the number of its edges.   5 Further applications The above data structure has 
several nice proper- ties, and we believe that it can be applied to a number of basic problems. In this 
section we con- sider some examples where the utilization of the data structure immediately improves 
the time com- plexity, and in some cases also the approximation factor, of existing results. 5.1 Shortest 
paths among domains Consider a polygonal domain consisting of a collection of polygonal obstacles in 
the plane, and let V be the set of vertices of these obstacles. The visibility graph of ~- is the graph 
G with vertex set V, and in which any two vertices p and q are connected by an edge if and only if the 
line segment joining p and q does not intersect the interior of any obstacle. We denote by 5G(P, q), 
the Euclidean length of a shortest path between p and q in the graph G. For any real number t > 1, we 
say that the collection is t-rounded if JV(P,q) is at most t times the Euclidean distance between p and 
q, for any two points p and q in V. In other words, the visibility graph is a t-spanner for the complete 
geometric graph on the point set V (where the obstacles are ignored). Arikati et al. [2] have shown how 
to compute, in O(n log n) time, a (1 + e)-spanner G' of G, for any given constant e > 0. Let p and q 
be two points of S, and assume that ~ is a constant. Since G ~ is a (1 + c)~-spanner of V, our results 
above imply that we can compute, in O(1) time, a (l+e)- approximation of the shortest path P in G t between 
p and q. The length of this path P is at most (1 + e) 2 times the length of a shortest obstacle-avoiding 
path between p and q. Clarkson [10] and Chen [7] have shown that, for any two points p and q in the plane, 
the problem of computing a (1 + e)-approximation of the shortest obstacle-avoiding path between p and 
q can be reduced to the computation of a constant number of shortest path queries in the visibility graph. 
This reduction takes O(log n) time. Hence, a (1 + e)a-approximation of the shortest obstacle- avoiding 
path can be computed in O(log n) time. 5.2 Closest pair queries Given a geometric graph G = (V, E) on 
n points and m edges, such that G is a t-spanner for V, for some constant t > 1, it is often of interest 
to answer various closest pair queries where distances are measured according to distances in G. We may 
assume that m = O(n). For any subset S of V, we define 5GCS) := min{~G (p, q) : p,q e S,p # q}. In a 
query, we get a set S C_ V, and want to compute two points x and y in V that are a (1 + e)-approximate 
closest pair in S. Consider a WSPD {As, Bi}, 1 ~ i ~ t, where g = O(n), for the set S, with separation 
constant s > 2L For each i for which both Ai and Bi are singleton sets, let &#38;i be a (1 + e)-approximation 
to ~a(ai, bi), where ai and bi are the only points of Ai and Bi, respectively. Let i be an index for 
which A i is minimum. Then the points x := ai and y := bd form a (1 + e)-approximate closest pair in 
S. (The proof follows from Lemma 3.1.) Hence, we have reduced the problem of computing a (1+e)-approximate 
closest pair in 8 to computing a WSPD for S and answering O(ISI) approximate shortest path queries in 
G. Next, we consider the bichromatic case. For any two disjoint subsets X and Y of V, we define 5a(X,Y) 
:= min{5~(p,q) : p e X,q fi Y}. In a query, we get disjoint sets X and Y and want to compute a (1 + e)-approximate 
bichromatic closest pair. Let {Ai,Bi}, 1 ~ i ~ ?., be a WSPD for the set X U Y, where l = O(n), with 
separation constant s, where s > 2t and s >~ 4t/e. For each i for which Ai contains one or more points 
of X but no points of Y, and Bi contains one or more points of Y but no points of X, let ai be an arbitrary 
point of Ai N X, let bi be an arbitrary point of Bin Y, and let Ai be a (1 + e)-approximation to ciG(ai, 
bi). Let i be an index for which/xi is minimum. Then the points x := ai and y := bi form a (1 + e)-approximate 
bichromatic closest pair in S. Hence, we have reduced the problem of computing a (l+e)- approximate bichromatic 
closest pair to computing a WSPD for X U Y and answering O(IX I + IYl) approximate shortest path queries 
in G. 5.3 Computing stretch factors of a geomet- ric graph Given a geometric graph G = (V, E) on n points 
and m edges, it was shown in [20] that the problem of computing a (1 + E)-approximation to the stretch 
factor t of G, can be reduced to the problem of computing O(n) approximate shortest path queries, after 
computing a well-separated de- composition of V. Assume that the stretch factor t is bounded from above 
by a known constant. Using our result, we can answer the approximate shortest path queries in O(n) time 
after O(m +nlogn) preprocessing, giving a total computation time of O{m + n log n). 6 Conclusions We 
have presented the first data structure which supports (1 + e)-approximate shortest path queries in constant 
time for geometric t-spanners, hence functions as an approximate distance oracle. In the process we develop 
several tools that we believe are useful for other geometric problems. References [1] D. Aingworth, C. 
Chekuri, P. Indyk, and R. Mot- wani. Fast estimation of diameter and short-est paths (without matrix 
multiplication). SIAM Journal on Computing, 28:1167-1181, 1999. [2] S. Arikati, D. Z. Chert, L. P. Chew, 
G. Das, M. Smid, and C. D. Zaroliagis. Planar spanners and approximate shortest path queries among obstacles 
in the plane. In $th ESA, LNCS, Vol. 1136, pp. 514-528, 1996. [3] S. Arya, D. M. Mount, and M. Staid. 
Randomized and deterministic algorithms for geometric span- ners of small diameter. In 35th FOCS, 703-712, 
1994. [4] S. Arya and M. Smid. Efficient construction of a bounded-degree spanner with low weight. Algorithmica, 
17:33-54, 1997. [5] M. A. Bender and M. Farach-Colton. The LCA problem revisited. In 4th LATIN, LNCS, 
Vol. 1776, pp. 88-94, 2000. [6] P. B. Callahan and S. R. Kosaraju. A decompo- sition of multidimensional 
point sets with applica- tions to k-nearest-neighbors and n-body potential fields. Journal o] the ACM, 
42:67-90, 1995. [7] D. Z. Chen. On the all-pairs Euclidean short path problem. In 6th SODA, pp. 292-301, 
1995. [8] D. Z. Chen, K. S. Klenk, and H.-Y. T. Tu. Short- est path queries among weighted obstacles 
in the rectilinear plane. SIAM Journal on Computing, 29:1223-1246, 2000. [9] Y.-J. Chiang and J. S. B. 
Mitchell. Two-point euclidean shortest path queries in the plane. In IOth SODA, 1999. [10] K. L. Claxkson. 
Approximation algorithms for shortest path motion planning. In lgth STOC, pp. 56-65, 1987. [11] E. Cohen. 
Fast algorithms for constructing t- spanners and paths with stretch t. SIAM Journal on Computing, 28:210-236, 
1998. [12] G. Das and G. Narasimhan. A fast algorithm for constructing sparse Euclidean spanners. IJCGA, 
7:297-315, 1997. [13] M. de Berg, M. J. Katz, A. F. van der Stappen, and J. Vleugels. Realistic input 
models for geo- metric algorithms. In 13th SoCG, 1997. [14] D. Dor, S. Halperin, and U. Zwick. All-pairs 
al- most shortest paths. SIAM Journal on Comput- ing, 29:1740-1759, 2000. {15] J. Gudmundsson, C. Levcopoulos, 
and G. Nazasimhan. Improved greedy algorithms for constructing sparse geometric spanners. In 7th SWAT, 
LNCS, Vol. 1851, pp. 314-327, 2000. [16] D. Gusfield. Algorithms on Strings, Trees and Se- quences. 
Cambridge University Press, Cambridge, UK, 1997. [17] D. Hazel and R. E. Taxjan. Fast algorithms for 
finding nearest common ancestors. SIAM Journal on Computing, 13:338-355, 1984. [18] J. M. Keil and C. 
A. Gutwin. Classes of graphs which approximate the complete Euclidean graph. Discrete Computational Geometry, 
7:13-28, 1992. [19] J. S. B. Mitchell. Shortest paths and networks. In Handbook of Discrete and Computational 
Geome- try, pp. 445-466. CRC Press LLC, 1997. [20] G. Narasimhan and M. Smid. Approximating the stretch 
factor of Euclidean graphs. SIAM Journal on Computing, 30:978-989, 2000. [21] M.H. Overmars and A. F. 
van der Stappen. Range searching and point location among fat objects. Journal of Algorithms, 21:629-656, 
1996. [22] B. Schieber and U. Vishkin. On finding lowest common ancestors: simplifications and paralldisa- 
tions. SIAM Journal on Computing, 17:327-334, 1988. [23] M. Thorup and U. Zwick. Approximate distance 
oracles. In 33rd STOC, 2001. [24] A. C. Yao. On constructing minimum spanning trees in k-dimensional 
spaces and related prob- lems. SIAM Journal on Computing, I1, 1982. 
			

 An Alternative to Constraint Logic Programming for Managing Domain Arithmetics in Prolog Expert Systems 
 David Roach Hal Berghel Department of Computer Science University of Arkansas Abstract We present 
a method for including procedural arithmetic knowledge in a declarative rid-base. The declarative and 
procedural components am integrated in such a way that the procedural component can be represented naturally 
in the rule­base but stilI be an integral part of the proof tree generated by the inference engine. A 
way of organizing explanations based on the integrated proof tree is discussed. Prolog is used to illustrate 
the implementation of the integration strategy. Introduction There is considerable interest in ap lying 
ex rt system technology to problem domains in whlc Fl some or the domain information is procedural in 
character [5][6][~. Currently, one of the more promising and formally well-founded methods for handling 
arithmetics is constraint logic programming (CLP) [3][4][1 1]. CLP languages supplement the traditional 
unification mechanism with a more general constraint satisfier capable of solving systems of equations 
which may contain any number of non-ground terms. Expert systems implemented in CLP languages are described 
in [9][12]. However, in the absence of widely available implementations of CLP languages, it may be useful 
to determine to what extent arithmetics can be satisfactorily handled by traditional expert systems languages 
such as Prolog. We begin with the specification of a typical if. then rule and then discuss the modifications 
necessary to integrstc arithmetic knowledge. Let the vocabulary of a relational expression be Then a 
relational expression is an expression of the form VjOV -,or Vj O Ii where i~ ~ 1,vi,vj eV, ocO,and ~isavalue. 
By letting the vocabulary of a logical expression be 1. the vocabulary of a relational ex reasion, 2. 
the set of logical operators, L= rand,or}, and 3. the punctuation symbols ( and ) ,  a logical expression 
can be defmcd inductively as follows: 1. A relational expression is a logical expression. 2. If A and 
B are logical expressions, then so are (A and B) and (A or B). (We allow optional parentheses. If missing, 
and binds more strongly than or .)  Permission to copy without fee all or part of this material ia granted 
provided that the copies are not made or distributed for direet commercial advantage, the ACM copyright 
notice and the title of the publication and its date appear, and notice is given that copying is by permission 
of the Association for Computing Machinery. To copy otherwiee, or to republish, requires a fee and/or 
specific permission. Q 1992 ACM 0.89791 .502-x/92 ~002/0328... $ 1.50 If we Id the vocabulary of an assignment 
statement be a finite set of variabla togetherwith the assignment operator, = , then an assignment statement 
is an expretmon of the form vi= ~or i =$! for vi,v) and p as above. If. then rules are defmod as follows: 
If@ is a logical expression and ~ is an assignment statement, then if 1$then ~ is an if..then rule. The 
problem In a problem domain where some of the constituent variables obtain their valuca by computing 
real-valued functions, the simple rule schema we have described is inadequate. For instance, the folIowing 
situations can occur in the encoding of problem domain knowledge. 1) An if. .thcn mle may call for a 
calculation in its consquent. Although not aUowed in the simple model, the most natural representation 
for such a rule would be to make the expression to be evaluated explicit in the rule, as in the following 
sample rule (Uppercase lelters are variables.) if A<B then c = (D* E)/4. 2) It may also happen that a 
value ean only be obtained for one or more of the variables in a rule s antecedent by means of some calculation. 
For instance, A in the above rule may obtain its value by means of some formula, such as A = (F+ G)*8. 
When arithmedc knowledge is an integral part of the problem domain knowledge, it should be explicitly 
represented in the corresponding rule-base. However, in order for it to be represented in a declarative 
ruI*base, the standard rule schema must be altered.  In the development of a new schema, we seek a 
natural representationof the arithmetic knowledge. At the same time, it should be Possible to integrate 
it into the proof tree so that a suitable explanation of the obtainment of values based on that knowledge 
is possible. If the arithmetic knowledge u represented in its most readable form (ss ordinary infix expressions), 
special provisiom must be made in the rule interpreter (inference en ine) for the evaluation of these 
expressions. Also, modl ?wations are neceaaary to incorporate them into the proof tree so that they become 
an integral part of the system s explanation of its deciwons. The goals identified by Gallsnti et al. 
[5J are appropriate: effective and natural representation of pieces of procedural knowledge...; use 
of production rules for representing declarative knowledge; integration of the two components into a 
unitary inference meehanism (p. 346). A Solution In order to have a natural representation of arithmetic 
knowledge, wc modi@ the existing if. .thcn rule schema and introduce a ncw mle type. Wc refer to instances 
of the new rule type as assignntenl rufes. Syntactically, assignment rules are very much like the assignment 
statements found in imperative programming languages. They are defined as follows: Let the vocabulary 
of an arithmetic expression be 1. a finite set of real-valued variables, 2. the arithmetic operators 
* , / , + , - , and 3. the punctuation symbols ( and ) .  We define arithmetic expressions inductively 
as follows: 1. Real-valued variables and real numbers are arithmetic expressions. 2. If A and B are 
arithmetic exprmsions, then so arc (A * B), (A / B), (A + B), and (A -B). (Parentheses arc optional. 
If missing, the usual default prcmxicnce of operators is assumed.)  The vocabulary of an assignment 
rule is compcd of 1. the vocabulary of arithmetic expressions, 2. the assignment operator = .  Thus, 
if 1$ is a real-valued variable and # is an arithmetic expression, then @ = # is an assignment rule. 
We also want to include arithmetic expressions in the conse+ents of if. then rules. In fact, the consequent 
of if. .thcn rules should be syntactically identical to assignment rules. (Although in principle there 
is no need to prevent arithmetic ex ressions in the antceedertts of if. then rules, in practice the in 
erence fengine is simpler if they are disallowed. A separate assignment rule can be constructed whose 
left operand matches an antecedent variable whose value is to be calculated.) We assume the same definition 
for antecedent expressions in this new if. ,then rule as was detined for tic simpler type. By letting 
the vocabulary of an if. ,then rule be 1. the vocabularies of logical expressions and assignment rules 
plus 2. the conditional operator if then ,  we can define an if. then mle as follows: If@ is a logical 
expression and ~ is an assignment rule, then if ~ then # is an if..then mlc. Defining the rules in thii 
manner takes care of the representation problem for the arithmtic knowledge. The desired integration 
is achieved by having the inference engine treatassignment rules in two different ways during the course 
of a derivation. First, for purposes of proof tree construction, assignment rules arc transparently reformulated 
as if. .thcn rules, i.e., they are given a declarative interpretation. The left operand of the assignment 
rule is transformed into a consquent of an if. .thcn rule, and the right opands are transformed into 
antecedent conditions of that if. then rule. Each of these right operands (conditions) is treated as 
a relational expression that evaluates to true. For instance, the assignment rule A = (F+ G)*8 has the 
declarative interpretation in the inference engine that is captured in the following if. .thcn mle (lhdikc 
its occurrence in the consqucnt, the = sign in the antecedent conditions tlmctions as a relational opedor.) 
if F = al and G=a2and 8=8 then A = eval((al +a2)*8). As each of these reformulated rules is incorporated 
into the proof tree values arc obtained for the variablea by the ap lication of additional rules andlor 
user responses. The va rucs are rep~entedby ai, i> 1. Thc evaluation function, ev~, is only called onec 
a set of ground terms (values) is avadable through the satisfaction of the antcccdcnt condkions. Once 
the declaratively reformulated assignment rules have been incorporated into the roof tree and the constituent 
variables have been instantia~thc original assignment rules can be evaluated. The right-hand expression 
is sim ly parsed and cvahtated using the instantiated values, an~ the lcfi-hand variable is instantiated 
to the resttkiig value. If. .thcn rules which have an arithmetic expression in the cmscqucnt arc handled 
similarly. Under their declarative rcformulatiodiiterprctation they are treated as nested if. .thcn IUICS. 
For instance, the if. .thcn rule if A<l then B=C+2 is interpreted as if A<l thc$l if C = al and 2=2 
 then B = cval(al + 2).  Bceausc arithmetic Icnowhxigc is an integral part of the proof tree under the 
dcelarativc interpretation, it is also an integral part of explanations based on that proof tree. This 
is illustrated in a later section. Implementing the Solution Fra ments of an inference engine for implementing 
the proposed m~odology are preacntcd. The complete engine is a pure mcta-level inference engine as dcfmcd 
by [S][13][14]. The thcoretkd foundations of such engines are described in [10][15]. A single proof tree 
is constructed on which both how and why-not explanations arc baaed. This is in accordance with the approach 
reported in [Id for the meta-level inteqmetationof Prolog. Thc engine kernel is composed of a squencc 
of Prolog clauses of the form: pursue (Current Goal, WhyTrace, HowTrace) :-subgoals where Current Goal 
is the goal whose satisfaction is attempted on entry into the clause, WhyTra ce ia list structure contmning 
all nodes in the proof tree on the path from the root to the current goal (the why-trace ), and HowTrace 
is the moof tree Chow-trace or why-not trace depending on whether ihe top-level goal succccds o; fails) 
consistfig of ;ll successful 329 paths from the root node. (In order to avoid confusion, we will refer 
to the inference engine rules as clauses and the problem domain rules as rules.) There arc two different 
forms of Curren itGoal in the inference engine clauses. In some clauses, curren tGoal is a metavariable 
which is instantiatal on activation of the clauses to one of the variable goals occurring in the domain 
roles. In other clauses, curren tGoal is a relational expression of the form:  Goal = Value Goal < Value 
Goal > Value . . where Goa 1 and Va 1 ue are metavanables instantiated on activation of an inference 
engine clause to a domain goal and value. To illustrate the chainiig of assignment rules we can restrict 
ourselves to the simpler variable goals. The how-trace is of particular interest for it contains the 
information on which the system s post consultation explanations are based. It is implemented in the 
inference engine as a Prolog structure of the following form: because (is(eq(Goal ,Value) ,TruthValue) 
, Reason) . The infix reading is Goal eq Value is TruthValue because Reason. Expanding on the previous 
inference engine template, we see that the clauses for simple variable goals are of the form: pursue 
(Goal, (Goal l_J ,Goal eq Value is TruthValue because Reason) :­ subgoals. Value is uninstantiated on 
entry into the clauses. Value is the value obtained for Goal as a result of further chaining, the evaluation 
of an expression, or a response to a user query. Tru tAVaZ ue will be instantiated to true, for a value 
can always be obtained for a variable goal. This is in accordance with the earlier observation that on 
a declarative interpretation variable goals can be inte~reted as relational expressions that always evaluate 
to true. The chaining of ordinary if. then rules (involving no arithmetics) is illustrated in the following 
clause. pursue (Goal, Why, Goal eq Value is TruthValue because Reason) :­f ind_rul e (if then_rul e (if 
Condi tions then Goal = Value) ), pursue (Conditions, [Goal IWhy] ,Reason) , truth_ value (Reason, TruthValue), 
 record (wasderived(Goal, Value) ] . Goal is fist copied directly into the how-trace . The find_rule 
predicate then searches the rule-base for an if..then rule with Goal in its consequent. If found, the 
antecedent conditions of that rule are passed on to additional clauses for parsing and chaining. On return 
the success or failure of those antecedent conditions in noted in Tru thVal ue, and the derived value 
is recorded to avoid unnecessary rq@ition should that goal be pursued again. The chaining of assignment 
rules is accomplished with minor modifications. Rather than pass a set of antecedent conditions on for 
parsing and chaining, an arithmetic expression is passed on. pursue (Goal, Why, Goal eq Value is true 
because Reason) :­ f ind_rule (assign_rule (Goal = Expression) ) , pursue (Expression, [Goal I Why] ,R) 
, evaluate (Expression, Value) , Reason = ((Goal eq Expression is true because recorded in rule base 
) and R) , record (wasderived(Goal ,Value) ) . In this case, the f ind_rule predicate searches the rulebase 
for an assignment rule whose letl operand matchea the current goal. If found, thenght-hand expression 
is pasaed onto other pursue clauses which parse the expression (treating it as a conjunction of goals) 
and which attempt to satis~ (find a value for) each goal (operand) just as is done with the individual 
conditions of an if. then rule. This accomplishes the declarative reformulation nwessary to integrate 
the rule into the proof tree. Upon returning from the recursive chainiig process R contains the expkmation 
of the values which have been associated with the operands in Expression. At thii point the evaluate 
clause is invoked to evaluate Expression in accordance with its procedural interpretation. All the components 
are available to construct an integrated explanation of the use of the arithmetic knowledge contained 
in the assignment role. The explanation states that the input goal Goal receives value Value. The reason 
Reason is that the value for Goal is defined by the assignment mle Goal eq Expression and Expression 
s operands have the values identifiwJ and explained in R. The clause for if. then rules with assignment 
statements in the consquents is only slightly more complex. pursue (Goal, Why, Goal eq Value is TruthValue 
because Reason) :­get_rule (if then rule (if Condition then Goal = Express~on ) ) , pursue (Condition, 
[Goal IWhy] ,Reasonl ) , truth_value (Reasonl , TruthValue) , TruthValue = true, pursue (Expression, 
[Goal I Why] ,Reason2 ) , evaluate (Expression ,Value), Reason = ((Goal eq Expression is true  because 
Reasonl) and Reason2), record (wasderived(Goal, Value) ) . The primary difference here is that the pursue 
predicate is called twice -once for the antecedent conditions of the if..then rule and again for the 
arithmetic expression in the consequent. This implements the declarative nested if interpretation of 
the rule. The final how-trace includes the logical conjunction of the traces for the antecedent conditions 
and the arithmetic expression (declaratively interpreted) intheeonsquent. Applications This method of 
integrating arithmetics has proven uaetid in two systems developed by the authors [1][2]. The fmt system 
aids government employees who are assigned to new posts of duty. Certain of the costs associated with 
the relocation are reimbursable. The kinds of expenses and amounts the government will reimburse are 
determined in a set of regulations. By encoding these regulations into a role-base the seek residence 
quarters+ your transportation allowance process can be largely automated. The other system estimates 
for seeking residence quarters the computing resources and costs that are associated with because toxicological 
studies. Its rule-base contains information on the resources that are needed given a study of a patiicular 
size and type as well as information for calculating the costs for these resources. Arithmetic knowledge 
is an integral part of each of these problem domains. (For economy, we restrict ourselves to the relocation 
allowance system. ) Once it has been determined that a trans ferce is eligible for reimbursement for 
a particular category of expense, it is desirable to actuafly calculate the amount based on prescribed 
formulas. The folfowing sequence of rules illustrates both the need for an arithmetic capability and 
the ease with which arithmetic knowledge can be incorporated using the modified rule schema. (The delimited 
objects, $...$, are object-level variables.) if $you are eligible for an allowance to seek residence 
quarters$ = yes then $your allowance for travel to seek residence quatiers$ = (($your allowance per day 
for travel to seek residence quarters$ + $your spouse s aLlowance per day for travel to seek residence 
quartera$) * $the number of days required to seek residence quarters$) + $your tmnsportation allowance 
for seeking residence quarters$. $your allowance per day for travel to seek residence quarters$ = $your 
per diem$. if $your spouse will accompany you when traveling to seek residence quarters$ = yes then $your 
spouse s allowance per day for travel to seek residence quarters$ = 3/4 * $your per diem$. if $you will 
drive a privately owned vehicle when tmveling to seek residence quarters$ = yes then $your transposition 
allowance for seeking residence quartcrs$ = $the total miles driven when traveling to seek residence 
quarters$ * $your mileage rate$. if $the size of your immediate family$ = 2 then $your mileage rate$ 
= $0.17$. The following excerpt shows how an explanation of the arithmetic information used during a 
consultation is integmted into the final explantion presented to the user. This style of explanation 
makes explicit the role that arithmetic knowledge has played in the obtainment of values for goals which 
depend on it. For each goal whose value is determined by an arithmetic expression the final value for 
that goal is displayed, the arithmetic expression that was used to obtain that value is displayed, and 
the process is repeated for other subgoals (variables) in the expression. your allowance for travel to 
seek residence quarters = 295.00 bezause your allowance for travel to seek residence quatters = your 
allowance per day for travel to seek residence quarters + your spouse s allowance per day for travel 
to seek residence quarters * the number of days required to you are eligible for an aUowance to seek 
residence quarters because and your allowance per day for travel to seek residence quartera = 60.00 because 
your allowance per day for tmvel to seek residence quarters = your per diem and your per diem = 60,00 
and your spouse s allowance per day for tmvel to seek residence quarters = 45.00 because your spouse 
s allowance per day for tmvel to seek residence quarters = 314 * your per diem because your spouse will 
accompany you when tmveling to seek residence quarters and your p diem = 60.00 and the number of days 
required to seek residence quatirs = 2 because and your tmnqmtation allowance for seeking residence quarters 
= 85.00 because your transportation alfowance for seeking residence quarters = the total miles driven 
when traveling to seek residence quarters * your mileage mte because you wilf drive a privately owned 
vehicle when traveling to seek residence quarters and the total mifes driven when tmveling to seek residence 
quarters = 500 and your mileage rate = 0.17 because the size of your immediate family = 2 Gmclusion 
We have seen that procedural arithmetic knowledge can be natumlly represented in a decktrativc rule-base 
and yet still be smoothly integmted into proof trrm. This can be done by conatrttcting an inference engine 
which imposes a ddarative as wefl as a procedural interpretation on the proceduml component. Portions 
of a Prolog expert system inference engine which is capable of the required dual interpretation have 
been presented alon~ with mlea and an explanation from a real-world apphcation. Futther research is planned 
to determine the applicabilhy of the mtihodology to a broader range of declamtive/procedural problems. 
 References [1] Berghel, H., Roach, D., Green, G., &#38; Meehan, J. 1991. An Expert System for Detrmniniig 
Government Relocation Allowances. Expert $wiem WUh Applications 2(1 ), 167-174.. [2] Berghel, H., Roach, 
D., Green, G., Place, S., &#38; Meehant J. 1991. An Expert System for Managing Toxicology.al Studies. 
J3pert Systems 3(l), 38-45. [3] Cohen, J. 1990. Constraint Logic Programming Languages. CACM 33(7), 52-68. 
[4] Colmerauer, A. 1990. An Introduction to Prolog III. CACM 33(7), 69-90. [51 Gallanti, M., Guida, G., 
Spampinato, L., &#38; Stetknini, A. 1985. Representing procedural Knowledge in Expert Systems: An Application 
to process Control. Proceedings oj the Ninth International Joint Conference on Art@cial Intelligence, 
pp. 345-352. La Altos, CA: Morgan Kaufmann. [61 Georgeff, M. P. 1982. ProcAural Control in Production 
Systems. Arti@ial Intelligence, 18, 1 75-201. [71 Georgeff, M. P., &#38; Bonollo U. 1983. Procedural 
Expeti Systems. Proceedings c?fthe Eighth Internatkmal Joint Conference on Arti@al Intelligence, pp. 
151-157. Los Altos, CA: MorganKaufmann.  [8] van Harmelen, F. 1989. A Classificationof Mets-Level Architectures. 
In Logic-Based Knowledge Representation, eds. P. Jackson,H. Reichgclt,&#38; F.Harmelen,pp. 13-35. Cambridge,MA 
MITPress. [9] Heintze, N., Michaylov, S., Stuckey, P. 1987. CLP(R) and Some Electrical Engineering Problems. 
Proceedings o~ lhe Fourth International Conference on Logic Programming, pp. 675-703. Cambridge, MA. 
MIT Plus. HO1 Hill. . P.. &#38; Llovd. J. 1989. Analvsis of Mets-prcmams. In . Me ta-Prog%nrning in 
L.ogh Programming,-eds. H. Abramson &#38; M. Rogers, pp. 23-51. Cambridge MA: MIT hSS. [11] Jaffar, 
J., &#38; Michaylov, S. 1987. Methodology and ImplementatiJenti~..P System. Proceedings of the Fourth 
Conference on Logic Programming, pp. 196-218. Cambridge, MA: MIT Pre3s. [12] Lassez, C:, McAloon, K., 
&#38; Yap, R. 1987. Constraint Logic Programming and Option Trading. IEEE Expert 2(3), 42-50. [13] Sterling, 
L., &#38; Shapiro, E. 1986. lle Art of Prolog. Cambridge, MA: MIT Press. [14] Sterling, L. 1988. A Mets-level 
Architecture for Expert Systems. In Mets-level Architectures and Re~ection, ~gti~d Maes 8C D. Nardi, 
pp. 301-311. North­ [15] Subrahmanian, V. 1989. A Simple Formulation of the Theory of Metalogic Programming. 
In Meta-Progranuning in Logic programming, eds. H. Abramson &#38; M. Rogers, pp. 65-101. Cambridge, MA: 
MIT hXJS. [lq Yalcinalp, L., &#38; Sterling, L. 1989. An Integrated Interpreter for Explaining Prolog 
s Successes and Failures. In Mets-Programrning in L41gic Programming, eds. H. Abramson &#38; M. Rogers, 
pp. 191-203. Cambridge, MA MIT Press.   
			
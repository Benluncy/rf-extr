
 Read-Once Branching Programs, Rectangular Proofs of the Pigeonhole Principle and the Transversal Calculus 
Alexander Razborov* Avi Wigdersont Andrew Yao$ Abstract We investigate read-once branching programs for 
the following search problem: given a Boolean m x n ma­trix with m >n, find either an all-zero row, or 
two 1 s in some column. Our primary motivation is that this models regular resolution proofs of the pigeonhole 
prin­ciple PHPnm, and that for r-n > n2 no lower bounds are known for the length of such proofs. We prove 
ex­ponential lower bounds (for arbitrarily large m!) if we further restrict this model by requiring the 
branching program either to finish one row of queries before ask­ing queries about another row (the row 
model) or put the dual column restriction (the column model). Then we investigate a special class of 
resolution proofs for PHP~ that operate with positive clauses of rectangular shape; we call this fragment 
the rectan­gular calculus. We show that all known upper bounds on the size of resolution proofs of PHPnm 
actually give rise to proofs in this calculus and, inspired by this fact, also give a remarkably simple 
rectangular reformula­ *Steklov MathematicalInstitute, 117966, Moscow, Russia. Part of the work was done 
while this author was visiting Special Year on Logic and Algorithms at DIMACS, Princeton. Also sup­ported 
by Russian Basic Research Foundation grant 96-01-01222. t Institute of Computer Science, The Hebrew University, 
Jerusalem, Israel. Part of this work was done while on sabbatical leave at the Institute for Advanced 
Study and Princeton Uni­versit y, Princeton. This work was supported by USA-Israel BSF grant 92-00106 
and by a Wolfson research award administered by the Israeli Academy of Sciences, as well as a Sloan Foundation 
grant. t Computer Science Department, Princeton University, prince­ton, New Jersey 08544, USA. This work 
was supported in part by National Science Foundation and DARPA under grant CCR­9627819, and by USA-Israel 
BSF grant 92-00106. tion of the Haken-Buss-Turiin lower bound for the case m << n2. Finally we show that 
the rectangular calculus is equivalent to the column model on the one hand, and to tmnsversal calculus 
on the other hand, where the lat­ter is a natural proof system for estimating from below the transversal 
size of set families. In particular, our ex­ponential lower bound for the column model translates both 
to the rectangular and transversal calculi.  1 Warm Up The following elementary data structure problems, 
which may be contemplated as independent puzzles by the reader, are the axis connecting the different 
notions in the title of the paper. Consider algorithms which probe, once, the entries of an input array 
A in an ar­bitrary adaptive order, and use s bits of memory. Let m> n. What is the smallest memory size 
s = s(n, m) needed for solving the following problems? . When A E [m] , find a number in [m] missing 
from A. . When A c [n]m, find two entries A containing the same number from [n]. 2 Introduction Complexity 
of propositional proofs is rapidly becom­ing to play as important a role in the theory of feasible proofs 
ss the role played by the complexity of Boolean circuits in the theory of efficient computations. And 
the resolution proof system introduced in [Bla37] and fur­ther developed in [DP60, Rob65] is one of the 
first and simplest in the hierarchy of propositional proof systems; it is also of invaluable importance 
for various automatic theorem proving procedures. Tseitin [Tse68]proved, a1­most 30 years ago, the first 
exponential lower bound for regular resolutions (these are resolutions with the addi­tional restriction 
that along every path every particular variable can be resolved at most once). However, despite its apparent 
(and deluding) sim­plicity, the first lower bounds for non-regular resolu­tions were proven only in 1985 
by Haken [Hak85]. These bounds were achieved for the pigeonhole prin­ fl+l 1) pigeOnS can not sit ~erting(n+that 
  ciple PHPn in n holes so that every pigeon is alone in his hole. M&#38; tivated by a separation problem 
in Bounded Arithmetic (just like the research on the complexity of Boolean cir­cuits is motivated by 
needs of the theory of Turing com­putations!), Buss and l%r6n [BT88] extended his bound to exp ( Q (~)) 
for more general form PHP~ of the pigeonhole principle in which the number of pigeons, m is another parameter. 
See also [Urq87, CS88, BP96] for other bounds on the complexity of resolutions, and [Juk96] for a generalization 
of the Haken-Buss-Thriin bound to the caae of semantic resolutions. All these bounds trivialize when 
m z nz, and all lower bounds techniques discovered so far become void with that many pigeons. As mentioned 
in [BT88] (see also [Kra94, page 31]) it is an open question whether PHP~ haa a poly-size resolution 
proof, and this is open even for regular resolutions. More generally, it is open whether there is any 
m (as a function of n) for which PHP~ has a resolution proof of size polynomial in n. The only non-trivial 
upper bound is due to Buss and Pitami [BuP96]: PHP# has a resolution proof of size exp(O(~= + n log n/ 
logm)). In this paper we take the first partial steps toward resolving the above question in the negative 
(at least for regular resolutions). The meaning of our results be­comes, however, clearer if we employ 
the characteriza­tion of regular resolutions in computational terms (see e.g. [Kra94, Theorem 4.2.3]). 
Namely, regular resolu­tions are known to be equivalent to read-once branching programs (b.p.) solving 
the following search problem: given a truth assignment, find some initial clause falsi­fied by this assignment. 
For the special case when the search problem (i.e. the initial clauses) corresponds to PHP~, we introduce 
two restricted classes of read-once b.p. and call these computational models the raw model and the column 
model. In the row model (with rows corresponding to pigeons) the (read-once) b.p. must query all variables 
from some row immediately after it queries the first such variable. The column model is defined dually. 
We prove a tight exp(fl(n log n)) size lower bound in the row model and an almost tight bound exp(Q(@ 
+ n/ log m) ) in the column model; note that they make perfect sense for m = 00. The proofs for both 
models have one remarkable feature in common that is some­what novel for research of this kind (in fact, 
it is this feature that allowed us to overcome the nz barrier), As in many similar proofs we do construct 
a distribution on inputs that fools branching programs from some class. But (and this is the novelty) 
our distn butions essen­tially depend on the progmm being fooled, and are being constructed along with 
the progress of computation itself. Both the obvious 2°1nl-sized resolution proof of PHP~ and the Buss-Pitassi 
proof mentioned above can be restructured to operate with positive clauses of rect­angular form only. 
Inspired by this fact, we introduce the corresponding rectangular calculus (a subclass of res­olution 
proofs for PHP~m), and show that both these proofs can be carried out there. We have failed to sim­ulate 
arbitrary resolution proofs of PHP~m in this cal­culus, and we doubt that such a simulation is possible 
(it actually seems that already the row model cannot be reduced to the rectangular calculus). However, 
in per­forming this task we have succeeded enough to sim­ulate there the Haken-Buss-Turiin lower bound: 
the rectangular version of their proof is remarkably sim­ple and may be of independent interest. Interestingly, 
it turns out that the rectangular cal­culus is equivalent to the column model. This al­lows us to translate 
the Buss-Pitasai upper bound exp(O(~= + n log n/ log m)) to the column model, and our exp(fl(fi + n/ 
log m)) lower bound in the col­umn model to the rectangular calculus; these bounds are matching up to 
a logarithmic factor in the exponent. From the complexity-theoretic perspective, the set of all propositional 
tautologies TAUT is just one of natu­ral c&#38; NP-complete sets, even if it was historically the first. 
For any such set we can raise the question of what are natural (i.e., coherent to the intrinsic struc­ture 
of the set) proof systems for membership proving, and then ask how do proof systems for different sys­tems 
compare to each other in terms of their strength via natural reductions. While natural proof systems 
for the ca-NP-complete sets corresponding to the INDE PENDENT SET and CHROMATIC NUMBER prob­lems were 
defined and studied by Chvatal [Ch77] and McDiarmid [Mc79] respectively, no relations between the power 
of these systems and others are known. Re­ductions were systematically studied only for the differ­ent 
systems for TAUT (which, in our opinion, is to a large extent caused by historical and psychological 
rea­sons). The only nice exception we are aware of are Haj&#38; calculus for the set of non-3-colourable 
graphs [Haj6 1], and the proof of its equivalence to Frege systems [PU92], We contribute to this line 
of research by defining a natural (sound and complete) proof system for proving lower bounds on the transversal 
(hitting set) size of set families (dual to the SET COVER problem). We call this system the tmnsversal 
calculus and show it to be equivalent to the rectangular calculus. In particular, all upper and lower 
bounds for the column model and for the rectangular calculus immediately translate to the transversal 
calculus. The paper is organized as follows. In Section 3 we re­call some necessary notation and definitions. 
In Section 4 we present our lower bounds for the row and column models. Section 5 is devoted to the rectangular 
calculus (including our reformulation of the Haken-Buss-Tur6n bound), and Section 6 to the transversal 
calculus. Preliminaries Let pl, p2,.. .,pn,. . . be propositional atoms. A lit­eral is either an atom 
or the negation (7P) of an atom p. A clause is a set of literals, to be thought of aa the disjunction 
of participating literals. A clause is positive if it does not contain negated literals. The resolution 
system is the propositional proof system that operates with clauses and has one rule of inference c1 
u {p} c u lP} (c, Uc, gc) c called the resolution rule. We say that the atom p is resolved in this application 
of the resolution rule. A resolution proof is a proof in the resolution system. A resolution refutation 
of a set of clauses is a resolution proof of the empty clause from this set. Throughout this paper we 
allow straight-line proofs (as opposed to tree-like), i.e., after a formula is inferred, it can be used 
arbitrarily many times in further infer­ences. The size of a proof is the number of clauses in it. A 
resolution proof is regular if along every path from an axiom to the final clause every atom is resolved 
at most once, For any unsatisfiable set of clauses c={cl(pl, ....pn).c..,c k(,Pn)},,  Pn)}, let us consider 
the following search problem Sc: given a truth assignment a E {O, l} , find some v such that C.(a) = 
O. Following Borodin and Cook [BC82], we define an R-way bmnching progmm in n variables aa a directed 
acyclic graph with one source node s (sometimes also called the root),in which every non-sink node is 
la­belled by one of the variables xl, . . . . Zn and has ex­actly R outgoing edges numbered by 1, . . 
. . R. Let [R] = {1,2,..., R}. Every input string A E [R]~ deter­mines a computational path cornp(A) 
from s to a sink node. An R-way b.p. (branching program) solves some search problem with inputs from 
[R]n if its sinks can be labelled by possible solutions to the search in such a way that for every A 
E [R]n, cornp(A) leads to a sink Iabelled by a solution admissible for the input A. The size of an R-way 
b.p. is the total number of nodes. The logarithm of size corresponds to the space used by general sequential 
algorithms. An R-way b.p. is read-once if along every path p every variable is tested (i.e. appears as 
a node label) at most once. Let X(p) be the set of variables that are tested along some path p. A read-once 
b.p. is unifomn if: a) for a path p beginning at the root s, X(p) depends only on the terminal node v 
of p (accordingly, we denote it by X(V)); b) for every sink t, X(t) contains all variables. If, moreover, 
the variables are teated in the same order along every path (i.e., X(v) depends only on the depth of 
v defined as [X(v) I), the uniform program is called oblivious. Uniform read-once R-way b.p. possess 
the nice prop erty that every path from the root to a sink node is the computational path cornp(A) for 
an uniquely defined input A E [R] ; therefore we can identify inputs with such 1/0 paths. On the other 
hand, [Oko91] noticed that uniformity is not actually a serious restriction: Proposition 3.1 Every R-way 
read-once b.p. in n variables can be simulated by an equivalent uniform pro­gmm whose size is larger 
by at most a factor of n. It is not known whether a similar simulation is in general possible by oblivious 
programs. The following remarkable result is apparently the only known case of an equivalence between 
a propo­sitional proof system and a computational model (we omit the prefix 2-way in the case of ordinary 
binary programs): Proposition 3.2 Let Cbean unsatisfiable set of clauses. Then the minimum size of any 
regular reso­lution refutation of C is equal to the minimum size of any read-once b.p. solving Sc. For 
the proof see e.g. [Kra94, Theorem 4.3] (cf. also the proof of Theorem 5.4 below). Definition 3.3 YPHP~ 
is the following set of clauses, over the (m xn matrix of) atoms pij: {-Pil,j> =Pi2!j}(~l!~2 ~ [~11il 
# i ; ~~[4); (1) {Pil,Pi , . ~.,Pi~}(i E [~]). (2) Clearly, =PHP; is unsatisfiable for m ~ n+ 1. Hence 
it possesses resolution refutations that we will sometimes call resolution proofs of PHPnm. In the ma­trix 
representation 1, an admissible solution of S.PHPr 1Note that this is a transpose of Haken s original 
representa­tion from [Hak85], The reason for implementing this change is that at the moment it has become 
more customary to use the notation in which the first index i corresponds to the largest of the two numbers 
m, n (most often m), and that would be highly confusing to let it also correspond to the columns of a 
matrix. is either an identically zero row, or two l-entries in the same column. Since we do not consider 
in this paper any tautologies other than PHPnm, we assume through­out that m, n are some integers, m 
~ n+ 1, and all propositional atoms have the form pij, where i E [m] and j E[n]. Let A be a family of 
sets (that are subsets of some fi­nite underlying universe). A set T is called a transversal of A if 
it intersects all members of d (i.e., A n T# 0 for all A E A). The transversal number r(d) of the family 
A is the size ITI of the smallest transversal 2 of d. 4 Lower bounds Many lower bounds in Boolean complexity 
are based upon the following transparent idea: define a natural probability distribution a on inputs2, 
and show that every small circuit/program B presumably solving our problem must err with positive probability 
on a random input chosen accordingly to a. In particular, it seems that all known lower bounds for read-once 
b.p. (see e.g. [Weg87, Chapter 14.4], [Raz91] for examples) employ this idea. In this paper we bring 
something fresh to this method: the distribution aB will not be fixed in advance but will essentially 
depend on the program 1?, and will be constructed dynamically along with the progress of the computation. 
We consider two types of read-once b.p. for S_PHPr : those which must query all variables from some row 
immediately after querying the first such variable, and those satisfying the dual column restric­tion. 
 4.1 The Row Model If a read-once b.p. attempting to solve SYPHP­queries at once all variables from some 
row, then tie adversary should not respond with all zeros since then the program can immediately produce 
an unsatisfiable clause of the form (2). Conversely, if he follows this rec­ommendation and never responds 
wit h all zeros, then all clauses (2) will be satisfied, and the result of the search must be a negative 
clause of the form (1). Which means that it is disadvantageous for the adversary to respond with more 
than a single one either, and this leads us to the following model: Definition 4.1 In the raw model, 
an n-way read-once b.p. in m variables attempts to output a solution to the following search problem 
Row:: given an input A~ [n]m, find some il, iz E [m] and j c [n], where il # 22, such that Ail =Aiz =j. 
z throughout the paper we use the bold face for denoting ran­dom objects Clearly, there is an exp(O(n 
log n))-sized program solving Row;: just ignore all but the first (n + 1) vari­ables, and treat every 
one of nn+l inputs individually by a decision tree. Our first result shows that in the row model we cannot 
do any better: Theorem 4.2 Any n-way read-once b.p. in m vari­ables that solves Row; must have size exp(fl(n 
log n)). Proof. We can assume n > 3. Let B be an n-way read-once b.p. in m variables. For any node v, 
denote by J(v) the set of all j E [n] such that for some jired variable ~i, every path from the root 
s to v makes the assignment ~i = j. Note that if e = (u, v) is an edge (directed from u to v), then IJ(v)I 
~ I.l(u)l + 1. Let us call an edge e labelled by j and outgoing of v legal if j @ J(v) and illegal otherwise. 
Claim 4.3 If B solves Row:, then there is no path from the root to a sink consisting entirely of legal 
edges. Proof of Claim 4.3. Consider some path p between the root s and a sink node t labelled by Ail 
=Ai, = j. Then p must contain at least two edges labelled by j. Let e = (w, v ) be the last edge along 
p with this property. We are going to show that e is illegal.  Replacing, if necessary, il by iz, we 
may assume that il is not the label of v. Every path from s to v must make the assignment Xil = j: otherwise 
we could com­bine it with the segment of p beginning at v (keeping in mind that B is a read-once program), 
and get a com­putational s t path that does not make the assign­ment Xil = j, contrary to the assumption 
that B solves Row: . Hence j c J(u), and e is illegal., Now we convert B into a finite Markov chain as 
fol­lows: the set of states is simply the set of nodes, s is the initial state, and terminal states are 
sink nodes along with those v for which J(v) = [n]. The Markov process which at any non-terminal state 
v traverses all outgoing legal edges with equal probabilities, defines a random path PB. Claim 4.3 implies 
that with probability 1 pB actually arrives at a terminal node v of the second type, i.e. such that J(v) 
= [n]. Also, every time the value IJ(v) I increases along an edge in pB, it increases by at most one. 
Thus, with probability 1, PB visits some node v such that IJ(v) I = ~n/21. Let v be the first such node 
along pB. We are only left to show that for every specific V. with IJ(vO)I = [n/21, P[v = Vo]< exp( 
fl(n logn)) (and, hence, there must beat least exp(~(n log n)) such Vo).  Consider any V. with J(vo) 
= {jl, . . . . j(nfzl }, and let iv (1 ~ v ~ [n/21) be integers such that ev­ery path from s to V. has 
made all the assignments xil = 31,. ..,~i[n/21 = ~[n/21 . Clearly, il, . . . . i[n/.4 are also distinct. 
Then v = V. implies, in particular, that before arriving at the node V., the Markov process PB must have 
tested all variables ~i, , ., x , ~n,21 (possibly in a variable order) and make every time the decision 
Z~V= ] . Moreover, since v was chosen to be the first node along PB with ~(v) = ~n/21, PB must make these 
decisions at nodes v with at least [n/21 outgoing le­gal edges which implies that, for each v, the probability 
to make the decision xiu = j is at most 2/n. It fol­lows from general properties of Markov processes 
that P[v = vo]< (2/n)[ni21 < exp( fl(n logn)). The proof of Theorem 4.2 is complete.=  4.2 The Column 
Model Similarly to the row model, if a read-once b.p. for S.PHP7 always queries at once all variables 
from the same column, we may assume that it receives in re­sponse a single one, and this leads us to 
the following model that is dual to the row model: Definition 4.4 Let Colum~m be the following search 
problem: given an input A E [m] (viewed as a func­tion), find some i E [m] which is not in the image 
of A. In the column model, we consider m-way read-once b.p. in n variables attempting to solve Colum~m. 
Unlike the row model, there is a non-trivial upper bound in this model, and it will be presented in the 
next section {see Corollary 5.5). Our lower bound matches it within a logarithmic factor in the exponent. 
Theorem 4.5 Any m-way read-once b.p. in n uari­ ables that solves Colum~m must have size at least exp(fi?(fi+ 
n/ logm)). Proof. Firstly we prove the bound exp(fl(rz/ log m)). (3) Let B be an m-way read-once b.p. 
in n variables solving Colum~~. By Proposition 3.1, we may assume that B is uniform. For a node v of 
B denote by 1(v) the set of all i c [m] which are not assigned to any variable Xj c X(v) aIong any path 
from the root s to v. Let us call an edge e outgoing of v and labelled by i legal if i E 1(v) and iliegal 
otherwise. The dual statement to Claim 4.3 simply says that 1(v) # 0 for every node v. Moreover, J(s) 
= [m], 1(v) can only decrease along edges, and z E I(t) for every sink node t labelled by i @ ire(A). 
Define PE by the same Markov process as in the proof of Theorem 4.2 (with the new notion of legal edge, 
of course). The remark above implies that PB arrives, with probability 1, to a sink node t.Since B is 
uniform, PB has length n (w.p. 1). Let k = [logrn~, and s = VO,Vl, . . ..V~ = t be nodes along PB that 
divide this random path into segments of length at least [n/k] each. Since l~(vo)l = m, l~(vk)l ~ 1 and 
I(vU) is decreasing in v (w.p. 1), we have that for some O~ v < k 1, Similarly to the proof of Theorem 
4.2, we are left to show that for any specific pair (u., Ul) of nodes with the properties IX(UI) \ X(uo)l 
~ [n/k], l(uI) ~ I(uo) and [l(u1)I ~ ~]l(uo)l, we have P[uo and UI belong to pB (in this order)] (4) 
<2-in/kJ . This again follows from the general theory of Markov processes. Indeed, any successful PB 
can visit between U. and U1 only those nodes v for which At any such node v, there are [1(v) I outgoing 
legal edges, and at most II(v) \ l(u1 ) I ways for the Markov process to maintain the property (5). Thus, 
the probability to make the right decision at every individual node v is at most and on its way from 
U. to U1 the process must make at least in/kj of them. The bounds (4) and (3) follow. In order to see 
the remaining bound exp(f2(@)) on the size of B, we just remark that if B is an m-way read­once b.p. 
of size at most 2fi, we can assume w.1.o.g. that ms 2@: only as many i s can appear as labels on sink 
nodes, and all other i s can be disregarded. But now the bound exp(~(fi) ) follows from the already proven 
(3). The proof of Theorem 4.5 is complete. .  5 The Rectangular Calculus For1~ [m], J ~ [n], let RIJ 
denote the positive clause {pij IiE1, j GJ}; we call clauses of this form rectangular or, if we want 
to specify sizes, III x IJI rect­ angular. The perimeter of a non-empty ax b rectangu­lar clause is defined 
as a+ b (half of the geometrical perimeter). As we will see below, rectangular clauses (and espe­cially 
those of perimeter (n + 1)) are of ext reme impor­tance for both upper and lower bounds on the complex­ity 
of resolution proofs of PHPnm. This motivates the study of the following fragment of resolutions that 
op­erates with rectangular clauses only and captures that kind of reasoning. Definition 5.1 The rectangular 
calculus is the proof system that works with rectangular clauses and has one inference rule RI,,J,u{j}> 
. . .. RI,,J,u{j] RIJ (6) (lln... nI~=O, j~[~], 11 u.. .Ulkgl, Jl u.. .uJ~~J). 1 (Intuitively, only one 
pigeon from 1 can go to hole j, and there is no pigeon which is common to all i , so at least one has 
to go to J.) A rectangular pmaf is a proof in the rectangular cal­culus, a rectangular refutation of 
a set of rectangular clauses is a rectangular proof of the empty clause from this set, and a rectangular 
refutation of ~PHP~ (a rect­angular proof of PHPnm ) is a rectangular refutation of the set of axioms 
(2). The size of a rectangular proof is the number of clauses in it. Let s(m, n) be the minimum size 
of any rectangular refutation of =PHPnm. Let us firstly see that proofs in the rectangular calcu­lus 
can be polynomially simulated by resolution proofs from =PHP~. Statement 5.2 Suppose that a rectangular 
clause R has a rectangular praof of size s from a set 7?, of ini­tial rectangular ciauses. Then there 
ezists a resolution proof of R from the set of azioms R + (1) that has size at most rn2(s + n). Proof. 
Since there are at most m2n axioms (1), we only have to show how to simulate the rule (6) with at most 
m2 resolution inferences using (1) as additional axioms. This is done straightforwardly: for every i 
E 11 we find some v with i @ Iv, and infer RIJ U {=p~j } from R~.,J.u{j} using at most II. I < (m 1) 
resolutions with appropriate axioms (1). Then we consecutively resolve the resulted clauses with RI, 
,J,uij} along {p~j Ii G 11} and get rid of these atoms. The whole inference uses at most IllI.(m 1)+ 
IIII< m2 resolution rules.- Unfortunatelyj it does not look plausible that ar­bitrary resolution proofs 
of PHP~ can be efficiently simulated in the rectangular calculus. However, many known constructions, 
both in the context of upper and lower bounds, can in fact be viewed as rectangular. We provide this 
view for three known results: c Brute-force search proof of PHP~+ 1: S(n + 1,n) < 2n+1 . Non-trivial 
proof of PHP~ for large m [BUP96]: s(m, n) ~ exp(O(logm+ nlogn/logm)) . The Haken-Buss-Tur6n lower bound 
rHak85,. BT88] : s(m, n) ~ exp(!d(n2/rn)). While the rectangular view of the two upper bounds presents 
the rectangular calculus merely as convenient for describing resolution proofs of PHP~, the view of the 
lower bound uses something more essential and sur­prising: we can trace rectangular clauses in an arbitrary 
resolution proof of PH P:. The rectangular proofs of these results are deferred to Appendix. Quite remarkably, 
the rectangular calculus is equiv­ alent to the column model from the previous section. The proof of 
this equivalence (similar to the proof of Proposition 3.2) takes up the rest of Section 5. Firstly we 
notice that rectangular proofs can be fur­ther structured to work only with one-dimensional clauses. 
We say that a rectangular clause ~~J is com­pact if J =[~ for some d, and abbreviate this clause aa R1,d. 
Note that the axioms (2) are compact. The following inference rule Rr,,d+~, . . . . R1.,d+~ &#38;,d (7) 
 (lln... nl, =0, d>o, rl u.. .Ulkgq is a special case of the rule (6). Lemma 5.3 For every rectangular 
proof of a compact clause R from a set R of initial compact clauses, there exists a rectangular proof 
of R from 7? that has the same size, and such that every line is a compact clause and every inference 
rule has the form (7). Proof. It is easy to see that the compression opera­tor that replaces any rectangular 
clause RIJ by ~J,lJl, transforms the rule (6) into either the trivial rule (i.e., when some premise is 
contained in the conclusion) or an instante of (7). . Theorem 5A s(m, n) is equal to the minimal possible 
size of a uniform m-way read-once b.p. in n variables solving the search problem Colum~m. Proof. a). 
Let P be a rectangular refutation of =PHPnm that has size s(m, n). By Lemma 5.3 we may assume that P 
contains only compact clauses, and that inference rules have the form (7). We convert P into an (oblivious) 
m-way read-once b.p. B as follows. Nodes n is an integer. The default axioms are of the form of B are 
just lines of P, the source node s is the final ~(d) ~ 1, where A is non-empty, and the only (unary) 
(empty) rectangle in P, and axioms become sink nodes. inference rule has the form For the computational 
node corresponding to the con­ clusion R1,d of the inference (7), the outgoing edge la- T(A) > n belled 
by i goes to some premise Rlv,d+l with the prop erty i @ 1.. Clearly, working on an input A E [m] , this 
T(f?)zn+l (8) b.p. traverses only through compact clauses R1,d fakii­ (VA~A3BA~B(nBA=0 &#38; UBA~A)). 
 fied by A (in the sense {A(1), A(2),.. ., A(d)] n 1= 0) 1 and thus eventually finds i # ire(A). b). 
Conversely, suppose that B is an uniform m-way read-once b .p. in n variables solving the search prob­lem 
Columr#. Using notation from the proof of Theo­rem 4,5, we associate with every node v the rectangular 
clause R(v) = R1(VJ,X(UJ. Clearly, R(s) is empty (since X(s) is so), R(t) contains R{il,[nl for a sink 
t labelled by the output i @ ire(A), and R(v) can be obtained from R(vl), ..., R(v~) via one application 
of the rule (6) if v is a computational node and V1,....v~ are all its children. Thus, we have constructed 
a rectangular refutation of lPHPnm that has the same size as B. . As a by-product of the above proof 
we obtain the fact that every read-once b.p. solving Colum~m can be made oblivious without any increase 
in size (this is also easy to prove directly). Using Theorem 5.4, we can translate the Buss-Pitassi upper 
bound (see Appendix, Example 2) to the column model, and our lower bound in Theorem 4.5 to the rect­angular 
calculus: Corollary 5.5 There exists an m-way read-once b.p. in n variables that solves ColumWm and has 
size at most exp(O(<=+ nlogrz/ logm)). Corollary 5.6 s(m, n) ~ exp(fl(fi + n/ log m)). 6 The Transversal 
Calculus In this section we define a natural (sound and com­plete) proof system for proving lower bounds 
on the transversal number r(d), and show it to be equivalent to the rectangular calculus and the column 
model. We thus infer the following lower bound for proofs in this system. Any proof that a family of 
m disjoint sets re­quire at least n elements to hit it, must be at least exp(fi) long, even if m is much 
larger than n or even infinite. Recall that for a family of sets A, we denoted by r(d) the size of the 
smallest set hitting every member of A. Let us further define nd = n&#38;4A andUd = UA~AA (respectively 
the intersection and union of all sets in A). As usual Idl denotes the cardinality of this family, i.e., 
the number of sets in A. Definition 6.1 Lines in the tmnsversal calculus have the form r(.4) ~ n, where 
d is a family of sets, and While the intuition behind this inference rule may not be clear at first sight, 
the simple proof of its soundness and completeness below would clarify it. We define the size of a transversal 
proof as the sum of cardinalities IAI of families appearing in all lines of the proof, Remark 6.2 A sensible 
alternative definition of size is to use the count ~A~A IAI in place of IA[ which is tant~ mount to the 
length of the proof. These two definitions are polynomially equivalent in many situations, such as for 
example, if the cardinality of the family we are in­terested in is not smaller than the number of elements 
in the underlying universe. Theorem 6.3 r(A) ~ n is provable in the transversal calculus if and only 
if it is true, i.e., this calculus is sound and complete. Proof. Soundness is proved by induction on 
the length of a transversal proof. For the inductive step, suppose r(d) ~ nis already known to be true, 
and VA E A ~~A ~ ~(nf?A= 0 &#38; U~A ~ A). We wish to prove T(B) ~ n+ 1. Assume that, to the contrary, 
T is a transversal of B with ITI = n. We derive a con­ tradiction. Choose any i ET. Since T \ {i} is 
not a transversal of d, there exists some A EA such that AnT ~ {i}. But since nBA = a, there exists also 
some B cBA (which implies B ~ A) such that i # B. We conclude that B n T~ (A nT) {i} = O, contrary to 
our assumption that T is a transversal of B. Completeness. Let Un be the family of all sets whose complements 
(to the whole universe) have size n 1. Let ~ be the quasiordering on families of sets given by A~ Bs 
YE E B 3A EA(A ~ B). Completeness is immediately implied by the combination of the following three facts 
easily checkable individually: Provability in the transversal calculus is antimono­ tone w.r.t. ~. In 
other words, if A~B and T(B) ~n is provable, then T(A) ~ n is provable, too. ~(A)~niffA~U.. . ~(un ) 
~ n is provable in the transversal calculus, In fact, T(un) > n r(Lln+l) ~ n + 1 is a legal inference. 
 m For a family of sets d and an integer n such that T(A) z n+ 1 is true, let us denote by i!(d, n) the 
min­imum size of any transversal proof of this fact, and by s(A, n) the minimum size of any rectangular 
proof of the empty clause from the set of initial clauses {R~,[nl\A cd}. (9) Note that s(A, n) generalizes 
the function s(m, n) studied in the previous section: namely, s(m, n) = S({{l}, {2},..., {m}], n). The 
following result says that the rectangular and transversal calculi are essentially just different forms 
of the same proof system: Theorem 6.4 For every jamily of sets A and every in­teger n such that r(d) 
z n+ 1, we have s(d, n) < t(A, n) < s(d, n) + Idl. Proof. Lower bound on t(d, n). Suppose we have a transver­sal 
proof T(A1) 2 1 r(dz) 22 ... T(A~+I) 2 n+ 1 of size -t(d, n), where An+l = A. We convert it into a rectangular 
proof (in the compact form) as follows: for every A c Ad, introduce the clause RA,ii-1. Then the clauses 
resulting from A.+l become initial axioms (9). Furthermore, if d<n and AE dd, then RA,d_l is inferred 
from { R~,d I B E BA } (where BA G dd+l is chosen accordingly to (8)) via one application of (7). Finally, 
any A EAl (remember that Al is non-empty!) gives rise to the empty clause. Upper bound on t(d, n). We 
prove it by reversing the above argument. By Lemma 5.3, there is a rectan­gular proof in compact form 
of size s(A, n). To obtain a transversal proof, we set for each d dt+ = {AI RA,d_l appears in the proof}. 
One subtle point is that in this way we obtain only a s(A, n)-sized transversal proof of T(d ) z n+ 1 
for some subset At of A, aswe do not require that all axioms necessarily appear in the proof (this is 
more than just an excessive pedantry cf. the last argument in the proof of the bound (13) below!) We 
convert it into a transversal proof of ~(~) z n + 1 simply by adding all sets from A \ d to the last 
line. m  Denote t({{l}, {2},..., {m}}, n) by t(rn, n). Corollary 6.5 exp(fl(logm + n/ logrn)) ~ t(m, 
n) ~ exp(O(log m + n logn/logm)). Proof. Immediate from Theorem 6.4, Corollary 5.6 combined with the 
trivial bound i(m, n) ~ m, and (12).m 7 Conclusion and open problems In studying the complexity of resolution 
proofs of the pigeonhole principle PHPnm, the case of m =n2 pigeons becomes a natural barrier where ordinary 
(static) distri­butions on the set of partial truth assignments, restric­tions etc. fail to fulfill their 
mission. In this paper we have proved first partial results beyond this barrier, and we hope that the 
idea which allowed us to overcome it (i.e., the usage of dynamical distributions constructed along with 
the progress of a computation or a proof it­self) will eventually lead to establishing lower bounds on 
the size of resolution proofs of PHPnm, at least in the regular case. The next step in carrying out this 
program might be the following Problem 1 Prove exponential lower bounds on the size of any oblivious 
read-once b.p. solving S7PHPF . More modest (but still interesting) goal is to close the logarithmic 
gap between upper and lower bounds on s(m, n): Problem 2 What is the order of magnitude of log s(co, 
n)? [BuP96] showed that it is at most {= , and we have proved that it is at least fi. Finally, we would 
like once more to draw attention to the fact that we have only a handful of natural proof systems for 
c&#38; NP-complete sets other than TAUT. We propose a more systematic study of natural reducibil­ities 
between such systems: this would help convinc­ing combinatorists and complexity theoretists (and our­selves) 
that proof complexity is a little bit more than just the Hilbert-style game with abstract symbols on 
a sheet of paper. References [BP96] P. Beame and T. Pitassi. Simplified and im­proved resolution lower 
bounds. In Proceedings of the 37th IEEE FOCS, 27A 282, 1996. [Bla37] A. Blake. Canonical expressions 
in Boolean ai­gebra. PhD thesis, University of Chicago, 1937. [BC82] A. Borodin and S. Cook. A time-space 
trade­off for sorting on a general sequential model of computation. SIAM J. on Computing, 11 :287 297, 
1982. [Bus87] S. Buss. Polynomial size proofs of the propo­sitional pigeonhole principle. Journal of 
Sym­bolic Logic, 52:916-927, 1987. [BuP961 S. Buss and T. Pitassi. Resolution and the weak pigeonhole 
principle. Manuscript, 1996 [BT88] S. Buss and G. Tdn. Resolution proofs of generalized pigeonhole principle. 
Theoretical Computer Science, 62:311-317, 1988. [Ch77] V. Chv6tal. Determining the stable set number 
of a graph. SIAM J. on Computing, 6:1-14, 1977. [CS88] V. Chv6tal and E. Szemer6di. Many hard ex­amples 
for raolution. Journal of the ACM, 35(4):759-768, 1988. [DP60] M. Davis and H. Putnam. A computing proce­dure 
for quantification theory. Journal of the ACM, 7(3):210-215, 1960. [Haj61] G. Haj6s. Uber eine Konstruktion 
nicht n­farbbarer Graphen. Wiss. Zeitschr. Mar­tin Luther Univ. Halle-Wittenbery, 10:116-117, 1961. [Hak85] 
A. Haken. The intractability or resolu­tion. Thwretical Computer Science, 39:297­308, 1985. [Juk96] S. 
Jukna. Exponential lower bounds on the size of clause based semantic derivations. Submit­ted to Proceedings 
of the DIMA CS workshop on Feasible Arithmetic and Length of Proofs, 1996. [Kra94] J. Kraji5ek. Bounded 
arithmetic, propositional logic and compiem ty theory. Cambridge Uni­versit y Press, 1994. [LNNW951 L. 
Lovasz and I. Newman and M. Naor and . A . Wigdreson. Search Problems in the Decision Tree Model SIAM 
J. on Discrete Math., 8:119­ 132, 1995. [Mc79] C. McDiarmid. Determining the chromatic number of a graph. 
SIAM J. on Computing, 8:643-662, 1979. [Oko91] E. A. 0KOJIbH19LUHHKOBiL HrmcHme OIleHKM cJromHocTH peanH3aumi 
xaparmepkrcm4_ec-KHX @yHKI@ ABOkPIHkJX KOnOB 6HHEtpHEJMH nporparmmmmr. Memodw ducxpemnozo ana­~wa, 51:61 
83, 1991. E. A. Okolnishnikova, Lower bounds for branching programs com­puting characteristic functions 
of binary codes, Metody discretnogo analiza, 51(1991), pages 61-83 (in Russian). [PU92] T. Pitassi and 
A. Urquhart, The complexity of the Haj6s calculus. In Proceedings of the 33rd IEEE Symposium on Foundations 
of Computer Science, pages 187-196, 1992. [Raz91] A. Razborov. Lower bounds for determinis­tic and nondeterministic 
branching programs. In Proceedings of the 8th FCT, Lecture Notes in Computer science, 529, pages 47 60, 
New York/Berlin, 1991. Springer-Verlag. [Rob65] J. A. Robinson. A machine-oriented logic based on the 
resolution principle. Journal of the ACM, 12(1):23-41, 1965. [Tse68] r. C. ~e~TI-IH. O CJIOXHOCT14 BbIBOAZL 
B MCWICJIeHkDI BbICKa3bIBaHMti. In A. O. Cnvrcem-io, editor, Hcc~edoea~r6x no xoncnapyxmuenoii AameNamuxe 
u Name&#38;­ amu~ecxoti ~oztme, II; 3anucxu uaywbtx ce~uuapoe JIOMH, m. 8, pages 234 259. HayKa, JIem.mrpaa, 
1968. Engl. translation: G. C. Tseitin, On the complexity of derivations in propositional calculus, in: 
Studies in math­ematics and mathematical logic, Part II, ed. A. O. Slissenko, pp. 115-125. [Urq87] A. 
Urquhart. Hard examples for resolution. Journal of the ACM, 34(1):209-219, 1987. [Weg87] I. Wegener. 
The complem ty of Boolean func­tions. Wiley-Teubner, 1987. Appendix: Rectangular view of Upper and Lower 
Bounds Example 1 (brute-force search proof of PHP#+l) We consecutively infer, for d = n,n 1,....1,0, 
all (n d+ 1) x d compact clauses, i.e., all rectangular clauses of the form RI.[all,Ill = n d+ 1. The 
case 1.. .. d= n is given as axioms (2), and if we already have all (n -d) x (d+ 1) compact clauses, 
then, given 1 with Ill = n-d+l, we infer RI,Idl from {RI\{i},[d+l] I j E ~} with a single application 
of (6). At the end (for d= O) we get the empty clause. This shows the bound s(n+l, n)~2n+l. (lo) Example 
2 (non-trivial proof of PHF ~ for large m [BuP96] ) We also have the following non-trivial re­cursion 
for s(m, n): s(m2,2n) < (m + 1) . s(m, n). (11) In order to see this, let P be the rectangular refuta­tion 
of -IPHP~ that has size s(m, n). Replacing every clause RIJ in P with R1,JUl~+l,,,,,Z~l (i.e., adding 
n new holes), we will get a rectangular proof of RI~l,{~+l,... ,Zn} 747 from axioms {Pil, p:z, . . ~Pi,zn} 
(i E [~]) that has the same size s(rn, n). By symmetry, we have similar s(rn, n)-sized proofs of every 
m x n rectangular clause. The dual transformation that can be done with the proof P is to replace every 
single pigeon with an rn­member pigeon family, i.e., replace every clause RIJ with RI X[~l,J. This gives 
us an s(m, n)-sized rectan­gular refutation of the set of clauses {~{l}x[m],{n+l,..,2n))h}} ~   ~.,~{na}x[na],{n+l,.., 
Combining this refutation with the s(m, n)-sized proofs of R{;} x[~],i~+l,.. .,zn} constructed above, 
we get the re­cursion (11). (10) and (11) imply (n+ l)(2~),2t n s () s (n+l) ) 2 +1 Substituting here 
n := (+1, / := 11% (*) J (m ~n3, logarithms are base 2), we have the bound s(m, n) ~ exp(O(logm + nlogn/ 
logm)) (12) (which follows from (10) for m < n3). It implies s(rn, n) < exp O ~=+ nlogn/logm (( )) (13) 
(for mz 2G just use the first 2= pigeons ignoring all others), and this is the best upper bound on the 
complexity of resolution proofs of PH Pnm (not necessarily rectangular!) known today. Example 3 (Halcen-Buss-Tur4n 
bound) In Exam­ple 1 we used rectangular clauses of perimeter (n+ 1)for upper bounds; now we show how 
to trace such clauses through an arbitmry resolution proof. Firstly we get rid of negations (a dual construction 
was previously used in [Bus87, BP96, BuP96, Juk96]). For this purpose we replace in a resolution refutation 
of YPHPn* every negative literal (=~ij ) by the set of literals {~ij~ Ij # j}. This results in a proof 
of the empty clause in the positive calculus that operates with positive clauses, has 1 x n and 2 x (n 
 1) rectangular clauses as axioms (the latter resulting from (1)), and has one inference rule Cl U {Pij} 
C2U{Pij 1.1 #j} c (14) 1 (C, uc, gc). J In fact, this calculus is easily seen to be equivalent to resolution 
proofs from =PHPnm appended with the set of clauses  {{=Pij,, =Pij,}li E [~]; ~1,~2 E [4, jl #~2}, 
748 but we will not need this in what follows. Suppose now that the premises in (14) are known to contain 
rectangular clauses of perimeter (n+ 1): RI,~, ~ Cl l-J{~ij}; RJ,J, ~ C2U {Pijl I j # j}. We wish to 
find a subclause of perimeter (n + 1) in the conclusion C. We may assume that i E 11 n 12 andj E J1\ 
Jz (other­wise C simply inherits one of R1l J1 , R12J2). But then C contains two rectangular clauses 
R(1,n12)\{i} ,JIUJ, and RI1uI,,J, nJ~ , an d the sum of their perimeters is equal to[11n121+ [Jl UJ21+111U 
121+ lJ1nJzl l= 1111+1121+IJ11+IJ21 1 = 2rI+l. Hence, one of them has perimeter at least (n+ 1). Summing 
up, in every line of a refutation in the posi­tive calculus we can trace a rectangular clause of perime­ter 
(n+l), until we get at the end the virtual (n+l) XO empty clause. Moreover ~ the above construction shows 
that III < 111I + 1121,where 11,12,1 correspond to the rectangular clauses in the premises and the conclusion 
of the rule (14), respectively. Since initially, at every axiom, we have 111 < 2, every such refutation 
should contain somewhere an (n/3) x (n/3) rectangular sub­clause ( bottleneck in the established terminology). 
Now it is easy to finish the proof of the Haken-Buss-TurAn exp (Q (n2/m) ) bound with the idea proposed 
in [BP96]. Namely, if we hit a refutation in the positive calculus with a random restriction assigning 
(n/2) ran­domly chosen pigeons to (n/2) randomly chosen holes, then every individual clause containing 
an (n/6)x (n/6) rectangular subclause gets killed to 1 with probabil­ity at least 1 exp ( Q (n2 /m)). 
Hence, in order for the restricted refutation to have an (n/6) x (n/6) bot­tleneck, the original refutation 
must contain at least exp (Cl (n2/rn) ) positive clauses. 
			
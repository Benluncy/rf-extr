
 Alpha-Algorithms for Incremental Planarity Testing * (Extended Abstract) J. A. La Poutr6 Department 
of Computer Science, Utrecht University, 3508 TB Utrecht, The Netherlands email: han @es.ruu.nl Abstract 
In this paper, a data structure is presented for incremental planarity testing. At any moment, the data 
structure can answer the following type of query: given two nodes in the graph, can an edge be inserted 
between these nodes such that planarity is preserved, while edges (preserving planarity) are inserted 
from time to time. Starting from an empty graph of n nodes, the data structure runs in O (n + rn. a(m, 
n) ) time, where m is the total number of queries and edge insertions. The data structure allows for 
insertions of nodes also (in the same time bounds, taking n as the final number of nodes), As a co-result, 
the problem of finding a maximal planar subgraph of a given (static) graph can be solved in O(n + e.a(e, 
n) ) time, where e is the number of edges in the graph.  Introduction Planarity testing is an important 
problem in the field of algorithms. Several algorithms have been developed for this problem. Hopcroft 
and Tarjan [16] showed that testing whether a (static) graph is planar can be performed in linear time. 
Besides its algorithmic relevance, planarity testing has relevance for e.g. VLSI design, layout problems 
and isomorphism of chemical structures, In this paper, we consider the problem of incremental planarity 
testing. It starts from an empty graph with n nodes and no edges, and the following operations may be 
performed: Test whether a new given edge can be inserted in the graph while preserving planarity, and 
insert a new given edge in the graph (provided that the graph remains planar), In generrd, dynamic graph 
algorithms have received increasing at­tention in recent years. Currently, algorithms and data structures 
 are known for various dynamic graph problems. Examples are occurring in [4, 5,7,8,9, 12, 14, 17,20,2 
1,22,29,30, 31], -The resenrch of the aurhor has berm mark possible by a fellowship of the Royaf Netherlands 
Academy of Sciences and Arts (KNAW), and the research was partiatly supported by the ESPRIT Basic Research 
Actions of the EC under contract no. 7141 (project ALCOM II). Permission to copy w thout fee all or 
part of this materfal is granted provided that the copies are not made or distributed for direet commercial 
advantage, the ACM copyright notice and the title of the publication and Its date appear, and notice 
is given that copying is by permission of the Association of Computing Machinery. To copy otherwise, 
or to republish, +equirea a fee and/or specific permission. STOC 94-5/94 Montreal, Quebec, Canada @ 1994 
ACM 0-89791 -663-8/94/0005..$3.50 In [4, 5], Di Battista and Tamassia presented the well-known algo­rithms 
for incremental planarity testing. The algorithms work in O((n + m). log n) time in total, where m is 
the number of queries and edge insertions, and n is the number of nodes. They are based on decomposing 
a graph into unconnected components, in which planarity testing is done by using st-orientations. Amongst 
others, their algorithms use dynamic trees [27] for maintaining and re­turning information in between 
tricomected components, balanced search trees to search inside triconnected components, while up­dates 
such as joining components are done by processing the small­est components. All these data structures 
and algorithms work in O(log n) (amortized) time per operation. In several related dynamic graph problems, 
obtaining an O(a(m, n) ) amortized time bound per operation instead of the O(log n) amortized time bound 
has been a significant problem. Examples are maintaining the 2/3-edge-and 2/3-vertex-connected components 
of graphs under edge insertions, or computing nearest common ancestors with linking [5, 12, 14, 20, 21, 
22, 29]. The static versions of these problems can all be solved in linear time (and O(1) time per query). 
This gives rise to the provoking ques­tion whether incremental planarity testing can be performed within 
O(a(m, n)) amortized time as well, especially since planarity test­ing appears to need much more structural 
information for answering queries. Thus, to improve the O(log n) time bound for incremental planarity 
testing, all the above mentioned representation, search, and joining problems need to be solved in less 
than O(log n) time. In [30], Westbrook presented new algorithms for this problem, al­though with a different 
type of time complexity (viz., probabilis­tic), and for blconnected graphs, These algorithms used a fast 
data structure for nca-like queries in a tree on which several modifi­cation operations can be performed 
(except for linking), and got around the search problem inside triconnected components by us­ing dynamic 
perfect Hash tables, thus rendering a running time of O((n + rn).cY(m, n)) for biconnected graphs with 
high probabil­ity. So, this still leaves the question whether incremental planarity testing can be performed 
in O(n + rn.a(m, n)) time. In this paper, we present algorithms and data structures for in­cremental 
planarity testing for general graphs that run in O (n + m. a (m, n)) time in total. In addition, the 
qt h query is performed within O(a (q, n)) worst-case time. Also, the edge between two nodes (if any) 
can be found in this O(a(q, n) ) time, and the data structure allows insertions of nodes also (in the 
same time bounds, taking n as the final number of nodes). Our approach is as follows. We develop a new 
combinatorial (struc­tural) characterization of triconnected planar graphs (or compo­nents), and introduce 
the notions of split pairs and minimum split pair queries. By means of this structural characterization, 
we develop new algorithms and data structures for incremental pla­narity testing inside triconnected 
graphs (and components), which are also fit for use in tricorrnected components inside general graphs 
(in which tricomected components are joined from time to time). We thus are able to e.g. insert edges 
and find the common face for two nodes in a triconnected graph in O(a(m, n) ) amortized time, Furthermore, 
new data structures are presented for incremental pla­narity testing in general graphs by using modifications 
of [21, 22,24] as underlying framework (to represent triconnected, bicormected, and connected components 
in general graphs, respectively, together with their interconnection structure), and by constricting 
a new top layer of data structures for maintaining planarity testing in­formation throughout this framework. 
These data structures are thus developed for all the above components. As a co-result, application of 
our algorithms improves on the exist­ing results for the problem of finding a maximal planar subgraph 
of a given (static) graph. This problem asks for a planar subgraph If of a given graph G that is maximal, 
i.e., there is no other planar subgraph of G that contains H as subgraph. This problem has been studied 
in [2, 3, 26]. The first algorithms for this problem can be found in [3, 26], which work in O(n.e) time. 
Recently, Cai, Han and Tarjan [2] presented an algorithm for this problem that works in O(e. log n) time. 
(This time bound can also be obtained by us­ing [4, 5].) By using our algorithms, the maximal planar 
subgraph problem can now be solved in O(n + e.ci(e, n)) time. In this extended abstract, we give a rough 
sketch of the data struc­tures and omit details and special cases; We mainly focus on the new combinatorics 
and data structures for triconnected graphs (and components). The extended abstract is organized as follows. 
Section 2 contains the preliminaries and considers triconnectivity and planarity testing. In Section 
3, we introduce the new combinatorial representation of tricormected planar graphs, Subsequently, in 
Section 4, a data structure for trees is described that will be used in the sequel. In Section 5, data 
structures and algorithms are presented for incre­mental planarity testing in triconnected graphs. Finally, 
Section 6 deals with biconnected and general graphs.  Preliminaries We use the standard terminology 
for graphs [15]. Two paths are called vertex disjoint if they do not have a common vertex except for 
possibly their end nodes, Two nodes x and y are lc-vertex­ connected iff there exist k different vertex-disjoint 
paths between z and y. A graph is k-vertex-comected if all its nodes are k-vertex­ connected. Instead 
of l-vertex-connected, 2-vertex-cormected, or 3-vertex-connected, we also speak of connected, bicormected, 
and triconnected. A connected or bicomected component of graph G is a subgraph of G induced by a maximal 
set of nodes that are connected or biconnected, respectively. A graph is planar if it can be drawn in 
the plane without crossing edges. For a tree T and two nodes L-C,y in T, PT-(z, y) is the simple path 
in T between x and y. If e is a new edge outside the tree (a nontree edge), then PT (e) is the tree path 
in T between the end nodes of e. Furthermore, we usually denote the father of a node z in a rooted tree 
T just by fx. If y is a real ancestor of x, then $OnT (y, z) denotes the son of y that is an ancestor 
of z. We usually abbreviate nearest common ancestor by nca. We often omit the subscript T if there is 
no ambiguity, We denote by x ~y that y is an ancestor of z. We denote by arz(x, i) the ancestor of z 
with distance i to the root (if it exists). A Z@ointer between two items denotes the pair of pointers 
between them in both directions. We usually let n be the number of nodes in the graph. Finally, in this 
paper, we will use dynamic microsets. This is a generalisation of the concept of microsets as presented 
in [ 13], that rdlow joining of microsets into new rnicrosets and queries within the c+bound [23, 22]. 
2.1 Cycle Trees In this section, we describe cycle trees and their constituents for splitting up biconnected 
graphs into tricomected components. (A related way can be found in e.g. [4].) Subsequently, we describe 
the use of such trees for maintaining triconnected components (also cf. [5, 22]), and we describe problems 
that arise for tubitrary graphs. We consider a biconnected graph G. G can be subdivided into so-called 
3vc-classes, cycles, and bars in a way as follows. A 3vc­class of nodes in G is a maximal set of at least 
three nodes that are triconnected. A pair of nodes {u, v} that is a cut pair (i.e., a cut set) of G, 
and such that u and v are triconnected, is called a 3vc-bar of G. Let {u, v} be a 3vc-bar of G. The deletion 
of u and w from G yields a number of comected components HI, .. , H~. For each H, =< V,, E, >, let Hl 
be the subgraph of G induced by the node set Vi U {u, v}, where H! now contains one (new) edge between 
u and v. This process can be continued until no 3vc-bars are left. A final graph in this process corresponds 
to a 3vc-class, or it is a simple cycle. We denote these final graphs by tricomected components. We call 
each pair of consecutive nodes on such a cycle a cycle bar, and we call a 3vc-bar or a cycle bar just 
a bar. Note that in such a triconnected component, an edge maybe auxiliary only and thus not exist in 
the original graph. We remark that a graph is planar iff all its triconnected components are planar [15], 
and that a triconnected component (graph) has a unique planar embedding up to the choice of the exterior 
face. We define the cycle tree of G similarly as follows. The nodes of the cycle tree are the cycles, 
classes, and bars as defined above (and represented by their names), that are linked by edges corresponding 
to the occurrences of bars in cycles or classes, We denote the tree by Cyc(G). For a detailed description, 
we refer to [22]. Suppose edge (x, Y) is inserted in G, where x and y are not uncon­ nected. Let PCV. 
(Z, y) be the tree path between the two subtrees of Cyc(G) containing z and y, respectively. Then all 
3vc-classes on P(z, y), all nodes in bars on P(z, y), and nodes z and y together form one new 3vc-class 
K resulting from the insertion. Moreover, each cycles occurring on P (z, y) is split into two new cycles, 
viz., according to the nodes in cycles that are in a bar on P(x, y) or that are z or y. We remark that 
the auxiliary edges may disappear when two tricormected components are joined. (I[n this abstract, we 
will not explicitly keep track of this.) The above structure of rooted cycle trees can be used to efficiently 
process insertions of edges in a biconnected ~aph, while queries are performed from time to time. However, 
in a general graph, connected components and bicomected components maybe joined arbitrarily, and therefore 
cycle trees for bicomected components must be linked from time to time, while queries can be performed 
at any time. In [22], this problem is solved within the optimal time complexity of O(rn. ~(m, n) ) (where 
m is the number of edge insertions and queries). It can also return the representatives of two nodes 
for a common triconnected component.  2.2 Planarity testing As shown in [4], an edge (z, y) (where 
z and y are not triconnected) may be inserted in a biconnected planar graph if and only if we have the 
following. Let PCVC(z, y) be the tree path in Cyc(G) as above. Then for each 3vc-class C on P(z, y), 
the nodes in CJ that are in the bars on P(z, y) or that are nodes z and y, must be in the same face. 
These nodes are called connection nodes. In [4], this is tested by maintaining additional information 
in Cyc(G), which can be thought of as having boolean values indicating whether a bar is in the same face 
as its grandfather in Cyc(G). Then, in general, the test consists of checking whether the connection 
nodes of the nca of PCV, (z, y) are in the same face, and similarly for z and the first bar on PCVC(z, 
~), and for y and the last baron Pc,, (x, y) ( local planarity tests inside a tricomected components), 
and whether the boolean values related to bar pairs on P(x, y) are true. On the other hand, as seen above, 
in case such an edge is actually inserted, this means that all the 3vc-classes need to be joined into 
a new one, and therefore the local planarity testing structures need to be joined into a new one for 
the new component. First, for triconnected components, we develop anew planarity test­ing mechanism and 
thus new planarity testing data structures. To allow the use in general graphs, the structures can be 
joined effi­ciently in any needed order, corresponding to joining triconnected components. Also, our 
data structures for planar graphs can find an edge given its end nodes, and maintain how many tricomected 
components share an auxiliary edge.  3 New Combinatorial Representation of Triconnected Planar Graphs 
A triconnected graph has a unique planar embedding up to the choice of the exterior face. Consider a 
triconnected graph G (without self­loops) and an embedding (i.e., we choose an exterior face). We only 
deal with triconnected graphs that are no cycles . In the sequel (until further notice), we will refer 
to the embedded graph just by G, The embedding defines an orientation (cyclic ordering) of the edges 
incident to a node. We develop a new approach of characterizing this graph. Let T be a spanning tree 
of G. Then T is an oriented tree defined by the graph too. Let NT be the set of non-tree edges, and let 
TT be the set of edges of T, where each tree edge is represented twice, viz, one for each side. The dual 
tree D is defined as follows (where our definition is slightly different from the previous definition 
in [7]). The nodes of tree D are the edges of NT and TT. The edges of TT are the leaves of D. Each edge 
has a link to the edge in its face that is closest to the exterior face, provided that we are not allowed 
to cross edges of T, where for each tree edge in T, its two representatives in TT are used for the two 
faces on the two sides of the edge. Now, each edge e that is not in TT represents the face in which it 
is contained and for which it is the father of all other edges in that face. We denote this face by F(e). 
The edges of the exterior face are sons of a dummy (-edge), called m (which maybe thought of as a quasi 
edge being a circle surrounding the point co in the plane). Each node of G has a representative for 
each face in which it is contained, and the representative has two pointers to the two edges of that 
face that are incident with it. Conversely, each edge has four pointers to the representatives for its 
end nodes in the two faces in which it is contained. We want to perform the query common ~ace(z, g): 
test whether z and y are in some common face, and return the name F of this face and the corresponding 
representatives of z and y for F (if these exist). For each edge and its father edge in D, we define 
the split pair as follows. Let e be an edge (where for tree edges, one of its representatives is taken) 
and let ~e be its father in D. Let PT (e, fe) be the intersection of the paths P~ (e) and &#38;(~e). 
Then &#38;(e, fe) is a tree path in T too, or it is empty. Then the split pair for e and fe (or just: 
e) is the pair (z, y), where z and y are the end nodes of path PT (e, fe). We call z and y the split 
nodes fore. If &#38;(e, fe) is the empty path, then this pair is denoted as 1. If z or y are in the face 
containing both e and fe, then it is called reachable (for e). If both are reachable, then the split 
pair is called reachable (for e). See Figure 1 for an example, where T is drawn heavy. The external 
face F for a node x is the unique face F containing x such that F = F(e) and z @ P~(e) (PT(co) is the 
empty path), if it exists. We prove the following lemmas. Lemma 3.1 For a nontree edge e, the nodes 
on PT (e, f e) are not contained in the face containing e and f e, except for possibly the end nodes 
of PT(e, f e).  Lemma 3.2 tit z ande be a node andan edge such that x E F(e). If x ~ PT (e), let el 
be an edge on PT (e) incident with x. Then z is a reachable split node for edge SOTID (e, el ). Otherwise, 
x @ PT (e), and F(e) is the external face of x. Lemma 3.3 For a tree path PT (x, y) in T, and for an 
edge e c NT, such that e is an ancestor in D of both sides of all the nodes on p~(~,y), we ~ve tkt [PT(e) 
n PT(Z,y)l <1. Computing the split pair for two given edges can be done as follows: If T is rooted, 
then the two split nodes can be obtained from nca queries in T on each of the 6 pairs of end nodes. 
We sketch the idea of how we make use of split pairs and extemrd faces to answer common face (z, y) 
queries for two nodes z and y. At this point, we simply suppose that for each edge e with a split pair 
(u, v) with u # W, e has a pointer to the representatives of u and w for the face containing both e and 
f e, if any. Each node u that has an external face has a pointer ezt (u) to its representative for that 
face. Let em and ev be the two edges in T that are incident with c and y, and that are on the tree path 
between x and y on T. Suppose z has an external face, say, F(eez ) for z, and y is in this face too. 
Then, by Lemma 3.2, either ezt (y) refers to F(eez ) too, or y is a reachable split node of son~ (eem, 
ey ) (for a proper side of ey ). The same holds with z and y interchanged. Otherwise, by Lemma 3.2, a 
common face for both z and y, say, J (e), must have z and y on PT (e). Consider the sides of the edges 
eo and ev that are on one side of path ~T(~, y) (e.g., by [6]). Let PI := nca(e~, ev ) in D, and the 
same for the other side of the path, defining ancestor pz. Now, e must be an ancestor of PI or p2, since 
these are the lowest edges stored in D that include a side of PT (z, y). We have the following. If e 
= pl, then .sorz(pI, em) in D has z as reachable split node (for the side of em corresponding to P1),andsimilarly 
for ey and y. Similarly fore = pz. See Figure 2. If all this is not the case (pl # e # pj), let plz be 
the nearest common ancestor of pI and pj in D. Edge e cannot be an ancestor of pl j, by Lemma 3.3. Similarly, 
e cannot be an ancestor of eez or eev. Let el be the one of eez, eey, and pM that is closest to PI in 
 D. For pl, let ql = son(son(el, PI ), pl ). For all e in between pl and el (but not equal to el ), ~T(e 
) must contain P2-(z, y) as a subpath. So, each spit pair (u, v) for an edge in between pl and ql satisfies 
that z and y are on PT (u, v). Similarly forpj. On the other hand, there is a son se of e in D that is 
ancestor of (the proper sides of) ec and ev, and that has (x, y) as reachable split pair. Hence, we can 
just search the reachable split pair related to an edge between some p and an ancestor pp of p in D, 
such that the pair lies on path PT (u, v) for every split pair (u, v) related to an edge between p and 
pp (in D), We call this pair the minimum (reachable) split pair. (See Figure 3.) This is formalized in 
Subsection 3.1, where query Get corresponds to searching this minimum reachable split pair. 3.1 Minimum 
Split Pair Queries We describe the essential properties that we use for searching and manipulating (reachable) 
split pairs. The situation as described above satisfies the below properties (and constraints), However, 
we will only apply these in a liberalized situation, which we will describe in the sequel and for which 
the below properties (and constraints) hold as well. At this point, however, the reader may think of 
D as just being the dual tree. Let L be the set of pairs of nodes on a tree T together with a (new) bottom 
element 1. We define a partial ordering given by: (a, b) < (c, d) iff a, b are on the tree path PT(c, 
d) in T, and {a, b} # {c, d}. For any two pairs in L, there exists an infi­mum, viz, in~((a, b), (c, 
d)) are the end nodes of the tree path PT ((a, b), (c, d)), where if this path is empty, we take 1. Now, 
we are given a rooted tree D. The sons of every node are ordered. We denote the father of a node x by 
f x. For each node x in D, v(x) is an element of L. (v(z) will correspond to the end nodes of an edge 
z in the considered planar graph.) We will write z instead of V(Z), however (if there is no confusion). 
For x c D, we define s(x) := inf(x, fz), and there is a boolean value b(z). (b(a) can be thought of as 
indicating whether split pair s(z) is reachable.) D satisfies the following constraint, which are fulfilled 
in our applications in the sequel, since D corresponds to (parts of) the dual tree of T in a triconnected 
planar graph. Firstly, we require expansion monotonicity, which means that for x, y, z c D, where =~y~z, 
wehavsk~(%~(iv, ~),%~(y, -)) = %~(z, z). We also require Uniqueness, which means that for every 1 G L\{l}, 
there is at most one z s.t. s(z) = 1 and b(z) = true, and that s(z) = 1 must give b(z) = false. The query 
and operation we want to perform is of the following type. Query Get(z, y) is described as follows: For 
twrt nodes x and y in D (y is ancestor of z), return the node z on the tree path between z and y s.t. 
s(z) = inf (z, y) and b(z) := true (z # y) if it exists. If it exists indeed, then inf (z, y) is called 
realizable for x and y. Operation Insert does the following: For a node z in D, replace a consecutive 
part P of its sons S by a new node y, where y has as its sons the nodes in P, The value y preserves the 
expansion monotonicity. We have the following constraints for operation Insert, 1. For z E P, SOM(Z) 
< s(z) < Z, and b(z) # b~M(z) = false ~ s(z) # sO1~(z). There are at most two nodes z E P, say Z1 and 
z2, such that b(z) # IJOU(Z) = tr-uevs(z) # sold(z) # J-. 2. For z c S\P, sOZ~(z) = s(z) and b(z) < 
bOld(.z). There are at most two nodes z ~ S\P, say Z3 and Z4 such that b(z) # bol~(z).   4 Monotone 
Dynamic Trees In this section, we describe some underlying features of data struc­tures we will construct 
to handle various operations and queries on trees. The considered trees may be rooted. The nodes adjacent 
to a node (its neighbours ) may be (cyclically) ordered, and the trees may be partitioned into different 
edge-disjoint subtrees, so-called constituent subtrees. The trees allow the following queries for two 
nodes z and y in a tree: 1. The computation of the nearest common ancestor ( nca ) for freely chosen 
root r; 2. The compu­tation of the node and edge adjacent to y that is on the path between x and y ( 
adjacent nca ); 3. The computation of the node z that is closest to c and that is in the same constituent 
tree as y. The following creation operations are supported: creating a tree consisting of one node, 
and adding a new leaf y to a node z (where for ordered trees, its predecessor and successor neigh­bors 
are given), which is called AddLeaf. In addition, we have the mutation operations Link, GlueTrees, Split 
Sons, and JoinSubtrees, which are given as follows. Operation Link links two trees via an arbitrary new 
edge. Operation SplitSons is given by: For a node z for which the neighbors are cyclically ordered, replace 
a consecutive part P of its neighbors S by a new node y, where y has as its neighbors the nodes in S 
where S\P is replaced by node z, Operation GlueTrees is given as follows: For two trees T and T , two 
nodes tl,t2in T, ancI two nodes t;, tj in T , do the following. If t1and t2or t;andl t j are adjacent, 
then delete (one o~ the edge(s) in between them. Otherwise, delete some (possibly specified) edge e on 
the path from t1to t2inT or from t;to t~in T in the smallest of T and T , and construct a new tree from 
these trees by identif ying node t 1 and tjas the same node, and similarly for tjand t:. Finally, operation 
.70inSubtrees replaces two adjacent constituent subtrees by the union of them. We will consider the following 
two combinations of specific oper­ations: operations Link and GlueTrees, and operations Link, Split Sons, 
and JoinSubtrees. W.r.t. constituent subtrees, SplitSons is not allowed to separate the edges of a constituent 
subtree into two (new) distinct constituent subtrees. Former results on trees occur in [ 1 2], where 
linking and nca are considered, and in [30], where GlueTrees and linking are not considered. However, 
we need these operations for algorithms for general graphs, and we use the virtual trees described below 
in Section 5 as well. 4.1 Representation A tree T is represented as a rooted tree (with root to),and 
it is represented by a virtual tree T as follows. The virtual tree is a kind of compressed tree (like 
those occurring in [12, 27, 30]). Each node x c T has its own representative rz in T , and it has a new 
companion node c(z) in T . Companion nodes of distinct nodes need not to be distinct, but all the nodes 
with the same companion node u must form a path, called companion path p(u), in the tree T, with one 
of its end nodes, called top, being the node closest to the root. The root of T is c(to ). Each other 
node is the son of its companion node, each companion node u is the son of the father of top of p(u), 
and the sons of u are ordered according to their order in path p(u). (Note that a node has several companion 
nodes as sons.) A compressed ancestor y of x is an ancestor of z in T such that c(y) is the grandfather 
of c(z) in T . The weight of a subtree of T rooted at z, denoted by Tz, is at most ~ the weight of the 
subtree rooted at some compressed ancestor of z (except for z with c(z) = C(to)). The depth of T is thus 
O(log n). For each companion node co, there is a BBIIx] tree: a weight­balanced (search) tree [25] for 
the nodes on its companion path. Each node z 6 T with c(z) = co has a new representative r z for this 
tree. Updates are done by partially rebuilding subtrees that go out of balance. The BB[a] tree (also) 
maintains the weights of subtrees of T like in [27]. 4.2 Algorithms operating on virtual trees We only 
sketch operations AddLea f and Split Sons. Operation AddLeaf just links c(y) to rz, and s-y to c(y), 
and then updates T by partial rebuilding if the weight constraints are violated. Operation Split Sons 
works as follows. Compute the smallest of the two subtrees of T that we want to result from the operation, 
i.e., TY rooted at y, and T=. ~ rooted at x but without subtree TV by simultaneously enumerating all 
subtrees rooted at nodes in P and at nodes in S\P. (This is done via the virtual trees.) If TV is the 
smallest, then remove all nodes of P and their descendants from T, and build TV at node x by AddLeaf 
operations. Otherwise, if Tmiv is the smallest, then let y replace z in T , viz. ry := m, C(Y) := c(z), 
and remove the nodes in T.\V. Then insefl z as the father of y by linking a new representative m as a 
son to c(y) in T (following ry). In the BB[cz] tree for c(z), insert a new leafr y as the predecessor 
leaf of r z. Then build the remainder of TZ\ ~ at node x by means of the Add Lea f operation. Thus, we 
perform the operations on virtual trees by adding leaves, inserting new fathers, and removing complete 
subtrees. W.r.t. the AddLeaf operations, a virtual subtree is only rebuilt after a con­stant fraction 
of its nodes in T. is added. Removal of (reprc,senta­tives of) nodes is postponed and done by marking, 
until at least half the number of nodes is marked. Each node in T has an array of size O (log n), where, 
among others, the entries contain pointers to the nodes on its root path. For a companion path, there 
is a (simple) Union-Find structure w.r.t. constituent subtrees. A nearest common ancestor query in T 
corresponds to an nca-query in T , where if this is a companion node, the corresponding sons of it that 
are ancestors of the query nodes are taken, and the rightmost of it is the nca, by using [6]. By using 
[12] for nca-queries while adding leaves in O(1) time (with O(1) query time), we obtain the following 
lemma for later use, (However, since our conversion has a slack of a factor log3 n, we actually have 
a somewhat simpler algorithm for this,) Lemma 4.1 A sequence of creation operations together with Link 
and GlueTrees operations or Link, Split Sons, and JoinSubtrees operations, can be pe~ormed in 0(log3 
n) amor­tized time per operation, while queries can be pe~ormed in O(1) time. 4.3 Conversion into appropriate 
contraction trees We use clustering techniques to reduce the factor 0(log3 n) to a(m, n). We sketch how 
to reduce a tree T to a reduced tree T. such that T. contains 0(&#38;) nodes. We will choose csize(n) 
= @(log3 n). The conversion of a tree T is as follows. A tree T (or actually its ver­tex set) is partitioned 
into subtrees (clusters) of size O(csize(n)). Each subtree is contracted to a node. The globat tree T= 
is the con­traction tree, where the leaves are omitted. T= has size 0( --&#38;&#38; ). Inside each such 
a subtree, we apply the same strategy Iocally again (giving clusters of size O(csize(csize(n) ))), until 
we have 3 levels of clusters. At the lowest level, we just use dynamic microsets to perform the operation, 
by encoding the subtrees [23]. The oper­ations are performed as in Subsection 4.2, at the highest possible 
level, where if e.g. trees of different levels are joined, clusters may be extended and then split if 
they become too large. (Thus, tree TC is represented by a virtual tree T:.) For later use, we obtain 
the following lemma, (We also obtain a similar result for Link, SplitSons, and JoinSubtrees.) Lemma 4.2 
A sequence of creation operations together with Link and GlueTrees operations and m queries can be pe~ormed 
in O(n + m.a(m, n)) time,  5 Data Structure for Common-Face Queries In this section, we present a data 
structure for computing common­face queries in a triconnected graph G =< V, E > (while edges may be inserted 
as well). Again, we start from a spanning tree T of G and use the dual tree D (in this description). 
We perform a traversal Trav (or just: tour) of the tree, in which each edge and node occurs each time 
it is visited by the traversal, The traversal consists of tour representatives of edges (two per edge) 
and nodes (at least two per node), one for each occurrence in the tour. The sequence Trav is partitioned 
into O ([ El /csize (n) ) node(-representative) disjoint subsequences ( clusters ) of size O(csize(n)). 
We will choose csize(n) to be 0(log3 n) later on. For node z in the embedding, the (graph-) edges incident 
to z and the face representatives for z are uniquely cyclically ordered; thus, to each non-tree edge 
of the graph, we can relate a tour representative for each of its end nodes, determined by the order 
of the incident edges of each of these nodes. An edge in G is called interconnection edge if it is incident 
with two different clusters. We contract each cluster into a new node, and replace each interconnection 
edge by its contraction edge between the corresponding contraction nodes. We replace multiple edges by 
single edges. We show that there are 0(1171 /csize(n)) such edges. For each such contraction edge e, 
let packet(e), called edge packet, denote all the edges that are contracted to e. Let outer(e) denote 
the pair of edges in packet(e) that together with the edges in the cluster enclose all the edges of packet(e) 
in the embedding. We call the edges the outermost edges. We now divide each cluster into tour packzts 
that are maximal sub­sequences of Trav as follows. For an edge packet packet(e) for cluster C, let ut 
and ut be the two tour representatives related to the end nodes of the edges in outer(e) that occur in 
C. Then the corresponding tour packet in C is the subsequence of the cluster in between (and including) 
ut and vt. These packets are called closed tour pac,kzts. An edge packet, its two corresponding closed 
tour packets, and the edges in G for which both the two tour represen­tatives of their end nodes are 
in one of these tour packets, is called a closed packet, The remaining tour packets of edges and nodes 
in a cluster are remaining maximal subsequences inside a cluster that contain at least one edge (where 
the end nodes of edges are included in these packets), These packets are called~ree tour packets, A free 
tour packet together with the edges in G for which the two tour representatives of their end nodes are 
in the tour packet, is called a free packet. See Figure 4 for an example, where packets are shaded and 
T is drawn heavy. The faces that are enclosed by edges of one packet are called local faces. The other 
faces are called global faces. The external face of the graph must be global. For free packet p, outer(p) 
denotes its ( part of a ) global face, i.e., the global face that contains an edge of p (for a tree edge, 
this must be an edge representative of p). We call this the outermost face of packet p. We may interpret 
outer (p) as a local face as well, viz., when considered w.r.t. p. We define multiple nodes (m-nodes) 
as nodes that occur in at least three tour packets. We thus have 0( [.EI /csize(n) ) tour packets (including 
multiple occumences) and m-nodes. (This upper bound will be invariant under our algorithms.) 5.1 Description 
of the Structure For each edge packet packet (e), we have a representative e in it. Wewillhenceforth 
identify thispacket bypacket(e ). Callthis set of representative edges EE. Wedistinguish three kinds 
ofdata structures. Firstly, wehave the packets that form local data structures on their own. These deal 
with the local faces inside packets. In the second place, we have data structures for all the remaining 
faces, viz., the global faces. Finally, wehave an overall data structure that deals with the so­called 
reduced dual tree, which deals only with the representative edges. Afurther description isgiven in the 
sequel; we omit many detailed implementations. For packets, we have the following, among others. Each 
node has a packet representative for each packet in which it is contained. For each free packet, the 
outermost face F of p has a local representative FP. FP has an additional list of the representatives 
of all the m­nodes in it, in the order of occurrence. Inside packets, split pairs are defined and computed 
locally, and only representatives the 10CSS1are taken into account, For global faces, we implement the 
father relation, split pairs, and ezt pointers (for external faces) w.r.t D as far as outermost edges 
or m-nodes are involved, This is done as follows, For each m-node x, a pointer ext (x ) is stored to 
the representative for its external face, if any. If m-node z is in a global face F(e), son(e, em) contains 
a split-node pointer to the representative of z for F(e), for edges em on P(e) incident with z. Each 
outermost edge e with father edge ~e in D that is in a common global face has a pointer to ~e and pointers 
to split pair in~(e, je) if this split pair is reachable in face F(fe). The name of a global face has 
a list consisting of the outermost edges, the (local) outermost face representatives, and the face representatives 
of the end nodes of outermost edges, in the proper order. This is called its global face list. A global 
face also has a bipointer to its edge e such that F = F(e). The overall data structure is based on the 
so-called reduced dual tree D,ed consisting of the edges of EE only. The tree can be derived from the 
dual tree D for G as follows: For each nontree edge in G that is not in EE, we contract it with its father 
in the dual tree. For DT,d, we will make use of a virtual tree D~,d as detined before. Inside Dred, we 
define split pairs in term of the fathers in D,ed: for edges e, h c EE, where h is the father of e in 
Dred, s,ed (e) = inf(e, h). We also have a relaxed definition of b(e), viz., b(e) = true, if split pair 
inj(e, h) is realizable (instead of reachable) for e and h. The b(e) -values satisfy the uniqueness constraints 
(Subsection 3.1). (Note that b(e) may be true if its split pair inf(e, b) is not realizable.) The face 
representatives for a node z in a face F can be obtained in O(1) time via any of the two edges in F that 
are incident with z. The packet representative of a node z for some packet p can be obtained from any 
face representative that is inside the packet, or by any other node y in p, by computing the edge incident 
to x on PT(z, y). 5.1.1 Queries and Edge Insertions We sketch the approach for common-face queries and 
edge inser­tions. A query for the nodes z and y now consists of the following steps, based on the observations 
of Section 3. We perform the nca and adjacent nca queries in the (not implemented dual tree) D by making 
use of such queries on D.,d (for appropriate represent­ing edges in EE) and inside packets, and by the 
pointers related to outermost edges w.r.t packets and global faces. Then the split-pair queries are performed 
in Drcd, possibly returning a candidate pair of representing edges, and at most 6 local split pair queries 
are performed inside packets. We omit the details here. If an edge e = (z, y) is inserted in the graph, 
then the data structure is updated as follows. We are given the representatives z,, y, for x, y of the 
face F in which the edges are inserted (and thus the face name F can be obtained too). If F is locrd 
or both representatives are in the same outermost face, then update the structures locally inside the 
corresponding packet. Otherwise, the representing edge g of the face is obtained, i.e., F = F(g). Split 
the face in two parts (using the corresponding face list by processing only the smallest resulting part 
completely), while adding new representatives. First it is checked whether e can be joined into an existing 
edge packet together with the free packets in between them, if any (viz., w.r.t. the constraint that 
closed tour packets are inside clusters). This is done by computing candidate outermost edge and outermost 
faces, respectively. If so, then this joining is performed. Otherwise, if edge e cannot be joined in 
an edge packet, then it forms a new edge packet on its own, and the split pair for the proper outermost 
edges and representing edges are updated, together with those for edges involving m-nodes. These edges 
are obtained by traversing the face list of F(e) starting from both sides of e, while using Constraint 
1 in Subsection 3.1, which can be checked by nca queries in T. For handling the insertion of e into EE, 
we refer to Subsection 5.3.  5.2 Data Structure for Packets Each packet, free or closed, consists of 
the edges in it, and of all the face representatives of their end nodes, and we recurrently have a local 
data structure inside packets in a way similar as above, taking the partialness of packets into account, 
however (a packet does not represent a tricormected graph, nor its complete outermost face), For a closed 
packet packet(e), we take as its spanning tree the two subtrees TI and T2 corresponding to the two closed 
tour packets, together with the representing edge e connecting them. We have two local split pair data 
structures that actually consists of two parts, viz., corresponding to the two dual (sub)trees rooted 
at the outermost edges of the packet. On the two partial tours of the subtrees TI, T2, and e as defined 
by the two closed tour packets and the edge e, tour packets are defined at a lower level. For a free 
packet, the local data structure for the split pair queries consists of the subtrees of the dual tree 
with as roots the edges in its outermost face, and tour packets are defined at a lower level.  5.3 Data 
Structure for Minimum Split Pair Queries in the Reduced Dual Tlee We sketch the data structure for split 
pair queries in the reduced dual tree, while graph-edges are inserted as well (we omit details and special 
cases), We represent the reduced dual tree D,ed by a virtual tree D~ed, However, for each node z in DTed, 
node TX in D~ed has the value v(rm) with v(rz) = v(z) or w(m) = v(u), where u is an ancestor of x in 
D,ed such that c(z) = c(u). For each companion path in D,ed, we store in the BB[a] tree additional information 
to be able to compute queries inside companion paths. Each node z has its own representative r z for 
the BB[a] tree B in which it is contained, with u(T Z) = v(z) and ~,.d(~ ~) = .$red(X) in ~. Each node 
rx in D~ed has an array of size O(log n), where for an entry i, and ry := an(x, i) with y a node in Dv.d, 
it contains a pointer to a node rz on the path from rz to ry in D~cd, such that the following holds (if 
z and the below z exist; arbitrary otherwise): There is a node z between z and y in D,=d (z # y), such 
that %.ed(z ) = in~(v(rz), v(ry)) and b(z ) = true, and either (l:) r.z is a grandson of rz, or (2:) 
c(.z) = c(z ) and z is not a top (if z # z, while z is a top if z = z). The type of query we thus implement 
is then returning the node z for the nodes z and y as described above. In a BB[ct] tree B related to 
a companion node, each node@ in B contains the infimum of the real s,,~ -values in its subtree (denoted 
by in(/3)), and it contains a pointer to a leaf z that contains that value as an .9,&#38;value with b(z) 
= true, if any (in which case ~ is called eligible), except for nodes@ on the rightmost and the leftmost 
paths from the root. Each leaf z E B contains an array ln~Right of size O(log n) such that each entry 
i contains a pointer to that right son ,6 of the nodes an(z, j) (j > i) that has the minimum in(,6)-value 
(if it exists), and that is eligible, while it is not a node an(z, j) itself. Similarly, there is such 
an array lnfLe~t for the left sons. We can thus answer minimum split pair queries between leaves of B 
(by first performing an nca-query; also cf. Section 4). If we have to rebuild a subtree of D~,d, then 
we also recompute all the values in the arrays of the nodes involved, For the SplitSons operation (where 
for the sons S of node z, the sons in P are replaced by y and put below y), we have two cases as described 
in Section 4. For the smallest of the subtrees (Dred)v and (@cd )Zig, say SD, we do the above recomputation, 
where for z E SD, V(TZ) = v(#z) = v(z). Note that if (D~ed)m\,v is the smallest, then node p = rx now 
stands for the newly inserted node y instead of for the father z of y, and, hence, afterwards, v(ry) 
= v(p), which equals the old value v(rz). Inserting a node y in a BB[cI] tree means that all the O(log 
n) ancestors in this tree must be updated. If r z had a predecessor r z in the BB[a] tree, then we do 
this by replacing the node r z in the BB[cY] tree by the new subtree consisting of a new node with r 
z as left son and r y as right son. The infimums of all the subtrees remain unchanged (because infimums 
are taken over Sred-V~UeS). Only the .%&#38;values for z and y must be updated, together with the InjRight-and 
ln~Le~t-arrays for r y and r z, and the pointers corresponding to the infimum of the subtrees containing 
y and z may need to be changed from z to y. If r z did not have predecessor, then r y is just added to 
the tree on the left side, with a similar construction with its successor as in the previous case. As 
mentioned before, we rebalance BB[cv] trees by rebuilding appropriate subtrees. When we do this, the 
corresponding arrays lnfR.ight and InfJeft are recomputed too. A split-pair query for nodes x and y in 
D,.d now consists of the following parts (omitting many details and special cases). First, the ancestors 
rsl, rsz, and rs3 of rx in Dyed are obtained, sat­isfying that c(s1) = c(y), rsz is a grandson of rsl, 
and rss is the grandfather of rz (if they exist). Then a query from rx up to rsz is performed in D~ed, 
while by the BB[a] trees for c(x), C(SZ), and c(y), queries between x and S3, between sz and s1, and 
between S1 and y are performed, respectively (where the first two queries consist of a query with the 
rightmost node in the BB[cz] tree, combined with the values S3 or S1, respectively). Then the infimum 
i of the answers is computed. If i (also) occurs inside one of the above BB[a] trees, then the proper 
candidate node is obtained inside this tree, by means of pointers stored in the local arrays. If z (also) 
occurs between rz and rsz, the node z in D~,d is obtained from the array stored with rz. Then, by the 
BB [CY] tree for c(z), the ancestor (and candidate) z is computed satisfying Sred(z ) = inf(v(rz), v(ru)) 
(if any), where PM is the grandfather of rz. Similarly, for the grandson rv of rz that is an ancestor 
of z, candidate z is computed by the BB[cz] tree for c(v), satisfying Sred(z ) = inj(v(rv), v(rz)) (if 
any). From all these candidates, the one with the proper reachable split pair is obtained (if it exists). 
 5.4 The Layered Structure 3vc-class may occur in several clusters). For a detailed description of cluster 
partitions and cluster trees, we refer to [22], For the partition size of the clusters, we choose CSiZe(TZ) 
= 0(log3 n). Inside the clusters, we use the same kind of parti­tioning again, in subclusters of size 
O(csize(csize(n) ) ) (hence, 0( (log log n)3 )), and we use the same structure. The basic clusters of 
size O(csi.ze(csize( n))) are implemented as dynamic microsets [23, 22], and the above operations are 
computed by means of lookups in precomputed tables. We prove the following theorem. Theorem 5.1 For a 
triconnected graph G of n nodes, a sequence of m queries and edge insertions can be perjormed in O (n 
+ m, a (m, n)) time, while the data structure can be initialised in O(n) time.  6 Biconnected and General 
Graphs In this section, we give the main ideas for planarity testing in bi­connected and general graphs. 
(We omit details and special cases.) 6.1 Joining Planarity Structures of Several Ikiconnected Components 
When edges are inserted, several triconnected components may be joined into one new triconnected component; 
such components correspond to a path in a cycle tree. For joining triconnected components of size Q(csize(n)), 
we do the following. Let C~arge be the largest component. For each component C # C1.rg., the face FC 
containing the connection nodes is made global, and the reduced dual tree is recomputed with Fc as external 
face (actually, several distinct subtrees of it are recomputed). Then C is embedded in C~arge, where 
faces are joined. The spanning trees of C and Clarg. are glued together with the GlueTrees operation, 
where the disappearing tree edge may be specified when it is an auxiliary edge that disappears from the 
component. Then the reduced dual subtrees of the components C # C~a.,~ are attached to the reduced dual 
tree of Cl~,g~. (The number of steps for this is linear in the number of packets in the smrdlest component(s).) 
In case some component is of smaller level than Cta,g., then this component is added by inserting it 
into two packets of the current Ct..g., or otherwise, if the packets become too big, by adding it as 
a new cluster in Cla,ge. We omit the details. 6.2 Planarity Information in between Tricon­nected Components 
For a general graph, we use the decomposition data structure of [22] to handle triconnected components. 
The data structure parti­tions each biconnected component into clusters, that together with additional 
representatives for certain tricomected components are linked to each other such that a tree is formed 
( cluster tree ), A triconnected component (3vc-class) may occur in several clusters, that together induce 
a subtree in this cluster tree. Thus, a cycle tree (see Subsection 2.1) is partitioned into clusters 
too (where a We modify this structure s.t. the cluster trees are implemented as real trees with fixed 
father relations that can only change in case such trees are linked. The fixed father relation in a cluster 
tree CT is then such that all edges that are related to the same 3vc-bar have the same cluster C as father 
(which is obtained by an extension of the set of clusters with auxiliary clusters), where the 3vc-bar 
occurs in C, or where the 3vc-class containing the 3vc-bar and separating the bar from the root of the 
formally underlying cycle tree [22] occurs in C. Furthermore, all the clusters in which some 3vc-class 
occurs forma subtree of CT. The joining of triconnected components is represented by means of constituent 
subtrees (see Section 4). The method of using boolean values related to bars as described in Subsection 
2.2 is replaced by using pass-bits on the edges in between clusters, as follows. The outgoing edge e 
of a cluster C is related to either the 3vc-bar or the 3vc-class that occurs in C and that is closest 
to the root of the underlying cycle tree. For e, top(e) is this 3vc-bar or it is the father 3vc-bar of 
this 3vc-class in the cycle tree. Then the pass-bit for the edge e ending in cluster C, where C has outgoing 
ecIge f, is true iff there exists a planar embedding such that all the nodes of top(e) and top(f) are 
in a common face. (This corresponds to local planarity testing information in between the nodes in the 
3vc-bars top(e) and top(j).) The subtrees of CT consisting only of edges with a true pass-bit form disjoint 
sets of edges with an indirectly addressed pointer to the corresponding root of the subtree. Inside clusters, 
similar information is maintained recurrently, and thus the pass bits outside the cluster are maintained, 
as follows, (Since rooted cluster trees may be redirected, pass bits may need to be be recomputed and 
maintained differently afterwards.) Inside a cluster, there is a finer cluster partition and rooted cluster 
tree, in a recurrent way. We maintain pass bits outside cluster C by this local cluster tree inside C. 
To this end, 3vc-bars and 3vc-classes corresponding to edges incident with C are marked inside cluster 
C, where the one corresponding to the father edge of C is made a reference . In the local cluster tree, 
the planarity information between the reference and the marked 3vc-bars and 3vc-classes is maintained 
by the local cluster tree and by severrd triconnected components (linear to the number of marked items) 
occurring in it. Since the reference may change, this maintenance is robust: changing the reference is 
done in a number of steps proportional to the number of marked items in the cluster only. To this end, 
we also maintain local pass-bit information between marked items and the local root of the local cluster 
tree. Furthermore, we maintain for a collection of distinguished bars (and nodes) in several tricomected 
components whether these are in the same face as some specific distinguished bar (or node). (Again, when 
triconnected components are joined, distinctions may be adapted.) Then, a query whether an edge (x, y) 
can be inserted between two nodes is typically done in the following way, First, the appropriate triconnected 
components for these nodes (viz., closest to each other in the corresponding cycle tree) are obtained 
and the cut pairs (3vc­bars) in each of them that disconnect z and y are obtained. For these 3vc-bars, 
the two appropriate clusters are obtained, and it is tested whether (a constituent subtree incident with) 
the nearest common ancestor of them in CT is reachable via true pdss-bits (ignoring the last bits). Furthermore, 
local planarity queries are performed in 0(1) appropriate components and clusters, containing the above 
bars and nodes, being (in the constituent subtree incident with) the nca, or being adjacent to these. 
If an edge in inserted indeed, then all the tricomected components that are joined are obtained (together 
with their corresponding cut pairs) and the planarity structures are joined accordingly.  6.3 Planarity 
Information in between Bicon­nected Components For generaf graphs, we maintain the bicomected components 
of the graph by means of clusters again. This is a variation of the structure presented in [21, 24] in 
terms of a RAM solution and makes use of dynamic microsets [23]. We need to maintain additional information 
w.r.t. these clusters, which is done in a way similar as for biconnected graphs. We omit a more detailed 
description, 6.4 General Graphs We use a similar recurrent approach as in Subsection 5.4, (we have three 
levels of clusters, where the basic clusters are encoded into dynamic microsets [23]), but now some clusters 
maybe exceptional w.r.t. their size constraints. Viz., clusters representing a single cycle in the cycle 
tree (possibly with some 3vc-classes directly attached to it) can be of bigger size to fit into one cluster. 
When such a cycle is split, then the corresponding cluster is split too, This is done in the way of Lemma 
4.1 (allowing splitting of nodes and joining of constituent subtrees). We thus obtain the main theorem. 
Theorem 6.1 Starting from an empty graph G of n nodes and no edges, a sequence of m queries and edge 
insertions can be performed in O(n + m.a(m, n)) total time, whereas the qth query is perjiormed in O(a(q, 
n)) time, and while the data structure can be initialised in O(n) time. The data structure allow insertions 
of nodes too, with the same time complexity.  7 Conclusion We have shown that incremental planarity 
testing can be performed in O(n + m.~(m, n)) time, where n is the number of nodes, and m is the number 
of queries and insertions. As remarked in [30], any algorithm for incremental planarity testing that 
maintains the tricormected components of a graph runs in Q(n+m.a(m, n) ) time, which follows by [11, 
19]. This gives rise to the conjecture that the time complexity obtained in this paper is optimal for 
incremental planarity testing.  References [1] A.V. Aho, J.E. Hopcroft and J.D. Unman, The design and 
analy­sis of computer algorithms, Addkon-Wesley Publ. Comp., Readkrg, Massachusetts,1974. [2] J. Cai, 
X. Hao and R.E. Tarjan, An O(m log n)-Time Algorithm for the Maximaf Planar Subgraph Problem, SIAM J. 
Comput., 1993. [3] T. Chiba, 1. Nishicka andd I. Shirrdcawa, An afgorithm for maximrd planarization of 
graphs, Proc. 1979 IEEE Int. Symp. on Circuits and Systems, 1979, pp. 649-652. [4] G. Di Battista and 
R. Tamassi&#38; Incremental Planarity Testing, Proc. 30th Aan. Symp. on Found. of Comp. Sci. (FOCS) 1989,436-441. 
[5] G. D1 Battista and R. Tamassi&#38; On-Line Graph Algorithms with SPQR-Trees, Proc. 17th I@. Colloq. 
on AutomatA Languages, and Programming (ICALP) 1990,598-611. [6] P. Dietz and D.D. Sleator, Two algorithms 
for maintaining order in a list, FTOC. 19th Ann. ACM Symp. on Theory of Comput. (STOC) 1987,365-372. 
[7] D. Eppstein, G.F. Italkmo, R. Tamassi~ R.E. Tarjan, J. Westbrook and M. Yung, Maintenance of a Minimum 
Spanning Forest in a Dy­namic Planar Graph, Proc. 1st Ann. ACM-SIAM Symp. on Discrete Algorithms (SODA) 
1990, 1-11. [8] D. Eppstein, Z. Galil, G.F. Itatiano, amd T.H. Spencer, Separator Breed Sparsification 
for Dynamic Pkumr Graph Problems, Proc. 25t h Am. ACM Symp. on Theory of Comput. (STOC) 1993. [9] G.N. 
Fredrickson, Data structures for on-line updating of minimum spanning trees, with applications, SIAM 
J, Computing 14 (1985), pp.781-798. [10] G.N. Fredrickson, Ambivalent data structures for dynamic 2-edge­connectivity 
and k smatlest spanning trees, Proc, 32 d Ann. Symp. on Found. of Comp. Sci. (FOCS) 1991, 632-641. [11] 
M.L. Fredman and M.E. Saks, The Cell-Probe Complexity of Dy­namic Data Structures, Proc. 2It k Ann. ACM 
Symp. on Theory of Comput. (STOC) 1989,345-354 [12] H.N. Gabow, Data Structures for Weighted Matching 
and Nearest Common Ancestors with Linking, Proc. I t Ann. ACM-SIAM Symp. on Discrete Algorithms (SODA) 
1990,434-443. [13] H,N. Gabow and R.E. Tarjan, A Linear Time Algorithm for a Special Case of Disjobrt 
Set Union, J. Comput. Syst. Sci. 30 (1985), 209-221. [14] Z. Gahl and G.F. Itahano, Maintaining the 3-Edge-Connected 
Com­ponents of a Graph On-Line, SIAM J. Comput. 22 (1993) 11-28. [15] F. Harary, Graph Theory, Addison-Wesley 
Publishing Compaoy, Reading, Massachusetts,1969. [16] J. Hopcroft and R.E. Tarjan, Efficient planarity 
testing, J. ACM 21 (1974), pp. 549-568. [17] A. Kamevsky,G. D1Battista, R. Tamassir+and J. Chen, On-line 
Main­temmce of the Four-Connected Components of a Graph, Proc. 32wd AM. Symp. on Found. of Comp. Sci. 
(FOCS) 1991,793-801. [18] J.A. La Poutr&#38;, New Techniques for the Union-Find Problem, Proc. 1st Ann. 
ACM-SIAM Symp. on Discrete Algorithms (SODA) 1990, 54-63. [19] J.A. La Poutr6, Lower Bounds for the Union-Find 
and the Split-Find Problem ou Pointer Machines, Proc. 22t h Ann. ACM Symp. on Theory of Comput. (STOC) 
1990, 34-44. To appear in: J. Comput. Syst. Sci.. [20] J.A. La Poutr6, J. van Leeuwen and M.H. Overmars, 
Maintenance of 2-and 3-Edge-Connected Components of Graphs I, Discrete Mathe­matics 114 (1993) 329-359 
(Special 1ss.on the French-Israeli Conf. on Combmatorics and Algorithms 1988). [21] J.A. La Poutr6, Maintenance 
of 2-and 3-connected components of graphs, Part 11:2-and 3-edge-connected components and 2-vertex­comectcd 
components, Tech. Rep. RUU-CS-90-27, Utrecht Univer­sity. [22] J.A. La Poutr6, Maintenance of Tricomected 
Components of Graphs, Proc. 19*h Int. Colloq. on Automata, Languages, and programming (ICALP) (1992) 
354-365. [23] J.A. La Porrtr6, Dymamic Microsets for RAMs, Tech. Rep. RUU-CS­93-22, Utrecht University, 
1993. [24] J.A. La Poutr&#38;, Dynamic Graph Algorithms and Data Strictures, Ph.D. Thesis, Utrccht University, 
1991. [25] M.H. Overmars, The Design of Dynamic Data Structures, Lecture Notes in Computer Science 156, 
Springer-Verlag, Berlin. 1983. [26] T. Ozawa and H. Takahashi, A graph-planruization aJgorithm and its 
applications to random graphs, in: Graph Theory and Algorithms, Spnnger-Verlag, Lecture Notes in Computer 
Science 108 (1981), pp. 95-107. [27] D.D. Sleator and R.E. Tarjasr, A data structure for dynamic trees, 
J. Comput. Syst. Sci. 24 (1983) 362-381. [28] R.E. Tarjan, A Class of Algorithms which Require Nonlinear 
Time to Maintain Disjoint Sets, J. Comput. Syst. Sci. 18 (1979) 110-127. [29] J. Westbrook and R.E. Tarjan, 
Maintaining bridge-connected and bi­connected components on-line, Algorithmic (1992) 433-464. [30] J. 
Westbrook, Fast incremental planarity testing, Proc. 19th Int. Col­loq. on Automat&#38; Languages, and 
Programming (ICALP) (1992) 342-353. [31] J. Westbrook, Fast Incremental Algorithms for 4-Edge-Connectivity, 
manuscript. Figure 1: x Figure 2: 2 x Figure 3: el Figure 4: / / / 0-\ \ \ \ \ I  
			
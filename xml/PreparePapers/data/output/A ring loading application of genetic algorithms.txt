
 A Ring Loading Apphcation of Genetic Algorithms Nachimuthu Karunanithi and Tamra Carpenter Bellcore, 
Morristown, NJ Abstract In this study, we examine the suitability of a genetic algo- rithm (GA) for 
solving an optimization problem that arises in sizing SONET rings in a telecommunications network. We 
consider applying genetic algorithms to this problem be- cause it is a computationally difficult problem 
whose solu- tions have clear economic impacts and very straightforward encodings in genetic algorithms. 
We compare GA solutions with optimal solutions obtained by the CPLEX mixed inte- ger program solver and 
heuristic solutions generated by the algorithm that is incorporated in the SONET TooLkit -a decision 
support system for planning SONET networks. Keywords: genetic algorithms; integer programming; telecommunica-tions 
networks; SONET rings. Introduction Structurally, a SONET [1, 9] ring consists of a set of nodes connected 
by high-capacity optical links to form a cycle that nowhere overlaps itself. (See Figure 1.) This configuration 
affords high failure survivability because every pair of nodes is connected by two physically diverse 
paths. As a conse-quence, no single node or link failure disconnects the ring. In the event of a failure, 
all traffic, except that which ter-minates at a failed node, can be diverted around the failure as long 
as the links have enough capacity. The ring sizing problem is to determine how much capacity is enough. 
More specifically, given a set of demands between nodes on a ring, the ring sizing problem is to find 
the minimum ring capacity that a.fiords full survivability from. single failures. Since the cost of a 
ring is directly related to its capacity, this amounts to finding the least cost ring that meets the 
survivability re-quirement. Before proceeding, we note that rings are built with all links of equal capacity, 
so the notions of ring capac- ity and link capacity axe interchangeable in this application. In the rings 
that we consider 1 , the capacity required for sur- vivabillty d~pends on the routing of the demands 
around the ring. Given aparticuiar routing for each demand (clockwise or counter-clockwise), the smallest 
capacity required to as- sure survivability is linearly related to the maximum amount t Bidirectional 
rings with time-slot interchange capability. Permission to copy without fee all or part of this material 
is granted provided that the copies are not made or distributed for direct commcmial advantage, the ACM 
copyright notice and the title of the publication and its date appear, and notice is given that copying 
is by permission of the Association for Computing Machinery. To copy othe~ise, or to republish, requires 
a fee and/or specific permission. O 1994 ACM 089791-647..6/ 94/0003 $3.50 of traffic routed on any link. 
Thus, the question becomes: how do we route the demands so as to minimize the maxi- mum amount of traffic 
on a link? The process of assigning each demand to one of two possible routes around the ring is known 
as ring loading. The ring loading problem is the related optimization problem that minimizes the maximum 
traffic on a link. Clearly, solving the ring loading problem yields a solution to the ring sizing problem. 
The ring loading problem and its application to SONET ring sizing are pre-sented by Cosares and Saniee 
[2]. (See also [10].) Cosares and Saniee [2] prove that ring loading is NP-complete and propose several 
heuristics for obtaining approximate solu-tions. The fact that the ring loading problem is NP-complete 
makes it a logical candidate for a heuristic search method such as GA. Moreover, the binary nature of 
the decision provides an immediate encoding for the genetic algorithm. As a re- sult, GA can be implemented 
in a very natural way. To our knowledge, ring loading is a new application for genetic algorithms, which 
can be very successful on realistic-sized instances. This paper is organized into three main parts: (1) 
a mathe- matical description of the ring loading problem; (2) outlines of the heuristic methods we apply; 
and (3) computational results comparing GA solutions with optimal solutions ob-tained by CPLEX [4] and 
approximate solutions obtained by a heuristic implemented in the SONET Toolkit [3] -a decision support 
system used by transport planners in the Bell regional operating companies. 1 Figure 1: A 12 node ring. 
  The Ring Loading Problem The ring loading problem-is defined on a network whose nodes axe connected 
to form a ring, as shown in Figure 1. We consider the nodes to be indexed from 1 to n going clockwise 
around the ring. Similarly, the links are indexed from 1 to n -so that index i corresponds to the link 
on the clockwise side of node i. Given a set ~ of demands between nodes on the ring, the ring loading 
problem seeks a routing for each demand -ei-ther clockwise or counter.clockwise -such that the maxi- 
mum load on a link is minimized. A demand k E ~ is defined by a pair of nodes i~ and ]~ and some' amount 
d~ of traffic between them. We assume dk to be nonnegative and integer. A particular demand k, partitions 
the links of the ring into two sets: those that are traversed in a dock- wise routing of demand k and 
those that are traversed in a counter-clockwise routing. Let C(k) be the clockwise finks, and let CO(k) 
be the counter-clockwise finks. Given these definitions, the ring loading problern is: [RL]: minimize 
z subject to: zk + ~t = 1, Vk 6 ~ (1) < w = (2) l~C(k) ~Ecc(h) ~,~ ~ {0,1} vk ~ v. (3) The constraints 
(1) ensure that each demand is satisfied. The left-hand side of each constraint (2) computes the traffic 
on a particular link 1. Hence, the objective value z will be the maximum amount of traffic on any llnk 
of the ring. Since [RL] is formulated using binary variables, a partic-ular demand is routed either entirely 
clockwise or entirely counter-clockwise. By relaxing this "all-one-way" require- ment, we could formulate 
the ring loading problem to allow some portion of a demand to route c|ockwise and the re-mainder to route 
counter-clockwise. Frank, Nishizeki, Salto, Suzuki, and Tardos [5] analyze the ring loading problem when 
the demands may be split in an "integer way". Ear-lier results of Frank [6] (for a more general problem) 
provide a polynomial time algorithm for this version of ring load- ing. If the demands may be split arbitrarily, 
then ring load- ing is equivalent to solving a linear program and, therefore, polynomially solvable. 
Shulman, Vachani, Ward, and Ku- bat [10] have proposed an algorithm that exploits the special structure 
of the underlying network to solve the continuous- variable ring loading problem extremely efficiently. 
So, al- though ring loading may be viewed as a mathematical pro- gram in binary, integer, or continuous 
variables, the binary ring loading problem is the only one that is c0mputationally difficult. Heuristics 
for Binary Ring Loading Cosares and.Saniee [2] consider heuristic approaches to the (binary) ring loading 
problem both because it is computa- tionally intractable and because a ring loading subroutine could, 
potentially, be called a large number of times during a network planning session. Although Cosares and 
Saniee propose several heuristics, we include only the two-phase greedy heuristic our study. This heuristic 
is the basis of the one currently implemented in the SONET Toolkit [3]. The two-phase greedy heuristic 
is most easily described by first presenting a basic greedy (one-phase) approach. Given set of demands 
sorted in non-increasing order of demand size, the method routes them one at a time so that the traffic 
on the busiest link is increased the least. The two-phase greedy algorithm is simply the basic greedy 
algorithm calling itself to break ties. Specifically, the algorithm is stated as: For each demand, route 
in the direction that causes the: current maximum link load to increase the least. If there is a tie, 
do the following: - Temporarily route the current demand clockwise., then route all other demands according 
to the ha.. sic greedy algorithm. - Temporarily route the current demand counter-clockwise, then route 
all other demands according to the basic greedy algorithm.  - Permanently route the current demand in 
the di- rection that yielded the best final link load. Our results verify that this algorithm is extremely 
fast and that its solutions are relatively good. However, the variabil- ity in the quality of the solutions 
that it produces suggests that there may also be a place for alternative methods such ' as genetic algorithms. 
Genetic Algorithm Genetic algorithms developed by John Holland [8] are search procedures based on the 
mechanics of natural evolution. Ge-netic algorithms try to strike a balance between exploration and exploitation 
during search [7]. However, the fitness pro- portlonate selection used in the standard genetic algorithms 
may sometimes lead to premature convergence [11]. One way to reduce premature convergence is to use ~ 
variant of the standard genetic algorithm called the steady-state genetic algorithm. In this study, a 
steady-state genetic algorithm called GENITOR developed by Whitley [11, 12] is used. The objective for 
the ring loading problem is to minimize the maximum load on the links of a ring. Thus for each individual 
in the population, a fitness value is assigned by determining the maximum link load it induces. In this 
study, we use the standard binary encoding because it inherently maps to the directions of the demands. 
Here, the number of bits in a string is equal to the number of demands to be routed. A value of 1 at 
position k can be interpreted as routing load d~ in the clockwise direction, and a value of 0 as routing 
in the counter-clockwise direction. We use the Reduced Surrogate Crossover operator and the Adaptive 
Mutation operator implemented in the Genitor package [12]. For all our experiments, the mutation rate 
is 0.15 and the crossover probability is 0.20. Evaluation of Algorithms We evaluate the utility of the 
genetic algorithm by examin- ing its performance on 10 and 25 node rings. A ring in a telecommunications 
network will typically contain between 5 and 15 nodes. Thus, we coi,s:der 10 node tings to be in the 
range that we would expect and 25 node rings to be an upper bound on the size of problems that might 
be encountered. We generate the demand am.~t~ d~ randomly from either a unifcrm or a bimodal distribution, 
in addition, we consider both complete and partial sets of demands. For a ring with n nodes, there are 
n* (n-1)/2 possible source and destination pairs. This is the complete set of demands. Partial sets of 
~emands are generated by randomly setting some fraction of the possible demands to zero. Our study includes 
examples in which half of the possible, demands are zero. In addition, we consider two ranges for the 
demands: a low variance " range over 1 and 100 units, and a high variance range over 1 and 500 units. 
These consi,~erations lead to four test cases for each ring size. They are: Case 1: Full set of demands 
between 1 and 100 with uniform distribution (C1_).  Ca~e 2: Half of the demands in Case 1 set to zero 
(C2_).  Case 3: Full set of demands between 1 and 500 with uniform distribution (C3_).  Case 4: Full 
set of demands between 1 and 500 but with a bimodal distribution (C4_).  Note that cases 1, 3 and 4 
have complete demand sets, while case 2 has only a partial demand set. In case 4, 80% of the demands 
are uniformly distributed between 1 and 50, while the remaining 20% are uniformly distributed between 
400 and 500. We generate 10 different sets of demands for each case. This yields 40 instances for each 
ring size. For convenience, they are labeled .Ci_j, where 1 < i < 4 represents the demand case and 1 
< ] < 10 represents the instance within a case. For ex- ample~ C1_10 represents the 10th instance of 
the test case 1. Since the final solution produced by the Genitor algorithm is influenced by the randomly 
generated initial population, we perform the search 50 times for each instance. Thus, the results reported 
for the Genitor algorithm are based on summary statistics from these experiments. Results Tables 1 and 
2 summarize Icsults obtained by applying the two-pass algorithm, CPLE:(, and GA to 10 and 25 node problems 
on a Sun4m workstation. Since the two-pass algo- rithm is by far the fastest of the three methods, our 
intent is mainly to evaluate the quality of the solutions obtained by the two heuristics. To do this, 
we compare the heuristic solutions to the optimal solutions obtained by CPLEX [4] - a commercially available 
solver for linear and mixed integer linear programs. The ring loading problem includes integer variables, 
so we use CPLEX's mixed integer ~c!ver, which employs a branch and bound algorithm. We invoke CPLEX from 
within our own program via the CPLEX callable library. We use all default options with the exception 
that we specify the abso-lute mipgap to be 0.99 and C~.e relative ~pgap to be 10 -Â° . These settings 
save CPLEX needless search but do not omit any potentially optimal solutions. In each of the 10 node 
problems, the genetic algorithm finds an optimal solution at least once. The objective mean value and 
standard deviations indicate that there is little variabil- ity in the quality of the GA solution from 
one trial to the next. For several problems, the genetic algorithm obtains an optLmal solution in every 
trial. In most cases, the two-pass algorithm is within 10% of the optimum. However, it is off by as much 
as 25% for example C~_3. In many of the 10 node instances, the worst solution obtained by GA is at least 
as g~,od as the tv/o-pass solution. For some of the 25 node problems, CPLEX reaches its branch and boundnode 
limit before it discovers an optimal solu- tion. When this happens, we are sometimes able to generate 
optimal solutions by adjusting additional CPLEX parame-ters, or by adding some constraints to the basic 
formulation. When the optimal solution is obtained by one of these al- ternate means, we provide only 
the solution but no CPU time in Table 2. In a few cases, none of these strategies yields a confirmed 
optimal solution. When no solution can be proven optimal, the value reported in Table 2 is simply the 
best solution observed, which is an upper bound on the true optimal value. Once again, the best genetic 
algorithm solution often matches the best solution obtained. Although the GA solu- tions still appear 
to be quite robust, there is more variability between its best and worst solutions. In contrast, the 
two-pass algorithm performs more consistently on large problems than it does on the small ones. In every 
case, it is within 11% of the best solution observed. Our results emphasize the fact that GA is robust 
not only in the quality of it's solutions, but also in the time it takes to obtain them. The times provided 
in Tables 1 and 2 demon- strate that the time i.t takes for GA to obtain its solutions depends mainly 
on the number of demands populating the ring. These times are relatively insensitive to the specific 
problem instance and the underlying demand distribution. References [1] J. Babcock. Sonet: A practical 
perspective. Business Communications Review, 59-63, September, 1990. [2] S. Cosares and I. Saniee. An 
optimization problem re-lated to balancing loads on SONET networks. Technical Memorandum. Bellcore, Morristown, 
N J, 07962, 1992. [3] S. Cosares, I. Saniee and O. Wasem. Network plan-ning with the SONET Toolkit. Bellcore 
Exchange, 8-13, September/October, 1992. [4] CPLEX Optimization, Inc. Using the CPLEX Callable Library 
and CPLEX Mixed Integer Library, Version 2.1, 1993. [5] A. Frank, T. Nishizeki, N. Saito, H. Suzuki, 
and E. Tar- dos. Algorithms for routing around a rectangle. Discrete Applied Mathematics, 40:363-378, 
1992. [6] A. Frank. Edge-disjoint paths in planar graphs. Journal of Combinatorial Theory, Series B, 
39:16'~-178, 1985. , . " .... ,~ . ,,. [7] D. E. Goldberg. Genetic Algorithrns in Search, Opti- mization 
and Machine Learning, Addison-Wesley Pub- lishing Company, Inc., 1989. [8] J. H. Holland. Adaptation 
in Natural and Artificial Sys- tems, The University of Michlgan'Press, Ann Arbor, 1975. [10] A. Shulmaa, 
R. Vaehaafi, J. Ward, and P. Kubat. Mul- ticommodity flows in ring networks. Technical Report. GTE Laboratories, 
Waltham, MA, 02254, 1991. [11] D. Whitley. The GENITOR Algorithm zmd Selective Pressure: Why P~.nk-based 
Allocation of Reproductive 'I~rials is Best. Proceedings of the Third Conference on Genetic Algorithms, 
1989, Washington, D. C., pp. 116- 121, Morgan Kaufmann, Publishers. [12] D. Whitley, and T. Starkweather. 
Gerdtor II: A Dis- tributed Genetic Algorithm. Journal of Ezperimental and Theoretical Artificial Intelligence, 
No. 2, pp. 189-214, 1990. [9] D. Miaoli. TelecommunicatiOns Technology tfdndbook, Artech House, Inc., 
Boston, 1991.  Heuristics CPlex Genitor Test Link CPU Link i CPU Link Capacity CPU Time Sec Ca.ses Capacity 
Time Sec Capadty Time Sec Mean Best Std Mean I Best Std Cl_l 584 0.03 584 0.77 584.0 584 0.0 4.13 3.13 
0.49 C1_2 881 0.02 749 0.55 749.7 749 3.3 4.49 3.22 0.61 CI_3 759 0.03 661 5.37 662.3 661 1.8 5.86 3.82 
1.05 CI_4 726 0.03 701 1.62 701.4 701 1.6 4.73 3.80 0.74 Ci.5 721 0.02 660 2.77 660.8 660 1.3 5.26 3.48 
0.97 CI_6 733 0.03 726 0.67 726.2 726 0.7 5.50 3.57 0.96 CI_7 729 0.02 712 2.48 712.5 712 1.1 5.06 3.75 
0.69 CI_8 715 0.02 702 1.53 702.6 702 2.6 5.15 3.45 1.08 Ci_9 666 0.03 644 0.70 645.6 644 4.8 5.31 3.62 
0.89 CI_IO 715 0.03 712 1.02 712.8 712 2.0 4.94 3.52 0.87 C2_i 329 0.02 312 0.28 312.2 312 0.4 2.77 0.38 
0.71 C2.2 402 0.00 399 0.90 400.2 399 1.5 2.63 1.28 1.10 C2_3 434 0.00 383 0.28 384.4 383 3.1 2.79 1.38 
0.97 C2_4 346 0.00 346 0.45 346.6 346 1.8 2.62 1.35 0.85 C2_5 487 0.00 449 0.15 449.1 449 0.3 2.31 0.97 
0.54 C2_6 429 0.00 424 0.20 425.3 42,4 3.6 2.98 1.30 1.02 C2_7 409 0.00 403 0.42 403.7 403 1.8 2.97 1.23 
1.17 C2_8 474 0.02 473 0so 474.0 473 2.7 2.99 1.32 1.17 C2_9 350 0.00 347 0.85 347.0 347 0.4 2.29 0.37 
0.78 C2_10 517 0.02 456 0.62 456.6 456 2.9 2.53 1.27 0.57 C3_i 2895 0.03 2893 0.95 2893.4 2893 0.0 4.65 
3.10 0.75 C3_2 4236 0.03 3722 0.92 3726.9 3722 19.8 4.51 3.40 0.66 C3_3 3771 0.03 3277 4.98 3284.8 3277 
9.9 5.88 3.72 1.13 C3_4 3786 0.02 3469 1.57 3469.7 3469 4.1 4.87 3.35 0.89 C3_5 3504 0.03 3273 2.65 3277.5 
3273 6.8 5.11 3.60 0.92 C3_6 3615 0.03 3605 4.10 3607.4 3605 4.6 5.73 2.82 1.21 C3_7 3611 0.02 3530 3.65 
3533.1 3530 4.9 5.28 3.67 0.84 C3_8 3575 0.02 3486 3.53 3488.8 3486 5.9 5.39 3.43 0.90 C3_9 3472 0.03 
3196 1.20 3199.8 3196 17.4 5.05 3.07 1.05 C3_10 3982 0.02 3530 4.10 3534.9 3530 8.4 5.03 3.52 0.88 C4_1 
1865 0.03 1863 0.87 1863.2 1863 0.0 4.73 3.00 0.73 C4_2 1859 0.03 1858 1.47 1858.0 1858 0.0 4.48 3.23 
0.52 C4_3 2036 0.03 1620 0.38 1620.0 1620 0.0 4.45 3.15 0.64 C4.4 2120 0.03 2000 1.25 2000.0 2000 0.0 
4.69 3.40 0.78 C4.5 1939 0.02 1932 0.75 1932.1 1932 1.0 4.74 3.37 1.07 C4_6 1659 0.02 1658 0.57 1658.0 
1658 0.0 4.92 3.08 0.88 C4_7 2102 0.03 1907 0.67 1912.7 1907 19.3 5.37 3.77 0.92 C4_8 1858 0.00 1857 
0.87 1868:8 1857 12.2 .. 4.88 3.55 0.79 C4 _9 2048 0.02 2009 4.35. 2009.0 2009 0.0 5.10 3.57 0.99 C4_10 
1777 0.02 1770 1.78 1770.0 1770 0.0 4.59 3.05 0.61 Table 1: A Summary of Results for the Ring with 10 
Nodes. 4.  Heuristics II CPlex Genitor Test Cases Link Capacity CPU Time Src Link Capacity CPU Time 
Sec Link Capa~l~y Mean B?~t [ Std CPU ~ean Time Sec Best Std CI_I 4391 1,98 4110 19,78 4161,5 41i9 28,8 
447.64 360,13 39.67 CI_2 4150 2,02 3911 - 22,60 3933,5 3911 19.1 454,10 351,52 44.19 CI_3 4476 1,93 4136 
19.12 4207.8 4153 31,1 448.11 340,67 48.57 C1_4 4353 2,03 4202 4234,9 4204 25.7 457,50 373.48 37,23 CI_5 
4206 2,15 4122 29.73 4127,3 4122 15,3 427,31 314.52 42.73 C1_6 4297 2,20 4]28 22,18 4181,9 4141 30.6 
452.74 361,12 39.39 CI_7 4182 2,05 4018 4078.0 4023 22.7 454.57 380,40 36,95 CI_8 4335 2,03 4142 46.30 
4196,4 4156 30,6 448.99 374,82 36,50 CI_9 4182 2,00 4075 331,98 4124.9 4082 25.2 456.40 362.82 39.89 
C1_10 4093 1,93 4010 22.72 4020.9 4010 15.6 430.00 341.05 45.93 C2_i 2246 0,40 I 2147 2147.1 2147 1.6 
118.92 86.77 13.86 C2_2 1946 0,52 1946 1947.9 1946 3,9 !11.63 69,70 14,77 C2_3 2381 0,57 2323 31,93 2325,6 
2323 4.5 ]37.3890,47.17.75 C2_4 2134 0.58 2050 122.85 2062,2 2052 5,8 126,71 99,75 15.46 C2_5 2366 0,45 
2235 t 2242.9 2235 14,7138,90 102,23 18,91 C2_6 2199 0,45 2049 58,58 2051,8 2049 5,1 128,1198,9714,92 
C2_7 2164 0,47 2051 5,72 2051,2 2051 1,4 118,26 80,48 21,96 C2_8 2110 0,47 2026 551,27 2032,3 2026 10.2 
141,44 98,57 17,97 C2_9 2237 0.45 2179 13,28 2181.4 2179 i 5,2 134,08 101,57 16,77 C2_I0 2201 0.52 2136 
22,70 2136.3 2136 0.8 123,28 95.67 16,42 C3_1 21594 2.05 20391 202,60 20631,5 20401 ! 157,3 451,10 347,08 
42,39 i C3_2 20559 1.95 19399 38,65 19494,4 19399 81,8 472,95 361,37 35,09 C3_3 22059 1.72 20516 38,35 
20912,0 20543 179,4 450,67 362,48 39,99 C3_4 21765 1.73 20853 21049.9 20854 109,9 459,15 371,58 38,22 
C3_5 21061 2.10 20453 558.07 20549.6 20453 93.8 449.98 349.42 40,70 C3_6 21562 2.22 20477 54,58 20768.1 
20552 138,6 465,62 365.13 38.97 C3_7 20847 2.02 19922 35.82 20186.7 19930 145.2 459.93 386.98 35,97 C3_8 
21358 1.98 20547 879,58 20801.0 20551 155.7 458,11 353.55 45,53 C3_9 20906 1.95 20216 20422,4 20216 141,8 
473,11 390.25 31,57 C3_i0 20047 2.07 19886 29,53 19931.7 19886 64.5 459,75 347.33 36.17 C4_1 9598 1.87 
9523 16,72 9553,9 9523 22.5 { 472.89 379.85 39.18 C4_2 10155 2,00 9495 11.90 9517.6 9495 43,6 490.26 
370,28 37.86 C4_3 9769 1.97 9354 16,13 9435,9 9362 84.1 484,48 369.63 44.67 C4_4 10224 1.75 10195 24,82 
10204.7 10195 19.6 481,91 352,03 46.75 C4_5 9993 1,90 9594 24.72 9616,5 9594 41,0 460.86 377.23 38,79 
C4_6 10827 2,13 10094 118,77 10096,4 10094 3.4 488.70 389.72 40.54 C4_7 9522 1,88 9061 19,43 9070,0 90~! 
15,3 ! 489,26 415.27 31.02 C4_8 9476 1,85 9466 t 9478.7 94~6 20,9 479.25 355,28 41.29 C4_9 10512 2,02 
10089 t 10128,6 10089 40,5 487,00 353.52 40.84 C4_10 11676 2,02 10532 21,57 10535,3 10532 11,6 458.96 
340,37 53,21 Table 2: A Summary of Results for the Ring with 25 Nodes. t: Solution not confirmed optimal. 
 
			
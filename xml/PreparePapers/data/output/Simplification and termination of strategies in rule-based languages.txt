
 Simpli.cation and Termination of Strategies in Rule-Based Languages Olivier Fissore, Isabelle Gnaedig, 
H´el`ene Kirchner LORIA-INRIA &#38; LORIA-CNRS B.P. 239 F-54506 Vand uvre-l`es-Nancy Cedex Phone: +33383581700 
Fax : +33383278319 e-mail: fissore@loria.fr,gnaedig@loria.fr,Helene.Kirchner@loria.fr ABSTRACT In rule-based 
languages, control of rule application can be expressed thanks to strategy constructors. The paper ad­dresses 
termination of such strategy-guided evaluation. To .x ideas, we use the ELAN strategy language. We .rst 
give a su.cient criterion for ELAN-like strategies to terminate, only lying on rewrite rules involved 
in the strategy. We then give a simpli.cation process of strategies, itself described by rewriting, to 
empower the previous criterion. This simpli­.cation can also make proofs of other program properties 
easier. Categories and Subject Descriptors D.2.4 [SOFTWARE ENGINEERING]: Software/Program Veri.cation 
correctness proofs, formal methods; D.3.2 [PRO-GRAMMING LANGUAGES]: Language Classi.cations constraint 
and logic languages; F.4.1 [MATHEMATICAL LOGIC AND FORMAL LANGUAGES]: Mathemati­cal logic mechanical 
theorem proving; I.1.3 [SYMBOLIC AND ALGEBRAIC MANIPULATION]: Languages and Systems evaluation strategies 
 General Terms Algorithms, Language, Theory, Veri.cation. Keywords Rewriting, termination, strategies, 
rule based languages, pro­gram simpli.cation. 1. STRATEGY-GUIDED EVALUATION IN RULE-BASED LANGUAGES Rule-based 
languages like ASF+SDF [17], Maude [6], Cafe-OBJ [11], Stratego [24] or ELAN [3] are now used for vari­ous 
applications like constraint solving, protocol veri.cation, Permission to make digital or hard copies 
of all or part of this work for personal or classroom use is granted without fee provided that copies 
are not made or distributed for pro.t or commercial advantage and that copies bear this notice and the 
full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute 
to lists, requires prior speci.c permission and/or a fee. PPDP 03, August 27 29, 2003, Uppsala, Sweden. 
Copyright 2003 ACM 1-58113-705-2/03/0008 ...$5.00. modelization of biological or chemical systems, and 
more. Nowadays, these systems deserve all the more interest as they are backed up by e.cient compilers 
or interpreters. The declarative aspects of programming brought by rewrite rules can be enforced by a 
declarative language for express­ing control as for instance in [14]. In a more general context, methods 
for controlling non-deterministic computations [20, 21, 15] are used to reduce backtracking. The ELAN 
system, in particular, provides an environment for specifying and prototyping deduction systems by allow­ing 
to combine rules with strategy operators. Evaluating a data in the rewriting context consists in exploring 
all possi­ble rewriting derivations. The strategy operators combining the rules are used to re.ne the 
rewriting process while pre­serving its non-determinism. They restrict the search space by describing 
the form of the best derivations to get results. In this context, as in programming in general, termination 
is a key property. It warrants, in particular, the existence of a result for every evaluation of a program. 
Our purpose here is to study termination of ELAN-like strategies. The idea is to transform the termination 
problem of a strategy, very di.cult to tackle directly, into the termination study of a conditional rewriting 
system (CRS in short). The trans­formation we propose is a simpli.cation in the sense that operators 
of the strategy are suppressed, as well as redun­dant rules in the program. The structure of the resulting 
program is then simpler ; it has in general signi.cantly less rules than the initial one, and so is in 
general more readable. Thus, our simpli.cation can also be seen as an assistance tool for writing rule-based 
programs. For related work, R. Kieburtz, in [16], de.nes a program­ming logic for rewriting Stratego-like 
strategies [24]. His study consists in characterizing the largest set of terms ver­ifying a certain property 
P once transformed by a strategy S. However, no termination result emerges from this work, and recursion 
is explicitly assumed terminating. Some of the simpli.cations of this paper have been inspired from [19], 
where many laws on ELAN-like strategies (called tactics) are established. The notion of simpli.cation 
of stra­tegies also occurs in [25], but, as we will see, ours is the .rst one that preserves both semantics 
and termination be­haviour, may the strategies terminate or not. This work is also of interest for rule-based 
languages like Stratego, Maude and Cafe-OBJ, previously cited, and for declarative languages [21, 15], 
since they have strategy fea­tures similar to the ones described here. The paper is organized as follows. 
In Section 2, we present the background and introduce the strategies studied in the paper. In Section 
3, we introduce a method for proving termination of these strategies. In Section 4, a simpli.cation process 
empowering this method is proposed. Illustrative examples are given.  2. RULE-BASED PROGRAMS WITH STRA-TEGIES 
We assume that the reader is familiar with the basic def­initions and notations of term rewriting given 
for instance in [5]. In the following, we denote X a (potentially in.nite) set of variables. T(F, X) 
is the set of terms built from a given .nite set F of function symbols f having (possibly variable) arity 
n . N(which is denoted f : n), and the set X. Given a term t .T(F, X), Var(t) denotes the set of variables 
in t. The normal form of a term t w.r.t. a term rewriting system (TRS in short) Ris denoted t.R.A substitution 
is an assignment from X to T(F, X), written s =(x ff .t) ... (y .u), and identi.ed with the .nite set 
of equations (x = t) .... .(y = u). It uniquely extends to an endomorphism of T(F, X). The result of 
applying s to a term t .T(F, X) is written s(t)or st. The do­main of s, denoted Dom(s) is the .nite subset 
of X such that sx x. = The range of s, denoted Ran(s), is de.ned  by Ran(s)=Var(sx). We have in addition 
x.Dom(s) Dom(s) nRan(s)= Ø. The restriction of a substitution s to a set of variables X is denoted sX 
, and is de.ned by Dom(sX ) .X,and sX x = sx for every x .X. "From the programmation point of view, a 
rule-based formalism with strategies enables to specify system calculi based on multi-sorted rewriting 
theories ; each theory is described by a program consisting of a signature, a set of rewrite rules for 
calculus and execution strategies for con­trol. Given a program E describing a theory, we denote FE the 
set of symbols of the signature, where the subscript E may be omitted if there is no ambiguity. We denote 
LE the set of its rules, assumed labelled to enable strategy constructors to use them later on. Several 
rewrite rules may have the same label ; hence a labelled rule is a set of conditional rewrite rules built 
over terms of T(FE, X). The syntax of a rewrite rule is [label] l .r if c where label is the label of 
the rule, (l .r if c) is a condi­tional rewrite rule, where l, r, c .T(FE, X) are respectively the left-hand 
side, the right-hand side and the boolean con­ditional part of the rule. By convention, we have Var(r) 
. Var(c) .Var(l). In the following, to .x ideas, we will consider the strategy language o.ered by the 
ELAN system. Strategies consist of terms built on FE.SE,with SE = LE.{id, fail, dk, dc, first, ; , repeat 
* }.The dk operator is an abbreviation of dont know choose, and selects non-deterministically all strategies 
given as parameter. The dc operator, for dont care choose, chooses in a non-deterministic way one strategy 
that does not fail. The first operator selects the .rst strategy that does not fail. It is similar to 
the classical structure if-then­else-orelse in other languages. The ; operator expresses composition 
of strategies, and the repeat * operator com­poses a strategy with itself while it is not failing. Note 
that this is the case of recursion we consider in our study. Id is the identity strategy, and fail a 
strategy that always fails. Given a strategy S .T(F.S, X), for i =0, we inductively de.ne Si by S0 = 
id and Si+1 = Si; S.The semantics of the strategy operators is given in Table 1, and borrowed from [2]. 
Strategies apply to terms to give sets of terms, empty if the application fails. Application of a strategy 
S to a ground term t .T(F) is denoted S(t), and computed with rules of Table 1. For readibility, we may 
also use the notation [S](t). Labelled rewrite rules apply to a term at the top position ; however, a 
congruence strategy enables the ap­plication of a strategy deeper in a term. We denote ff . the rewriting 
relation on strategy applications induced by rules of Table 1. Its re.exive transitive closure is denoted 
ff* Normal forms of this rewriting are sets of terms. Due . . to the non-determinism of some strategy 
operators, we may have two sets of terms E1 E2 such that S(t)ff* E1 and = . S(t)ff* (t) i. for every 
set of terms . E2.We write S(t) .S'E such that S(t)ff* . E, there exists an evaluation of S'(t) such 
that S'(t)ff* . E',with E .E'.We write S(t)= S'(t) i. S(t) .S'(t)and S'(t) .S(t). We say that S and 
S' have the same semantics i. S(t)= S'(t) for every ground term t, that S(t) terminates (or is terminating) 
if every evaluation of S(t) terminates and that S terminates (or is terminating) if S(t) terminates for 
every ground term t.We say that two strategies S and S' have the same termination behaviour if for every 
ground term t, S(t)terminates i. S'(t)terminates, and that two strategies S and S' are equivalent i. 
they have both same semantics and termination behaviour. Remark that two strategies S and S' may have 
the same semantics without having the same termination behaviour ; if we consider a terminating strategy 
S and a strategy S8 such that there exists no terminating evaluation of [S8](t) for every ground term 
t, then the strategies dc(S, S8)and S have the same semantics, but the .rst is not terminating, while 
the second is. Remark also that given a ground term t .T(F)and a strategy S, we can infer from the rules 
of Table 1 that if [S](t)ff*  . Ø, then every evaluation of [S](t) fails. By abuse of notation, we may 
denote [S](t)= Øfor [S](t)ff* . . Ø  3. TERMINATION OF STRATEGIES Given a strategy, we propose a way 
of extracting a set of labelled rules whose termination ensures termination of the strategy. A .rst, 
naive approach for proving termination of astrategy S is to prove termination of the set of all labelled 
rewrite rules involved in S. Indeed, given a set of labelled rewrite rules, strategy operators are used 
to constrain the rewriting, and hence restrict the possible applications of the rules. If termination 
of all applications is proved, then, in particular, so is termination of a strategy restricting these 
applications. By decomposing the strategy term and gath­ering the involved set of rules, the rewriting 
system LRon T(F.S.{Rules:1}, X) given in Table 2 rewrites Rules(S) into this set. Remark the particular 
rewriting of Rules(repeat * (S)), eval­uating in Rules(S)to which id is added. Indeed, id is hidden in 
the strategy repeat * (S), and applies if S fails. In partic­ular, a strategy repeat * (repeat * (S)) 
cannot be terminating, even if S is. Before using LR to prove termination of strategies, re­mark that 
since labelled rewrite rules only apply at the top position, we can restrict their termination study 
to the par­ticular case of e-rewriting, i.e. rewriting at the top position. Table 1: The ELAN strategies 
: atoms and operators Label/Operator Notation Functional semantics / De.nition enables the application 
of a strategy deeper into a term. Don t know dk(S1,... ,Sn) [dk(S1,... ,Sn)](t) ff. n i=1 [Si](t) returns 
all results of S1,... ,Sn. Whatever the term t, every strategy Si is tried in all possible ways on t. 
Don t care dc(S1,... ,Sn) [dc(S1,... ,Sn)](t) ff. { Ø if n i=1 [Si](t)= Ø [Sj ](t) if [Sj ](t) = Ø chooses 
non-deterministically a successful strategy among S1,... ,Sn and returns all its results. First first(S1,... 
,Sn) [first(S1,... ,Sn)](t) ff. {Ø if n i=1 [Si](t)= Ø [Sj](t) if j-1 i=1 [Si](t)= Øand [Sj](t) = Ø selects 
in a sequential way the .rst strategy that does not fail, and returns all its results. If Si is selected, 
then S1,... ,Si-1 have failed. Repeat repeat * (S) [repeat * (S)](t) ff. [Sj ](t)if [Sj+1](t)= Ø. j i=0 
[Si](t) = Ø iterates the strategy S until it fails and then returns the last result. Remark that if S 
fails, then repeat * (S)is equivalent to the id strategy. Table 2: Collection of TRSs used for termination 
Rules(id) .{x .x} Rules(fail) .Ø Rules({... }) .{... } n {Rules(dk(S1,... ,Sn)) . i=1 Rules(Si) LR= 
Rules(dc(S1,... ,Sn)) . ni=1 Rules(Si) Rules(first(S1,... ,Sn)) . ni=1 Rules(Si) n Rules(f(S1,... ,Sn)) 
. i=1 Rules(Si)if f .F Rules(S1; S2) .Rules(S1) .Rules(S2) Rules(repeat * (S)) .Rules(S) .{x .x} TERMIN(S) 
.T (true, S) T (b, id) .true T (b, fail) .true T (b, {... }) .true n T (b, dk(S1,... ,Sn)) . i=1 T (b, 
Si) T (b, dc(S1,... ,Sn)) .n T (b, Si) i=1 T (b, first(S1,... ,Sn)) .T (b, S1)n T (false, Si) i=2 { 
n T (b, f(S1,... ,Sn)) .i=1 T (b, Si)if f .F Termin = T (b, S1; S2) .T (b, S1) .T (false, S2) { true 
if Rules(S).is e-terminating T (false, repeat * (S)) .LR r if Rules(S).LR cannot be proved e-terminating 
 true if {.. . }is e-terminating * T (true, repeat ({... })) .false if {.. . }is not e-terminating r 
if {.. . }cannot be proved e-terminating { * true if S = {.. . }and Rules(S).LR is e-terminating T (true, 
repeat (S)) . r if S = {.. . }and Rules(S).cannot be proved e-terminating LR Definition 1. Given a CRS 
Rbuilt on T(F, X) and two between e-termination of S and termination of repeat * (S), terms t, t ' .T(F, 
X), we say that te-rewrites into t ' i. t -.nt ' . We say that R is e-terminating i. there exists R 
no in.nite e-rewriting chain in R. Note that the notion of e-rewriting is a particular case of rewriting 
with local strategies or context-sensitive rewriting, for which termination techniques exist [7, 18] 
when rules are unconditional. Classical methods for proving termination of CRSs [4, 13] rely on simpli.cation 
orderings and then show general termination, hence in particular e-termination. In Section 4.1, we propose 
a su.cient condition for proving e­termination of a set of labelled rewrite rules in some cases, when 
classical methods fail. We can now state a .rst su.cient condition for termina­tion of strategies. The 
complete proofs of the results pre­sented in this paper, omitted here for lack of space, can be found 
in a full version [10]. Proposition 1. Given a strategy S, the reduction of the term Rules(S) with LR 
terminates and results in a set of rules such that : if Rules(S).LR is e-terminating, then S terminates. 
Proposition 1 can be re.ned, since it considers all rules of a strategy, while only some of these rules 
may cause non termination. For instance, let us consider the strategy S = {f(a) .g(a)}; repeat * ({g(a) 
.f(a)}). Obviously, S is terminating : for any ground term t,the rule f(a) .g(a) fails or applies and, 
if it applies, the rule g(a) . f(a) can apply only once. However, we have Rules(S).LR = {f(a) .g(a),g(a) 
.f(a),x .x}, which is obviously not e-terminating. The intuition suggests that non termination can be 
caused only by recursion. We then use Proposition 1 for strategies encapsulated by a repeat * operator. 
Moreover, if the encap­and in this particular case, non termination of a strategy may be shown. If S 
is not a set of rules, then e-termination of the set of rules Rules(S).LR is just a su.cient condition 
for termination of S. For strategies that are not headed by a repeat * operator, we infer from the semantics 
given in Table 1 and the de.­nition of a terminating strategy the following conditions for termination 
: if S = id, fail or {... }, then its application consists of a .nite number of one-step rewritings, 
and hence terminates ;  if S = f(S1,... ,Sn), for f .F,then S terminates i. S1,... ,Sn are terminating 
;  if S = dk(S1,... ,Sn), then S terminates i. S1,... ,Sn are terminating ;  if S = dc(S1,... ,Sn), 
application of S may evaluate into application of Si,for some i .{1,... ,n};there­fore S terminates i. 
S1,... ,Sn are terminating ;  if S = first(S1,... ,Sn), application of S may never evaluate into application 
of Sj ,... ,Sn,for j> 1;this is why termination of S1,... ,Sn is just a su.cient condition for S to terminate. 
However, if S1 does not terminate, then neither does S ;  if S = S1; S2, a su.cient condition for S 
to terminate is that S1 and S2 are terminating. However, like for the previous point, if S1 does not 
terminate, then neither does S.  The above conditions for termination induce a transforma­tion that 
preserves termination and can even sometimes en­ sulated strategy is a set of rules S,thenwehave equivalence 
sure non termination of a strategy. This transformation is de.ned by a TRS T ermin on T (F.S.{ TERMIN:1,T 
: 2,true :0,false :0,r :0} ,X ) such that given a strategy S, S terminates if the term TERMIN(S) built 
on S with the new symbol TERMIN rewrites into true and does not ter­minate if TERMIN(S)rewrites into 
false. Termination of S is undetermined if TERMIN(S)rewrites into r. Reduction of the term TERMIN(S)is 
achievedin a clas­sical way through reduction of the term T(b,S)where b is a boolean value, initially 
true, indicating whether the reduc­tion will give a necessary and su.cient condition or just a su.cient 
condition. The value r extends the boolean values true and false by r. r = r, r. true = r, r. false = 
false. See Table 2 for T ermin, whose correctness is ensured by the following theorem. Theorem 1. Let 
S be a strategy. Then the reduction of TERMIN(S) with T ermin terminates and its normal form is either 
true, false or r,and : if TERMIN(S).T ermin = true,then S terminates ;  if TERMIN(S).T ermin = false,then 
S does not ter­minate.  A corollary of Theorem 1 is that any strategy containing no repeat * operator 
is terminating. Example 1. Let us come back to the strategy S motivat­ing the re.nement of Proposition 
1 : { f(a) . g(a)} ; repeat * ({ g(a) . f(a)} ). With T ermin, we have the reduction : TERMIN(S) -. 
T(true,{ f(a) . g(a)} ; repeat * ({ g(a) . f(a)} )) -. T(true,{ f(a) . g(a)} ) . T(false,repeat * ({ 
g(a) . f(a)} )) -. true . T(false,repeat * ({ g(a) . f(a)} )) -. true . true -. true. Consequently, 
by Theorem 1, S is terminating. Our termination criterion is still too coarse, for we have not taken 
into account the way strategy operators make their arguments interact. For instance, let us consider 
the strat­egy S : repeat * (first({ f(a) . g(b)} ,{ f(x) . g(x),g(a) . f(a)} )). Theorem 1 proves that 
S terminates if { f(a) . g(b),f(x) . g(x),g(a) . f(a)} is e-terminating, which is not the case, because 
of the in.nite e-derivation f(a) -. g(a) -. f(a) -. ... Yet, the semantics of the first operator ensures 
that the rule f(x) . g(x) cannot apply with the instance x = a, because of the .rst argument of the first 
strategy. In fact, S terminates. We then need to exploit the semantics of the strategy op­erators for 
proving termination of strategies in a .ner way than previously. An appropriate way consists in simplifying, 
in some sense de.ned later on, a strategy into another one whose termination is easier to prove and ensures 
termination of the original strategy.  4. SIMPLIFICATION OF STRATEGIES We then propose to exploit the 
particular de.nition of strategy operators to de.ne a reduction mechanism on strate­gies. We come up 
with rewrite rules transforming strategy terms into equivalent ones, i.e. having both same seman­tics 
and termination behaviour. To distinguish rewriting of strategies from rewriting applied to data t of 
programs, we will denote the reduction relation on strategies by '. . De.n­ing the size of a strategy 
by its number of labelled rewrite rules and strategy operators, the main idea is to make this size decrease 
when simplifying a strategy S intoastrategy S ' . We propose a simpli.cation process empowering the termination 
criterion described in Section 3, by removing labelled rules and strategy operators. Starting from very 
simple observations, we can easily, in a .rst step, introduce simpli.cation rules dealing with prop­erties 
of the failure and success of a strategy, i.e. of the par­ticular operators fail and id. They are rules 
(1 9) of the system SIMPL given in Table 5 at the end of Section 4, where all simpli.cation rules of 
the paper are gathered. Remark that one would also expect the simpli.cation rule S; fail . fail in the 
list of rules above, but this rules does not preserve the termination behaviour of the left-hand side 
strategy. Indeed, if S is not terminating then neither is S; fail, while the strategy fail always terminates. 
The rules (6) and (7) express that the fail strategy is never selected in the list of arguments. On the 
opposite, the rules (8) and (9) express that if a strategy S cannot fail, then the strategies occurring 
after S in the list of arguments of a first strategy will never be selected. Now, rules expressing the 
distributivity of the composi­tion can also simplify strategy expressions. See rules (10 12) in Table 
5. Note however that though the ; operator is distributive over congruence and dk strategies, it is not 
over dc and first strategies. We refer the reader to [10] for illustrative examples. When encapsulation 
of arguments by a strategy combina­tor is super.uous, we propose a way of .attening strategies with rules 
(13 20). For the rule (20), we assume that f .F and V ar(li) nV ar(lj)= Ø ,. i = j. Note that in this 
rule, the conjunction of the conditions only a.ects subterms of f(l1,... ,ln). Finally, we deal with 
redundancy of arguments in first and dc strategies by removing arguments that are syntacti­cally equal 
to other ones. See rules (21),(22). Let us now tackle more complex simpli.cations. 4.1 Composition of 
labelled rewrite rules We now focus on the simpli.cation of the composition of sets of labelled rewrite 
rules. As said above, the main pur­pose of the simpli.cation is to reduce the number of rewrite rules 
occurring in a strategy, which has a direct impact on its termination study with our termination criterion. 
We recall that labelled rewrite rules apply only at the top position ; given a ground term t, the application 
of the com­position of two labelled rewrite rules l1 . r1 if c1; l2 . r2 if c2 to t can then either fail 
or result in a singleton. Putting the conditional parts aside, the previous composi­tion succeeds if 
there exist two ground substitutions a1,a2 such that t = a1l1 and a1r1 = a2l2. Assuming there is no variable 
shared by both rules, the domains of a1 and a2 are disjoint, and the last condition is equivalent to 
the existence of a uni.er of r1 and l2. The following Proposition formal­izes this result and extends 
it to the conditional case, where both rule conditions must be satis.ed for getting a result. Proposition 
2. Let l1 . r1 if c1,l2 . r2 if c2 be two labelled rewrite rules, and let us assume that any rewriting 
step only occurs at the top position. Then, for any ground term t .T(F), we have : [l1 .r1 if c1; l2 
.r2 if c2](t)= Øif r1 and l2 are not uni.able.  [l1 .r1 if c1; l2 .r2 if c2](t)=[µl1 .µr2 if µc1 . µc2](t) 
if µ is a most general uni.er of r1 and l2.  We now infer from Proposition 2 the two-rule TRS Comp 
on T(F.S.{comp:2}, X) given in Table 3 such that given two labelled rewrite rules (l1 .r1 if c1), (l2 
.r2 if c2), the term comp(l1 .r1 if c1,l2 .r2 if c2) rewrites into a set of rules equivalent to the composition 
of the two rules. This set of rules is either the empty set, or a singleton. Rule (23), in Table 5, simpli.es 
the composition of two sets of labelled rewrite rules {... }1 and {... }2 into a new (possibly empty) 
set of rewrite rules, by using Comp. Let us give an example illustrating how e.cient this simpli.cation 
may be. Example 2. Let us consider the strategy S = {f(x) .g(x),f(x) .h(0,x)}; {h(1,x) .f(1),h(x, y) 
.y, f(1) .h(1, 1)} By using the simpli.cation rule (23), S rewrites in the union of the following six 
sets of rules : comp(f(x1) .g(x1),h(1,x2) .f(1)). Comp comp(f(x1) .g(x1),h(x2,y2) .y2). Comp comp(f(x1) 
.g(x1),f(1) .h(1, 1)). Comp comp(f(x1) .h(0,x1),h(1,x2) .f(1)). Comp comp(f(x1) .h(0,x1),h(x2,y2) .y2). 
Comp comp(f(x1) .h(0,x1),f(1) .h(1, 1)). Comp The .fth set is reduced into {f(x) .x}by using the sec­ond 
rule of Comp with the unifying substitution µ =(x2 = 0 .x1 = x .y2 = x). The other sets are reduced into 
Øby using the .rst rule of Comp. Then S simpli.es into S '= {f(x) .x}. Given a set {... }of labelled 
rewrite rules, rule (23) en­ables to simplify {... }i = {... }; ... ; {... },for i> 0, into a (possibly 
empty) set of rules. We can induce from this simpli.cation a criterion for e-termination. Proposition 
3. Given a CRS R consisting of a set of rules {... }built on T(F, X), Ris e-terminating if .i> 0: {... 
}i '. *. SIMPLØ Proposition 3 often holds with a reasonable value for i and is of high interest in practice, 
since it allows to prove speci.c e-termination of a non terminating (in the classical sense) set of rules, 
which often arises for programs with labelled rules. 4.2 Constraining rewrite rules The idea now is 
to suppress redundancy in the application of the rewrite rules occurring in a strategy by constraining 
them with extra conditions. On the one hand, the condi­tional part of a rewrite rule may be so constrained 
that it can be shown to be unsatis.able. In this case, the rewrite rule is equivalent to fail, and the 
strategy can be simpli.ed by the rules given at the beginning of Section 4. On the other hand, constraining 
rewrite rules restricts their application domain, and hence may improve their termination behaviour. 
For instance, the rewriting system {f(x) .g(x),g(a) .f(a)}is not terminating, but terminates if the .rst 
rule is con­strained by the condition x = a. We propose here a way of constraining rewrite rules oc­curring 
in a strategy by using the assumption that other strategies fail. This is of particular interest for 
strategies like first(S1,... ,Sn) applying to a ground term t,which evaluates into [Si](t)onlyif [S1](t),... 
, [Si-1](t) fail. As labelled rewrite rules apply to a term at the top position, the main idea is the 
following : given a rewrite rule l1 .r1 and a ground term t such that [l1 . r1](t)= Ø,we also have [l2 
.r2](t)= Øfor any rewrite rule l2 .r2 such that l2 is an instance of l1.On the opposite, if l1 is an 
instance s of l2 (l1 = sl2), then we can exclude this instance when applying l2 .r2 to t,that is[l2 .r2](t)=[l2 
.r2 if s](t). To ensure that the variables of the condition occur in l2,we must restrict to the case 
where s is ground. Proposition 4 generalizes this idea to the case where l1 and l2 are uni.able, and 
extends it to the conditional case. Proposition 4. Let l1 .r1 if c1 and l2 .r2 if c2 two conditional 
rewrite rules, t .T(F) such that l1 .r1 if c1 fails on t. If there exists a unifying substitution µ such 
that µl1 = µl2 and Ran(µ) .Var(l2), then we have [l2 . r2 if c2](t)=[l2 .r2 if c2 .not(µc1 .µVar(l2))](t). 
The conditional part not(µc1 .µVar(l2)) excludes instances of l2 equal to l1 and satisfying c1. For consistency, 
we denote the empty substitution by the boolean value true ;hence, if Dom(µ) nVar(l2)= Ø, the boolean 
expression not(µc1 . µVar(l2))is equivalent to not(µc1). Note that the condition Ran(µ) .Var(l2), together 
with the usual assumption Dom(µ) nRan(µ)= Ø, ensures that for every variable x . Dom(µ) nVar(l2), µx 
is a ground term. Thus the set of variables of the new condition is still included in the set of variables 
of l2, such as required by the de.nition of the conditional rewrite rules. We illustrate on an example 
how to use Proposition 4 to constrain a rewrite rule. Example 3. Let us assume that the comparison between 
integers reduces into true or false. Given rule1 =(g(x1, 1) . h(x1) if x1 > 1),and a ground term t .T(F) 
such that [rule1](t)= Ø, let us constrain the rewrite rule rule2 = (g(x3,x4) .f(x3) if x3 > 2) in the 
application [rule2](t). The intuition suggests that rule2 can be constrained by adding the condition 
x4 =1. In this way, we exclude possi­ble instances of the left-hand side of the failing rule rule1. Let 
us apply the constraining suggested by Proposition 4 to rule2,by taking µ =(x1 = x3 .x4 =1).With such 
a substitution, the conditions µ(g(x1, 1)) = µ(g(x3,x4)) and Ran(µ) .Var(g(x3,x4)) are ful.lled. Proposition 
4 then states that, since [rule1](t)= Ø, [rule2](t) is equivalent to the application [g(x3,x4) . f(x3) 
if x3 > 2 .not(x3 > 1 .x4 =1)](t). Assuming that the instances x3 and x4 normalizes into integers, the 
condition is equivalent to x3 > 2 .(x3 =1 .x4 =1), that is to (x3 > 2 .x4 =1), such as suggested by the 
intuition. We then de.ne a TRS CO on T(F.S.{constrain : 2}, X) such that given two strategies S1 and 
S2,the term Table 3: TRSs used for simpli.cation: composing and constraining rewrite rules { comp(l1 
.r1 if c1,l2 .r2 if c2) '.Ø if r1 and l2 are not uni.able Comp = comp(l1 .r1 if c1,l2 .r2 if c2) '.{µl1 
.µr2 if µc1 .µc2} if µ = mgu(r1,l2) failureRules({... }) '.{... } failureRules(id) '.Ø failureRules(fail) 
'.Ø failureRules(dk(S1,... ,Sn)) '.failureRules(S1) .... .failureRules(Sn) { failureRules(dc(S1,... 
,Sn)) '.failureRules(S1) .... .failureRules(Sn) FR= failureRules(first(S1,... ,Sn)) '.failureRules(S1) 
.... .failureRules(Sn) failureRules(S1; S2) '.Ø failureRules(repeat *(S1)) '.Ø failureRules(f(S1,... 
,Sn)) '.f(failureRules(S1),... ,failureRules(Sn)) if f .F n f({... }1,... , {... }n) '. (li.ri if ci).{... 
}i {f(l1,... ,ln) .f(r1,... ,rn)if i=1 ci} constrain({... },l .r if c) '.{l .r if c not(µici .µiVar(l))} 
(µi,ci).E constrain({... },id) '.id constrain({... },fail) '.fail constrain({... }1, {... }2) '. (l.r 
if c).{... }2 constrain({... }1,l .r if c) constrain({... },dk(S1,... ,Sn)) '.dk(constrain({... },S1),... 
, constrain({... },Sn)) { constrain({... },dc(S1,... ,Sn)) '.dc(constrain({... },S1),.. . , constrain({... 
},Sn)) CO= constrain({... },first(S1,... ,Sn)) '.first(constrain({... },S1),... , constrain({... },Sn)) 
constrain({... },S1; S2) '.constrain({... },S1); S2 { * id if constrain({... },S) -.CO*fail constrain({... 
}, repeat (S)) '. repeat *(S) otherwise constrain({... },f(S1,... ,Sn)) '.f(S1,... ,Sn)if f .F constrain(S1,S2) 
'.constrain(failureRules(S1).FR,S2)if S1 is not a set of rules with E = {(µi,ci)|.(li .ri if ci) .{... 
}such that µil = µili and Ran(µi) .Var(l)}. constrain(S1,S2) rewrites into a constrained form S2 'of 
S2 such that [S2'](t)=[S2](t) for every ground term t .T(F) on which S1 fails. Thanks to an easy extension 
of the failing rule in Proposition 4 to a set of failing rules, we get the .rst rewrite rule of CO(the 
complete TRS is given in Table 3). Let us now extend the constraint mechanism for a rewrite rule, expressed 
in the .rst rule of COintroduced above, to a constraint mechanism for any strategy S knowing the failure 
of a set of rules {... }. Wethen get thenext9 rules of Table 3, using the following facts : If S = id 
or fail, then there is no rule to constrain.  If S is a set of rewrite rules, then we can try to con­strain 
each rule of S.  If S = op(S1,... ,Sn), with op .{dk, dc, first},then we look for the rules to constrain 
in each strategy S1,... ,Sn.  If S = S1; S2, then we look for the rules to constrain in S1 only. We 
cannot deduce anything on S2,since S2 applies to the results of S1, and not directly to the term on which 
the set of rules {... }fails.  If S = repeat *(S1), as above, we cannot constrain S1, which is repeatedly 
applied. However, S1 is not re­peatedly applied if its .rst application fails. We can then test whether 
its constraint form is fail ;if it is the case, then S can be simpli.ed in id.  If S = f(S1,... ,Sn), 
with f .F,the strategies S1,... ,Sn apply to the subterms of the term on which the set of rules {... 
}fails, and then we cannot deduce any constraint mechanism.  We then have a way to constrain a strategy 
according to the failure of a set of rules. We .nally extend this failure case to the failure of any 
strategy. To do so, we de.ne a TRS FR on T(F.S.{constrain}.{failureRules :1}, X), given in Table 3, such 
that failureRules(S)rewrites into a set of rewrite rules that fail on every term t on which S fails. 
The rule failureRules(repeat *(S1)) '.Øof FRis implied by the fact that a repeat *strategy never fails. 
The last rule consists of simplifying a congruence strategy when all arguments are sets of rules. The 
following Lemma ensures the correction of the transformation induced by FR. Lemma 1. Given a strategy 
S, we have : 1. the reduction of the term failureRules(S) with FR terminates and its normal form is a 
(possibly empty) set of rewrite rules ; 2. every rule of failureRules(S).FRfails on any ground term 
t .T(F) such that [S](t)= Ø.  Thanks to FR, we can link the constraint mechanism of a strategy according 
to the failure of another strategy to the previous constraint mechanism of a strategy according to the 
failure of a set of rules, hence the last rule of CO. Lemma 2. For any strategies S1 and S2, the reduction 
of the term constrain(S1,S2) with CO terminates, and its normal form S2 'is a strategy such that for 
any ground term t .T(F) on which S1 fails : (correctness) [S2'](t) .[S2](t). (completeness) [S2](t) .[S2'](t). 
(termination) [S2](t) terminates i. [S2'](t) terminates. Let us now study how to exploit CO for simplifying 
strate­gies. As said before, constraining a strategy with respect to the failure of another one is of 
particular interest for first strategies. We recall that the first operator behaves like the classical 
if-then-else-orelse in other languages. So, given a ground term t, the application [first(S1,... ,Sn)](t)eval­uates 
into [Si](t)only if S1,... ,Si-1 fail on t. According to the semantics of the dk operator, the latter 
condition is equivalent to the failure of [dk(S1,... ,Si-1)](t). The con­strained form of each Si is 
then given by the normal form with CO of the term constrain(dk(S1,... ,Si-1),Si). The first strategy 
may then be simpli.ed by the rule (24) of Table 5. With this rule, we can get an in.nite reduction of 
a first strategy : S = first(S1,S2,... ,Sn) '.(24) S '= first(S1,S2',... ,Sn') '.(24) S '' = first(S1,S2 
'',... ,Sn '') '.(24) ... But the rule has no e.ect anymore from the term S '.This is why we require 
this rule to be applied only once on the same strategy term. Remark that we can also use CO to simplify 
the partic­ular case of the composition of a repeat *strategy with an­other strategy (see rule (25) in 
Table 5). Indeed, the strat­egy repeat *(S1) iterates the application of S1 until S1 fails. Henceforth, 
in the particular case of repeat *(S1); S2,the strategy S2 applies to a set of terms on which S1 has 
just failed, and can then be constrained. For the same reason as above, rule (25) is required to be applied 
only once on the same strategy term. 4.3 Exclusive strategies The constraint-based simpli.cation studied 
in Section 4.2 may make strategy arguments of the first operator mutu­ally exclusive. Intuitively, two 
strategies S and S 'are mutu­ally exclusive if there exists no ground term on which both S and S 'apply. 
Definition 2. Let S,S 'be two strategies. We say that . * S excludes S 'i. .t .T (F):(.E = Ø :[S](t) 
ff E) . ([S '](t) terminates and evaluates into Ø). We say that S and S 'are mutually exclusive i. S 
excludes S 'and S 'excludes S. To illustrate how important exclusive strategies are for simpli.cation, 
let us consider the strategy S = first(rule1, rule2), where rule1 =(g(x1,1) . h(x1)if x1 > 1) and rule2 
=(g(x3,x4) . f(x3)if x3 > 2). Both rule1 and rule2 apply on ground terms g(n,1), with n> 2. We showed 
in Example 3 that S can be simpli.ed into S '= first(rule1,rule2'), with rule2 '=(g(x3,x4) . f(x3)if 
x3 > 2 . x4 =1). Now rule1 and rule '2 are mutually exclu­sive. As a consequence, we can show that the 
strategy first(rule1,rule2')is equivalent to dk(rule1,rule2'), which simpli.es into {rule1}.{rule2'}, 
thatis a setof rewrite rules. Proposition 5 generalizes the use of mutually exclusive strate­gies sketched 
above to transform first and dc strategies into dk strategies, whose simpli.cation is in general easier, 
and particularly interesting if arguments of the strategy are sets of rules. Proposition 5. Let S1,... 
,Sn be strategies such that .i, j .{1,... ,n},i = j : Si and Sj are mutually exclusive. Then we have 
: 1. dc(S1,... ,Sn) is equivalent to dk(S1,... ,Sn). 2. first(S1,... ,Sn) is equivalent to dk(S1,... 
,Sn).  Using Proposition 5 to e.ectively transform dc or first strategies into dk strategies requires 
a way of proving that two strategies S and S 'are mutually exclusive. We then de.ne a TRS Excl on T (F.S.{constrain,failureRules}.{mutex:2,true:0,r:0},X) 
such that mutex(S,S ')rewrites with Excl into true if the strategies S and S 'are mutually exclusive, 
and into r if we do not deduce anything on mutual exclusion of S and S '. The de.nition of Excl relies 
on the following su.cient conditions : if the left-hand sides of two rewrite rules are not uni.­able, 
then these rules are mutually exclusive ;  if the left-hand sides of two rewrite rules are uni.able 
and their mgu makes one of the conditional parts of the rules unsatis.able, then these rules are also 
mutually exclusive ;  since id never fails, id and a strategy S 'are mutually exclusive i. S '= fail 
;  two sets of rules are mutually exclusive if each rule of the .rst set is exclusive with each rule 
of the second ;  astrategy op(S1,... ,Sn), with op .{dk,dc,first}, and a strategy S 'are mutually exclusive 
if for each Si, i .{1,... ,n}, Si and S 'are mutually exclusive ;  a congruence strategy f(S1,... ,Sn)and 
a strategy S 'are mutually exclusive if :  S ' side of rule of S 'is equal to f,or is a set of rules 
and no top symbol of left-hand  S 'is another congruence strategy g(S1',... ,S ')  m with f = g,or 
S 'is another congruence strategy f(S1',... ,Sn') and at least two strategies Si,Si',for i .{1,... ,n}, 
are mutually exclusive. We do not deduce any mutual exclusion if S 'is neither a set of rules nor a congruence 
; if S1 and S2 are mutually exclusive, then so are S1; S1 'and S2; S2', for any strategies S1',S2'. 
Indeed, let us consider a ground term t such that [S1; S1'](t)= Ø.In particular, we have [S1](t)= Ø,and 
then, if S1 and S2 are mutually exclusive, we get [S2](t)= Ø.Con­sequently, we have [S2; S2'](t)= Ø. 
By a symmetrical reasoning, we get that S1; S1 'and S2; S2 'are mutually exclusive ;  since a repeat 
*strategy never fails, repeat *(S)and a strategy S 'are mutually exclusive i. S '= fail.  The TRS Excl 
is given in Table 4. Lemma 3. Let S,S 'be two strategies. We have : 1. The reduction of mutex(S,S ') 
with Excl terminates and its normal form is either true or r. 2. If mutex(S,S ') '.E*xcl true,then S,S 
'are mutually exclusive.  We infer from Proposition 5 and Lemma 3 simpli.cation rules (26) and (27) 
in Table 5. Table 4: TRS used for simpli.cation: exclusive strategies mutex(l1 . r1 if c1,l2 . r2 if 
c2) '. {r if .µ = mgu(l1,l2): µ satis.es c1 . c2 true otherwise Excl = { mutex(id, S ') mutex(fail, S 
') mutex({.. . }1, {.. . }2) mutex({.. . }1,S ') mutex(dk(S1,... ,Sn),S ') mutex(dc(S1,... ,Sn),S ') 
mutex(first(S1,... ,Sn),S ') mutex(f(S1,.. . , Sn), {.. . }2) mutex(f(S1,.. . , Sn),g(S '1,... ,S 'm)) 
mutex(f(S1,.. . , Sn),S ') mutex(S1; S2,S ') mutex(repeat *(S),S ') '. {true if S '= fail r otherwise 
'. true '. (li.ri if ci).{... }i mutex(l1 . r1 if c1,l2 . r2 if c2) '. mutex(S ', {.. . }1)if S 'is nota 
setof rules '. n i=1 mutex(Si,S ') '. n i=1 mutex(Si,S ') '. n i=1 mutex(Si,S ') '. {true if .(l2 . r2 
if c2) .{.. . }2 : top(l2) = f r otherwise '. {true if f = g . n i=1 mutex(Si,S 'i) if f = g '. r if 
S 'is neither a set of rules nor a congruence strategy '. mutex(S1,S ') '. {true if S '= fail r otherwise 
 4.4 A correct and complete simpli.cation We now have obtained simpli.cation rules for all strat­egy 
operators. They are gathered in the rewriting system SIMPL on T (F.S, X) given in Table 5. Remark that 
al­though Comp, CO and Excl introduce symbols that are not in F.S, these symbols do not appear in SIMPL. 
Indeed, only normal forms for Comp, CO and Excl are involved in SIMPL, and these normal forms do not 
contain these sym­bols. The following theorem states that the transformation in­duced by the simpli.cation 
rules preserves both the seman­tics of the strategies and their termination behaviour. Theorem 2. Let 
S, S 'be two strategies such that S'. *.Then S and S 'are equivalent. SIMPLS ' As our simpli.cation 
preserves the semantics of the initial strategy, it can be used not only for proving its termination, 
but also as an assitance for writing programs : obtaining a clearer, simpler and more concise form of 
the program en­ables a better control on it and facilitates proofs of its prop­erties. Moreover, as the 
simpli.ed form of the programs often is a set of rewrite rules, properties like con.uence, suf­.cient 
completeness of the simpli.ed program, reachability test of a given value and characterization of computed 
val­ues can be studied and proved with classical methods of the rewriting theory. In addition, as the 
simpli.ed form of the programs computes the same results as the initial one, reachability tests and characterization 
of computed forms also hold for the initial program. 4.5 Ef.ciently computing the simpli.cation The 
e.ciency of the previously de.ned simpli.cation of strategies is closely related itself to the strategy 
the rules of SIMPL are applied with. For instance, to simplify fail; S, it is recommended to apply the 
rule (1) at the top position before trying to simplify S. We now propose an e.cient rewriting strategy 
to simplify a strategy with SIMPL.The strategy consists in attaching to each operator a strategy annotation 
[22, 12, 11], with the notation 0(i) for an attempt at rewriting at the top position without using the 
rule (i). first :[0(24) , 1, 0(24), 2,... , 0(24) ,n, 0] '''' ; :[0, 1, 0, 2, 0] dk :[0, 1, 0, 2,... 
, 0,n, 0] dc :[0, 1, 0, 2,... , 0,n, 0] repeat *:[0, 1, 0] f :[1,... ,n, 0] for f .F The above strategies 
attached to each strategy operator rely on the idea that we .rst try to rewrite at the top position, 
then simplify an argument if rewriting at the top is not pos­sible, then try again to rewrite at the 
top position, and so on. This strategy is somehow similar to the lazy strategy, but we need strategy 
annotations for a better control of the application of the rules, such as motivated by the simpli.­cation 
of first strategies. In particular, the strategy attached to the first operator guarantees that the rule 
(24) is tried on a first strategy S only when S has previously been simpli.ed by all other pos­sible 
rules. In fact, these other rules may remove arguments in S, while the rule (24) attempts at constraining 
each argu­ment. In addition to the strategy annotations of first and repeat *, we respectively require 
rules (24) and (25) to be applied only once, such as noticed at the end of Section 4.2. '''' For the 
strategy attached to the ; , the normalization of the .rst argument is required before reducing the second 
argument. Indeed, S1; S2 can be simpli.ed by rules (1) or (2) if S1 simpli.es respectively to fail or 
id,and by rule (3) if S2 simpli.es to id. Therefore S1; S2 has more chance to be reduced by simplifying 
S1 than by simplifying S2. But there is no clear preference for the order in which ar­guments of dk or 
dc strategies have to be normalized. We arbitrarily chose the leftmost order, but we could have cho­sen 
any permutation of the arguments. Let us come back to the example introduced at the end of Section 3, 
where Theorem 1 failed to prove termination of S = repeat *(first({f(a) . g(b)}, {f(x) . g(x),g(a) . 
f(a)})), because the extracted set of rewrite rules {f(a) . g(b),f(x) . g(x),g(a) . f(a)} was not e-terminating. 
Simpli.cation of S with SIMPL results in S '= repeat *({f(a) . g(b),f(x) . g(x) if x = a, g(a) . f(a)}). 
Theorem 1 succeeds in proving termination of S ',for the Table 5: Strategy simpli.cation rules system 
SIMPL fail; S'. fail (1) id; S'. S (2) S; id '. S (3) repeat *(fail) '. id (4) dk(S1,... ,fail,... ,Sn) 
'. dk(S1,... ,Sn) (5) first(S1,... ,fail,... ,Sn) '. first(S1,... ,Sn) (6) dc(S1,... ,fail,... ,Sn) '. 
dc(S1,... ,Sn) (7) first(S1,... ,id,... ,Sn) '. first(S1,... ,id) (8) first(S1,... ,repeat *(Si),... 
,Sn) '. first(S1,... ,repeat *(Si)) (9) { ''Ø if f = g m. f(S1,... ,Sn); g(S1,... ,S ) '''(10) f(S1; 
S1,... ,Sn; Sn) if f = g dk(S1,... ,Sn); S'. dk(S1; S,... ,Sn; S) (11) S; dk(S1,... ,Sn) '. dk(S; S1,... 
,S; Sn) (12) dk(S) '. S (13) first(S) '. S (14) dc(S) '. S (15) '''' dk(S1,... ,dk(S1,... ,S m),... 
,Sn) '. dk(S1,... ,S 1,... ,S m,... ,Sn) (16) '''' first(S1,... ,first(S1,... ,S m),... ,Sn) '. first(S1,... 
,S 1,... ,S m,... ,Sn) (17) '''' dc(S1,... ,dc(S1,... ,S m),... ,Sn) '. dc(S1,... ,S 1,... ,S m,... ,Sn) 
(18) n dk({...}1,... ,{...}n) '.{...}i (19) i=1n f({...}1,... ,{...}n) '.{f(l1,... ,ln) . f(r1,... ,rn)if 
ci} (20) i=1 (li.ri if ci).{... }i first(... ,Si,... ,Sj ,...) '. first(... ,Si,... ,...)if Si = Sj 
(21) dc(... ,Si,... ,Sj ,...) '. dc(... ,Si,... ,...)if Si = Sj (22) {...}1; {...}2 '. comp(l1 . r1 if 
c1,l2 . r2 if c2).Comp (23) (li.ri if ci).{... }i first(S1,... ,Sn) '. first(S1,... ,constrain(dk(S1,... 
,Sn-1),S) (24) n).COrepeat *(S1); S2 '. repeat *(S1); constrain(S1,S2).CO(25) first(S1,... ,Sn) '. dk(S1,... 
,Sn)if mutex(Si,Sj).Excl (26) i =j dc(S1,... ,Sn) '. dk(S1,... ,Sn)if mutex(Si,Sj).Excl (27) i =j (24) 
and (25) have to be applied once extracted set of rules to show termination of is {f(a) . g(b),f(x) . 
g(x) if x = a,g(a) . f(a)},which can be shown terminating by Proposition 3. Note that no simpli­.cation 
ordering enables to show termination of the set of conditional rules above. For details, see [10]. 4.6 
Examples Let us show on other examples how simpli.cation can both ease termination proof and make syntactic 
expression of strategies much clearer. We already showed in Example 2 that the strategy S = repeat * 
({f(x) . g(x),f(x) . h(0,x)}; {h(1,x) . f(1),h(x,y) . y,f(1) . h(1,1)}) simpli.es with SIMPL into S 
'= repeat *({f(x) . x}). Theorem 1 fails to prove termination of S,because the ex­tracted set of rules 
contains the rules h(1,x) . f(1) and f(1) . h(1,1), and hence is not e-terminating. However, e-termination 
of S 'is obvious, and ensures termination of S.Remark that S 'is syntactically much simpler than S, though 
equivalent. Example 4. Let us consider the following three labelled rules : [s1] f(x,y) . g(x,y) [s2] 
g(x,y) . y [s3] g(x,y) . f(y,x). The strategy S1 = first(first(s2,s3),first(s3,s2,s1)). rewrites with 
SIMPL into S1 '= s1 . s2. Then, while the strategy repeat *(S1) built on S1 cannot be shown terminating 
by Theorem 1, the equivalent strategy *(S 'S ' repeat 1) built on 1 can, by Theorem 1. Let us now consider 
the strategy S2 = first(first(s3,s2),first(s3,s2,s1)), which rewrites with SIMPL into S2 '= s1 . s3. 
 Then, though Theorem 1 fails to say anything about termi­nation of the strategy repeat *(S2) built on 
S2, it enables to show non termination of the strategy repeat *(S '2) and hence non termination of S2. 
The example above illustrates a case where non termina­tion of a strategy can be shown. Let us mention 
that the library provided with ELAN o.ers a strategy implementing a matching algorithm. The simpli.cation 
has made possible to show, in combination with Theorem 1, that this strategy was not terminating. The 
bug has been .xed since then. Example 5. The following strategy S = repeat *(first({f(x1) . g(x1) if 
x1 > 3}; first({g(x2) . h(x2) if x2 > 1}, {g(4) . g(4)},{g(x4) . f(x4) if x4 > 2}), dk({f(x) . g(x),f(x) 
. h(0,x) if x> 4}; {h(1,x) . f(1),h(x,y) . y,f(1) . h(1,1)}, f(x) . f(f(x)) if x> 5))) simpli.es with 
SIMPL into S '* = repeat ({f(x) . h(x) if x> 3}). Theorem 1 fails to prove termination of S, while it 
enables to prove termination of S '. Remark the important syntactic simpli.cation of the strategy. For 
details and complete development of examples, we refer the reader to [10].  5. CONCLUSION We have presented 
a criterion for proving termination of strategies lying on a simpli.cation process of these strate­gies. 
This simpli.cation is de.ned by a rewriting mecha­nism removing most of the operators in the strategy, 
and suppressing redundancy in application of its rewrite rules. Beyond the impact on the termination 
study, since a simpli­.ed strategy is syntactically much clearer than the original one, the simpli.cation 
process can be used as a helpful ver­i.cation tool for writing speci.cations. Another interesting aspect 
of our transformation is that it enables to infer for strategies other classical properties than termination. 
Indeed, when a strategy is shown, by simpli.­cation, to be equivalent to a set of rules, then one can 
deal with classical rewriting properties like su.cient complete­ness or con.uence on the simpli.ed form 
of the program, and even with reachability and characterization of normal forms of the initial program. 
A .rst interesting perspective is to extend this work to the full expressivity of ELAN. We now plan to 
study recur­sively de.ned strategies. Note that such strategies allow to encode, in particular, leftmost-innermost 
and leftmost­outermost rewriting, for which we are already able to prove termination with other techniques 
[1, 8, 9]. Then, in all its generality, an ELAN program is not only a combination of labelled rules, 
but a composition of labelled rules, together with a set of unlabelled rules, assumed to be con.uent 
and terminating, and whose leftmost-innermost normalization strategy is prede.ned. A data is normal­ized 
with the unlabelled rules between two rewriting steps determined by the user de.ned strategy. Since the 
unla­belled rules are evaluated leftmost-innermost, the previously cited existing methods for proving 
innermost termination of rewriting can be used. Their combination with labelled rules, under study, will 
be dealt with equational rewriting [23], by rewriting with labelled rules modulo rewriting with unlabelled 
rules. Another perspective is the use of our simpli.cation of the program at run time. We will now observe 
in which cases it will be more e.cient to replace the direct execution of the ELAN strategies, as ELAN 
has provided till now, by the rewriting process with the set of rules obtained by simpli.­cation.  6. 
REFERENCES [1] T. Arts and J. Giesl. A collection of examples for termination of term rewriting using 
dependency pairs. Technical Report AIB-2001-09, RWTH Aachen, Germany, September 2001. [2] P. Borovansk´y, 
C. Kirchner, H. Kirchner, and Ch. Ringeissen. Rewriting with strategies in ELAN:a functional semantics. 
International Journal of Foundations of Computer Science, 1999. [3] Peter Borovansk´y, Claude Kirchner, 
H´el`ene Kirchner, and Pierre-Etienne Moreau. Elan from a rewriting logic point of view. Theoretical 
Computer Science, 285:155 185, August 2002. [4] N. Dershowitz, M. Okada, and G. Sivakumar. Canonical 
conditional rewrite systems. In E. Lusk and R. Overbeek, editors, Proceedings of the 9th International 
Conference on Automated Deduction, volume 310 of LNCS, pages 538 549, 1988. [5] Nachum Dershowitz and 
Jean-Pierre Jouannaud. Handbook of Theoretical Computer Science,volume B, chapter 6: Rewrite Systems, 
pages 244 320. Elsevier Science Publishers B. V. (North-Holland), 1990. Also as: Research report 478, 
LRI. [6] M. Clavel et al. Maude: speci.cation and programming in rewriting logic. Theoretical Computer 
Science, 285:187 243, August 2002. [7] O. Fissore, I. Gnaedig, and H. Kirchner. Termination of rewriting 
with local strategies. In M. P. Bonacina and B. Gramlich, editors, Electronic Notes in Theoretical Computer 
Science, volume 58. Elsevier Science Publishers, 2001. Also available as Technical Report A01-R-177, 
LORIA, Nancy (France). [8] O. Fissore, I. Gnaedig, and H. Kirchner. CARIBOO : An induction based proof 
tool for termination with strategies. In Proceedings of the Fourth International Conference on Principles 
and Practice of Declarative Programming (PPDP), Pittsburgh, USA, October 2002. ACM Press. [9] O. Fissore, 
I. Gnaedig, and H. Kirchner. Outermost ground termination. In Proceedings of the Fourth International 
Workshop on Rewriting Logic and Its Applications,volume 71of Electronic Notes in Theoretical Computer 
Science, Pisa, Italy, September 2002. Elsevier Science Publishers.  [10] O. Fissore, I. Gnaedig, and 
H. Kirchner. Termination of elan strategies by simpli.cation Extended version. Technical report, LORIA, 
2003. Available at http://www.loria.fr/~.ssore/stratELAN/internal.html. [11] K. Futatsugi and A. Nakagawa. 
An overview of CAFE speci.cation environment an algebraic approach for creating, verifying, and maintaining 
formal speci.cations over networks. In Proceedings of the 1st IEEE Int. Conference on Formal Engineering 
Methods, 1997. [12] Joseph A. Goguen, Timothy Winkler, Jos´e Meseguer, Kokichi Futatsugi, and Jean-Pierre 
Jouannaud. Introducing OBJ. In Joseph A. Goguen and Grant Malcolm, editors, Software Engineering with 
OBJ: Algebraic Speci.cation in Action, chapter 1, pages 3 167. Kluwer, Boston, 2000. [13] Bernhard Gramlich. 
On termination and con.uence properties of disjoint and constructor-sharing conditional rewrite systems. 
Theoretical Computer Science, 165(1):97 131, September 1996. [14] M. Hanus. Reduction strategies for 
declarative programming. In B. Gramlich and S. Lucas, editors, Electronic Notes in Theoretical Computer 
Science, volume 57. Elsevier Science Publishers, 2001. Also available from http://www.elsevier.nl/locate/entcs/volume57.html. 
[15] M. Hanus and F. Steiner. Controlling search in declarative programs. In Principles of Declarative 
Programming (Proc. Joint International Symposium PLILP/ALP 98), pages 374 390. Springer LNCS 1490, 1998. 
[16] R. Kieburtz. A Logic for Rewriting Strategies. In M. P. Bonacina and B. Gramlich, editors, Electronic 
Notes in Theoretical Computer Science, volume 58. Elsevier Science Publishers, 2001.  [17] P. Klint. 
A meta-environment for generating programming environments. ACM Transactions on Software Engineering 
and Methodology, 2:176 201, 1993. [18] S. Lucas. Termination of (canonical) context-sensitive rewriting. 
In S. Tison, editor, Proc. of 13th International Conference on Rewriting Techniques and Applications, 
RTA 02, Lecture Notes in Computer Science, pages 296 310, Copenhagen, Denmark, July 2002. Springer-Verlag, 
Berlin. [19] A.P. Martin,P.H.B.Gardiner, and J.C.P Woodcock. A tactic calculus full version. Formal 
Aspects of Computing, 8(E):244 285, 1996. [20] Christian Schulte and Gert Smolka. Encapsulated search 
in higher-order concurrent constraint programming. In Maurice Bruynooghe, editor, Logic Programming: 
Proceedings of the 1994 International Symposium, pages 505 520, Ithaca, New York, USA, November 1994. 
MIT-Press. [21] Gert Smolka. The Oz programming model. In Jan van Leeuwen, editor, Computer Science Today,Lecture 
Notes in Computer Science, vol. 1000, pages 324 343. Springer-Verlag, Berlin, 1995. [22] J. van de Pol. 
Just-in-time: on strategy annotations. In B. Gramlich and S. Lucas, editors, Proceedings of the .rst 
International Workshop pn Reduction Strategies in Rewriting and Programming, WRS 01, volume 2359, pages 
39 58, 2001. [23] Patrick Viry. Equational rules for rewriting logic. Theoretical Computer Science, 285:487 
517, 2002. [24] Eelco Visser and Zine el Abidine Benaissa. A core language for rewriting. In Claude Kirchner 
and H´el`ene Kirchner, editors, Proceedings of the second International Workshop on Rewriting Logic and 
Applications, volume 15, http://www.elsevier.nl/locate/entcs/volume16.html, Pont-`a-Mousson (France), 
September 1998. Electronic Notes in Theoretical Computer Science. [25] Marian Vittek. ELAN: Un cadre 
logique pour le prototypage de langages de programmation avec contraintes.Th`ese de Doctorat d Universit´e, 
Universit´eHenri Poincar´e -Nancy 1, octobre 1994.  
			
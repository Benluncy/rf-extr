
 Dynamic Maintenance of Maximas of 2-d point sets Sanjiv Kapoor Department of Computer Science Indian 
Institute of Technology Hauz Khas, New Delhi 110016. e-mail: skapoor@cse.iitd. ernet.in Abstract This 
paper describes an efficient scheme to dynamically maintain the set of maximas of a 2-d set of points. 
Using the fact that the maximas can be stored in a Staircase structure, we use a technique which maintains 
approx­imations to the Staircase structure. We first show how to maintain the maximas in O(logn) time 
per insertion and deletion when there are n insertions and deletions. O(logn) is charged per change for 
reporting changes to the structure. We also show another scheme which re­quires O(logn) amortized time 
per insertion and deletion with an output complexity of O(r) steps when r maxi­mal points are to be listed. 
The data structures require O(n) space. 1 Introduction Given a set S of points in the x y plane, pi 
= (xi, yi) G S is a maximal point iff it is not dominated by another point pj where a point pj dominates 
pi iff xi < xj and yi < yj. The set of maximal points of S form a structure which monotonically decreases 
in the y direction as the x coordinate of the points increases. Such a structure is called a Staircase 
structure. The maxima problem occurs in a large number of applications in statistics, economics, operations 
research etc. The reader is referred to the book by Preparata and Shames for further details [PS] In 
this paper is described the design of a data struc­ture for the dynamic maintenance of the maximas of 
a point set. We maintain approximations to the set in a structure which is an approximate staircase structure. 
For the static case it has been shown that the staircase structure can be computed in O(nlogn) time eliminat­ing 
dominated points [KLP]. In the dynamic case however one needs to keep track of the dominated points. 
Permission to copy without fee all or part of this material is granted provided that the copies are not 
made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association of Computing 
Machinery. To copy otherwke, or to republish, requires a fee and/or specific permission. 10th Computational 
Geometry 64-6/94 Stony Brook, NY, USA @ 1994 ACM 0-89791 -648-4194/0006..$3.50 In this case Overmars 
and Van Leeuwen [OL] have designed a data structure which requires splitting and merging balanced trees 
when points are inserted and deleted. In their scheme 0(log2n) operations are re­quired for each insertion 
and deletion. A scheme by Willard and Luekar [WL] gives a bound of O(logn) for updates but the set of 
maximaa is not maintained. Fredrickson and Rodger [FR] and Janardan [J] have de­signed a scheme which 
maintains the staircase struc­ture of the set of maximaa and allows for insertions and deletions in O(logn) 
and 0(log2n) operations, re­spectively. These are the most asymptotically efficient schemes known. Their 
data structure requires O(n) space. Also [HS] gives a scheme for offline maintenance. We first present 
an improved data structure that main­tains the staircase structure in O(logn) time per inser­tion and 
deletion. A point can be tested to be a maxima in O(logn) time in our representation. And the staircase 
­structure representing the set of Maximas can be listed out in time linear in the size of the set of 
Maximae but with O(logn) operations to be spent on changes in the report of the maximal elements. The 
data structure is simple and requires O(n) space. Furthermore it is shown that the data structure can 
be modified to give a bound of O(nlogn + mlogn + r) operations when there are n insertions, m deletions 
and r maximal points are reported. We hope that the methodology that we have described may also be applicable 
to dynamic maintenance of other geometric structures, i.e. convex hulls, intersection of half planes 
and kernel of simple polygons. Since the optimal d ynarnic maintenance of these geometric struc­tures 
haa been unsolved for some time, the solution in this paper may be of interest in terms of technique. 
 2 Outline of the Paper. Thh paper first describes the structural changes required for maintaining the 
maximas under insertions and dele­tions. We then show how to implement the scheme in a data structure 
requiring O(n) space. The underlying data structure that we use for storing the points is the red-black 
tree [T]. It is called the Max­ima Balanced Tree. The set of points, S are stored at the leaves of a 
red-black tree, which we denote by LCZ (S), in order of increasing x-coordinate values. At each node 
is stored the set ofmaximasofa set ofpoints stored in the subtree rooted at that point. This set is not 
stored ex­plicitly aswewill see. Theinitial tree can reconstructed in O(rdogn) time easily. Let M(q) 
be the set of maxi­mas at node q in the tree. Furthermore assume that at each node the maximaa are specified 
in a staircase sorted order with points having decreasing y-coordinate and in­creasing x-coordinate. 
We let Top(.M(q)) represent the point with the maximum y-coordinate in the staircase structure representing 
the maximaa at node g. We let Y(P) refer to the y-coordinate of point p. The first scheme that is proposed 
uses the fact that during insertions binary search is performed only once after which the inserted point 
is dominated. This fact has also been used in [FR], [J] in their data structure. We thus obtain a solution 
with O(logn) insertion time and O(log2n) deletion time. Also isolated is the reason for the 0(log2n) 
behaviour of the scheme. Thh scheme is briefly described in section 3. In section 4, the algorithm is 
refined so that both insertions and deletions can be done in O(logn) time. We do so by maintaining approximations 
to the stair­case structure. This allows the use of only a constant number of binary searches to update 
the balanced tree structure storing the maximas. The improvements are described without a description 
of the secondary struc­tures required to store the maximas at the nodes of the balanced binary tree. 
Finally, in section 5, the space re­quirements are shown to O(n). In section 6 the scheme is modified 
to list the maximal points in linear amortized time. 3 An O(logn) insert ion and 0(/og2n) deletion scheme. 
Let us first consider insertions. Let p be the point to be inserted into the tree MT(S) storing the set 
of maxima-s of the point set S. Since the leaves are arranged in x­sorted order a binary search gives 
us the leaf at which the point p is to be inserted. Let P be the path from the root to the leaf. Suppose, 
on the path P, we encounter a triple of nodes (u, v, w) where v is the common parent of u and w. u is 
the left child and is referred to by left(v) and w the right child and referred to by right(v). P uses 
v and one of u and w. Firstly suppose the path P uses w. Suppose the max­ imas of the points in the 
subtree at w has been recom­ puted because of the insertion of the new point p. M(v) has to be recomputed 
from M(u) and M(w) by a merger. The merger, in general, involves locating Top(M(w)) in M(u) and then 
replacing the portion of M(u) dominated by M(w) by M(w) itself. However when a single point, p, is inserted 
M(w) changes only locally. The merger operation can now be accomplished by chamges to the current staircase 
structure instead of complete recompu­tation. There are a number of cases depending on the topmost node 
of M (w), Top(M (w)) where M (w) is the updated staircase structure at w. We isssume that Top(M (w)) 
has changed. If it does not, then no change in the merged staircase structure is requirecl. Case 1: Top(M 
(w)) is above Top(M(v)). In this case the merger requires constant time since M (I)) is actually M (w). 
(Fig. Ml) Case 2: Top(M (w)) is not above Z op(M((v)). In this case the merger is done by a binary search 
cm M(v) and requires O(logn) time. Note that from this node up­words to the root the top node of any 
staircase structure does not change and new merger points need not be re­computed. (Fig. M2) Next consider 
the case when P uses u. Again, suppose M(u) has been modMied and let the modified structure be M (u). 
There are two cases: Case 1: Top(M(u)) haa changed. There are two cases. If Top(M(uJ)) < Top(M (u)) then 
change lthe top node of M(v) to Top(M (u)) if necessary. Otherwise, change Top(M(v)) to Top(M(w)) if 
necessary. Case 2: Top node of M(v) haa not changed. In this case we have to determine the changes that 
are to be made to M(v) since the top of M(w) has to be posi­tioned with respect to the changes in M(w). 
We note that this can be done in constant time sines only a com­parison of Top(M(w)) with the point inserted 
into M(u) and points adjacent to it has to be made, provided that node is in the set of maximas. This 
information is easily maintained aa we proceed up the path P. (lFig. M3) We thus see that an O(logn) 
insertion is l?ossible since binary search is performed once only in Case 2 when P uses w. Next consider 
the affect of deletions. Again consider a path P from leaf to root and a triple of nodes (u, v, w) on 
the path. The path may use either u or w. First consider the case when the path P uses w. Suppose the 
maximal set haa been recomputed at w and is M (w). There are two cases depending on Top(M(w)): Case 1, 
where Top(M (w)) changes. Thh case has ltwo sub cases. And Case 2 when Top(M(w)) does not change. We 
con­ sider the subcases. Case 1.1: Top(M (w)) < Top(M(u)). Then M(v) can be computed in O(logn) time 
by locating Top(M (w)) in Top(M(u) by a binary search. Case 1.2: Top(M (w)) > Top(M(u)). Update Top(M(v)) 
in O(1) time since M(v) is M (w). Case 2: Top(M(w)) does not change. M(Iu) changes ex­ . actly as M(w) 
is changed in the portion of the staircase common to both M(u) and M(w). In this case the list at v need 
not be searched but only changed at Z op(ilf(w)) to incorporate Af (w). Next consider the case when the 
path P uses u. M(v) is obtained from M (u) and M(w) by a merge operation and requires O(logn) operations. 
It is the first sub-case of the first case when the path uses w and u that creates the first problem, 
i.e. it gives a time bound of 0(log2n) since the merge of M (u) and M(uJ) requires O(logn) time due to 
search for Z op(M(w)) in M (u) and there may be fl(logn) such merges to be performed. Also Z op(Af (w)) 
may be changed at O(logn) nodes along path P. Finally we consider the rebalancing operations. They can 
be per­formed in O(logrz) time since the balancing requires at most O(1) locations of top nodes of staircase 
structures. Next we show how to improve the performance to O(logn) per deletions also. 4 An Improved 
Solution. 4.1 Outline. In order to improve the performance we attempt to re­move the bottleneck introduced 
by the repeated mergers that are required on path P when ill (u) and AZ(w) are merged after a deletion. 
This is done by performing a constant number of mergers as follows: Let Mset(P, u) be the set of nodes 
on the path P with the following property: Z op(M(wi)), Wi. E Mset(P, u) intersects the section of the 
staircase in Af(u) that is changed due to the deletion. Note that Wi is an ances­t or of u and [Mset 
(P, u) I = O(logn). Only one merger is required and that is the merger with the maximal set kf(wk) where 
wk is the node in the binary tree such that Top(it!f(wk)) exceeds the top, Z op(M(w~)), of all other 
nodes in the set Mset(P, u). All the other mergers re­quired are deferred by actually constructing the 
chains so that Af(w~), Wi 6 Mset(P, u) is merged with M(u), where w is the sibling of Wi , by joining 
Top(M(wi)) to either the node in M(u) at which M((wk )) is merged or to Z op(M(~)). This construction 
is required for a constant number of sets, Mset(P, u) corresponding to nodes u on the path P. This destroys 
the staircase na­ture of the maximal set; creating non-horizontal and ver­tical lines called kinks but 
the deletion now requires O(logn) steps. The insertion also requires O(logn) steps. It may so happen 
that during insertion or deletion the node at which the kinksn occur changes. The kinks thus shift, 
However we show that the shift only occurs once on the path and there are only O(iogn) edges to be transferred 
at the kinks. 4.2 Detailed Algorithm. We first formally define the semi-staircase structure at the nodes. 
 The Semi-staircase structure is a sequence of nodes, simultaneously sorted in increasing x order, and 
in de­creasing y-order such that two adjacent vertices are ei­ther connected by a horizontal and vertical 
Manhattan path or by a straight line (called kiik line). (Fig. M4) A Stairstep is the horizontal and 
vertical Manhattan path that connects two adjacent vertices. The kink line (u, v) is an approximation 
to a staircase structure which connects the two vertices u and v. We need the following property of klmks 
which will be proved later. Property Cover: Every kink line connecting a point u, which is not mzmimal, 
to another point v is dominated by a horizontal edge or a kink edge, i.e. there exists a point, c with 
greater y co-ordinate than u and greater z co-ordinates than u and v. When the point c is connected by 
a horizontal line to a point s with y-coordinate equal to or just above that of v, s is called the kink-cover 
of the kink line. Note that such a point need not always exist, e.g. it does not exist when v is the 
top node of a staircase structure. Note also that we may obtain a sequence of kink lines. The Cover property 
is also satisfied for each edge of this sequence and hence by the entire sequence. We next show how to 
dynamically maintain this semi­staircase structure under insertions and deletions. 4.3 Insertions We 
first consider Insertions. For inserting point p let P be the path from leaf to root. As we proceed up 
the path consider the triple of nodes (u, v, w) such that v is the parent of u and w. Suppose the path 
P uses w. The cases are similar to the previous section and involve a binary search with Z op(M(w) onto 
a semi-staircase structure. The first change in the algorithm occurs when y = y(Z op(M(w))) intersects 
a kink line joined to v. In this case a new kink line is introduced from Z op(M(w)) to v. The second 
change is when at a node w, Top(M(v)) is connected by a kink edge to a node in M(u) and the node to which 
the kink edge is connected is removed by the insertion of a point. Top(M(v)) is then located within the 
new stair­case in constant time by computing the intersection with the stairstep newly introduced. Thus 
as in the previous section one location of Top(M(w)) in a semi-staircase structure is required. Before 
detailing the location of Top(M(w)) we de­scribe in general the procedure for the location of a point 
pin a semi-staircase. The procedure is recursive. At any node v in the tree we check if the point is 
located in the . part of the semi-staircase at the left son or at the right son and we recur in the 
appropriate sub-tree. This check is done as follows: Suppose w and u are the right and left sons at IJ 
and itf(w) is merged with ikf(u) by a hori­zontal edge, h. Then the procedure branches to the left if 
y(p) is greater than the y co-ordinate of point on h otherwise the procedure branches to the right. Alter­natively, 
if at u there is a kink edge merging the right semi-staircase with the left then the procedure recurs 
at the left. The procedure stops at a leaf having discovered on the staircase a point with y co-ordinate 
just greater than y(p). This is the node to which p is located. The procedure requires O(iogn) steps. 
Also those O(logn) kink edges on the search path which intersect y = y(p) are obtained. To update the 
staircase structures after the location of a point is done, suppose the node to which the location is 
done is q . Firstly the edge joining Z op(lkf(w) to q is added to the semi-staircase structure at v. 
Next the kink edges intersected by y = y(s) have their top point changed to the node in the staircase 
just below q if such a node exists. Else the kink edges become horizontal edges. When path P uses u, 
the update after an insertion is again in constant time as described in the previous section. Thus insertions 
can be done in O(logn) steps. Deletions Next consider deletions: Again consider the triple (u, v, w). 
Suppose P, the path from the leaf deleted (cor­ responding to point q) to the root, uses w. We consider 
the case depending on whether M (w) has it s topnode different from M(w) or not. Case 1.1: Top(M (w)) 
is changed, i.e. the topmost node of the previous maximal set has been deleted. In this case Z op(M (w)) 
is to be located again in M(u) to construct M(v). There are two subcases: Either the new topmost node 
is the topmost node of M(v). In this case the check is done in 0(1) time. On the other hand the topmost 
node has to be relocated within M(u) in O(logn) time. However we need to do this only when the set of 
maximas is tiected. Before we consider the number and type of such relocations required we describe in 
detail one such relocation: There are two possible situ­ ations depending on whether the previous topmost 
node is connected by a kink edge or not. We first consider the situation when the topmost node in M(w) 
is not connected by a kink edge to a node in M(u) but by a horizontal edge. Let q be the node in M(u) 
to wKlch the topmost node in M(w) was con­ nected. The relocation depends on whether or not other nodes 
were connected by kink edges to the node q. If no other nodes were connected then the relocation is simple. 
The relocation is done onto a staircase structure M(u). When kink edges are present at the node q, relocation 
of the topmost node may destroy the semi-staircase struc­ture and changes have to be made to preserve 
the serni­staircase structure and the cover property. We describe these changes next. When other kink 
edges are present relocating Top(M (w)) involves two sub-cases. Either the top node of M (w) is relocated 
below the kh-ik edge (s, g), where s is the point at the first descendant node of u attached to q by 
a kink edge. Or onto the kink edge. Let d be the node at which s is attached to q by a kink edge. Note 
that s G M(right(d)) where right(d) is the right son of d. s is located in the staircase structure at 
left(d). Sup­pose the node to which the relocation is done is q . Next, all the kink edges intersected 
by y = y(s) have their top point changed to the node in the staircase just below q if such a node exists. 
Also Top(M (w)) is relocated in the changed structure M (u). All the operations require O(logn) time 
since atmost two locations are done and at­most O(logn) kink edges have their top point changed. In the 
second sub-case, i.e. when !Z op(M (w)) is lo­cated onto the kink edge, Z op(M (w)) is located in M(u) 
by a procedure similar to the one which locates s in the above case. And all the kink edges intersected 
by the horizontal edge are changed. In this case too O(logn) steps are required. Next consider the situation 
when Z op(M(w)) was con­nected by a kink edge to a node q in M(u). Again, let s be the point first attached 
to q by a kink edge at a descendant node of u (if such a node exists). Either the y-coordinate of Z op(M 
(w)) is less than that ofs or not. Firstly consider the case when Top(M (uJ)) < y(s). Then Z op(M (w) 
is relocated in the staircase structure at M(u). Furthermore s may be located also, modify­ing kink edges 
intersected by y = y(s) as in the above case. Next, consider the case when Z op(M (w)) > y(s). Then a 
kink edge from Z op(M (w)) to q maybe retained in the merge step or Top(M (w) may be located in the staircase 
structure modifying the kink edges from s and other nodes as described in the previous paragraph. We 
next characterize when the relocation of points in the semi-staircases is necessary: Let Uset be the 
set of nodes, whose Top has changed due to the deletion of the particular node. Note that the Top value 
of these nodes is in increasing order of y-coordinate. A relocation is done at the node, say t,with the 
highest Top value. Furthermore, consider a node u, u # t and u E Uset. u is not relocated but Top(M(right(u))) 
is joined to Z op(M(ieft(u))) by a kink edge. Case 1.2: Top(M (w)) has not changed. In this case no changes 
are required in the merger step and the com­position of itf (w) and Ikf(v) is carried upwords in O(1) 
time. Next suppose the path P uses u. We assume by in­duction that M (u) has a semi-staircase structure. 
Case 2.1: M(w) intersects M(u) at the stairstep asso­ciated with the removed node. Let R(q) be the semi­staircase 
that replaces the node q deleted. R(q) is ob­tained as we traverse up the path P. We let S be the set 
of nodes on the path P such that if v c S then Top(M(v) intersects the stairstep associated with q and 
thus R(q). Let w be the node in S such that Top(M(w)) > Top(M(u)), u c S. Then Top(M(w) is located in 
R(q) to give a node z which forms the node above Top(M(w)) in the semi-staircase structure at the parent 
of w. Otherwise a direct line (kink line) is drawn from Top(M(u)), u E S to a node i! in R(q) where t 
is the node in R(q) with y-coordinate just less than z and greater than Top(M(w)). If such a tdoes not 
exist then either a normal staircase is constructed with z being the node next in the semi-staircase 
structure at the parent of u. Also if t is not present in M(w), where w is the sib­ling of u, then Top(M(u)) 
is connected via a kink line to Top(M(w)). Note that this procedure involves delaying the construction 
of the straight lines until z is obtained. All the merges required can be done in O(logn) time. (Fig. 
M5) Case 2.2: M(w) does not intersect M(u) at the stairstep associated with the changed node. Then no 
change in the merger need be done. The above cases complete the description of the changes required after 
a deletion. It is easily seen that O(logn) steps are required. Furthermore, baIancing re­quires O(logn) 
steps as each rotation or double rotation requires at most O(1) relocations of topmost nodes giv­ing 
a bound of O(logn) steps. Note however that at the end of the deletion some kinks may be left on the 
final staircase structure at the root. We next show that the insertion and deletion proce­dures are correct. 
It suffices to show that a semi-staircase is maintained at each of the nodes and also that the cover 
property is maintained. Lemma 1 The insertion and deletion procedure main­tains semi-staircases at each 
node of the Mazima Bal­ anced Tree. Moreover the semi-staircase structures sat­isfy the cover property. 
Proof: The proof is by induction. It is trivially true when there is only one point. Thus sssume that 
there are n points and the data structure contains lists which are staircase structures. If an insertion 
is made the operation only introduces a kink edge when the inserted node is located onto a kink edge 
in the staircase structure. The new kink edge added maintains the semi-staircase structure and also the 
cover property since either the kink edge is the dominating edge or the dominating edge is unchanged. 
 When a deletion is performed, the operations firstly introduces kink edges by finding the node closest 
to the root which intersects the modified staircase and locating it in the staircase structure. All other 
edges added at descendant nodes are kink edges and valid, i.e. joining a point in the right subtree to 
a point in the left subtree unless the point is at the top. These also include kinks introduced by adding 
edges from the Top of staircases at the left son to the Top of staircases at the right sons. The cover 
property is main­tained since each kink edge (u, v) is covered if it has been determined if u is not 
in the maximal set. Also when kink and cover edges are modified by locations the semi­staircase structure 
and cover property are maintained as detailed by the construction procedure. This is also true after 
balancing of the tree. z Since the cover property is maintained at the nodes of the tree kinks in the 
output are important in that these kinks have to be removed to obtain the actual out­put. These kinks 
can be removed at the time of report­ing along with other kinks that are discovered when the kinks are 
removed resulting in an output complexity of O(m + (chng)iogn) when there are chng changes in the set 
of maximaa to be reported. Details of the report­ing will be discussed in the next section. Once removed 
these kinks do not occur again in the output. To summarize Lemma 2 The structural changes required to 
maintain the semi-staircase structures at each node of the Maz­ima Balanced !?kee under insertions and 
deletions can be cam ed out in O(logn) operations. Moreover O(logn) operations are required for every 
change to be reported in the mazimal set. 4.5 An O(n) Space Solution In this section we show how to 
implement the scheme for insertion and deletion in O(n) space. Thh is accom­plished by maintaining O(1) 
information at the nodes of the balanced binary search tree. Firstly at each node, v, is maintained left 
and right pointers, left(v) and right(v), to the sons of the node, say u and w. We also maintain two 
variables TOP and INTER which contain points. TOP is the top­most point in the semi-staircase structure 
at v (This point is also referred to by Top(M(w)) before). And INTER is the node at which Top(M(w)) is 
located in the semi-staircase structure at u, i.e. INTER is the point in the staircase structure at v 
just above the point TOP at node w in the staircase structure at v. Note that Top(M(w)) may be attached 
to INTER by a kink edge. In the description below the value of INTER for nodes where a kink line is drawn 
is sssumed to be the y-coordinate of the upper point of the kink line. To list the points more efficiently 
we need another variable CHANGE which we detail below. We next describe the listing and search procedures 
on the data structure without using CHANGE. 4.6 Listing the maximas To list all the maximas we proceed 
as follows: We start at the root. At the root node TOP gives the first node in the staircase structure. 
To obtain nodes contributed by the left subtree we test if the topmost node of the right subtree, UJ, 
is located strictly below the topmost node of the left subtree, w If so then we list, recursively, those 
maximal elements in the subtree at u not yet reported and with y co-ordinates greater than the y-coordinate 
of TOP(right(w)). We then list the maximal elements in the subtree rooted at w recursively. When we apply 
thh procedure recursively we note that at a node the left son may be merged with the right son using 
a kink edge. We thus first remove this kink edge before recurring. This procedure is formalized as follows: 
LIST(V, stop, last); (This procedure lists the maxima in the subtree at v with y-cordlnate greater than 
stop. last is the y-coordinate of the last maximal point output.) Begin If last > y(TOP) ~ stop then 
begin output TOP; last := TOP end; else begin if (right son is connected to left son by a lhk edge) then 
LOCATEY( Top(right(v))); if y(Z OP) > y(INTER) then begin LIST(left, y(IN TER), last); LIST(right, stop, 
last) end else LIST(right, stop, iast) end end. We now describe the implementation of the locate pro­cedure, 
LOCATEY. The locate algorithm has been de­scribed before. Suppose we are at a node v and wish to search 
for the horizontal location of p in the semi-staircase structure at v. There are two cases: Suppose y(INTER) 
is less than y(TOP). If y(p) > y(lNTER) then we recursively search in the left subtree. And if y(p) ~ 
y(TOP(uI)) where w is the right son of the current tree node then we recur to the right. Otherwise we 
get two subcases. If INTER is TOP because of a kink edge from the right son to the left son then locate 
y(p) in the left subtree again. Otherwise we return with INTER i~ the node required. Note that this procedure 
requires O(logn) time. A list of kink edges along the path s.t. y = y(p) intersects the kink edge is 
also obtained. These edges are modified so that their top end is y(p) thus modifying the staircase structure 
as described before. The procedure, LIST, above is invoked at the root with stop being the least y-coordinate. 
We ornit the proof of correctness. The procedure requires time pro­portional to O(rrdogn) where m is 
the numl>er of maxi­mal points. To list the maximal points in O(m) time we make the following modification 
to the data structure: At each node, say v, we store a pointer called CHANGE. CHANGE points to the first 
preorder descendant node where a change to the staircase structure at v is made. If INTER(v) < TOP(v) 
then CHANGE points to the first node , say u, in a preorder scan of the left sub­tree rooted at v where 
TOP(right(u)) > INTER(v). If TOP(v) = TOP(right(v)) then CHANGE(v) is the same as CHANGE(right(v)). It 
is easy to see that using these pointers we can re­cursively list the maximas in linear time. Thh includes 
the time required to remove kinks along the staircase structure. The following scheme does so: LIST(V, 
stop, hzst); (This procedure lists the maxima in the subtree at v with y-cordinate greater than stop) 
Begin If last > y(TOP) ~ stop then begin output(TOP); last:= TOP end; else begin if (right son is connected 
to left son by a kink edge) then LOCATEY( Top(right(v))) and update CHANGE using LOCATE CHANGE. if y(TOP) 
> y(INTER) then begin LIST(CHANGE, y(INTER), last); LIST(right, stop, last) end else LIST(CHANGE, stop, 
last) end end. Note that the procedure LOCATE CHAINGE is in­voked to find the value of CHANGE at every 
node. This is required since this value is not updated at ev­ery node during the deletion operation when 
kink edges are constructed. The procedure LOCATE CHANGE will be described later in the section. Before 
LOCATE CHANGE is invoked the kink is removed by locat­ing Z OP(right(v)). This requires O(logn) steps 
for every kink removal. Since the corresponding point is not in the previously reported output (else 
the khik would not be present) the complexity of the procedure is O(m + chng(logn)) where m is the number 
of maximaz and chng is bounded by the number of changes in the set of maximas since the last report where 
every change involves removal of a kink. We next show that the pointers CHANGE can be assigned at each 
node initially in 0(1) amortized time. This requires the use of a stack to maintain a list of nodes at 
which relevant changes to the current staircase structure have taken place. The top of the stack gives 
a candidate to be assigned to CHANGE at the cur­rent node, say v, as we traverse up the tree to the root. 
It is the first descendant node in preorder at which a change in the staircase structure takes place. 
Note that at this node, say u, Z op(~ight(u)) was located within ikf(le~t(u)). The next item in the stack 
has the same property, i.e. it is the first descendant node v of the cur­rent node with the property 
that INTER(v) is greater than the value of INTER at the current node. The stack contains nodes, v, such 
that INTER(v), is in increasing order for the nodes as we go from top to bottom in the stack. To obtain 
a stack and to assign a value to CHANGE at the current node, v, we adopt the following proce­dure. At 
node v, TOP(right(v)) is located within the staircase structure at lefl(v). If the location is such that 
TOP(right(v)) exceeds TOP(lefi(v)) then the value of CHANGE is the same as the one at right(v) and the 
stack at the current node is the same as the stack on the right son. If TOP(right(v)) is below TOP(Zeft(v)) 
then CHANGE is obtained from the stack of CHANGE val­ues at left(v) as follows: Let Can be the node on 
top of the stack. If the y-coordinate of INTER(v) is ~ y­coordinate of INTER at Can then Can is removed 
from the stack and a new candidate is obtained from the top of the stack. This removal is repeated until 
we find a node on the stack at which the y-coordinate of INTER is above the y-coordinate of INTER(v). 
CHANGE at v is then assigned to be this node. Moreover the modi­fied stack obtained from the left son 
is updated with v and the stack at right(v) is removed from further consid­eration. The initialization 
of CHANGE can be done in constant amortized time at the nodes since once a node is deleted from a stack 
it is not considered again. We finally describe the procedure LOCATE CHANGE. This procedure is used when 
the merge of the right son with the left son at v is done by a non­kink edge using LOCATEY. In this procedure 
let yP be the y-coordinate of the located point. A candidate, say Can for CHANGE is obtained from the 
value of CHANGE at the staircase structure at the left son of V. If Yp 2 v(INTER(Can)) a new value of 
Can is ob­tained from the CHANGE value at the node currently assigned to Can and the process repeated 
until we find a node at which INTER has greater y-coordinate than yp. Such a node exists when this procedure 
is called and CHANGE is assigned this node. At each step the height of Can decreases. Thus this procedure 
requires O(logn) steps.  4.7 Searching for Dominance In this section we show how to determine if a given 
point, p, is dominated by the set of maximas or not. We do so by a search for the y-coordinate of the 
given point in the set of points with greater x-coordinates. Let P be the path from the root to the leaf 
where the z-coordinate of the point p is located. Let R be the set of roots of the subtrees to the right 
of path P. It suffices to check if Y(P) > Y(TOP(V)) for all v c R. If it is, then the point is not dominated 
otherwise it is. 4.8 Insertions and deletion To bound the time for insertions and deletions in the data 
structure we note that the crucial step while per­forming insertions and deletions is that of locating 
the topmost node of a semi-staircase structure in another semi-staircase structure. This is problem LOCATEY. 
An O(logn) solution to this problem has been presented above in the O(n) space data structure. Moreover 
the 0(1) rotations required can also be done in O(iogn) steps since they require O(1) mergers, each requiring 
O(logn) steps. The variables TOP and INTER stored at the nodes at which relocations are performed can 
also be modified in O(logn) steps. Note that the value of INTER can be obtained by using LOCATEY. The 
value of TOP is immediately avail­able. We would also like to update the value of CHANGE at the nodes. 
We consider the insertion path P(p) for a point p. Let Cp be the node at which p is located within a 
staircase structure. Below that node, p is at the TOP of the staircase structures. Also let CUbe the 
node at which p is removed from the staircase structures. Above this node p is no longer on the staircaze 
and will not affect the value of CHANGE at these nodes. The procedure which modifies CHANGE values is 
similar to the ini­tialization procedure. For nodes below CP the value of CHANGE. is not modified. The 
value of CHANGE at Cp is computed from the left son of Cp by the procedure LOCATE CHANGE which has been 
described before. For nodes above + upto c. the value of CHANGE is+ unless a change in the current staircase 
structure takes place. Again if the change is below the y-coordinate of p the change is stacked. And 
if the change is above the y-coordinate of p then CPis removed from further consid­eration and the value 
of CHANGE need not be changed at this node and above since the value of INTER is un­changed. Furthermore 
the entire insertion procedure requires O(Zogn) steps since at most O(logn) values are stacked or popped 
while recomputing CHANGE on P(p). And LOCATE CHANGE is called only once. A similar procedure to update 
CHANGE is used when a point is deleted. Firstly, note that only 0(1) lo­cations which require a binary 
search are performed dur­ing a deletion. Thus O(1) LOCATE CHANGE calls which requires O(logn) operations 
are required. When kink edges are added only O(1) work is required to up­date CHANGE. Modification of 
CHANGE along the deletion path is done using stack manipulations as in the insertion case and requres 
O(logn) time. We next show how to rebalance. We consider single rotations only. The procedure is similar 
for double rota­tions. Let v be the node at which a rebalancing opera­tion is performed. At the nodes 
affected by the rebalanc­ing CHANGE is obtained by the procedure LOCATE CHANGE described above. Also 
the rebalancing may affect the value of CHANGE above v. Note that rebal­ancing changes the value of INTER 
at two nodes. The procedure for updating CHANGE above v is similar to that for updating CHANGE at nodes 
above CP in the insertion case when point p is inserted. Note that the initial nodes to be stacked to 
compute CHANGES are chosen from the nodes affected by the balancing. Thus updates to CHANGE after rebalancing 
can be done in O(logn) operations. We state our final result: Theorem 1 The mazimas of a set of point 
can be main­tained in a data structure which uses O(n) space and which requires 0(20gn) operations per 
update when O(n) points are deleted or inseFted. The output complexity is O(m+(chng)logn) when m points 
are FepoFted and when there have been chng changes since the iast Fepod.  5 An improved amortized Bound 
In this section we show how the maximas can be reported in ~lnear amortized time. To improve the reporting 
bound we note that the O(logn) factor in the reporting time bound essentially arises because a point 
repeatedly occurs in the changes in the maximal set, i.e. it occurs, is removed from the maximal set 
by an insertion, and then re-occurs in the set of maximas. Thus its location in the staircase is to be 
determined at each step. To remedy this we keep thh location as follows. Let p be a point and let v be 
a node in the tree where the point p first occurs withh-i a semi-staircase, i.e. not at the top of the 
semi-staircase at v. At this node the point has to be located within a staircase structure. This location, 
LO C(p), is important since it may need to be redetermined during deletions. So we keep this location 
with the point. However this lo­cation is not updated at every insertion or deletion since only the top 
points in a staircase are manipulated. Thus when thh point is to be output the value of LOC(p) may need 
to be updated. If the location requires a bl­nary search the time for thb search is charged to a point 
that is inserted or deleted and changes this value. We prove this below: Lemma 3 EveFy update of LOC(p) 
for p [~ M(S), the set of mazimas of a point set S, can be charged uniquely to an insertion or a deletion. 
Proof: To prove the lemma, suppose LOC(p) for point p is modified. Let u be the node at which LOC(p) 
is mod­ified and let v be the son of u on P(p) where P(p) is the path from the leaf to the root. The 
relocation is required when p is added to the set of maximas. The modification must be due to an insertion 
or a deletion since the last time p was added to the set of maximaz. Since the Top of every node is updated 
during the insertion procedure, p cannot be at the top of the staircases at v when insertions affect 
v. Thus p must have become the topmost node of a staircase structure due to a deletion and moreover the 
top node of the staircase structure at v just prior to this event must be above the topmost node of the 
sibling else p would have been located. (we are referring here to the deletion procedure described in 
section 4). Thus if p is to be relocated by a search requiring more than O(1) time the corresponding 
section of the staircase at w, the sibling of v must have been modified. The loca­tion is charged to 
the deletion or insertion that modified the section. Note that other points which have the same LOC value 
as p are also affected by the same deletion or insertion. Let this set be called OTHER. The points in 
OTHER are dominated by p since p is maximal and the location of p introduces kink edges from these points 
to the located point. Moreover the points in OTHER can be ordered by domination since they lie along 
the path to the leaf where LOC(p) is present iIIl the Maxima Tree. The topmost kink edge becomes important 
and is removed either when p is deleted or when the maximas are to be reported. Either the first point 
in OTHER is in the set of maximas or some other point dominating it is. The location at this step is 
charged to p and points in OTHER associated with the point locatecl at thh step. To summarize the details: 
With each point, p we asso­ ciat e a set OTHER(p). Thb is the set of points whose LOC will be affected 
due to the deletion of p. The relo­ cation of a point occurs when the point becomes a maxi­ mal element 
and there is a khk line from the point in the staircase structure. This happens in two ways. Firstly 
when the point, p becomes the Top point at a node dur­ing a deletion of a node which was the old Top 
point of the staircase structure containing pat the node and when LOC(p) has changed. The other event 
happens when the point, p, is to be located onto a staircase structure on which the deleted point was 
located. In the first caae the location is charged to the deleted point which intro­duced the modified 
semi-staircase at that node. Note that only one location is done. Other points connected by kink lines 
and which are encountered during the loca­tion are assigned to the located point, p, by adding them to 
the set OTHER(p) since these points will be affected due to the deletion of p. In the second case the 
location of p is charged to the deleted point that forced the loca­tion, say q, and the elements of OTHER(q) 
are assigned to OTHER(p). Thus a deleted point is charged twice, once in the first case and once in the 
second. The second type of charging is part of the deletion process whereas in the first case a kink 
is removed from the output and a previous deletion is charged. Finally, note that the LOC values do not 
change due to rotations and double rotations. The lemma follows. Note, while maintaining LOC(p), CHANGE 
values at tree nodes also need to be maintained. This in­volves computing CHANGE by a call to LOCATE 
CHANGE and updating CHANGE on the path from the leaf to the root. This is done by a procedure simil­ar 
to that which updates CHANGE during insertions and requires 0(/ogn) steps. We thus have the following 
result: Theorem 2 The set of Mazimas of a aet of points in the plane can be maintained in O(nlogn + mlogn) 
oper­ations when there are n insertions and m deletions. The data structure requires linear space. Moreover, 
r mazi­ mal points can be listed out in O(r) operations.  6 Conclusions and Acknowledgements. We have 
shown efficient schemes for dynamically main­taining the set of maximas of a set of points in 2­dimensions. 
We do so by maintaining approximate in­formation. This technique can also be applied to main­taining 
maximas in higher dimensions with less effective results. Maintaining the maximas efficiently under both 
deletions and insertions in higher dimensions is a chal­lenging problem. ThhJ technique has also been 
applied to convex hulls by the author but the results do not give optimal insertion and deletion time 
as yet. The results will be reported elsewhere. Other applications of this technique would be interesting. 
I would like thank A. Dutta and S. Sen for helpful discussions. I would also like to thank MPI-Informatik, 
Germany for providing support during the final part of the work. References [FP] [GR] [HS] [J] [KLP] 
[OL] [T] [WL] F.P. Preparata and M. I. Shames, Computa­ tional Geometry- An Introduction, Springer Verlag, 
(1985). G.N. Fredrickson and S. Rodger, A new ap preach to the dynamic maintenance of maxi­mal points 
in a plane, Discrete and Computa­tional Geometry, 5, 365-374, 1990. Hershberger and Suri, Offline Maintenance 
of Planar Configurations, SODA, 1991, pp. 32­ 41. R. Janardan, On the dynamic maintenance of maximal 
points in the plane, 40(2)(1991) 59­ 64. H.T. Kung, F. Luccio, and F.P. Preparata, On finding the maximas 
of a set of vectors, J. Assoc. Comput. Mach. 22, 4 (1975), 469-476. M.H. Overmars and J.L. Van Leeuwen, 
Main­tenance of configurations in the plane, J. Comp. System SC, 23 (1981), 166-204. R.E. Tarjan, Updating 
a balanced search tree in O(1) rotations, IPL 16 (1983), 253-257. D.E. Willard and G.S. Luekar, Addhg 
range restriction capablMy to dynamic data struc­tures, J. Assoc. Comput. Mach. 32, 3 (1985), 597-617. 
  L> ------T \ M(u) M(w)% Fig. Ml Mergel Fig. M2 Merge2 -.. ---z M (u) 1I Mu M(w) \ Fig. M3 Delete 
Covenngline w .................................................. I I -1 I .-, -. Fig. M4Semi-Staircase 
Structure. Semi-Staircase structuresM(a) L--l ._l===EM::,::,?<-T .-..-.-*.:. ..................-. .-.:.=. 
 . Fig. M5. Deletion of node v. 
			
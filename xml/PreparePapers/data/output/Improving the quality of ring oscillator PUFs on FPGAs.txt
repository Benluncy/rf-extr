
 Improving the Quality of Ring Oscillator PUFs on FPGAs Dominik Merli Fraunhofer Institute for Secure 
Information Technology Munich, Germany merli@sit.fraunhofer.de  Frederic Stumpf Fraunhofer Institute 
for Secure Information Technology Munich, Germany stumpf@sit.fraunhofer.de Claudia Eckert Dpt. of Computer 
Science Technische Universität München Munich, Germany eckertc@in.tum.de ABSTRACT Physical Unclonable 
Functions (PUFs) based on Ring Oscil­lators (ROs) are a promising primitive for FPGA security. However, 
the quality of their implementation depends on several design parameters. In this paper, we show that 
ring oscillator frequencies strongly depend on surrounding logic. Based on these .ndings, we propose 
a strategy for improving the quality of RO PUF designs by placing and comparing ROs in a chain-like structure. 
We also show that an in­creased RO runtime and RO disabling has a clear positive e.ect on the quality 
of a RO PUF. We implemented a RO PUF key generation system on an FPGA using our design strategy. Our 
results clearly indicate that our proposed de­sign strategy can signi.cantly improve the quality of a 
RO PUF implementation. Categories and Subject Descriptors K.6.5 [Management of Computing and Information 
Systems]: Security and Protection  General Terms Security, Measurement, Experimentation  Keywords Physical 
Unclonable Function (PUF), FPGA, Ring Oscilla­tor, Fuzzy Extractor 1. INTRODUCTION Field Programmable 
Gate Arrays (FPGAs) gain increas­ingly in importance as highly .exible alternative to Appli­cation Speci.c 
Integrated Circuits (ASICs). Their recon.g­uration property enables fast prototyping and updates for 
hardware devices even after market launch. These advan­tages are already exploited in, e.g., automotive 
applications [16]. However, FPGAs are more vulnerable to intellectual prop­erty theft than ASICs. Bitstreams 
stored in external .ash Permission to make digital or hard copies of all or part of this work for personal 
or classroom use is granted without fee provided that copies are not made or distributed for pro.t or 
commercial advantage and that copies bear this notice and the full citation on the .rst page.To copyotherwise, 
to republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or 
a fee. WESS 10, October 24, 2010, Scottsdale, AZ,USA Copyright 2010ACM 978-1-4503-0078-0 ...$10.00. memory 
may be read out and reverse engineered to an analys­able netlist [15]. This means that not only implementation 
details of algorithms can be disclosed but also stored cryp­tographic keys can be extracted. One way 
to prevent reverse engineering attacks, is to en­crypt the bitstream [5] before saving it to the .ash 
mem­ory. A decryption engine, included in a high-end FPGA, then decodes the bitstream while loading it 
into its internal memory. Since side-channel attacks against hardware im­plementations [6] improve continuously, 
it might be possible to successfully attack these decryption engines and break their protection. Also, 
attacks on ASICs and FPGAs using a Focused Ion Beam (FIB) to analyse and manipulate the physical construction 
of integrated circuits are already fea­sible today [7]. Hence, FPGA implementations are exposed to a 
variety of security threats. A promising approach towards holistic embedded security arises through the 
application of Physical Unclonable Func­tions (PUFs). These physical structures enable the exploita­tion 
of unavoidable variations in manufacturing processes, e.g., lithographic processes. Signal properties, 
such as the propagation delay on metal lines of a microchip, depend on these variations. Circuits measuring 
and comparing these properties can extract PUF responses. These bit strings are noisy by nature and not 
uniformly distributed, but su.­ciently unique to identify a silicon device. A PUF can be seen as a function 
mapping a response to a challenge input in an unpredictable way. In contrast to challenge-response authentication, 
where a PUF has to generate a big amount of responses to given challenges, i.e., Challenge-Response Pairs 
(CRPs), for the purpose of secure key generation, only a small number of challenges or even only a single 
one is ap­plied. PUFs based on Ring Oscillators (ROs) currently seem to be the most reasonable PUF construction 
to securely identify FPGAs. Their quality has been evaluated in several anal­yses recently [12, 14] and 
enjoys great interest within the scienti.c community. However, in order to use PUFs for the generation 
of cryp­tographic keys, an additional module, a fuzzy extractor, is necessary. It consists of an error-correction 
stage to cancel noise related errors and an privacy ampli.cation stage to provide a uniformly distributed 
key in the end. In this contribution, we show that the quality of RO PUF implementations depends on several 
design parameters. We demonstrate that ring oscillator frequencies strongly depend on the logic implemented 
close to them. Based on this re­sults, we de.ne a RO pair comparison strategy which con­siders RO pair 
placement and selection, RO runtime and the enable/disable function of ROs in order to improve the quality 
of RO PUF responses. We implemented RO PUFs with con.gurable runtime and selection strategy to verify 
our methods. Our results show clear improvements in qual­ity of RO PUF responses. The remainder of this 
paper is organised as follows. Section 2 gives a brief overview of previous work related to our con­tribution. 
Reasons for a trend towards ring oscillator based PUFs are given in Section 3. In Section 4, we show 
that RO frequencies depend on their spatial location and the logic surrounding them. Our comparison strategy 
to improve the quality of PUF responses is explained in Section 5. An im­plementation analysis of our 
comparison strategy is found in Section 6, as well as a discussion about the results of an FPGA implementation 
of a RO PUF key extraction system. Our contribution is completed by a conclusion in Section 7. 2. RELATED 
WORK In 2002, Gassend et al. introduced the .rst PUFs based on silicon structures [2]. Their implementation 
on an FPGA included eight self-oscillating loops consisting of 32 bu.ers and one inverter each. To measure 
the delay di.erences of each loop, their oscillations were counted during a period of typically 220 clock 
cycles at 50 MHz (approx. 0.02 s). The results were clear: the measurement involves a certain level of 
noise, but the information extracted from present delay variations allows to uniquely identify a silicon 
device. Fur­ther, it was stated that environmental changes, e.g., temper­ature increase from 25 to 50 
.C and supply voltage variation between 2.5V and2.7 V cause a higher level of noise in an FPGA s PUF 
response. An arbiter-based PUF model was analysed by Lim et al. in 2005 [10]. Besides determining the 
quality of their proposed symmetric delay structure, their focus was set on authenti­cation by utilizing 
CRPs depending on the physical struc­ture. It was also shown that non-linear functions, e.g., feed forward 
arbiters, have to be introduced to destroy the lin­ear dependence between challenge and response in order 
to render modelling attacks considerably harder. The RO PUF was introduced by Suh and Devadas in 2007 
[18]. Five inverters and one AND-gate, to enable the circu­lation, form a single ring oscillator. In 
the cited document, an implementation of 1024 oscillators is described, where all oscillator outputs 
are connected to inputs of two multiplex­ers to select a pair of oscillators and compare the counter 
values, representing the oscillator frequencies. To enhance the reliability of compared pairs, a 1-out-of-8 
scheme is ap­plied, which chooses the best pair of oscillators out of eight pairs available. It requires 
seven times more bits to gener­ate a response, but also limits the probability of di.erent responses 
from the same chip to 0.48% even for worst-case environmental changes. Maiti and Schaumont pursued a 
similar, but more optimized approach in [13] by introducing con.gurable ring oscillators. During the 
enrolment phase, the optimal con.guration for largest distances of compared oscillator frequencies is 
determined and saved (3 bits per os­cillator). They also suggest to compare adjacent RO pairs by controlled 
oscillator placement, which we will extend to a chaining strategy for optimized RO comparison. In [3], 
PUFs based on SRAM memories were proposed to provide an FPGA intrinsic security primitive. The great 
advantage is that no FPGA resources are occupied by this PUF construction, but unfortunately most FPGA 
devices automatically reset all SRAM blocks after power-up. A sim­ilar approach was described in [11], 
where random start-up values of .ip-.ops are exploited. However, the extraction of these start-up values 
has to be done by the con.gura­tion controller or by a speci.c circuit, which has to be reset externally 
after every start-up, which makes it impractical. Another idea, the Butter.y PUF, was presented by Kumar 
et al. in 2008 [9]. Here, bits are generated from two cross­coupled latches, which leave their meta-stable 
state after releasing the excite signal and tend to output a high or low voltage level depending on manufacturing 
variations of in­volved latches and wires. In [14], Morozov et al. analysed the in.uence of FPGA in­ternal 
routing for proposed FPGA PUF types and conclude that Arbiter PUFs and Butter.y PUFs are not as appropri­ate 
for stable identi.cation as RO PUFs. Fuzzy extractor implementations on FPGAs have been pro­posed by 
B¨ osch et al. in 2008 [1]. They utilise concatenated error-correcting codes and a family of universal 
hash func­tions (Toeplitz hash) to generate uniformly distributed and noise-free cryptographic keys. 
 3. FPGA PUF CONSTRUCTIONS SRAM PUFs o.er a good basis for key generation, but as they are not realisable 
on every FPGA, they are not suit­able as a general FPGA PUF primitive. Flip-Flop PUFs require manual 
bitstream modi.cations and a special read­out technique, which makes them impractical. During our research, 
we investigated Arbiter PUFs, Butter.y PUFs and Ring Oscillator PUFs, but focused on the latter for the 
fol­lowing reason. FPGA routing renders symmetric Arbiter PUF and Butter.y PUF design very hard as explained 
in Section 3.2. One should notice, that the quality and possibilities of an FPGA PUF implementation always 
depend on the tools pro­vided by FPGA manufacturers and the internal low-level de­sign of their devices. 
During the following paragraphs, we concentrate on tools and structures of a Xilinx Spartan-3E device. 
However, it would be an important step to evalu­ate advantages and disadvantages of PUF design on other 
FPGA platforms, e.g., Altera devices, with di.erent low­level concepts and design tools. 3.1 Ring Oscillator 
PUFs RO PUFs are based on manufacturing variations of silicon devices. The frequency of ring oscillators, 
built of an odd number of inverters, depends on these manufacturing varia­tions. The general structure 
proposed by Suh and Devadas [18] is shown in Figure 1. It consists of several ROs from which two are 
selected by a challenge signal using a mul­tiplexer and are each connected to a counter. During the enable 
signal is high, the counters increment with the oscil­lators frequencies, representing their frequencies 
when dis­abling the oscillators again. A .nal relative comparison of the counter values generates a logical 
0 or 1 for this RO pair, depending on which oscillator had the higher frequency. To ensure identical 
routing for all RO instances, only local routing (within a CLB) is allowed, which can be achieved with 
three-inverter ROs in Spartan-3E devices. Arbiter PUF and Butter.y PUF architectures are not satis.ed 
by instan­tiation of identically layout. They require symmetric routing on local and non-local wires, 
which is very hard to achieve, as shown in [14]. Therefore, RO PUF are currently the best choice for 
general FPGA PUF designs. Figure 1: RO PUF structure 3.2 Hard Macro Design The key to solid PUF design 
is the usage of lowest-level FPGA engineering techniques. The Xilinx software FPGA Editor enables the 
creation of hard macros, which are man­ually placed, routed and con.gured designs, which can be instantiated 
multiple times in an FPGA design. This fea­ture can be exploited to design an exactly de.ned ring os­cillator 
and instantiate it several times. Figure 2 shows two nearly identical three-inverter ring oscillators, 
implemented in a single Con.gurable Logic Block (CLB), the basic divi­sion of a Xilinx FPGA. Figure 
2: Hard macro with local routing for two three-inverter ring oscillators in one CLB  4. SPATIAL FREQUENCY 
DEPENDENCE In [13] Maiti and Schaumont showed that ring oscillator fre­quencies depend on their location 
on an FPGA die, e.g., frequencies of ROs at the edges of an FPGA are slower than central ROs. We show 
that logic placed around ROs has an in.uence on their frequencies and also causes a signi.cant spatial 
dependence. (a) (b) (c) (d)   Figure 3: Spatial frequency distribution of 2712 ROs on a Spartan-3E, 
in.uenced by surrounding logic In order to analyse the spatial dependence of RO frequen­cies, we instantiated 
an array of 2712 ring oscillators with the hard macro shown in Figure 2 to cover more than half of a 
Spartan-3E die. Additionally, a RS232 interface, counter and comparison logic was implemented to allow 
measure­ments on all RO frequencies. To analyse the internal envi­ronmental changes within an FPGA depending 
on surround­ing logic, we restricted us to four example cases where the placement of all interface and 
measurement logic, a distur­bance source, was prede.ned. In the .rst case, it was limited to the left 
corner of the empty .oorplan space as depicted in Figure 3(a), in the second one, only the right corner 
was al­lowed, see Figure 3(b). The third case was the area directly at the border of the RO array as 
shown in Figure 3(c) and the fourth one was as far as possible away from the array of oscillators as 
depicted in Figure 3(d). Of course, other cases based on other logic can be de.ned for future analy­ses. 
However, we believe that these cases are representative and allow drawing conclusions about spatial dependence 
of RO frequencies. In Figure 3, the frequencies of all implemented oscillators are depicted by di.erent 
colours at the .oorplan position of the corresponding RO. The presented results show that the position 
of interfaces and read-out logic signi.cantly alters the intra-die conditions. The .rst characteristics 
one observes, are the circular ar­eas of lower frequencies around the position of the read-out and measurement 
logic. Our analysis results show that the communication and read-out logic radiates a condition to decrease 
frequencies, for each case depicted in Figure 3. One possible e.ect could be a local temperature rise 
which orig­inates from .owing currents in the comparison logic and drops with increasing distance to 
it. Our measurements do not allow conclusions about which e.ect, e.g., temperature, exactly causes frequency 
deviations. However, they clearly indicate that frequencies of ROs depend on their spatial lo­cation 
and on surrounding logic. Second, a stripe pattern is visible over the whole area. This depicts the fact, 
that the ring oscillator implementations of Figure 2, although nearly identical, still show a noticeable 
mean frequency di.erence of approximately 10 MHz. There­fore, only exactly identically routed oscillators 
may be com­pared to avoid predetermined comparison results. When looking closer, the locations at the 
bottom borders of Figures 3(a)-3(d) again show slower frequencies instead of higher although they have 
the largest distance to the measurement logic. This might result from higher energy densities at the 
die borders because of nearby output bu.er locations or local heat accumulation. Comparing Figures 3(c) 
and 3(d), one will .nd that moving the logic farther away only shows little improvement. Since the e.ects 
in.uence not only the edge of our oscillator array, the idea of placing dummy cells around it, as proposed 
in [17], is not applicable here. A comparison strategy is needed to overcome this disturbances. 5. RO 
COMPARISON STRATEGY In previous publications, only little focus was put on the circuitry for creating 
a PUF response from comparing os­cillators. We identi.ed three parameters, which in.uence the quality 
and resource usage of the overall system and are therefore critical for area, time or power constrained 
de­vices. First, we present a place and map method to avoid foreseeable comparison results of oscillator 
pairs because of their location. It allows to extract n - 1 bits from n os­cillators while comparing 
only neighbouring ROs. Second, we show that an increasing RO comparison runtime has a positive e.ect 
on measurement errors of oscillator frequen­cies. Third, advantages and disadvantages for a mechanism 
to only enable the actually measured ring oscillators are bal­anced. However, other parameters, such 
as placement and design of frequency counters and RO output multiplexers may in.uence the quality of 
a RO PUF, but are not consid­ered in our strategies. 5.1 RO Pairs In [13] the authors extracted n - 1 
bits from n ROs. In or­der to avoid correlation of response bits, i.e., no comparison result can be foreseen 
when knowing all other comparison results, we use this approach as basis for our strategy. As shown in 
[13], the quality of RO PUFs increases with con­trolled RO placement. We extend this idea to a chain-like 
placement and comparison strategy. Based on our observations in Section 4, we conclude that only completely 
identical ROs, with identical hard macros, are allowed to be used for comparison in order to avoid fore­seeable 
comparison results. However, it might be necessary to use two RO types as shown in the hard macro of 
Figure 2, because of design speci.c area constraints. In this case, two PUF arrays of di.erent types 
have to be considered. Only RO pairs of the same type are to be compared to generate the overall PUF 
response. For example, if a response of 128 bits is necessary, it can be achieved by 129 ROs of type 
0, but if this is not possible for any reasons, a combined so­lution of 65 type 0 and 65 type 1 ROs is 
imaginable. One should notice that m types of ROs in a PUF design require n + m oscillators to extract 
n bits. In order to create a RO PUF challenge, a list of RO pairs to be compared has to be chosen carefully. 
Closely located pairs are exposed to similar spatial conditions. Therefore, we suggest to compare only 
oscillators which are direct neigh­bours. To achieve this while still enabling a simple counter based 
selection mechanism, we propose a chain-like approach in the following paragraphs. We label all available 
n ring oscillators with 0 to n - 1. To simplify and optimize oscillator comparison, a counter runs from 
0 to n - 2 and always selects two consecutive oscillator outputs with a multiplexer. Step by step, these 
pairs are compared and n - 1 bits are extracted. (a) (b) (c) Figure 4: Spatial RO mapping strategies 
With our results of Section 4 in mind, we also propose a spatial chain mapping of ROs. Since ROs are 
often organ­ised in arrays as shown in Figures 4(a) and 4(b) or even in unshaped structures as depicted 
in Figure 4(c), mapping the numbered oscillators to the physical layer of an FPGA de­mands a strict pattern. 
Figure 4(a) shows that wrong physi­cal mapping can cause long distance comparisons. Based on our results 
of Section 4, we believe that these long distance comparisons might produce predetermined results because 
of di.erent dependence on local conditions. Chain-like map­ping as shown in Figures 4(b) and 4(c) achieves 
comparison pairs which are exposed to the same spatial intra-die condi­tions and therefore minimizes 
the risk of location prede.ned comparison results. Many FPGA design tools allow con­trolled placement 
of hard macro ROs and therefore enable a low footprint RO PUF challenge circuitry. This guarantees an 
optimized selection of RO pairs to compare with a single counter. 5.2 RO Runtime In order to enable 
exploitation of frequency variations of ROs to extract unique bit strings, one has to precisely mea­sure 
those frequencies. For RO PUFs, frequency measure­ment is performed by incrementing counters using a 
ring os­cillator s output during a speci.ed time. Higher frequencies lead to higher counter values. We 
show that the runtime, during which a RO pair is com­pared, has signi.cant in.uences on the present measurement 
error and therefore on the quality of a RO PUF. A .rst re­quirement is, that runtime and corresponding 
counter sizes are matched with the estimated maximal RO frequency, in order to avoid counter over.ows. 
Further, the runtime spec­i.cation has to be balanced between reliable RO discrimi­nation and fast response 
extraction. Especially the latter might be critical for embedded cryptographic applications that are 
limited in time. If fclk is a system s clock frequency and nclkcyc is the num­ber of clock cycles during 
which ROs are enabled, the re­sulting maximum measurement error emeasure,max can be calculated as follows: 
fclk emeasure,max = ± (1) 2 · nclkcyc Assume a circuit with a very short read-out time, which en­ables 
two counters only for a single cycle of a 50 MHz clock. Measurements of this circuit resulting in counter 
values of 1, 2, 3, ..., x would represent frequencies of 50, 100, 150, ..., x · 50 MHz respectively. 
This means, all frequencies between 25 and 75 MHz will be mapped to 50 MHz and so forth, re­sulting in 
a maximum measurement error of emeasure,max = 25 MHz. For an array of hard macro ROs, assuming a RO frequency 
range from 175 to 225 MHz with a mean value of 200 MHz, an error of 25 MHz would be unacceptable. Therefore, 
the measurement time for RO comparisons should always be chosen in respect to a carefully de.ned maximum 
measurement error. For instance, if a maximum error of 0.1 MHz is required on a 50 MHz clocked system, 
the run­ 50 MHz time for each RO pair has to be at least nclkcyc == 2·0.1 MHz 250 cycles. This de.nes 
the lower bound on RO comparison runtime. One should also notice that enable signal propagation de­lay 
deviations can cause comparison errors. By increasing measurement time, these delays lose their signi.cance. 
Upper bounds on RO runtime are always determined by the application using RO PUFs, since the evaluation 
time of a large number of RO pairs might be time-critical. For example, an evaluation of 1001 ROs (1000 
RO pairs), based on the parameters calculated in the previous example, would last at least 1000 · 250 
· 20 · 10-9 s=5 · 10-3 s. The only way to accelerate evaluation, would be to measure and compare several 
RO pairs in parallel, which again causes a larger hardware footprint. 5.3 RO Disabling In Section 4, 
we showed that RO frequencies strongly depend on surrounding logic and the resulting local environmental 
changes. Therefore, we believe that oscillators also depend on neighbouring ROs. As a result, we suppose 
that a RO enabling/disabling strategy can improve quality. A trivial enable/disable strategy is activating 
all oscillators with a single enable signal every time RO pairs are compared as depicted in Figure 5(a). 
However, an array of running ROs might cause changes in local temperatures and electro­magnetic emission. 
These parameters might again alter the intra-die environment and increase the present noise level. This 
results in decreased measurement precision. We only enable currently compared ROs and keep all oth­ers 
disabled as shown in Figure 5(b). The advantages of implementing such an enabling module are power consump­tion 
reduction for battery powered devices and less noise on RO pair comparisons. A disadvantage, shown in 
the follow­ing implementation results, is the additional, not negligible, need of hardware resources 
to build this selection logic. (a) (b) Figure 5: RO enable/disable strategies  6. IMPLEMENTATION RESULTS 
We implemented a group of RO PUFs on a Xilinx Spartan­3E FPGA, to demonstrate the positive e.ects of 
our pro­posed strategies on the quality of RO PUFs. Further, we im­plemented a key extraction system 
based on our RO PUFs and a fuzzy extractor architecture as an example applica­tion. 6.1 RO Quality To 
monitor the quality of our RO PUFs, we used two cri­teria, reliability and uniqueness, de.ned in [12]. 
However, for reliability, Maiti and Schaumont only consider Hamming distances to a reference response, 
although every response could be a reference response. For uniqueness, only one re­sponse per device 
is used, but it is not stated how to select or calculate this response. In order to obtain complete results, 
we extend the proposed de.nitions to consider all distances between all responses. 6.1.1 Reliability 
Reliability characterizes intra-device variations of PUF re­sponses R. To measure it, each of m PUF devices 
is evalu­ated x times. Depending on the test purpose, environmental conditions are kept stable or altered 
accordingly. Then, the d(Rj,u,Rj,v) average of the percentage Hamming distance n × 100% between each 
of the measured n-bit responses Rj,u and Rj,v of each device j is calculated, where u and v run from 
1 to x to address every recorded response. Since reliability is a positive measure, we de.ne a maximum 
of 100% as the most desirable result and subtract the calculated average from it. Reliability is then 
de.ned as follows: 1 RPUF =100% -× (2) xP-1 m × i i=1 Xmx-1x XX d(Rj,u,Rj,v) × 100% n j=1 u=1 v=u+1 Reliability 
is an average property, but when specifying error­correcting methods for a PUF system, also the maximum 
re­sponse deviation is signi.cant. It is de.ned as the maximum percentage Hamming distance between two 
intra-device re­sponses out of all devices. 6.1.2 Uniqueness Uniqueness characterizes inter-device variations 
of PUF re­sponses R. Its calculation can be done with the same x responses of each of the m PUF devices 
as described for reliability. This estimate is de.ned by the average of the d(Ri,u,Rj,v) percentage Hamming 
distance n × 100% between all n-bit responses Ri,u and Rj,v of two di.erent devices i and j out of all 
m devices. u and v run from 1 to x to address every recorded response of each device. Uniqueness is then 
de.ned by the following equation, with an optimal value of 50%: m-1xmx XX X X 1 d(Ri,u,Rj,v) UPUF = × 
100% mP-1 n i=1 u=1 j=i+1 v=1 x2 × k k=1 (3) Uniqueness values below 50% indicate correlation between 
PUF responses and therefore lower PUF quality.  6.2 PUF Test Array: 129 ROs, 128 RO Pairs We implemented 
.ve instances of 129 ROs in non-overlapping areas in each of two Spartan-3E1200 devices. These ten PUF 
devices represent only a small test group, but they already allow to show improvements with our strategies. 
The avail­able 128 RO pairs enable the extraction of 128-bit responses. First, the 129 oscillators were 
placed in random order within the given area of each PUF device . This allows us to com­pare our chain 
placement approach with random placement. Second, all oscillators were physically placed by our pro­posed 
chain-like system as shown in Figure 4(b). Hence, the challenge, a list of RO pairs, is created by a 
counter and only direct neighbouring oscillators are compared. Our con.gurable VHDL design allowed to 
synthesize and test all PUFs with speci.ed RO runtimes and di.erent en­able/disable strategies. Runtime 
was increased from 10 cycles at 50 MHz to 10240 cycles. For three chosen runtimes, the feature of RO 
enable selection was activated. Environmental conditions were not altered intentionally, because the 
main focus of this test was to show the e.ects of our proposed strategy, even under normal conditions. 
Table 1: Quality improvement by chain-like place­ment (RO runtime: 640 clock cycles) Placement Reliability 
Maximum Uniqueness response deviation random 99.20% 4.69% 43.40% chain 98.28% 6.25% 48.51% The comparison 
of random and chain-like placement is shown in Table 1. Uniqueness improves by approx. 5% with the use 
of our chaining strategy. Using random placement, where long distance comparisons are likely to happen, 
causes a loss in uniqueness and provides more foreseeable comparison re­sults. Reliability and maximum 
response deviation seem to be better in the random case, but this is only because more RO comparison 
results stay at a .xed, placement dependent value. Table 2 shows the results for our runtime and enable/disable 
strategies. Tests with the smallest runtime con.guration of 10 cycles showed an unacceptable uniqueness 
value of 30.42%. Uniqueness improves while increasing measurement time un­til a value of 640 cycles, 
which equals a measurement error of ±0.04 MHz. For longer runtimes, no improvements in uniqueness are 
observed. Curiously, the enable/disable selection logic does only have a slightly positive e.ect on reliability, 
but also a slightly negative e.ect on uniqueness. On the other hand, the maxi­mum response deviation 
is lowered by almost 1% every time the selection module is activated. However, the large re­sources required 
for the module make it only interesting for reliability critical applications. Regarding runtime, between 
40 and 10240 cycles, an im­provement of approximately 5% in maximum response de­viation is observable. 
This con.rms the e.ectiveness of in­creased measurement time in order to obtain more reliable PUFs with 
a higher quality. Hardware resources for larger comparison counters and re­ Table 2: RO PUF quality 
results (*includes an RS232 interface: 93 slices, 75 registers and 124 LUTs) Runtime (50 MHz cycles) 
Maximum measure­ment error Enable signal Counter size Reliability Maximum response deviation Uniqueness 
Read-out time (for 128 bits, at 50 MHz) Spartan-3E (slices, registers, LUTs)* 10 ±2.50 MHz all 6-bit 
98.39% 7.81% 30.42% 0.03 ms 499, 232, 847 40 ±0.63 MHz all 8-bit 97.85% 10.16% 45.55% 0.10 ms 502, 
238, 858 40 ±0.63 MHz select 8-bit 97.94% 9.36% 45.45% 0.10 ms 608, 238, 1067 160 ±0.16 MHz all 10-bit 
97.45% 8.59% 48.02% 0.41 ms 508, 245, 866 640 ±0.04 MHz all 12-bit 98.28% 6.25% 48.51% 1.64 ms 512, 
251, 874 640 ±0.04 MHz select 12-bit 98.96% 5.47% 47.05% 1.64 ms 617, 250, 1082 2560 ±9.77 kHz all 14-bit 
98.65% 5.47% 48.65% 6.55 ms 516, 257, 882 10240 ±2.44 kHz all 16-bit 99.16% 5.47% 47.82% 26.21 ms 521, 
264, 890 10240 ±2.44 kHz select 16-bit 99.19% 4.69% 46.38% 26.21 ms 624, 262, 1101 lated logic are 
negligible compared to the enable logic mod­ule, but the listed read-out times might become critical 
for some applications. Time optimized read-out strategies, other than parallel read-out with a higher 
hardware footprint, have to be investigated in future.  6.3 128-bit RO PUF Key Extraction System In 
order to demonstrate an example FPGA application based on RO PUFs, we implemented a key extraction system. 
Therefore, we also show how many RO pairs are needed to generate a 128-bit key reliably. RO PUFs can 
be used to generate cryptographic keys from physical structures without actually storing the key. We 
implemented a 128-bit RO PUF key extraction system to analyse its applicability and its resource requirements. 
Noisy, non-uniformly distributed sources, such as RO PUF responses, have to be processed by a fuzzy extractor 
to ob­tain stable, uniformly distributed keys. These modules con­sist of two stages, an error-correcting, 
noise eliminating stage and a redistributing hashing stage. The .rst step is usually based on error-correcting 
code constructions, which are ca­pable of detecting and correcting a de.ned number of bit errors. The 
corrected responses are then transformed by a universal hash function to achieve a uniform distribution 
of keys. In Figure 6, our hardware architecture modules are depicted, which were needed to implement 
the helper data protocol of [1]. First, the protocol requires an enrolment phase where a reference PUF 
response is read and corresponding helper data is generated. Afterwards, the created key can be re­constructed 
any time by applying the saved helper data to the PUF system. To the best of our knowledge, no statistical 
entropy analyses of RO PUFs have been carried out yet. In [9], an entropy for Butter.y PUFs is assumed 
for the calculation of required PUF cells. Since our aim is the demonstration of an exam­ple key extraction 
application, we also assume an arbitrarily chosen entropy of 0.95. Beginning with the requirement of 
generating a 128-bit key, we .nd 128 135 bits needed to 0.95 be hashed. As described in [8] and [1], 
we utilize a hard­ware design of a Toeplitz hash function to achieve a uniform distribution. In [1], 
B¨et al. proposed hardware architectures for osch Reed-Muller and Golay code decoders on FPGAs. The au­thors 
state that a combination of these codes and repetition codes are very area e.cient solutions. An obvious 
disad­vantage is, that they require approx. double the number of source bits than BCH code designs, because 
their error­correction properties are not as strong as those of BCH codes. In order to save source bits, 
which again require hardware resources in case of a RO PUF, we compared several ver­sions of BCH codes 
and concatenations of BCH and repe­tition codes. We calculated the residual error probability as de.ned 
in [1], which should be less than the Failure In Time (FIT) rate of the used FPGA. A value below 10-6 
is a good pessimistic requirement. At the same time, the second parameter -required source bits -should 
be kept as small as possible. Based on our results above, we assume a bit error rate pb =0.08 for a reliable 
RO PUF construc­tion. Our code comparison results are listed in Table 3. The BCH(255,37,45) code shows 
a low residual error probability while requiring an acceptable number of 1020 source bits. Table 3: Error 
probabilities and source bits of pos­sible error-correcting codes (for 135 bits) Error-correcting code 
Error probability Source bits BCH(127,15,27) 0.75 · 10-6 1143 BCH(127,22,23) 0.66 · 10-4 889 BCH(255,37,45) 
0.18 · 10-6 1020 BCH(255,71,29) 0.22 · 10-1 510 BCH(511,76,85) 0.57 · 10-10 1022 BCH(511,139,54) 0.16 
· 10-1 511 BCH(1023,143,126) 0.75 · 10-6 1023 REP(3,1,1) + BCH(255,71,29) 0.11 · 10-14 1530 REP(5,1,1) 
+ BCH(255,139,15) 0.31 1275 In [4], a tool for generating BCH codecs in VHDL language was designed. 
We used it to generate a BCH(255,37,45) encoder and decoder, which represent our error correction module. 
We implemented 1021 ROs with an optimized read-out cir­cuitry to obtain a high quality PUF. Further, 
our designed fuzzy extractor system consists of a universal hash function,  Figure 6: Key extraction 
system modules an error-correcting stage and a key extraction algorithm sim­ilar to the one explained 
in [1]. For communication pur­poses, an RS232 interface was added to our architecture. Xilinx ISE synthesis 
results for a Spartan-3E1200 FPGA led to the following utilization: 6622 registers (38%), 13490 LUTs 
(77%), 8429 slices (97%). The fraction of the error­correcting module is estimated to be approx. 42% 
of the required slices, while the RO array occupies approx. 10%. The hash implementation requires approx. 
4% of this design and the wide XOR module approx. 9%. A disadvantage of this design is that the helper 
data is also saved within FPGA resources and occupies approx. 10%. The RS232 interface, which has access 
to the PUF response, helper data and gen­erated key, uses another approx. 3%. Approx. 22% consist of 
control logic, a pseudo random number generator and module interfaces. The size of this construction, 
admittedly not fully optimized yet, is unacceptable for low-cost FPGAs, since it does not leave much 
resources for the actual application. The error­correcting code module occupies a signi.cant fraction, 
there­fore reasonable trade-o. between required source bits and area e.cient error-correcting code implementations 
could improve the resource usage of key extraction systems. Fur­ther, a even higher quality of PUF responses 
could lower the number of required source bits. An optimized control system and a trade-o. between serial 
and parallel processing could reduce the amount of required FPGA resources, also. How­ever, there is 
a strong need to investigate PUF systems with a signi.cantly smaller footprint to enhance the applicability 
of PUFs in small and middle size FPGAs.  7. CONCLUSION We have shown that RO frequencies strongly depend 
on their spatial location on an FPGA because of surrounding logic al­tering intra-die conditions. Based 
on this fact, we proposed a chain-like mapping strategy for controlled physical place­ment of oscillators. 
We were able to demonstrate RO PUF quality improvements by adjusting RO runtime and usage of an enable/disable 
logic module. Our contribution is com­pleted by an implementation of a RO PUF key extraction system. 
 8. REFERENCES [1] C. B¨ osch, J. Guajardo, A.-R. Sadeghi, J. Shokrollahi, and P. Tuyls. E.cient helper 
data key extractor on fpgas. In CHES 08: Proceedings of the 10th International Workshop on Cryptographic 
Hardware and Embedded Systems, pages 181 197, Berlin, Heidelberg, 2008. Springer-Verlag. [2] B. Gassend, 
D. Clarke, M. van Dijk, and S. Devadas. Silicon physical random functions. In CCS 02: Proceedings of 
the 9th ACM conference on Computer and communications security, pages 148 160, New York, NY, USA, 2002. 
ACM. [3] J. Guajardo, S. S. Kumar, G. J. Schrijen, and P. Tuyls. Fpga intrinsic pufs and their use for 
ip protection. In P. Paillier and I. Verbauwhede, editors, CHES, volume 4727 of Lecture Notes in Computer 
Science, pages 63 80. Springer, 2007. [4] E. Jamro. The design of a vhdl based synthesis tool for bch 
codecs. Master s thesis, School of Engineering, The University of Hudders.eld, Sep 1997. [5] T. Kean. 
Secure con.guration of .eld programmable gate arrays. In FPL 01: Proceedings of the 11th International 
Conference on Field-Programmable Logic and Applications, pages 142 151, London, UK, 2001. Springer-Verlag. 
[6] P. C. Kocher, J. Ja.e, and B. Jun. Di.erential power analysis. In M. J. Wiener, editor, CRYPTO, volume 
1666 of Lecture Notes in Computer Science, pages 388 397. Springer, 1999. [7] O. K¨ ommerling and M. 
G. Kuhn. Design principles for tamper-resistant smartcard processors. In WOST 99: Proceedings of the 
USENIX Workshop on Smartcard Technology on USENIX Workshop on Smartcard Technology, pages 2 2, Berkeley, 
CA, USA, 1999. USENIX Association. [8] H. Krawczyk. Lfsr-based hashing and authentication. In CRYPTO 
94: Proceedings of the 14th Annual International Cryptology Conference on Advances in Cryptology, pages 
129 139, London, UK, 1994. Springer-Verlag. [9] S. S. Kumar, J. Guajardo, R. Maes, G. J. Schrijen, and 
P. Tuyls. Extended abstract: The butter.y puf protecting ip on every fpga. Hardware-Oriented Security 
and Trust, 2008. HOST 2008. IEEE International Workshop on Hardware-Oriented Security and Trust (HOST), 
pages 67 70, June 2008. [10] D. Lim, J. W. Lee, B. Gassend, G. E. Suh, M. van Dijk, and S. Devadas. Extracting 
secret keys from integrated circuits. Very Large Scale Integration (VLSI) Systems, IEEE Transactions 
on, 13(10):1200 1205, December 2005. [11] R. Maes, P. Tuyls, and I. Verbauwhede. Intrinsic pufs from 
.ip-.ops on recon.gurable devices. In 3rd Benelux Workshop on Information and System Security (WISSec 
2008), page 17, Eindhoven,NL, 2008. [12] A. Maiti, J. Casarona, L. McHale, and P. Schaumont. A large 
scal characterization of ro-puf. In IEEE International Symposium on Hardware-Oriented Security and Trust 
(HOST), pages 66 71, 2010. [13] A. Maiti and P. Schaumont. Improving the quality of a physical unclonable 
function using con.gurable ring oscillators. In 19th International Conference on Field Programmable Logic 
and Applications (FPL), 2009. FPL 09., 2009. [14] S. Morozov, A. Maiti, and P. Schaumont. A comparative 
analysis of delay based puf implementations on fpga. Cryptology ePrint Archive, Report 2009/629, 2009. 
http://eprint.iacr.org/. [15] J.-B. Note and E. Rannaud. From the bitstream to the netlist. In FPGA 08: 
Proceedings of the 16th international ACM/SIGDA symposium on Field programmable gate arrays, pages 264 
264, New York, NY, USA, 2008. ACM. [16] J. Saad, A. Baghdadi, and F. Bodereau. Fpga-based radar signal 
processing for automotive driver assistance system. In RSP 09: Proceedings of the 2009 IEEE/IFIP International 
Symposium on Rapid System Prototyping, pages 196 199, Washington, DC, USA, 2009. IEEE Computer Society. 
[17] Y. Su, J. Holleman, and B. P. Otis. A digital 1.6 pj/bit chip identi.cation circuit using process 
variations. IEEE JOURNAL OF SOLID-STATE CIRCUITS, 43(1):69 77, Jan 2008. [18] G. E. Suh and S. Devadas. 
Physical unclonable functions for device authentication and secret key generation. Design Automation 
Conference, 2007. DAC 07. 44th ACM/IEEE, pages 9 14, 2007.  
			

 Separating Concurrent Languages with Categories of Language Embedding Ehud Shapiro Department of Applied 
Mathematics and Computer Science The Weizmann Institute of Science Rehovot 76100, Israel Extended Abstract 
Abstract 1 Introduction 1.1 A Method for Language Compari­son Concurrent programming enjoys a proliferation 
of All reasonable sequential programming languages are languages but suffers from the lack of a general 
method Turing-complete and hence computationally equivalent. of language comparison. In particular, concurrent 
Nevertheless, researchers in the early 1970 s were able (as well as sequential) programming languages 
can­ to separate the expressive power of various sequential not be usefully distinguished based on complexity­ 
programming language constructs using the notion of theoretic considerations, since most of them are 
Turing­ translation among program schemas. An example of a complete. Nevertheless, differences between 
program­ result from that period is that recursion is more pow­ming languages matter, else we would not 
have invented erful than iteration [37] (cf. [8] for a survey of this so many of them. work). Models 
of concurrency and concurrent programmingWe develop a general method for comparing concur­ languages 
are by far more diverse and plentiful than rent programming languages based on their algebraic their 
sequential counterparts. Although such models (structural) complexity, and, using this method, achieve 
have been investigated by now for more than a decade, separation results among many well-known concurrent 
no general method for comparing concurrent languages, languages. analogous to the theory of program schemas 
for sequen-The method is not restricted to concurrent languages. tial languages, has emerged. As a result 
research on It can be used to compare the algebraic complexity of seemingly closely related phenomena 
cannot be effec­abstract machine models, other families of programming tively communicated across language 
boundaries and languages, logics, and, more generaly, any family of lan-new language proposals cannot 
be objectively compared guages with some syntactic operations and a notion of and related to previous 
ones. semantic equivalence. The method can also be used to Perhaps the key obstacle to the development 
of a compare the algebraic complexity of families of opera-method for concurrent language comparison 
was the tions wit hin a language or across languages. We note lack of an agreement on even the most basic 
elements that using the method we were able to compare lan-from which concurrent programs are constructed. 
All guages and computational models that do not have a languages and models employ some notion of commu. 
common semantic basis. nication and synchronization and, usually, some notion of indeterminacy y. However, 
notions of communicant ion and synchronization are radically different among differ­ent models. Consequently, 
semantic models for different Permission to copy without fee afl or part of this material is granted 
concurrent languages are often irreconcilable. provided that the copies are not made or distributed for 
direct In this paper we propose a general framework for lan­ commercial advantage, the ACM copyright 
notice and the title of the guage comparison, based on algebraic (structural) com­ publication and its 
date appear, and notice is given that copying is by plexity, which overcomes this obstacle. The method 
permission of the Association for Computing Machinery. To copy other­wise, or to republish, requires 
a fee and/or specific permission. is based on demonstrating the existence or nonexis­tence of mappings 
among languages that preserve both @ 1991 ACM 089791-397-3/91/0004/0198 $1.50 the syntactic and the semantic 
structure of the lan­ 198 guage, Although motivated by concurrent languages, the method is quite general, 
and can be used to ana­lyze the algebraic complexity of many other families of languages, including abstract 
models of computation, sequential programming languages, Iogics, and (well­defined fragments of) natural 
languages. In addition to proposing the general framework we develop general tools for achieving language 
separation, which are ap­plicable both to abstract models of computation and to concurrent programming 
languages. We view languages as sets with syntactic and se­mantic structure: the syntactic structure 
is a set of partial operations; the semantic structure is an equiv­alence relation, referred to as observable 
equivalence. When comparing languages we have the freedom to ex­pose only certain aspects of their syntactic 
and semantic structure. We compare the algebraic complexity of the exposed structure of languages by 
establishing the ex­istence or nonexistence of language mappings that pre­serve that structure. We call 
such mappings language embedding. Our approach can be most naturally couched in category-theoretic termsl. 
Each family of language em­bedding we consider defines a category that haa sets wit h structure as objects 
and mappings that preserve that structure as morphisms. Each category K of lan­guage embedding induces 
a preorder SK on the X­languages, where L ix L iff there is a K-embedding of L in L . We would like to 
find categories K of language em­bedding for which ~ x is nontrivial (i.e., is neither the identity relation 
nor does it collapse into one equiva­lence class). For a given category K, we prove that ~K is not the 
identity relation by exhibiting K-embeddings among distinct languages. To prove that ~K does not collapse, 
i.e., that there are language L and L such that L AK L, we look for a language property P such that: 
1. P is satisfied by L but not by any sublanguage of L. 2. P is preserved by K-embeddings, Since any 
embedding of L1 into L maps L into a sub­language of L, the existence of such a property implies that 
L $K L. We believe that categories of language embedding with nontrivial preorderings expose the relative 
struc­tural complexity of their member languages. Here we study categories of language embedding that 
preserve the semantic structure to various degrees: 1To follow this paper it is sufficient to know that, 
infody, a category consists of a class of objects and a class of mappings between the objects, called 
morphisms. The class of mappings is equipped with an associative composition operatio~ it is closed under 
composition and it includes for each obj ect a in the category the identity mapping, which acts as a 
left (right) unit for compo­sition with morphisms from (to) a. Two examples of categories are the classes 
of ordered sets and order-preserving mappings, and the classes of X-algebras and X-homomorphisms. sound 
embedding, which are embedding that preserve observable distinctions, and faithfui embedding, which are 
sound embedding that preserve observable equiv­alence. Each observable equivalence induces a unique fully-abstract 
congruence, which is the coarsest congru­ence relation that is included in the observable equiva­lence. 
We study fully-abstract embedding, which are embedding that are faithful with respect to the induced 
fully-abstract congruence. For every such category K and for any two concurrent languages L, L E K we 
consider, we wish to establish which of the following four relations holds: L <~ L (i.e., L AX L and 
L $x L), L +X L, L -K L fi.e,, L ~K L and L <K L) or L and L are incomparable. The ~eparation results 
in this paper make a small step towards this goal, but a large number of open problems remain.  1.2 
Sound and Faithful Mappings A base language is a pair (S;=) where S is a set and = is an equivalence 
relation over S, called observable equivalence. In a concrete language there would be a (possibly partial) 
function that associates some observable be­havior with elements of the language. The observable equivalence 
would then be the kernel of this function2. In a sequential programming language the function may give 
the input/output relation computed by a program in the language. In a concurrent programming language 
the function may give some information on the possible interactions of a program with its environment, 
In Iogics the function may characterize the validity of a sentence or give its deductive closure. In 
abstract models of com­putation, such as Turing machines and finite automata, the function may give the 
language accepted by a ma­chine. In other setups, such as natural languages, the observable equivalence 
may be given explicitly, e.g. as judgments of the equivalence of the meaning of sen­ tences of a natural 
language, made by a native speaker of the language. Definition 1 Let L = (S; N) and L = (S ; ~ ) be 
two base Janguages, and E : S 4 S a mapping. Then c is . sound if a+b w a&#38;~tb&#38; for every a, b 
6 S, and Note that a faithful mapping is sound. Proposition 1 Let L = (S; =), L = (S , H ) be two base 
languages, &#38; : S * S be a mapping, and assume that the observable equivalences are given as kernels 
of some functions Ob : S -+ O and Ob : S * O1. Then E is sound iff there is a mapping 6:01 -+ O for which 
the following diagram commutes: 2The kernel of a function j is the equivalence relation 3 Sat­isfying 
a R b iff f(a) = f(b). s &#38;s  o 0 Hence soundness is equivalent to the existence of a de­coder 
from observable of L to observable of L. A sufficient condition for the existence of a faithful mapping 
from L = (S; =) to L = (S ; = ) is that the cardinalit y of S / &#38; is greater or equal to the cardinalit 
y of S/ z. Hence if the quotient sets of two base languages have the same cardinalit y (as they normally 
do), then there are fait hful mappings in both directions. As examples of natural faithful mappings consider 
L, the set of all finite automata, and L , the set of all Turing machines, where two automata/machines 
are ob­servably equivalent iff they accept the same formal lan­guage. Then a mapping L ~ L that takes 
every finite automaton into a Turing machine that accepts the same formal language is faithful. Conversely, 
assume some Godel numbering of Tur­ing machines, and let G(T) denote the smallest Godel number of any 
Turing machine that accepts the same language as T. Consider a mapping L ~ L that takes every Turing 
machine T into an automaton that accepts the singleton language containing G(T). This mapping is faithful. 
The example shows that to be a useful tool for lan­ guage comparison we should put some additional con­ 
st raints on sound and faithful mappings. One natural constraint is restricting the computational complexity 
of the mapping. For example, there is no effective faithful mapping of Turing m8Lchines intO finite automata, 
eke we could decide the equivalence of two Turing machines. Another constraint one can put is to r~quire 
that the mapping preserve some structural properties of the source language. This is the direction pursued 
in this paper. Our method alllows great flexibility in choosing what structure in a language we wish 
to expose and preserve: an operation intrinsic to the definition of a language, e.g. parallel composition 
in concurrent lan­ guages or conjunction in logics, an operation we define on a language, e.g. union 
of grammars or automata, or a structure conjectured to be intrinsic to the language, but which is not 
directly accessible to us, e.g. deep syn­ tactic structures in naturaI languages. 1.3 Comparing Concurrent 
Program­ming Lang uages In comparing concurrent programming languages we take parallel composition as 
the sole given operation and stud y sound, faithful, and fully-abstract embedding. We have found so far 
three properties that provide us with a host of separation results for the family of concur­rent languages: 
the property of (non) -compositionality of the observable equivalence; the property of (non)­interference-freedom 
of parallel composition; and the property of having parallel composition with hiding. Compositionality 
means that the observable equiva­lence coincides with the fully-abstract congruence. Non­comp ositionalit 
y is preserved by faithful ernbeddings. Examples of compositional languages are deterministic dataflow 
networks [27], deterministic CSP [22], deter­ministic concurrent logic languages [45], and the nonde­terrninistic 
language of 1/0 Automata [32]. Interference-freedom means that the parallel com­position of any nontrivial 
program with itself is ille­gal. Non-interference-freedom is preserved by sound embedding. Interference-free 
languages include lan­guages based on binary communication channels such as dataflow networks, CSP [22] 
(the original version, in contrast to the more recent version, referred to as The­oretical CSP [23], 
which does not have this property), languages based on directed logic variables [29] such as Doc [20] 
and Janus [43], and shared variable languages that admit a single-writer restriction, such as the read­only 
subset of Unity [9]. Composition has hiding if there are programs that are observably distinct from the 
trivial program, but their composition is observably equivalent to the trivial program. Having composition 
with hiding is preserved by faithful embedding. Dataflow networks and CSP have composition with hiding. 
 1.4 Related Work Language embedding has been used as a method for giving a semantics to one language 
in terms of another, presumably a better understood one. Examples are the embedding of procedural languages 
in the lambda cal­culus [30], the embedding of a shared variable language in CCS [36], and the embedding 
of dataflow networks in CSP [26]. Translating some language constructs into others was proposed by Landin 
[30] as a method for identifying the <essential core of a programming language, and was later developed 
and applied by others [39,40,46]. The use of translations for comparing program schemas was popular in 
the early 1970 s [8,34,37]. The use of transla­ tion among programming languages as a method of lan­guage 
comparison was common in functional and logic programming. See [21] for a discussion of pragmatic as­pects 
of language embedding and the Concurrent Prolog book [44] for several papers devoted to translations 
of logic, functional and object-oriented models of concur­rency into concurrent logic languages. Most 
of these translations are embedding in the sense of this paper. The use of language embedding as a formal 
tool for language comparison was proposed by the author [45]. An embedding of L in L in the sense of 
[45] is a pair of functions (c, d), called compiler and decoder, satisfy­ing O@) = d(Ob (c(p)) for every 
program p c L, where Oh(p) denotes the obser~able behavior of the L-program p. This requirement implies 
that the mapping c is sound with respect to the observable equivalences induced by Ob and Oh . Conversely, 
if c is a sound mapping then there is a decoder d satisfying this requirement, as noted in Proposition 
1. That paper demonstrated various em­bedding among concurrent logic languages, which sat­isfy an additional 
property related to the use of logic variables, but did not contain separation results. De Boer and Palamidessi 
[2] incorporated in that def­inition of embedding the requirement that it be home morphic with respect 
to parallel composition and in [3] extended this requirement also to the choice operator. They added 
restrictions on the decoder d and proved re­sults that distinguish between unguarded nondetermin­ism, 
input-guarded nondeterminism, and input/output­guarded nondeterminism in concurrent logic languages. 
A similar approach was independently proposed by Felleisen [12], who proved that certain extensions to 
the basic A-calculus cannot be embedded in the basic language. Riecke [38] introduced the notion of fully­abstract 
translations, which are translations among lan­guages that preserve both the observable behavior of a 
program and the fully-abstract congruence. He showed fully-abstract translations among variants of the 
func­tional language PCF and, by adding restrictions on fully-abstract translations that are specific 
to typed functional languages, proved separation results bet ween several variants of PCF. De Boer and 
Palamidessi require the decoder to be elementwise and termination invariant, hence they depend on the 
similarity between the observable of the languages under comparison. Felleisen s frame­ work is geared 
to the analysis of language extensions rather than to the comparison of independent lan­ guages. Riecke 
extends Felleisen s work by allowing translations bet ween distinct languages, but requires the observable 
of the target language to include those of the source language and requires translations to pre­ serve 
observable (rather than observable equivalence). Our method, in contrast, compares the internal alge­ 
braic complexity of languages, and hence does not de­ pend on any a priori relationship between the languages 
being compared. In particular, it does not require the languages being compared to have a common semantic 
basis. Boug6 [4] has compared variants of CSP by determin­ ing their ability to solve leader election 
problems in var­ ious network topologies. Using this method Boug6 has separated several variants of CSP. 
The results of de Boer and Palamidessi and of B oug6 are analogous in the sense that they show the added 
expressive power of input­guarded indeterminacy over unguarded indeterminacy y and of i/o-guarded indeterminacy 
over input-guarded indeterminacy. We have yet to determine whether these results can be couched in our 
framework. Our algebraic approach to concurrency follows the work of Milner [35,36], Hennessy [18], 
and others. Our approach to full abstraction is based on that of Gaifman and Shapiro [13]. 1.5 Contributions 
The main contribution of this paper is in developing a framework for language comparison based on algebraic 
complexity and in developing general tools for language separation. From a mathematical point of view, 
the novelty of the approach is in investigating mappings between algebras equipped with an equivalence 
relation, rather than with an equational theory. Algebras with equational theories have been thoroughly 
studied in mathematics [33] and have been extensively applied in algebraic specifications [11]. We feel 
that our approach is more suitable as an abstract framework for the study of programming lan­guages and, 
more generally, families of languages with a syntactic structure and a notion of semantic equiv­alence. 
The reason is that it is often more natural to operate on concrete representations of programs than on 
their semantic equivalence classes. The embedding that we have found are nontrivial in that they involve 
some programming tricks , but they are usually of rather low computational complexity for programs hav­ing 
finite representations. In contrast, any reasonable notion of semantic equivalence for a programming 
lan­guage is usually undecidable, and hence it would be un­ natural to factorize a faithful embedding 
L -L that is recursive into a (nonrecursive) mapping L -+ (L/N) from programs to their semantic equivalence 
classes and a (probably nonrecursive) mapping (L/=) ~ (L / x ) between semantic equivalence classes. 
Furthermore, we note that such a factorization would result in a homo­ morphism from L/ = to Lll = if 
and only if the orig­ inal embedding is fully abstract. Hence this approach effectively excludes the 
study of embedding that are not fully abstract or, equivalent ly, precludes semantic equivalences which 
are not congruences. Another deviation from common practice is our use of partial algebras rather than 
(ordinary or many-sorted) algebras (although partial algebras have also been used in algebraic specifications 
[6]). Programming languages contain restrictions on program composition that can­ not be modeled by many-sorted 
algebras. One of our separation results is based on this phenomenon. We note that, given the framework, 
our separation re­ sults are quit e straightforward. This should be viewed as evidence to the power 
of our approach, not as a draw­ back. We suspect that further separation results may not be so easy. 
In contrast to the common experience with computational complexity hierarchies, our positive results, 
to be reported in a subsequent paper, were more difficult to establish than the negative ones. 2 Algebraic 
Languages and Their Embedding In this section we describe a general framework of lan­guage comparison. 
2.1 Preliminaries We recall some basic notions of partial algebra. For for­mal definitions see [10, 17,33]. 
A partial algebra (S; F) is a set S with a collection F of finitary partial operations on S. We assume 
that F is well ordered, F = .fl, .f2, . . . and use Fn to denote the set of n-ary operations in F. Let 
(S; F) and (S ; F ) be two partial algebras. (S ; F ) is a weak subalgebra of (S; F) if S ~ S, F and 
F have the same cardinality, the arities of .f~ and of ~~ are the same for every i, and for every al, 
aa, . . ., an E s, if f~(al, az, . . . , an) is defined then f~(al, az, . . . . an) = , an). Here and 
in the following equality (or equivalence) of expressions means that one side is defined iff the other 
side is, and if both are defined then they are equal (or equivalent). An equivalence relation = on S 
is called a strong con­ gruence relation on (S; F) if ai = bi, 1 S i s n implies f(al, aa,..., an) S 
f(tq, bz, ..., bn) for every ~ c Fn. A homomorphism&#38; : (S; F) -(S ; F ) is a mapping3 such that 
for every al, az, . . ..a~ = S ma f 6 Fn, ~ic G S , ~: &#38; F; and if ~(al, az, ..., am) is defined 
then ~(al, a2, ..., an)&#38; = ~c(als,a2&#38;. . . ,ane). For a homomorphism c : (S; F) ~ (S ; F ), the 
image of (S; F) under e, denoted (Se; Fe), is the partial alge­ bra where Ss c S is the image of S under 
E, and F&#38; is the set of operations obtained from F by letting its operations be defined only where 
implied by the homo­ morphism. Note that (Ss; Fs) is a weak subalgebra of (S ; F ). For a given partial 
algebra (S; F) the closure of F on S, denoted by ~, is the set of all finitary operations on S that 
correspond to terms with variables over F. (~ is sometimes called the clone of action of F [10,33] or 
the finitary polynomials over F [17].) A homomorphism c : (S; F) ~ (S ; ~ uniquely determines a homomorphism 
fi(al, a2,... F: (S; F) ~ (S ; ~ that agrees with c on (S, F). A derived operation of a partial algebra 
(S; F) is an operation obtained from an operation of ~ by special­izing ) some of its arguments to elements 
of S. 2.2 Algebraic Languages A partial structure (S; F; R) is a triple where (S; F ) is a partial algebra 
and R is a set of relations on S. An algebraic language is a particular kind of partial structure: 3For 
simplicity of notation we do not distinguish between the component of s that maps S to SI and the component 
that maps Fto F . Definition 2 An algebraic language (or language, for short) is a triple (S; F; ~), 
where S is a set, F is a set of partial operations on S, and z is an equivalence relat ion on S, called 
observable equivalence. For a language L = (S; F; =) we call elements of S programs and use p = L as 
synonym with P c S. For al, a2, . . ..ane Landf~ F~weputf(al, az, . . . ,an) G L to assert that f (al, 
az, ..., a~) is defined. Definition 3 A language L = (S ; F ; N ) is called a sublanguage of L = (S; 
F, =) if (S ; F ) is a weak subal­gebra of (S; F) and R is R restricted to S . When considering concurrent 
languages we take par­allel composition as the sole operation in F.  2.3 Language Embedding and Their 
Composition We allow embedding among languages with different sets of operations. Furthermore, we allow 
an embed­ding to realize an operation in the source language by an operation in the closure of operations 
of the target language. This is formalized as follows. Definition 4 Let L = (S; F; m) and L = (S ; F 
; N ) be two languages. A language embedding &#38; of L into L , denoted s : L ~ L , is a homomorphism 
of the partial algebra (S; F) into the partial algebra (S ; ~). Definition 5 Let L = (S; F; E) and L 
= (S ; F ; = ) be ]anguages and c : L -+ L an embedding. Then LC is the algebraic language (Ss; Fe; = 
), where (Se; F&#38;) is the image of the partial algebra (S; F) under the ho­ momorphism c and CX J 
is N restricted to SC. For a language L = (S; F; ~) the closure of L, de­noted ~, is the language (S; 
~; ~). Proposition 2 Let L and L be languages and c : L ~ L a language embedding. Then Lc is a sub]anguage 
of v. Definition 6 The composition of two language em­bedding E:L 4 L and c :L 4 L , isgiven by / d~f 
Eo&#38; E .~, where ? :~ -+ L is the unique ]ifting of z) to ~ and . denotes finction composition. Let 
EL : L -+ L denote the identity embedding on L. Proposition 3 Let s :L x L , c :L + L , and E : L -L 
 be language embedding. Then 1. Eos is an embedding of L in L 2, &#38;0(&#38; 0 e ) = (et 0&#38; /) 0&#38; 
3.CLO&#38;=CO&#38;LJ=&#38;  Hence the set of languages together with language embedding form a category, 
which we call LX. We note that .fX is a category of sets with structure. 2.4 Sound, Faithful, and Fully-Abstract 
Embedding Definition 7 Let L = (S; F; =) be a language. Then ~L, called the fully-abstract congruence 
of L, is the largest strong congruence relation on (S; F) that is in­ cluded in =. Definition S Let L 
= (S; F; ~) and L = (S ; F ; 2) be two languages. A language embedding E : L ~ L is: sound if a#b =+ 
a.s#lbc for every a, b E S,  faithful ifaz b ~ ac&#38; bcfor every a,b cS, and  fitly abstract if a 
~L b W a~ ~Ll bc for every a, bGS.  In other words, an embedding is fully-abstract iff it is faithful 
with respect to ~L. Note that a fully-abstract embedding is not necessarily faithful or sound. Observation 
1 Let E : L -L be a faithful embed­ding. Then c constitutes a fully-abstract embedding of L into L&#38;. 
By a context C(a) of a language L = (S; F =) we mean a unary derived operation of L (including the identity 
operation). The application of a context C(z) to an L-program p is denoted C(p). Let C (X) be an L-context. 
We say that C(x) distinguishes between p and q if C(p)#C(g). Observation 2 Let L be a language and p, 
q E L. Then p $L q iff there is an L-context C(x) that distin­guishes between p and q. The relative power 
of sound, faithful, and fully­abstract embedding of algebraic languages can be char­acterized as follows. 
If .s : L d L) is a sound but not faithful embedding, then L contains programs p, q such that p E q but 
pe# qc. If 6 is faithful then no such programs exist. However, if it is not fully abstract then there 
are programs p, q c L and an L -context C(z) such that p -L q but C(x) distinguishes between p= and q.c. 
If the embedding is fully abstract, though, then no such cent ext exists. Notation: For a language L 
= (S; F; =), L/=L de­notes the partial algebra (S; F)/~L, and [.]L denotes the natural mapping from L 
to L/~L. Proposition 4 Let e : L * L be a faithful embed­ ding. Then &#38; is filly abstract iff there 
is a monomor­ phism 2: (L/~L) ~ (L /EL) ) for which the following diagram commutes: &#38; L L The following 
proposition is useful for establishing that an embedding is fully abstract, Definition 9 Let L = (S; 
F; =) be a language. A sub­language T of~ is a testing sublanguage of L if for every P, q E L such that 
P #L q there is a T-context C(x) for which C(p)#C(q). Proposition 5 If&#38; : L Y L is a faithful embedding 
and Le is a testing sublanguage of L , then c is fully abstract. We have no general conclusion as to 
whether one should pay attention to the observable equivalence, to the fully-abstract congruence, or 
to both. On the one hand the observable equivalence can be viewed just as an intermediate step in the 
definition of the fully­abstract congruence. Under this view we may prefer not to distinguish between 
languages with the same car­rier set, which differ in their observable equivalences but not in their 
fully-abstract congruence. On the other hand, we often have a good handle on the observable equivalence, 
and no simple characterization of the fully­abstract congruence (cf [13,14]). 2,5 The Preorder Induced 
by a Cate­gory of Language Embedding By a category of language embedding we mean a cat­egory of objects 
with structure [33] over the base cate­gory fl$ (or some subcategory of L$). It can be verified that 
the composition of two sound embedding is sound, and that the identity embedding is sound. Hence lan­guages 
together with sound embedding form a category of language embedding, which we call M. The same holds 
for faithful and fully-abstract embedding, whose categories we call ,C3 and LA, respectively. Definition 
10 Let K be a category of language em­bedding. Define ~K to be the relation satisfying L SK L iff there 
is a K-embedding of L in L . It is easy to see that the objects of K together with SK form a preorder. 
A language property is a unary predicate P(X) where X ranges over languages. A program property is a 
bi­ nary predicate T(z, Y) whose arguments x and Y range over programs and languages, respectively. Definition 
11 Let K be a category of language em­ bedding, A language property P(X) is preserved by K if for every 
K-embedding .s : L * L1, P(L) ==+ P(Le). Sim larly, a program property P(x, Y) is preserved b~ K if for 
every K-embedding &#38; : L d L and every program p c L, P(p, L) s P(ps, L&#38;). Proposition 6 (Separation 
Schema) Let K be a category of language embedding, L and L two K­languages, and P a language property 
such that: 1. ? is satisfied by L but not by any sublanguage of z. 2. P is preserved by K-embeddings. 
 Then L $x L. Proofi Assume to the contrary that the conditions of the proposition hold and that there 
exists a K­embedding E : L + L. Since P(L ) and P is preserved by K-embeddings, then P(L e). By Proposition 
2 L s is a sublanguage of ~. Contradiction. D Note that any separation result for K holds also for any 
subcategory of K.  3 Separation Results We describe three instances of the Separation Schema. 3.1 Compositionality 
When the observable equivalence is sufficiently refined, the equivalence class of a composed program 
is deter­mined by the equivalence classes of its components, i.e., the equivalence is a congruence: Definition 
12 The observable equivalence z of a lan­ guage L = (S; F; =) is called compositional if z coin­ cides 
with EL. Noncompositionalit y is equivalent to a propert y often referred to as the Brock-Ackerman anomaly 
[5]: As im­plied by observation 2, the semantics of a language L is noncompositional iff there are p, 
q e L and an L-context C(Z) such that p &#38; g and C (z) distinguishes between p and q. Proposition 
7 The property of the observable equiv­ alence being noncompositional is preserved by faithful embedding. 
Proof Assume that the observable equivalence of L is noncompositional. Then there are p, q E L and an 
L­context C (r) such that p = q but C(p)#C (q). Since e is faithful it follows that ps H q: but C(p) 
E# C(q)E, thus establishing that the observable equivalence of Lc is noncomp osit i onal. D Proposition 
8 If the observable equivalence of L is compositional then the observable equivalence of any su blanguage 
of ~ is compositional. Together, Propositions 6, 7, and 8 imply our first sep­aration theorem: Theorem 
1 (Compositionalit y) If the observable equivalence of L is compositional and the observable equivalence 
of L isn t, then L $ LF L, 3.2 Interference Freedom In some languages parallel composition is only partially 
defined to avoid naming conflicts, to ensure that com­municant ion is one-to-one, or to allow only a 
single writer per variable. The common aspect of these restrictions is captured by the following property, 
called interference freedom. Definition 13 Let L = (S; F; S) be a language and @ E T a binary operation. 
A program p ~ L is trzvial with respect to@ if for every q E L such that (p@q) c L, (P@q) ~ (q@p) &#38; 
q. @ is an inter~er ence-~ree operation if for every program p E L, nontrivial with respect to @,(P@p) 
@L. We say that L is interference free if every binary op­eration in ~ is interference free. Proposition 
9 If L is interference free then any sub-Ianguage of T is also interference free. Note that ifp and q 
are both trivial with respect to some binary operation then p E q. Also note that if L has binary operations 
only and all of them are interference free then L is interference free. Proposition 10 The property of 
a language not being interference free is preserved by sound embedding. Proof Let e be a sound embedding 
of L = (S, F, ~) in L = (S , F , R ), let @ c F be a binary operation that is not interference free and 
let @&#38; denote the image of@ under e. For every p, q E L, (p@q)#q * (p&#38;@&#38; q&#38;)# qc by soundness 
ofs. Hence p being nontrivial with respect to @ in L implies that p~ is nontrivial with respect to @e 
in Le. Let p G L be a program nontrivial with respect to @ such that (p@ p) E L. Then pc is nontrivial 
with respect to @&#38; in Lc by previous claim. In addition, (P@ P)~ = PC @e PC ~ L&#38; by definition 
of embedding. Hence LE is not interference free. D Together, Propositions 6, 9, and 10 imply: Theorem 
2 (Interference Freedom) If L is inter­ ference free and L isn t, then L $Ls L. Note that since the category 
of faithful embedding LF is a subcategory of the category of sound embed­ding LS, Theorem 2 holds also 
for ,CX. 3.3 Hiding In some languages once the input port and the output port of a channel are connected, 
communication on this channel cannot be observed, This is captured by the property of composition with 
hiding. Definition 14 Let L = (S; F; ~) be a language. A binary operation @ E ~ is composition with hiding 
if there are programs p, q, c c L such that c is trivial with respect to @, p#c, q#c, and p @ q E c. 
We say that L has composition with hiding if ~ has such an operation. Proposition 11 IfL does not have 
composition with hiding then any sublanguage of ~ does not have com­ position with hiding. Proposition 
12 The property of a language having composition with hiding is preserved by faithful embed­ ding. Proof 
Let e be a faithful embedding of L = (S, F, ~) in L1 = (S , F , N ), let@ c ~ be composition with hiding, 
and let @&#38; denote the image of @ under &#38;. For every P, q E L, (P@ q) N q =+ (p&#38;fBE qe) H 
qt by faithfulness of e. Hence p being trivial in L implies that pc is trivial in L.c. Let p, q, c E 
L be programs such that c is trivial with respect to @, p#c, qqr!c, and (p @ q) = c. Then cc is trivial 
in L&#38; by previous claim and p#cc, qs# cc, and (P6 q)&#38;= (P&#38;@c qc) ~ cc by faithfulness of 
e, implying that Le has composition with hiding.n Together, Propositions 6, 11, and 12 imply: Theorem 
3 (Hiding) If L has composition with hid­ ing and L hasn t, then L $LF L.  4 Application to Concurrent 
Programming Languages We now present the main application of our method of language comparison. 4.1 The 
Languages We chose a set of concurrent programming languages representing a wide spectrum of communication 
and synchronization mechanisms. We associate with each concurrent programming language an algebraic lan­ 
guage (S; F; H) as follows. S is the set of terms of the programming language. F consists of parallel 
composi­ tion as the sole operation; all concurrent programming languages under consideration come equipped 
with this operation. Forp,q 6S,wesaythat p~qifpandq have the same observable. The observable of p ~ S 
is the set of all observable outcomes of all possible (finite and infinite) computations of p in some 
environment, if p is a complete program. Otherwise it is the empty set. We briefly mention the observable 
outcome of a com­putation in an environment for each language and state the properties of it~ associated 
algebraic language. DN: nondeterminist ic Dataflow Networks. Observ­able outcome it the input/output 
relation. (cf. [27] for the original deterministic model, and [25,41] for fully-abstract semantics for 
nondeterrninistic  205 dataflow networks). DN has noncompositional ob­ servable equivalence, it is interference 
free (since channels are one-to-one, networks with conflicting port names cannot be composed) and has 
compo­ sition with hiding. . CSP: Observable outcome is the trace of messages on external ports together 
with termination mode, (cf. [22] for the original definition and [4] for the definition of certain sublanguages.) 
(.XP and the sub languages of [4] have none omp osit ional observ­able equivalence, are interference 
free and have composition with hiding. Actors [19]: Observable outcome is the set of mes­sages sent on 
external mailboxes, Actors have non­compositional observable equivalence, are interfer­ence free (since 
actors have unique identifiers), and do not have composition with hiding. . DLV: Processes communicating 
via directed logic variables [29] (e.g. Doc [20] and a subset of Janus [43]). Observable outcome is the 
limit input sub­stitution and limit output substitution projected on the initial external variables, 
together with ter­mination mode. DLV languages have noncomposi­tional semantics, are interference free 
(to preserve the single-reader single-writer invariant), and have composition with hiding. . FCP, FGHC, 
and variants: In Flat Concurrent Pro­log [44,45], Flat Guarded Horn Clauses [47,48] and the variants 
investigated in [3,15,42,49], the observ­able outcome is the limit input substitution and limit output 
substitution projected on the initial variables, together with termination mode. (Sim­pler observable, 
that do not allow for environment input, also suffice for the negative results of this pa­per.) The observable 
equivalence of these languages is noncompositional, they are not interference free, and have no composition 
with hiding. . IOA: 1/0 Automata [32]. Observable outcome is the trace of externally visible actions. 
The lan­guage has compositional observable equivalence, it is interference free (since the output alphabet 
of processes must be disjoint), and has no hiding, CCS*. The standard definition of CCS [35,36] does 
not lend itself to a simple notion of observable out­come with respect to which bisimulation, the of­ficial 
semantic equivalence of CCS, is the fullY­abstract congruence. Hence we investigate a va,ri­ant of CCS, 
closer to EPL [18], in which the observ­able outcome of a computation is defined as in CSP. Another approach 
might be to compare CCS with bisimulation equivalence to other languages using fully-abstract embedding. 
CCS* and the remain­ing languages listed below have noncompositional observable equivalence, they are 
not interference free, and they do not have composition with hiding (CCS and TCSP have hiding as a separate 
opera­tor). Linda [7]. Observable outcome is the set of tuples that eventually remain in the Tuple Space. 
 SV: Processes communicating by reading from and writing to shared variables [31]. Our results in this 
paper do not distinguish between variants that dif­fer in the degree of atomicity. In particular we do 
not distinguish between a model in which reading and writing are done in separate transitions, and a 
model, like Unity [9], where values written may depend on values read in the same transition. Ob­servable 
outcome is the limit values of the shared variables.  AC: Processes communicating by upgrading a shared 
store, whose values are taken from some par­tially ordered domain [16]. Observable outcome is limit store 
value.  TCSP: Theoretical CSP [23]. Observable outcome as same as in CSP. In contrast to CSP, TCSP is 
not interference free and does not have composition with hiding.  In addition, we are interested in 
subsets and variants of some languages. These are defined specifically for each language, but have some 
properties in common: c dL: The deterministic subset of L. ifL: The interference-free subset of a language 
L. The deterministic subset dL of L is the set of L programs in which each primitive process is deterministic. 
Note that a dL-program may be nondeterministic since the parallel composition of deterministic processes 
may ex­hibit nondeterministic behavior. We investigate dDN, dFGHC, and dCSP. They differ from their nondeter­minist 
ic sup erlanguages in that their observable equiv­alences are compositional. We investigate the following 
sublanguages, which dif­fer from their superlanguages in being interference free: ifCCS*: The sublanguage 
of CCS* in which the parallel composition of agents is allowed iff they have disjoint sorts.  ifSV: 
The single-writer sublanguage of SV (called the read-only sublanguage in the case of Unity).  ifAC: 
The sub language of AC in which parallel com­position of two pr~ce~ses is allowed iff the store aug­mentations 
of their active transitions are disjoint.  4.2 Separation The following are corollaries of Theorems 
1, 2, 3 and the properties of the algebraic languages corresponding to the concurrent programming languages 
listed above: Corollary 1 L $LF L for L c {dDN, dCSP, dFGHC, IOA} and L is any other language under con­siderate 
ion. Corollary 2 L $LS L for L ~ {DiV, CSP, IOA, ifCCS*, ifAC, if5 V, Actors, DLV} and L c {Linda, GHC, 
FCP, CCY , TCSP, AC, SV} . Corollary 3 L $LF L for L c {dDN, DN, dCSP, CSP} and L is any other language 
under consideration.  5 Conclusion and Future Work We feel we have just scratched the surface of the 
theory of language comparison and have yet to fully appreciate its applications. Concerning the theory 
itself, algebraic and category­theoretic properties of the various kinds of language em­bedding have 
yet to be studied. Concerning applications to concurrency, one inter­esting challenge is to employ the 
theory in an at­temp~ to resol~e the concurrency -as-partial-orders vs. concurrency -as-interleaving 
debate. Another possible investigation, which is somewhat independent of the one we have made, is to 
use the framework to compare the various nondeterministic choice operators that, were pro­posed in the 
context of CCS and CSP. Other open problems relate to various operational properties of concurrent languages, 
which we have not yet exploited in separation results. Examples are: Couching the results of Boug6 [4] 
and de Boer and Palamidessi [3], concerning the added expressive power of guarded input and guarded output, 
into our framework.  Showing that languages with static interconnec­tions, like Dataflow Networks, CSP, 
and CCS, can­not embed languages with dynamic interconnec­tions, such as Actors and concurrent logic 
lan­ guages.  Exploiting the ability of DLV and other concurrent logic languages to send output ports 
in messages in order to separate them from Actors, Lucy [28], and POOL [1].  Separating nonstable concurrent 
logic languages from stable ones [42,15,49].  Finding a general tool for separating synchronous models 
such as CSP from asynchronous ones such as DN.  ~oncurrent languages constitute but one of many po­tential 
application areas for this theory. Others include: Sequential programming languages: Check the ap­plicability 
of the framework to sequential program­ming languages and relate it to previous work [12,38].  Logic: 
Logics that are either equivalent or incompa­rable from a logical point of view can be compared for their 
algebraic complexity.  206 Abstract models of computation: We believe that general results such as 
the added power of nonde­terminism over determinism, alternation over non­determinism, etc., can be obtained 
using our ap­proach. Natural language: Various theories of (well-defined fragments of) natural languages 
can be compared.  Acknowledgements Comments by Frank de Boer, David Harel, Matthias Felleisen, Haim 
Gaifman, Michael Maher, Yael Moscowit z, Catuscia Palamidessi, Amir Pnueli and Moshe Vardi on earlier 
drafts are gratefully acknowl­edged. References [1] America, P., de Bakker, J., Kok, J.M., and Rut­ten, 
J., Operational Semantics of a Parallel Object-Oriented Language, Proc. 13tb ACM Symposium on Principles 
of Programming Languages, pp. 194 208, 1986. [2] de Boer, F. S., and Palamidessi, C., Concurrent Logic 
Programming: Asynchronism and Language Comparison, Proc. of 1990 North American Con­ference on Logic 
Programrru ng, S. Debray and M. Hermenegildo (Eds.), pp. 175-194, MIT Press, 1990. [3] de Boer, F. S., 
and Palamidessi, C., Embedding as a Tool for Language Comparison, CWI Technical Report, 1990. [4] Boug6, 
L,, On the Existence of Symmetric Algo­rithms to Find Leaders in Networks of Communi­cating Sequential 
Processes, Acts In formatica, 25, pp. 179-201, 1988. [5] Brock, J. D., and Ackerman, W. B., Scenarios: 
A Model of Non-Determinate Computation, in Diaz and Ramos (ed s.), Formalization of Programming Concepts, 
Lecture Notes in Computer Science 107, pp. 252-259, Springer-Verlag, 1981. [6] Broy, M. and Wirsing, 
M., Partial Abstract Types, Acts In formatica, 18, 47-64, 1982. [7] Carriero, N., and Gelernter, D., 
Linda in Context, 6 omrrI, ACM, 32(4), pp. 444-458, 1988. [8] Chandra, A. K., and Manna, Z,, The Power 
of Pro­ gramming Features, J. Computer Languages, 1, pp. 219 232, 1975. [9] Chandy, K. M., and Misra, 
J., Parallel Program De­sign, Addison-Wesley, 1988. [10] Cohn, P. M., Universal Algebra, Harper &#38; 
Row, 1965. [11] Ehrig, H., and Mahr, B., Fundamentals of Alge­braic Specification 1, Equations and Initial 
Seman­tics, Springer-Verlag, 1985. [12] Felleisen, M,, On the Expressive Power of Program­ming Languages, 
Proc. ESOP 90, N. Jones (Ed.), LNCS 432, pp. 134-151, Springer-Verlag, 1990. [13] Gaifman, H., and Shapiro, 
E., Fully Abstract Com­positional Semantics for Logic Programs, Proc. ACM Symposium on Principles of 
Programming Languages, pp. 134-142, 1989. [14] Gaifman, H., and Shapiro, E., Proof Theory and Semantics 
of Logic Programs, Proc. IEEE Sympo­sium on Logic in Computer Science, 1989. [15] Gaifman, H., Maher, 
M. J., and Shapiro, E., Re­active Behavior Semantics for Concurrent Con­straints Logic Programs, in Lusk, 
E. L., and Over­ beek, E. (eds.), Proc. 1989 North American Con­ference on Logic Programming, pp. 553-572, 
MIT Press, 1989. [16] Gaifman, H., Maher, M. J., and Shapiro, E., Re­play, Recovery, Replication, and 
Snapshots of Non­deterministic Concurrent Programs, Submitted, 1990. [17] Griitzer, G., Universal Algebra, 
D. Van Nostrand Company, Inc., Princeton, 1968. [18] Hennessy, M., Algebraic Theory of Processes, MIT 
Press, 1988. [19] Hewitt, C., A Universal, Modular Actor Formalism for Artificial Intelligence, Proc. 
International Joint Conference on Artificial Intelligence, 1973. [20] Hirata, M., Programming Language 
Doc and its Self-Description, or, X = X is Considered Harm­ful, Proc. 3 d Conference of Japan Society 
of Soft­ware Science and Technology, pp. 69 72, 1986. [21] C.T. Haynes, Logic Continuations, J. of Logic 
Pro­gramming, Vol. 4, No. 2, pp.157-176, 1987. [22] Hoare, C. A. R., Communicating Sequential Pro­cesses, 
Comm. ACM, 21(8), pp. 666 677, 1978. [23] Hoare, C. A. R., Communicating Sequential Pro­cesses, Prentice 
Hall, New Jersey, 1985. [24] INMOS Ltd., OCCAM Programming Manual, Prentice-Hall, New Jersey, 1984. [25] 
Jonsson, B., A Fully Abstract Trace Model for Dataflow Networks, 16~~ Annual ACM Symposium on Principles 
of Programming Langu ages, pp. 155­ 165, 1989. [26] Jifeng H., Josephs, M. B,, and Hoare, C. A. R., 
A Theory for Synchrony and Asynchrony, Proc. of IFLP TC 2 Working Conf on Programming Con­cenpts and 
Methods, Sea of Gallilee, Israel, April, 1990. [27] Kahn, G., The Semantics of a Simple Language for 
Parallel Programming, Information Processing 74, pp. 993-998, North-Holland, 1977. [28] Kahn, K., and 
Saraswat, V. A., Actors as a Special Case of Concurrent Constraint (Logic) Program­ming, Xerox Technical 
Report, 1990. [29] Kleinman, A., Moscowitz, Y., Pnueli, A., and Shapiro, E., Communication with Directed 
Logic Variables, To appear in Proc. of ACM POPL, 1991. [30] Landin, P. J., The Next 700 Programming Lan­guages, 
Comm. ACM, 9(3), pp. 157-166, 1966. [31] Lynch, N. A., and Fischer, M. J., On Describing the Behavior 
and Implementation of Distributed Sys­tems, TCS, 13, pp. 17 43, 1981. [32] Lynch, N.A ., and Tuttle, 
M .R., Hierarchical Cor­rectness Proofs for Distributed Algorithms, Proc. ACM Symposium PODC 87, 1987. 
[33] Manes, E. G., Algebraic Theories, Graduate Texts in Mathematics 26, Springer-Verlag, 1976. [34] 
Manna, Z., Mathematical Theory of Computation, McGraw-Hill, 1974. [35] Milner, R., A Calculus of Communicating 
Systems, Lecture Notes in Computer Science 92, Springer- Verlag, 1980. [36] Milner, R., Communication 
and Concurrency, Prentice-Hall, 1989. [37] Paterson, MS., and Hewitt, C. E., Comparative Schematology, 
Conf Rec. ACM Conference on Concurrent Systems and Parallel Computation, pp. 119-127, 1970. [38] Riecke, 
J .G., Fully Abstract Translations between Functional Languages (Preliminary Report), Proc. of ACM POPL, 
1991. [39] Reynolds, J. C., GEDANKEN -A simple typeless language based on the principle of completeness 
and the reference concept. Communication of the ACM, Vol 13 No. 5, pp.308-319, 1970. [40] Reynolds, J. 
C., The essence of Algol, in Algorith­mic Languages, de Bakker and van Vliet (Eds.), North-Holland, Amsterdam, 
pp.345-372, 1981. [41] Russel, J .R., Full Abstraction for Nondeterminis­tic Dataflow Networks, Proc. 
30th IEEE FOCS, PP.170-175, 1989. [42] Saraswat, V. A., A Somewhat Logical Formulation of CLP Synchronization 
Primitives, in Bowen, K., and Kowalski, R.A. (eds.), Proc. 5tk International Conference Symposium on 
Logic Programming, pp. 1298-1314, MIT Press, 1988. [43] Saraswat, V. A., Kahn, K., and Levy, J., Janus: 
A Step Towards Distributed Constraint Program­ming, To appear in Proc. 1990 North American Conference 
on Logic Programming, S. Debray and M. Hermenegildo (Eds.), MIT Press, 1990. [44] Shapiro, E. (Editor), 
Concurrent Prolog: Collected Papers, Vols. 1 &#38; 2, MIT Press, 1987. [45] Shapiro, E., The Family of 
Concurrent Logic Pro­ gramming Languages, ACM Computing Surveys 21(3), pp. 412-510, 1989. [46] Sussman, 
G. J., and Steele, G. L., Jr., Scheme: An Interpreter for Extended Lambda Calculus, Memo 349, MIT AI 
Lab., 1975. [47] Ueda, K., Guarded Horn CJauses, Ph.D. The­sis, Information Engineering Course, University 
of Tokyo, Tokyo, 1986. [48] Ueda, K., and Furukawa, K., Transformation Rules for GHC Programs, Proc. 
International Conference on Fifth Generation Computer Science, pp. 582 591, 1988. [49] Yardeni, E., Kliger, 
S., and Shapiro, E., The Lan­guages FCP(:) and FCP( :,?), J. New Generation Computing, 7, pp. 89-107, 
1990. 208 
			
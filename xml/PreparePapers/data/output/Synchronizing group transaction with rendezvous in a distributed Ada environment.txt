
 SYNCHRONIZING GROUP TRANSACTIONS WITH RENDEZVOUS IN A DISTRIBUTED ADA ENVIRONMENT ° Marta Patifio-Martinez 
Ricardo Jim~nez-Peris Sergio Ardvalo Universidad Politdcnica de Madrid Facultad de Inform~tica 28660 
Boadilla del Monte (Madrid), Spain {mpatino, rjimenez, sarevalo}@fi.upm.es Keywords: Distributed Systems, 
Fault-Tolerance, Group Communication, Transactions. Abstract The group communication paradigm (multicast 
com- munication) has been proposed as a useful interaction mechanism in many distributed applications. 
In this paradigm, a client sends a service request to a group of processes (it multicasts a request), 
and then all the members of the group receive the request and cooper- ate among them to provide the service. 
On the other hand, transactions allow a client to interact with dif- ferent services in an atomic way. 
Transactions exhibit isolation, failme atomicity and permanence of effect of client operations. We have 
developed a model that integrates transactions with the group communication paradigm. Drago is a distributed 
extension of Ada im- plementing the group paradigm. Transactional Drago is an extension of Drago that 
implements our model. As in Ada, Drago processes interact via rendezvous, while client and server transactions 
traditionally have inter- acted via remote procedure call (RPC). Besides this, RPC presents some shortcomings 
that can be overcome using rendezvous. For these reasons, we find necessary to use the rendezvous as 
the synchronization mechanism between client and server transactions. We present in this paper which 
are the advantages and difficulties of this approach and how it has been introduced in our system. 1 
INTRODUCTION Transactions [10] are a mechanism to provide fault tol- erance. The3' provide useful properties 
for constructing reliable distributed applications. These properties are failure atomicity, isolation 
and data consistency. On °This work has been partially funded by the Spanish Research Council(CICl'T~. 
contract number T1C94-C02-01. Permission to make digital/hard copy of all or part of this work lbr personal 
or classroom use is granted without fee provided that copies are not made or distributed for profit or 
commercial advantage, the copyright notice, the title of the publication and its date appear, and notice 
is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers 
or to redistribute to lists, requires prior specific permission and/or a fee. &#38;#169; 1998 ACM 0-89791-969-6/98/0002 
3.50 the other hand, the group communication paradigm, in particular Causal and Totally Ordered Communication 
(CATOCS) [4], has also been proposed as an adequate way to build fault tolerant applications such as 
coop- erative and replicated ones. There has been some controversy about which of those mechanisms is 
more adequate to build fault tolerant applications. In [6] some limitations of CATOCS are identified, 
in particular, the applicability of CATOCS is limited to those applications where application-level consistency 
is required. One of these limitations is the lack of serialization ability for groups of messages corresponding 
to different operations. CATOCS just provides ordering properties between individual messages, but some 
applications require handling groups of messages as a serial unit. This in- ability to group operations 
also affects to the handling of higher-level errors. For example, in replicated appli- cations CATOCS 
guarantees that every server receives the message, but if some of the servers are unable to fulfill the 
operation due to some reason (e.g. storage problems), the programmer has to write a lot of code to coordinate 
this partial failure, because other replicas will be processing the message. In other words, total ordering 
does not guarantee anything once messages are delivered. However, atomic transactions allow a server 
to abort (undo) easily a set of operations in this scenario. Another limitation identified in the paper 
is that many semantic ordering constraints cannot be expressed in CATOCS, for instance: linearizability 
[14] and serializability. In summary, CATOCS provides complementary fault tolerance to the one provided 
by transactions. Despite the shortcomings discussed above, CATOCS offers some benefits [3] missing in 
the transaction model: Its framework allows the construction of (efficient) distributed cooperative 
servers.  It improves process and data availability by means of replication.  Schiper and Ravnal [19] 
state that transactions and group commumcation are not antitheticM. Others, [20] conclude that b,~th 
('ATO('S and lransac'lion models are useful, and that some applications are better solved with CATOCS, 
while others with transactions. Our opinion is that both paradigms are comple-mentary and that it is 
necessary a system offering both mechanisms, in an orthogonal way. So, our approach is to integrate both 
paradigms. We have developed a new transaction model, Group Transactions I that integrates both approaches. 
We have followed a linguistic approach starting from a fault-tolerant distributed language, Drago [1, 
16], that implements the group paradigm. Transactional mechanisms have been incorporated in a new version 
of the language called Transactional Drago. Drago is a distributed extension of Ada. It allows to program 
two kinds of groups: replicated groups that provide control and data availability, and cooperative groups 
that provide a framework to program coopera- tive applications with high throughput and low latency. 
Our model presents some novelties. First of all, the integration of both paradigms by means of transactional 
groups that provide atomic services to client transactions. Secondly, a service is provided as a subtransaction 
that is distributedly executed by all the members of the group, that can cooperate among them to provide 
the service. In the traditional transaction model a service request is accepted by a single server, that 
can call concurrently to other servers, but each of these calls are executed as different subtransactions, 
preventing cooperation among them. Ada concurrency support is kept in Transactional Drago. In our model, 
concurrency is allowed within a transaction, that is, a transaction can be multi-threaded. Besides this, 
the server is able to enforce an order to multiple concurrent interactions, in spite of the misuse of 
the server calls on the client side, providing data consistency in the server. One of the problems found 
when designing our model was the election of the synchronization mecha- nism to be used between client 
and server transactions. Remote procedure call (RPC) [10, 21, 8, 15] is the syn- chronization mechanism 
commonly used. When a RPC is issued, a client transaction borrows a flow of control in the server to 
execute the procedure that will perform some work on server data. The execution of concurrent RPCs does 
not impose any order to the server to serve client requests other than the order imposed by the internal 
synchronization mechanisms available in the server (e.g. locks). On the other hand, the rendezvous model 
is traditionally used in message based concurrent applications with a client-server structure. The client 
asks for a service sending a message to the server and the server decides when to accept the service 
requested by that message (establishing in that way the rendezvous), thus enforcing an order to serve 
requests. Even though the Ada95 Distributed Annex ('hoosos tho RP(' modol for distributed communication. 
Drago provides a remote rendezvous approach, not l'I't:~lls;I, ti,,l, gl.,tl[)~. I,lr;I)os(~(t ill [9]. 
iS ~. different model, de-~uile thr ~imilariuc ,,f th(" names. only because 'of its expressiveness, but 
also due to reasons related to the group communication and the -replicated group paradigm. Members of 
replicated groups must receive the same requests in the same order and this canbe achieved much more 
easily with a unique flow of control. Thus, replicated group members can decide deterministically what 
to do, in contrast with uncontrolled requests (RPC). Transactional groups introduce new reasons to use 
the rendezvous approach. In our model, clients and servers interact by means of rendezvous to allow a 
server to impose a protocol of calls to its clients. This paper will focus on the use of rendezvous to 
synchronize client and server transactions in a distributed Ada environment. Some effort has been devoted 
to study how to implement atomic actions [18, 23, 5] in Ada-95. How-ever, they just deal with the isolation 
property, and they do not care about failure atomicity and recovery. In addition, these works center 
in how to use Ada mechanisms to implement them, while ours centers on transactions (so we deal with recovery) 
and their integration with the group paradigm. Furthermore, our work is focused in the introduction of 
linguistic features. There are other systems providing atomic transac- tions as language mechanisms or 
libraries [15, 8, 21], but they use RPC as synchronization mechanism between client and server transactions 
and they do not support the group paradigm. They only allow concurrency within a transaction running 
concurrent subtransactions, thus preventing any cooperation among them. This paper is organized as follows. 
Section 2 in- troduces transactions. Section 3 summarizes the main features of Drago. Section 4 presents 
our model, group transactions, while in section 5 we propose how to syn- chronize client and server transactions 
in the context of this model. Finally, we present our conclusions in section 6. 2 TRANSACTIONS A transaction 
is a sequence of server operations requested by a client that are executed atomically, that is, the whole 
sequence is executed or the effect is as it never has been executed. Transactions preserve four properties 
(known as ACID properties [13]): atomicity, consistency, isolation (serializability) and durability. 
Atomicity guarantees that the effect of the transaction is all or nothing in spite of failures. Isolation 
ensures that two concurrent independent transactions will not interfere. Durability ensures that once 
a transaction has finished its effect will continue despite failures. To deal with isolation, concurrency 
control mechanisms are used. while to preserve atomicity and durability recovery mechanisms are employed. 
Transactions that involve several servers located in different nodes in tile network are called distributed 
transactions. When a distributed transaction fin- 3 ishes, all the involved servers commit or all of 
them abort. To ensure the atomicity of a distributed transaction, commit protocols are used. One of the 
best-known protocols is the two-phase commit protocol. Client and server transactions traditionally interact 
via RPC [15, 21]. Servers offer their services as re-mote procedures and clients use them via RPC. If 
a server needs to interact with another server it also issues a RPC. RPCs are executed as subtransactions 
of the client transaction. Thus, transactions can be nested. Nested transactions [17] are useful for 
two reasons: they allow additional concurrency within a transaction (par- ticularly in distributed systems) 
by running nested con- current subtransactions and the failure of a subtransac- tion does not force the 
parent to fail, providing a firewall against failures. However, the concurrency allowed is very limited, 
as concurrent subtransactions cannot co-operate. There are several languages and systems that implement 
the nested transaction model [15, 8, 21]. DRAGO Drago [16] is a language to program fault-tolerant dis- 
tributed applications that supports the group paradigm. It has been implemented as a distributed extension 
of Ada. Drago provides two group abstractions: replicated groups and cooperative groups. Groups are composed 
out of agents that are the distribution unit of Drago. Group communication in Drago is based on the client- 
server model. Groups interact using group remote ren- dezvous (GRR), the rendezvous extension for calling 
a group. Figure 1: Client-Server interaction in Drago Replicated groups provide fault tolerance by means 
of modular redundancy (via a set of deterministic repli- cas). They behave as single agents tolerating 
failures of its members in a transparent way to the client. For this reason, this kind of group returns 
a unique answer to the client (figure 1.b), as all the answers are the same. Cooperative groups allow 
writing distributed appli- cations. In these applications, members of the group cooperate to achieve 
a common goal. A cooperative group ('an im-rease the throughput of a server, reduc-ing the latency, of 
the service, as well as tolerate partial faih,res, working m a degraded mode. \Vl,ext a service is requested 
lO a cooperative group, the xesuh of this service is the set of answers of all its members (figure 1.a). 
Agents are an extension of Ada tasks; they have a main thread and interact via GRR. When an agent is- 
sues a GRR to a group, the call is multicasted to all the members of the target group (figure 1). The 
multi- cast implemented in Drago [11, 12, 1] has the following properties: Atomicity: a message is either 
delivered to all of the live agents of the target group or to none of them. As far as the sender is alive, 
it will try to send the message again.  Total ordering: all the messages sent to a group are delivered 
in the same order to all the group agents.  Causal ordering is a FIFO ordering where mes-sages from 
the same sender are delivered in the same order in which they were sent, and messages from different 
senders are delivered according to the causal precedence relation among messages.  Uniformity: if a 
message is delivered to any process of the group (even if it dies immediately after), it will be delivered 
to all the alive processes.  These properties ease the programming of fault- tolerant applications. 
In Ada, each task has a specification with the entries provided by it. In Drago, this specification is 
extended for groups of agents and is called group specification. The group specification provides the 
common interface of all the agents of a group. A group specification is similar to an Ada package declaration; 
it contains declarations of constants, types and exceptions, plus group entry declarations. There are 
two sections within the group entry declaration. The first section is public (intergroup declaration) 
and corresponds to the services provided by the group. The second one is only visible to group members 
(intragroup declaration) and it is only applicable to cooperative groups. It must be noticed that entries 
declared in the intergroup declaration could be used by clients of the group, but entries declared in 
the intragroup declaration can only be called by the members of the group to interact among them. There 
is a special intragroup entry that is automat- ically called (if declared) by the runtime system when 
an agent of a cooperative group fails. This feature is termed ]ailure notification and is very important 
when writing distributed servers tolerating partial failures. This notification is treated as any other 
GRR. Agents can accept entry calls by means of accept statements. Once all (live) agents finish the accept 
statement, the result and control is returned to the client. As in Ada tasks, only the main flow of a:~ 
agent can accept group remote calls. 4 GROUP TRANSACTIONS its subtransactions have finished. Our model 
is an integration of the group communica- tion and transaction paradigms, that ex£ends the nested transaction 
paradigm [17]. The integration of the group and transaction models overcomes some shortcomings of both 
paradigms: It improves transaction latency, because dis-tributed servers may run concurrently, probably 
cooperating, to provide a transactional service.  Available transactions. One of the problems of long 
transactions in the traditional transaction model is its low availability (because of its dura- tion, 
the likeliness of aborting, due to crashes, is higher than in short transactions). Our integration allows 
the replication of both clients and servers, that is, a transaction can be initiated by a repli- cated 
group. This increases the availability of the transaction because it will survive node failures.  Isolation 
of a sequence of group calls. In our model, a set of group calls (total and causally ordered op- erations) 
can be serialized with respect to other operations encapsulating them within a transac- tion.  Failure 
atomicity of a sequence of group calls. There is an additional advantage of the encapsu- lation of a 
group of operations in a transaction. It consists in the possibility of undoing the effect of a whole 
group of operations in case some kind of exception arises.  Transactions ease recovering from a network 
parti- tion of a group during a client/server interaction.  One of the main features of our mo(iel is 
that it al- lows concurrency within a transaction. This intratrans- actional concurrency allows decreasing 
the latency of transactions. There are two kinds of intratransactional concurrency: Multi-thread transactions. 
A transaction can have several tasks, that is, several flows of execution can act on the behalf of a 
transaction. This allows taking advantage of multiprocessor capabilities.  Multi-process transactions. 
A transactional ser- vice requested to a group will be provided by all the agents of the group. This 
service is executed as a single multi-process subtransaction of the client transaction. Due to all the 
agents are part of the same transaction, they will be able to cooperate using intragroup communication. 
 Flows of execution of a transaction, concurrent or distributed, are called fingers 2. Fingers of the 
same transaction are called sibling fingers. Sibling fingers are not concurrent subtransactions, they 
are part of the same transaction. :\ finger can initiate a subtransaction anytime. A transaction ends 
when all its lingers t~axe tinishcd and a finger fimshes whcu all 2"l'his i~ame wa-hlsph,'d tw a r:d," 
,,f ;i:,' .\~im,~xs hook "'I Transactions are serialized in the traditional way. The final effect of 
the concurrent execution of two transactions must be the same as if they were executed sequentially in 
any order. That is, as if all the fingers of the transaction serialized in the first place were executed 
first and then all the fingers of the other transaction. Because a transaction can be composed of several 
fingers, if one of the fingers initiates a subtransaction (e.g. calling a server) the rest of them will 
continue running. So, in this sense, the parent transaction and a child of it will be running at the 
same time. This is different in the nested transaction model, where a transaction with concurrent subtransactions 
will be blocked waiting for the end (commit or abort) of its children. In the traditional transaction 
model, transactions are automatically serialized, so the concurrency control among transactions is implicit, 
and there is no other concurrency than the concmrrent execution of different transactions. On the other 
hand, in a concurrent/distributed language concurrency control is explicit, but there are no transactions. 
However, in our model we have to deal with both kinds of concurrency control: transactions must be serialized 
(inter-transactional concurrency control) and tasks and agents within transactions (i.e. sibling fingers) 
must synchronize and communicate among them (intra-transactional concurrency control). One of the difficulties 
to be solved is how to prevent in- terference between both concurrency controls, keeping inter-transactional 
concurrency control implicit and intra-transactional concurrency control explicit. To illustrate the 
differences between them, consider the following examples: two fingers (e.g. two tasks within the same 
transaction) can synchronize by means of rendezvous, that is, one calls an entry of the other, and the 
other accepts the call to that entry. On the other hand, if one transaction acquires a lock on a datum 
and a second one tries to lock the same datum in an incompatible mode, the second transaction will be 
blocked until the first transaction ends. It must be noticed that in the first example synchronization 
is explicit, while in the second one is implicit. There is an additional kind of synchronization to take 
into account: client and server transactions synchronization [2]. Client and server transactions usually 
synchronize using remote procedure call (RPC). That is, the client transaction triggers the server subtransaction 
and waits for the end of it. A thread is created in the server to provide the requested service. This 
thread executes the server subtransaction and when the service finishes. it commits and returns the results 
to the client. Then, the client continues its execution. This type of synchronization between client 
and server transactions is also known as single-request [22]. It must be noticed that in this case the 
synchronization is explicit, but it is not the same than intra-transactional synchronization due to the 
synchronization is between two different transactions (one is the parent of the other). Client and server 
transactions synchronization can also be 5 conversational [22], that is the client transaction issues 
a set of requests to the server and then decides whether to commit or abort that transaction. During 
the conversation, control changes between client and server, each time the client transaction issues 
a request, the server transaction is responsible of generating an answer. Conversational synchronization 
is the one used in our model. We propose the use of rendezvous as synchroniza-tion mechanism between 
client and server transactions, because it overcomes the following problems of RPC: A server using RPC 
cannot enforce (easily) a pro- tocol of interaction with its clients.  As in our model, concurrency 
is allowed within a transaction, synchronization among different fin- gers of a transaction to access 
a server cannot be easily achieved by means of RPC.  5 DISTRIBUTED INTERACTION IN THE GROUP TRANSACTION 
MODEL Many client-server applications present a pattern of interaction among clients and servers that 
requires a protocol of invocations rather than a single invocation. That is, the operations provided 
by the server need to be called in a predetermined order, following a protocol, to provide that service. 
The following example will be useful for the discus- sion. A distributed file server can offer a service 
struc- tured into two different protocols: Protocol 1: Open a file in read mode. One or more reads. 
Close file.  Protocol 2: Open a file in write -mode. One or more writes. Close file.  If we want this 
service to be atomic, the whole interaction should be within a transaction. Each call to a server operation 
will be a subtransaction. The client must call the operations of the server following the protocol. But 
if RPC is used, these subtransactions will have no relation between them on the server side. The server 
has not an easy way to check whether its operations have been called in the preestablished order and 
to keep track of which clients have requested them. In order to perform this checking a lot of work must 
be done on the server side compiling information about the order in which operations are done. Furthermore, 
this compiled information would create a bottleneck because all the transactions have to access it. Thus, 
the RPC model of interaction between clients and servers does not provide adequate support for this kind 
of (multiple) interaction. When the interaction among clients and servers requires a protocol of invocations, 
it is more expressive a dialogue-oriented mechanism than an operation-oriented one, such as RPC. (:stag 
such a dialogue-oriented mechanism, the server can easily enforce a protocol to the client. Additionally. 
in our model RP(" ha.~ am)ther disadvamage, i)u(' to a client T ransa(:tion can be muhi- threaded, when 
using I:¢P(" mechanism, the s(,rv('r is unable to enforce a protocol to client concurrent. invocations. 
Using RPC, the server must rely on the correctness of the concurrency control on the client side. A lot 
of effort is needed to ensure that concurrent invocations of the same transaction are issued in the right 
order. The use of rendezvous as transaction interaction mechanism helps to solve both problems, because 
with rendezvous the server will explicitly accept each oper- ation in a particular order, enforcing a 
protocol. This protocol is enforced both when client is single-threaded and when it is multi-threaded. 
However, rendezvous cannot be directly applied as it is discussed next. 5.1 Interaction Between Client 
And Server Transactions The first approach to use rendezvous for client and server transaction interaction 
is a naive one. In this approach, the main thread of a server has to deal with all the transactions interacting 
with the server. The first problem we find with this approach is that it is too prone to deadlocks. The 
server will deal with all the calls in its main thread, so the first time it tries to lock a datum on 
behalf of a transaction that was previously locked by a still uncommitted transaction, it will be blocked. 
If the transaction holding the lock tries to interact again with the server a deadlock occurs. This situation 
or similar ones can happen very likely when different transactions access the server in an interleaved 
way. If a single thread serves all the requests in the server using rendezvous, new dependencies in the 
waits-for graph appear, inc-easing too much the probability of cycles (deadlocks). And what is worse, 
it is not sensible to allow the same server thread to deal with rendezvous calls from different clients 
as it could not distinguish which client it is interacting with, so it could not enforce a protocol to 
each client. When RPC is used, this problem does not arise due to each time a call to a server is made, 
a new thread is created, so client and server interaction does not introduce edges in the waits-for graph. 
The second approach to solve this problem, the one we have followed, is to create a thread in the server 
for each transaction interaction, understanding as interaction the whole dialogue between client and 
server transactions to achieve a service. The first time a client transaction issues a call to a group, 
a new thread (a finger of the server transaction) is created in each agent of the group to serve the 
client transaction. A set of sibling fingers will serve all the calls from a client interaction, and 
they will only block when the server tries to lock a datum that is locked with an incompatible lock held 
by other transaction. It must be noticed that, in each agent of the server group, a thread will be created 
to serve each request. and that all the threads corresponding to an agent will run the same code. that 
is. the code written for the agent. Fhis is the natural extension of atomic R P(" t,-, 6 atomic rendezvous 
(figure 2.a). From now on, we will consider groups of one agent, without loss of generality. a) A single 
service for a client transac'tion. b) Two interleaved services (of different sewers) for the same client 
transaction. --v- c) Two int~teaved nrvicea of the sarne server d) Two intecleaved services of ~'te 
unll for two different client subtransactlona, server for the same client transaction. Figure 2: Types 
of interaction between client and server transactions A client transaction might need to interact with 
two different servers interleaving calls to them. In this case each service will be provided by a different 
group, creating a new thread in each group to serve each protocol in that transaction (figure 2.b). Another 
issue that must be solved is how to deal with the situation where a client transaction needs two simultaneous 
services a from the same server. The difficulty comes from the fact that server threads are automatically 
created and associated to client transac- tions, so restricting to one the number of interactions with 
a server per client transaction. The server will only see one client transaction, so any request from 
this client will be served by the same server thread. There are two different scenarios to study from 
the client's perspective: when the client requires two (or more) independent services (i.e. intermediate 
results of one are not needed by the other) and when the client requires two (or more) dependent services. 
An example of the former is when a client needs to write two different files with no relationship between 
them. An example of the latter is when a client wants to copy one file into another, record by record 
(because the file to copy is very big), so it will need to interleave calls to both services (i.e. calls 
to read a record from the source file and to write a record to the target file). In the first case, services 
are independent, so it can be solved without introducing any new language mechanism. The client can start 
two concurrent subtransactions, one for each of the services (by means of two threads, each one initiating 
explicitly a sublransaction). As the .qelvlcos are re(lUebtod by different transactions, a diiferent 
thread wd[ be created ~ lhi- i~ a general tu,fl~l,un i~l ,ti~llil,ul,.d .llU,li, ,~i,,n~ ,m .... [llti,,l! 
, I11 hf + il+]itp~O(] l,' ~l II,J[1 tl;lllq.t.'f D~tl.tl +[i<~:!}"it' 'i "'.'" tl. for each one on the 
server side (figure 2.c). On the other hand, when the services requested are not independent, the client 
will need to keep two different interleaving protocols. For instance, using again our example, to copy 
a file it will be needed: a protocol to read the source file and another one to write the target file, 
interleaving the operations of both protocols. For this reason, it is necessary a way to identify concurrent 
interactions from the same client transaction to the same server. Transactional Drago copes with this 
problem providing a way to associate interaction identifiers for simultaneous interactions with the same 
server. Each operation request will be identified by its interaction identifier. This will allow the 
server to distinguish them, and will create a different thread for each service, associating the right 
server thread to each operation request. To avoid handling with interaction identifiers in the usual 
cases (one interaction per client transaction) automatic server thread association is used by default. 
 5.2 Subtransaction Management, and Struc-ture Unfortunately, the nested transaction paradigm does not 
provide support for this kind of synchronization between client and server transactions. The serializ-ability 
of the server transaction must be relaxed to allow the client to use the results of each rendezvous call. 
The traditional model has a very strict notion of serializabilit_y. This is because it was intended for 
short transaction~in competitive environments, but it fails to fulfill the-requirements of long and cooperative 
ap- plications, that have been called complex transactions [7, 9]. In our model, an interaction between 
client and server transactions, happens as follows: The service requested by the client transaction 
is executed in the server as a subtransaction.  The first time the client transaction interacts with 
the server, a thread is created in each agent of the server group for the whole interaction. These threads 
are sibling fingers of the server subtrans-action.  The client and server transactions synchronize by 
means of remote rendezvous.  Each accept on the server initiates a new subtrans- action of the server 
transaction (the accept sub-transaction will be executed by all the agents, each one running a finger 
of the subtransaction). In this way, client and server can mask partial failures of the interaction. 
 At the end of the accept., the server transaction inherits the locks acquired by the accept subtrans- 
action. Then, the server returns control to the client, and makes visible its state to the client. In 
lhis sense, tile server transaction has several com-mit points (one per call) [7] to make available its 
~late to the client transaction.  Because of its semantics, there is an abort depen- dency [7] between 
client and server transactions. This means that if the server transaction aborts, the client transaction 
will also be aborted. It is not possible to undo the server subtransaction without undoing the client 
transaction.  A transaction can only commit when all its fingers have finished.  Tasks declared inside 
the scope of an agent of a transactional group will be considered fingers of the server transaction, 
while tasks declared within the scope of an accept will be considered fingers of the accept subtransaction. 
Aborts have been integrated with the Ada exception mechanism. Transaction implicit aborts (e.g. due to 
crashes or logging problems) are propagated as a predefined exception, abort, and they are propagated 
and handled as any other exception. An unhandled exception inside a transaction forces the abortion of 
the enclosing transaction. If the server transaction aborts during an accept (i.e. due to an unhan-died 
exception), the exception will be propagated to both client and server, as it happens in Ada rendezvous. 
5.3 Transactional Drago Transactional Drago implements our transaction model by introducing two kinds 
of groups: transactional co- operative groups and transactional replicated groups. Both kinds of groups 
have some important differences with non-transactional Drago groups: They provide atomic services. 
 They can have persistent data, that is, data stored in non volatile memory. Their declaration is pre- 
fixed with persistent.  The code of Drago agents, usually contains an infinite loop that processes requests. 
This code must deal with concurrent accesses from differ- ent clients. In contrast, the code of transactional 
agents only deals with one client interaction. Au- tomatic thread creation takes care of offering ser- 
vices to different clients. In summary, Drago agents are active, while transactional agents are passive. 
 Transactional groups must handle abort excep-tions to cope with partial failures.  Transactional 
Drago also introduces new linguistic mechanisms to support transaction creation: A construct to create 
a transaction. We have cho- sen the syntax of the Ada block statement due to its suitability, as it provides 
a scope and a dec-laration part. Ada blocks are distinguished from transactional ones by prefixing begin 
with trans- actional.  Only tasks declared inside the transactional block will bc considered lingers 
of the transaction.   Drago (non-transactional) groups can only interact with transactional groups 
within a transaction.  Transactional groups can only interact with trans- actional groups. This restriction 
and the previous one help to guarantee isolation of transactions, pre- venting transactions from interacting 
using non- transactional groups.  Abort is a predefined exception, raised when im- plicit aborts happen. 
 When an unhandled exception within a trans-action propagates, the enclosing transaction is aborted. 
 To start a new interaction with a server, it must be named. The new interaction is declared as follows: 
newlnter is new interaction. Calls to the server group within the new interaction must be qualified with 
the group name.  6 CONCLUSIONS A new synchronization mechanism between client and server transactions 
has been presented in the context of the Group Transaction model, a model that integrates both group 
and transaction paradigms. This new synchronization mechanism is based on rendezvous, in contrazt with 
the synchronization mechanism used in the traditional transaction model,. based on RPC. The advantage 
over the RPC is that the server can impose easily a protocol of calls. In. addition, it becomes essential 
in complex transaction * models, like group transactions. In particular, a client.- can manage more easily 
the synchronization of the accesses of its different threads to a server. Another conspicuous novelty 
of the proposed mechanism is that the server is able to deal with simultaneous interactions of the same 
client. The choice of rendezvous as the synchronization mechanism allows a smooth integration with Drago, 
because it is the communication mechanism used by agents. Acknowledgments We wish to thank to Mikel Larrea 
for his help and com- lnents. References [1] S. Ar6valo, tit. ,g, lvarez, J. Miranda, and F. Guerra. 
A Fault-tolerant Programming Language Based on Distributed Consensus. Gabernet'94 Workshop, .Mar. 1994. 
[2] N. S. Barghouti and G. E. Kaiser. Concurrency Control in Advanced Distributed Database Appli- cat 
ions. A CM Computing Surveys, 23(3) :269-317~ Sep. 199l. 8 [3] K. P. Birman. A Response to Cheriton 
and Skeen's Criticism of Causal and Totally Ordered Commu- nication. Operatin 9 Systems Review, 28(1):11-20, 
Jan. 1994. [4] K. P. Birman and R. van Renesse. Reliable Dis-tributed Computing with Isis Toolkit. IEEE 
Com- puter Society Press, 1994. [5] A. Burns and A.J. Wellings. Ada 95: An Ef-fective Concurrent Programming 
Language. In A. Strohmeier, editor, Reliable Software Technolo- gies, Ada-Europe'96, volume LNCS 1088, 
pages 58-77. Springer, 1996. [6] D. R. Cheriton and D. Skeen. Understanding the Limitations of Causally 
and Totally Ordered Com- munication. In 14th ACM Symposium on Operat-ing Systems Principles, Asheville, 
North Carolina, pages 44-57, Dec. 1993. [7] P. K. Chrysanthis and K. Ramamritham. ACTA: A Framework for 
Specifying and Reasoning about Transaction Structure and Behavior. In ACM SIG- MOD International conference 
on Management of Data, pages 194-203, 1990. [8] J.L. Eppinger, L.B. Mummert, and A.Z. Spector. Camelot 
and Avalon. Morgan Kaufmann Publish- ers, 1991. [9] M. F. FernAndez and S. B. Zdonik. Transac-tion Groups: 
A Model for Controlling Coopera- tive Transactions. Third International Workshop on Persistent Object 
Systems, pages 128-138, 1989. [10] J. Gray and A. Reuter. Transaction Process-ing: Concepts and Techniques. 
Morgan-Kaufmann, 1993. [11] F. Guerra, S. Ar6valo, A. Alvarez, and J. Miranda. A Distributed Consensus 
Protocol with a Coor-dinator. In Int. Conf. on Decentralized and Dis- tributed Systems. ICDDS'93. IFIP. 
Palma de Mal- lorca, pages 85-96. Elsevier, Sept. 1993. [12] F. Guerra, J. Miranda, ./~. :~lvarez, and 
S. Ar6valo. An Ada Library to Program Fault-Tolerant Dis-tributed Applications. In K. Hardy and J. Briggs, 
editors, Reliable Software Technologies, Ada-Europe'9Z volume LNCS 1251, pages 230-243. Springer, 1997. 
[13] T. Haerder and K. Rothermel. Principles of Transaction-Oriented Database Recovery. A CM Computer 
Surveys, 15(4):287-317, 1983. [14] MP. Herlihy and J. M. Wing. Linearizability: A Correctness Condition 
for Concurrent Objects. ACM Transactions on Programming Languages and Systems, 12(3):463-492..Jul. 1990. 
[15] t3. Liskov. l)istributed Programming in .\rgus. Comuzunications of the A CA[. 31 (3):300 312..~Iar. 
19b~. [16] J. Miranda, A. Alvarez, S. Ar~vaio, and F. Guerra. Drago: An Ada Extension to Pro-gram Fault-tolerant 
Distributed Applications. In A. Strohmeier, editor, Reliable Software Technolo- gies, Ada-Europe'96, 
volume LNCS 1088, pages 235-246. Springer, 1996. [17} J. E. Moss. Nested Transactions: An Approach to 
Reliable Distributed Computing. PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, 1981. 
Also, Tecnnical Report MIT/LCS/TR- 260. [18] A. Romanovsky, S.E. Mitchell, and A.J. Wellings. On Programming 
Atomic Actions in Ada 95. In K. Hardy and J. Briggs, editors, Reliable Software Technologies, Aria-Europe'97, 
volume LNCS 1251, pages 254-265. Springer, 1997. [19] A. Schiper and M. Raynal. From Group Commu- nication 
to Transactions in Distributed Systems. Communications of the ACM, 39(4):84-87, 1996. [20] S. K. Shrivastava. 
To CATOCS or not to CATOCS, that is the ... OperatiNg Systems Re- view, 28(4):11-14, Oct. 1994. [21] 
S. K. Shrivastava, G. N. Dixon, and G. D. Par- rington. An Overview of Arjuna: A Programming System for 
Reliable Distributed Computing. IEEE Software, 8(1):63-73, Jan. 1991. [22] B. Walter. Nested Transactions 
with Multiple Commit Poinf, s: An Approach to the Structuring of Advanced Database Applications. In lOth 
In- ternational Conference on Very Large Data Bases, pages 161-17!, 1984. [23] A. Wellings and Burns 
A. Implementing Atomic Actions in Ada 95. IEEE Transactions on Software Engineering, 23(2):107-123, Feb. 
1997. Marta Patifio-Martinez received a MS degree in computer science in 1990 from Universidad Polit(icnica 
de Valencia. She is currently working on Group Trans- actions, an integration of the transaction and 
group communication paradigms. She has been assistant pro- fessor in computer science at Universidad 
Polit~cnica de Madrid since 1990. She is member of the Associa- tion for Computing Machinery and the 
IEEE Computer Society. Ricardo Jim6nez-Peris holds a MS degree in com- puter science from Universidad 
Politfcnica de Madrid (1990). He is currently working on TransLib, an ob- ject oriented framework to 
program fault-tolerant pro- gramming systems. He has been assistant professor in computer science at 
Universidad Polit6cnica de Madrid since 1990. He is member of the Association for Com- puting .Machinery. 
Sergio Ar6valo is an associate professor of com- puter science at Universidad Politdcnica de Madrid. 
His research interest include distributed systems, fault- tolerance, operating systems and real-time 
systems. He has been visiting researcher ATT Bell Laboratories and research fellow in the European Space 
Agency. He re- c~ived a PhD in computer Science from Universidad Polit(,cnica de .Madrid. He is a member 
of ACM since 19~:L 9   
			
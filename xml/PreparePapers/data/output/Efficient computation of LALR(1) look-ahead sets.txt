
 by Frank DeReBer Thomas J. Pennello Information Sciences University of California ~an~a Cruz, CA. 95064 
We define two relations that capture the essential structure of the proble~ of co~-putin 9 LALR(1) look-ahead 
sets, ~nd present an efficient algorith~ to co~pute the sets in ti~e linear in the size of the relations. 
In particular, for a PASCAL 9tartar, our algorith~ performs less than 20~ of the set unions performed 
by a popular coMpiler-compiler (YACC). gg¥ ~g£~! ~d Eb£!~g~: context-free, LR(k), and LALR(k) 9tartar, 
parser, syn-tactic analysis, look-ahead~ digraph , stronGly-connected component. ~ ~39£~: 4.12, 5.23. 
Note: Due to the restricted character set of the device on which this text was printed, we use the followin9 
conven-tions: cross product S set MeMbership set union U indexed set union, e.~. y S~ set inclusion t 
Greek K Greek Greek Greek Greek UJ Greek Subscriptin9 is often indicated by placin9 the single subscript 
to the right of the subscripted element, as in vl, iO, qt, BI, or when the subscript is an expression, 
it is enclosed in parentheses, as in q(k+1). (+) is used to denote footnotes. Since the invention of 
LALR(1) 9r~M-~ars [DeR 69], the LALR 9raNMar analysis and parsing techniques have been popular as a component 
of translator writin9 sys-tems or coMpiler-coMpilers. However, DeReMer did not describe how to compute 
the needed look-ahead sets. Instead, LaLonde was the first to present an algo-rithm [LLH 71]. Since then 
LaLonde's algorithm has been published by Anderson, Eve, and Hornin9 [AEH 72, p. 21-22], who also presented 
their own algorithm (p. 21), and Aho and UllMan have published the one used in the YACC coMpiler-coMpiler 
[A&#38;U 77, p. 238]. Various others have tried their hand ~t designin9 such an algorithM, often with 
the result of iMpleMentin9 a particular subset of LALR(1) that we have dubbed "not quite" LALR(1) or 
NQLALR(1) [DeR 72, gat 74, get 77]. Subsequently, g~,tt attempted to repair his original approach [Wat 
76], as did Chaney with DeReMer~s approach [Alp 76]. Neither of these later attempts was correct, although 
both were More complex and worked in More cases than did the NQLALR Method. None of the correct LALR(1) 
algorithms, however, have been nearly as efficient as their NQLALR(1) counterparts. Later we describe 
the over-siMplification that results in the simple, efficient al~o-rithMs that are not quite right. Here 
we simply note that no one heretofore has. recosnized the essential structure of the proble~ and provided 
an algorithm that efficiently exploits that structure, although Watt came close [Wat 76]. That is exactly 
the purpose of the current paper. ~!~-When a 9raMMar is not LR(O), one or More of the LR(O) parser's 
states Must be "inconsistent", havin9 either "read/reduce" or "reduce/reduce" conflict, or both. In the 
former case the p~irser cannot decide whether to read the next symbol of the input or reduce a phrase 
on the stack. In the latter case the confu-sion is between distinct reductions~ &#38;#169; 1979-ACM 0-89791-002-8/79/0800-0176 
$00.75 see ii 1 7 5 Lookin9 ahead at the first symbol of the input May resolve the conflict, and DeRe-Met 
defined a 9raMMar to be LALR(1) iff each inconsistent state q can be auDMented with look-ahead sets that 
resolve the con-flict and result in a correct, determinis-tic or "consistent" parser [DeR ~?]. More precisely, 
for each inconsistent state q and possible reduction A -> w in q we let the "look-ahead set for A -> 
~ in q" be denoted by LA(q,A -> ~). Uhen the parser is in state q and the symbol at the head of the input 
is in LA(q,A -> w), it Must reduce w to A. Thus the look-ahead sets in q Must be Mutually disjoint and 
not contain any of the symbols that could be read from q. gatt has defined LA(q,A -> ~) as {t 6 T I S 
=>+ aAtz and aw accesses q} [gat 76]. Intuitively, when the parser is in state q, and ~jw is on the stack, 
reduc-tion of ~ to A is appropriate exactly when the input be3ins with some terminal t th~,t can follow 
~A in a ri~htMost sententiz,1 forM. It is our purpose to investiDate the underlyin9 structure in this 
defini-tion and to show how to compute CA effi- ciently. ge decompose the problem into four separate 
computations. In reverse order of computation they are as follows: LA is computed from "Follow" sets 
of nonterMinal transitions; Follow sets are computed from "Read" sets of nonterMinal transitions; Read 
sets are computed from "Direct Read" sets; and Direct Read sets are computed by inspectin9 the LR(O) 
parser. ge define a relation on nonterMinal transitions, called "includes", relatin~ the Follow sets, 
and another, called "reads", relatin9 the Read sets. The Read sets are initialized by inspection of the 
parser Then their values ~re completed by a 9raph traversal alDorithM for findin9 "strongly connected 
components" (SCCs)~ adapted to union the sets appropriately as it searches the diBraph induced by the 
reads relation. If a non-trivial SCC is found, the 9raMMar in question is not LR(k) for any k. Next the 
Read sets are used as initial values for the Follow sets, which are completed by the adapted SCC algorithm 
applied to the diDraph of the includes relation. This time, if a non-trivial SCC is encountered hz, vin~ 
non-e~pty Read set in it, the 9raMMar is aMbiDuous. In any case the LALR(1) look-ahead sets are simply 
unions of appropri-ate Follow sets. ge now define our terMinoloDy, define LALR(1), Dive theorems relatin~ 
to look-ahead set computation, present the algo-rithM, discuss over-siMplifications, ~ive statistics 
for some practical 9raM~ars, and conclude. The notions of s~bgl and ~CJD9 of syM-bols are assumed here. 
A ZgcabLJla££ V is a set of symbols. V~ denotes the set of all strinDs of symbols from V. ~± denotes 
V* -{e}, where e is the eN~t~ ~£~D~-The l~9~b of any strin9 a is denoted lzjl. The first symbol of a 
non-eMpty strin~ is denoted EJ£~ ~; the strin9 followin9 is denoted B~ ~; the last symbol is denoted 
Last a. As just illustrated we often do not parenthesize arguments to functions when the intent is clear. 
If R is a relation, R* denotes the reflexive, transitive closure of R, and R+ denotes the transitive 
closure, ge write X ~ F(X) to Mean that X is the smallest set satisfyin~ X = F(X). ~E~. A {~D~Z~£~ ~ 
is a qua-druple G = <T,N,S,P> where T is a finite set of terminal symbols, N is a finite set of D~D~D~! 
symbols such that T A N = {} (the e~pty set), S e N is the sta£~ symbol, and P is a finite subset of 
N V*, where V = T U N and each ~e~ber (A, w) is called a 2E~tJ{~JgD, written h -> w. A is called the 
left ~art and w the E~3ti~ ~a~t. ge require a production S -> S~I for some S" e N and ~ e T such that 
~ and S appear in no other production. In this paper we adhere to the followin9 conventions: S, A, B, 
C, ... e N X e V t, a, b, c ... e T .., x, y~ z e T* _a, b, c, d, w 6 V* The relation => is pronounced 
",directly (riDht) produces" (+) and is defined On V* such that aAy => a~y for all ~ e v,, y e T*, and 
A -> w e P. 9oth =>* and =>+ are pronounced "produces". A ~u!!~b!~ ~D~£~!D~! is one that produces e. 
If S =>* a then a is called a ~~J! fgE~; if a 8 T* then it is called z, ~g~D£~-The lzjDDtjaDe L(G) 9enerated 
b,y G is the set of sentences~ i.e. {~ e T* I S =>+ a}. Let 6 be a CF6 and k > O. Then G is ~kJ iff S 
=>* aAy => awy implies that, if S =>* c => awy', then £ = aAy ~, for all ~, £ 6 V* and y, y" 6 T* such 
thz, t Firstk(y') = Firstk(y) [Knu 65]. Here Firstk(y) is that prefix of y of length k, or just y if 
lyl < k. 6~ 2~-Next we introduce our own formalization of an LR parser, i.e. ~,ny one-syMbol look-ahead 
parser, such as z,n LR(t), LALR(1), or 5LR(1) parser EA&#38;J 743. The generalization to Multi-syMbol 
look-ahead is easy, but we have no use for it here. Given some tabular represent~,tion of our "LRI automaton" 
defined below and the 9eneral LR parsin9 algorithm to inter- pret those tables, we have an "LR parser". 
The particular states, transitions, ~nd look-ahead sets are determined by the 9raMMar in question and 
the construction technique. For example, the LALR(I) tech- nique produces an "LALR(t) automaton". An 
LRJ 9U~gD~gD for a CFG 6=KT,N,S,F'> is a sextuple LRA(G) = <K,V,P,Start,Hext,Reduce> where K is finite 
set of states, V and P are as in G, Start e K is the ~t~£t ~t~te, Next: K ~ -> K is called the ~£~ns~t!on 
~g~9~, and Reduce: K ~ V -> 2 P is called the £~tJ~ ~gD~g~. We have allowed for non- deterministic or 
"inconsistent" LR auto- ~ata; the LALR(1) condition of the next section excludes such cases, h ~E~D~D 
is a ~eMber of K x V; it is a ~£O~zjl ~£~!9~ if it is in K ~ T and a X represent the transition (q~X) 
by q ") X p where p = Next(q,X), or q ~ when p is irrelevant, and we define ~~-~9~ P = X; each state 
has a unique accessin9 symbol, except Start which has none. In figures we represent LR1 automata t,y 
state diagrams in which states are con- nected by transitions. For each state q in which Reduce indicates 
possible reduc- tions, we list the productions. h 2~b H is a sequence of st~,tes ql, ..., qn such that 
 Xt Xn qO " ) q2 ~...----> q(n-1) --~ qn. Ue say that H sRells a = Xl...Xn and define ~2~!~!~9 H = ~ 
and !~R H = qn. Ue denote H by qO ~...----> qn, pronounced "qO 9oes to qn under ~". An alternate nota-tion 
for H is [qO:~], siren the automaton or its state diagram. The concatenation of [q:a] and [q':~'] where 
Top [q:a] = q~ is written [q:a][q':~'] and denotes [q:aa']. ge abbreviate [Start:a] to just [~]; thus 
[] denotes Start alone. We say that ~j ~c£esse~ q if Top £a] = q. its first part is called the ~t~t~ 
~t~ck and its second the i~ggt. The relation l-on configurations is pronounced "directly ~oves to" and 
is the union of I-re=~ and I-, for a11 h -> ~ e P. I-is A -> ~ re~d pronounced "reads to": [q:~]tz I-read 
(+) Usually =>R is used; we drop the R since we always Mean "right". 178 [q:at]z if Next(TopEq:a],t) 
is defined. l~.>~is pronounced "reduces u to A in ~ovin~ to": [q:~]tz I-[q:~A]tz if A -> w e Reduce(TopEq:aw],t). 
I-~ and I-+ are pronounced "Moves to ". The ~D3ua~g" L(LRA(G)) parsed by LRA(G) ~ust be identi-cally 
L(G), and is {z e T* I []z I-+ IS'I!}. triple (A,a,b) e N x V* ~ V* is called an item, written A -> aob; 
if b = e, it is a ~! !~O. A set of items is called ~ (Q~E~) ~d~!~-The set of LR(O~ ~E~ t~ PT(8) ~9£ a 
CFG G is PT(G) =S {Closure {S -> .S'J} } g {Closure IS I IS e Successors IS for IS" 8 PT(G)~where Closure 
IS =$ IS {A -> .w I B -> a.Ab e IS" and A -> ~ e F'}, Successors IS = {Succ(IS,X) I X S V}, and Succ(IS,X) 
= {A -> aX.b I A -> a. Xb 8 IS}. An LR(QJ ~J~9~g ~g~ a CF6 6 is an LR1 automaton LRA(8) such that there 
exists bijective function F: K -> PT(G) -{ {~ } where Start = F-f (Closure {S -> .S'!}), and for all 
t e T, X E V: Next(q,X) = F-/lClosurelSucclF(q),X))), Reduce(q,t) = {A -> w I h -> w. 8 F(q)}. F simply 
establishes a one-to-one correspondence between tables (except {~, the "trap table") and states, and 
thus an iso~orphis~ between the parse tables and the parser. Hence, hereafter we elide all occurrences 
of F and F';, since context always deternines whether q denotes a state or its correspondin9 parse table. 
The "LR(O)-ness" of the automaton is evi-dent in that the definition of Reduce(q,t) is independent of 
t. Hereafter, we often use "parser" rather than "automaton". It is well known that the LR(O) atltOM~l-ton 
A is a correct parser for 6, i.e. L(A) = L(6); however, in 9eneral it is non-deterministic, due to the 
existence of "inconsistent" states= h state q is i~£g~~ iff there exists a t 6 T such that Next(q,t) 
is defined and Reduce(q,t) £~D£!~£~), or both. As a shorthand notation for a certain sequence of Moves, 
we say that [al]yz I-* [alb]z iff (Top [a],yz) [-* ([Top [~]:~],z). This captures the notion that the 
parser reads y and reduces it, and possibly the eapty strin9 precedin9 y, to ~. We need the vertical 
bar notation because [a]yz I-* [~b]z does not neces-sarily imply that y was reduced to ~. For example, 
consider [aA]txz I-[aAt]xz l- [aA]xz I-* [aAb]z, where y=tx was D~ reduced to ~. pair (q',E) where V" 
is a set of ~ti~ and E is a subset of V" M q', each Me~ber of which is called an edge. In this pape~ 
V" is always finite A ~9[~QbzE~b, or simply a 2~b when the context is clear, is a sequence of vertices 
vt, ..., vn, n > t, such that (vi,v(i+t)) E E for t ~ ~ < n; we say there is a path froo vt t~ vn. A 
£~t is a vertex havin9 no paths to it. digraph in which there is no path from any vertex back to itself. 
A fo~s~ is a DAB in which there is at Most one path to each vertex. A tre~ is a forest having exactly 
 one root. ge define "LALR(i) parser" by refinin~ the definition of Reduce for an LR(O) parser. Intuitively, 
Reduce(q,t) should contain A -> ~ only if there exists a strin~ aw that accesses q and, when reduced 
to ~A, can lead to a successful parse, given that the input begins with t. First, we define the set of 
"look-ahez, d symbols". ~D. For an LR(O) parser, LA(q,A->w) = {t 8 T l [aw]tz l-[aA]tz I-* [S'~], A~ 
and aw accesses q}. like G's LR(O) parser, except that Reduce(q,t) = {A -> w I t G LA(q,A -> w)}. PfD-A 
CFG is L~!!! iff its LALR(1) parser has no inconsistent states. D The latter defines LALR(1) 9raMMar 
in terms of LALR(1) parser; a 9raMMar is LALR(1) iff its LALR(1) parser is deter-Ninistic. It is desirable 
to have a definition of LALR(1) 9raMMar that does not involve the parser, but we know of no reasonable 
way to do this We do, how-ever, come a little closer in the follow-ing theoreM, which Watt 9ave as a 
defini-tion [gat 76]. !bO-LA(q,A -> w) = {t 6 T I S =>+ ~Atz and ~H accesses q}. I The proof depends 
essentially on the correctness of the LR(O) parser; i.e., the Moves faithfully reflect the deriva-tion. 
Our primary 9oal here is to show how to compute the LA sets. To do so we fOCLIS our attention on nonterMinal 
transitions and define "Follow sets" for theM. Dfn. For an LR(O) parser with nonter- Minal transition 
(p,A), Follow(p,A) = {t 6 T I [aA]tz l-* [S'!] and a accesses p}. g These are just the terminal symbols 
that can follow A in a sentential form whose prefix ~, preceding A, accesses state p, given the correctness 
of the LR(O) parser. Stated in terms of derivations, Follow(p,A) = {t 6 T ; S =>+ aAtz and accesses p}. 
Thus it is easy to see that each LA set is just the union of some related Follow sets. ThM_ Union. LA(q,A 
-> _w) = U FolIow(p,A). a (p,A) w p ~... > q That is, the LA set for production A -> in state q is the 
union of the Follow sets for the A-transitions whose source state p has a path spellin8 w that terminates 
at q. Intuitively, when the parser reduces A -> w in state q, each such p is a possi- ble top state after 
~ is popped; then the parser Must read A in p, all with so~e terminal t, the first of the input. Dia3raMMatically 
, A A ... p~ ) ... Follow(pl,A) \ w is contained in -> LAlq,A -> w) which contains T ... ) ... Followlpn,A) 
We want to reduce A -> w when in state q, if the next input symbol is in any of the Follow(pi,A) (l < 
i 5 n), i.e. if it cz, n follow A in any of the left contexts "reMeMbered" by states pl through pn. The 
Follow sets are, in turn, related to each other. In particular, Ibm-Follow(pl, B) C Follow(p,h) if B 
-> bA~, c =>~ e, and p" --. . ) p g DiagraMMatically, B ) .. Fol low (p',B) b is contained in .'~ Follow(p,A)= 
 * .. -. 179 This is easy to see since, 9iven some strin9 ~ accessin$ p', we have ~ access- in9 p, and 
in an appropriate right con- text, ~bA can be reduced first to ~bAc vi~, =>* g and then to ~B; thus those 
symbols that can follow B in the left context remembered by p" can also follow A in the left context 
remembered by p. Ue capture the above inclusion via a relation on non-terminal transitions. B -> bAc, 
5 =>* e, and p" --... ~ p. B Next we observe that the symbols label-in 9 terminal transitions "followin~" 
nonter~inal transition (p,A) are obviously in Follow(p,A). ~b~-Read(p,A) C Follow(p,A). 0 where Otn. 
FoP an LR(O) parser with nonter- ~inal transition (p,A), Read(p,A) = {t ~ T I [~Al]tz I-~ [~Alc]tz I-[aA~t]z 
I-=~ [S'i] and ~ accesses p}. Diagrammatically, Read(p,A) is the set of terminals that can be read before 
any phrase includin9 A is reduced. The definition is complicated by the possibility of numerous reductions 
of the e~pty string, and nonter~inals sen-eratin 9 it, viz. c =>* e, before the rez, d ~ove finally occurs. 
Read(p,A) is just the "direct read symbols" (DR, below) fron tO, if c = e in the above diagra~ (i.e., 
n = 0). Finally, we su~arize our observations about the Follow sets, havin 9 considered all possible 
contributions. Ib~ Up. Follow(p,A) =$ Read(p,A) U ~ Follow(p',B) 0 (p',B) That is, Follow(p,A) is exactly 
(t) the set of terminals that can be read, via the first read, after reducing a phrase to A in the left 
context "remembered" by p, before any phrase includin9 A is reduced, unioned with (2) the Follow sets 
of the nonter~inals to which so~e phrase contain- in9 A, followed at ~ost by so~e nullable nonter~inals, 
cap be reduced before read-in~ another symbol, each st~ch nonter~inal in the appropriate left context, 
of course, biagra~atically, for n such non-terminals, BI through Bn (not necessarily distinct): B1 \ 
. bt , i nc!_ud_e~ "-~ ci "'" "d Bn ) ... (Bi, Bj; hi, ~j; ~i, cj not necessarily distinct.) The dashed 
arrows indicate the ~!Udg~ relation. In a similar ~anner we can decompose Read sets. T~j~ Across. Read(p,A) 
--~ OR(p,A) U Read(r,C). (r,C) (p,A) reads (r,C) where ~t~-~R(p,A) = {t ~ T I p A t ) r ) }.O Ofn. (p,A) 
rea~ (r,C) iff p A ) r C ) and C =>* _e. n The "direct read symbols" (DR) are simply those that label 
terminal transitions o~ the successor state r of the (p,A) transi-tion. "Indirect read symbols" arise 
when nullable nonter~inals can folloW. Diagrammatically, re_ad_s _re_a_ds , ,® : Cl=>*g Cn=>~g Here, 
(p,A) reads (rO,Cl) £e~ ... £~.~ (r(n-1),Cn); thus, OR(r(n-1),Cn) Read(p,A) so that t 6 Read(p,~). In 
conclusion to this section, we observe that to compute the LA sets, we need the Follow sets, for which 
we need the Re~,d sets, for which we need the DR sets. The Follow sets are interrelated ~s described 
by the iDcltj~es relation, as are the Read sets by the re~ds relation. In the next section we describe 
the coMputa-tion of these sets by carryin9 information alan9 the edges of the 9raphs induced by the ~eads 
and i~!LJ~ relations. We use a 9raph traversal algorith~ to determine an optiMuM order of doin~ so, and 
siMul-taneously, to co~pute the sets. 180 TheoreMs Up and Across relate Follow, Read, and DR in such 
a way that, given Bn appropriate graph traversal algorithM, we can apply it a first ti~e to compute Read 
from DR, and then apply it a second ti~e to compute Follow from Read. ge start by noting that DR is already 
directly avail-able in the LR(O) parser. Then the two graphs of interest are those induced by the relations 
reads and !n£1ijdes, respec-tively. However, let us consider a ~ore general problem first and then return 
to this specific LALR application. §ene£al cas~. Let R be a relation on a set X. Let F be a set-valued 
function such that for all x 6 X, [gB ~z!-F x =S F` x g U F y. g xRy where F" x is given for all x 6 
X. Let 6=(X,R) be the digraph induced by R, i.e. 6 has vertex set X and (x,y) is an edge iff xRy. Then 
F x can be efficiently coM-puted from F~ x by traversing G appropri-ately, as we shall consider first 
when G is a forest, then a DAG, and finally general digraph. Suppose G is a forest, such as Each !~B~ 
x has no y such that xRy: thus F x is simply F~ x. Each BgB:l~B~ x is a 2~D~ of one or More children; 
a ch~]~ of x is a vertex y such that xRy; and F x in this case is F~ x unioned with the F- values of 
the children of x. rhu~, ~ standard, recursive, tree-traversal aleo-rith~ T can be used to compute F 
in this case, by carryin~ information from the leaves to the roots. Now,consider a BAG, such as Vertices 
a and c "share" the child b. Algorithm T correctly computes F for ~,ll vertices, but it traverses b and 
its sub-trees twice, once as a subtask of travers- ing a and again as a subtask of c. An algorithm D, 
based on T, can avoid such recoMputation by ~arkin9 each vertex on first encounter and never re-traversin~ 
~arked vertices. Finally, consider the general case of a digraph with cycles and possibly no roots, e.g. 
If algorithm D were to start its traversal at vertex a, it would visit a then b then c, incorrectly coMputin 
9 F c = F" c g F" a, although it would correctly compute F a and F b. gorse yet, Algorith~ T would loop 
forever. Note that by the definition of F, F a C F b C F c C F a, so F a = F b = F c = F t a Lj F ~ b 
g F" c. A second trip around the cycle would solve the proble~ for simple loops such as the above, but 
{n the general case we May have loops inside loops, short-cut paths between loops, etc., so that a "second 
trip" is not so easy to define. The generalization of such cycles is a iMal subgraph (V",E") such that 
V" C V", E" = E ~ (V °° ~ V"), and for all distinct vi, vj 6 V", there is a path from vi to vj (thus, 
vice versa). It is easy to see, as above, that for V" = {xl, ..., xn} we he~ve F xl = ... = F xn z~nd 
that this common value contains F" xl M --- M F" xn. Thus, we could collapse each SCC V" to a single 
vertex x" with F" x" = F~ xl g ... tj F" xn, forming a new digraph G', apply algo-rithm O to 6 ~, then 
distribute the results from 6 ~ to G, e.g. F xl = ... = F xn = F x". It is well known that, since V" 
is Maximal, 6 ~ will have no cycles, i.e. it will be a DA6. Thus, D will work correctly on 6 ~. Note 
that each vertex v in G not involved in any cycle will be the only MeMber of a trivial SCC and will thus 
appear unchanged in 6 ~ For e×aMple, the digraph ~ reduces t{~eto DA~ Here we have F f = F" f, F d = 
F~ d, F e = F" e U F" d, and F a = F b = F c = F {a,b,c} = F ~ {a,b,c} u F {f} g F {d} = (F" a y F" b 
y F~ c) y F" f u F" d. In practice we need not actually con-struct the collapsed graph G ~. Rather we 
can effect the coM~utation of F while finding the 5CCs. The following algo- rithm, Digraph, is an adaptation 
of one given in the literature [£KS 77]. ge first Modified the exposition of the also-rithM to improve 
its readability ~,nd understandability. Then we added the three statements set off to the right to compute 
F. Further explication is ~iven below the algorithM. ~3g£~b~ Digraph: iE~g~ R, a relation O~ X~ a~d 
F', a function fro~ X to ~ets. gg~2~ F, a function fro~ X to sets, such that F x satisfies 4.1. ~@~ S 
be an initially expty stack of elements of X l~ g be an array of zeroes indexed by elements of X -f9£ 
x e X suc b tb~t N x = 0 _d 9 c~11 Traverse(x,|) od ~here £e~uP_s~ve c__a_l_l _a_s_si$~ _fo_r ~lg ~ 
~11} egd Digraph  Traverse(x~k) = # Order Uertices Push x g_n S N x <- k ; F x <- F" x y e X ~gc~ t~_at 
xRy # Order Edses !f_ N y = 0 tb_e_n (:~_]l Traverse(y,k÷l) _fi ~ss_isg N x <- Hin(N x, N y) ; F x <- 
F x .u F y N x = k £lB_eat _u~til _assign (Pop ~ N(Top S) = g~ x B) Traverse The array N serves three 
purposes: (l) recordin9 unmarked vertices (N x = 0), (2) associatin9 a positive integer value with vertices 
that are under active considera-tion (0 < N x < Infinity), and (3) ~arkin9 with Infinity vertices whose 
SCCs have already been found. Startin~ with ~ny unmarked vertex we push it on stack S and sark it with 
a level number (startin9 at one) and Traverse its "subtrees" incre-~entins the level number k as we proceed 
down the "tree" If ever an edge is encountered that points back up the tree to ancestor A fro~ descendant 
D (see diagra~ below), the N-value of ~ is ~ini~-ized to that of A, and that ~iniMal value uill bubble 
up the tree all the way back to A, unless a reference back to an ances-tor even lower numbered than A 
is encoun-tered, in which case that s~aller value will prevail. Finally, when we hz~ve Traversed all 
"subtrees" and the "root" has not had its N-value reduced, we reco3- nize that root and all vertices 
above it on the stack S as being an SCC.  ~ ~Z 3 ~-, T~M. Algorith~ Oigraph correctly determines 
SCCs. For a proof we refer the reader to that 9iven by Eve and Kurki-Suonio [EKS 77], since ours is but 
a slight ~odific~tion of their algorithm. ~B. A19orith~ Oigraph is order IVer-ticesl + IEdgesl of the 
digraph in-duced by relation R, i.e. l~n~ar in the "size" of R. P~ggf: Traverse is called once for each 
vertex v, due to the i~edi~,te ~arkin9 and the avoidance of re- # An SCC found <-Infinity ; F(Top .of 
5) <-F >, # Order Vertices traversin9 ~arked vertices. Inside Traverse, v is pushed on the stack once, 
and the fgr-loop body is execut-ed once for each edge fro~ v. The ~2~ loop executes only intermit-tently, 
when an SCC is determined, and simply pops vertices off the stack; ultimately lVerticesl are popped since 
that ~any were pushed. Thus, each verte× is pushed once and popped once, and each edge fro~ it is traversed 
once. _Co~. Al~orith~ Digraph performs one set union per edge of relation R, i.e. Fx <-F x u F y. n In 
fact, it is possible to reduce the number of such unions inside each non-trivial SCC fro~ the number 
of edges to the number of vertices in the SCC [EKS 77]. This improvement would become iNportant in "highly 
connected" SCCs in a 9raM~ar with Many terminal symbols, i.e. in which set unions become expensive. Ue 
did not include the improvement here because it would obscure the essential algorithm. In addition, non-trivial 
SCCs are infrequent, in practice. Ibm. Algorithm Oigraph correctly coM-putes F. ~£~9~: The theorem is 
based on the following facts: First, if F x satis-fies 4.1, then F x = y F~ y. This x R* y is not difficult 
to show. Second, Bi-graph implicitly coMpues R~ [EKS 77]. In fact, if F~(x) = {x} for all x 6 X, then 
F x = {y O X I x R* y}, the set of all vertices reachable from x in the digraph induced by R. U ~2!!~J~!g9 
~g L~L~- Let the set X in algorith~ Digraph be the set of nonter~i-nal transitions of an LR(O) parser. 
First let F" be DR and R be re~ds; then tl-,e resulting F will be Read; i.e. accordin9 to Theorem Across. 
we will have computed Read(p,A) $ OR(p,A) cj U Rezld(r,C). (r,C) (p,A) re~jds (r,C) Second let F * be 
Read and R be ~!Y~; then the resulting F will be Follow, i.e. according to Theorem Up, Follow(p,A) =S 
Read(p,A) u g Follow(p~,B). (p",B) Finally, we compute LA(q,A -> w) = U Follou(p,A) (p,A) p--...--~ 
q accordins to Theorem Union, ~md we have the desired LALR(1) look-~,head sets a~ter two applications 
of alsorithM ~israph. Fro~ a relational point of view, t LA(q,A -> ~) iff (q,A -> ~) l~kb~k (p,~) !)J~!~J~* 
(p~,B) r~* (r,C) ~s t ~here (q,A -> w) !~g~ (p,A) iff p~... > q and (r,C) sees t iff t 6 ~RS(r,C). Watt 
proposed this formulation, althoush with ~inor errors in the definitions of re~ and ~!~! resarding nullable 
nonterMi-nals [Uat 7~]. Uatt~s proposed bit ~atrix representations of the sparse relations ~eads and 
i~£!~J~§ would be ~asteful of space and time. ge have effectively pro- vided an efficient way to compute 
R = reads* . sees, then I = !ncltjdgs* . R, and finally LA = !gg~ I. ~ ~9£ ~!~£~b-Finally, we demon-strate 
that the 9enerality of a19orithM Disraph is needed because both the digraphs induced by !D~!tJ~g~ and 
£ea~s can, in 9eneral, be non-DAGs. In the z~d~ case the existence of a non-trivial 5CC implies that 
we have a ~ra~Mar that is not LR(K) for any k, and May or May not be ambiguous. In the inc!tjdes case 
a non-trivial SCC having a certain property i~plies an ambiguity. Consider the LR(O) parser with the 
fol-lowing state diagram: 6~AI  ]'~ ~,,A -> a A -> bB ~ The dashed lines indicate the edges of the disraph 
induced by the i~!U~ relation. The disraph is not a DAG, since we have cycle, and the correspondin9 9raMMar 
is not only LALR(1) but LR(O). (Addin 9 the production A -> b would Make it non-LR(O), but still LALR(1).) 
 The above example is, however, "danserously close to being aMbi3uous", in the sense that, if the Read 
set were non-empty for any of the A-, B-, or C-transitions involved in the loop, then the sraMMar wouldbe 
aMbisuous. The 9enerali- zation of this statement is: Ibm-Let (p,A) be a nonterMinal tran- sition that 
is in a non-trivial SCC of the digraph induced by the in~l~0~es relation. Then the correspondin~ 9raMMar 
is ambiguous if Read(p,A) {}. 0 Such an aebisuity can be illustrated in the above parser by adding the 
production B -> cCf. This changes state CO to the following: B -> cC f ~;B -> cCf Thus, f is in DR, 
Re~d, ~nd Follow of the C-transition; thus it is in the Follow set of the A-transition in the loop; thus 
it is in Follow for the B-transition; thus it is in LA(CO,B -> cO) and hence we have a read-reduce conflict 
since t can also be read from state CO. (The symbol i is the only other symbol in each of these Follow 
sets, due to the k-transition from the start state.) The ambiguity is evident in that we now have B =>* 
cdbB and distinctly B =>* cdbBf, thus essentially the classi-cal "dan31in9 ~!§~ probleM", where # is 
the e!se clause and cdb is the !~-~b~D clause: B =>* cdbB =>* cdbcdbBf and dis-tinctly B =>* cdbBf =>* 
cdbcdbBf. This example can be Made arbitrarily More subtle and complex by addin9 strings of nullable 
nonterMinals to the ends of the various productions and prior to the f in the added production. Additionally 
changin9 B -> cC to B -> cOX, e.g., where X -> ~, still produces a read-reduce con-flict on symbol f, 
but now the production involved is X -> ~ in state CO. If instead we chanse B -> cCf to B -> cCXf, then 
we set a reduce-reduce conflict on symbol f in state CO, since LA(CO,B -> cC) = {f,!} and LA(CO,X -> 
e) = {f}. The coM- plexity of our proof of the latter theorem reflects such subtleties. Now consider 
the LR(O) parser whose state diagra~ is D -> e S->AI a ~A -> a ' B-) e A ~A -:> BCDA a \ .~A -> a 
%% 3 Here the dashed lines represent the edges of the £~d~ relation. DR for the two B-transitions and 
the C-transition is e~pty, but for the D-transition it is {a}. Thus Read for each is {a} because the 
B-'s £~,d C-, C- £e~ds D-, and D- ~eads (the lower) B-transition. Hence we have a read-reduce conflict 
on symbol a in state DO, since LA(DO,B -> e) contains Follow of the lower B-, which contains Read of 
the lower B-, which contains a. In this particular case the 9tartar is a~blguous, since we can reduce 
the e~pty strin 9 to BCD as ~any ti~es as we want prior to reducin 9 to A the only a in the only strin9 
in the l~nguage. However, by changin 9 production A -> BCDA to A -> BCDAf we eliNinate the ambiguity, 
while retainin9 the conflict. How the 9ra~r is unambiguous, since the number of f's is the number of 
times we Must reduce e~pty to BCD, but it is still not LR(k) for any k, since the BCDs ~ust be reduced 
before ~ is reduced to A hut the f's follow the a. In 9eneral: :~0-If the digraph induced by the reads 
relation contains a non-trivi~l SCC, then the correspondin 9 $raeear is not LR(k) for any k. g Again 
the proof is complicated by nullable nonter~inals, and the exaeple can be arbi- trarily complicated by 
their addition, so~e of which change the conflict fro~ read-reduce to reduce-reduce. Two "clever ideas" 
come to ~ind, each of which is shown below to be inadequate. One is to union the two relations i nc_LIjd_e_s 
and rezjds so that only one application of Digraph is needed. Another has been invented independently 
by several researchers [DeR 72], [Wat 74], [Wet 77]. It involves definin 9 another relation receives 
that is closely related to the union of _inc_!tj_de_sand _r_eads and leads to what we call "not quite 
LALR(t )" or NQLALR(t) parsers. The basic idea is to relate states rather than transitions. We reason 
that LA(q,A -> w) ~ust include z~ll symbols that can be looked-ahead-at or read from any "restart" state 
s such that there is a "look-back" state r with an A-transition to s and path spellin9 u to q: A  e,, 
,e ._w ~ r_ec__eiv_e_s e= t ~ A -> w  If we reduce _w to A in q, r nz~y be the top state after poppin9 
J_w] states. Then we read A and enter s, so any symbol looked-ahead-at or read by s would be in LA(q,A 
-> _u), or really NOLA(q,A -> w). ForMally: _Dfn. q r_ec_ei_v_es s iff there is an r 6 K A such that 
r .> s and r ~... ) q, where A -> w 6 q. g Dfn. NQLA(q,A -> w) = U HOFollow(s). O S q £g~ s Pfn. NQFollow(s) 
=s NQDR(s) g g NQFollow(s'). S / t > }; Df__n. HODR(s) = {t 6 T I s i.e. the sa~e as DR except defined 
for states rather than transitions, a Ibm. NQFollow(s) = U HQDR(s')-D S / Cot. NOLA(q,A -> w) = ~ HOlIR(s). 
O s q ce£ei~e!+ s The theorem follows fro~ simply rewritin9 the definition of HQfollow, and the corol-lary 
from back-substitutin9 into the definition of NQLA. Note that the nullable nonterMinals cause no problem 
here. For example: C->e The dashed edge froN s to s" co~es directly fro~ the definition of £e£ei~s and 
obviously serves a purpose similar to the edges of reads. Thus, NOLA(q,A -> w) ~s jus~ f he union of 
all the NgDRs of the states reachable via the r~v~ relation alon9 one or ~ore edges. Our own IBM 360 
i~ple~entation [DeR 72] just computes the transitive closure of rece~v#s via bit ~atrix techniques, then 
unions the related read sets (NQOR) to 9et the NOLAs. The inadequacy of NgLALR arises fro~ the fact that 
inappropriate "paths of reduc-tions" are traced through the parser. In effect, we first consider reducin9 
~ to A, landin9 in state s, but then we consider reductions in s, e.9. B -> ×A, ~bgg~ gS into state s 
be involved as we leave via reduction. The followin9 LR(O) parser illustrates this point: S" ! f ~-~S 
-> e A a I b A d :':::--~~9~'-I'%'i. v -i:~::~j" -" -]_ ~ar~:i: ~:'L%S::>: - " - The relevant receives 
edges are indicated by dashed arrows. In this case both NgLA(90,B -> 9) and NQLA(91,B -> 9) receive both 
symbols c and d, because the £~£eiv~s relation connects state DO with both states AO and AI, which can 
read c and d, respectively. Hence the 9rae~ar is not NgLALR(t) because we have read-reduce conflicts 
in both states 90 and 91. The grammar is, however, LALR(1) and our correct approach results in LA(gO,B 
-> 9) = {c} and LA(gI,B -> g) = {d}, which are the correct LALR(1) se~t's. Finally ue consider the si~plification 
of unionin9 includes and reads, and run-nin9 the Digraph algorith~ once, to sim-plify the coNputation. 
Such a simplifica- tion i~plies that instead of co~putin9 Follow(p,A) = U DR(r,C) (r,C) (p,A) in£1tjdes* 
. rea,~s:~ (r,C) as we have described (+) we instead coM-pute Follow(p,A) = U DR(r,C) (+) This formula 
can be obt~ined by rewritin9 the expressions for Follow z~nd Read (see Theorems Up and Across) z~nd back-substitutin9 
the rewritten Read in the rewritten Follow). The two equations are not equivalent in the 9eneral case. 
The followin9 state diagra~ presents a counter-example: S -> s'z  5"-> aBd B -> DE tea d~/I-reads C." 
B 9 S" -> CB9 c ~ d ~ ( ~ S" -> cd  ~->c v LA(cO,C -> c) contains Follow of the C- S" ~ transition, 
which reads the O-, which £e~ds the E-, ~hich includes the upper B-transition, whose ~R-set-contains 
dE'so we would ~et a read-reduce conflict in cO. Ad On the other hand, with the correct approach the 
relevant LA set contains g only. A complete procedure to co~pute LALR(~) g look-ahead sets is as follows: 
A. Coepute which nonter~inals are null-able. B. Initialize Read to DR: one set (bit vector of length 
the number of termi-nals) for each nonterMinal transi-tion, by inspection of the transition's successor 
state. C. CoMpute reads: one list of nonterMi- nal transitions per nonterMinal tran- sition, by inspection 
of the latter transition's successor state. D. Apply algorithm Digraph to rea,~s to compute Read; if 
a cycle is detected, announce that the 9raMMar is not LR(k) for any k and print the look-ahead symbols 
and productions associ- ated with the cycle. E. Garbage collect the lists of part C if necessary. (Typically 
little or no space is used compared to ig~tJ~ below, and besides, parts B, C, and ~= can be executed 
in parallel so no lists need actually be created.) F. CoMpute !O£~LJ~ and !~g~ (+): one list of nonterMinal 
transitions per nonterMinal transition and redtlc- tion, respectively, by inspection of (+) For the definition 
of !g~, see section 4, subheadin9 ~DD!!~t!g~ ~ L~6B- 185  each nonterMinal transition and asso-ciated 
production right parts, ~,nd considering nullable nonterMinals appropriately. 6. Apply algorith~ Digraph 
to ~D£~Y'~g~ to compute Follow: use the sa~e sets as initialized in part B and com-pleted in part D, 
both as initial values and as workspace. If a cycle is detected in which a Read set is non-eMpty, announce 
that the gr~=~ar is a~biguous and print the relevant productions and look-ahead symbols. H. Union the 
Follow sets to for~ the LA sets according to the ~RR~£~ 1.ink.s computed in part F. I. Check for conflicts; 
if none, announce that the grammar is LALR(1) --we have a parser; if so~e not pre-viously Mentioned, 
print out the relevant symbols and productions. ~D~£~¥-Algorith~ Digraph is linear in the size of the 
relation to which it is applied. For practical graMMars, the size (nuMber of edges) of the ~n£1tjdes 
relation is about 2 to 3 rices the number of non-tereinal transitions in the parser. Each non~erMinal 
transition (p,h) has one ~Dg!g~ edge to it for each pr0ductio~i for A that ends in a nonter~inal B, or 
B£ where c =>* ~, i.e. usually only two or three at ~ost. The £e~d~ relation is vir-tually non-existent 
in practical cases, so we can i~nore it. Thus, for practicz~l LR(O) parsers 9igraph is about linear in 
the number of nonter~inal transitions. These statements are substantiated by the following table: PAL 
1892 1293 599 35 XPL 876 634 242 5 PASCAL 868 579 289 30 0 ~ 69 42 9~0~ CA~U 72] 0 433 40 25 5292 [~HW 
703 7 337 43 26 6096 [Jen 24] The table lists the total number of Unions performed by our i~ple~entation. 
Note the the number of !gg~£~ edges listed are only those for redtictions in inconsistent LR(O) states. 
The SCC column records the total number of egdes of the i~cltjd~ relation involved in non-trivial 5CCs. 
NTX is the number of nonter~inal transi- tions. The ti~e in seconds for the LR(O) parser construction 
and the look-~,he~,d (LA).coMputation is for a Burroughs B5700 with a four ~icrosecond ~e~ory. YACC tends 
to perfor~ about five ti~es as ~any se~ unions as does our algorithm. In the worst case the size of the 
~D~!~J~ relation could be proportional to the square of the number of nonter~inal transitions, since 
the relation could be nearly complete, i.e. xRy for z~ll x and y. This worst case is illustrated by the 
graMMar whose productions are {S -> $I!, Si -> Sj, Si -> t} for I ~,j 5 ~. I~nor-ing the path [51 ~], 
the LR(O) parser for this grammar has n nonter~inal transi- tions, one for each Si, I < i < n, ~nd each 
has n ~!~J~ edges to it; i.e. e~,ch nonterMinal transition has an edge to it from each of the others 
and tro~ itself! Of course, this example is contrived, highly ambiguous, and has no redeeming virtue 
from a practical viewpoint. algorithms of both Aho and UllMan [A~U 773 and Anderson, Eve, and Homing 
[AEH 72] work by "propagating" look-ahead sets across the edges of a graph. When propz~- ~ation causes 
the look-ahead information at a node to be increased, the node is queued tip so that it May in turn cause 
propagation of the new information to other nodes. This is iterated until the queue becomes empty. The 
order of propa-gation ~ay not be optimal, in the sense that each edge is traversed only once. This causes 
the YACC algorithm to perform considerably poorer than ours, as indi- cated by the table above. LaLonde~s 
~19orithR [LLH 21] is essen- tially algorithm D (see the beginning of section 4), but to avoid incorrect 
compu-tation of look-ahead sets (see the example in section 4), no information is retained at the graph's 
nodes between the coMputa-tion of the look-ahead sets for distinct reductions. Thus, edges eay need to 
be traversed repeatedly as different look-ahead sets are computed. In contrast to the above-~entioned 
~,Igo- rithMs, ours traverses each edge ex~ctly once. We have defined the two relations !D~Y~ and £ead~ 
which capture the essential structure of the problem of coM-puting LALR(1) look-ahead sets. The look-ahead 
sets May be computed from information obtained by two successive applications of a graph traversal algo-rithm 
~,pplied to the relations. The algo- rithM is linear in the size of the rela-tion to which it is applied. 
Thus, b~,r-ring Minor and constant i~proveMents in underlying representations, we suspect that we have 
the best possible algorithm for this probleM, ge leave any proof or disproof of this conjecture for future 
research. 186 Our thanks 90 to Martin Chaney for an [A~U 72] essential insight alon9 the way. Also, 
the papers of Uatt and Uetherell had an inspirational effect on us. But ~ost o~ all we thank our Lord 
and Saviour, Jesus Christ, for His inspiration and strength. [A&#38;U 77] Note: There is an error in 
algorithm Digraph and another re the NQLALR tech- nique. Write to the authors for an [AEH 72] errata 
sheet. [Alp 76] [PeR 69] [DeR 72] [EKS 77] [Jen 74] [LLH 71] [Uat 74] [gat 76] [Wet 77] Aho, Alfred 
q. and Ull~an, Jet- trey D. I~ !~g~Y g~ ~r~ vo]uees. Prentice Hall, Prince- ton, N.J., 1972. Aho, Alfred 
V. and UllMan, Jef- Des~. Addison-gesley, Readin9,  Mass., 1777. Anderson, To~, Eve, JiM, and Horning, 
JiM. Efficient LR(1) parsers. Acta InforMat~£a (1973), 12-39. Alpern, Bowen, Hartin Ch~ney, Hichael Fay, 
ThoMas Pennel]o, and Rachel Rodin. Translator gritin9 System for the Burroughs D5700. InforMation Sciences, 
UC Santa Cruz, Santa Cruz, CA. 95064. DeReMer, Frank. Practical translators for LR(k) languages. Ph.D. 
thesis, Dept. of Electri-cal Engineering, M.I.T., CaM-bridge, Hass., 19&#38;9. DeRe~er, Frank. XPL distribu-tion 
tape contain 9 LALR transla- tor writin9 systeM. InforMation Sciences, UCSC, Santa Cruz, CA. 95064, 1972. 
Eve, JiM, and Kurki-Suonio, R. On coMputin9 the transitive clo- sure of a relation. Act~ !~g£~i£~ ~ (1777), 
303-314. Jensen, Kathleen and Uirth, Nik-laus. ~D~D! U~£ ~)~g~! )~ B~9~-Second edition, Springer-qerlag, 
New York, 1974. LaLonde, U.R., Lee, E.S., and Horning, J.J. An LALR(k) parser 9enerator. Proc. IFIP Congress 
71, North Holland, AMsterdzm, 151-153. Watt, David A. Personal commun-ication. Watt, David A. Personal 
coMMun- ication (class notes). Uetherell, Charles. A correc-tion to DeReMer~s SLR(1) parser constructor 
algorithM. Unpub-lished ~anuscript. Lawrence LiverMore Laboratories. Liver-More, CA.  
			
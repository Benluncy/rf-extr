
 SynRGen: An Extensible File Reference Generator Maria R. Ebling and M. Satyanarayanan School of Computer 
Science Carnegie Mellon University {mre,satya}@cs. cmu.edu Abstract SynRGen, a synthetic file reference 
generator operating at the system call level, is capable of modeling a wide variety of usage environments. 
It achieves realism through trace-inspired rrricromdek and flexlbdity by com­bining these micromodels 
stochastically. A micromodel is a parameterized piece of code that captures the dlstinctwe signature 
of an apphcatlon. We have used SynRGen extensively for stress testing the Coda File System We have SISOperformed 
a controlled experiment that demonstrates SynR­Gen s abdity to closely emulate real users w]thm 20% 
of many key system variables In this paper we present the rationale, detaded design, and eval­uation 
of SynRGen, and mention Its applic~bility to broader uses such as performance evaluation 1 Introduction 
Transforming a file system from an initial prototype into a fully de­ployed system is a process fraught 
with hazard. Many insidious bugs will only be triggered under heavy loads and extended usage. But fear 
of serious failures, involving loss of data and lengthy downtime, Sources for SynRGen sre avadable VM 
AFS (Iafslcs cmu edulprojectlcoda-sy nrgen)or wa arronymou$FTP from ftp cs cmu edu (projectkynrgen) For 
quesnons or comments related to SynRGen, please send e-mail to synrgen@cs cmu edu Th]s work has been 
supported by the Advanced Reseach Projects Agency (Avion­ics Lab, Wright Research and Development Center, 
Aeronauocal Systems DIvIsIon (AFSC), U S Am Force, Wright-Patterson AFB, Ohio, -!5433-6543 under Contract 
F33615-90-C-1465,ARPA Order No 7597 and Hanscom AFB. Contract F19628-93-C-O 193. ARPA Order No A700), 
the Noaonal Scrence Foundauon (Grant No ECD 8907068),theIBM Corporation. Digital Equ,prmmt Corporation, 
and Xerox Corpora­tion The wews and conclusion expressed m this paper are those of the authors, and should 
not be Interpreted as those of the funding organmmorrs or Carnegie Mellon Uraverslty Permission to copy 
without fee all or part of this material is granted provided that the copies are not made or distributed 
for direct commercial advantaqe, the ACM copyright notice and the title of the publication and Its date 
appear, and notice is given that copying is by permission of the Association of Computing Machinery. 
To copy otherwise, or to republish, requires a fee and/or specific permission. SIGMETRICS 94-5/84 Santa 
Clara, CA. USA @ 1994 ACM 0-89791 -659-xKWOO05..$3.5O deters many potential users. How, then, can implementors 
hope to increase the robustness of their system? SynRGen is our solution to this problem. Configuration 
files, describing the behavior of real users and the characteristics of their data, are used by SynRGen 
to construct programs called syrrthetic users. When executed, a synthetic user generates references em­ulating 
the modeled users. By stress testing with a wide variety of synthetic users, an experimental system can 
be brought to an acceptable level of robustness. SynRGen s usefulness extends well beyond stress testing. 
Since synthetic users can be parameterized and since the generated work­load is reproducible, they can 
be used as the basis of a family of benchmarks for performance evaluation Further, the logistical and 
privacy problems inherent in exporting reference traces can be avoided by exporting a synthetic user 
representative of those traces. Most importantly, SynRGen allows a system to be subjected to hy­pothetical 
or anticipated usage scenarios. For example, one may wish to study the behavior of a file system when 
the extent of write­sharing, the degree of locality or the distribution of file sizes differs substantially 
from that of any currently available environment. We have used SynRGen extensively in the development 
of the Coda File System[l 6]. Our experience confirms that it is an invaluable tool for file system development. 
We have also shown that the synthetic users produced by SynRGen can closely emulate the impact of real 
users on system resources. Specifically, our experiments indicate that SynRGen can emulate a group of 
users in an editidebug cycle within 20% of key system variables such as network load and server CPU usage 
Our description of SynRGen begins with a discussion of the pr­imary factors that influenced its design. 
We then describe its archi­tecture and implementation. The results of a controlled experiment exploring 
SynRGen s ability to emulate real users are presented in Section 4. We conclude the paper with a discussion 
of potential refinements and a survey of related work. 108 Design Rationale 2.2 File System Independence 
2.1 Combining Realism with Flexibility The dominant design consideration for SynRGen was our need to 
characterize a wide variety of usage environments, including aspects such as the physical characteristics 
of files, the behavior of users and programs, and the scale of the system. In building SynRGen, we had 
to carefully balance the degree of realism achieved with the amount of flexibility possible. Realism 
can be viewed as the measure of correspondence along a number of dimensions[6]. The dimensions of interest 
may vary considerably. For example, in one experiment the only variable of interest may be server CPU 
utilization. In contrast, a more detailed experiment might include many system variables such as cache 
hit ratio at clients, volume of client-server traffic, and disk traffic at the server. The ultimate degree 
of realism is to replay an actual file reference trace. Unfortunately, traces can be extrapolated only 
in limited ways. Parameters such as file sizes and interarrival times can be scaled with relative ease, 
But there is no mechanical way to modify more complex aspects such as the degree of write-sharing between 
users, SynRGen achieves realism through trace-inspired micromodels. File reference traces of applications 
reveal distinctive patterns or signatures in their file access behavior. A micromodel captures the signature 
of a particular application in a parameterized function. As an example, considers hypothetical C compiler 
that opens and reads a .c file, opens and reads a number of ,h files, creates an empty .0 file, writes 
to that file, and finally closes it. The specific .c file referenced, the number and identity of h files, 
the sizes of each file. and many other details vary from execution to execution. Yet an examination of 
traces from many such executions will reveal the general pattern described above, A micromodel for this 
hypothetical C compiler would capture this distinctive signature, parametrizing the details of interest 
that vary between executions. SynRGen achieves flexibility because experimenters can stochastically combine 
micromodels to capture workloads repre­sentative of a particular class of users, They can also specify 
pa­rameter values at runtime and during configuration. Rather than wiring in the degree of realism, our 
approach defers this decision to the experimenter. We expect most experimenters will begin by using existing 
micromodels, simply setting parameter values appropriately. If they find that no micromodel exists for 
an important application or if they find that the existing micromodel is not sufficiently accurate, they 
will either create a new micromodel or improve the existing one. An important aspect of our approach 
is that it is possible to substantially separate the efforts of the modeler and experimenter micromodels 
encapsulate the work of the former. A goal in developing SynRGen was to compare the performance of akemative 
implementations of a particular file system API (ap. plication program interface) for identical user 
communities. For example, one might want to compare AFSII 4], NFS[l 2], Sprite[l 1:1 and Coda[16]. This 
requires that the reference stream generated by SynRGen had to beat the level of abstraction common to 
these file systems, in this case the Unix file system API. References generated at the file system API 
means that semantic constraints at that level must be respected. For example, in the Unix API, one cannot 
delete a directory unless it is empty; nor can one reacl from a file until it has been opened. Rather 
than trying to capture these API-specific constraints in some declarative form (such as a table), we 
chose to embed them in micromodels written in arbitrary C code. It is then the responsibility of the 
micromodel s author to ensure that API-specific constraints are met. Further, the mecha­nism for stochastically 
combining micromodels is AP1-independent because the micromodels encapsulate all knowledge of the API, 
A consequence of this decision is that SynRGen is not restricted to generating file system references. 
By writing appropriate micro­models, SynRGen could equally well generate, for example, syn­thetic SQL 
database queries or disk I/O references. Although our experience with SynRGen has been limited to file 
reference gener­ation, we do not foresee any obstacles to its broader use. 2.3 Parameterizing File Locality 
The performance of virtually every file system ts critically depen­dent upon design assumptions regarding 
the degree and nature of locality of file reference. If these assumptions do not hold in a particular 
environment, the performance of the file system could be significantly different from expectations. We 
wanted the ability to study the effect of changing the locality of reference substantially. In order 
to conduct such a study without recoding every micro­model, one needs the ability to convey interfile 
locality information between independently-authored micromodels. For example, if a user examines the 
attributes of a given file, he or she is likely to look at the contents of that file next. Somehow. we 
must capture this temporal locality of reference. We use pathrarne iferators to meet this requirement. 
A pathname iterator is simply a procedure that encapsulates locality information. Each call to a pathname 
it­erator yields the name of a file or directory; the stream of names generated by successive calls exhibits 
the interfile locality modeled by that iterator. To use SynRGen micromodels with different lo­cality 
patterns, one merely invokes them with different path name iterators. In principle, a similar mechanism 
could provide a choice of intrafde locality models. However, intrafile locality tends to be 109 olume 
Typ Physical Characteristic User Project System BBoard All Total Number of Volumes 786 121 72 71 1050 
Total Number of Directories 13955 33642 9150 2286 59033 Total Number of Files 152111 313890 113029 144525 
723555 Total Size of File Data (MB) 1700 7000 1500 560 11000 Absolute Depth 4.3 (1 3) 6.3 (z1) 60 (13) 
53 (lo) 5.7 (2 o) Relative Depth 3.3 (1 3) 5.2 (2 O) 4.0 [1 2) 2,7 (O 8) 4.5 (1 9) File Size (KB) 10,3 
(65 O) 24.0 (1457) 16.4 (72.6) 2,6 (7,0) 19.1 (1180) Directories/Directory 3.6 (134) 3.0 (45) 3.6 (104) 
6.8 (194) 3.2 (83) Files/Directory 14.6 (3o 6) 16.2 (35 6) 15.9 (36 9) 66.9 (1424) 15.7 (34 5) Hard Links/Directory 
3.7 (124) 2.0 (15) 4.0 (39) 0.0 (00) 34 (57) Symbolic Links/Directory 4.1 (10.1) 3.4 (75) 13,6 (45 3) 
6.0 (25 9) 6.3 (24 9) This table summarizes various physlcd cbamctermcs of system, user. project, and 
bulletin board ( bboard ) volumes in AFS at Carnegie Mellon University in early 1990 These d~tzz were 
obtained WI statx mmlysls. We present only the mean and standdrd deviation (m pmenthesls) here. The full 
data are represented In cumulauve dwnbution funcuons Absolute depth IS measured from Pafslcs cmu eduluser 
for user volumes. /afslcs cmu edulproject for project volumes, and so on Relat]ve depth IS mewured from 
the volume root Table 1 Sample Physical Characteristics by Volume Type specific to an application rather 
than being a function of the usage environment. Hence we expect SynRGen s micromodels to capture intrafile 
locality internally. For instance, a micromodel for the more program would open a file and read all or 
the initial part of the file sequentially, while a micromodel for a database or a linker/loader would 
open a tile and access portions of the file randomly 3 Architecture and Implementation The design rationale 
presented in the previous section leads directly to the architecture of SynRGen. The core of SynRGen 
consists of a set of preprocessors that transform configuration files mto exe­cutable code. linking in 
the specified micromodels from a hbrary. Synthetic user executable are generated for each type of user 
spec­ified by the configuration files. Running a synthetic user results in references corresponding to 
that type of user. An experiment consists of subjecting a candidate system to a collection of synthetic 
users. To emulate a timesharing environment, multiple synthetic users are run on the same machine. When 
em­ulating a distributed workstation environment, each synthetic user is run on a different client machine. 
Tbe system-spectfic instru­mentation necessary for momtoring the impact of synthetic users on clients, 
servers, and the network must be provided externally. In the following sections, we describe SynRGen 
at the next level of detad. We first present the abstractions supported by SynRGen, and then discuss 
how each abstraction is specified. We complete the section by giving the status of our implementation. 
3.1 SynRGen Abstractions Our design 1s based upon two key abstractions: volumes and user classes. The 
volume abstraction provides the basis for modeling the layout and storage characteristics of the file 
system, while the user class abstraction provides the basis for modeling user activity. A volume is a 
subtree of files and directories exhibiting a unique combination of physical characteristics. Each characteristic. 
such as file size and directory fan-out. is descrtbed by a distinct volume­specdic stochastic distribution. 
For simplicity, we assume volumes are mounted only at the root of the file system hierarchy. Table 1 
summarizes the characteristics observed in different types of vol­umes from a representative file system 
A user class corresponds to a stochastic finite state machine. States in the FSM represent distinct user 
behaviors, while transi­tions represent a user changing from one behavior to another. For example, a 
behavior might be programming or document pro­cessing . Each behavior consists of some set of possibly 
repetitive actions, corresponding to subtasks performed within this behav­ior. The actions associated 
with a programming behavior might include searching header files , editing and compiling , while the 
actions associated with a document processing behavior might include editing and formatting Actions exhibit 
distinctive file access characteristics, and correspond to micromodels 110 Zmo Start StateChoose \ 
1.( print \ demo initial lze_me 1() 0.6 0.4 0.45 from Volume * n 36 045Choose z:;:: !+ 0 36# () (!4 
Action ?&#38; 0,040.1 to . 06 clean.-UP &#38;m I another_ behavtor v End State I/ I Io from another_ 
behav!or ,0 x another_behevior (a) Complete Finite State Machine (b) Detail of demo Behavior Figure (a) 
shows the finite state m~chine for a h ypothetical user class Each of the states ini t ial i ze.me. demo, 
c 1 ea~up, and another. behavi or represent user behaviors Figure (b) shows the detmled contents of one 
of these behaviors, demo Each small rectangle in this figure, such as edit-debug and readent ire-file, 
corresponds to m action, these actrons are Implemented m mtcromodels In both figures, arcs represent 
transitions between user behaviors, and the numbers on the arcs Indicate trmslt]on prohabdltles Figure 
1: User Class Finite State Machine / Include volume type descriptions / #include <system> #include <hacker-pro] 
ect>  / Volume Instantlations --name: volume-t~e */ Sys : system codasrc: hacker-pro j ec t synrgensrc: 
hacker.proj ect / Include user class descriptions */ #include <hacker>  / User Declarations --group: 
user-class (parameters) */ codahackers, hacker ( ) synrgenhackers: hacker (proj ectl = synrgensrc, mean-mterarrival 
= O 14 ) Figure 2: Sample System Configuration File This figure shows I v~mple system contigumuon file 
NotIce that the synrgenhackers user declwmon redefines the default vidue of the $pro j ect 1 vtiriable 
to synrgensrc md the value of the mean-interarrival vwmble to O 14 FILESIZE: DIRS per DIRECTORY, 007 
0 0,67 0 SYMLINKS per DIRECTORY 010100 081 1 091 0 013 200 089 2 0.95 1 ,,. 092 3 0.98 3 ,. 0954 0999 
 099 400000 100 90 100 10000000 100 100 Tbls figure, contammg excerpts of the pro] ect volume contigtmmon 
file, shows three physd chamctenstics of tbls type of volume This frle contmns the reverse tmnsformation 
of tbe CDF for each Chwdcterlstic For example, 13 36 of all files In project volumes contain no more 
than 200 bytes of dtta The dum detmls the summary presented In T~ble Figure 3: A Portion of a Volume 
Configuration File 111 Figure 1(a) shows an example of a user class. This class of users exhlblts four 
behaviors initial ize.me, demo, another. behavior and clean-up. The arcs m this fig­ure represent transitions 
between behaviors; the numbers repre­sent the probability of taking a particular transition Figure l(b) 
details a single behavior (demo) of that user class The ac­tions associated with the demo behavior include 
syscall-stat, read-entire_file andedit_debug. Our representation of a user class closely resembles a 
user be­hal iorgraph, asdefinedby Ferrari[6] Each behavior ina SynRGen user class comespondsto anode 
in the behavior graph, and each transition to an arc.  3.2 Configuration Files SynRGen s volume and 
user class abstractions are described in configuration files which are transformed by preprocessors. 
The mkclass preprocessor transforms a user class into a C program representing a synthetic user, Themkvol 
preprocessor transforms a volume description into a C data structure accessed by micromod­elsthrough 
library routines. Toslmplify thecompilation andlinking of synthetic users, we provide a third preprocessor. 
mksynrgen. that takes a system configuration file and generates shell scripts. Redescribe SynRGen further 
with asetofexamples Figure2 shows atypical system configuration file. Thetirstsection ofthis file defines 
volume descriptions by including volume configuration files, system .vol andhacker-.pro ject.vol Inthe 
next section, we instantiate three volumes: sys, codasrc, synrgensrc. The first volume is of type SYS 
tern, and the other two are of type hacker.proj ect. The syntax resembles the way in which C programs 
include header files to obtain typedef definitions and then instantiate variables of those types. In 
a similar manner, the rest of the file obtains definitions of the user class hacker and instantiates 
two different instances of this type of user. The instances differ in that codahackers uses the default 
set of parameters, while synrgenhackers redefines certain parameters, Figure 3 depicts a portion of a 
volume configuration file, This file can contoin up to six sections, each describing a physical char­acteristic 
of the file system hierarchy, The physical characteristics are: the file size; the number of files, symbolic 
links, hard links and directories per directory: and the relatlve depth, The characteristics are described 
using the inverse transformation of the correspond­ing CDF (cumulative distribution function). This information 
is transformed into a data structure used by the volume information routines (e.g. get_Fi leSize) accessible 
to mlcromodels, Figure 4 depicts the user class configuration file correspond­ing to Figure 1. The heart 
of the user class definition consists of the description of individual behaviors such as ini t ialize.me, 
demo, another.behavior and clean-up. Descriptions of be­ haviors can use either arbdrary C code or our 
syntactic constructs for commonly encountered control flows. The demo behavior, for example, uses our 
syntactic constructs. After entering the demo be­havior, the program will stochastically choose a volume 
in which to operate (either the $proj ectl or the sys volume), If the project volume is chosen, the program 
will loop, stochastically choos­ ing one of three actions (syscall_stat, readentire-f ile or edit_debug) 
on each iteration These actions are micro­ models. If the sys volume is chosen instead, the program 
will stochastically choose to perform either a syscal l_s tat, a read_ entire-file or a transition to 
the clean_up behav­ior, Notice that each of the micromodels take a pathname iterator, Fractile_FallOff 
( ) , as a parameter. Parameters to the user class can be accessed within the configu­ration file by 
prepending a $ to their name, e g. $pro j ectl. These variables are bound to a default value when they 
are declared, but can be rebound either at configuration time or at run hme, Run time binding takes precedence 
over configuration time binding, which in turn takes precedence over the default binding. As shown m 
Figure 4, the default binding for the $proj ectl volume M co­dasrc . However, as shown in Figure 2, the 
system configuration file redefines this parameter to synrgensrc for synrgenhackers. Arbitrary C code 
(surrounded by { and } ) also appears in many places within the body of Figure 4. By allowing experimenters 
to combme specialized syntactic constructs together with arbitrary C code, SynRGen provides a good balance 
between brevity and open-endedness,  3.3 Implementation Status SynRGen has been operational since May 
1992. The implemen­tation is highly portable and has run under Mach on DEC MIPS workstations, Intel 386/486 
machines, and IBM RTs. It has also been ported to run under AIX on IBM R!V6000 machines, The three preprocessors 
are implemented in C, using lex and yacc. We have built up a small library of parameterized micromodek 
representing a variety of typical applications used in our environ­ment. These include use of an emacs-style 
editor, C compilation, and building programs via make. Using micromodels and user classes representative 
of our environment, we have used SynRGen extensively for stress testing new releases of the Coda File 
System. Also, we have conducted controlled experiments to evaluate how realistically SynRGen models a 
true Coda file server workload. The results of our experiments are reported in the next section. 112 
1** ********* * * *********** ******* *******++************ **** . * SynRGen USER Configuration File 
*******.***,*+** +*************** * *************.* *****.********** ***J { #include behavior. h #include 
fract.falloff. h #include volume-i nfo. h Fractile. FallOff-Inf O system-info, project-info, Volume. 
Inf o System-VolLune, Proj eCt-VOIUMe; } / Parameter Declaration and Initialization *I double meaminterarrival 
= O. 10227; double ckp.interval = 30. O; int pause = 10; int loop. times = 5; char projectl [101 = codasrc 
; initial ize. me: { printf ( SynRGen initialized. Beginning SynRGen demo in %d seconds\n , pause) 
; 1 sleep BEGIN (pause) (demo) ; ; demo z { printf ( \n\nSTART: demo behavior\n ) ; } < 0.60 $projectl 
loop [$loop.times] <0.25 syscall-stat (Fractile. FallOff ( ) , &#38;Pro ject.Volunte, &#38;project-info, 
DIR-OBJ) > <0.25 read-entire-file (Fractile-FallOff ( ) , &#38;PrOj ect-VOlume, &#38;prOj ect-info) 
>  <0.50 edit-debug (Fractile-FallOf f ( ) , &#38;Proj ect.Voluone, &#38;project-info, ckp-intemal ) 
> end loop { BEGIN ( another-behavior) ; } > < 0.40 Sys <0.45 syscall-stat (Fractile. FallOffo , &#38;System_ 
Volunte, &#38;syste~inf o, DIFLOBJ) > <0.45 read_ entire. file(Fract ile-FallOff () , &#38;systemVolume, 
&#38;systerkinfO) >  <0.10 { BEGIN (cleanup) ; } > > { .l.ep (Exponential (mean interarrival ) ) ; } 
 another. behavi or: { I* This section of the configuration file would model another behavior. */ BEGIN 
(demo) ; } c1 can-up: J1 printf ( \n\nSynRGen run complete! \n ) ; exit(0); This figure shows the 
user ckiss configumtion tile corresponding to the user elms finite state machine shown in Figures l(a) 
and (b). The demo behavior exemplifies SynRGen s syntactic constructs which simplify modeling common 
control flows. In this behavior, we see three distinct actions syscal 1. stat, read-entire-file, and 
edit-debug. These octions correspond to micromodels. Arbitrary C code appears in numerous places in the 
file: at the top of the file, in well-defined points within the demo behavior, and as the entirety of 
three bebaviors (initialize-me, another-behavior, and c lean-up). The BEGIN statements that appew throughout 
this tile represent transitions between behaviors. Although the Fract i le. Fal 10 f f ( ) parameter 
looks like a function call, the preprocessor translates this into a pointer to a function so that the 
micro models can use it w a pathn ame itemtor. Figure 4: Sample User Class Configuration File 113 4 
Case Study: Users in an Edit/Debug Cycle The mean interarnval time parameter of our synthetic user was 
set to the mean interarnval time of file system requests observed in An important question is How well 
does a SynRGen workload emulate a real workload? To answer this question, we conducted a performance-oriented 
study [6] comparing real users to a syn­thetic user. We chose to study the editidebug cycle because it 
is a common activity in our environment as well as many others. We wrote micromodels for the most frequent 
activities in an editidebug cycle, generated a synthetic user, and then performed a controlled experiment 
to compare the load generated on Coda servers by the synthetic user to that generated by real users. 
4.1 The Synthetic User Our first task was to build mlcromodels of the tools most frequently used during 
editidebug cycles. To build these micromodels we examined many traces generated by a number of users 
working in an editidebug cycle on a variety of machine architectures. After completmg the mlcromodels, 
we constructed a synthetic user. The main achvity of this synthetic user is an edit/debug cycle that 
consists of editing some number of files associated with a par­ticular program , recompding the modified 
files, and executing the program after it is built In addition, the synthetic user occasionally performs 
a few other related activities such as consulting a manual page, examining a system header file or looking 
through a source file. Broadly, the user resembles the example shown in Figure 4. The important user 
class parameters are the mean interarrival time of file system requests, and the mean checkpoint interval 
time for the emacs-style editor. 4.2 The Experiment For our experiment, we observed five C or C++ programmers 
as they performed edit/debug activity for one hour. We made no attempt to rigidly constrain these users 
 our only request was that they confine their activities to a single workstation. Inevitably, some activities 
not modeled by SynRGen were performed, but we believe that the amount of such activity was minimal These 
users were working on DEC DS-5000/200 machines rtm­ning Mach 2.6. The data they were accessing resided 
primarily in triply replicated volumes located on three Coda servers. Each server was also a DS-5000/200 
machine running Mach 26 The client and server machines communicated via an Ethernet, The system parameters 
we measured on the Coda servers in­clude distribution of incommg RPC operations. transactional activity, 
CPU utilization, disk activity, and Ethernet load. In addition to these server and network statistics, 
we obtained file reference traces of these users on the client machines. the traces of these users (about 
0,1 seconds). The mean checkpoint interval parameter to our synthetic user was set using an estimate 
of the frequency of checkpoints in actual use of our editors (30 seconds) In addition, the pathname iterator 
to our micromodels was the fractile falloff distribution described by Satyanara yanan [15], Specifically, 
75% of the time, 4% of the files were referenced; 209Z0of the time, 16T0 of the files were referenced; 
and the remammg 5% of the time, the other 80% of the files were referenced. Using these parameters, we 
then ran the synthetic user on one of the client workstations in a subtree of the Coda tile system, The 
physical characteristics of files in this subtree were consistent with the data presented in Table 1 
for project volumes.   4.3 Results Table 2 compares the values of the system variables obtained from 
our real users to those obtained from our synthetic user. The last column of this table calculates the 
difference between the synthetic user and the mean of the real users in units of the standard deviation 
of the real users. This column shows that all but two system var­iables (the number of status fetches 
and the CPU usage in user mode) fall within one standard deviation of the average for the real users, 
For most system variables including the two above, the synthetic user comes within 20% of the mean value 
for the real users, With the exception of the number of data fetch and store requests, all the other 
system variables of interest lie within about 40?Z0of their observed values for the real users In all 
cases where the results from the synthetic user diverge substantially from the mean value for the real 
users, the result from the synthehc user still falls within the range observed for real users, A final 
observation is that SynRGen consistently underestimates the observed values from real users (i.e., relative 
error N negative for most system variables). This suggests that we might be able to get the synthetic 
user to better match real users by applying a correction factor to the run time parameters. Experiments 
not reported here confirm that this 1sindeed the case. It is important to note that the bulk of our effort 
m this experi­ment was in building the micromodels The actual construction of our synthetic user was 
relatively simple. This confirms the under­lying hypothesis of our approach: that it is possible to substantially 
separate the efforts of the modeler and experimenter, and to encap­sulate the work of the former in micromodels 
Our results confirm that SynRGen is able to realistically model users in at least one domain. Further 
validation of our approach would require slmdar controlled experiments spanning a broader class of activities, 
applications, and environments, 114 Real Users Synthetic Relative Stdzd Characteristic User 1 User 2 
User 3 User 4 User 5 Mean (StD.v) Cov User Error Error Total Time (see) 3642 3379 3603 3602 3597 3565 
(105) 0.0 3602 1% 0.4 Total Operations 3431 2177 2898 2085 2601 2638 (551) 0.2 2590 -2% 0.1 SERVEROPS: 
FetchData 32 30 63 4 28 31 (21) 0.7 11 -65% 1.0 1219 Fetch Status 1061 1462 1161 1278 1236 (149) 0.1 
1078 -13% 1.1 StoreData 269 29 70 72 35 95 (99) 1.0 167 76% 0.7 StoreStatus 263 48 49 59 21 88 (99) 1.1 
115 31% 0.3 Create 117 26 21 22 7 39 (44) 1.2 33 -15~o 0.1 RVM: Transactions 2158 437 422 403 394 763 
(780) 1.0 686 -lo% 0.1 CPU TIME: User (see) 81 90 81 63 68 77(11) 0.1 63 -18% 1,3 System (see) 163 169 
244 132 133 168 (46) 0.3 134 -20% 0.7 DISK: Transfers 7804 2434 11735 2535 3518 5605 (4070) 0.7 3968 
-29% 0.4 KBs Transferred 57112 15891 86862 15046 22359 39454(31633) 0.8 22420 -43% 0.5 Busy Time (see) 
137 45 196 46 65 98 (67) 0.7 69 -30% 0.4 ETHERNET Packets In 123800 129365 163207 117353 107830 128311 
(21088) 0.2 114245 -11% 0.7 Packets Out 27485 34737 38847 25867 24888 30365 (6115) 0.2 25205 -17% 0.8 
This table presents theresults ofacontrolled experiment comparing theworkload generated on Codaservers 
bytiverval users tothatgenerdted byasyntiehcuser Foreach user , represent thememv alueobserveda tthethreeservers. 
Inaddltlon totbe load generated byeachreal user, represent themwan, sr~ndard deviation andcoefficlent 
ofvarlatl on for these users Therelauve error isdefined astheratio oftbedifference between thesynthetlc 
user andtbemean of theredl users tothemr~n of there~l users. ArelWveerrorgrrWer tianzero ]mpl]es tbatthe 
synthetic loadoverestimated theactual load. whllean error less than zero lmplles thesynthetlc load underestlm~ted 
Tbestandwdlzed error ]sdetinedas the mtio of the absolute value of the difference between thes ynthetic 
user and the mem of the red users to the standard dewimon of the real users. Table2: Comparison of Real 
and Synthetic Users 4.4 Extending the Case Study In the above sections we used SynRGen to model a single 
user in anedit-debug cycle. Suppose. however, that we need to modelan entire usercommunity. What would 
thenecessary changes be? The first step is creating validated SynRGen models for each class of user inthe 
community understudy. Once available, these synthetic users can be run simultaneously to generate a workload 
representative of the entire community. Almost certainly, we will want to model data sharing between 
users. Sharing can be read-read, read-wrtte or write-write. For simplicity, we refer to read-read sharing 
simply as read-sharing and to both read-write and write-write sharing as write-sharing . We model read-and 
write-sharing of files and read-sharing of directories by having synthetic users perform activities in 
shared volumes, For example, to model read-sharing of manual pages or header files, all members of a 
community might occasionally exam­ine the contents of files and directories in shared system volumes. 
Similarly, when modeling members of a project, one would concen­trate their actiwties in one or more 
project volumes. Increasing the time spent performing activities in the shared volume will increase the 
probability of sharing. Modeling write-sharing of directories is more challenging. Syn­thetic users create, 
remove and rename objects as dictated by their micromodels When synthetic users write-share directories, 
they may experience interference caused by these directory updates. For instance, one synthetic user 
might remove an object that another synthetic user later attempts to edit. The micromodels in Section 
4.1 do not update internal data structures upon discovering new, missing or renamed objects. In order 
to support write-sharing of directories, we must modify those micromodels to use failed system calls 
as hints to trigger updates to internal data structures. One of SynRGen s strengths is that these improvements 
require modifica­tions only to the micromodels and not to SynRGen itself.  5 Open Issues and Future 
Work 5.1 Automatic Micromodeling Because writing micromodeis is a labor intensive task, automatmg this 
process in some fashion would make modeling new activities easier. One approach would be to invert a 
file reference trace, producing a command script, This command script, when executed, would produce a 
trace isomorphic to the original trace We have experience with an untrace facility that does just that 
[17]. A difficulty with such an approach is determining how to parametrize the generated micromodels, 
and how to specify locality. Another approach would be to use the strategy proposed by 115 Thekkath et 
al. [20]. This approach recognizes that random sam­ples selected from a representative trace of the workload 
being modeled will result in workloads that exhibit the same statistical characteristics as the original. 
These random samples could be used as micromodels. Parametrizing these micromodek must still be done 
manually Both of these techniques require an accurate trace of the envi­ ronment being modeled This requirement 
hrnitsthei rapplicability to environments that already exist one cannot use either of these techniques 
for constructing a micromodel for a hypothetical or an­ticipated application. 5.2 Incorporating Locality 
Phases SynRGen provides a means of modeling locality of reference in a synthetic workload In Bunt et 
al. s terminology [2, 3], SynRGen offers flexibility in modeling any degree of concenrrakvrof locality; 
that is, SynRGen allows any number of files to be in the active set, However, Majumdar and Bunt have 
shown that tile reference locality exhibits phases. or bounded locahty intervals [8] Although we do not 
foresee any difficulty in incorporating locality phases, SynRGen currently has no notion of these phases 
The consequence of not supporting bounded locality intervals is that SynRGen can be expected to display 
a hlgherdegree of locality than actual workloads Adding the notion of locality phases to SynRGen would 
improve the accuracy of modeling. As seen in Figure 2, the synthetic user greatly underestimated the 
number of fetches seen by the servers One possible explanation of this behavior is that the chent cache 
was able to service fetch requests for the synthetic user more successfully than for the real users. 
In other words, the synthetic user may be displaying a higher degree of locality than real users. 5.3 
Quantifying Accuracy of Micromodels The overall realism of an experiment is limited by the accuracy of 
individual micromodels. This raises the question of how to quantify the accuracy of a micromodel. One 
approach would be to define some metrics and use these metrics to compare traces generated by the synthetic 
user to a set of reference traces generated in a real system. These metrics might include the fraction 
of files referenced and the locality of files referenced, While such metrics give some indication of 
the accuracy of the micromodel, they completely ig­nore the order in which events happen. In modeling 
locality of reference. it is important to capture the order in which system calls occur as well as the 
order in which files and directories are accessed. One metric that respects ordering is the longest common 
sub­sequence (LCS) The LCS is a well-known measure of closeness between two strings and has been used 
in a variety of contexts such as DNA sequencmgand speech processing 13] We explored the pos­sibility 
of using thm metrtc to quantify the accuracy of micromodels. Unfortunately, we found this approach to 
be intractable due to the large storage requirements of the algorithm and the voluminous size of realistic 
traces. Quantifying accuracy thus remains an open problem, We now believe that such quantification must 
be based either on metrics other than the LCS, or on a more efficient approximation to the LCS.  6 Related 
work Synthetic file reference generation has received considerable atten­tion in the recent past Much 
of this attention has been focused on measuring NFS performance, For example, NHFSStone [9] facil­itates 
comparisons of competing NFS implementations, A funda­mental distinction between this work and ours is 
the dependence of this benchmark on the NFS interface. Further, this benchmark is considerably less realistic 
and less flexible than SynRGen. Bodnarchuk and Bunt [1 ] significantly Improve upon the above benchmark 
in both flexibility and realism. Their algorithm involves sampling discrete distributions to choose an 
NFS operation. a file system in which to operate (uniformly choosing a specific file from a representative 
set of this file system), a data transfer size, and an interarrival time. SynRGen differs from this work 
in that it raises the generator up to the file system call level, models interfile locality in addition 
to intratile locality, and allows measurement of client effectiveness as well as server and network effectiveness, 
In contrast to NFS benchmarks, SynRGen operates at the file system call level. This makes performance 
comparison of file sys­tem implementations such as AFS and NFS possible. It also broadens the range of 
phenomena that can be modeled Another widely used benchmark, the Andrew Benchmark[7], operates at the 
Unix system call level and attains a respectable degree of realism. Because this benchmark is restricted 
to specific activities, it cannot be used to model a variety of workloads, In contrast, SynRGen is considerably 
more flexible and allows a wide range of scenarios to be modeled. Viewing SynRGenin a broader context, 
it is clear that the idea of generating a synthetic workload is not new. In fact, there area wide variety 
of synthetic workload generators including the SPEC bench­ mark suite[19], the TPC benchmarks[l 8], IOBENCH[21], 
tcplib[5], and many others. What differentiates SynRGen from other work­ load generators is its flexibility 
in accommodating new workloads while preserving realism. It achieves this flexibility by providing not 
a single workload generator, but a common framework on which workload generators can be built. The separation 
of micromodels from their stochastic combination is, to the best of our knowledge, not duplicated in 
any other synthetic workload generator. 116 7 Conclusion [4] CORMEN, T H, LEISERSON, C E. AND RIVEST. 
R L Introduction to Algorlthm\ MIT Press, Cambridge, MA, 1990, SynRGen is a tool born of necessity. Early 
in the evolution of the [5] DANZIG, P, B,, JAMIN, S,, CACERES, R., MITZEL, D, J,, AND ESTRIN, D An Coda 
File System, it became clear to us that we needed some way Empirical Workload Model for Driving Wide-arra 
TCF/lP Network Simul~uons [nternetworkmg: Research und Experwnce 3.1 (Mwch 1992) of stressing our system 
without burdening real users. In retrospect, SynRGen has indeed proven to be an invaluable tool for this 
purpose. ~6] FERRARI, D On the Foundzmon of Artdicml Workload Des]gn In Procecdmfls Coda is now used 
daily by over 30 users as their primary data of the 1984A CM SIGMETRICS Conjerertce on MCYISUrement and 
Modehng OJ Compurc!r Sywerm (Cambridge. MA, August 1984). repository. New releases of Coda are exposed 
to synthetic users for an extended period of time before they are installed on our [7] HOWARD, J H, 
KAZAR, J L, MENEES, S G, NICHOLS, D A, SATYA­ production servers. Furthermore, SynRGen proved invaluable 
in NARAYANAN, M, AND SIDEBOTHAM, R N Scale and Performance in it Di+ debugging our current backup system. 
tributed File System. ACM Tran.vudton$ on CornpuWr Systems 6, 1 (February 1988) We are confident that 
SynRGen s unique ability to combine [8] MAJUMDAR, S., ANO BUNT, R. B. Mtmurement and Analysls of Locahty 
Phases realism with flexibility will make it attractive to other tile system in File Referencing Behawor 
In Procetdmg v of Performum e 86 und ACM S!:­ developers. As discussed earlier in the paper, we foresee 
it being metrtm 86, Joint Conference on Compute rPetformunc e MoclellinS, Mumurement useful in performance 
evaluation. We also envision it allowing and Evduarion (Raleigh, NC, May 1986) researchers to subject 
their systems to a broader range of workloads 191 MOLLOY, M. K Anatomy of the NHFSSTONES Benchmarks ACM 
.SIGMET­ than has historically been possible. This will enhance the credibility RICS RtWWW 19,4 1992) 
Perjorrnunce Evulufmon ( May of research systems, whose generality has often been questioned [10] MUMMERT. 
L B, AND SATYANARAYANAN. M Efficient and Port~hle File Ref­ because of their bias toward academic workloads. 
 erence Tmcing m I Dlstrlbuted Workstaaon Enwronment Czunegle Mellon University, matmscnpt In preparltlon. 
While already useful in its present form, SynRGen is not a finished piece of work. There is clearly work 
to be done in building [111 NELSON, M., WELCH, B., AND OUSTERHOUT, J, Caching In the Sprite Network 
up a rich library of micromodels, representing a wide range of File System ACM Trunrucrmru on Compuwr 
Sy.wan.\ 6, 1 (February 1988) applications. A related piece of work is to assemble a collection [12] 
SANDBERG. R, GOLDBERG, D. KLEIMAN, S , WALSH, D, AND LYON, B Design of configuration files capable of 
representing a variety of usage and Implementmon of the Sun Network Filesy stem [n Procedwtg r of rhe 
environments. Finally, as Section 5 explained, SynRGen itself can USENIXSummer Conference (Summer 1985) 
be refined in a number of ways. We believe that these efforts will [13] SANKOFF, D. AND KRUSKAL, J B 
Tone Wurpv, Srrm~s Edm, and Mac r{>­ result in an important asset to the tile systems community. moleculcv 
The Theo~ und Pructlce o) Sequence Compurwm Addison-Wesley Pubhshlng Compury, Inc , Re~dlng, MA, J983 
[14] SATYANARAYANAN, M The lTC Distributed File System Principles md De­ 8 Acknowledgements SIg I pMCCdmg,s 
Tenth ACM .$ynpowunt on Operumrg .sysrerns Pritlcip[ev (December 1985) We wish to thank Lily Mummert 
for her indispensable file reference [151 SATYANARAYANAN, M. Modelhng ,$torage Sy,!term. UMI Research 
Press, Ann tracing facility. In addition, we would also like to thank our real Arbor. MI, 1986. users 
and those who provided comments on early versions of this [161 SATYANARAYANAN. M, KISTLER, J J, KLIMAR, 
P., OKASAKJ. M. E, SIEGEL, paper, including Puneet Kumar, Qi Lu, Scott Nettles, Brian Noble, E H, AND 
STEERE. D C Codtr A Highly Awnlablet?le System foro D1str!buted Chris Okasaki, Josh Raiff, David Steere 
and Matt Zekauskas, Fi- Workstmon Enwronment IEEE Trun,vuc!wms on Compurers 39,4 (AprlJ 1990) nally, 
we would like to thank the referees for their many valuable comments. [171 SATYANARAYANAN, M. KISTLER, 
J J. MUMMERT, L B. EBLING, M R, KUMAR. P., AND Lu, Q Experience with Disconnected Operimon m a Mobde 
Comput!ng Environment In Proct!tdmg \ oj rhe 1993 USENIX .$ympmium on Moh(le ml LJcut[on-IndependentC<~ 
mpLlting (C~mbrldge, MA, August 1993) References [18] SERLIN, O The History of DebllCredN and the TPC 
In The Bt!nchmurk Hun ff - BODNARCHUK, R R. AND BUNT. R B A Syntheoc Workload Model for I hook, J Grdy, 
Ed MorEan Kaufmm, 1991. D,stnbuted System Fde Server. In Pmceedmf., oi the 1991 ACM SIGhfETRICS Con@rence 
on Meu vurenwnr und Modelm# of Compurcr .$.v$reml (San Diego. [19] SysTsM PERFORMANCE EvAwATtoN COOPERATIVE, 
SPEC Benchmark sum+ CA, May 1991 ). Reltwse 10. October 1989 BUNT, R. B., AND MURPHY, J M The Measurement 
of LocARy mdthe Behavmr [20] THEKKATH, C A, WILKES, J, AND LAZOWSKA, E D Techniqueifor FiIe System of 
Program} The Compu~er Jowrna(27, 3 (August 1984) Slmulmon. Techmcid Report 92-09-08, Unlvers]ty of Washington, 
Deportment of Computer Science and Engineering, 1992 6UNT, ft 5, MURPHY J M AND MAJUMD&#38;lt 3 A h[t-d>urc 
Or i70~ram LOciIIRY and Its Apphcatlon In Proceeding\ of the 1984A CM SIGMETRICS Con&#38;rence [21) WOLMAN, 
B L, AND OLSON, T M IOBENCH A System Independent 10 ort MeLI,$urc!mc fit and Modelm# of Computer Sysrem.\ 
(C~mbrldge, MA. August Benchttmrk Computer Arch@crurs! New.! 17,5 (September 1989) 1984) 117 
			
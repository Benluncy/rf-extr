
 Biconnectivity Approximations and Graph Carvings * Samir Khtdler University of Maryland  Abstract A 
spanning tree in a graph is the smallest connected spanning subgraph. Given a graph, how does one find 
the smallest (i.e., least number of edges) 2-connected spanning subgraph (connectivity refers to both 
edge and vertex connectivity, if not specified) ? Unfortunately, the problem is known to be NP-hard. 
We consider the problem of finding an approximation to the smallest 2-connected subgraph, by an efficient 
al­gorithm. For 2-edge connectivity our algorithm guaran­tees a solution that is no more than ~ times 
the optimal. For 2-vertex connectivity our algorithm guarantees a so­lution that is no more than ~ times 
the optimal. The previous best approximation factor is 2 for each of these problems. The new algorithms 
(and their analyses) de­pend upon a structure called a carving of a graph, which is of independent interest. 
We show that approximating the optimal solution to within an additive constant is NP-hard as well. We 
also consider the case where the graph haa edge weights. We show that an approximation factor of 2 is 
possible in polynomial time for finding a k-edge con­nected spanning subgraph. This improves an approxi­ 
mation factor of 3 for k = 2 due to [FJ81], and extends it for any k (with an increased running time 
though). Partially supported by NSF grants CCR-890S949, CCR­9103135 and CCR-9111348. Institute for Advanced 
Computer Studies (UMIACS), University of Maryland, College Park, MD 20742. Permission to copy without 
fee all or part of this material is granted provided that the copies are not made or distributed for 
direct commercial advantage, the ACM copyright notica and the titla of the publication and its data appear, 
and notica is given that copying is by permission of the Association for Computing Machinery. To copy 
otharwise, or to republish, requiree a fse and/or epecific permission. 24th ANNUAL ACM STOC -5/92/VICTORIA, 
B. C., CANADA 01992 ACM 0-89791-51 2-71921000410759 . . ..$1 .50 Uzi Vishkin University of Maryland &#38; 
Tel-Aviv University  1 Introduction Let a graph G = (V, 1?) represent a feasible communi­cations network. 
An edge (a, b) denotes the feasibility of adding a link from site a to site b. A spanning tree in G is 
the smallest connected subgraph, i.e., the cheapest network that will allow the sites to communicate. 
No­tice that the network is highly susceptible to failures, since it cannot even survive a single link 
or site failure. For more reliable communication, one desires spanning subgraphs of higher connectivity. 
In this paper we consider the problem of finding the smallest 2-connected spanning subgraph (edge or 
vertex connected). These problems are easily seen to be NP­hard by a reduction from the Hamilton cycle 
problem (the graph has a Hamilton cycle, if and only if it has a 2-connected (edge or vertex) spanning 
subgraph with n edges). We will study approximation algorithms for this problem. Contributions: We give 
linear time algorithms to find a subgraph H = (V, EH) in G = (V, E), such that H is 2-connected. The 
number of edges in H is guaranteed to be no more than c OPT where OPT is the size of an optimal solution. 
For the case of 2-edge connectivity we obtain c = $, and for the case of 2-vertex connectivity we obtain 
c = ~ From the results presented, a natural question that 3 arises is: what are the limits for the 
edge and vertex cases ? We also show that unless P = NP there is no polynomial time algorithm that will 
produce a solution that is guaranteed to be of cost no more than OPT+ C, where C is some constant. For 
the csse of weighted graphs we observe that an approximation factor of 2 is possible in O(nk log n(m 
+ n log n)) time for finding the smallest weight k-edge con­nected subgraph based on algorithms by [G91a, 
FT89, Ed79]. This improves upon the approximation factor of 3 due to [FJ81] for k = 2. In designing the 
approximation algorithms we iden­ tified the carving and tme-carvingl of a graph as struc­tures that 
are useful for establishing lower bounds on the optimal solution. These notions might be of inde­pendent 
interest for understanding graph connectivity issues. Significance of the Approximation Results: Improving 
biconnectivity approximation factors can re­sult in significant savings in the design of a physical net­work 
since it enables discarding a fraction of the edges that were needed before. The algorithm has been implemented 
and tests on random graphs indicates that it achieves approximation factors in the range 1.1 . ..1.2. 
The approximation fac­tors got better as the graphs got denser; it went down to around 1.02 in the densest 
graphs that we checked. Previous Approximation Results: We note that an approximation factor of 2 is 
easy to obtain. Do a Depth First Search, and from each vertex (except the root) pick the highest going 
back edge. This gives a 2-connected spanning subgraph with at most 2n 2 edges, while n is a trivial 
lower bound on any optimal solution. Other schemes for obtaining approx­imation factors of 2 follow as 
simple consequences of [Wh32, CT91, N190]. Related Work: The question of finding minimum cost k-connected 
spanning subgraphs can be posed in the context of weighted graphs as well. For the case k = 1, the prob­lem 
reduces to that of finding a minimum spanning tree. For k = 2, the problem is Np-hard and a scheme that 
gave an approximation factor of 3 was given by [FJ81] in 0(n2) time. This was made simpler and improved 
to ob­taining the same approximation factor in O(rn+n log n) time by [KT91]. (Actually, the problem solved 
is of in­creasing the connectivity of an existing network from 1 to 2, but it can be used for an approximation 
factor of 3 as well.) When the edge weights satisfy the triangle inequality (and the underlying feasibility 
graph is a clique), there is extensive literature on the k-edge connected span­ning subgraph problem 
[FJ82, GB92, GMS92, MK89, SWK69]. For the case of edge or vertex connectivity when the underlying feasibility 
graph is a clique (any edge can be added at unit cost), one can solve the problem of the smallest k-connected 
spanning subgraph optimally [Ha62]. For the case of increasing the edge connectivity of an existing network 
from any A to k, when the un­derlying feasibility graph is a clique (any edge can be added at unit cost), 
the problem can be solved opti­mally [WN87, NGM90, G91b]. Naor, Gusfield and Mar­tel [NGM90] use a clever 
extension of the basic DFS ap­ 1Both these me distinct from the block cut tree described in Even s book 
@lv79]. preach of [ET76] to generalize the technique to work for any k. (Eswaran and Tarjan solved the 
case of increas­ing connectivity from 1 to 2 in their paper, where the problem was actually first introduced.) 
For the case of vertex connectivity, for k = 2, 3 the best algorithms are due to [ET76, RG77, HR91b] 
and [HR91a] respectively. A more general edge connectivity problem was con­sidered by Frank [Fr90] when 
the feasibility graph is a clique, and shown to be solvable in polynomial time. This result has recently 
been improved by [G91b]. The problem of finding a minimal (not minimum) 2-connected (edge and vertex) 
spanning subgraph was studied by [KR91] and [HKRT92]. (A graph with prop­erty P is minimal with respect 
to property P if it loses property P on deletion of any edge.) The relationship to this paper is that 
any minimal biconnected graph has at most 2(n 1) edges, which gives an approximation factor of 2. Studying 
biconnectivity properties of graphs has led to a few fundamental graph algorithmic techniques. (1) The 
power of Depth First Search was illustrated through biconnectivity [Ta72]. (2) The Tree Euler Tour technique 
for a parallel bicon­nectivity algorithm [TV85]. (3) The design of the Ear Decomposition Search algo­rithm 
in [MSV86] was originally motivated by extend­ing [Vi85] from a strong orientation algorithm into an 
alternative biconnectivity algorithm. Its use as a gen­eral technique for parallel graph algorithms came 
at a later stage. (4) Application of Graph Decompositions [G191, Fr91] to dynamic 2-edge and 3-edge 
connectivity.  Improving approximation factors: Considerable atten­tion has been given to improving 
constant approxima­tion factors. For example, Johnson [J082] reports a se­ries of 8 papers that give 
such improvements for bin packing, starting from an approximation factor of 2 down to 1.18333, and recently 
to (1 + c). For st einer trees, a similar series exists [KMB81, TM80, Ze91, BR92] . Outline of Paper: 
Section 2 gives basic definitions related to edge and ver­tex connectivity. Section 3 describes the algorithm 
for the edge connectivity case (this section is very simple and gives the flavor of the results and analysis 
for the vertex case, which is more involved). Section 4 describes the algorithm for the vertex connectivity 
case. Section 5 describes the results for weighted graphs. In Section 6 we show that the problem of finding 
a constant additive approximation to the optimal solution is lVP-hard. 2 Some definitions We will be 
dealing only with connected graphs G = (V, E), with no parallel edges. A graph is said to be k­vertez 
(k-edge) connected if it has at least (k + 1) ver­tices (edges), and the deletion of any (k 1) vertices 
(edges) leaves the graph connected. A single vertex in a connected graph whose deletion disconnects the 
graph is called a cut vertex (also known as articulation ver­tex). A graph with no cut vertices is called 
biconnected. A bridge in a graph is a single edge whose deletion dis­connects the graph. A graph with 
no bridges is called 2-edge connected. In a rooted tree, the pammt of a vertex u is denoted by p(u). 
 3 Edge Connectivity Case Given a 2-edge connected graph G(V, E), let OPT de­note the minimum number 
of edges in a 2-edge con­nected spanning subgraph of G. We present an algo­rithm that finds a subgraph 
H = (V, EH) that is 2-edge connected with I EH I at most ~OPT. High-level Description of the Algorithm 
We search G using depth-first-search (DFS). A DFS rooted spanning tree T is computed; T has at most n 
 1 edges, and all the non-tree edges are back edges (i.e., one of the endpoints of the edge is an ancestor 
of the other in T). All edges of T are picked for EH. During the depth-first search the algorithm also 
picks a set of non-tr~e edges that will increase the edge con­nectivity by covering all the edges in 
T (since each edge in T threatens to remain a bridge). A back edge may be chosen just before withdrawing 
from a vertex for the last time. Before withdrawing from a vertex v, we check whether the edge (v, p(v)), 
joining v to its parent, is currently a bridge or not. If (v, p(o)) is still a bridge, we cover it by 
adding to EH a back edge from a descen­dant of v to Iow[v], where 10W[V] is the vertex with the smallest 
dfs-number that can be reached by following zero or more downgoing tree edges from v, and a single back 
edge. The algorithm maintains the foIlowing data-structures during the DFS. dfs[v]: A serial number given 
to a vertex the first time it is visited during DFS. 10WH [v]: This is defined to be the smallest numbered 
vertex that can be reached by following zero or more downgoing tree edges from v, and a single back edge 
that belongs to EH. savior[v]: This is defined to be the descendant end vertex of the back edge that 
goes to 10W[V]. Correctness and Complexity: It is quite easy to see that H is 2-edge connected, and that 
the algorithm runs in time O(n + m). A detailed description of the algorithm maybe found in [KV92]. In 
Fig l(a), the vertices are shown numbered with the DFS numbering. The back edges are added in the following 
order: (6, 4), (7, 3), (9, 2), (3, 1). 3.1 The Approximation Analysis Our analysis finds a partition 
of the vertices, called a tree-carving, which is used to prove a lower bound on OPT, the number of edges 
in the optimal solution. The upper bound of ~ on the approximation factor is es­tablished using this 
lower bound. After presenting the concept of a tree-carving, we apply it to the approxima­tion analysis. 
 3.1.1 Tree-Carving Definition 3.1 A tree-carving of a graph is a parti­tion of the vertex set V into 
subsets Vi, V2, ..., V.. with the following properties. Each subset constitutes a node of a tme I . For 
every vertex v e Vj, all the neighbors of v in G belong to either Vj itself, or vk when vk is adjacent 
to Vj in the tree r. The size of the tree-carving is k. We will refer to the vertices of I as nodes, 
and the edges of r ss arcs. An example of a graph G, and a tree-carving for it is shown in Fig. 1. The 
carving tree I is shown in Fig. 2. Theorem 3.2 (Tree-Carving Theorem) If the graph G = (V, E) has a ime-carving 
of size k, then a lower bound on the number of edges of any 2­edge connected spanning subgraph in G is 
2(k 1). It is interesting to note that the same simple proof implies that the smallest ~-connected subgraph 
of G must have at least J(k 1) edges (for A > O). Proof: There are k 1 arcs in the tree I . Each such 
arc e = (Vi, Vj ) partitions the vertices in G into two sets Se and V Se. (Deletion of arc e breaks 
I into two trees rl and 1 2, where V; belongs to 171. Se is defined to be the union of the sets VY that 
belong to I 1.) In any 2-edge connected spanning subgraph we have: (1) at lesst two edges going from 
Se to V Se, and (2) the two edges implied by any other arc f in I are different than the ones implied 
by arc e. Since I has k -1 arcs, we get a lower bound of 2(k 1). o 3.1.2 Using !Jlee-Carvings for the 
Approxima­tion Analysis Given T, the DFS spanning tree, we will be interested in the following partition 
of the vertices of G, called the DFS-tme partition. Some recursive calls DFS(V, u) end by adding the 
back edge (savior[v], 10W[V]) to EH, and some do not add any edge. For each call DFS(V, u) where a back 
edge is added to EH, remove the tree edge (u, W) from ~ the resulting connected components of T (with 
some tree edges removed) provides the DFS­partition. Furthermore, T induces a rooted trve struc­ture 
I on the sets in the DFS-tree partition. In Fig l(a), the vertices are shown numbered with the DFS numbering. 
The back edges are added in the following order: (6, 4), (7, 3), (9, 2), (3, 1). Now con­sider the tree 
T, and remove the following tree edges: (5, 6), (5, 7), (8, 9), (1, 2). This gives us the DFS-tree partition. 
Theorem 3.3 The DFS-trve partition yields a tree­carving of G. Pmofi Let (VI, V2) be any non tree edge 
in G. Suppose that VI is in set VI of the DFS-tree partition and V2 is in set V2. The only thing that 
has to be proven is that exactly one of the following three possibilities must occur: VI = V2, or set 
VI is the parent set of set Vz (in the rooted tree structure I ), or Vz is the parent set of set VI. 
This is readily implied by the definition of low and the selection of back edges. 0 Corollary 3.4 Since 
the number of arcs in the trce­carving is exactly the same as the number of back edges that am added 
to EH we conclude that OPT ~ 2(k 1), whew k 1 is the number of added back edges. Theorem 3.5 The algorithm 
outputs a solution of size no mow than ~ OPT. Proof.c The number of edges added by the algorithm to H 
is: (i) (n 1), for the tree edges, plus (ii) k 1 back edges, where k is also the size of the tree-carving. 
Hence, thenumber ofedgesinEHisn-1 +k 1.Alower bound on the OPT solution is max(n, 2(k l)), since n is 
the minimum number of edges in a 2-edge connected graph with n vertices (each vertex should have degree 
at least 2), and 2(k 1) follows from Corollary 3.4. Hence, the ratio of the algorithm s solution to 
the OPT solution is n l-i k-l < max(n, 2(k 1)) Ifn~2(k 1), then clearly the ratio is < 3/2. If n~2(k 
1), it is again easy to see that the ratio is < 3/2. c1 We have an example to show that the ratio of 
~ is asymptotically tight.  3.1.3 Worst Case Example We provide an example (see Fig. 3) with n = 16, 
where the algorithm outputs EH with 15 + 8 = 23 edges. The optimal solution has 16 edges. The figure 
describes two 762 copies of the graph G; in each copy not all the edges are shown. The left copy shows 
only the 15 tree edges and the 8 back edges that are added by the algorithm (highest ones). In the right 
copy, the 16 edges that form a Hamiltonian cycle are shown along with the tree edges. Clearly we can 
generalize the example into a graph with n vertices that hss n/2 leaves attached to n/2 ver­tices in 
a path (like a broom ). In this case the ratio will be * , which converges to ~.   4 Vertex Connectivity 
Case We now describe the algorithm that finds a 2-vertex connected spanning subgraph H = (V, EH), of 
a given 2-vertex connected graph G, with I EH I at most gOPT. To motivate the presentation we start by 
applying the greedy approach of the 2-edge connectivity approxi­mation algorithm of the previous section 
to the example in Fig. 4. The DFS tree is the straight path and it is easy to see that each back edge 
must be added to cover a vertex that threatens to be a cut vertex. The graph shown is actually Hamiltonian, 
and clearly the example can be extended to yield approximation factors that are as close to 2 as we want. 
For this reason we design the algorithm to identify redundant edges in the DFS tree and discard them, 
For the analysis of the algorithm, we will define the notion of a carving of a graph, which is not as 
simple as the tree-carving that worked for the edge connectivity case. High-level Description of the 
Algorithm We first provide an overview of the algorithm. In the graph G, do a depth-first-search to compute 
a DFS spanning tree T. The idea is to now pick a set of back edges that will increase the vertex connectivity 
of the tree to two by detouring around each vertex of the tree T. During the Depth First Search all the 
tree edges are added to EH, as well as some subset of back edges. Some of the tree edges may be identified 
as redundant and discarded during the DFS. The back edges are cho­sen when the DFS traversal is visiting 
a vertex for the last time. When DFS retreats out of a vertex v for the last time, we check if the vertex 
u (parent of v) is po­tentially a cut vertex or not. If yes, we can cover it by adding to EH the highest 
going back edge from a de­scendant of v. (This will at least prevent the separation of v from p(u) under 
the deletion of u.) If the back edge emanates from v we discard the tree edge joining v with u (see Fig. 
5). This is called the discarding rule. Complexity: It is quite easy to see that the algorithm runs in 
time O(n + m). A detailed description of the algorithm may be found in [KV92]. 4.1 Correctness of the 
Algorithm subtree in T, including SZLViOrH [z]. Using the back edge (saviorH[z], 10WHIZ]), z can connect 
to the path Q, and The correctness of thealgorithm iseatablished via the thereby to p(v), as well. o 
following theorem. Theorem 4.1 The subgraph H = (V, E~) obtained by the algorithm is 2-vertez connected. 
Pmofi For the proof, it will be helpful to think of the algorithm as working in two phases. Phase ~: 
Baverse the graph using DFS, add all the tree edges to EH. Phase 2: Ikaverse the graph using DFS, add 
the re­quired back edgea to EH, and discard the tree edges by applying the discarding rule. We first 
state two lemmas that are used in the proof of the theorem. Lemma 4.2 For each non-root vertex v, the 
following paths exist in H, fmm the end of Phase 1 till the end of the algorithm. 1. Pathu(v): fmm v 
to its panmt p(v), using vertices outside the DFS subtree rooted at v (except for v itself). 2. PUthD(v, 
z): fmrn v, to each x that is a descendant of v, using only vertices in the subtwe rooted at v. By PUihD(V), 
we will wfer to the set of the paths PathD(v, x), for all descendants x.  Lemma 4.3 Let v be a vertez, 
and suppose that neither v nor p(v) are the mot. When the algom thm terminates, them is a path from v 
to its gmndpamnt w (i. e., w = P(P(v))) that does not use p(v). We complete the proof of the theorem 
by showing that no single vertex can disconnect H. Observe that the root of the DFS tree cannot be a 
cut vertex. (Since G is biconnected, the root has only one child v and using PathD(v), v can reach all 
the vertices, without using the root.) Let v be a non-root vertex. We will prove that H remains connected 
on deletion of v, by showing that every remaining vertex has a path to p(v). Consider deleting v from 
T. We obtain a connected component corresponding to each child of v, and one corresponding to the parent 
(that contains the root). (1) Let u be a child of v. Using PathD(v), clearly u is connected (in H) to 
all vertices in its subtree in T. Using Lemma 4.3, we can connect each such u with p(v). (2) We now consider 
the component of T containing p(v). Let the path from p(v) to the root in T be Q = [VI = p(v), vz, . 
. .v~ = root]. Clearly p(v) is connected (in H) to all of its ancestors on path Q by using f athu(vl) 
to V2, and Pat hU(v2) to us etc. Consider a vertex z (other than v), that is a child of some vi. Using 
PathD(Z) paths, z is connected (in H) to all the vertices in its 4.2 The Approximation Analysis We would 
first like to motivate the need for a slightly different structure than the one in the previous section, 
by showing the short-comings of the tree-carving in han­dling the vertex connectivity csse, Consider 
the graph shown in Fig. 6. It consists of 1 units of 4 vertices each. The root of each unit is connected 
to v in the DFS tree, and v is connected to r. Clearly the num­ber of back edges added by the algorithm 
equals 31. It should be clear that we cannot find a tree-carving of size greater than 21! + 2. The 21 
leaves form singleton sets in the carving, and since they all have edges to v, the set containing v in 
the tree-carving contains all the other vertices (except for r). Since n = 4.t + 2, and the number of 
added edges is 34, we get a ratio of ~, and this is not as good as we would like to claim. Our analysis 
finds a partition of the vertices, called a carving, which is used to prove a lower bound on OPT, the 
number of edges in the optimal solution. The upper bound of ! on the approximation factor is established 
using this lower bound. After presenting the concept of a carving, we apply it to the approximation analysis. 
4.2.1 Carving Definition 4.4 A carving of a gmph is a partition­ing of the vertex set V into a collection 
of subsets V1,V2,...,vk with the following properties. Each sub­set constitutes a node of a meted tree 
I . Each non-leaf node Q of I has a special grey vertex denoted by g(vj ) that belongs to p(Vj). Fo~ 
evey vertez v c ~, all the neighbors of v that arc in ancestor sets of Vi belong to either 1. K. 2. 
~, where U is the parent of K in the tme r.  9. Vl, where VI-is the gmndparent in the tree r. In this 
case however, the neighbour of v can only be 9(U). The size of the carving is k. We will refer to the 
vertices of I as nodes, and the edges of r as arcs. An example of a graph G together with a carving for 
it is shown in Fig. 7. Theorem 4.5 (Carving Theorem) If the graph G = (V, E) has a carving of size k 
with leaves in r, then a lower bound on the number of edges of any 2-vertez connected spanning subgmph 
in G is (k+ 1 1). Proof: Consider the rooted tree I , Each node of the tree other than the root has 
a unique parent node. Consider any leaf node X; Claim (1): in any 2-vertex connected spanning subgraph 
there must be at least two edges with exactly one endpoint in X. This implies that there are at lesst 
21 edges in the OPT solution. Now consider any non-leaf node X that is not the root. Claim (2): in any 
2-vertex connected spanning subgraph there must beat least one edge that has one endpoint in X and the 
other in an ancestor set of X. (Some vertices that belong to the children sets of X may have edges going 
to g(X), but since g(X) is not a cut vertex, Claim (2) follows.) There is no overlap in the counting 
scheme for different sets. There are k 1 1 nodes satisfying Claim (2) in the tree I . This shows that 
24+ (k 1 1) is a lower bound on the size of any 2-vertex connected spanning subgraph. 0 4.2.2 Using 
Carvings for a Lower Bound on OPT Given T, the DFS spanning tree, we will be interested in the following 
partition of the vertices of G, called the DFS-tme partition. Some recursive calls DFS(V, u) end by adding 
the back edge (savior[v], 10W[V]) to EH without discarding any tree edge. (These are the re­cursive calls 
that cause a net increase in the number of back edges.) For each such call DFS(V, u), remove the tree 
edge (u, v) from T; the resulting connected compo­nents of T (with some tree edges removed) provides 
the DFS-partition. lhmthermore, T induces a rooted tree structuw on the sets in the DFS-tree partition. 
Let 1 denote the number of back edges emanating from the leaves, and z denote the net increase due to 
the other back edges. The net increase in the number of edges is 1+ Z. Theorem 4.6 The DFS-tree partition 
yields a carving of G. Before describing the proof, we give some definitions that make the proof clearer. 
The algorithm adds an edge to EH just before it leaves v for the last time and discovers that 10WHIW] 
= v (which implies that v is a leaf), or discovers that 10WH [v] = u (which implies that u is threatening 
to be a cut vertex). In the first case we add to EH the highest going back edge from the leaf v, and 
create a singleton leaf set in the DFS-tree partition. In the second case (only when no tree edge is 
discarded), we pick the highest going back edge from a descendant of v, and find a new set for the DFS-tree 
partition. The gmy vertex of this set is defined to be u. (Recall that the grey vertex is a vertex in 
the parent set.) Definition 4.7 Given a set of vertices K, its mot is the vertex with the smallest dfs 
number in the set. It is denoted as mot~i). Proposition 4.8 The mot of a set in the carving is the vertex 
v such that the tme edge (v, p(v)) was wmoved from the DFS tree. Proof (Of Theorem 4.6): Consider coloring 
all the ver­ tices that are roots of a set red. Each vertex joins the set corresponding to its closest 
red ancestor (in the DFS tree). It is clear that this gives us a tree structure on the sets. Consider 
a non-tree edge e = (v, w). Since there are no cross edges assume that w is an ancestor of v. Assume 
that v E ~. We need to prove that the endpoint w either (1) belongs to the same set ~, (2) to the parent 
set ~, (3) or w is the grey vertex of Vj, in the parent set of Vj. Suppose that w is in set vh such that 
vh is neither Vi, nor ~. So Vh is a proper ancestor of ~ in r. The algo­ rithm picked the highest going 
back edge when mark­ ing root (u) finished. This must go to a vertex z with z < w. Hence when marking 
v = root(Vj ) finished, 10WHIV ] ~ Z. The only way v can be colored red, is if z = w = p(v ), in which 
case w is the grey vertex of Vj. 1 Corollary 4.9 (Lower Bound) The number of arcs in the carving is 
exactly the same as the net number of back edges that are added to EH (k 1 =1+ z), and the number of 
leaves in the carving twe is the same as the number of back edges added from leaf vertices. Thus we conclude 
that OPT > 2!+ x, whew x is the net increase due to non-leaf back edges and 1 is the number of leaves 
in the carving tme I . Proofi Corresponding to each back edge we have one set in the carving and thus 
k 1 = 1+ Z. Each leaf is put in a singleton leaf set in the tree I , and since a back edge is added from 
each leaf the claim follows. Substituting for k in Theorem 4.5 yields OPT z 2t?+ x. 1 A lower bound for 
the OPT solution is max(n, 2.4+ z). (The bound of n edges follows from a degree argument since each vertex 
should have degree at least 2. The other bound follows from Theorem 4.5 and Corollary 4.9.) 4.2.3 An 
Upper Bound on I EH I The number of edges added by the algorithm is as fol­lows: first (n 1) edges (for 
the tree edges), then an extra (.4+ z) edges (this denotes the net increase). Theorem 4.10 The number 
of edges added by the al­gorithm (net inc~ase) can be upper bounded by #(n +1) where n is the number 
of vertices and 1 is the number of leaves in the DFS tree T. Notice that this gives an upper bound of 
~(n /) for z (the net increase = 1 + z). Proof: We prove this theorem by a simple charging scheme. The 
back edges that are added break naturally into three categories. 1. $Upe A) Back edges that emanate from 
a leafv in 2. (Type B) Back edges that emanate from a non-leaf w in T, and delete the tree edge (v, 
p(v)) when they are added. 3. (Type C) Back edges that emanate from a non-leaf  v in T, and do not 
delete any tree edgea when they are added. It is clear that the net increase in the number of edges is 
only due to edges of types A and C. We give a simple proof to upper bound the number of added edges. 
For each edge of type A emanating from a leaf v, we put a charge of 1 to each leaf vertex. For each edge 
of type C emanating from a vertex v, we put a charge of # to v and a charge of # to p(v), The following 
lemma shows that no non-leaf vertex can get charged more than once. Lemma 4.11 By this process each non-leaf 
vertex gets a charye of at most ~. Pmojl Suppose that there is a vertex v that gets charged more than 
once due to edges of type C being added. There are two cases; either it could get charged due to back 
edges emanating from children U1 and U2, or it could get charged due to a back edge emanating from v 
and a back edge emanating from a child U1 (all of type c). First notice that if any Ui is a leaf vertex, 
then it would not charge v. Hence we can assume that ui s are non-leaf vertices and hence 10WH [ui] < 
ui when we mark ~i finished. In the first case, if either 10WH[u1] or 10WH [uz] is equal to v, before 
the back edges emanating from U1 and U2 are added then these back edges are of type B. Now suppose that 
both 10WHIU1] and 10WH [U2] are less than v. In this case only one of the back edges emanating from U1 
or U2 can be chosen (the one that goes higher). In the second case, low~[ul] s v when we mark U1 finished. 
If it is equal to v, then the edge emanating from U1 is of type B. If it is < v then again only one of 
the two back edges emanating from v and U1 can be chosen (the one that goes higher). n Hence after this 
process, each leaf vertex has a charge of 1, and each non-leaf vertex has a charge of at most ~. Thus 
the total number of added edges (net increase) is no more than 1+ ~(n 1) = ~(n + 1). Thus Theorem 4,10 
follows. 0 4.2.4 Wrapping up the Approximation Analy­sis Theorem 4.12 The algorithm outputs a solution 
of size no more than ~ OPT. Proof; The ratio of the algorithm s solution to the OPT solution is upper 
bounded by -j. By Theorem 4.10 we know that z ~ ~(n -1). The sp­proximation ratio of the algorithm is 
upper bounded by the maximum possible value of the following function: n+(t?+z) msx(n, 2/ + z) Case 
1: n~2t?+z We wish to compute the maximum of 1 + ~ sub­ject to the constraints on i, t. The constraints 
are n 21 z z and !j(n 1) ~ z. Under these con­ straints we have to maximize ~. By drawing the fessible 
region on the (1, z) plane we can see that it is maximum for-l = n/3 and z = n/3 thus giving 5 as an 
upper bound. Case 2: ng21+z We wish to compute the maximum of ~. Re­placing n by 24+ z, (since its an 
upper bound) we get, 3e+ 28 =2 A 2e-tx u where u= 2+$. To compute the maximum value we wish to maximize 
u. The constraints are n 21 ~ z and ~(n 1) ~ z. Under these constraints we have to maximize ~. This 
time we get (t = l), hence we get u = 3 and hence the maximum value is ~. c1  4.2.5 Worst Case Example 
Fig. 8 describes an instance of an example where the algorithm achieves an approximation factor that 
is as bad as $ in the limit. (The example is due to Saran, Vaziraru and Young.) There is a path of alternating 
black and white vertices of length 277J+ 1, with m white vertices. (In this instance m = 4.) There are 
m leaves that are connected to the black vertices (one to each, except at the root). This describes the 
DFS tree T completely. There are back edges that connect each leaf to the closest black ancestor that 
is not the parent. There are also back edges that connect adjacent white vertices on the path, and back 
edges connect alternate black vertices on the path. Here n = 3m + 1. The num­ ber of back edges added 
from the leaves is m, and the number of back edges added from non-leaf vertices is m 1. The total number 
of edges in the subgraph ob­tained by the algorithm is 5m 1, but the graph is easily seen to be Hamiltonian. 
(Take all the leaves and their adjacent edges, and add to it a path connecting suc­cessive white vertices 
together with the extreme edges of the alternating path.) Thus the ratio is ~, and approaches ~ asymptotically. 
  Weighted Graphs Consider the following problem: Given a graph G = (V, E) with weights on the edges, 
find the smallest weight spanning subgraph H = (V, EH ) that is k-edge connected (for any k). The problem 
is known to be NP-hard [GJ78]. An al­gorithm that achieves an approximation factor of 3 for k = 2 is 
implied by [FJ81] as follows. Find the min­imum spanning tree. Consider the problem of adding the least 
weight set of edges to add to the tree to obtain a 2-edge connected subgraph. Not surprisingly, this 
is NP-hard as well [GJ78]. They gave an algorithm with an approximation factor of 2 for the problem of 
aug­menting connectivity, yielding an approximation factor of 3 for the least weighted 2-edge connected 
subgraph. (The same factor for 2-vertex connectivity is obtained as well.) Consider a directed graph 
G with weights on the edges, and a fixed root r. How does one find the cheapest directed subgraph HD 
that has k-edge disjoint paths from a fixed root r to each vertex v ? Gabow [G91a] gives the fastest 
implementation of a weighted matroid intersection algorithm to solve this problem in O(kn(rn + n log 
n) log n) time. (See also [Ed79, FT89].) To solve our problem (approximation algorithm) take the undirected 
graph G, and replace each undirected edge (u, v) by two directed edges (u, v) and (v, u) with each edge 
having weight W(U, v) (the weight of the undi­rected edge). Call this graph GD. Now run Gabow s al­gorithm 
on the graph GD. If at least one of the directed edges (u, v) or (v, u) is picked in HD, then we add 
(u, v) to EH. Lemma 5.1 The graph EH is a k-edge connected span­ning subgraph of G. Proofi Suppose in 
contradiction that there is a k 1 edge cut in H. Assume that it separates H into pieces Cl and C2. Let 
r be in C l, now consider a vertex v in C 2. It is clear that r cannot have k edge disjoint directed 
paths to v. Thus, there cannot be a cut set of size k 1. 1 Theorem 5.2 The total weight of EH is at most 
twice the weight of the OPT solution. Proof Consider the OPT solution for the problem. Consider all the 
antiparallel edges corresponding to edges in OPT. We get a directed subgraph in GD of cost 2c(OPT) (where 
c(OPT) is the total weight of the edges in OPT). From r there are k edge disjoint undi­rected paths to 
any vertex v; they also yield k directed paths from r to v that are edge disjoint. Thus, this subgraph 
has the property of having k directed edge disjoint paths from r to any vertex v. Thus the opti­mum solution 
found by Gabow s algorithm must only be cheaper. c1 6 What can we hope for ? In this paper we showed 
that we can get multiplicative approximation factors of ~ and ~ for the 2-connected (edge and vertex 
respectively) spanning subgraph prob­lem. In this section we ask: Is a multiplicative constant the best 
that we could hope for ? Can one hope to get an additive constant ? We answer this question nega­tively 
by proving that no additive constant is possible. The proofs may be found in [KV92]. Theorem 6.1 If P 
# NP, then there is no polynomial time approximation a!gon thm that can obtain a solution to 2-edge connected 
spanning subgraph that is s OPT+ C, for any constant C. Theorem 6.2 If P # NP, then there is no polyno­mial 
time approximation algorithm that can obtain a solution to 2-vertez connected spanning subgraph that 
is ~ OPT+ C, for any constant C. Acknowledgments: We thank Yossi Matiaa and Neal Young for help in the 
generation of random graphs. We thank Huzur Saran, Vijay Vazirani and Neal Young for gifting the example 
in Subsection 4.2.5 on the occa­sion of the first author s wedding. We thank Ramki Thurimella for useful 
discussions. We also thank Umesh Vazirani for useful comments on an earlier draft.  References [BR92] 
P. Berman and V. Ramaiyer, Improved ap­ proximations for the steiner tree problem, 3rd Annual Symposium 
on Discrete Algorithms, pp. 325-334, (1992). [CT91] J. Cheriyan and R. Thurimella, Algorithms for parallel 
k-vertex connectivity and sparse certifi­catees, 23rd Annual Symposium on Theory of Computing, pp. 391-401, 
(1991). [Ed79] J. Edmonds, Matroid intersection, Annals of Discrete Mathematics, No. 4, pp. 185 204, 
(1979). [Ev79] S. Even, Graph Algorithms, Computer Science Press, Potomac, Md., (1979). [ET76] K. P. 
Eswaran and R. E. Tarjan, Augmenta­ tion problems, SIAM Journal on Computing, Vol. 5, No. 4, pp. 653-665, 
(1976). [Fr91] G. N. Fredrickson, Ambivalent data structures for dynamic 2-edge connectivity and k small­est 
spanning trees: 32nd Annual Symposium on Foundations of Computer Science, pp. 632-641, (1991). [Fr90] 
A. Frank, Augmenting graphs to meet edge­connectivity requirements? 31 t Annual Sympo­sium on Foundations 
of Computer Science, pp. 708-718, (1990). [FJ81] G. N. Fredrickson and J. J6.16, Approximation algorithms 
for several graph augmentation prob­lema~ SIAM Journal on Computing, Vol. 10, No. 2, pp. 270-283, (1981). 
[FJ82] G. N. Fredrickson and J. J&#38;J6, On the rela­tionship between the biconnectivity augmenta­ tion 
and traveling salesman problems, Z heorei­ ical Computer Science, Vol. 19, No. 2, pp. 189 201, (1982). 
[FT89] A. Frank and E. Tardos, An application of sub­ modular flows, Linear Algebra and its Applica­tions, 
114/115, pp. 320-348, (1989). [G9: a] H. N. Gabow, A matroid approach to finding edge connectivity and 
packing arborescences, 23 d Annual Symposium on Theory of Comput­ ing, pp. 112 122, (1991). [G9: b] H. 
N. Gabow, Applications of a poset repre­ sentation to edge connectivity and graph rigid­32 nd Annual 
symposium on Foundations of ity, Computer Science, pp. 812-822, (1991). [GB92] M. X. Goemans and D. J. 
Bertsimas, Surviv­able networks, linear programming relaxations and the parsimonious property, to appear 
in Mathematical Programming, (1992). [GJ78] M. R. Garey and D. S. Johnson, Computers and Intractability: 
A guide to the theory of NP­completeness , Freeman, San Francisco (1978). [G191] Z. Galil and G. Italiano, 
Fully dynamic algo­rithms for edge connectivity problems, 23rd An­nual Symposium on Theory of Computing, 
pp. 317-327, (1991). [GMS92] M. Groetschel, C. L. Monma and M. Steer, Computational results with a cutting 
plane al­gorithm for designing communication networks with low-connectivity constraints, to appear, Operations 
Research, (1992). [Ha62] F. Harary, The maximum connectivity of a graph? Proc. Nat. Acad. Sci., 48, pp. 
1142-1146, (1962). [HKRT92] X. Han, P. Kelsen, V. Ramachandran and R. E. Tarjan, Computing minimal spanning 
sub­graphs in linear time, 3rd Annual Symposium on Discrete Algorithms, pp. 146-156, (1992). [HR91a] 
T. S. Hsu and V. Ramachandranj A lin­ear time algorithm for triconnectivity augmenta­tion, 32nd Annual 
Symposium on Foundations of Computer Science, pp. 548 559, (1991). [HR91b] T. S. Hsu and V. Ramachandran, 
On finding a smallest augmentation to biconnect a graph, 2nd Annual International Symposium on Algo­rithms, 
Springer Verlag LNCS 557, pp. 326 335, (1991). [HT73] J. E. Hopcroft and R. E. Tarjan, Dividing a graph 
into triconnected components, SIAM Journal on Computing, Vol. 2, No. 3, pp. 135­158, (1973). [HT74] J. 
E. Hopcroft and R. E. Tarjan, Efficient pla­narity testing, Journal of the ACM, Vol. 21, No. 4, pp. 549-568, 
(1974). [J082] D. S. Johnson, The NP-completeness column: An ongoing guide, Journal of Algorithms, 3, 
pp. 288-300, (1982). [KMB81] L. Kou, G. Markowsky and L. Berman, A fast algorithm for steiner trees, 
Acts Informat­ica, 15, pp. 141-145, (1981). [KR91] P. Kelsen and V. Ramachandran, On finding minimal 
two-con nected subgraphs, 2nd Annual Symposium on Discrete Algorithms, pp. 178-187, (1991). [KT91] 
S. Khuller and R. Thurimella, Approxima­tion algorithms for graph augmentation, Tech­nical Report UMIACS-TR-91-132, 
CS-TR-2766, Univ. of Maryland, September (1991), to appear in Journal of Algm-ithms. [KV92] S. Khuller 
and U. Vishkin, Biconnectivity ap­proximations and graph carvings, Technical Re­port UMIACS-TR-92-5, 
CS-TR-2825, Univ. of Maryland, January (1992). [MK89] C. L. Mcmma and C. W. Ko, Methods for designing 
survivable communication networks, NATO Advanced Research Workshop, Denmark, (1989). [MSV86] Y. Maon, 
B. Schieber, and U. Vishkin. Par­allel Ear Decomposition Search (EDS) and st­numbering in graphs, Theondical 
Computer Science, 47, pp. 277-298, (1986). (NGM90] D. Naor, D. Gusfield and C. Martel, A fat algorithm 
for optimally increasing the edge connectivity, 31 t Annual Symposium on Foun­dations of Computer Science, 
pp. 698 707, (1990). [N190] H. Nagamochi and T. Ibaraki, Linear time algo­rithms for finding a sparse 
k-connected spanning subgraph of a k-connected graph, to appear, Al­gorithmic. [RG77] A. Rosenthal and 
A. Goldner, Smallest aug­mentations to biconnect a graph, SIAM Journal on Computing, Vol. 6, No. 1, pp. 
55-66, (1977). [SWK69] K. Steiglitz, P. Weiner and D. J. Kleitman, The design of minimum-cost survivable 
net­works, IEEE i%msactions on Circuit Theory, CT-16, 4, pp. 455-460, (1969). [Ta72] R. E. Tarjan, Depth-first 
search and linear graph algorithms, SIAM Journal on Comput­ing, Vol. 1, No. 4, pp. 146 159, (1972). [TM80] 
H. Takahashi and A. Matsuyama, An ap­proximate solution for the steiner tree problem in graphs, Math, 
Japonica, 24, pp. 573 577, (1980). [TV85] R. E. Tarjan and U. Vishkin, An efficient par­allel biconnectivity 
algorithm, SIAM Journal on Computing, 14, pp. 862 874, (1985). [Vi85] U. Vishkin, On efficient parallel 
strong orien­tation, Information Processing Letters, 20, pp. 235-240, (1985). [Wh32] H. Whitney, Non-separable 
and planar graphs, ZYans. Amer. Math Sot., 34, pp. 339­362, (1932). [WN87] T. Watanabe and A. Nakamura, 
Edge­connectivity augmentation problems, J. of Comp. and Sys. Sciences, 35 (l), pp. 96-144, (1987). [Ze91] 
A. Zelikovsky, The 11/6 approximation algo­rithm for the steiner problem on networks, manuscript, to 
appear in Information and Com­putation. (a) G : , , , : * , : 9 ........-......... (b) Tree-Carving 
of size 5 for G Figure 1: A graph G and a tree-carving for it. Figure 2: The carving tree r. G ,.. .. 
..O r.. .** .* ., -.. . : 9. ; ., ** ,. ..: . .*, 8 .$. ; ,. .*. 4 9 .* ., , . . ;: .: ., , .* ,, : 
: . ,, : . ~;; *8:: ,, ; . ,, ::: :0, ; , ,s, : ,*,* ,s, : a:, , ,0;: , . ,*; , :9 ::: : : :: ; :*: 
0:0, :: ::: , : ;: :.::,* ;: :,, :: 0:, ;  :::: :::: ::: , **, ::: ::: .:: ~ ; :: ;: ;,:: :; ::~ o::: 
,::: :::: :,$: * ,:: *::: *. *:: %:; ., : . ,*, : .s, ,/: **:::*:* ,.,:::; \ ;:: j: : : .................... 
 ;::: S*:: A *4 ;h: . G 0 Figure5: Rule fordiscarding tree edges. DFS tree edges ---Back edges added 
by algorithm -Hamiltonian cyclein G Example to illustrate worst case performance. a unit of 4 vertices 
 Figure 6: Example to slhow short-comings of tree­carving. Figure 4: Example to show the necessity of 
discarding. (a) G . , , , .. , , : ~ * (a) The graph G node of V3 and V5 . : , : , : (b) Carving of 
size 6 for G (b) The edges picked by Algorithm 2-VC (c) The tree r Figure 8: Example to illustrate worst 
case performance. Figure 7: A graph G, a carving for it, and the carving tree r. 
			
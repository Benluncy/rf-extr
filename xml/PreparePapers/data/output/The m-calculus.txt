
 The M-calculus: A Higher-Order Distributed Process Calculus Alan Schmitt Jean-Bernard Stefani INRIA 
INRIA alan.schmitt@inria.fr jean-bernard.stefani@inria.fr ABSTRACT This paper presents a new distributed 
process calculus, called the M-calculus, that can be understood as a higher-order version of the Distributed 
Join calculus with programmable localities. The calculus retains the implementable character of the Distributed 
Join calculus while overcoming several important limitations: insu.cient control over communica­tion 
and mobility, absence of dynamic binding, and limited locality semantics. The calculus is equipped with 
a poly­morphic type system that guarantees the unicity of locality names, even in presence of higher-order 
communications a crucial property for the determinacy of message routing in the calculus. Categories 
and Subject Descriptors F.m [Theory of Computation]: Miscellaneous  General Terms Design, Languages, 
Theory  Keywords Process Calculi, Distribution, Mobility, Higher Order, Type Systems 1. INTRODUCTION 
Among the process calculi which have been introduced over the past decade to serve as a basis for a distributed 
and mobile programming model, the Distributed Join calcu­lus [7, 6, 11] constitutes an interesting milestone. 
It provides a distributed programming model with hierarchical fail-stop localities, transparent mobility 
and communications, and it can be e.ciently implemented. The Distributed Join calcu­lus, however, has 
several limitations: This work has been supported in part by the Mikado IST Global Computing Project 
(IST-2001-32222) Permission to make digital or hard copies of all or part of this work for personal or 
classroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial 
advantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, 
to republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or 
a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 
...$5.00. It o.ers insu.cient control over communication and process mobility, which is an issue in 
distributed en­vironments where security is a primary concern. For instance, it is not possible to prevent 
a locality from migrating to another locality, except by forcing its fail­ure. Also, once a resource 
(a Distributed Join calculus de.nition) has been de.ned and communicated, it is very di.cult to prevent 
access to that resource or to de.ne the equivalent of a .rewall [4].  It does not support dynamic binding. 
In a distributed programming model, it is important to provide both local and remote equivalent of libraries 
or services, be­cause of the cost, safety, and security considerations that may apply. Thus, it should 
be possible to access identically named libraries or services (like a print ser­vice) at di.erent sites. 
In the Distributed Join calculus such a choice is not directly available since each de.ni­tion is uniquely 
de.ned: every resource is permanently bound to a single locality.  It does not support the de.nition 
of localities with di.erent semantics. For instance, localities in the Dis­tributed Join calculus are 
de.ned to be fail-stop. While it would be possible to change the semantics of the cal­culus to accommodate 
di.erent failure modes (such as omission or byzantine failures), the question remains as to how one can 
combine di.erent failure modes within the same calculus. Likewise, one could require a locality to be 
endowed with a particular form of ac­cess control (e.g. restricting access to resources within a locality 
to principals appearing in an access control list).  The M-calculus presented in this paper is designed 
to over­come the limitations of the Distributed Join calculus while preserving some of its key features, 
notably, its concept of hierarchical localities (which is crucial to deal with security, migration, and 
failures), its notion of multiway synchroniza­tion, and its implementable character. Speci.cally, the 
main contributions of this paper are: the notion of programmable locality, that generalizes the di.erent 
concepts of locality found in the Dis­tributed Join calculus and other distributed process calculi; 
 the conjunction of higher-order processes and hierar­chical programmable localities to unify communication 
and process migration, combining the possibility of  P ::= process 0 null process ||||||||| V a(P)[P] 
P | P PP (P,...,P) .n.P ([µ = V]P,P) (JrP) pass V value locality parallel composition application tuple 
restriction conditional reaction rule passivation V ::= value () null value ||| u (V,...,V) .x.P name 
tuple abstraction J ::= Join pattern rx message | J | J synchronization Figure 1: Syntax of the M-calculus 
transparent routing as in the Distributed Join calculus with .ne-grained ambient-like control over information 
exchange; the introduction of a passivation operator as a key primitive for programming di.erent forms 
of control that can be exercised by localities;  the de.nition of a type system that guarantees the 
de­terminacy of the routing mechanism by ensuring that every locality bears a unique name, even in presence 
of higher-order communication.  A programmable locality in the M-calculus (or locality, in brief) has 
a name and contains two processes: a con­troller, which .lters incoming and outgoing messages, and a 
content. In order to apply the same control mechanisms to remote communication and process migration, 
the latter is just communication of a thunk, i.e. a frozen process. A running locality may be frozen 
by its controller using the passivation operator. This operator takes a function that de.nes the operations 
to apply on the controller and con­tent processes of a locality, such as sending them in a remote message, 
discarding them, or modifying them. The paper is organized as follows. Section 2 de.nes the syntax and 
operational semantics of the M-calculus. Sec­tion 3 introduces a type system that ensures the unicity 
of locality names. Section 4 gives an encoding of the Join cal­culus that illustrate the versatility 
of the calculus. Section 5 discusses related work. Section 6 concludes the paper.  2. THE M-CALCULUS 
We present in this section the M-calculus, introducing the syntax and the semantics as we describe local 
communica­tion, remote communication, control, and migration. The syntax is summarized in .gures 1 and 
2. In the following, we use bold fonts for identi.ers that may stand for names or variables, as described 
in .gure 2. Communication takes the form of an asynchronous, chan­nel-based, point-to-point exchange 
of messages, re.ecting the dominant mode of communication in current large scale n ::= resolved name 
r resource name | a locality name r ::= variable resource name r resource name | x variable a ::= variable 
locality name a locality name | x variable u ::= name a variable locality name | r variable resource 
name | a.r located resource µ ::= name pattern n resolved name wildcard | Figure 2: Names E ::= ( · ) 
| EV | PE | .n.E | (E | P) | (P | E) | a(P)[E] | a(E)[P] | (P1,...,E,...,Pn) Figure 3: Evaluation Contexts 
networks. Channels are called resources and we assume there is an in.nite countable set of resource names. 
We let r range over this set. A local message is an application of a resource name to a tuple of values 
rVX. Receivers in the M-calculus are reaction rules composed of a multiway synchronization pattern (similar 
to the one proposed infor­mally by Milner for his Polynomial p-calculus and to Join patterns), and of 
a guarded process. Every reaction rule (r1xx1 | ... | rnxxn CP) de.nes theresourcenames r1, ..., rn. 
The formal parameters xx1, ..., xxn are tuples of vari­ables, and we assume there is an in.nite countable 
set of variables. The local communication rule is very similar to the Join rule of the Join calculus, 
substituting message ar­guments for formal arguments in the guarded process (rule R.Res of .gure 4). 
We remark that the reaction rule is repli­cated: it does not disappear after reduction. We also remark 
that a reaction rule does not bind its de.ned names. New resource names are introduced and bound using 
a restriction operator .r.P. In the reduction rules of .gure 4, rule R.Context uses evaluation contexts 
de.ned in .gure 3, and rule R.Equiv uses structural equivalence. Structural equivalence, =,isthe smallest 
equivalence relation that satis.es the rules given in Figure 5, where the parallel composition operator 
| for pro­cesses is taken to be commutative and associative, with 0 as its neutral element. The structural 
rules comprise scope extrusion rules for the restriction operator, standard rules for equivalence under 
a-conversion, and congruence for eval­uation contexts. Equivalence of two processes P and Q up to a-conversion 
is noted P =a Q.We recall that in .n.P, .x.P,and (r1xx1 | ... | rnxxn CP), the names and variables n, 
x,and xXi are bound in P. Free names of a process P are de.ned as usual and written fn(P). We recall 
that the de.ned names of a reaction rule (JCP) are free. [R.Beta] (.x.P)V .P{V/x} match(µ, V ) [R.If.Then] 
([µ = V ]P,Q) .P ¬match(µ, V ) [R.If.Else] ([µ = V ]P,Q) .Q [R.Passiv] a(pass V |P)[Q] .Va(..P)(..Q) 
(JrP)= (r1xV1 |... |rnxVn rP) [R.Res] . (JrP)|r1VV1 |... |rnVVn .(JrP)|P{Vi/.} xi P .Q [R.Context] E(P) 
.E(Q) P =P' P' .Q' Q' =Q [R.Equiv] P .Q Figure 4: Computing Rules n .fn(Q) [S.Nu.Par] (.n.P) |Q =.n.P 
|Q n .fn(Q) . n= a [S.Nu.Ctrl] a(.n.P)[Q] =.n.a(P)[Q] .fn(P) . n= a n P =a Q [S.Nu.Cont][S.a] a(P)[.n.Q] 
=.n.a(P)[Q] P =Q P =Q [S.Context] E(P) =E(Q) Figure 5: Structural Equivalence As a communication example, 
we may write a reference cell process as in the Join calculus: .s. (get(k) '|s(st) Ck(st) '|s(st)) )| 
|(set(st) |s(st) Cs(st)) get(print) |set(3) |s(0) which may reduce to print(0) or print(3). We now describe 
remote communication of asynchronous messages. In many calculi, remote communication involves two steps: 
resolving where to send the message, and send­ing it. For instance, in the Distributed Join calculus, 
every channel is de.ned in at most one location and de.nitions cannot move from one location to another. 
Thus a de.ned channel name is unambiguously associated to the location containing its de.nition. In the 
dynamic Join calculus [20], the destination for a dynamic message is resolved accord­ing to the channel 
name and the current position of the message. In the Ambient calculus, an ambient migrates ac­cording 
to the explicit capabilities that it expresses and its local environment. The destination of a message 
in the Box­p calculus [21] also depends on the immediate environment of the message. In order to avoid 
restricting the calculus to one particular semantics, we let the resolving step be a X part of the calculus: 
a remote message has the form a.rV , where a is the explicit destination of the message, which [R.A.Ctrl.Final] 
a(P |a.rVx)[Q] .a(P |rVx)[Q] [R.A.Cont.Final] a(P)[Q |a.rVx] .a(P)[Q |rVx] b .locs(P) .locs(Q) .{a} [R.A.In] 
b.rVx|a(P)[Q] .a(P |i(b, r, Vx))[Q] b .locs(Q) \locs(P) b= a [R.A.Ctrl.To.Cont] a(P |b.rVx)[Q] .a(P)[Q 
|b.rVx] b. locs(P) .locs(Q) b = a [R.A.Ctrl.To.Env] a(P |b.rVx)[Q] .a(P)[Q] |b.rVx b. locs(Q) b = a [R.A.Out] 
a(P)[Q |b.rVx] .a(P |o(b, r, Vx))[Q] Figure 6: Routing Rules (Addressed Messages) locs(.n.P)= locs(P) 
\{n} locs(PQ)= Ø locs(a(P)[Q]) = a,locs(P),locs(Q) locs((JrQ))= Ø locs(P |Q)= locs(P),locs(Q) locs(([µ 
= V ]P,Q)) = Ø locs(pass V )= Ø locs(V )= Ø locs(0)= Ø locs(P1,...,Pq)= Ø Figure 7: Multiset of Active 
Localities can be thus chosen by the programmer. We see that an ad­dressed resource a.r is composed of 
an address (a locality name), whichmay correspondtoan IP address, anda re­source name, which may correspond 
to a port number. This construction is similar to the high-level c@a construct of No­madic Pict [24]. 
The second step of remote communication is the actual sending of the message to the remote locality. 
This communication step might be direct independently of the relative positions of the message and the 
destination, as in the Join calculus, or it might involve several local steps, following the structure 
of localities to reach the destination, as in the Ambient calculus. We remark that these two mod­els 
may coincide when considering a .at model of localities. Just as in the Distributed Join calculus and 
in Ambient calculi, we retain the idea of hierarchically organized local­ities, a crucial feature for 
capturing the spatial and logical partitioning of control in distributed systems. We assume there is 
an in.nite countable set of locality names, and we let a, b range over this set. New locality names are 
intro­duced and bound by the restriction operator .a.P. To de.ne the routing rules, we write locs(P) 
for the multiset of un­restricted active localities of P. This multiset is formally de.ned in .gure 7. 
In the rest of this paper, we say that a process P is active in Q if Q is structurally equivalent to 
a process of the form E(P) for some evaluation context E.Lo­calities in the M-calculus provide the means 
to enforce some control on incoming and outgoing messages. This control may be arbitrarily complex, may 
require maintaining some state, and should be kept separate from the program run­ning in the locality. 
For this reason, localities take the form a(P)[Q]where a is the name of the locality, P is a process 
controlling the locality and its interactions with the envi­ronment, and Q is the content of the locality. 
The .rst role of the controller is to .lter incoming and outgoing messages. To this end, we introduce 
two special resource names i and r .dln(P) r .dln(Q) [R.L.Ctrl.To.Cont] a(P |rVx)[Q] .a(P)[Q |rVx] r 
.dln(P) r .dln(Q) [R.L.Cont.To.Ctrl] a(P)[Q |rVx] .a(P |rVx)[Q] Figure 8: Routing Rules (Local Messages) 
dln(PQ)= Ø dln(.n.P)= dln(P) \{n} dln(a(P)[Q]) = Ø dln((r1xV1 |...|rqxVq rP))= {r1,...,rq} dln(pass V)= 
Ø dln(P |Q)= dln(P) .dln(Q) dln(V)= Ø dln(([µ = V]P,Q)) = Ø dln(0)= Ø dln((P1,...,Pq)) = Ø Figure 9: 
De.ned local names o on which incoming and outgoing messages are intercepted (rules R.A.In and R.A.Out 
in .gure 6). On interception, an incoming or outgoing message is split into three parts: the destination 
address, the targeted resource, and the mes­sage arguments. The controller should provide a reaction 
rule for these .ltering channels, implementing the desired behavior. For instance, a locality that does 
not want to block any message could contain the process Fwd in its con­troller, where: def Fwd = (i(x,y,z) 
Cx.y z)|(o(x,y,z) Cx.y z) We remark that this de.nition is stateless and relies on the other routing 
rules to send the message to its .nal destina­tion automatically: even though the routing is step by 
step, it is not necessary to specify how to take each step. This is much di.erent from the Ambient calculus 
where an explicit path to the target ambient needs to be given. As localities form a tree, there is no 
notion of site as in Nomadic Pict (a site can be modeled by a locality at a given level in the tree) 
and the routing algorithm is part of our semantics. It is however possible to express di.erent routing 
algorithms by forwarding messages from locality to locality using some speci.ed resource. One example 
of this is the simulation of the dynamic Join calculus in the M-calculus in [19]. It is also possible 
to intercept and reroute messages using the control mechanism, as shown below. A message present in the 
controller is considered as hav­ing been controlled and may freely leave the controller (rules R.A.Ctrl.To.Cont 
and R.A.Ctrl.To.Env). A message that has reached its .nal destination becomes a local mes­sage (rules 
R.A.Ctrl.Final and R.A.Cont.Final). Local messages may move freely from controller to content and vice 
versa (.gure 8), depending on where the resource is de.ned. To this end, we call de.ned local names the 
set of resources that are de.ned in a given process without in­specting sublocalities. This set is formally 
de.ned in .gure 9. We give an example of transparent incoming message routing in .gure 10. One interesting 
feature when writing a reaction rule for the .ltering channels i and o is to be able to test the target 
locality or resource. To this end, we introduce a simple name matching operator ([µ = V ]P,Q), whose 
semantics (rules R.If.Then and R.If.Else in .gure 4) rely on a match() predicate, which is true only 
in the following cases: match( ,V ) match(n, n) a.rVx|b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv))[(r = ...)] 
 . b(i(d,r,v) rd.rv)|i(a,r, Vx)a((i(d,r,v) rd.rv))[(r = ...)] . b(i(d,r,v) rd.rv)|a.rVxa((i(d,r,v) 
rd.rv))[(r = ...)] . b(i(d,r,v) rd.rv)a.rVx|a((i(d,r,v) rd.rv))[(r = ...)]  . b(i(d,r,v) rd.rv)a((i(d,r,v) 
rd.rv)|i(a,r, Vx))[(r = ...)] . b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv)|a.rVx)[(r = ...)] . b(i(d,r,v) 
rd.rv)a((i(d,r,v) rd.rv)|rVx)[(r = ...)] . b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv))[(r = ...)|rVx] Figure 
10: Remote communication example For instance, a .lter for incoming messages could be: (i(d,r,v) C[a 
= d](b.r v,0)) This .lter throws away any message that is not for locality a, and reroutes messages for 
a to b. As in the Ambient calculus and the Join calculus, we pro­vide a way to modify the tree structure 
of localities. How­ever, we want to be able to control incoming and outgoing localities at every locality 
boundary, as is possible with re­mote communication. We thus unify migration and remote communication 
by considering migration as the communi­cation of a frozen process. A frozen process is of the form ..P, 
and may be unfrozen by applying it to the null value (). We actually consider a generalization by embedding 
a call by value .-calculus within our calculus (with the usual ß reduction rule R.Beta of .gure 4). We 
use standard no­tational conventions: in a term .x.P or .n.P,the scope extends as far to the right as 
possible; PQ1 ...Qn stands for (...(PQ1) ...Qn); .x1 ...xq.P stands for .x1.... .xq.P; .n1 ...nq .P stands 
for .n1.....nq.P. Wealso makeuse of the notation ..P to stand for a thunk .x.P,with x not free in P. 
The passivation primitive pass V ,where V is a function expecting a locality name and two frozen processes, 
is intro­duced to freeze running processes. Passivation is the second role of a controller: when evaluated 
in the controller of a lo­cality a(pass V |P)[Q], the locality is split into three parts: its name a, 
its frozen controller ..P,and itsfrozen content ..Q. These parts are given as arguments to the function 
V : a(pass V |P)[Q] .Va (..P)(..Q) For instance, a function V = .xpq.x(p())[q()] simply recre­ates the 
passivated locality. Locality mobility can be implemented using higher-order messages and passivation 
(cf the go construct in the Join calculus and ambients in and out capabilities). Locality Qm(a) below 
can be moved to a di.erent locality: Qm(a)= a(Fwd |(go uCGo(u)))[Q] Go(u)= pass .xpq.(u.enter ..x(p())[q()]) 
Arequest go b, results in the passivation of the locality a and its sending as a thunk to the resource 
enter of the lo­cality named b. If the request comes from the outside of the locality, the result is 
an objective form of move. If the request comes from the content of the locality, the result is a subjective 
form of move. The controller of locality b can contain the process Enter, depicted below, to de.ne the 
re­source enter used to insert and spawn a frozen process in its content: Enter = (enter fC pass .x p 
q.x(p())[q() |f()]) Passivation may also be used to implement various forms of control on a locality. 
Locality Qo(a)below can besus­pended, resumed, dissolved (cf the open capability of ambi­ents), and updated 
with a new controller (we note simply r a message of the form r() ): Qo(a)= .s on.L(a, s, on) Fwd |(suspend 
|on r S(s))L(a, s, on)= a |(resume |sf rR(f, on)) )[Q] |(open rO)|(update frU(f))|on S(s)= pass .x p 
q.x(p() |(sq))[0] R(f, on)= pass .x p q.x(p() |on)[f()] O = pass .x p q.q() U(f)= pass .x p q.x(f())[q()] 
 As usual, we take the reduction relation for the M-calculus, ., as the smallest relation that satis.es 
the rules given in Figures 4, 6, and 8. We present as an example an M-calculus variant of the taxi example 
presented by L. Cardelli in [3]. The basic idea is as follows: a passenger enters a taxi by specifying 
a route (list of localities to enter), a sitting behavior (to be executed while sitting in the taxi), 
and a continuation behavior (to be executed on arrival) L. Cardelli s version only comprises a route 
and a continuation behavior. A route consists of a list of locality names a1,...,an, which we represent 
by the frozen process ..route(a1, ..route(a2, M = ..., ..route(an,..route(nil,..0)) ...)) where nil is 
a special locality name reserved to signal the end of the list. A passenger requests entrance in the 
taxi named tx by emitting a message tx.enter(M, ..S, ..C) where S is the sitting behavior, and C is the 
continuation behavior. A taxi named tx is de.ned as follows: Taxi = .f.tx((Enter)|(Exit)|(Route)|f)[0] 
enter(r, s, c) |f C Enter = pass .x p q.x(p()|onexit(c)|r())[s()] exit |onexit(c) C Exit = pass .x p 
q.x(p()|f)[0] |q() |c() route(x, y) C Route = ( ( [nil = x] exit, pass .z pq. x.visit(..z(y() |p())[q()]) 
 ) )) t ::= type . process type | s value type s ::= value type unit unit type | a plain type variable 
| dom(w) name type | s1,...,sq tuple type | s .t function type |(s). plain resource + |(s)sendable resource 
. w ::= locality name variable a locality name | d name type variable |Ø no such locality . ::= locality 
name multiset Ø empty multiset | . multiset variable | d name type variable | a locality name | ., . 
multiset union s ::= .axx..s dxtype scheme Figure 11: Types: Syntax unfrozen, and the sitting behaviour 
is spawned in the con­tent of the taxi, using passivation. Since the route consists of a message containing 
a locality name and the rest of the route, the (Route)de.nition matches the locality name. If if it is 
nil, then the taxi has arrived, and the exit message is spawned. This message triggers the (Exit)de.nition, 
that consumes it as well as the reference cell onexit, recreates the taxiasfreetohire(spawning the lock 
f), and spawns the continuation as well as the content of the taxi outside. If the next destination is 
not nil, then the taxi migrates to this destination. We suppose every locality has a channel visit that 
simply spawns its argument. The frozen taxi is thus sent to the next stop, with the remaining of the 
route spawned in its controller.  3. THE TYPE SYSTEM The routing rules for addressed messages in Figure 
6 rely heavily on locality names and active localities. Locality namesthusplaythe role of addresses in 
the M-calculus. However, to faithfully mirror the situation in current wide area networks, and to allow 
for an e.ective implementation of the calculus, one must ensure the determinacy of the .nal destination 
of a remote message by ensuring that no two ac­tive localities may bear the same name. Unfortunately, 
it is not possible to obtain this property by syntactic means only. In fact, even a simple type system 
will not do because of the higher-order features of the calculus. In presence of the pas­ sivation operator, 
one must indeed be careful of the e.ects of functions on locality names. For instance, if a resource 
twice is de.ned as (twice fCf() | f()), then a passivation instruction of the form pass .x p q.(twice 
..x(p())[q()]) may Intuitively, each taxi contains a private lock (here the lead to the illicit duplication 
of the passivated cell. name f) indicating the taxi is free to hire. When a pas-To enforce the unicity 
of active locality names, we intro­senger enters the taxi, the lock is consumed, the frozen con-duce 
the following type system. The grammar for types tinuation is stored in the reference cell onexit, the 
route is is given in Figure 11. We remark that terms in the M­ . =. ' . . .. ' '' )i.[1..n] sx=sx. (si 
=s i '' unit =unit s .t =s .t ' . s =s and t =t ' '' dom(w) =dom(w) (s). =(s ).' . s =s and . =. ' '' 
a=a (s). =s .. ' . s =s and . =. ' ++ + '' (s)=(s)(s)=(s ).' . s =s and . =. ' .. . + '' (s)=s .. ' . 
s =s and . =. ' . Figure 12: Subtyping relation calculus are partitioned in two kinds: processes and 
expres­sions. This distinction is di.cult to manifest by relying only on the syntax, mainly because of 
functional applica­tion (the result of an application may either be an expres­sion or a process), but 
the intuition behind this partition is that processes may be put in parallel, and include mes­sages, 
localities, controller and content of localities, whereas expressions may reduce to values and include 
functions, tu­ples, and names. We formalize this partition by making a distinction among types t between 
process types .and value types s. Process types are multisets of locality names, representing an upper 
bound of the localities that may be or become active in the process. Value types represent the value 
the expression may eventually reduce to. They in­clude function types s . t , tuple types sX,the unit 
type, and types for names. Resource names have type (s). or (s)+ if they expect an argument of type s 
(which may be . a tuple) and if a message on this resource name leads to the creation of localities .. 
A resource name with the type (s)+ may be received and used for further input, as in the . creation of 
a reaction rule (create xC(x() Ca(0)[0])),where create may have the type ((unit)+ a )Ø. Locality names 
have type dom(w), where w may either be a locality name a,a name type variable d, or the empty set Ø. 
Intuitively, a lo­cality name a has singleton type dom(a), a variable x may have type dom(d), and no 
name may have type dom(Ø) (this last type is needed for technical reasons). Name type vari­ables d re.ect 
term variables x that may be instantiated to locality names, as in (create(x) Cx(0)[0]) where create 
may be given the type .d.(dom(d))d. Multisets . include locality names a, name type variables d, multiset 
variables ., the empty multiset Ø, and unions of multisets ., . ' . The basic intuition to guarantee 
the unicity of names of active localities in a process P is to type aprocess P with a multiset .. If 
this multiset happens to be a set, then we prove that every active locality bears a unique name. We use 
.aXX..s to denote a type scheme where plain type dXvariables aX, name type variable dXand multiset variables 
.Xare generalized. We use ß to range indi.erently over these di.erent type variables. In what follows, 
we consider an extended syntax for the M-calculus, where new resource names are required to be annotated 
by their type scheme, in order to specify whether the resource has a plain resource type (which may be 
poly­morphic) or if it has a sendable resource type (which cannot be polymorphic for safety reasons). 
The intersection operation between multisets, n,is the standard intersection on multisets (taking the 
smallest num­ber of occurrences in both multisets). The inclusion relation . between multisets is also 
the standard one. By . - . ' , a,. Ua,. ' = a,(. U. ' ) .,. U.,. ' = .,(. U. ' ) d,. Ud,. ' = d,(. U. 
' ) . U. ' =.,. ' if . n. ' = Ø unit Uunit = unit dom(w) Udom(w)= dom(w) aUa = a ''' ' (s1,...,sn) U(s1,...,s 
n)=(s1 Us1,...,sn Usn) '' s .t Us .t ' =(sns ) .(t Ut ' ) '' (s). U(s ).' = (sns ).u.' '' (s). Us .. 
' =(sns ) .(. U. ' ) ++ + (s)U(s)= (s) .. . + ' + '' (s)U(s )' = (sns ).u.' if s = s or .=. ' .. + '' 
(s)U(s ).' = (sns ).u.' . + '' (s)Us .. ' =(sns ) .(. U. ' ) . Figure 13: De.nition of U a,. na,. ' = 
a,(. n. ' ) .,. n.,. ' = .,(. n. ' ) d,. nd,. ' = d,(. n. ' ) . n. ' = Øif . n. ' = Ø unit nunit = unit 
dom(w) ndom(w)= dom(w) ana = a ''' ' (s1,...,sn) n(s1,...,s n)=(s1 ns1,...,sn nsn) '' s .t ns .t ' =(sUs 
) .(t nt ' ) '' (s). n(s ).' = (sUs ).n.' '' (s). ns .. ' = (sUs ).n.' + ' ++ ' (s)ns = (s)if (s)=s . 
.. Figure 14: De.nition of n we denote the multiset which is composed of the elements of . (locality 
names or multiset variables) after removing each element of . ' . For instance ., ., a, b, b - ., a, 
a, b = ., b. We de.ne in .gure 12 a subtyping relation = (where sXand sX' are tuples of the same size 
n). The intuition behind the subtyping relation is that it is safe (with regard to the unicity of locality 
names) to replace a process that includes more active localities with a process that includes fewer active 
localities. It is also safe to replace a function by a resource name if the types agree (a resource name 
may be used to send a message, by functional applica­tion, but it can also be used to create an addressed 
resource name). It is also safe to replace a plain resource name by a sendable resource name (sendable 
resource names may be used for message sending, but they can also be used to in­stantiate variables that 
are de.ned names of a Join pattern). We remark that sendable resource types have no subtype, except themselves. 
This is necessary for type safety since, unlike [25], we do not distinguish between input and output 
types. We de.ne the symmetric U and n operators on types in .g­ures 13 and 14 (other possible cases not 
listed are unde.ned). .1 U .2 is de.ned as the multiset where the multiplicity of each name a is taken 
to be the max of the multiplicities in .1 and .2,and .1 n .2 is de.ned as the multiset where the multiplicity 
of each name a is taken to be the min of the multiplicities in .1 and .2 (it is the usual intersection 
on multisets). We use G and its decorated variants to denote type en­vironments, i.e. .nite mappings 
between names and type schemes. We de.ne the set of free plain type variables ftv() fsv(Ø)= Ø fwv(Ø)= 
Ø fsv(.)= {.} fwv(.)= Ø fsv(d)= Ø fwv(d)= {d} fsv(a)= Ø fwv(a)= Ø fsv(.,. ' )= fsv(.) .fsv(. ' ) fwv(.,. 
' )= fwv(.) .fwv(. ' ) Figure 15: De.nition of fsv() and fwv() C ::= ·: t |.r : s.C |.a.C |.x.C |a(C)[Q] 
| a(P)[C] |(C |P) |(P |C) |pass C |(CQ) | (PC) |([µ = C]P,Q) |([µ = V ]C,P) | ([µ = V ]P,C) |(JrC)|(P1,...,C,...,Pq) 
Figure 16: Typed Contexts as usual. We de.ne the set of free multiset variables fsv() and the set of 
free name type variables fwv() in .gure 15. We letthe setof freevariables fv() be the union of ftv(), 
fsv(), and fwv(). Type judgments take the following form, where C is an M-context extended with a typed 
hole, as de.ned in Figure 16: G . C : t and G . P : t . We write fun(s; t ) for the types of all values 
that may be used as functions, that is for either s . t , (s)t ,or (s)+ t (in the latter two cases, t 
is necessarily a process type .). We write chan(s; .) for channel types (either (s). or (s)+ ). . In 
order to correctly type the i and o resources, we consider only type environments with the following 
associations: i : .ad..(dom(d), (a).,a). o : .ad..(dom(d), (a).,a).  Both the i and o resources expect 
a locality name (the des­tination of the message), the targeted resource expecting an argument of type 
a and creating localities ., and an argu­ment of type a. A message on such a channel potentially creates 
localities .. The type system is de.ned by the rules in Figure 17. They make use of the Inst operator, 
that takes a type scheme and returns a type where the generalized plain type variables, multiset variables, 
and name type variables have been in­stantiated to types, multisets, and locality names or name type 
variables respectively. Typing rule Join may seem complex but is the usual typ­ing rule for Join patterns: 
the guarded process is typed in an environment extended with the formal parameters, and the result is 
checked to create fewer localities than advertised by the resource types. Every de.ned resource name 
that is a variable is checked to have a sendable resource type in the environment. The additional hypotheses 
check that the type schemes associated with the resources are consistent with the typing environment, 
following the usual rules of the Distributed Join calculus: no generalized variable may occur free in 
the environment nor be shared by two resources in aJoinpattern. Inrule Pass, the passivation function 
is checked to have a type that is a subtype of a function ex­pecting a locality name and two thunks. 
The name type variable d in the locality name type represents the name of the passivated cell. Each thunk 
type includes a multiset vari­able .1 or .2 representing the active localities of the thunk. These three 
variables are intuitively generalized by check­ing that they do no occur in the typing environment (they 
will respectively be substituted by the name of the passi­vated locality and by the active localities 
of the controller and content, that are unknown when typing the primitive). The type of the whole passivation 
construct is simply the type of the result of the passivation function, removing the name of the passivated 
locality and the multiset variables since the locality is passivated. The soundness of the our type system 
is characterized by the following de.nitions and theorems. De.nition 1. A typing environment G is well-formed 
if and only if: ß.(s)., 1. G only contains associations of the form r : .X r : (s)+,and a : dom(a); . 
2. we have fn(G) = dom(G). Lemma 3.1. Let G . P : t be a typing derivation with G well-formed. If P = 
P ' , then there exists a typing derivation G . P ' : t . Theorem 1 (Subject reduction). Let G . P : 
t be a typing derivation with G well-formed. If P . P ' ,then '' '' there exists a type t such that t 
= t and G . P : t . De.nition 2. A locality a(P ' )[Q ' ]issaid tobe free and active in P if it is active 
in P and if it is not under a scope restriction for a. Aprocess P has failed if and only if there is 
some pro­cess P ' active in P containing at least two free and active localities bearing the same name. 
Theorem 2 (Progress). Let G . P :. be a typing derivation with G well-formed. If . is a set, then the 
process P has not failed. Most of the complexity of the subject reduction proof is alleviated by distinguishing 
name variables x from name type variables d, greatly simplifying the substitution lemma. Complete proofs 
are available in the draft of the long version of this paper [18]. Our notion of progress deals only 
with the unicity of active locality names. Since our type system is very close to type systems for the 
.-calculus and the Distributed Join calculus, this progress property can be easily extended to more usual 
guarantees. We now discuss the power and limits of our type system. Linearity. Since our type system 
aims at enforcing the lin­earity of names of active localities, we describe how this feature interacts 
with functions (or resources) that are not linear. First of all, our system guarantees the linearity 
of names of localities that are active (as described in theo­rem 2). Relaxing the linearity constraint 
for localities that are not active yields a much simpler type system (e.g. our system allows the typing 
of ..a(0)[0] | a(0)[0]as longas this function is not applied). We also require linearity of a newly introduced 
locality name in the process under the scope restriction (rule Nu.Dom, since the introduced name should 
not occur in the type). We recall that the type of a process is a conservative approximation of the active 
lo­calities it may contain. In the following, we only consider processes that are active. xx u : .ß.s 
.G s. = Inst(.ß.s) fn(ran(.)) .dom(G) [Name][Nil][Void] G fu : s. G f0 : ØG f() : unit G fa : dom(w)G 
fr : chan(s;.) [Proc.Hole][Addr] G f( ·: t): t G fa.r : s .. Pi : si)i.[1..q] G+ x : s fP : tx .dom(G) 
fn(s) .dom(G) (G f [Fun][Tuple] G f.x.P : s .t G fP1,...,Pq :(s1,...,sq ) G fa : dom(w)G fP :.1 G fQ 
:.2 G fP :.1 G fQ :.2 [Dom][Par] G fa(P)[Q]: w,.1,.2 G fP |Q :.1,.2 xxx G+ r : .ß.(s). fP :.1 r .dom(G) 
fv(.ß.(s).)= Ø fn(.ß.(s).) .dom(G) [Nu.Res.1] x G f.r : .ß.(s)..P :.1 + ++ G+ r : (s)fP :.1 r .dom(G) 
fv((s))= Ø fn((s)) .dom(G) . ..[Nu.Res.2] + G f.r : (s).P :.1 . G+ a : dom(a) fP :. a .fn(G) a .(. -a) 
[Nu.Dom] G f.a.P :. -a G fV : dom(d) .(unit ..1) .fun(unit ..2;.) .1 = .2 .1 ..1 .2 ..2 d, .1,.2 .fv(G) 
.(. -(d, .1,.2)) [Pass] G fpass V :. -(d, .1,.2) G fP : fun(s; t) s ' =s G fQ : s ' G fV : t G fP : 
t1 G fQ : t2 [App][Test] G fPQ : t G f([µ = V ]P,Q): t1 Ut2 (ri is not a variable and ri : si = .ßxi.(sxi).G, 
or ri : si = (sxi)+ .G)i.[1..n] . ' =.1,...,.n (x i)i ndom(G) = Ø .i .i G+ xV1 : sV1 + ... + xVn : sVn 
fP :. ' .i .[1..n].ßxi nfv(G) = Ø.i,j .[1..n]2.i = j =.ßxi nßVj = Ø [Join] G f(r1xV1 |... |rnxVn rP): 
Ø Figure 17: Typing rules Consider for instance the function .x.x() |x(). This func­tion takes a frozen 
process and runs it twice. It is perfectly reasonable to apply it to a frozen process that does not re­lease 
localities with free names, as in: (.x.x() |x())..0 or (.x.x() |x())...a.a(0)[0]. In these cases, the 
function has type (unit .Ø) .Ø. The type system would reject apply­ing this function to the thunk ..a(0)[0]. 
A function .x.x(), that only runs a process, can be given the type (unit . .) . .. Since functions never 
have polymorphic types, one can instead consider a resource run de.ned as (run(x) Cx()). Such a resource 
can be given the type ...(unit ..).: it simply recreates the active localities frozen in its argument. 
The check that these localities do not interfere with currently active localities is done when typing 
a message on run. We remark that our use of multiset variables is very similar to row variables described 
in [16]. Subtyping. Subtyping is explicitly used in typing rule App. Returning to the example of the 
run resource above, this resource can receive a frozen process as argument, as in (run ..a.(0)[0]). It 
can also receive a resource name, as in (run createa)with (createa() Ca(0)[0]),since (unit)a is a sub­type 
of unit .a. The subtyping used in typing rule Join gives some .ex­ibility when de.ning a resource, since 
the type of the re­source gives an upper bound on the localities that may be created. For instance, the 
special channel i has type .ad..(dom(d), (a).,a).. Typical de.nitions for this channel are (i(d, r, args) 
Cd.r args), which simply sends the message, and (i(d, r, args) C 0), which discards it. The typing of 
the second de.nition relies on the fact that this de.nition of i does not create all the localities it 
is allowed to. Dependent Types and Polymorphism. Our type system does not allow dependent types, but 
simulates them us­ing polymorphism and name type variables (type variables that represent locality names), 
since locality names may oc­cur in types. For instance the resource new in the de.ni­tion (new(x) Cx(0)[0])may 
begiven thepolymorphictype .d.(dom(d))d: it expects any locality name and creates a lo­cality with this 
name. We remark that our solution is less powerful than dependent types, since it does not allow the 
typing of (.f.f a | fb)(.x.x(0)[0]). However, polymor­phism is powerful enough to let us type de.nitions 
of the form: (create(x, p, q) Cx(p())[q()]),where create is given the type .d.1.2.(dom(d), unit ..1, 
unit ..2)d,.1,.2 . Passivation. One limitation of our type system comes from the passivation operator. 
Consider for instance the pro­cess: a (pass .xpq.x(0)[b(0)[0]]) [b(0)[0]]. The pass oper­ator freezes 
locality a and respawns it, discarding its con­troller and content, but adds a locality b in its content. 
Since the locality b that is added is .rst discarded, one would ex­pect this process to be well typed. 
This is not the case because locality b is active, and may be sent somewhere else (see for instance the 
migration example in section 2). This is why the process pass .xpq.x(0)[b(0)[0]] has type b:this process 
creates an active locality b, independently of the con­troller and content that are passivated. On the 
other hand, the process pass .xpq.x(p())[q()] has type Ø (it only recre­ates a locality that has been 
passivated) and the following process is well typed: a(pass .xpq.x(p())[q()]) [b(0)[0]]. Example. As 
a small example, we remark that the taxi example we describe at the end of section 2 is well typed with 
the following bindings: enter : ..S,.C .(unit .Ø,unit . .S,unit . .C ).S,.C exit : (unit)Ø onexit : ..C 
.(unit . .C ).C route : .d.(dom(d),unit .Ø)Ø visit : ...(unit . .).  4. SIMULATING THE JOIN CALCULUS 
In this section, we show that we can simulate the Dis­tributed Join calculus in a straightforward manner, 
thus re­taining all its expressivity. However, we .rst check that the M-Calculus addresses the limitation 
of the Distributed Join calculus described in the introduction. The lack of control over communication 
and mobility is directly addressed by the possibility to program controllers for each locality to .lter 
incoming and outgoing messages. These controllers are normal M-Calculus processes, they can be arbitrarily 
complex. Dynamic binding, or more precisely locality based bind­ing, is provided by addressed messages, 
which explicitly in­clude the name of the locality hosting the targeted resource, and by the possibility 
to de.ne resources at several locali­ties. A simulation of the Dynamic Join calculus [20] in the M-Calculus 
presented in [19] illustrates how to use addressed messages to get transparent locality based binding. 
Finally, programmable controllers and the passivation op­erator let the programmer de.ne localities with 
di.erent se­mantics within the same program. Since the M-calculus is a direct o.spring of the Distributed 
Join calculus, a translation of a Distributed Join calculus process into an M-calculus process is relatively 
straightfor­ward. Such a translation is interesting to present, however, because it illustrates the versatility 
of programmable local­ities. In the following, we only consider Join processes with no free names. We 
proceed in three steps, in order to account for the fact that resource names are introduced with their 
types in the M-calculus, and that message routing requires the messages to be annotated with address 
information. The .rst step consists in typing the Distributed Join cal­culus process, and annotating 
every local Join calculus de.­nition with the channel names (as well as their type schemes) and location 
names it de.nes. We write def (D; n1 : s1,nq : sq,a1,...,ar) in ...the result of the .rst translation 
step of def D in P if dn(D)= {n1,...,nq }.{a1,...,ar} and if the channel names ni have type schemes si 
after generalization. By de.nition of the types of the Distributed Join calculus, the si are of the form 
.Xt). a.(XWe suppose that these type schemes have no free type variables, and we transform them immediately 
in M-calculus type schemes, writing ()Ø instead of (). The second translation step consists in annotating 
every channel name that is not a variable with the locality where its de.nitions reside. To do this, 
we rely on the fact that in the Distributed Join calculus, the only locality in which a de.nition may 
eventually be dissolved is the syntactically enclosing locality. This property is a direct consequence 
of the de.nition of migration: the only way to have processes migrate in the Distributed Join calculus 
is by locality migra­tion. Thus de.nitions cannot be separated from the locality where they syntactically 
occur. For reasons of space, we do not formally present the algorithm used in this second step, which 
is roughly of the following form: for every channel name that is not in a Join pattern, .nd the enclosing 
def binder for this name, then .nd the name of the syntacti­cally enclosing locality, and prepend the 
locality name to the channel name. The third step is the translation to the M-calculus itself. We represent 
a location of the Distributed Join calculus a[ ·] by a locality a(PJ )[ ·]with: PJ = Fwd |(add frAdd( 
f) )|(go ( b,.) rSend( b,.) ) Add( f)= pass .xpq.x( p())[ q() |f()] Send( b,.)= pass .xpq.( b.add ..x( 
p())[ q() |.()]) We type the resource add with the type ...(unit . .). that expects a thunk and frees 
it, and the resource go with the type .d..(dom(d),unit . .)., that takes a locality name and a frozen 
continuation that it will eventually spawn. Writing [ · ] for the translation operator, we have: [[ b.n]] 
= b.n [[ b]] = b [[ x]] = x [[ 0]] = 0 [[ P |Q]]= [ P]] |[[ Q]] [[ .]] = 0 [[ go b; P]] = go( b,..[[ 
P]]) [ D,D ' ]]= [ D]] |[[ D ' ]] [[ b[ D : P]]] = b( PJ )[[ D]] |[[ P]]] [[ m(n1,...,nq)]]= [ m]]([ 
n1]] ,...,[[ nq]]) [[ n1(xV1)|...|nq(xVq )rP]] = (n1(xV1)|...|nq(xVq )r[[ P]] ) [[ def ( D; n1 : s1,...,nq 
: sq,a1,...,ar ) in P]] = .n1 : s1,...,nq : sq..a1,...,ar .[[ D]] |[[ P]] Note that our translation is 
not entirely faithful with re­spect to migration, since in the Distributed Join calculus migration does 
not occur if the target locality is a sublocal­ity of the moving one. In order to detect these cases, 
we would need a more complex translation. We now extend the previous translation to the Distributed Join 
calculus with failures. To do this, we only need to change the translation of a locality, replacing the 
PJ con­troller by the following PJF (a) controller: PJF = Fwd |(add frAdd( f) ) |(go ( b,.) rSend( b,.) 
) |(halt rHalt) |(ping ( y,n) ry() ) Add( f)= pass .xpq.x( p())[ q() |f()] Send( b,.)= pass .xpq.( b.add 
..x( p())[ q() |.()]) (ping ( y,n) rn() )  Halt = pass .xpq.x(|(add frAdd( f) ) ) [ q()] |(i ( d,m,v) 
rP( m,v) ) |(o ( d,m,v)= 0) P( m,v)= ([ ping = m] mv,([ add = m] mv,0)) Thus, when a locality has failed, 
it prevents all outgoing messages from leaving the failed locality: no sublocality may send a message 
outside. Similarly, with respect to incoming messages, a failed locality only accepts messages sent on 
ping or on add for itself or its sublocalities. Messages on ping are emitted locally, and will be subsequently 
reduced by the new de.nition for ping, that will answer saying the sublocality has failed. Messages on 
add will add the migrating location to the current locality, thereby cutting it from the rest of the 
world. We remark that the sublocalities of the failing one are still active, but they cannot communicate 
with the outside world. This translation strongly relies on the interception of routed messages by controller 
processes.  5. RELATED WORK Several distributed process calculi have been proposed in the recent years, 
but they all have shortcomings as dis­tributed programming models: Ambient calculi, such as the original 
Mobile Ambients [4] and the subsequent variants (Safe Ambients [10], Safe Ambients with Passwords [13], 
Boxed Ambients [2], Controlled Ambients [22]), provide a simple model of hierarchical localities with 
.ne-grained control over locality moves and communications, but their basic mobility primitives (the 
in and out capabilities) re­quire a 3-party atomic handshake which makes them costly to implement in 
a distributed setting as illus­trated by the implementation of Mobile Ambients in the Distributed Join 
calculus [8].1  Higher-order process calculi such as as Facile/CHOCS and Dp. [25] model process mobility 
via higher-order communication and remote process execution, but lack an explicit notion of locality 
to account for potential failures or to provide a basis for access control. Fur­thermore, they do not 
allow for a running process to be migrated to a di.erent locality, unless the process has been explicitly 
de.ned to allow for such a migration.  Variants of the .rst-order asynchronous p-calculus with explicit 
localities such as the Distributed Join calcu­lus [6, 11], Nomadic Pict [24], DiTyCo [12], or the p1l-calculus 
[1], feature process migration primitives (go in the Distributed Join calculus, spawn in the p1l ­calculus, 
migrate in Nomadic Pict) but lack su.cient control over resource access and process migration.  Compared 
to these works, the M-calculus has several dis­tinguishing features. Its notion of programmable locality 
allows the de.nition of di.erent forms of locality within the same calculus. In contrast, the calculi 
above, or even calculi such as Klaim [14, 15] (that uses generative communication as its basic form of 
communication), or ATF [5] (that considers distributed 2­phase transactions as processes), consider only 
a single form of locality. 1Recent work on a distributed abstract machine for Safe Ambients [17], just 
reinforces this point. The distributed implementation of ambients proposed there does away with the problem 
by implementing the in and out capabilities lo­cally (by using cocapabilities and single-threadedness), 
and interpreting the open capability as a move to the implicit location of the parent ambient. In this 
interpretation, am­bients no longer characterize the physical distribution of a computation, which defeats 
the original intent of the cal­culus. Furthermore, work on Boxed Ambients successfully argues against 
the open capability. In distributed calculi, many alternatives exist when it comes to combine communication 
and localities. At one extreme lies the fully transparent communication of the Dis­tributed Join calculus, 
where messages are routed directly to the target locality. At the other extreme lies Mobile Am­bients, 
where communication is purely local to an ambient and remote communication must use migration primitives 
and explicitly encoded routes to deliver an ambient mes­sage. The Seal calculus [23] and Boxed Ambients 
lie be­tween these two extremes by providing the ability to com­municate across one locality boundary. 
In the M-calculus, we still provide transparent routing but allow messages to be intercepted each time 
they cross a locality boundary. Finally, one may remark that there are striking similarities between 
controlling migration on one hand, and controlling communication on the other hand. For this reason, 
we take the further step to merge the two aspects, by considering a higher-order calculus. In our setting, 
migration becomes communication of a thunk or passivated process. With respect to the type system, Yoshida 
and Hennessy s work on Dp., a higher-order distributed process calculus [26], is closest to our own. 
Dp. allows the communication of processes as thunks. In this regard, it is similar to the M­calculus. 
There are however several important di.erences that we now detail. The two calculi take a di.erent ap­proach 
to the determinacy of communication. As in the Join calculus, the Dp. calculus adopts a channel local­ity 
invariant, which ensures a channel or resource is only present in one locality. In the M-calculus, resources 
of the same name can be present in di.erent localities in order to allow for dynamic binding. The M-calculus 
therefore relies on addressed resources, where a resource name is annotated with a locality name, to 
ensure the determinacy of message routing. The unicity of locality names invariant in the M-calculus 
is more complex to ensure than the channel lo­cality invariant in the Dp. calculus. This is due to the 
passivation operator in the M-calculus. This operator has no counterpart in the Dp. calculus, where the 
only way to obtain a thunk (frozen process) is by either specifying it, or by receiving it. The ability 
to passivate an active process, as in the M-calculus, is powerful but it makes the type system more complex, 
as the type of the passivation operator de­pends on some type information of the passivated process. 
Asin theDp. calculus, a process in the M-calculus has a type that gives information on its behavior (its 
interface for the Dp., its active localities for the M-calculus). More precisely, the type of a term 
is a conservative approxima­tion of the value or process it may become. Thus locality errors in Dp. and 
multiple locality de.nitions in the M­calculus only lead to type errors if the faulty process may eventually 
become active. Both systems also have a form of dependent types, but they are dealt with di.erently. 
In the Dp.-calculus, name variables can occur in types and can be bound in types, yielding dependent 
types. In the M-calculus, the dependency between input and output of a resource (channel) is represented 
as a type variable (which may stand for a locality name) that is generalized. Accord­ing to the type 
of the argument, the type variables of the type scheme of a resource are instantiated to the correct 
values, and the type of a message is thus dependent on the type of the argument. In order to simplify 
the type sys­tem of the M-calculus, we allow cell names in the types but not name variables. We use instead 
name type vari­ables, which provide us with a cleaner distinction between types and names. The advantage 
of dependent types ap­pears when considering partial application: if the result of an application is 
a function that has a dependent type, this function may still be applied to several frozen processes 
hav­ing di.erent types, which is impossible when relying on .rst order polymorphism. However, previous 
work on the typing of the Join calculus and our experience with programming in JoCaml showed us that 
.rst order polymorphism is useful, well-understood, and powerful enough when using Join pat­terns. Finally, 
both the Dp. calculus and the M-calculus al­low input on channels that were received previously, but 
the Dp. uses .ner input-output types for channels that could be adapted to our setting. 6. CONCLUSION 
AND FUTURE WORK We have presented in this paper the M-calculus, a higher­order distributed process calculus, 
and an associated type system that statically enforces the unicity of locality names, a crucial invariant 
for the determinacy of .nal destination for remote messages. The M-calculus constitutes a non­trivial 
and powerful extension of the Join calculus [6, 11] with call-by-value higher-order functions, programmable 
lo­calities, and dynamic binding. The possibility to de.ne, within the same calculus, di.er­ent kinds 
of localities, with non-trivial behavior, is an im­portant requirement for a realistic foundation of 
distributed mobile programming. While the M-calculus still falls short of meeting key requirements for 
advanced distributed pro­gramming (e.g. support for transactional behavior), we be­lieve it constitutes 
an important step. To validate the implementable character of the M-calculus, we have de.ned and implemented 
a distributed abstract ma­chine for it [9], and, in order to prove the correctness of our abstract machine, 
we are working on an annotated lower­level calculus that makes the routing and passivation reduc­tion 
rules more local. In parallel, we are de.ning notions of observables in order to compare, using operational 
equiva­lences, the annotated calculus to the original calculus, and to study the correctness of the translations 
from distributed calculi to the M-calculus. 7. REFERENCES [1] R. Amadio. An asynchronous model of locality, 
failure, and process mobility. Technical report, INRIA Research Report RR-3109, INRIA Sophia-Antipolis, 
France, 1997. [2] M. Bugliesi, G. Castagna, and S. Crafa. Boxed ambients. In 4th International Symposium 
on Theoretical Aspects of Computer Software (TACS), 2001. [3] L. Cardelli. Types for mobile ambients. 
In Proceedings 26th Annual ACM Symposium on Principles of Programming Languages (POPL), 1999. [4] L. 
Cardelli and A. Gordon. Mobile ambients. In Foundations of Software Science and Computational Structures, 
M. Nivat (Ed.), Lecture Notes in Computer Science, Vol. 1378. Springer Verlag, 1998. [5] D. Duggan. Atomic 
failure in wide-area computation. In Proceedings 4th IFIP International Conference on Formal Methods 
for Open Object-Based Distributed Systems (FMOODS),S.Smith andC.Talcott eds. Kluwer, 2000. [6] C. Fournet. 
The Join-Calculus.PhD thesis,Ecole Polytechnique, 1998. [7] C. Fournet, G. Gonthier, J.J. Levy, L. Maranget, 
and D. Remy. A calculus of mobile agents. In In Proceedings 7th International Conference on Concurrency 
Theory (CONCUR 96), Lecture Notes in Computer Science 1119. Springer Verlag, 1996. [8] C.Fournet,J.J. 
Levy, andA.Schmitt. An asynchronous distributed implementation of mobile ambients. In Proceedings of 
the International IFIP Conference TCS 2000, Sendai, Japan, Lecture Notes in Computer Science 1872. Springer, 
2000. [9] F. Germain, M. Lacoste, and J.B. Stefani. An abstract machine for a higher-order distributed 
process calculus. In Proceedings of the EACTS Workshop on Foundations of Wide Area Network Computing 
(F-WAN), July 2002. [10] F. Levi and D. Sangiorgi. Controlling interference in ambients. In Proceedings 
27th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 2000), 2000. [11] 
J.J. Levy. Some results on the join-calculus. In 3rd International Symposium on Theoretical spects of 
Computer Software (TACS), Lecture Notes in Computer Science no 1281. Springer, 1997. [12] L. Lopes, F. 
Silva, A. Figueira, and V. Vasconcelos. DiTyCO: An Experiment in Code Mobility from the Realm of Process 
Calculi. In Proceedings 5th Mobile Object Systems Workshop (MOS 99), 1999. [13] M. Merro and M. Hennessy. 
Bisimulation congruences in safe ambients. In 29th ACM Symposium on Principles of Programming Languages 
(POPL), Portland, Oregon, 16-18 January, 2002. [14] R. De Nicola, G.L. Ferrari, and R. Pugliese. Klaim: 
a Kernel Language for Agents Interaction and Mobility. IEEE Trans. on Software Engineering, Vol. 24, 
no 5, 1998. [15] R. De Nicola, G.L. Ferrari, R. Pugliese, and B. Venneri. Types for Access Control. 
Theoretical Computer Science, Vol. 240, no 1, 2000.  [16] Didier R´emy. Type inference for records in 
a natural extension of ML. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects Of Object-Oriented 
Programming. Types, Semantics and Language Design. MIT Press, 1993. [17] D. Sangiorgi and A. Valente. 
A Distributed Abstract Machine for Safe Ambients. In Proceedings of the 28th International Colloquium 
on Automata, Languages and Programming, volume 2076 of Lect. Notes in Comp. Sci. Springer-Verlag, 2001. 
[18] A. Schmitt and J.B. Stefani. The M-calculus: A Higher Order Distributed Process Calculus. Draft 
of the long version, available at http://pauillac. inria.fr/~aschmitt/publications.html, 2002. [19] Alan 
Schmitt. Conception et Implmentation de Calculs d Agents Mobiles. PhD thesis, Ecole Polytechnique, 2002. 
[20] Alan Schmitt. Safe Dynamic Binding in the Join Calculus. In IFIP TCS 02, Montreal, Canada, 2002. 
[21] Peter Sewell and Jan Vitek. Secure composition of untrusted code: Box-p, wrappers and causality 
types. Journal of Computer Security, 2000. Invited submission for a CSFW00 special issue. To appear. 
[22] D. Teller, P. Zimmer, and D. Hirschko.. Using Ambients to Control Resources. In Proceedings CONCUR 
02, 2002. [23] J. Vitek and G. Castagna. Towards a calculus of secure mobile computations. In Proceedings 
Workshop on Internet Programming Languages, Chicago, Illinois, USA, 1998. [24] P. Wojciechowski and P. 
Sewell. Nomadic Pict: Language and Infrastructure. IEEE Concurrency, vol. 8, no 2, 2000. [25] N. Yoshida 
and M. Hennessy. Subtyping and locality in distributed higher-order processes. In Proceedings CONCUR 
99, Lecture Notes in Computer Science no 1664. Springer, 1999. [26] N. Yoshida and M. Hennessy. Assigning 
types to processes. In 15th Annual IEEE Symposium on Logic in Computer Science (LICS), 2000.  
			
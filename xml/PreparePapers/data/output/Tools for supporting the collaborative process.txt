
 Tools for Supporting the Collaborative Process James R. Rhyne, Catherine G. Wolf IBM Thomas J. Watson 
Research Center Yorktown Heights, NY 10598 jrhyne@watson.ibm.com Abstract Collaborative software has 
been divided into two temporal categories: synchronous and asynchronous. We argue that this binary distinction 
is unnecessary and harmful, and present a model for collaboration processes (i.e. the tem­poral record 
of the actions of the group members) which includes both synchronous and asynchronous software as submodels. 
We outline an object-oriented toolkit which implements the model, and present an application of its use 
in a pen-based conferencing tool. Introduction Contemporary toolkits for developing collaborative ap­plications 
tend to support either a fully synchronous form of collaboration, or a fully asynchronous form. The laclk 
of asynchronous capability in a fully synchronous application manifests itself in an inability for a 
person to join a collabo­ration in process and to get up to speed by reviewing the events which happened 
before he or she joined. This prob­lem has been especially noted in distributed architectures. On the 
other hand, not being able to switch from an asynchronous mode to a synchronous mode is restrictive. 
Someone who is editing a memo may want to ask another colleague to join in a synchronous editing session 
Fhxdly, synchronous and asynchronous applications tend to view their data different y: when you call 
up someone to dis{;uss a piece of email, you cannot take the conversation you have with them and turn 
it into email for archiving along with the email you were discussing. Permission to copy without fee 
all or part of this material is granted provided that the copies are not made or distributed for direot 
commercial advantage, the ACM copyright notice and the title of the publication and its dete appear, 
and notice is given that copying is by permission of the Association for Cornputi g Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. 01992 ACM O-89791-550-X192/001 
1/0161 . ..$1.50 The earliest collaborative applications were handcrafted. Over time, developers were 
able to extract software for suppotiing collaborative aspects (e.g. floor-control) into separate toolkits, 
The initial focus on toolkits was di­rected toward the question of a central vs. distributed ar­chitecture 
[Lantz86, Ahuja90, Lauwers90], and the question of converting existing applications for use by groups 
without having to rewrite the application [Gust88, Ahuja88, Patter90b, Knist90]. More recently, examples 
of toolkits for development of collaborative applications have been described [Dewan 91, Crowley90, Patter90]. 
Beyond the common require­ments of supporting geographically separated users syn­chronously, maintaining 
consistent state for each user, and mediating control of the floor, these toolkits are dktin­guished 
in various ways. The Rendezvous system [Pat­ter90a,Patter91] employs constraints to insure consistency, 
mechanisms for maintaining distinct views of a common body of data. The MMConf [Crowley90] tool­kit uses 
token passing to control the floor and insure a consistent view of events. Suite [Dewan91 ] models com­mon 
vs. private data and attributes and provides a UIMS­based specificational model for collaborative applications. 
Collaborative applications have been characterized in oth­er ways [Ellis91 ], e.g. as supporting spatially 
distributed collaboration, and as supporting temporally distributed collaboration [Bullen88]. Toolkit 
development has fo­cused mainly on spatial distribution, despite studies such as [Reder90], which clearly 
show that the workday of an individual is broken into many small fragments of syn­chronous and asynchronous 
collaboration. Social psychol­ogists have recognized the importance of time in the functioning of groups, 
see e.g. [McGrath90]. The toolkit described in this report is designed to support both syn-chronous and 
asynchronous collaboration, and offer a smooth transition between modes. Temporal Collaboration Support 
Asynchronous collaboration is characterized by individual or subgroup activity resulting in a permanent 
record that may be reviewed and commented on by others. Electronic mail, bulletin board, and forum systems 
all suppofi this work paradigm. Synchronous collaboration, on the other hand, typically allows the participants 
to see fine grained actions of other participants (e.g. pointing or typing text) in approximate realtime. 
Synchronous and asynchronous collaborations differ in several respects: the grain size of action, how 
a participant comes to see the most recent actions, the time frame in which actions become available 
to other participants, and whether actions are reviewable. The action grain size in synchronous collaboration 
tends to be small, the availability time frame short, and the re­sults of the actions are displayed for 
the user. Actions are not usually reviewable. In asynchronous collaborations, the grain size is larger, 
the availability time frame is long­er, and the participant must request to see the recent ac­tions. 
Actions may be usually reviewable as they are kept in a log, e.g. email systems support an action which 
is the composition and distribution of text messages. The consequences for the participants are dramatic 
in terms of the rapidity of exchange of ideas. Whether or not the collaboration makes rapid progress 
depends on the speed with which misunderstandings can be resolved, and issues explored, and this will 
be accelerated in synchro­nous collaboration. On the other hand, participants who have come late to the 
collaboration and who have not par­ticipated in the process, will find it difficult to resolve their 
own misunderstandings and to raise issues if all they have access to are the results of the collaboration. 
About two years ago, we began building a pen based, meeting support tool that we named WeMet, In addition 
to applications of pen-based user interfaces to meeting sup­port, we were also interested in the uses 
which might be made of a realtime meeting record, e.g. for meeting re­view, extraction of design rationale, 
and accommodation of asynchronous users. The process of building the WeMet application focused our attention 
on the synchronous/ asynchronous discontinuity, and led to the development of a toolkit. The WeMet toolkit 
bridges the synchronous/asynchronous modes by providing both fine grained, immediate, dis­played actions 
and by providing a history of the actions. With the history, one can reconstruct the present and one 
can review in approximate realtime the events which led up to the present, The toolkit supports the immediate 
syn­chronous collaboration by broadcasting actions to all ac­tive participants. It also supports asynchronous 
collaboration by allowing participants to work separately, then bring their work into the main group, 
either by going instantly to the end of their separate history, or by replay­ing selected stages or the 
entire process of their work. The toolkit supports a review mode, in which participants may review the 
histories of other participants, picking and choosing stages for replay.  Conceptual Software Architecture 
Modern, interactive applications are divided (roughly) into an application part and a viewer part. The 
viewer part han­dles presentation and direct interaction with the user. The WeMet approach adds a history 
part, alters the viewer part to support multiple participants (the collaboration part), and requires 
an undo/redo capability in the application. The top level of this architecture is shown below in Figure 
1. Figure 1. Conceptual Architecture The activity flow in this diagram begins with a user action at a 
viewer. Selected actions enter the toolkit represented as event objects. A timestamp and user identification 
are added to the event object by the viewer. The viewer also declares the set of viewers affected by 
this transaction (e.g. a popup menu maybe local to the originating viewer, while a change in the point 
of view will affect the other viewers in the set). The event is passed through the group­viewer to the 
history cursor, which appends it to the end of the current history and then instructs the application 
to do the event by moving forward in the history. The application will produce its visual effect by 
notifying the group-viewer of changes to be made in the presenta­tions. Depending on the affected viewer 
set of the causilng transaction, the group-viewer will update the appropriate viewers. The history component 
provides an undo/redo capabili~y, but one that is quite different from that normally imple­mented in 
applications [Vliss90, Vitter84]. All events in the history are timestamped to permit realtime replay. 
The history supports a branching, lossless model, unlike the single thread of history typically found 
in undo/redo im­plementations. It also supports multiple users, using multi­ple views of multiple applications. 
 The WeMet Application The WeMet application is a pen based meeting support tool that provides its users 
with a collection of shared, electronic writing pads. The user interface hardware con­sists of an integrated 
LCD and pen digitizer driven by a modified X server[Rhyne91 ]. The pen may function as a mouse, or it 
may create electronic ink traces called strokes, depending on how the application wishes to re­ceive 
input. In collaborative use, any stroke created by a user is seen virtually instantly by the other participants. 
1 WeMet provides an electronic record of the marks made by participants, in the form of a set of histories 
supported by the toolkit. This record is useful to anyone who wishes to review the meeting, which maybe 
seen linearly, or one may select various viewpoints to skip around in the meet­ing record. WeMet speeds 
the pace of meetings by elimi­nating the need to change places at a whiteboard, allowing concurrent contributions 
by several participants [Ste­fik87], It further allows remote participation in a meeting; we use it in 
conjunction with telephone and speakerphone audio channels to hold technical discussions. Addhional descriptions 
and usability studies are reported in [Wolf92]. In WeMet, the application is rather simple. It consists 
of a graphical editor, supporting a number of canvases, each of which corresponds to an application history. 
The editor deals with strokes, keystrokes and bitmap images. The WeMet user interface is shown below 
in Figure 2.. It provides a writing area surrounded by control functions. In general, the bar above the 
writing area contains functions for controlling the history. The New button creates a new canvas and 
an associated history. The Scenes button pops up a viewpoint selector allowing the user to select a pre­viously 
created canvas for viewing. The default viewpoint will be the end of the hktory for the selected canvas, 
The ViewPoints button allows access to the set of user-created viewpoint sequences. The users area shows 
the partici­ t-last-k  [mmm~Tm S1.=..= ....l lTq Figure 2. Example WeMet Application Interface November 
15-18, 1992 UIST 92 pants of the group-view by their initials. The Who button can be used after selecting 
some graphics to highlight the user labels of the users who created the graphics. The hor­izontal slider 
at the top of the writing area is a manual control over the history cursor for the group view. Moving 
it forward causes events to appear, and moving it back­ward causes events to disappear in the group-viewer. 
h the example, the slider is at the far right indicating the view is at the end of this history. In principle, 
one would like to have a common, reusable interface to the collaboration and history functions. Unfor­tunately, 
for the current generation of window based tool­kits, this implies an assembly of windows into a rectangular 
region, implemented as a widget tree. Howev­er, the assembly might be tall and narrow, and my inter­face 
design could require a short and wide assembly. Therefore, for the WeMet application, we created a cus­tom 
design that mixes the history and collaboration func­tions with application functions, in order to give 
the users a larger writing area. It is an interesting, open problem whether one could design a sufllciently 
flexible user inter­face builder to solve this problem, which arises in the con­text of other, multi 
layered applications. The WeMet toolkit was derived from the WeMet applica­tion. Its architecture became 
clear only after several reen­gineering iterations on the application. Others, e.g. [Crowley90, Patter90a], 
have reported similar experi­ences. Perhaps this phenomenon indicates that we do not yet understand the 
function and architecture issues of col­ laborative applications well enought to build the toolkits before 
building the applications. The next few sections of this paper will be devoted to de­ scribing the model 
from its object structure, i.e. defining inheritance and subclassing principles, and showing how the 
classes work together in clusters. Remarks will be made along the way about the manner in which applica­ 
tion development is caried out. The class description ex­ amples will be presented in a C++ style, but 
with many syntactic details eliminated.  Events One typically thinks of events as user actions at the 
ap­ plication interface, however our events are more closely related to transactions and may involve 
several user ac­ tions (e.g. to complete a dialog). Events are first-class objects in the WeMet toolkit, 
and have persistence. Dis­ play objects, on the other hand, are temporary and tran­ sient, and are synthesized 
from the events when needed. Transaction events have mainly been used to support con­sistency and undo/redo, 
cf [Ellis89, Vliss90]. The WeMet toolkit uses events for these purposes and to support re­view, replay, 
and retrieval as well. Events are time­stamped, as we found that meeting participants often recall events 
by searching around a timepoint in the meet­ing when they think the event occurred. Each event records 
the identity of its creator. This permits retrieval by remembering that an idea was contributed by a 
certain participant in the meeting. Each event also re­cords the group-view in which it was created, 
allowing retieval by group-view as well. Each event is identified by type, to distinguish e.g. draw­ing 
events from speaking, events. The event type also hap­pens to be an important recall cue. We have found 
that events fall into a hierarchy of classes, and this hierarchy has been the basis for the event object 
inheritance. Event Class Hierarchy WeMet events are organized as a class hierarchy with single inheritance. 
The base event class, shown below in Example 1., contains the members common to all events. class Evt 
ID get ID() ID getUser ( ) TimeStamp getTimestamp ( ) virtual int do(Hist Cursor) virtual int undo (HistCursor) 
virtual int record (History) Example 1. Evt Class Description This class specification is abstract in 
that the do and undo method definitions must be supplied for each instantiable subclass. These methods 
are not invoked by the applica­tion, but by the groupviewer, and are provided with the history context 
they belong to and the application to which they should apply. The record method appends the Evt to the 
history and adds the permanent members of the Evt to the permanent record for the history. Events are 
typically subclasses according to whether they affect the application, or the collaboration session. 
For example, an application event will alter the visible con­tents of the application display. Session 
events reflect the entrance, reentrance, and exit of users from the collabora­tion session. In the WeMet 
example, a st rokeEvt would bean application event, while adding a new user to the session would be a 
Sess ionEvk. Application Event Subclasses There are generally two important subclasses of the Ap ­pEvt 
class: those events which create objects, and those events which modify already created objects. Let 
us take a simple drawing editor as an example. In this editor, one may create graphics or groups of graphics, 
or one may modify (including deleting) a graphic or group. Operations that create a graphic are recorded 
as events which contain the complete set of parameters needed to create the initial graphic. For a circle, 
these parameters might consist of the center location and the radius. Graph­ic group creation is recorded 
as an event which creates a group object and which refers to the events which created the graphic objects 
that are its contents. Group creation is a hybrid subclass which both creates an object and whic;h refers 
to other events. Operations that edit a graphic or a group will be imple­mented as events which contain 
references to other events, and eventually to the creation event for the graphic being edited. Thus events 
always refer to other events and never to objects which are created as the results of the event op­erations. 
This policy simplifies the permanent record of the history, which need only contain Evts of various kinds, 
and need not contain any application state, unless this is desired for performance reasons. Application 
developers will typicatly create these two sub­classes and then subclass them further to define the actual 
application event classes. The design principles prohibit an application from keeping state related information 
in an Evt subclass, as multiple application instances maybe driven from a single history, and thus a 
single Evt may have a distinct manifestation in each application instance. Session Event Subclass Shortly, 
it will become apparent that the session claw, which keeps track of users, application instances, and 
his­ tories, is itself a toolkit application, and has its own histo­ ry, in which are recorded the arrival 
and departure of users, the creation and deletion of groups and teams, and the creation and termination 
of application instances. An example of a Sess i onEvt is shown below in Example 2.  History Architecture 
A history is a particular, nonbranching sequence of events for a specific application. This means that 
each applica­ class SessionEvt : Evt class UserJoinEvt : SessionEvt string getUserName ( ) CornPath* 
getComPaths ( ) Example 2. SessionEvt and Subclasses tion must have its own type of history, and consequent] 
y, that the application developer must subclass the History class. That the history is nonbranching means 
that there is an unambiguous forward and backward travemd of the history. A history is particular in 
that it represents one se­quence of actions. Histories may share a prefix sequence of events, diverging 
after this prefix. Two such histories are called variants, and they are represented in the Hi st ory 
class by a link­age from one His tory to another, so that the prefix se­quence of Evts k not duplicated. 
Variant histories are conceptually and actually separate, however, and a history cursor can designate 
a point in only one history at a time. If the application implementation permits, the history used to 
define the application state maybe switched at any time to another history type compatible with the application. 
class History bool record( . . . ) Evt* nextEvt (Evt* ) Evt* priorEvt (Evt ) class History Cursor bool 
move ( int ) bool move (Evt * ) bool move (ViewPoint * ) Evt* curEvt ( ) Example 3. History and History 
Cursor Classes The state of the application instance is defined by its History Cursor, and by the History 
it is tied to. To obtain the current application state, the application instance is initialized, and 
each Evt in the History from the beginning to the current Evt k done (by invok­ing its do method with 
the application instance). Moving backward in the history involves undoing Evts, and mov­ing forward 
involved doing Evts. One may define an application without undo methods, and the corresponding Hi st 
oryCursor will be unable to move backward. A new Evt, properly initialized, will be added to the History 
at the end, then the His t oryCur sor will be stepped forward, and the new Evt will be done. If the His 
t orycursor is not at the end of the History when a new Evt is received, a variant History is created 
with a prefix reference to the current History and its Evts from the beginning to the current Evt. The 
History Cursor is switched to the variant History, where it is at the end, and the new Evt is appended 
to the variant. This can be done without altering the application state, as the prefixes of the original 
History and its vari­ant are identical, implying that they lead to the same state of the application. 
In practice, this creation of variant histories never results in a noticeable delay, and the only indication 
in our examp­le interface is that the history slider moves over to the extreme left. This can have unfortunate 
consequences, as users occasionally create unintended variants. It will be very useful to make note of 
particular points in a history or collection of histories. The Hi st oryCursor is a bit too heavy for 
this purpose, so there is a kind of history index, called a Viewpoint Seq, which consists of an ordered 
collection of ( Evt, History ) pairs. A few viewpoint collections are maintained by the session, including 
the viewpoints representing the most current states of each application history. Other viewpoint collec­tions 
can be constructed by the users as ad-hoc indices to interesting events in the session. Users, Groups, 
and Teams The model of participants afforded by the WeMet toolkit consists of groups, teams and users. 
A user is an individu­al, who may be participating in several collaborations, and using several different 
interfaces (e.g. multiple worksta­tions, windows and displays and their associated input devices). A 
team is a collection of users who all have an identical (WYSIWIS) view of an application instance. A 
group is a collection of teams such that each team may have a distinct view of the current state of the 
application. Associations between users and teams, teams and groups, groups and application instances 
are represented as rela­tions, thus permitting users to belong to many teams, and teams to belong to 
many groups. Many groups may belong to an application instance, but they all see the identical state 
of the application. A pure WYSIWIS application may have one group, one team, and several users which 
are members of the team, Other applications, such as com­petitive games, may have one group, many teams, 
and a single user per team. The team is very much like the role notion expressed in [Patter91 ]. Anonymity 
has been identified as a critical issue for the quality of output from certain types of collaborations 
[Conn90, Vala90]. Complete anonymity is difficult to ob­tain, especially with small groups of people 
who know each other well. The toolkit in its present form does not deal well with anonymity. One can 
adopt a pseudonym instead of a name, but if the dk.play access information becomes part of the permanent 
record, a map of who was sitting where will expose the identity of participants. As our primary focus 
has been support of small groups of close collaborators, we have seen little need for anonym­ity. GroupViewer 
and Viewers The groupviewer and the viewers comprise the user inter­face of the application. The groupviewer 
and the group are tied together, along with the history cursor, history and application instance to forma 
complete, collaborative ap­plication. The groupviewer is application specific, but must provide certain 
management functions to the rest of the toolkit. It must receive changes in the user, group, and team 
configuration and create or destroy viewers to reflect these changes. It must provide an appropriate 
viewer for each unique combination of user, team and group, since these three elements determine the 
capabilities to be made available to the user. The viewers must define low level protocol interactions 
which define an application event, construct the corre­sponding Evt, initialize it with a timestamp and 
the iden­tifier of the (user, team, group) triple associated with the viewer. The Evt is passed to the 
groupviewer, which ap­pends it to the current History as previously described. The groupviewer and viewers 
for the WeMet application are a handcrafted combination of interface objects and Motif widgets. We have 
not yet tried to develop this part of the WeMet application into a toolkit, and we consider this effort 
to be of low priority since many others are in­vestigating this topic (e.g. [Alten90]). Our current design 
is unappealing, especially at the toolkit level, e.g. Motif and Xt, where we replicate whole inter­ faces. 
Needless to say, this chews up large amounts of storage and complicates the updating of stored state 
within replica widgets, such as the list widget in the popup tree that allows selection of a new viewpoint 
for the group­ viewer. Short of rewriting Xt and Motif, we see no practi­ cal solution other than replication. 
In an attempt to limit the amount of storage dedicated to replica interfaces, we cache popup trees by 
server, flushing trees that have not been used in a while, and recreating them on demand. This is not 
fun code to write, and the solution occasionally impacts performance of the application. Sessions The 
collaboration process cannot be limited to a single application, but instead must support a variety of 
applica­tions, independently developed. The collaboration process is a single process, however, and must 
record in a coherent way the mingling of events from the various users with respect to the various applications. 
This is the role of the session object, which acts as the primary recorder for all of the applications 
which participate in the collaboration. As shown in the example below, the Session class pro­vides access 
to the participants, applications, histories and groupviewers of the session. In addition, it maintains 
a history of the operations affecting the session (e.g. the entrance and departure of participants). 
class Session : App UserList users ... AppList apps ... HistoryList histories Example 4. Session Class 
Description The Session k subclasses from App, which is the ge­neric base class for WeMet applications. 
This means that the session is a collaborative application instance, with its own set of Evts (previously 
discussed) and its own His­tory. This is not only a nice way to reuse code, it also means that the permanent 
collaboration record includes the arrival and departure of participants, the starting and termination 
of applications, and so forth. The history cursor for a session does not support moving backward in the 
session history. We could not convince ourselves that this was a useful, or even an usable func­tion. 
The session history is mainly for indirect review pur­poses, e.g. examining it to see when individuals 
arrivecl and left, who was in a team at the time some application event occurred. It could also be used 
to restart a collabora­tion in some prior configuration of users, teams, groups, applciations and histories, 
but this will generally involve only a selective redoing of the session history. Conclusions, Future 
Work History Completeness The history model as it is described thus far is incomplete in a fundamental 
(though perhaps not practical) sense. If one compared a videotape of a WeMet session with the permanent 
transcript, one would see events in the video­tape that are not recorded in the transcript. These events 
are the occasions when a group decides to travel backward in an application history to review some actions 
or to create a divergent sequence of actions. The WeMet toolkit (and the WeMet application) do pro­vide 
a complete transcript. The HistoryCursor is actually a subclass of App, meaning that it also has a set 
of Evts and an associated history, which records the actions of going forward and backward in a history, 
and of switching a his­tory cursor to a new history. The resulting set of histories, application histories, 
session history, and history cursor histories, is complete in the sense just described. The history cursor 
of the history cursor application does not permit backward travel. If it did, yet another level of meta-history 
would be required. In fact, an infinite num­ber of meta-histories would be required to achieve com­pleteness 
in this case. Users may want the capability to return to a point in an application history which has 
al­ready been reached by traveling backward in an applica­tion history. This can be given to them without 
backward motion in the history cursor history by allowing them to duplicate a prior event in the history 
cursor history. In any event, we have not yet seen a compelling reason to extend the levels of meta-history 
past the initial level. It turns out that it is useful to have several subclasses of HistoryCursor to 
implement the different behavioral prop­erties needed. One subclass provides the meta-history de­scribed 
above, and provides a full set of traversal operations for its associated history. Another subclass does 
not provide the meta-history and only permits forward traversals of the associated history. A third subclass 
is used for real time replay of the associated history, and does not have a meta history. The US&#38;R 
work [Vhter84] was baaed on a history notion similar to ours, but with the addition of heuristics to 
allow events performed in one history to be perfonmed again in another. That system did not record meta-events, 
as ours does. However, it is clearly useful to be able to reperform actions previously performed in another 
history. We think that adding such a facility would be simple, however, dealing with the consequences 
of failure of an event in the middle of such a reperformance must be carefully treated. It should be 
noted here that the successor failure of an event performance cannot be recorded with the event. This 
is state information associated with a particular applica­tion instance, and if the same event is done 
by another application instance, there may be no error. The proper place to store such successor failure 
information is in the meta-history, since it is associated not with the event, but rather with the performance 
of the event. Performance Issues The two practicality concerns raised by reviewers and oth­er readers 
are: the size of the permanent transcript, and the online performance of the applications when it becomes 
necessary to recreate an application s state by traversing the history. The size of the permanent transcript 
depends on the grain size of the application actions, and thus is under control of the application developer. 
The developer gets to make an interesting design decision: to record actions at a fine grain size, and 
thus achieve high fidelity at playback, or to record actions at a large grain of detail and reduce the 
per­manent storage requirement. For example, if a text editor history consisted of key­stroke input and 
command and range selection events, the permanent space required could easily be 10-100 times larger 
than the size of the ASCII codes comprising the current size of the text file. On the other hand, one 
might elect to record just the overall changes by a particular par­ticipant in a particular locale of 
the text, and in this case, the permanent record might be 24 times as large as the text file. Certainly, 
nothing precludes the application designer from implementing a state saving function (e.g. creating an 
ASCII disk file), in which case the history can be deleted up to the point where the state was saved. 
In fact, it is pos­sible for an application to be written which dynamically decides what strategy to 
use, though it would probably not be easy in the current state of the toolkit. Our WeMet application, 
which records strokes as events, tends to generate a permanent transcript of 120-1 50KB when used by 
three people for a half hour meeting. A more compact representation for strokes could easily re­duce 
this to 50KB, and, if one was truly concerned about disk space, one might compress the file down to 25KB. 
The numbers used here come from actual experiments we have done. The processing time required to recreate 
an application state may not be a serious penalty. Since WeMet provides various means to link histories 
(variants, cross history ref­ erences), users do not generally create very long histories. The toolkit 
encourages application writers to implement transaction bounds around sequences of events so that each 
event does not update the displays as it is done, but instead, the displays are updated at the end of 
the transac­tion. This allows the application to simply build state. For X applications, once the state 
is built, the application win­dows are cleared and the expose processing updates them. There is also 
nothing to prevent an application designer from cacheing state. When a history is switched, or a move 
is made to a distant portion of the history, the ap­plication might look for a cached state which could 
be updated to reach the desired state. If fact, one of our early implementations of WeMet did just this. 
It turned out to be complicated code and totally unnecessary to achieve ac­ceptable performance. Future 
work Our experiments have convinced us that the audio portion of a meeting contains crucial information. 
We would like to add compressed audio to the events recorded in the his­tory. This will considerably 
enlarge the size of the meeting history, but we believe it possible to put a few hundred hours of meeting 
audio and other actions on a single 8mm tape cartridge. We would also like to couple the histories with 
external video recording devices, so that the review of a collabora­tion could include simultaneous replay 
of the video and the application events. We will likely have to implement some machinery to fast forward 
through long gaps in the history of a collaboration on an application. We have developed, but not yet 
implemented, a distrib­uted history sharing mechanism which can eliminate many of the vexing problems 
of keeping distributed replicated applications in the same state. We expect to report on this work in 
the near future. Conclusions Our experience with this toolkit to date has shown that it provides a simple, 
practical, and elegant solution to the problem of building applications which exhibit mixtures of synchronous 
and asynchronous behavior. The addition of history information permits the retrieval of information from 
a session by participant, by time, and by context, and this is a novel and valuable addition to collaborative 
ap­plications. The history components can add a common and complete undo/redo facility to any application 
in which they are included, and eliminate the need to write code to save and load the state of the application. 
 Acknowledgements We would like to thank Loma Zomnan, who built the ini­tial prototype while visiting 
our lab. Colin Harrison found us the resources to pursue this project, and P. R. Kumar, Haakam Winbom, 
Howard Page, and Charles Perkins all built system components which were critical to the WeMet effort. 
We would like to thank our colleages Jay Nuna­maker and Robert Briggs who provided many new insights 
into our vision of the collaboration process. Finally, we: thank the reviewers and readers of this paper, 
who madle many good suggestions. We hope we have addressed the most important of their concerns. References 
 [Ahuja90] S. R. Ahuja, J. R. Ensor, S. E. Lucco, A com­parison of application sharing mechanisms in 
real time desktop conferencing systems, Proceedings of the Con­ ference on Office Information Systems, 
Cambridge, MA, April 25-27,1990. ACM Press, 1991, pp. 238 248. [Ahuja88] S. R. Ahuja, J. R. Ensor, D. 
Horn, The Rap­port Multimedia Conferencing System, Proceedings of the Conference on Ofice Information 
Systems, Palo Alto, CA, March 23 25, 1988. ACM Press, 1989, pp. 1 8. [Alten90] M. Altenhofen, B. Neidecker 
Lutz, P. Tallett Upgrading a Window System for Tutoring Functions, Proceedings of the ARGOSI workshop 
on distributed window systems, The Cosener s House, Abingdon UK, 9 1 1 December 1991, submitted for publication 
as a EUROGRAPHICS Technical Report. [Bullen88] C. Bullen and R, Johansen, Groupware: A Key to Managing 
Business Teams, Technical Report, MIT Sloan School of Management, Cambridge, MA., 1988. [Conn90] T. Connolly, 
L. M. Jessup, and J. S. Valacich, Effects of anonymity and evaluative tone on idea genera­tion in computer 
mediated groups, Journal of Applied psychology, 53, 1990, Pp. 689-703. [Crowley90] Terrence Crowley, 
Paul Milazzo, Ellie Baker, Harry Forsdick, and Raymond Tomlinson. MMConfi An infrastructure for building 
shared, multimedia applica­tions, Proceedings of the Conference on Computer-Sup­ported Cooperative Work, 
ACM Press, 1990, pp. 329 342. [Dewan91] Prasun Dewan and Rajiv Choudhary, Primi­tives for Programming 
Multi User Interfaces, Proceed­ings of the ACM Symposium on User Interface Software and Technology, Hilton 
Head, SC, November 11 1 3, 1991. ACM Press, 1991, pp.69-78. [Ellis89] C. A. Ellis and S. J. Gibbs. Concurrency 
Con­ trol in Groupware Systems, Proceedings of the Interna­ tional Conference on the Management of Data, 
ACM Press, 1989, pp. 399-407. [Ellis90] C. A. Ellis, S. J. Gibbs, and G. L. Rein, Group­ ware: some issues 
and experiences, Communications of the ACM 34 (No. 1, January 1991), pp 39 58. [Garfink89] D. Garllnkel, 
P. Gust, M. Lemon, S. Lewder, The SharedX multi user interface user s guide, version 2.0, technical report 
STL-TM-89-07, Hewlett Packard Labs, March, 1989. [Greenb90] Saul Greenberg, Sharing views and interac­tions 
with singl-user applications, Proceedings of the Conference on O@ce Information Systems, Cambridge, MA, 
April 25-27,1990. ACM Press, 1991, pp. 227-237. [Gust88] Phil Gust, Shared X: X in a Distributed Group 
Work Environment, presented at the 2nd Annual X Tech­nical Conference, Boston, MA, January, 1988. Copies 
available from the author at Hewlett Packard Labs, Palo Alto, CA, [Hender88] D. Austin Henderson and 
Stuart Card. ROOMS: the use of multiple virtual workspacesto reduce space contention in a window based 
graphical user inter­face , ACM Transactions on Graphics 5 (No. 3, July 1986) pp21 1 243. [Knist90] Michael 
Knister and Atul Prakash. DistEditi A Distributed Toolkit for Supporting Multiple Group Edi­ tors; Proceedings 
of the Conference on Computer-Sup­ported Cooperative Work, ACM Press, 1990, pp. 343-355. [Lantz86] Keith 
A. Lantz. An Experiment in Integrated Multimedia Conferencing~ Computer Supported Coop­ erative Work: 
A Book of Readings, Morgan-Kaufmann, 1988, pp. 533 552. [Lauwers90] J. Chris Lauwers, Thomas A. Joseph, 
Keith A. Lantz, and Allyn L. Romanow. Replicated Architec­tures for Shared Whidow Systems: A Critique: 
Proceed-ings of the Conference on O@ce Information Systems, Cambridge, MA, April 25 27, 1990. ACM Press, 
1991, pp. 249-260. [Lauwers90b] J. Chris Lauswers. Collaboration Transpar­ ency in Desktop Teleconferencing 
Systems. Stanford Uni­ versity Ph.D. Thesis, 1990. Stanford University CSL-TR-90-435. [McGrath90] J, 
McGrath. Time Matters in Groups, in Intellectual Teamwork: Social and Technological Founda­tions of Cooperative 
Work, J. Galegher, R. Kraut, and C, Egido eds., Lawrence Erlbaum Associates, Hillsdrde, NJ, 1990, pp. 
23-61, [Patte@lO] John Patterson, Ralph Hill, Steven Rohall, and W. Scott Meeks. An Architecture for 
Synchronous, Mul­ti User Applications, Proceedings of the Conference on Computer Supported Cooperative 
Work, ACM Press, 1990, pp 3 17 328. [Patte@Ob] John Patterson, The Good, the Bad and the Ugly of Window 
Sharing in X, presentation at the 4th Annual X Technical Conference, Boston, MA. Jan. 15-17, 1990. Copies 
available from the author at Bellcore, 445 South St., Morristown, NJ 07962. [Patter91] John Patterson. 
Comparing the Programming Demands of SingleAJser and Multi User Applications, Proceedings of the ACM 
Symposium on User Interface Sofiware and Technology, Hilton Head, SC, November 11-13, 1991. ACM Press, 
1991, pp. 87 94. [Reder90] S. Reder and R. Schwab, The Temporal Struc­ture of Cooperative Activity, Proceedings 
of the Confer­ence on Computer+upported Cooperative Work, Los Angeles, CA., October 7-10, 1991. ACM Press, 
1991, pp. 303-316. [Rhyne91 ] J. Rhyne, D. Chow, and M. Sacks. Enhancing the X-Window System, Dr. Dobb 
s Journal, 1991 (#183, December), pp. 30-38. [Steflk87] Mark Stefik, Gregg Foster, Daniel Bobrow, Kenneth 
Kahn, Stan Lanning and Lucy Suchman, Be­yond the chalkboard: computer support for collaboration and problem 
solving in meetings, Communications of the ACM, 30 (no.1, January, 1987), pp-33-47. [Vala90] J. S. Valacich, 
A. R. Dennis, J. F. Nunamaker, Anonymity and Group Size Effects on Computer Me­diated Idea Generation, 
Technical report, MIS Depart­ment, University of Arizona, Tucson, AZ., 1990. [Vitter84] Jeffrey S. Vitter, 
US&#38;R: A new framework for redoing, Proceedings of the SIGSOFTISIGPLAN Sympo­sium on Practical Software 
Development Environments, Pittsburgh PA, 1984. ACM SIGPLAN Notices 19 No. 4, (April) 1984, pp. 169-176. 
 [Vlis90] John Vlissides. Generalized Graphical Object Editing. Stanford University Technical Report 
CSL­TR-90-427 (June, 1990). [Wolf92] Catherine Wolf, James Rhyne, and Laura Briggs, Communication and 
Information Retrieval with a Pen Based Meeting Support Tool, IBM Research Report RC 17842, March 26, 
1992, IBM Corporation, Distribu­tion Services, P.O. Box 218, Yorktown Heights, NY 10598. To appear in 
Proceedings of the Conference on Computer Supported Cooperative Work, 1992.  
			

 Paragon: Novel Uses of Type Hierarchies for Data Abstraction Mark Sherman Department of Math. and 
Computer Science Dartmouth College Hanover, NH 03755 1. Introduction This paper describes the design 
of the Paragon programming language. Through the use of multiple, inherited classes, a uniform object 
notation, separate procedure specifications and implementa- tions, and relaxed parameter matching rules, 
Paragon provides better support for data abstraction than current languages. This paper first describes 
the goals for the design of Paragon and briefly relates these goals to previous work. Then a brief introduction 
to Paragon's class structure, object notation and procedure definitions isprovided. In the next section 
I give program examples that illustrate how Paragon supports data abstraction. The last section gives 
a brief status of the Paragon work. 2. Goals of Paraqon The goals of Paragon can be grouped into three 
broad classes: abstract data type specification goals, abstract data type representation goals and automatic-processing 
goals. These goals are listed below: This research was sponsored by the Defexme Advanced Research Projects 
Agency (IX)D), ARPA Order No. 3597, monitored by the Air Force Avionics Laboratory Under Contract F3361S-81-K-IS39. 
The views and conclusions contained in this paper are those of the author and should not be interpreted 
as representing the official policies, either expressed or implied, of the Defense Advanced Research 
Projects Agency or the US Gov- ernment. Permission to copy without fee all or part of this material is 
granted Abstract Data Type Specification Goals * Refinements of speclficatio_ns of abstract data types 
may be written. * Related s~. cifleations may be combined in a single module.  Abstract Data Type Representation 
Goals * Multiple implementations of an abstract data type may be de qlared in a program. Several implementations 
of an abstract data type may be used simultaneously in a program (one implementation per variable). If 
several implementations of an abstract data type are used for different variables, those variables may 
interact. * A si__ng!e__im~.nt.a_ti.on may be written for several separaLe S/~_Â£i_ficati.ons,  Automatic-Processing 
Goals * Static .t_ypa ..c.hecking of all variable decla- rations (object creations ) and procedure calls 
should be supported.  * C_o..mp~le-time checkinq should ensure that al.l r_epXgsentation-selection decisions 
result in a program that can execute without run-time errors.  Although many languages are designed 
to meet some of these goals, no language known to me can meet all of theN. After a review of how other 
languages only paritally meet these goals, a description of Paragon is given along with examples of 
how a programmer can use Paragon to achieve these goals. provided that the copies are not made or distributed 
for direct commercial advantage, the ACM copyright notice and the title of the publication and its date 
appear, and notice is given that copying is by permission of the Association for Computing Machinery. 
To copy otherwise, or to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0208 
$00.75 The abstract data type specification goals are partially met by the object-oriented language 
designs in Simula [Dah168 ] and Smalltalk [GoldbergS1, Ingalls78, Ingalls8l, Morgan81, Xerox81], the 
Traits additions to Mesa [Curry82] and the Flavors facility for Lisp [WeinrebS1]. An 208 extension of 
Simula proposed by Ingargiola [Ingargiola7S] allows, in a very restricted way, layers of spacifications. 
A similar kind of hierarchy was proposed by Smith and Smith [ Smith77 ] and in Taxis [Mylopoulos80 ] 
for organizing relations, views and objects in a database. Further, the Program Develolnent System [Cheatham79] 
uses a refinement hierarchy for writing system modules. But all of these systems use the refinements 
only as a way to refine objects or system components, and not as refinements of specifications with the 
intention of later refining the spacifications into imple- mentations. Both sets of abstract data type 
goals are partially met by Clu [Liskov81], Alphard [ShawSl], Enhanced C [Katzenelson83a, Katzenelson83b], 
Adapt [Archibald83, Leavenworth81] and Ada [IchbiahS0]. However, all of these languages use exactly two 
levels of refinements, the upper level being the abstract specification and the lower level being the 
concrete implementation. The proposed layers of specifications are a departure from most languages that 
provide data abstraction facilities. Further, these other Im:guages place strong restrictions on how 
representations of abstract data types must be related to their spacifica-lions. These restrictions limit 
the programmers ' abilities to define and use multiple implementa-tions of abstract data types, or to 
let different implementations interact. In contrast, Paragon provides features that allow a progrmner 
to define and use multiple implementations of an abstract data type in a program. Further, the Paragon 
design permits different representations to have access to additional deta/Is about their parameters 
and use of the parameters' operations. This ability represents a substantial departure from current data 
abstraction methodolo~ which insists that a representation may be used anywhere the spacification is 
used. The goal of static type checking is a departure from the procedure-call checking performed in typical 
object-oriented, hierarchy-based systems, such as for Smalltalk's methods and Simula's virtual procedures. 
There is a tradeoff in these designs between safety and efficiency, and flexibility. Because the parameter 
matching for procedure calls can be verified during compila- tion, static checking is considered safer, 
and because more is known about the program being chocked, a more efficient program should result. Therefore 
Paragon opts for a safe and efficient languagerather than for flexibility. In applying this philosophy 
to a language that supports multiple representations of abstract data typas, the design of Paragon enforces 
complle-tlme chocking of implementations, guaranteeing that all variables have a feasible representation. 
Further the design of Paragon ensures that a program's feasibility may be checked at compile time, that 
is, that appropriate procedure implementations exist for all procedure calls as dictated by the representations 
of the actual parameters in the cal 1. Another part of this philosophy is that no run-time expanse should 
be incurred for making a selection decision. Although Paragon allows multiple procedure implementations 
to be provided for each procedure specification, the selection of an implementation to use for each procedure 
call must be made at compile time. These goals are met by the Paragon design, which is sketched in the 
next section. The following section then shows how these features are used to write layers of specifications, 
multiple implemen- tations of abstract data types and various kinds of shared representations. 3. Introduction 
to Paragon Many details of Paragon resemble a typical algebraic language. Four aspects of Paragon strongly 
influence its support for data abstraction: classes and inheritance, separation of procedure specification 
and implementation, a uniform object notation and relaxed parameter matching rules. The interactions 
between those aspacts provides a Paragon programmer with tremendous flexibility for writing abstractions. 
Each aspect is discussed below. 3.1. Classes and Inheritance Classes in Paragon are similar to classes 
in Simula: they contain declarations, statements and parameters. Unlike Simula classes, Paragon classes 
may inherit more than one class, and an ancestor may be inherited more than once. Also unlike Simula, 
classes declared inside of a class may be selected from that class. Variable declarations in Paragon 
namea class that s_L~_qi~fies the variable. Only the visible declara- tions in the class or one of its 
ancestors may be used by the variable. An implementation for that variable is selected from the subclasses 
of the specified class. Every class may be used as a specification, implementation or both. 3.2. Procedure 
Specifications and Implementations Procedures (which include functions and iterators) have separate spacifications 
and implementations. A procedure spacification is the signature of the procedure: the procedure's identifier 
and list of formal parameters. A procedure implementation is a signature followed by local declarations 
and statements. Any number of implementations may be written for each specification in the class (and 
in any subclass of the class) that contains the procedure specification. Paragon will select an appropriate 
procedure implementation given the im- plementations of the actual parameters for each procedure call. 
 3.3. Uniform Object Notation Paragon uses a uniform object notation in all expressions. Expressions 
are used as formal parameters in class and procedure declarations, as actual parameters in class instantiations 
and Procedure calls, as "types" in variable declara- tions and as statements. The same interpretation 
of an expression is used regardiess of where it appears. There are three interesting parts of this notation: 
definite objects, i.ndefinite objects and anl objects. A definite object results from the instantiation 
of a class. This is the same as object generation in Simula, and uses the same notation: new ClasslD. 
Generated (definite) objects are usually associated with variables through a variable declaration. An 
indefinite object can be thought of as a type. Its notation is merely a class name: ClassZD. An "any" 
object is a special, predefined object with the property that any object matches it. Its notation is 
"any". This uniform object notation allows a programmer to specify a "type" parameter by using an indefinite 
object as an actual parameter, to specify a constraint by using a definite object as a formal parameter, 
and to specify a procedure parameter by declaring a procedure in a class which can then be passed. Thus 
Paragon can use this single notation to provide for commonly used facilities in other languages. 3.4. 
Comparing Objects A relation called matchinq may exist between an actual object and a formal object. 
The terms "actual" and "formal" are used in the conventional sense. Unlike most languages, the matching 
relation is not symmetric. When an actual matches a formal, there is no implication that the formal matches 
the actual. Since the expressions used as parameters evaluate to objects, object matching is used for 
comparing parameters. At different times, the same parameter may be used as a formal and an actual. The 
fol I owi ng table e mmari zes the kinds of comparisons that occur in Paragon. Actual Formal Proc. 
Call Param. Proc. Spec. Param, Proc. Call Param. Proc. Implem. Param. Class Instance Param. Class Decl. 
Param. Subclass Decl. Param. Class Decl. Param, Proc. Implem. Param. Proc. Spec. Param, The basis for 
matching is the comparison of two instances of classes. Intuitively, an actual object matches a formal 
object if the underlying class of the formal is an ancestor of, or the same as, the underlying class 
of the actual. To ensure compatibl I ity between definite and ir~efinite instances, one of the following 
constraints must also be met: * The formal is an an~ instance, * The formal is an indefinite instance 
and the underlying class of the formal is a ancestor of, or the same class as, the underlying  class 
of the actual, or * The formal is a definite instance and the actual is the same definite instance. 
For example, "integer" matches "Integer", "I" matches "integer" and "i" matches "I", but "integer" does 
not match "I" and "I" does not match "2". There are also rules that ensure that any parameters of the 
instances match, but these rules are omitted for brevity, 4. S__u~99_r_ti.nq Data Abstraction In this 
section, the features of Paragon are use to illustrate how data abstractions may be defined in Paragon. 
These exaraples show how Paragon can describe and use shared specifications and repre-sentations. These 
examples are programned using a style of programming called the ob~ect-.manager .model_, which is described 
below. 4.1. Object Managers and Nested Classes The object-manager model divides program objects into 
two categories : _mana~ and individuals. The manager iS created first and contains data and procedures 
that are shared among all individuals. For each manager, there may be any number of individuals created, 
and each individual has a single manager. Naturally, each individual may have private data and procedures 
not shared with other individuals. As an example of this model, consider integers. Each individual integer 
can be represented as a word in memory. Further, there exists a procedure, "Addition", that is shared 
among all the individual integers, and so this procedure Much of the power of multiFle procedure implemen- 
tations and subclasses comes from the fact that their parameters need only match, not be identical with, 
parameters in the corresponding procedure specification or parent class. This is a radical departure 
from other data abstraction lang~mges, since this ability implies that an implementation may not necessarily 
work anywhere that the speci-fication is permitted. Instead, Paragon uses a process called e_lab@!atti_gn 
w_/t_bh .i.m/).l_ee~.ntat~ons_ that ensures that feasible representation selections have been made. This 
process is similar to execution simulation. belongs to the manage r of all integers. Paragon implements 
this model by using nested classes. The outer class defines the manager and the inner class defines the 
individual. An example of such definitions is given in Section 4.2 below. 4.2. Classes for Specifications 
 Classes in Paragon are used to represent two kinds of specifications: generalizations and descrip-tions. 
Generalizations attempt to abstract some commonly used properties that are inherited by other specifications. 
For example, Ada provides a generalization called nonlimited private which specifies that types declared 
as nonlimited private have the assignment operation defined for them. Clu provides a generalization that 
provides an object with the ability to be transmitted over a network (see [Herlihy80, Herlihy82]). By 
properly defining a set of classes for each set of operations that one m/ght want to refine (i.e., inherit) 
later, one can provide the same predefined generalization features that other languages do but without 
limiting the choices of operations. For example, a set of declarations that simulate the concept of nonlimited 
in Ada is shown below: class AssignableManager is class Assignable is begin end; procedure Assign(Assignable,Assignable); 
procedure Equal(Assignable,Assignable) return Booteans.Bit; ~end; A description corresponds to an abstract 
data type specification in other languages. It too consists of nested classes, and ,~ually inherits generalization 
classes. An object manager that inherits the AssignableManager class would then define an nonlimited 
type. Providing some details for the integer example shows this property: class IntegerManager of AssignableManager 
is begin ! Shared data and procedures go here ; procedure Addition(Integer,lnteger) return Integer; 
 ! And the class definition for [ndivid~mls ; class Integer of Assignable is begin end; end ; One could 
use these declarations to declare variables: var AppleManager => new IntegerManager; vat Lisa :> AppleManager 
. new Integer; var Cortland => AppleManager . new integer; and perform the operations declared in the 
specified classes or their ancestors: AppleManager.Assign(Lisa,Cortland); The distinction between generalization 
and de-scription classes is by convention alone. Paragon places no restrictions on how a class is used. 
There do exist classes that are used both as generalization and description classes.  4.3. Classes 
for Implementations Implementations are declared through the use of subclasses. Typically, a subclass 
that is intended to implement an abstract data type contains the implementations for those procedures 
specified in its ancestors and contains subclasses for the ancestors' nested classes. Assuming that a 
full specification and implementation for computer words exists in a manager called "04", an imple- mentation 
for the ~ntegerManager and Integer classes is : class WordlntegerManager of IntegerManager is begin 
I ....................................... ; procedure Assign(L :Wordlnteger, R :Wordlnteger ) return 
WordInteger is begi n CM.AsS ign(L .Rep,R .Rep ) ; end ; procedure Equal (L :Wordlnteger, R :WordInteger 
) return Booleans.Bit is begin return CM.Equal(L .Rep,R .Rep) ; end ; procedure Addition (L :WordInteger, 
R :Wordlnteger ) return WordInteger is begin return CM.Plus(L.Rep,R.Rep) ; end; ! ....................................... 
; ! And the class definition for individuals ; class WordInteger of Integer is begin vat Rep => CM 
. new Word; end; end ; The conventional methodology for implementing an abstract data type requ/res 
that all operations in the specification must be implemented, that a rep- resentation for the object 
must be described and that there is some way to separate the abstract object from the concrete object. 
These three recpairements are provided above. Procedure imple- mentations for Assign, Equal and Addition 
are declared, the class Wordlnteger defines the repre- sentation of Integer and use of the n~w,e Integer 
 instead of Wordlnteger separates the abstract object from the concrete object. Thus all of the requirements 
for an abstract data type implementa- tion are met in the example. 4.4. Multiple Implementations The 
example above also illustrates a feasible im- plementation for IntegerManager. In WordlntegerManager 
, procedure implementations are provided for the procedure specifications in all inherited ancestors: 
here the Assign, Equal and Addition procedures from the IntegerManager and AssignableManager classes. 
This is not required by Paragon bt,t does guarantee that this subclass may be used mr an implementation 
anywhere the specifi- cation is used. If some operation had been missing, and if a program used that 
operation on abstract integers, then this implementation subclass for the specification could not be 
used. An attempt to use such an incomplete subclass in this circumstance would render the program infc,~q 
ibte. The distinction between the abstract use of a object and the concrete use of ~n object is also 
illustrated by this example. The example above specifies the class Wordlnteger in al t of the proceduze~' 
par~aneters in the VordlntegerManager class. This implies that only the WordInteger rep- resentation 
of Integer can be used with these procedures and provides a boundary between the abstract and concrete 
representations. Some languages provide an operation that is supposed to translate between an abstract 
object and a concrete one (for example, in Clu called "cvt" ). Within the implementation of the abstract 
data type, one may restrict the implementation to use only the abstract properties of the object by 
omitting this special translator operation. Other languages reverse the convention and allow the programmer 
access to the representation unless the programmer specifies that only the abstract operations should 
be allowed. Ada uses still another approach by unconditionally permitting access to the representation 
of an object within the implementation of the abstract data type. Paragon attempts to strike a balance 
by using the names in the class declarations. Should only the abstract operations be permitted, then 
the progrmmer may specify this by writing the name of the specification class in the parameter. If access 
to the representation is required, then the name of the class used as a representation should be written 
in the parameter. Because each procedure specifies that WordInteger objects may be used as parameters, 
each may use the details of Wordlnteger objects, such as selecting the Rep field. Had the procedures 
merely required Integer objects, then access to the Rep field would have been denied, even if an instance 
of Wordlnteger had been given to the procedure. The use of names rather than conventions for selectin 
9 the abstract or concrete interpretation of an object permits a greater flexibility in the definition 
of implementations. This is more fully explored in the next section where some methods for providing 
multiple implementations of abstract data types are considered. There are times when a programmer may 
wish to have more than one implementation for an abstract data type. This can be illustrated with the 
previously specified IntegerManager. Many computers have more than one size of data representation provided 
by the hardware, so it seems reasonable that different integer variables might be able to take advantage 
of these differences in order to improve a program's performance. Each differently sized representation 
has its own representation class and its own procedure implementations. Unfortunately, most data abstractlon 
languages &#38;Lion only one representation for each specifica- tion. If the one word representation 
for integers were present in a program, such languages would prohibit the inclusion of a half word integer 
and a double word integer. Paragon does not have such a rule. A new represen-tation may be provided by 
declaring a new set of nested classes. For example, a program might contain the following declarations 
for integers requiring less than a word of storage: class ShortWordlntegerHanager of IntegerManager is 
begin ! ...................................... ; procedure Assign(L :ShortWordlnteger, R : ShortWordI 
nteger ) return Wordlnteger is begin CHSW.~ss ign (L .Rep,R .Rep) ; end; ! ...................................... 
; procedure Equal(L :ShortWordlnteger, R : Shot tWordlnteger ) return Booleans.Bit is begin return 
C~SW.Equal(L.Rep,R.Rep) ; end; ! ...................................... ; procedure Addition( L: Shor 
tWordlnteger, R:ShortWordI nteger ) return ShortWordlnteger is  begin return CMSW.Plus (L .Rep,R .Rep) 
; end; ! And the class definition for individuals ; class SbortWordlnteger of Integer is begin var Rep= 
> C14SW new ShortWord; end; end; The ShortWordlntegerHanager and ShortWordInteger classes represent 
another implementation of the integer abstract data type. Two factors are present which allow the second 
implementation to be declared and included in a program. First, the explicit separation of the specification 
and im- plementation of the abstract data type provides a way to bind more than one implementation to 
a specification. Second, the ability to name the representation explicitly allows different procedure 
implementations to use different concrete representations for parameters. The ability to name explicitly 
the representations or specifications in parameters permits multiple representations to be used in a 
more common setting: differing type parameters. Frequently cited examples include set implementations, 
where different representations of the set are used with different element types [Johnson76, Low74, 
Schonberg77, Wulf81]. A typical (partial) speci- fication for sets in Paragon appears below: class SetManager(T:any) 
is begin class Set is begin end; procedure Union(Set,Set ) return Set; end; The element type (T) of 
the set may be any class. However, certain classes have special properties that an implementation may 
wish to exploit. For example, if the element type were totally ordered, a B-Tree or discrimination net 
may be an appropriate implementation. If it can be hashed, a hash table may prove efficient. Sets of 
a small number of enumerated values are usually represented as a bit vector. Thus one wants the implementation 
to be able to take advantage of knowledge of the element type. Other languages, such as Clu and Alpbard, 
do not permit this exploitation in an implementation, Or more precisely, they insist that such requ/rements 
appear in the specification of the abstract data type. Paragon permits the specification to be as broad 
as requ/red and the implementation to be as ,arrow as required by allowing the parameters in subclasses 
merely to match the parameters in the. parent class, and not to be identical. A discrimination-net implementation 
of the previous SetManager might look like the following:  class Dis cri mi nati onSetManager (OrderedManager 
.T :Ordered ) of SetManager is begin class DiscSet of Set is begin ! Local storage goes here i endi ! 
...................................... ; procedure Union( DiscSet ,DiscSet ) return DiscSet is begin 
! Impl. of Union operation; end ; ! ...................................... ; end; The DiscriminationSetManager 
class may only be used as an implementation for Setaanager when the element type of the set is ordered. 
However, all available information about ordered objects (as expressed in the specification for OrderedManager) 
may be used inside DiscriminationSetManager in its manipulation of the set's element type. This use of 
a subclass in the parameter of the implementa-tion class also eliminates the need for procedure parameters 
since the composed data type and its operations are combined in a class declaration. Therefore the user 
can use the abstract data type without needing to consider the constraints required by any particular 
ia~91ementation. Such considerations are automatically processed by the translation system. 4.5. Explicitly 
Shared Implementations The examples given in the previous sections for integers and sets lead to the 
topic of sharing of representations. Because the class mechanism does not restrict the way in which specifications 
and representations may be combined, several arrangements of classes prove useful in selective sharing 
between the specifications of abstract data types, between the representations of abstract data types, 
and between the specifica- tions and the representations of abstract data types. Each of these kinds 
of sharing is considered in turn. 4.5.1. Shared Implementations via Shared Specifications Selective sharing 
of specifications is quite common in practice and supported in some languages, such as Ads. This usually 
taken the form of a single manager being used for several ctlfferent kinds of individuals. One example 
is a computer memory, as illustrated below: class MemoryManager is begin class Byte is begin end; class 
Word is begin end; procedure ReadByte (IM. Integer ) return Byte ; procedure Wri teByte ( IM. Integer 
,Byte ) ; procedure ReadWord(IM.Integer} return Word; procedure WrlteWord(IM. Integer ,word ) ; procedure 
LeftByte(Word ) return Byte;  procedure RightByte(Word ) return Byte ; end; The single manager HemoryManager 
provides the shared declarations for two related individuals, Byte and Word. Words and bytes are closely 
coupled in a memory and should be considered connected in some way. Many languages have no provisions 
for this selective sharing. Paragon permits multiple inner classes that are declared in an outer class 
to denote different kinds of individuals for the same manager. The implementation of MemeryHanager could 
contain further subclasses for Byte and Word and implemen- tations for ReadByte, VriteByte, ReadWord, 
Write%k)rd, LeftByte and RightByte, each of which could access the concrete representation for both bytes 
and words. 4.S.2. Shared Implementations via Previous Imple-mentations Another way of combining classes 
gives the programmer the ability to write procedure imple-mentations that define multiple representations. 
Like the MemoryManager example above where one can write a single subclass of the specification class 
that has access to representations of multiple kinds of objects, one can provide a subclass of subclasses 
that permits access to multiple, concrete representations of the same abstract object. This can be illustrated 
by extending the IntegerManager implementations given in Section 4.4. To include a procedure that can 
add integers regardless of the implementations of the abstract integer, one can write: class CombinedWordIntegerManager 
of WordIntegerManager, ShortWordIntegerManager is begin | ...................................... ; procedure 
Addition (L: ShortWordInteger, R :Wordlnteger ) return WordInteger is begin end; I ...................................... 
; procedure Addition(L:VordInteger, R:ShortWordlnteger ) return Wordlnteger is begin ... end; end; 
 If Combinec~brdlntegerManager were to be selected as the implementation for an abstract IntegerManager 
object, then abstract integers could be implemented with either the ShortWordlntsger or the Wordlnteger 
subclasses of Integer. Regardless of the implementation selected for two abstract integers, there will 
exist an im- plementation of tile Addition procedure that can operate on them. 4.5.3. Shared Implementations 
for Unrelated Specifications A third way of sharing in Paragon allows an imple- mentation class to be 
used as an implementation for multiple specification classes. One system that illustrates this sharing 
is SETL [I)ewar79] where sets are implemented by altering the repre-sentation of the elements of the 
set. This is a unique approach to implementing sets and their elements as it requires a shared implementation 
for two specifications that are not otherwise related: one specification for sets, one specifi- cation 
for the elements of the set. The use of classes and inheritance provides this capability as well. Given 
two separate sets of specification classes, say for integers and sets, one creates a single class that 
acts as the manager for both and that class contains the representations for the union of the inherited 
individuals and procedures. An abbreviated illustration is given below, beginning with the specificatons 
for integers and sets : ! .................................... ; ! Specification Classes for Integers 
; | .................................. _' ; class IntegerManager of AssignableManager is begin procedure 
Addition( Integer ,Integer ) return Integer ; class Integer of Assignable is begin end; end; I ................................ 
; ! Specification Classes for Sets ; class SetManager(T:any) is begin procedure Unlon(Set,Set ) return 
Set; class Set is begin end; end; With these following specifications, one shared implementation may 
for write sets the and integers ( adapted from [ Dewar79 ] ) : class IntegerSetManager(IntegerManager 
.T: Integer ) of IntegerManager, SetManager is begin ! ...................................... ; class 
IntBlock is begin ! Repe for the integer and set indication ; end; I ...................................... 
; ! Shared Data for the Manager ! (uses predefined reference manager) ; ! RIBM = "Reference to IntBlock" 
Mngr ; | ...................................... ; vat RIBM => new RefManager(IntBlock ) ; war IntValueList 
=> RIBM . new Reference; I..... . ................................ ; ? Integer Implementations ! ...................................... 
; class SharedInteger of Integer is begin war IntValueBiock => RIBM . new Reference; end; 214 ! ...................................... 
; procedure kddition(Sharedlnteger, SharedInteger ) return Sharedlnteger is begin ! Implementation 
for Addition operation; end; ! ...................................... ; ! ...................................... 
; ! Set Implementations ! ...................................... ; class SharedSet of Set is begin 
vat SetNum => CM. new Word; end ; procedure Union(SharedSet, SharedSet) return SharedSet is begin ! 
Implementationfor Union operation; end; ! ...................................... ; end; A complete 
example would show how the blocks of integers are linked together and shared by all set and integer variables. 
Although the details are missing, the example above shows that representa-tion combinations can be expressed 
via the class mechanism whereas most approaches to data abstraction have no way of describing a combined 
 representation.   4.6. Implicitly Shared Implementations Paragon also supports implicit sharing 
of repre- sentations. Such sharing comes when procedures are written that use only abstract properties 
of their parameters. For example, an implementation of the Union procedure could have been provided in 
the SetManager as follows: procedure Union(L :Set ,R :Set ) return Set is begin vat Temp :> new Set; 
var i => new T; for i in Elements(L) do Insert(Temp,i ) ; end for; for i in Elements(R) do Insert(Temp,i 
) ; end for ; return Tempi end; This procedure implementation assumes that an Elements iterator and 
an Insert procedure have been specified in SetManager. Note that implemen- tation uses only abstract 
operations On sets. Each call of this Union procedure may have different or even conflicting representations 
for the parameters. Paragon permits these calls and checks that all necessary procedure implementations 
are available for use inside of Union. All of the necessary processing is performed at compile time; 
no run-time examination of representations is necessary when executing this implementation. These examples 
have shown how multiple representa- tions for variables and procedures may be declared and used in Paragon. 
After a program is written, the selection of an appropriate representation must be made for each variable 
and each procedure call in the program. To satisfy this need, Paragon provides a representation selection 
mechanism that the programmer may use to guide the translator in picking appropriate implementations. 
The discussion of this selection system is beyond the scope of this paper. The interested reader is referred 
to the complete description of Paragon [ Sherman83 ]. 5. Status of Paraqon The design of Paragon is complete 
and a prototype implementation exists. Several thousand lines of Paragon code have been programmed. Both 
abstract data types and application programs have been programmed and processed by the prototype. This 
code also provides test cases for Performance measurements that were takenof the prototype translator. 
The prototype did provide some lessons about implementing a language with the generality of Paragon. 
First, I believe that efficient code can be generated for Paragon. Although the protoype has no optimizer, 
one of the outputs of the prototype is a transformed program that has specific representations for all 
variables and procedure calls made. This transformed program has the complexity of an Algol-60 or Pascal 
program. Given that efficient code can he generated for these languages, efficient code can be generated 
for Paragon. Second, the prototype was built with conventional compiler construction, therefore, no new 
compiler technology is needed to add the type hierarchy facilities of Paragon to a language. Third, the 
processing of a program may take significantly longer with a Paragon compiler than with a conventional-language 
compiler. For example, empirical measurements indicate that one of the new types of processing, feasibility 
checking, takes about 3 times as much resources as conventional semantic analysis. Finally, separate 
compilation may prove difficult. The prototype has no facility for separate compilation, though it became 
clear that separate compilation was needed when I was testing programs that used many different implementations 
of data abstractions. A separate compilation facility was not retrofitted becauseof some complications 
with feasibility checking and interactions with the representation selection system. Whether a good separate 
compilation facility can be built for Paragon remains an open question to me. Therefore, one can add 
most of Paragon's features using conventional techniques. However, the efficient addition of representation 
selection and feasibility checking may require new compiler methods.  6. S1mry The paper demonstrates 
how a type hierarchy (technically, a directed acyclic graph of types, but "type hierarchy" is a more 
commonly used term) can be mred for writin 9 programs using the object-manger model to specify abstractions, 
refine the specifications, write representations for the abstractions and combine representations as 
desired. These capabilities are not available in current languages, so the Paragon design shows how type 
hierarchies can be used to improve the facilities for data abstraction in future languages. A number 
of programs were written and translated with a prototype system that processes Paragon, thus the suggested 
language is not a more paper design, but a cowplete language that can he implemented and used for programming. 
7. Acknowl edqeman ts I wish to thank Andy Hisgen and Jonathan Rosenberg for many helpful discussions 
during the time I was designingParagon. Elaine Kant, Peter Hihbard and John Nestor also provided many 
useful comments on Paragon, representation selection and language design in general. 8. Biblioqraphy 
 [Archibaid83]J.L. Archibald, B.M. Leavenworth and L.R. Power, "Abstract Design and Program Translator: 
New Tools for Software Design," ~BM System Journal, 22(3):170-187, 1983. [Cheathem79]Tbomas E. Cheatham 
Jr., Judy A. Townley and Glenn H. Holloway, "A System for Programming Refinement," In Proceedinqs of 
the 4th Conference on Software gnqineerinq, pages $3-62, IEEE Computer Society, September, 1979. [curn,82] 
Gael Curry, Larry Bear, Daniel Lipkie and Bruce Lee, "Traits: An Approach to Multiple-Inheritance Subclassing," 
In Limb, J.O. (editor), proceedinqs~ SIGOA Conference on Office Infora~tion S~tem, pages 1-9, ACM, SIGOA, 
June, 1982. Also SIGOA Newsletter, Vol. 2, Nos. 1 and 2. [DahI68] O.-J. Dahl, Simula 67 Common Base 
Lanqu~e, Technical Report, Norwegian Computing Center, Oslo, 1968. [Dewar79] Robert B.K. Dewar, Arthur 
Grand, Ssu-ChengLiu and Jacob T. Schwartz, "Programming by Refinement, as Exemplified by the SETL Representation 
Sublanguage," ACN T~ansactione on Proqrmeminq Lanquaqes and System, 1(1):27-49, July, 1979. [GoldbergSl]Adele 
Goldberg, "Introducing the Snmlltalk-80 System," Byte, 6(8):14-22, August, 1981. [Herlihy80] Maurice 
Peter Herlihy, Transmittin q Abstract Values in Messaqes, Technical Report MIT/IES/TR-234, Laboratory 
for Computer Science, Massachusetts Institute of Technology, April 1980. [Herlihy82] M. Herlihy and B. 
Liskov, "A Value Transmission Method for Abstract Data Types," ACM Transactions on Proqramminq Lanquaqes 
and Systems, 4(4):$27-5S1, October, 1982. [ Ichblal~0 ] Jean Ichbiab, et ai., Reference Manual for the 
Ada Proqramminq Lanquaqe, US Government, Washington, D.C., 1980. [ Ingalls78 ] Daniel H.H. Ingails, "The 
Smailtalk-76 Programming System: Design and Imple- mentation," In Conference Record of the Fifth Annual 
ACM STmposium on Principles of Proqram~inq Lanquaqes, pages 9-16, ACM, January 1978. [Ingails81] Daniel 
H .H. Ingails, "Design Principles Behind Sumlltalk," Byte, 8(8):286-298, August 1981. [Ingargiola7S]Giorgio 
P. Ingargfola, "Implementa-tions of Abstract Data Types," In Proceedinqs of the Conference on Computer 
Graphics, Pattern Recoqnition, and Data Structure, page 108-113, IEEEComputer Society, May, 197S. [Johnson76] 
Robert T. Johnson and James B. Morris, "Abstract Data Types in the MODEL Programming Language," In Proceedinqs 
of Conference on Data: Abstraction, De. finition and Structure, pages 36-46, ACM, March, 1976. Also Sigplan 
Notices, Vol. 8, No. 2, 1976. [Katzenelson83a]Jacob Katzenelson, "Introduction to Enhanced C (EC)", Software 
--Practice and Experience, 13(7):551-576, July 1983. [Katzenelson83b]Jacob Katzenelson,. "Higher Level 
Programming and Data Abstractions --A Case Study Using Enhanced C," Software --Practice and Experience, 
13(7):S77-595, July, 1983. [LeavenworthS1 ]Butt Leavenworth, "Adapt Reference Manual ," Software Technoloqy 
Technical Memo Number 19, Computer Science Department, IBM T.J. Watson Research Center, Yorktown Heights, 
NY 10598, June 3, 1981. [ LiskovSl ] B. Liskov, E. Moss, C. Schaffert, R. Scheifler and A. Snyder, The 
CLU Reference Manual, Springer-Verlag, New York, N.Y., 1981, Lecture Notes in Computer Science No. 114. 
[Low74 ] James R. Low, Automatic Cod/nq: Choice of Data Structures, Technical Report CS-452, Stanford 
University Computer Science Department, August 1974. [ Morgan81 ] Chris Morgan, "Smalltalk: A Language 
for the 1980s," Byte, 6(8):6-10, August, 1981. [Mylopoulos80]John Mylopoulos, Philip A. Bernstein and 
Harry K.T. Wong, "A Language Facility for Designing Database-Inte~ive ARBlications," ACM Transactions 
on Database Systems, 5(2):18S-207 i June, 1980. [Schonberg77]E. Schonberg and S. C. Liu, "Manual and 
Automatic Data-Structuring in SETL," In Jacques Andre and Jean-Pierre (editors), Implementation andDeslqn 
of Alqorithmic Languaqes: Proce~d/nqs of the 5th Annual III Conference, pages 284-304, IRISA, May, 1977. 
[ ShawOl ] Mary Shaw (ed/tor), Alphard: Form and Content, Sprlnger-Verlag, New York, New York, 1981. 
[ Sherman83 ] Mark Steven Sherman, Paraqon: A Lanquaqe Ustnq Type Hierarchies for .the Speclfication 
i Implementation and Selection O f Abstract Data Types, Technical Report CMU-CS-83-147, Department of 
Computer Science, Carnegie-Mellon University, Pittsburgh, PA., 1983.  [Smith77] John Miles Smith and 
Diane C.P. Smith, "Database Abstractions : Aggregation and Generalization," ~ Transactions on Database 
Systems, 2(2 ):105-133. Jun'e, 1977. [ Weinreb81 ] Daniel Weinreb and David Hoon, Lis P Machine Manual, 
Symbolice Inc, California, 1981. Fourth Edition. [ nullS1 ] W.A. Wulf, M. Shaw, P.N. Hilfinger and L. 
Flon, Fundamental Structures of Computer Science, Add/son-Wesley, 1981. [Xerox81] Xerox Learning Group, 
"The Small talk-80 Sys tern," Byte, 6(8):36-48 1 August, 1981. 
			
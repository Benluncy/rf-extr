
 Minimum Cuts in Near-Linear Time David R. Karger* Abstract We significantly improve known time bounds 
for solving the min­imum cut problem on undirected graphs. We use a semi-duality between minimum cuts 
and maximum spanning tree packings com­bined with our previously developed random sampling techniques. 
We give a randomized rdgorithm that finds a minimum cut in an m­edge, n-vertex graph with high probability 
in O (m log3 n) time. We also give a simpler randomized algorithm that finds all minim­um cuts with high 
probability in O(n2 log n) time. This variant has an optimal MC parallelization. Both variants improve 
on the previous best time bound of O(n2 log3 n). Other applications of the tree-packing approach are 
new, nearly tight bounds on the num­ber of near minimum cuts a graph may have and a new data structure 
for representing them in a space-efficient manner. 1 Introduction The minimum cut problem has excited 
interest for many years as a fundamental graph optimization problem with numerous applica­tions. Initially, 
the problem was considered a harder variant of the s-t minimum cut problem and was solved in b(rnn2) 
time on m­edge, n-vertex graphs [FF62, GH61 ]. Improvements then followed: first to O(rrwz)-time [H094, 
N192a], meaning that minimum cuts were as easy to find as maximum flows; then to d(rzz)-time [KS93, KS95], 
showing they were significantly easier. In this paper we take the next nattrral step by giving an algorithm 
with an O(rn log3 n) rurming time. Initially perceived as a harder variant of the maximum flow problem, 
the minimum cut problem turns out to be solvable in near-linear time. Side effects of our anal­ysis include 
new combinatorial theorems on the structure, enumer­ation and representation of minimum cuts. We also 
give a relatively simple algorithm that runs in linear time on a large class of graphs MIT Laboratory 
for Computer Science, Csrnbridge, MA 02138. emaik kar9er@lcs .mit. edu URL http: / /theory. lcs. mi t. 
edu / karger. Research supperted kr part by ARPA contract NOOO14-95-1-1246 Permission to make digital/hanl 
copies of all or part of this material for personal or classroom use is grantad without fee provided 
that the copies are not made or distributed for profit or commercial advantage, the copy­ right notice, 
the titfe of the publication and its data appear, and notice is given that copyright is by permission 
of the ACM, Inc. To copy otherwise, to rapubtiab, to post on servers or to distribute to tista, requires 
specific nerrnission and/m fee...-. STOC 96, Philadelphia PA,USA e 1996 ACM 0-89791-785-5/96105. .$3.50 
and runs in O(rz2 log n) time on all graphs. This algorithm still dom­inates all previous ones and can 
also be parallelized optimally to yield the best %?.AfC algorithm for the problem. An interesting feature 
of our algorithm is that it is not funda­mentally based on either of the two previous methods for finding 
minimum cuts (namely flows and contractions). It thus introduces a third approach to finding minimum 
cuts in undirected graphs. 1.1 The Problem This paper studies the minimum cut problem. Given a graph 
with n vertices and m (possibly weighted) edges, we wish to partition the vertices into two non-empty 
sets so as to minimize the number (or total weight) of edges crossing between them. We use c to denote 
the value of this minimum cut. Throughout this paper, the graph is assumed to be connected, since otherwise 
the problem is trivial. We also require that all edge weights be non-negative, because oth­erwise the 
problem is ~P-complete by a transformation from the maximum-cut problem [GJ79, page 210]. We distinguish 
the min­imum cut problem from the s-t minimum cut problem in which we require that two specified verticess 
and tbe on opposite sides of the cuc in the minimum cut problem there is no such restriction. Application 
areas that use minimum cuts include compilation of parallel programs [Cha94], information retrieval [Bot93], 
network reliability analysis [Ks195], and cutting plane algorithms for com­binatorial optimization problems 
such as the Traveling Salesman Problem [DFJ54, LLKS85, PR90, App92] and others [PQ82]. The minimum cut 
problem was originally approached as a vari­ant of the s-t minimum cut problem and solved using flow 
tech­niques [FF62]. Gomory and Hu [GH61 ] showed how the problem could be solved by n flow computations; 
using present techniques this gives a time bound of d(rnn2). After a lengthy period of little progress, 
several new algorithms appeared. Hao and Orlin [H094] showed how the n flow computations could be performed 
in the time for one, improving the ruining time to ~(rnn). Gabow [Gab95] gave an alternative augmenting-path 
scheme that required O(rrzc) time on an unweighed graph with minimum cut c. The above approaches all 
use maximum flow techniques that treat undirected graphs as directed graphs (Gabow s algorithm packs 
directed trees rather than directed paths, but still addresses directed graphs). Recently a flowless 
undirected-graph approach based on edge contraction was discovered. If we can identify an edge that does 
not cross the minimum cut, then we can merge its endpoints into a single new vertex without affecting 
the minimum cut. Per­forming n 2 valid contractions will reduce the graph to two ver­tices, at which 
point there is only one nontrivial cut that must there­fore correspond to the minimum cut. Nagamochi 
and Ibarald [N192b, 56  N192a] devised a sparse certificate computation that found a con­tractible edge 
in O(m) time; this led to an O(mn)-time minimum cut algorithm. Karger [Kar93a] showed that random edge 
contrac­tion also worked well; this led to the first %?.,kfCalgorithm for the problem. Karger and Stein 
[KS95] improved the random contrac­tion approach to an algorithm running in O(n2 log3 n) time. 1.2 our 
Results In this paper we present a very different approach to minimum cuts that yields faster algorithms 
than were previously known. We use a semi-duality between minimum cuts and maximum packings of undirected 
spanning trees arguably a more natural dual problem for undirected minimum cuts than the directed flows 
or spanning trees of [H094, Gab95]. Our approach does not rely fundamentally on flows or edge contractions. 
For a weighted, undirected graph we give: A randomized algorithm that finds a minimum cut with con­stant 
probability in O(m log2 n) time and with high proba­bility in O(m log3 n) time. Asymptotically, this 
represents speedup by a factor of h(n) over the fastest previous algo­rithm on sparse graphs. A simpler 
algorithm that finds a minimum cut with constant probability in 0(TZ2) time and finds all minimum cuts 
with high probability in 0(n2 log n) time. While this is only a speedup of ~(log2 n) over the Contraction 
Algorithm [KS95], the new algorithm is quite simple, relying only on tinding least common ancestors and 
evaluating expression-trees, and may therefore outperform the Contraction Algorithm in practice. It runs 
in O(m) time on a large class of graphs. An optimally parallelized version of our simpler algorithm that 
runs in 0(log3 n) time using rz2/ log2 n processors. New bounds of El(n 12aJ) on the number of cuts with 
value at most a times the minimum. This improves on a previous best general bound of 0(n2e ) [Kar93a]. 
This bound is the first to match the step function behavior of known lower bounds. A new data structure 
that represents all minimum and near­minimum cuts. Besides being smaller than previous repre­sentations 
[KS95], this representation highlights certain struc­tural features of a graph s near-minimum cuts. 
 1.3 Our Methods We now summarize the approach of the paper. At its core is the fol­lowing definition: 
Definition 1.1 LetH and G be two connected graphs on the same vertices. We say that a cut in G k-respects 
H t~ it cuts at most k edges of H. We say that H k-constrains the cut in G. We show that for any graph 
G, we can find (via tree packing) a small set of spanning trees such that every minimum cut 2-respects 
some of the spanning trees. This lets us reduce to the following problem: find the minimum cut in G that 
2-respects a given span­ning tree. While this might appear a harder problem than the origi­nal, it turns 
out that the added constraints make the problem easier. Our scheme can bethought of as a variant of the 
branch and bound techniques used for hard optimization problems: we consider sev­eral families of added 
constraints, one of which is satisfied by the optimum solution. We can therefore find the optimum by 
solving each constrained optimization problem. To introduce our approach, in Section 2 we show that a 
maxi­mum packing of spanning trees always contains many trees that 2­constrain arty minimum cut. An immediate 
application of this ob­servation yields the tightest known bounds on the number of near­minimum cuts 
in a graph. Next we turn to the problem of actually finding the minimum cut. We note that it is sufficient 
to examine the trees of a maximum packing and find the minimum cut that 2-respects each tree. Al­though 
finding such a packing is hard, we show in Section 3 that Gabow s minimum cut algorithm [Gab95] or the 
Plotkin-Shmoys-Tardos fractional packing algorithm [PST91] can be used to find a packing of semi-disjoint 
trees that is sufficient for our purposes. Unfortunately, in a graph with minimum cut c, a maximum pack­ing 
contains c trees and finding them takes time proportional to c. To eliminate this factor, we use random 
sampling techniques we de­veloped previously [Kar94a, Kar94b] to reduce the running time to O(m+n log3 
n) and the number of trees in the packing to O(log n). It remains to solve a particular tree. We begin 
in Section 4 by showing how to find the smallest cut that l-respects a given tree in O(m) time. Our algorithm 
involves a simple dynamic program that determines the value of the cut induced by removing each edge 
of the given tree. Besides introducing our techniques, this algorithm can be used to find the minimum 
cut in O(m + n log3 n) time on a large family of dense graphs. In some cases we will not be able to find 
a tree that l-constrains the minimum cut, so we move on to finding the minimum cut 2­respecting a given 
tree. We present two solutions. In Section 5 we extend the dynamic program of Section 4 to compute the 
value of the cut induced by removing each pair of tree edges. The algorithm runs in El(TZ2) time-optimal 
for an algorithm that computes all (~) values. In Section 6, we also show how it can be parallelized 
opti­mally. The second algorithm, presented in Section 7, implicitly consid­ers all n2 pairs of tree 
edges without spending n2 time to do so. We show how dynamic tree algorithms [ST83] can be used to evaluate 
a particular tree in O(m. log2 n) time. The initial tree-packing step is the only one using randomiza­tion; 
all subsequent operations in the algorithm are deterministic. The fact that random sampling is used means 
that our algorithms, like those of [KS95], are Monte Carlo algorithms. Although the probability of success 
is high, there is no fast way to certify the cor­rectness of the final answer (indeed, the fastest known 
method is to use one of the deterministic minimum cut algorithms). 2 Combinatorics As a first application 
of the concept of respecting constraint trees, we tighten the bounds on the number of small cuts in a 
graph. Definition 2.1 A cut in G is a-minimum Zyits value is at most a times the minimum cut value. In 
[Kar93a, Kar94a], we proved that the number of a-minimum cuts in a graph is 0(n2a ). Others have since 
tightened this bound for small a: Nagamochi, Nishimura and Ibaraki [NN194] gave a bound of 0(n2 ) for 
the number of 4/3-minimum cuts, and subse­quently Henzinger and Williamson [HW95] showed that the num­ber 
of cuts strictly less than 3/2 times minimum is 0(n2 ). In an unweighed n-vertex cycle, any set of at 
most [2aj edges forms an a-minimum cut, Therefore, the number of a-minimum cuts can be as large as (J+(J 
e(nL2 )  + +(L) 57 We give an upper bound that is very close to this lower bound and is the first 
to match the step function behavior of the lower bound as a function of a. Theorem 2.2 The number of 
a-minimum cuts is at most 12a] +11 -2a [2:] 1+ 0(1)) ()  ProoR For simplicity, we focus on the case 
of o a constant inde­pendent of n. Assume first that G is unweighed. For 2m an integer, the claim is 
proven in [Kar93a], so assume not. A theorem of Nash-Williams [NW61] says that any graph with minimum 
cut c contains at least c/2 edge-disjoint spanning trees. Consider some a-minimum cut. Since this cut 
contains only ac edges and each edge is in only one of our spanning trees, the average number of cut 
edges in each spanning tree is at most 2a. It follows from Markov s inequality and the fact that [2al 
> 2cI that a con­stant fraction of the trees must contain at most k = 12aJ edges of the cut. In others 
words, every near-minimum cut corresponds to a set of k edges in a constant fraction of the trees. Since 
each tree con­tains at most (:) such sets of edges, an averaging argument shows there are O ((~)) cuts. 
For a more careful analysis that also handles the case of non­constant CY,we show that regardless of 
a very few cuts can cut fewer than 12a] edges in more than a small fraction of the trees; this lets us 
show as above that a constant fraction of the trees must have ex­actly 12c2] edges crossing the cut. 
0 3 Algorithms for Finding a Good Tree We now apply the ideas of the previous combinatorial proof algo­rithmically. 
We prove that in any graph, we can find a small set of trees such that the minimum cut 2-respects some 
of them. There­fore, we can find the minimum cut by enumerating only the cuts that 2-respect these few 
trees. Theorem 3.1 Given a graph G, in O(m + n log3 n) time we can construct a set of O (log n) spanning 
trees such thatthe minimum cut 2-respects 1/3 of them with high probability. Proofi In a previous paper 
[Kar94a], we showed how to construct, for any constant e, a skeleton graph H on the same vertices with 
the following properties: H has m = O(n log n) edges, the minimum cut of If is c = O(log n), the minimum 
cut in G corresponds (under the same vertex partition) to a (1 + e)-minimu-m cut of H. Perform the skeleton 
construction for e = 1/6. In the skeleton, per­form a modified version of our combinatorial proof. Suppose 
we found the c /2 disjoint trees in H guaranteed by Nash-Williams Theorem. Consider a minimum cut in 
G. By the skeleton construc­tion, it corresponds to a cut of at most (7/6)c edges in H. Since each tree 
in the packing contains at least one cut edge, at most 2/3 of the c /2 trees can contain more than 2 
cut edges. In other words, the (7/6) -mirrimum cut of H 2-respects 1/3 of the spanning trees. But this 
(7/6) -tninimum cut of H has the same vertex partition as the minimum cut of G, implying that the minimum 
cut of G 2-respects the same trees. Unfortunately, there is no sufficiently fast algorithm for finding 
the c /2 undirected spanning trees guaranteed by Nash-Williams Theorem (the fastest runs in ~(min(mn, 
m2/fi)) time [GW92]). However, we can work around this problem using Gabow s algo­rithm [Gab95] for packing 
directed spanning trees. Replacing each undirected graph edge with two directed edges, one in each direc­tion, 
gives a directed graph with minimum (directed) cut c . In such a graph, Gabow s algorithm runs in O(m 
c log n) = O(n log3 n) time and finds a collection of c disjoint spanning trees on the di­rected edges. 
If we now ignore edge directions, we find that we have c spanning trees such that each edge of G is in 
at most 2 spanning trees. The same averaging argument as in Theorem 2.2 shows that these spanning trees 
will suffice. Alternatively, extending the above argument, we can show that in fact it is sufficient 
to construct an approximately maximum ~rac­tional packing of undirected spanning trees. Afterwards, sampling 
O(log n) times from the packing with probability proportional to the packing weights will yield the desired 
collection of trees, The desired packing can be constructed using an algorithm of Plotkin, Shmoys and 
Tardos [PST91]. It is found via 0(log2 n) minimum spanning tree computations. Since minimum spanning 
tree compu­tations require O(rn ) time [KKT95] the claimed time bound fol­lows. 0 The remainder of this 
paper is devoted to the following ques­tion: given a tree, find the minimum cut that 2-respects it. Apply­ing 
the solution to the O (log n) trees described above identifies the minimum cut. 4 Minimum Cuts that l-respect 
a Tree To introduce our approach to analyzing a particular tree, we con­sider a simple special case: 
a tree that 1-constrains the minimum cut. In other words, there is one tree edge such that, if we remove 
it, the two resulting connected subtrees correspond to the two sides of the minimum cut. We prove the 
following: Lemma 4.1 The values of all cuts that l-respect a given spanning tree can be determined in 
O(m + n) time. Corollary 4.2 The minimum cut that l-respects a given spanning tree can be found in O(m 
+ n) time. We begin with some definitions. Suppose that we root the tree at an arbitrary vertex. Definition 
4.3 V1 is the set of vertices that are descendants of v in the rooted tree, including v. Definition 4.4 
VT is the set of vertices that are ancestors of v in the rooted tree, including v. Note that VJn VT= 
v. Definition 4.5 C(X, Y) is the total weight of edges crossing from x to Y. Thus C(v, w) is the weight 
of the edge (v, w) is it exists, and O otherwise. Definition 4.6 Given a vertex set S, C(S) is the value 
of the cut whose one side is S, i.e. C (S, ~). Once we have rooted the tree, we see that the cuts that 
l-respect the tree have the form C(V1 ) for vertices v. Using this observation, we now prove Lemma 4.1. 
 58  4.1 l-Respectinga Path As a first step, suppose the tree is in fact a path VI,. . . . Wn rooted 
atvl. Recompute alI values C(v~) inlinear time via a dynamic program. First compute C(v~, v~) and C(v~, 
v~) foreach v,; this takes one O(nz)-time traversal of the vertices adjacency lists. We then have the 
following recursive definition of cut values: C(v:) = C(vn, v:) C(vf) = C(v:+l) +c(wt,v:) c(vi,v:) This 
recurrence follows from the fact that when we move v, from below the cut to above it, the edges from 
vi to its descendants be­come cut edges while those from v, to its ancestors are removed from the cut. 
It follows that allncut vahsescan be computedin O(n) time by working up from V.. We now extend this approach 
from paths to general trees. Definition 4.7 Given afwction f on the vertices of a tree, the treefix 
sum of jr, denoted f 1, is the finction f (v) = ~ f(w) WEV1 Lemma 4.8 Given the values of a~nction f, 
all values of f 1 can be computed in O(n) time by working up from the leaves. We now compute the values 
C(vl) via treefix sums. Let b(v) denote the (weighted) degree of vertex v. Let p(v) denote the total 
weight of edges whose endpoints least common ancestor is v. Lemma 4.9 C(V1) = 61(v) -2p1(v). ProoE JL 
(v) counts all the edges leaving descendants of v. This correctly counts each edge crossing the cut defined 
by V1, but also double-counts all edges with both endpoints descended from v. But an edge has both endpoints 
descended from v if and only if its least common ancestor is in V1. Thus the total weight of such edges 
is pi(v). 0 Now note that 6(v) and p(v) can both be computed in O(m) time. Computing 8(.) is trivial, 
Computing p(.) is trivial if we know the least common ancestor of each edge, but this can be determined 
in O(m) time [GT85]. From these quantities, according to Lemma 4.8, two O(n) -time treefix computations 
suffice to determine tbe mini­mum cut This proves Lemma 4.1. 4.2 A Special Case Unfortunately, Theorem 
3.1 does not guarantee that any of the trees we find will l-constrain the cut. However, the algorithm 
for cuts 1­respecting a tree may still be useful in practice. The Nash-Williams lower bound of c/2 trees 
in a graph with minimum cut c is often pessimistic. The number of trees in the maximum packing maybe 
as large as c (the exact number is determined by the value of the minimum quotient of the graph see [NW61, 
Kar94b, Kar93b] for details). Call G an c-fat graph if its maximum packing contains more than (1 + e)c/2 
trees. Theorem 4.10 For any constant e, the minimum cut in an e-fat graph can befound with constant probability 
in O(m + n log3 n) time and thus with high probability in O(m log n + n log3 n) time. Proofi We have 
shown [Kar93b] that if a graph is c-fat then so is any skeleton we construct from it. Thus, Theorem 3.1 
can be adapted to show that we can find a set of trees such that an e-fraction of them l-constrain the 
minimum cut with high probability (note that the maximum tree packing in the skeleton can be approximated 
by the packing algorithm of[PST91 ]), Given such a tree, we can use the algorithm above to identify the 
minimum cut in linear time. The constant-probability argument follows by selecting a random tree and 
running our algorithm on it. The high probability bound fol­lows from selecting O(log n) random trees 
and running our algo­rithm on each. On sparse graphs, the bottleneck is now the packing algorithm of 
[PST91]. This heuristic is actually self certifying. Once we have used the tree to find the minimum cut 
in the graph, we can compare the size of our tree-packing to the corresponding cut c in the skeleton. 
If the packing has (1 + C)C /2 trees, then we know the skeleton is e-fat. By a Theorem of [Kar93b], with 
high probability the skeleton is e-fat if and only if the original graph is. 0 5 Minimum Cuts that 2-respect 
a Tree in 0(n2 ) Time Of course, not all graphs are e-fat (one counterexample is an un­weighed cycle), 
We must therefore consider the possibility that the minimum cut l-respects none of the O(log n) trees 
in our packing. However, we know that it 2-respects many of those trees and so we now turn to that case. 
We prove the following: Lemma 5.1 The values of all cuts that 2-respect a given tree can be found in 
0(n2) time. An immediate corollary (using Theorem 3.1 as in Theorem 4. 10) is the following: Theorem 
5.2 There is a Monte Carlo algorithm that finds a mini­ mum cut with constant probability in O n2 ) time 
andjnds all min­i imum cuts with high probability in O (n log n) time. We now prove the lemma. After 
rooting tbe given tree and ap­plying the algorithm of Section 4, we can assume that the minimum cut cuts 
exactly two tree edges. These two edges are the parent edges of two vertices v and w. Definition 5.3 
We say vertices v and w are incomparable, writing vLw, t~v$!wLandw @vi. In other words, v and w are not 
on the same root-leaf path. Suppose the minimum cut that 2-respects the tree cuts the parent edges of 
vertices v and w. If v 1 w, then the parent edges of v and w define a cut C(V1 U w~ ). If (without loss 
of generality) w c V1, then their parent edges define a cut with value C(V1 w J). We consider the first 
case; the nearly identical treatment of the second will be discussed in the full paper. Assuming v L 
w, C(VJ u w~) = C(VJ) +C(WJ) 2C(VJ, W1) since C(V1 ) and C(WJ) each include the edges of C(V1, W1 ) 
that should not be counted in C(V1 U W1 ). Since the values C (V1 ) are already computed for all v, we 
need only compute C(v L, w 1) for ev­ery v and w. This can be done using tree fix sums as in the previous 
section. First, let f.(w) = C(IJ, W) be the capacity of the edge connecting v to w, or Oif there is 
no such edge. It follows that f;(w) = C(LJ, WJ). 59 Therefore, we can determine all nz values gw(v) 
= C(v,d) in O (n2 ) time by performing n treefix computations, one for each fv. At this point, since 
g~(v) = C(vl,d), we can determine all the desired quantities with another n treetix sums. 5.1 Data Structures 
Previously, a linear-space representation of all minimum cuts was known [DKL76], but the best representation 
of approximately min­imum cuts required ~ (nza ) space [KS95]. We can now do better. Theorem 5.4 Given 
a graph with k a-minimum cuts, a < 3/2, there is a data structure that represents them in O(k + n log 
n) = O(n2 ) space that can be constructed in O(n2 log n) time. Proofi The output of the above algorithm 
can serve as a data strnc­ture for representing the near-minimum cuts that 2-respect the tree it analyzes. 
We simply list the pairs of edges that together induce a near minimum cut. Now consider any o < 3/2. 
We know that with high probability every a-minimum cut 2-respects one of the O(log n) trees we inspexl 
and will therefore be found. 0 An extension represents a-minimum cuts in 0(nL2~J ) space by considering 
sets of 3, 4, or more constraint-tree edges. 6 Parallel Algorithms We can parallelize the above algorithms. 
Note that they involve two main steps: tinding a proper packing of trees and finding the mini­mum cut 
constrained by each tree. Recall from Theorem 3.1 that the algorithm of [PST91] can be used to find a 
packing via 0(log2 n) minimum spanning tree computations. Since the desired minimum spanning tree can 
be found in MC with m = O(n log n) pro­cessors using an algorithm of Cole, Klein, and Tarjan [CKT94], 
the packing algotithm can be parallelized. We must then parallelize the above algorithms for a particular 
tree. But the only computations performed there are least common ancestor lookups, which can be performed 
optimally in parallel by, e.g., the algorithm of Schieber and Vishkin [SV88]; and treefix sum computations, 
which can be performed optimally in parallel as de­scribed in [KR90, Section 2.2.3]. Corollary 6.1 Minimum 
cuts can befozmd in R.AfC with highprob­ ability using n2 / log2 n processors and 0(log3 n) time for 
general graphs and using m processors fore-fat graphs. 7 Near-Linear Time We now reconsider the algorithm 
of Section 5 and show how its ob­jective can be achieved in O(rn log2 n) time on any given tree. Us­ing 
the same techniques as Theorem 4.10 will yield our main theo­rem: Theorem 7.1 The minimum cut of a graph 
can be found with con­stant probability in O(m log2 n+ n log3 n) time or with high prob­ability in O 
(m log3 n) time. As in Section 5, we consider the case of minimizing C(VJ U W1 ) for v L w; the almost 
identical case of v E W1 is deferred to the full paper. Rather than computing C(W1U W1) for all pairs 
rJand w, which clearly takes El (nz ) time, we settle for finding for each w a vertex w that minimizes 
C(V1 UIO1 ). This will clearly let us identify the minimum cut. Recall that for any vertices v -L w, 
C(vl Uwl) =C(VJ) +C(WJ) 2C(VJ, WJ). We now factor out the contribution of C(VJ ) to this quantity: 
Definition 7.2 The u-precut at w, denoted C o(w), is the value C(VJ UWJ) C(t+) = C(WJ) 2C(WL, WJ) if 
w 1 v and co otherwise. Definition 7.3 The minimum v-precut, denoted C., is dejirred as min{Cv(w) \ 3(v 
, w ) c E, v VL, w c W1} The point of this definition is to notice that for a given v, only certain 
vertices w are candidates for forming the minimum cut with v, as is seen in the foIlowing lemma. Lemma 
7.4 The minimum cut is mino C(W1 ) + Cu. Praofi Let the minimum cut be induced by v and a vertex w 1 
v. It suffices to show that w is in the set that we minimize over to define CV. But this follows from 
the fact that each side of the minimum cut induces a connected subgra h of G, for this implies that there 
? must bean edge (v , w ) from v to w~. To see that each side of the minimum cut must be comected, note 
that if one side of the mini­mum cut has two disconnected components then we can reduce the cut value 
by moving one of these components to the other side of the cut. 0 Suppose that we have already used the 
linear-time procedure of Section 4 to compute the values C(VL ) for every v. It follows from Lemma 7.4 
that it suffices to compute Co for every vertex v: the minimum cut can then be found in O(n) time. We 
now show how the minimum precuts can be computed in O(m log2 n) time on any tree. We first show that 
we can find Cu for a leaf v in time pro­portional to its degree. We then extend this approach to handle 
a bough a path of vertices with only one child per vertex. Finally, we handle general trees by repeatedly 
pruning boughs. We begin by giving each vertex w a variable val [w]. While working on vertex v, this 
variable will be used to accumulate Cv (w). Initially, we set val[w] = C(WJ). 7.1 A Leaf First consider 
a particular leaf v. To compute Cu, consider the fol­lowing procedure: 1. For ~ach vertex w, subtract 
2C(V, WJ ) from val[w] (so that val[w] = CV(W)). 2. C. is the minimum of val[w] over all w 1 v.  The 
correctness of this procedure follows from Lemma 7.4, the ini­tialization of val[w], and the definition 
of CW. To implement this procedure efficiently, we use the dynamic tree data structure of Sleator and 
Tarjan [ST83]. Given a tree, this struc­ture supports among others the following operations on a node 
v: 60  AddPath(w, z): add z to val[u] for every u e WT. I Procedure MinPrecut(v) MinPath(w): return 
miW~ val[u] as well as the w achieving this I lminimum. if v is the leaf of the bough call LocalUpdat 
e (w) (also computes Ca) Each such dynamic tree operation takes O(log n) amortized time else steps. Let 
u be the child of v We use dynamic trees to compute Co. Recall that C(v, w) is the c1 t MinPrecut. (u) 
(updates val [.]) weight of the edge connecting vertices v and w, or Oif no such edge cz -LocalUpdate(v) 
exists. Apply procedure LocalUpdat e from Figure 7.1. return min(cl, cz ) Procedure LocalUpdate(v) 1. 
Call AddPath(v, m). 2. foreach edge (v, u), call AddPath(u, 2C(v, u)). 3. foreach edge (v, u), call 
MinPath(u) 4. return therninimum result of Ste~3.  Figure 1: procedure LocalUpdate Lemma 7.5 AfterLocalUpdate 
returns, webave val[w] = Cv(w) Proofi Step lassigns aninfinite val[.]toeve~ ancestor ofv. Next, note 
that 2C(v, u) issubtracted in Step 2fromeveryval[w] such thatuc; W1. Therefore, thetotal amount subtracted 
fromval[w]is 2C(v, wJ), asrequired in Definition 7.2. It follows thatafter Step2, val[w] =Cv(w). 0 Lemma 
7.6 LocalUpdate(v) cal~edorr aleafvreW?tsCu. Proofi Step 3 minimizes over ancestors of neighbors of 
v. Accord­ing to Definition 7.3 this will identify Co. 0 It follows that for a leaf v with d incident 
edges, we can find Cv via O(c!) dynamic tree operations that require O(dlogn) time.  7.2 A Bough We 
generalize the above approach. Let a bough be a maximal path starting at a leaf and traveling upwards 
until it reaches a vertex with more than one child (this vertex is not in the bough). Lemmt+ 7.7 Letvbea 
vertex withauniquechildu. Then either C. =Cu, orelse Cv = Cu(w)for someancestor wofaneighbor of vertex 
v. In other words, given the value Cu, we need only check ancestors of neighbors of v to determine Cv. 
 Proofi Suppose C. = Co(w) for a certain w. If w is not an ancestor of a neighbor of v, then C(V1, wl) 
= C(U1, WL). It follows that Cti < Cti(w) = Cv(w) = Cu. But we always have C(u, W1) ~ C(U, w ~), so we 
know that C. 2 C.. Therefore C. = Co. 0 We use the above lemma in an algorithm for processing an entire 
bough. Given a bough with d edges incident on all its vertices, we show how to process all vertices in 
the bough in O(d log n) time. We use the recursive procedure MinPrecut from Figure 7.2. This procedure 
is initially called on the topmost vertex in the bough. We claim that MinPrecut computes the desired 
quantity. To prove this, we prove a stronger statement by induction: Figure 2: procedure MinPrecut Lemma 
7.8 A call to MinPrecut (v) 1. returns Cu and 2. sets val [w] = C. (w) for each w.  Proof: By induction. 
The base case is for v a leaf, and follows from Lemmas 7.5 and 7.6. Now suppose v has child u. After 
call­ing MinPrecut (u), we know by induction that val[w] = Cu (w). Therefore, Item 1 follows because 
the body of MinPrecut (v) up­dates val[w] to be val[w] - 2C(v, wl) = c.(w) 2C(V, Wl) = (C(WJ) 2c(u~, 
wJ)) 2C(V>W1) = C(WJ) 2C(V uu~,w~) = C(WJ) 2c(vJ, w~) = c (w) We now prove Item 2. Suppose v has 
child u. According to Lemma 7.7, there are two possibilities for Co. One possibility is that CL = Cu. 
But by induction, the recursive call to MinPrecut (u) sets c1 = C.. On the other hand, if Cu # Cti, then 
by Lemma 7.7, Cv = Cu (w) for an ancestor of a neighbor of v. But then cz is set to Cv when we call LocalUpdat 
e (w). In either case, the correct value is min(cl, CZ). 0 Based on this lemma, the correctness of the 
algorithm for find­ing all minimum precut values in a bough is immediate.  7.3 A Tree We now show how 
the minimum cut 2-respecting a tree can be eval­uated by several computations on boughs. Theorem 7.1 
then fol­lows the same way as did Theorem 4.10. Lemma 7.9 The minimum cut that 2-respects a given spanning 
tree can be found in O (m log2 n) time. Proofi We first add a stack to the computation for boughs in 
the previous section: this stack remembers all the changes made in the computation, meaning that when 
we finish we can unroll the com­putation in the same time it took to execute it and end up with our original 
tree. Therefore, we can process a collection of boughs in sequence since each computation on a bough 
starts with the val[w] variables back at their initial values C(WL ). Now note that every edge of G is 
incident on at most 2 boughs. It follows that the total size (number of incident edges) of all boughs 
of our tree is O(m). Therefore, the time to process all boughs of the tree with the algo­ rithm of the 
previous section is O(m log n). 61 Once we have processed all boughs, we know that we have found [Bot93] 
the minimum cut if even one of the two tree-edges it cuts is in a bough. If not, we can contract each 
bough of the tree (that is, merge all vertices in a bough into the vertex from which that bough de­scends) 
without affecting the minimum cut. This can be done in O(m) time. It leaves us with a new tree that 2-constrains 
the min­ [Cha94]imum cut of the contracted graph. Furthermore, every leaf of the new tree had at least 
two descendants in the original tree (else it [CKT94] would have been in a bough). This means the new 
tree has half as many leaves as the old. It follows that after O(log n) iterations of the procedure for 
boughs followed by contractions of boughs, we will have reduced the number of tree-leaves to O, meaning 
we will have found the minimum cut. 1 [DFJ54] 8 Conclusion [DKL76]This paper has presented two algorithms 
for the minimum cut prob­lem. The first is quite simple and runs in O(n2 ) time (and on fat graphs in 
O(m) time) where the constant hidden by the O-notation is apparently small. It is therefore likely to 
be practical and may run faster than the Recursive Contraction Algorithm of [KS95]. The second algorithm 
is relatively complicated, but holds out the pos­[FF62] sibility that the minimum cut problem can be 
solved in linear time. Several probably unnecessary logarithmic factors remain in the run­ning time, 
suggesting the following improvements: [Gab95] Give a dynamic path-minimization data structure taking 
con­stant amortized time per operation. This would reduce the running time by a log n factor. Extend 
the approach for boughs directly to trees in order to [GH61] avoid the O(log n) different phases needed 
for pruning boughs. This too would reduce the running time by a log n factor.  Give a deterministic 
linear-time akzorithm for finditw a tree [GJ79] that the minimum cut 2-respects. ~his would elimi~ate 
the log n factor required by our randomized approach. Note that randomization is used only to find the 
right trw, all remain­ing computation is deterministic. Thus any o(mn)-time al­gorithm for finding a 
good tree would yield the fastest known [GT85] deterministic algorithm for minimum cuts. Another question 
is whether the near-linear time algorithm can [GW92] be parallelized. This would require finding a substitute 
for the se­quence of dynamic updates the algorithm performs. The tree-packing concept has also led to 
some progress on the enumeration of near-minimum cuts. The gap between upper and [H094]lower bounds is 
now extremely small and should be eliminated en­tirely. Except for one graph on 7 vertices [NN194], the 
cycle appears to have the most small cuts, so it is the upper bound which should be improved. [HW95] 
9 Acknowledgments Thanks to Robert Tarjan for some helpful references and comments [Kar93a]on dynamic 
merging. References [K@3b] [ACM93] ACM-SIAM. Proceedings of the 4th Annual ACM-SIAM Symposium on Discrete 
Algorithms, kmuary 1993. [App92] David Applegate. AT&#38;T Bell Labs, 1992. Personal Communication. Rodrigo 
A. Botafogo. Cluster anal sis for hypertext m? systems. In Proceedings of the 16 Annual Interna­tional 
ACM SIGIR Conference on Research and Devel­opment in Information Retrieval, pages 116-125, June 1993. 
S. Chaterjee, April 1994. Personal communication. Richard Cole, Philip N. Klein, and Robert E. Tarjan. 
A linear-work parallel algorithm for finding minimum spanning trees. In Proceedings of the 6th Annual 
ACM-SIAM Symposium on Parallel Algorithms and Architec­tures, pages 11 16. ACM, 1994. G. B. Dantzig, 
D. R. Fulkerson, and S. M. Johnson. So­lution of a large-scale traveling salesman problem. Op­erations 
Research, 2:393-410, 1954. Efim A. Dinitz, A. V. Karzanov, and Micael V. Lomonosov. On the structure 
of a family of minimum weighted cuts in a graph. In A. A. Fridman, editor, Studies in Discrete Optimization, 
pages 290-306. Nauka Publishers, 1976. Lester R. Ford, Jr. and D. R. Fulkerson. Flows in Net­works. Princeton 
University Press, Princeton, New Jer­sey, 1962. Harold N. Gabow. A matroid approach to finding edge connectivity 
and packing arborescences. Journal of Computer and System Sciences, 50(2):259 273, April 1995. A preliminary 
version appeared in STOC 1991. R. E. Gomory and T. C. Hu. Multi-terminal network flows. Journal of the 
Society of Industrial and Applied Mathematics, 9(4):55 1-570, December 1961. Michael R. Garey and David 
S. Johnson. Comput­ers and Intractability: A Guide to the Theory of NP-Completeness. W. H. Freeman and 
Company, San Fran­cisco, 1979. Harold N. Gabow and Robert E. Tarjan. A linear time al­gorithm for a special 
case of disjoint set union. Journal of Computer and System Sciences, 30209 221, 1985. Harold N. Gabow 
and Herbert H. Westermann. Forests, frames, and games: Algorithms for matroid sums and applications. 
Algorithmic, 7:465497, 1992. Hao and Orlin. A faster algorithm for finding the min­imum cut in a directed 
graph. Journal of Algorithms, 17(3):424-446, 1994. A preliminary version appeared in SODA 1992. Monica 
Henzinger and David P. Williamson. On the number of small cuts in a graph. Technical Report 95­1486, 
Cornell University, 1995. David R. Karger. Globat rein-cuts in ~C and other ramifications of a simple 
mincut algorithm. In Proceed­ings of the 4th Annual ACM-SIAM Symposium on Dis­crete Algorithms [ACM93], 
pages 21 30. David R. Karger. Random sampling in matroids, with applications to graph connectivity and 
minimum span­ning trees. In Proceedings of the 34th Annual Sympo­sium on the Foundations of Computer 
Science, pages 84-93. IEEE, IEEE Computer Society Press, November 1993. Submitted for publication.. 62 
 [Kar94a] David R. Karger. Random sampling in cut, flow, and network design problems. In Proceedings 
of the 26th ACM Symposium on Theoty of Computing, pages 648­657. ACM, ACM Press, May 1994. Submitted 
for pub­lication.. [Kar94b] David R. Karger. Random Sampling in Graph Opti­mization Problems. PhD thesis, 
Stanford University, Stanford, CA 94305, 1994. Contact at karger@lcs. mi t. edu. Avail­able by ftp from 
theory. lcs. mi.t. edu, directory publkarger. [Kar95] David R. Karger. A randomized fully polynomial 
ap­proximation scheme for the all terminal network relia­bility problem. In Proceedings of the 27th ACM 
Sym­posium on Theory of Computing, pages 11-17. ACM, ACM Press, May 1995. [KKT951] David R. Karger, Philip 
N. Klein, and Robert E. Tar­jan. A randomized linear-time algorithm to find mini­mum spanning trees. 
Journal of the ACM, 42(2):321­328, 1995. [KR90] Richard M. Karp and Vijaya Ramachandran. Parallel algorithms 
for shared memory machines. In Jan van Leeuwen, editor, Handbook of Theoretical Computer Science, volume 
A, pages 869-932. MIT Press, Cam­bridge, MA, 1990. [KS93] David R. Karger and Clifford Stein. An ~(n2) 
algo­rithm for minimum cuts. In Proceedings of the 25th ACM Symposium on Theoty of Computing, pages 757­765. 
ACM, ACM Press, May 1993. [KS95] David to the 1995. SODA R. Karger and Clifford Stein. A new approach 
minimum cut problem. Journal of [he ACM, To appear. Preliminary portions appeared in 1992 and STOC 1993. 
[LLKS85] Eugene L. Lawler, J. K. Lenstra, A. H. G. Rinooy Kan, and David B. Shmoys, editors. The Traveling 
Salesman Problem. John Wiley &#38; Sons, 1985. [N192a] Hiroshi Nagamochi and Toshihide Ibaraki. Com­puting 
edge connectivity in multigraphs and capaci­tated graphs. SIAM Journal of Discrete Mathematics, 5(1):54-66, 
February 1992. [N192b] Hiroshi Nagamochi and Toshihide Ibaraki. Linear time algorithms for finding k-edge 
connected and k-node connected spanning subgraphs. Algorithmic, 7:583­596, 1992. [NN194] Hiroshi Nagamochi, 
Kazuhiro Nishimura, and Toshi­hide Ibaraki Computing all small cuts in an undirected network. Technical 
Report 94007, Kyoto University, Kyoto, Japan, 1994. [NW61] C. St. J. A. Nash-Williams. Edge disjoint 
of finite graphs. Journal of the London Socie~, 36:445-450, 1961. spanning trees Mathematical [PQ82] 
J. C. Picard and M. Queyranne. Selected applications of minimum cuts in networks. I.N. 110.R: Canadian 
Jour­nal of Operations Research and Information Proces­sing, 20,394-422, November 1982. [PR90] M. Padberg 
and G. Rinaldi. An efficient algorithm for the minimum capacity cut problem. Mathematical Pro­gramming, 
47:19-39, 1990. [PST91] Serge Plotkin, David Shmoys, and Eva Tardos. Fast ap­proximation algorithms for 
fractional packing and cov­ering problems. In IEEE Symposium on Foundations of Computer Science (FOCS), 
1991. [ST83] Daniel D. Sleator and Robert E. Tarjan. for dynamic trees. Journal of Computer ences, 26(3):362-391, 
June 1983, A data structure and System Sci­ [SV88] Baruch Schieber and Uzi Vishkin. On finding lowest 
common ancestors: Simplification and parallelization. SIAM Journal on Computing, 17: 1253 1 262, Decem­ber 
1988.  63   
			
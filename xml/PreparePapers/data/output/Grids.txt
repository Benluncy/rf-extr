
 Grids: A New Program Structuring Mechanism Based on Layered Graphs Harold L. Ossher Computer Science 
Department Stanford University, Stanford, CA94305 1. Introduction The structure of a computer program, 
and the extent to which that structure is visible, dramati- cally affect the clarity of the program. 
Clarity, in turn, affects other important attributes such as reliability and modifiability. For this 
reason, structure and the specification of structure are of central importance to programming. Programming 
languages contain structuring mechanisms to provide a framework within which to structure programs. One 
of the primary pur- poses of a structuring mechanism is to document structure in a clear and concise 
manner. Equally important, the structuring mechanism must en-force the documented structure, ensuring 
that the program does indeed conform to the structure specified. A structuring mechanism should also 
be sufficiently rich to cope with the wide diversity of program structures that rise in large systems. 
Tradition ! structuring mechanisms fall into two categories: nesting schemes and mechanisms in- volving 
separate modules. Nesting schemes can specify and enforce hierarchical structures, and document them 
reasonably well. They cannot, however, specify more general structures. Mechanisms involving separate 
modules can specify and enforce ~rbitr ry structures, provided module interconnections are specified 
explicitly by some means such as import and export lists. They do not, however, make the specified structure 
readily visible, primarily due to excessive com-plexity and lack of explicit grouping. The tradi-tional 
mechanisms thus have largely complemen- tary strengths and weaknesses, which suggests the possibility 
of single mechanism that has the strengths of both: the ability to specify and enforce Permtnnton to 
copy vithout fee all or part of thin material il granted provided that the copien are not made or distributed 
for direct comaercinl mivantage, the ACll copyright notice and the title of the publi-cation and itn 
date appear, and notice in given that copying in by permission of the Ansociation for Computing Machinery. 
To copy otherwine, or to republish, requires fee and/or npecific perainelon. &#38;#169; 1983 ACM 0-89791-125-3/84/001/001 
! $00.75 11 arbitrary structures, and to document them in a clear and concise manner. This paper proposes 
such a mechanism, called the grid. The grid mechanism was designed as part of the Fable language for 
specifying integrated circuit fabrication processes [7]. Such processes, as well as the fabrication equipment 
that performs them, are best described at multiple levels of abstraction. At the same time, each step 
of a process and each piece of equipment is complex and structured, and is best treated as n object. 
A Fable program is thus an object-oriented program in which objects are described at multiple levels 
of abstraction. A natural and convenient model for the structure of such a program is a layered graph, 
in which each layer corresponds to an abstraction level. Layered graph structures occur whenever levels 
of abstrac- tion are used; other areas in which they are com- mon are VLSI design and communication protocols. 
The grid mechanism is based on the layered graph model, and is able to specify ar-bitrary layered graph 
structures in a clear and con- cise manner. The grid mechanism has a number of additional important features, 
many of them novel. It is able to specify multiple views of objects, multiple im- plementations of specifications, 
and multiple relationships between the parts of a program. It is language-independent, and can be used 
unchanged to specify the structure of programs in different programming languages. A grid is textually 
sup rate from the program whose structure it specifies, so it can be created before the program is written, 
and then used to check that the develop- ing program conforms to the specified structure at all times. 
These features enhance the usefulness of the grid, though its chief advantage rum ins its ability to 
specify layered graph structures in a con- cise and read hie fashion. The remainder of this section introduces 
some important concepts and terminology, as well as a This research was supported in part by the Defense 
Ad- vanced Research Projects Agency under Contract No. MDA 003-80-C-0432. running example that is used 
throughout this paper. Section 2 describes other work related to the grid mechanism. Section 3 then discusses 
the specification of layered graph structures, and sec- tion 4 gives details of the grid mechanism itself. 
 1.1. Structure and Structuring Mechanisms A computer program is a collection of textual constructs, 
such as modules, procedures, state-ments and expressions. The structure of the program is determined 
by the organisation and in-teractions of its constructs. There are many dif- ferent types of interaction 
between constructs: one construct may contain another, refer to a type defined in another, invoke a procedure 
defined in another, etc. It is convenient to characterise each type of interaction as a separate relation, 
allowing familiar notation and terminology to be used. The task of a structuring mechanism is to specify 
the organisation and interactions of program constructs. The most critical issue in the specification 
of oiganisation is grouping: identifica-tion of collections of constructs that form cohesive groups is 
a great aid to apprehending structure. The most critical issues in the specification of in- teractions 
are generality and complezity: it must be possible to specify the wide variety of inter- actions that 
occur in large programs, yet in such a way that the specification is not unintelligibly complex. This 
paper is concerned with structuring mechanisms appropriate for use with object-oriented programs in which 
multiple views of ob- jects are specified. Such programs describe and manipulate a large number of objects, 
some or all of which are described from multiple points of view. For example, objects in an electronic 
mail system include messages and name tables; from the point of view of the user a message is a piece 
of text, from the point of view of the mail system it might be a structure consisting of a source, routing 
information, time stamp and text, and from the point of view of the underlying network software it might 
be a collection of packets. Multiple views of objects arise whenever multiple levels of abstrac- tion 
are used: each level of abstraction corresponds to a viewpoint. Multiple views also arise when a shared 
object is used in different ways by different users: each user has its own view of the shared ob- ject. 
Each view of an object is specified by means of a programming language construct called a specification, 
and is implemented, in terms of other views of the same object, or perhaps in terms of other objects, 
by means of one or more con-structs called bodies. Examples of specifications are Ada package specifications 
and Mesa interface modules; examples of bodies are Ada package bodies and Mesa program modules [6, 12]. 
The no-tion of separating specification and implemerit~/tion was pioneered in the data abstraction languages 
CLU and Alphard, and has since been widely adopted [5, 13]. Multiple bodies associated with a single 
specification describe alternative implemen- tations of that specification. A single specification together 
with all the bodies that implement it are collectively referred to as a unit. The structure of an object-oriented 
program with multiple views is determined by the organisation and interactions of its units. Fable programs 
describing integrated circuit fabrication processes are object-oriented programs with multiple views, 
and the paper introducing Fable contains some further discussion and ex-amples of such programs [7]. 
Further discussion and an extensive bibliography appear in the paper introducing the Paragon language 
[11]. Multiple views of objects can be specified in Paragon using refinement of specifications, and the 
language al- lows great flexibility in specifying their implemen- tation,   osaI DB Figure 1-1, Two 
Packages Sharing a Database Example 1-1: An object-oriented program with multiple views is described 
here and used as a running example throughout this paper. It is a simple case of a shared resource being 
used in different ways by different users. The program consists of ten objects: An extremely simple, 
in-core database, db, consisting of a network of named, at-tributed nodes. It provides operations create, 
destroy, fetch and store, and sup- ports attributes p, q and r. * Two users of db, a and b: a can use 
all the operations provided by db, and can manipulate properties p and q; b can use the fetch and store 
operations only, and can manipulate properties p and r. Two objects, hash and random; used to implement 
db. , Objects values, alists, lists, pairs and strings that export data types for general use and are 
referred to as utilities. The interactions between a, b and db are il-lustrated in fig. 1-1. Three different 
views of db are thus present in this example: e The complete view, DB, containing details of all the 
operations and attributes. 12  a's view, DBA, containing just those as-pects of db that are visible 
to a.  b's view, DBB, containing just those as-pects of db that are visible to b.  Three units describe 
these views, each consist- ing of an Ads package specification and a single body. The specifications 
are shown in fig. 1-2. The bodies of DBA and DBB implement their views in terms of the complete view, 
DR, and the body of DB implements the complete view in terms of the objects hash, values, alist~ and 
strings. Each of the other objects is described by means of a single unit: the names of these units are 
A, B, 1t, R, V, AL, L, P and S, corresponding to objects a, b, hash, random, values, aliats, lists, pairs 
and strings, respec-tively. These units are not shown, due to lack of space. with V, S; use V, S; package 
DB is type attribute is (p, q, r); procedure create(node: string); procedure destroy(node: string); function 
fetch(node: string; star: attribute) returns value; procedure store(node: string; attr: attribute; yah 
value); end DB; with V, S; use V, S; package DBA is type attribute is (p, q); procedure create(node: 
string); procedure destroy(node: string); function fetch(node: string; attr: attribute) returns value; 
procedure store(node: string; afar: attribute; val: value); end DBA; with V, S; use V, S; = package DBB 
is type attribute is (p, r); function fetch(node: string; attr: attribute) returns value; procedure store(node: 
string; star: attribute; val: value); end DBB; Figure 1-2: Specifications of DR, DBA and DBB Two relations 
on units are of importance in this example, and indeed in most programs in which specifications and implementations 
are separated. The relation spec uses relates the unit containing a specification to all units used by 
that specification, and the relation body uses relates the unit containing a body to all units used by 
that body. These relations are il- lustrated graphically in figs. 1-3 and 1-4, primarily to show their 
complexity and the in- adequacy of direct graphical representations. Though this program is almost trivial 
by modern standards, the traditional structuring mechanisms cannot specify its structure both accurately 
and clearly. Nesting schemes cannot specify its structure accurately, because it is impossible to arrange 
the units A, B, DBA, DBB and DB in such a way that A can access only DBA, B can access only DBB, and 
yet DBA and DBB can access DR. Separate packages with import or export lists can specify its structure 
accurately, but not clearly: the im- port or export lists are a direct textual encod- ing of the graphs 
in figs. 1-3 and 1-4, and like the graphs are sufficiently complex that their structure cannot be readily 
apprehended. ® ®® Figure 1-3: The spec uses Relation Figure 1-4: The body use8 Relation I.S. Graphs 
Planar graphs are commonly used to model and illustrate program structure, as in the example above. The 
nodes of the graph represent program units, and the edges represent interactions between units. Since 
multiple interactions between units can occur and each is characterised by a relation, the following 
definition of a planar graph is ap-propriate in the context of structuring mech-anisms: A planar graph 
is a pair {N, R), where N is a set of nodes, and R is a set of relations on N specifying interactions 
between the nodes. A more natural and convenient model for the structure of an object-oriented program 
with mul- tiple views, however, is a layered graph. A layered graph consists of a number of horizontal 
layers, each of which is a planar graph. Each node in the graph represents the unique unit describing 
a specific object from a specific point of view. Each 13 layer corresponds to a viewpoint, and is called 
a view: the nodes in a view describe different objects, but from the same point of view. All nodes in 
the various views that describe a single object can be arranged on a vertical plane orthogonal to the 
views. Each such plane corresponds to an object, and is called a group: the nodes in a group describe 
the same object, but from different points of view. Edges in the graph represent interactions between 
units, and can cross group and view boundaries ar- bitrarily. Example 1-I= A layered graph that models 
the structure of the shared database program is shown in fig. 1-5. There are four views, called a, b, 
db and u. View a specifies the program structure from A's point of view: it contains nodes representing 
A and all units used by A, and shows how they interact. Similarly, views b and db specify the program 
structure from B and DB's points of view. The fourth view, u, contains nodes representing the utility 
pack- ages, and shows how they interact. There are ten groups, called a, b, db, h, r, v, al, l, p and 
a, corresponding to the objects a, b, db, hash, ran- dom, values, alists, lists, pairs and strings, respectively. 
All nodes and all views are shown in full, but only four groups, in order to keep the diagram intelligible. 
The omitted groups h and r contain just single nodes, and the omitted groups v, al, l and p are similar 
to group s. The arrows represent pairs in the relation body uses; for simplicity, this single relation 
is used in all examples appearing before section 4.2, which deals with the simultaneous specification 
of multiple relations. As expected from the description of the ex-ample, three different views of the 
database are present in the graph. Less expected, perhaps, are the multiple views of the utilities. Consider 
the utility strings, which is typical. Its group, a, contains four nodes, corresponding to four units 
called SA, SB, SDB and S. Each unit describes a distinct view of strings. Since all these views are in 
fact identical, they were not distinguished in the original description of the program; they are introduced 
here in order to ensure that each layer in the graph presents a complete picture of the program structure 
from the appropriate point of view: since A, for ex- ample, uses otrings, a view of strings must aw pear 
in layer a. Each of SA, SB and SDB con-sists of the same specification as $, and a trivial body implementing 
the specification in terms of S. These bodies account for the arrows lying within group 8 in the figure. 
(An alter- native approach is also possible, in which only a single view of each utility, the u view, 
is present, and users in all views use this single view. No additional units are introduced in this case, 
but a view can no longer be said to con- tain a complete picture of the program struc-ture from a particular 
point of view.) In this example, each interaction crosses ei- ther a group boundary or a view boundary, 
but not both. This is quite common in well-structured layered graphs, but is not necessarily the case. 
In general, interactions can be ar-bitrary. {An example of this more general be- haviour occurs if the 
alternative approach to the handling of utilities is used: in that case, all arrows from user nodes to 
utilities lead down to the u view, crossing both group and view boundaries.) b db h r v at t p s b db 
h r v I1! I p I Figure 1-6: Layered Graph A layered graph as used in this context is defined as follows: 
 A layered graph is a quadruple {N, (7, V, R), where N is a set of nodes, G and V are par-titions of 
N, and R is a set of relations on N specifying interactions between the nodes. The members of G are called 
groups, and the mem- bers of 1:, views. The partitions G and V are such that the intersection of any 
group and any view contains either zero or one node. An important consequence of the restriction on G 
and V is that any node can be uniquely identified by specifying its group and view. The syntax g/v is 
used to denote the node in group g and view v. The only formal difference between the layered 14 graph 
(N, G, V, R) and the planar graph (IV, R)is that the groups and views are identified explicitly. This 
is a crucial difference, however, as specifica- tion of grouping is one of the most important aspects 
of documenting structure. 2. Related Work Little research on structuring mechanisms as such has been 
done by programming language designers since the advent of the traditional mechanisms. Designers have 
tended, instead, to concentrate on other related aspects of language design, most notably abstraction 
mechanisms, and to use variations of nesting and separate modules for program structuring. Ada, for example, 
uses a combination of static nesting and separate modules with explicit import lists (with clauses) [12]. 
The recent work most closely related to the grid comes from the areas of version control and 8oftware 
engineering. Version control is con-cerned with the problem of maintaining consis- tency in a software 
system under development. The issues of version control and structuring mechanisms are largely orthogonal, 
since a struc-turing mechanism deals only with a single version of a program, and only with the source 
code, whereas a version control system deals with mul- tiple versions of a program, including intermediate 
and object files. Version control systems are con- cerned with program structure, however. The cul- mination 
of recent work in the area of version con- trol is the thesis work of Eric Schmidt on control- ling the 
software development of Cedar [1, 10]. Schmidt developed two languages for describing in- terconnections 
between Cedar modules: simple description file8 (DF files) and the much more sophisticated system modeling 
language, SML. Descriptions in these languages are used very effec- tively to manage multiple versions 
of software and to control releases, but they do not, and are not intended to, document program structure 
in a readily perceivable fashion. Another version con- trol system of interest is PIE, which was designed 
for the Smalltalk environment [3, 4]. It has a dis- tinctive feature, perspectives, that allows objects 
to be viewed in different ways. Software engineering is concerned with systems analysis and design, as 
well as with programming, and notations and methodologies have been developed for use in these processes. 
They tend to be greatly concerned with documenting structure, but not with enforcing it. The most complex 
and sophisticated such notation is Structured Analysis (SA) [2, 8, 9]. SA is not intended as a program 
structuring mechanism, and its diagrammatic na-ture makes it unsuitable for automatic processing as it 
stands. It also has no means, other than dis- cipline, of enforcing the specified structure. 15  3. 
Specifying Layered Graph Structures The interactions between nodes in a layered graph can be so complex 
that any direct represen- tation of them would be unintelligible. The processes of factorisation, clu~tering 
and ap- proximation, described in this section, provide a means of specifying them clearly. Only interactions 
described by a single relation are considered here; section 4.2 deals with the specification of multiple 
relations. 3.1. Factorisation Interactions between nodes in a layered graph can be arbitrary, and can 
cross group and view boundaries. However, the organisation of the layered graph suggests the possibility 
of factoring these interactions into two orthogonal components: interactions between groups, and interactions 
be- tween views. Two groups (views) interact if any node within the first interacts with any node within 
the second; the interactions between groups and views thus subsume all interactions between nodes. This 
can be illustrated by adding a new view, called the group graph, that specifies the in- teractions between 
groups, and a new group, called the view graph, that specifies the interactions be- tween views. The 
group and view graphs are im-portant, because they form the basis of an effec-tive means of specifying 
the interactions within a layered graph. Example 3-1: The group and view graphs of the shared database 
example are illustrated within the framework of the layered graph in fig. 3-1. Note that, even in this 
small example, they are considerably simpler than the original layered graph. The factorisation process 
is now described more rigorously. Let L ~ (N, G, V, R) be a layered graph, and let Ro E R. Then relations 
Rg and Rv on groups and views, respectively, can be derived from L and Ro as follows: Rg---- { (g=, g=) 
E G x G I 3 Vl, v26- V such that (gl/vl, g2/v2) 6. Ro } Rv = ( (v~, v2) 6- v x v l 3 g~, o2 6- G such 
that (gl/vl, g2/v2) 6- Ro } Rg is called the group relation and describes the group graph; Rv is called 
the view relation and describes the view graph. A new relation on nodes can be derived from Rg and Rv 
by attributing to every node all the relationships in which its group and view are in-volved. The new 
relation is referred to as the derived relation after factori~ation, Rf, and is defined as follows: a 
b db h r v sl I p s views b db h ¢ v al t p s views b clb h r v at t p S views Figure 3-I: Group and 
View Graphs Rf = { (gl/Vl, g2/v2) E N X N I (gl, g2) E Rg and (vl, v2) ERv }  A consequence of this 
definition is that Rf ~ Ro. Further define Df : Rf -Ro Then Df is the set of interactions specified by 
Rf that are not present in Ro, and is referred to as the set of deviation8 associated with the factorisation 
process. Example 3-2: The derived relation after factorisation in the shared database example is illustrated 
within the framework of the layered graph in fig. 3-2. In order to keep the diagram intelligible, only 
a few nodes appear, but all in- teractions between those nodes are shown. Dotted arrows represent interactions 
that are present in body uees, as canbe seen by compar- ison with fig. 3-1. Solid arrows represent devia- 
tions. The deviations shown fall into three categories: 1. Interactions that cross both group and view 
boundaries. 2. Interactions between utilities. 3. The interaction between db/b and alists/b. This is 
a representative sample of the types of deviations that are frequently a~sociated with the factorisation 
process.  16 a b db h r v at L p s views Figure 3-2" Derived Relation after Factorisation The set of 
deviations, D f, is a set of pairs of nodes that do not interact in the original layered graph. It can 
be characterised by a sequence of one or more qualifiers, such as the following: The qualifier except(e 
z, s2), where s I and 8 2 are sets of nodes, is used to specify deviations directly. It states that all 
pairs in the set { (hi, n2) E Rfl n: E 8z and n 2 E e2 } are deviations. Both e 1 and 8 2 can be any 
of the following: a node name denoting a singleton set; a group, view or cluster name denoting all nodes 
in that group, view or clusterl; a set of any of the above; or an as-terisk, denoting all nodes in the 
graph. The qualifier only(v 1, v 2, S), where S is a set of pairs of nodes, is used to specify that 
the only interactions between nodes in views v 1 and v 2 are those specified by S. More precisely, it 
states that all pairs in the set { (nz, n2) E Rf[ nl E vz, n2 C v2 and  -2) s } are deviations. As a 
convenient abbreviation, vz and/or v~ can be replaced by sets of views,  IA cluster is a set of groups, 
views or clusters; see section 3.2. including clusters and asterisks. The qualifier can also be used 
in analogous fashion with groups replacing views. The qualifier same-group(v 1, v2), Vl ~ vs is used 
to express succinctly that no interactions between nodes in views v I and v2 cross group boundaries. 
More precisely, it states that all pairs in the set { (gl/vl, g2/v2) E Rfl gl ~ g2 } are deviations. 
As a convenient abbreviation, either or both of v I and v 2 can be replaced by sets of views, including 
clusters and asterisks. The qualifier same-view{gl, g2) is analogous. The qualifier home-view{g, v} is 
used to specify that all views of group g, other than g[v itself, interact with g/v only. More pre-cisely, 
it states that all pairs in the set {(g/vl, g2/v2) e Rf l V 1 ~ Vand g2/v2 ~ g/V } are deviations. As 
an abbreviation, g can be replaced by a set of groups. Qualifiers handle many important special cases, 
and allow even a large set of deviations to be characterised succinctly. Example 3-3" Each of the three 
categories of deviations identified in example 3-2 can be characterised by means of a single qualifier, 
as follows: 1. same-group(*,*) and/or same-view(*,*} 2. home-group({v, utilities}, u), where util-ities 
is a cluster consisting of groups al, l, p and s (see section 3.2). 3. exeept(db/b, alists/b} It follows 
from the definitions of Rf and Df that Ro ffi Rf -. Df Since Rf can be derived from Rg and Rv in a simple 
and direct manner, and Df can be charac- terised by a sequence Qf of qualifiers as described above, it 
follows that Ro can be accurately and completely specified by the triple {Rg, Rv, Q f}, which is referred 
to as the factored form of Ro. This is the key result concerning factorisation. Specifying relations 
in factored form has the fol-lowing important advantages: Rg and Rv are usually much simpler than Ro, 
and Qf is usually short. The factored form of Ro is therefore usually a more concise specification of 
interactions than Ro itself.  Identifying and exploiting logical groupings of nodes is, perhaps, the 
most important factor in documenting structure. The factored form specifies interactions in terms of 
the two im-portant groupings, groups and views.  If no qualifiers are required, the layered graph is 
referred to as regular; the simpler the se-  quence of qualifiers, the more nearly regular the graph. 
Regular layered graphs are par-ticularly easy to comprehend, and can be specified particularly well using 
the technique of factorisation. Specifying interactions in factored form encourages the programmer in 
a practical way to strive for regularity, yet provides a means of handling non-regular structures when 
they are truly necessary. The first step in specifying the structure of a layered graph is therefore 
to specify the inter-actions in factored form, as a group graph, a view graph and a sequence of qualifiers. 
The second step is to specify the group and view graphs in a clear and concise manner, as described in 
the next sec-tion. 3.3. Clustering The group and view graphs produced by the process of factorisation 
are planar graphs. Direct representations of planar graphs, such as import or export lists, do not work 
well because they are too complex in the case of large graphs, and they fail to specify grouping. The 
process of clustering al-lows planar graphs to be specified in a concise and readabJe fashion, largely 
as a result of making grouping explicit. It is similar to the process of grouping pieces of program into 
modules. Consider a complex planar graph consisting of many nodes, and involving many interactions be- 
tween the nodes. The process of clustering involves grouping the nodes into clusters, and replacing all 
interactions between nodes in different clusters by interactions between the clusters themselves. The 
result is a graph of clusters, each of which is a graph of nodes. Example 3-4: Consider applying clustering 
to the group graph of the shared database ex-ample (fig. 3-1). There are various ways of grouping the 
nodes (groups) into clusters. Since a and b in this example are users, and the other groups exist solely 
to provide them with the services they require, one grouping that im-mediately comes to mind consists 
of just two clusters, users and servers, as follows: users = { a,b } servers = { db, hash, random, values, 
alists, lists, pairs, strings } Fig. 3-3 shows these clusters. The result of replacing all interactions 
be-tween nodes in different clusters with inter-actions between the clusters themselves is shown in fig. 
3-4. The clustering process can be repeated recur-sively. If the graph of clusters is complex, it can 
be clustered further: this is the bottom-up approach. Alternatively, any subgraph that is complex can 
be 17 clustered: this is the top-down approach. Which-ever approach is used, the result is an hierarchy 
of graphs in which all the graphs are simple and all interactions are between siblings in the hierarchy. 
Figure 3-3: Group Graph Showing Clusters I I / \ I I / \ I I / \ Figure 3-4: Partially Clustered Group 
Graph Example &#38;-St The cluster utilities in fig. 3-4 is sufficiently complex to warrant recursive 
clustering. Once again, many different group-ings are possible; one possible result is shown in fig. 
3-5. All subgraphs are now sufficiently simple that no further clustering is necessary. The clustering 
process is now described more rigorously. Let P ----(N, R) be a planar graph, and let Ro E: R. The first 
step of the clustering process consists of choosing a partition C of N into dusters Cl, C2 ..... Ck of 
nodes. Then Ro can likewise be partitioned into sets Rii , i, j ~ 1, 2 ..... k, as follows: n,j = { (hi, 
nil 6. no I n, ~ C, and ni E 6'/} For each i, the pair S i ~ (Ci, Ril) is a closed subgraph of P. Let 
 I I / \ I I I N / / " // \   it I ill~ \\ Figure ~-5i Fully Clustered Group Graph I I / \ I I i 
\ f I / \ G Figure 3-6t Derived Relation after Clustering Sf { S~l i---1,2 ..... k} A relation on S, 
called the subgraph relation, Rs, can be derived from the Rii, i ~ j, to describe the relationships between 
these subgraphs, as follows: ns = { (S~, Sj) I i # J and Rii Y~ ~ } Note that Rs is, by definition, non-reflexive. 
Rs is a relation on subgraphs, whereas Rii and Ro are relations on the original nodes. A new rela- tion 
on the original nodes, called the derived rela- tion after clustering, Re, can be derived from S and 
Rs as follows: nc = U R. u { (n~, n i) I i # ~, ,,~ e e~, nj e Cj and (s~, si) e Rs } 18 Thus, if two 
subgraphs are related by Rs, then all nodes in the first are related to all nodes in the second by Re. 
A consequence of this definition is that R¢~ Ro. Further define Dc ~ Re -Ro Then Dc is the set of interactions 
specified by Re that are not present in Ro, and is referred to as the set of deviations associated with 
the clustering process. Example 3-6: Consider the clustering process described in example 3-5 that trans-formed 
the partially clustered group graph of fig. 3-4 into the fully clustered group graph of fig. 3-5. The 
relation after clustering is shown within the framework of the partially clustered graph in fig. 3-6. 
Light arrows represent inter- actions that are present in the original graph, as can be seen by comparison 
with fig. 3-4. Heavy arrows represent deviations. The devia- tions arise because the derived relation 
after clustering specifies that db interacts with all nodes in clusters hash and utilities, whereas, 
in the original graph, it interacts with only some of them. This type of deviation is typical of the 
clustering process. As in the case of factorisation, the deviations as- sociated with clustering can 
be characterised by a sequence of one or more qualifiers. Permissible qualifiers include the following: 
 Qualifiers except and only, analogous to those described in section 3.1. The only qualifier in this 
case is a form of detailed import/export list.  The qualifier ezports(c, E), where E is a set of nodes, 
is used to specify that cluster c exports the nodes in E for use by other clusters, and no others. More 
precisely, it states that all pairs in the set  { (hi, n2) ERc I nl ~ c and n 2 E c - E } are deviations, 
The set E can be specified as any combination of individual nodes and cluster names, where a cluster 
name stands for all nodes exported by that cluster. Though the deviations in this case are effectively 
import/export lists, they apply only to small sub graphs rather than to the entire original graph. Example 
3-7: The deviations identified in example 3-6 can be characterised by the follow- ing sequence of qualifiers: 
only(db, utilities, {(db, al), (db, s)}); ezports( hash, h} There are many possible abbreviations of 
this sequence, and many other legitimate sequences. It follows from the definitions of Rc and Dc that 
R ----Re -De Since Rc can be derived from S and Rs in a simple and direct manner, and Dc can be characterised 
by a sequence Qc of qualifiers as described above, it follows that P, the original planar graph, can 
be specified accurately and completely by the quad- ruple Pc ffi (N, S, Rs, Qc), which is called the 
clustered graph derived from P. This is the key result concerning clustering. Specifying planar graphs 
as clustered graphs has the following impor- tant advantages: The graph of clusters and its subgraphs 
are simpler than the original planar graph. There are two primary reasons for this: multiple in- teractions 
between nodes in different clusters are replaced and subsumed by single inter-actions between the clusters 
themselves, and a single large graph is replaced by a number of smaller graphs. Also, as in the case 
of fac- torisation, the sequence of qualifiers is usually short. The clustered graph is therefore usually 
more concise than the original planar graph.  The clusters are explicit, and the information they convey 
about grouping is an important aid to understanding.  If no qualifiers are required, the clustered graph 
is referred to as uniform; the simpler the sequence of qualifiers, the more nearly uniform the graph. 
Uniform graphs are par- ticularly easy to comprehend, and can be specified particularly well using the 
technique of clustering. Specifying planar graphs in clus- tered form encourages the programmer in a 
practical way to strive for uniformity, yet provides a means of handling non-uniform structures when 
they are truly necessary.  The clustering process can be applied recursively to the clustered graph, 
Pc, itself, and/or to any of the subgraphs within S, eventually producing a fully clustered graph in 
which all subgraphs are small and simple. 3.3. Approxlmatlon All deviations add complexity to a structure 
specification, and therefore reduce its readability. This is true even of deviations that can be charac- 
terised by short sequences of qualifiers, though the simpler their characterisation the less serious 
their effect. Also, in many cases the deviations correct trifling inaccuracies that are not material 
to an un- derstanding of the program. The process of ap- proximation exists in recognition of the fact 
that not all deviations are material, and it consists solely of discarding them. This has the effect 
of approximating the actual structure of the program by a structure that is more regular and/or more 
uniform, and that differs from the actual structure only in unimportant respects. The programmer has 
the choice of which devia- 19 tions to consider important enough to include, and which to discard. It 
is important to note, however, that discarding deviations can never result in omit- ting from the specification 
interactions that ac-tually occur in the program. Example 3-8: The only qualifier in ex-ample 3-7 specifies 
that db does not use certain of the utilities. This type of deviation is typical, and is a good candidate 
for omission: it is usually sufficient to know that db uses some of the utilities, without knowing the 
details. The deviation specified by the ezcept qualifier in ex- ample 3-3 is unimportant for similar 
reasons, and can be discarded.  4. The Grid Mechanism The grid is a program structuring mechanism based 
directly on the results of the previous sec- tion. It specifies layered graph structures using the techniques 
of factorisation, clustering and ap-proximation, but in a non-graphical form that is suitable for computer 
processing. 4.1. Abstract Syntax A grid corresponds to a layered graph that has undergone the processes 
of factorisation, clustering and approximation. It consists of a two-dimen-sional matriz of units and 
two directories, called the group directory and the view directory. The matrix specifies the organisation 
of units into groups and views, the group directory is a non-graphical representation of the fully clustered 
group graph, and the view directory is a similar non-graphical representation of the fully clustered 
view graph. The matrix is a projection of the layered graph onto a plane orthogonal to both the groups 
and the views. Each row of the matrix is called a view, and corresponds to a view of the graph: the units 
in a view describe different objects, but from the same point of view. Each column of the matrix is called 
a group, and corresponds to a group of the graph: the units in a group describe the same ob- ject, but 
from different points of view. Example 4-1: The grid matrix correspond- ing to the layered graph of fig. 
1-5 is shown in fig. 4-1. The matrix is obtained from the graph by dragging each node along the line 
of inter- section between its group and its view until it reaches the front of the diagram. The unit 
names correspond to those listed in examples 1-1 and 1-2. Note that no arrows are shown in the matrix, 
since the matrix specifies organisa- tion only; all interactions are specified in the directories. a 
b db h r v Id I p A DBA VA ALA LA PA 8A b S OBB V1B ALB LB PB 88 db OB H R VOB ~OB LOB POB SOB u V AL 
L P S Figure 4-1: The Matrix Each directory is a tree of named node8 representing a clustered graph. 
In the group direc- tory, leaves represent groups; in the view directory they represent views. In both 
cases, internal nodes represent subgraphs produced during the clustering process. Interactions and deviations 
are rep-resented by means of information in fidd8 at-tached to directory nodes; direct representations 
of qualifier sequences, not sets of pairs, are used to specify deviations. A wide variety of other infor- 
mation, including documentation, can also be placed in these fields. A directory thus resembles an hierarchy 
of configuration files in C/Mesa, or of DF files in Schmidt's scheme, but contains more information [6, 
10]. Example 4-2z Group directories cor-responding to the group graphs in figs. 3-4 and 3-5 are shown 
in figs. 4-2 and 4-3. Interactions are illustrated by means of arrows; qualifiers specifying deviations 
are not shown. Note that the final group directory contains far fewer ar- rows than the partially clustered 
one, making it easier to read. Also, more grouping information is given, which is an important aid to 
under-standing. Indeed, the hierarchical structure of the directories, even without the arrows and qualifiers, 
tells a good deal about the structure of the group graph. For completeness, the view directory of the 
shared database example is shown in fig. 4-4. Figure 4-2: Partially Clustered Group Directory 2O Figure 
4-3: The Group Directory Figure 4-4: The View Directory The semantics of the grid are derived directly 
from the results of section 3, and are not described further. Though the abstract syntax and seman-tics 
of the grid have been described briefly and in- formally here, the grid can be defined formally as an 
abstract data type, with all details specified in full. Such a type then provides a uniform interface 
for all software associated with grids, such as editors, compilers and browsers. 4.2. Specifying Structure 
According to Multiple Relations Thus far, all discussion of the specification of in- teractions has been 
in terms of a single relation. As indicated in section 1.1, however, multiple rela- tions often exist 
between units, and they all con-tribute to the overall structure of the program. Two approaches to specifying 
structure according to multiple relations are possible. The first approach is to use the same groups, 
views and clusters for the specification of all the relations; this means that all the relations will 
be specified within the framework of single grid. The fields associated with directory nodes are, in 
fact, able to specify an arbitrary number of different relations. The second approach is to use multiple, 
separate grids; this is analogous to multiple indexes associated with a single database. The first ap-proach 
is generally preferable, as it provides a unified description of program structure, but there are cases 
when the second is necessary. directory views is view a spec uses u; view b body uses a, db, u; spec 
uses u; body uses b, db, u; view db spec uses u; body uses db, u; view u spec uses u; body uses u; same 
group only; end views; directory groups is subdir users body uses servers; subdir servers; end groups; 
directory users is group a; group b; end users; directory servers is group db spec uses v, utilities; 
body uses db, hash, v, utilities; subdir hash; group v spec uses utilities; body uses v, utilities; home 
view u; subdir utilities; end servers; directory hash group h body uses r; group r; exports h; end hash; 
directory utilities is group al body uses al, 1, p; group 1 body uses I, p; group p; body uses p; group 
s; body uses s; home view u; end utilities; Figure 4-5: The Directories in Textual Form Example 4-3: 
The relation spec use8 was introduced in example 1-1, and then ignored. It can easily be specified together 
with body use8 in a single grid. The directories specifying both relations are shown in textual form 
in fig. 4-5. These directories omit the deviations that were discarded by the process of approximation 
in example 3-8, and others like them, but show the important ones. An Ads-like syntax is used, for compatibility 
with the rest of the example. 4.3. Syntax The matrix of a grid can be specified using any simple notation 
or naming scheme that is able to specify the position of units in the matrix. The directories can be 
specified using any notation that is able to represent networks of nodes with ar-bitrary fields in a 
clear and concise manner. Qualifiers can be specified using any notation that provides simple and clear 
abbreviations for all im- portant special cases. 21 If the grid is to be used to structure programs 
in a particular programming language, there is much merit in choosing a syntax for it that is consistent 
with that of the language. The specification of the grid mechanism in abstract terms facilitates this 
flexibility. Example 4-4: The matrix of the shared database program, illustrated in fig. 4-1, can be 
specified by a sequence of statements such as db/a -~- DBA; db/b ~ DBB; db/db == DB;... The directories 
are specified using an Ada-like syntax in fig. 4-5; the qualifiers denoting devia- tions are specified 
in a short and simple form that makes their meaning clear. The matrix and two directories constitute 
a complete grid describing the structure of the program.  5. Conclusion Many large programs, most notably 
those struc- tured on the basis of levels of abstraction, have a structure that is most naturally viewed 
as a layered graph. The grid is a convenient mech- anism for specifying such layered graphs. It uses 
the techniques of factorisation, clustering and ap- proximation in novel ways to achieve clear and concise 
documentation of structure, and its seman- tics specify precisely how to determine whether a program 
conforms to the specified structure. A grid is textually separate from the program it structures, and 
can be used to specify the structure of programs in any language. The grid mechanism has proven convenient 
for structuring Fable descriptions of integrated circuit fabrication processes and equipment. Experience 
has yet to be gained of its use in other areas. The importance of abstraction levels as a structuring 
principle, and hence of layered graph structures, however, suggests that it will have general useful- 
ness and wide applicability. References 1. L.P. Deutsch and E.A. Taft. Requirements for an Experimental 
Programming Environment. Tech. Rept. CSL-80-10, Xerox Palo Alto Research Center, June, 1980. 2. M.E. 
Dickover, C.L. McGowan and D.T. Ross. Software Design using SADT. Proceedings 1977 Annual Conference, 
ACM, October, 1977, pp. 125-133. 3. I.P Goldstein and D.G. Bobrow. A Layered Approach to Software Design. 
Tech. Rept. CSL-80-5, Xerox Palo Alto Research Center, December, 1980.  d. D.H.H. Ingalls. The Smalltalk-76 
Programming System Design and Implementation. Xerox Palo Alto Research Center, 1976. 5. B.H. Liskov, 
A. Synder, R. Atkinson, and C. Schaffert. =Abstraction mechanisms in CLU. = Comm. ACM/~0, 8 (August 1977), 
564-576. 6. J.G. Mitchell, W. Maybury and R.E. Sweet. Mesa language manual. Tech. Rept. CSL-79-3, Xerox 
Palo Alto Research Center, April, 1979. 7. H.L. Ossher and B.K. Reid. =Fable: a pro- gramming language 
solution to IC process automa- tion problems. = SIGPLAN Notices 18, 6 (June 1983}, 137-148. Proceedings 
of the SIGPLAN '83 SympOMum on programming language issue8 in software systems. 8. D.T. Ross. "Structured 
Analysis (SA): A Lan- guage for Communicating Ideas." IEEE Trans- action~ on Software Engineering SE-3, 
1 (Jan 1977), 16-34. 9. D.T. Ross and K.E. Schoman, Jr. "Structured Analysis for Requirements Definition." 
IEEE Transactions on Software Engineering SE-8, 1  (Jan 1977), 6-15. 10. E.E. Schmidt. Controlling Large 
Software Development In a Distributed Environment. Tech. Rept. CSL-82-7, Xerox Palo Alto Research Center, 
December, 1982. 11. M. Sherman. Paragon: Novel Uses of Type Hierarchies for Data Abstraction. Conference 
Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, ACM, January, 1984. 
 12. Reference Manual for the Ada Programming Language. U.S. Department of Defense, 1980. 13. W.A. Wulf, 
R.L. Landon, and M. Shaw. "An introduction to the construction and verification of ALPHARD programs." 
IEEE Transadions on Software Engineering SE-~ (1976). 22  
			
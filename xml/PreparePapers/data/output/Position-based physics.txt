
 Position-Based Physics: Simulating the Motion of Many Highly Interacting Spheres and Polyhedra Victor 
J. Milenkovic. University of Miami Abstract This paper proposes a simpli.ed position-based physics that 
allows us to rapidly generate piles or clumps of many objects: local energy minima under a variety of 
potential energy functions. We can also generate plausible motions for many highly interacting ob­jects 
from arbitrary starting positions to a local energy minimum. We present an ef.cient and numerically stable 
algorithm for car­rying out position-based physics on spheres and non-rotating poly­hedra through the 
use of linear programming. This algorithm is a generalization of an algorithm for .nding tight packings 
of (non­rotating) polygons in two dimensions. This work introduces lin­ear programming as a useful tool 
for graphics animation. As its name implies, position-based physics does not contain a notion of velocity, 
and thus it is not suitable for simulating the motion of free-.ying, unencumbered objects. However, it 
generates realistic motions of crowded sets of objects in con.ned spaces, and it does so at least two 
orders of magnitude faster than other techniques for simulatingthephysicalmotionsofobjects. Evenforuncon.nedob­jects, 
the new algorithm can rapidly generate realistic piles and clumps. CR Descriptors: G.1.6 [Numerical Analysis]: 
Optimization -Linear Programming; I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling 
-Physically based modeling; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism -Animation; 
I.6.8 [Simulation and Modeling]: Types of Simula­tion -Continuous. 1 Introduction To generate realistic 
animation, recent work in computer graphics has focused on methods to simulate the motion of objects 
under the laws of physics. Suppose one wants to create an animated dancer. Instead of laboriously choosing 
a sequence of poses, one creates a model of a dancer with masses, joints, and forces, and lets the laws 
of physics do the dancing. The laws of physics are well understood (for this domain), and current computers 
can simulate physics for 1Department of Mathematics and Computer Science, University of Mi­ami, P.O. 
Box 249085, Coral Gables, FL 33124. The research of Victor J. Milenkovic was funded by the Textile/Clothing 
Technology Corporation from funds awarded to them by the Alfred P. Sloan Foundation and by NSF grants 
CCR-91-157993 and CCR-90-09272. Permission to make digital or hard copies of part or all of this work 
or personal or classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advantage and that copies bear this notice and the full citation on the first 
page. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior 
specific permission and/or a fee. &#38;#169; 1996 ACM-0-89791-746-4/96/008...$3.50 these types of models 
in near to real time. The main dif.culty of this approach is choosing a set of forces (parameters for 
the model) that allow the dancer to dance and not fall on its face. However, there are other domains 
for which the forces are easily determined but the physics is very dif.cult to simulate. Consider the 
problem of generating a pile or clump of many objects under gravity or mutually attractive forces. Creating 
or even verifying an equilib­rium state of the physical system is a complex problem. Consider further 
the problems of animating the sand in an hourglass or the sand on the beach as someone sets foot on it. 
Consider even the problem of animating the molecules of .uid in a lava lamp. These models involve many 
highly interacting three-dimensional objects. For even a modest number of grains of sand or molecules, 
the sim­ulation outstrips our computational resources.1 This paper proposes a simpli.ed position-based 
physics that al­lows us to rapidly generate piles or clumps of many objects: local energy minima under 
a variety of potential energy functions. Position-based physics allows us to rapidly generate plausible 
mo­tions for sets of many highly interacting objects. We present an ef­.cient and numerically stable 
algorithm, based on linear program­ming, for carrying out position-based physics on spheres and non­rotating 
polyhedra. This algorithm is a generalization of an algo­rithm for .nding tight packings of (non-rotating) 
polygons in two dimensions. This work introduces linear programming as a useful tool for graphics animation. 
As its name implies, position-based physics does not contain a notion of velocity, and thus it is not 
suit­able for simulating the motion of free-.ying, unencumbered ob­jects. However, it generates realistic 
motions of crowded sets of objects in con.ned spaces, and it does so at least two orders of magnitude 
faster than other techniques for simulating the physical motions of objects. Even for uncon.ned objects, 
the new algorithm can rapidly generate realistic piles and clumps. Section 2 compares position-based 
physics to other methods of physical simulation such as velocity-based contact force methods. It describes 
two problems which severely slow down velocity-based methods: local and global rattling. Section 3 gives 
the formal def­inition of position-based physics and gives an algorithm to carry it out. For a system 
of translating objects that involves only sphere­sphere and sphere-polyhedron contacts, it is proved 
that the linear programming based algorithm converges to an equilibrium of the potential energy function: 
the algorithm cannot stick at a non­equilibrium con.guration. Section 4 describes how to implement the 
algorithm using linear programming to simulate position-based physics on a set of spheres inside a polyhedron, 
in particular, a set of 1000 spheres inside an hourglass . Section 5 shows how to han­dle non-gravitational 
potential functions such as attraction among the spheres. Section 6 presents results and running times, 
and Sec­tion 7 discusses the implication of this work and directions of future research. 1Also, numerical 
instability, which is a minor problem for the simulation of robots or dancers, becomes a serious impediment 
when the number of interacting objects rises into the hundreds, thousands, or beyond. 2 Techniques for 
Physical Simulation We categorize physical simulation techniques as acceleration­based, velocity-based, 
or position-based. Acceleration-based meth­ods come closest to simulating true physics, and they are 
the most expensive to carry out in computation. Velocity-based methods are farther divorced from reality 
but are faster. Position-based meth­ods are the farthest from reality and the fastest. Spring model methods 
(also called penalty methods) [25] [26] are typical acceleration-based methods. They allow the objects 
to overlap. For each pair of overlapping objects, there is a repulsive force proportional to the amount 
of overlap. The resulting repulsive forces cause the objects to accelerate. Numerical integration con­verts 
acceleration to velocity and then to position. These methods require many small time-steps when the acceleration 
is high. The large number of steps results in a high computational cost. Also, it is often dif.cult to 
determine the correct step size. Incorrect dis­cretization of time can cause unusual numerical results 
such as non­conservation of energy or momentum. Contact force model methods (also called analytical methods) 
[14] [1] [8] are examples of velocity-based methods. See [4] for a discussion of the many issues involved 
in contact force models. Rigid bodies are allowed to contact but not overlap. Given the cur­rent set 
of contacts, the method computes a set of consistent ve­locities such that no two contacting objects 
penetrate each other. The objects move with these velocities until a new contact occurs. The velocity-based 
method is much more stable and faster than the acceleration-based method for two reasons: 1) it can exactly 
com­pute the time of the next contact, and 2) the resulting time-step tends to be much larger than that 
needed to accurately carry out numerical integration. Even though these methods do not simu­late acceleration, 
they can handle increasingly sophisticated types of objects and forces: curved surfaces [2], friction 
[3], and .exible bodies [7]. Unfortunately, the velocity-based method is subject to two problems which 
cause small time-steps and thus high compu­tational cost. Local rattle occurs when one object bounces 
between two others (such as the rapid bouncing that occurs when you bring a paddle down on a bouncing 
ping-pong ball). Global rattle occurs when there are many interacting objects. Since there are so many, 
it is inevitable that some pair will make contact in a short amount of time. Even systems which can rapidly 
detect the next collision [16] cannot reduce the number of collisions. Each new contact forces us to 
recalculate the velocities. Just as a velocity-based method eliminates accelerations, a position-based 
method eliminates velocities (and also time, mo­mentum, and kinetic energy). The model only needs to 
have a po­tential energy function. Under position-based physics, the objects are allowed to move from 
their current con.guration (positions) to a lower energy con.guration along any valid (non-overlapping) 
energy-diminishing path. Under a linear programming based algo­rithm for position-based physics, the 
motion consists of a sequence of steps yielding a piecewise linear path. Each step diminishes the energy 
as much as possible within some maximal valid convex set of con.gurations surrounding the current con.guration. 
This con­vex set depends both on contacts that are occurring and on all con­tacts that might occur. Therefore 
the algorithm does not have to stop prematurely to handle a new contact, and there is no local rat­tle 
. Position-based physics also avoids global rattle since each object moves a maximal amount. Even if 
two objects in the model require only a small motion to come into contact, this does not pre­vent other 
objects in the model from moving farther, if they are able to. In his Ph.D. thesis [19] and in joint 
work with this author [22, 23], Li introduced the concept of position-based modeling. His application 
is compaction: .nding tight packings of polygo­nal objects in the plane. As he and others have noted 
[29, 30], for most layout applications the motion of the objects is immate­rial, and only the .nal con.guration 
matters. He attempted to carry out compaction using a velocity-based method similar to Baraff s [1], 
but he found this to be very expensive computationally and also numerically unstable. He formulated a 
position-based model and algorithm. This algorithm uses Minkowski sums [27, 13] and a locality heuristic 
to calculate a maximum convex region of the con.guration space visible to the current con.guration. Linear 
pro­gramming .nds the lowest energy con.guration in this region, and the model jumps to this con.guration. 
According to his experi­ments, the method typically reaches a local energy minimum in .ve or fewer jumps 
even for a layout of more than 100 polygons with up to 75 vertices per polygon. For the examples which 
were simple enough for him to carry out the velocity-based minimization, the position-based method was 
at least two orders of magnitude faster. The algorithms presented in this paper also use position-based 
physics. For sphere-sphere and sphere-polyhedron interactions, they do not require explicit calculation 
of the Minkowski sum (un­like Li s method for polygons). For polyhedron-polyhedron inter­actions, they 
do require calculation of the Minkowski sum, but un­like Li s locality heuristic, they do not require 
that the polyhedra be decomposed into star-shaped2 components. The new algorithms can solve for the motions 
of spheres and polyhedra, whereas Li s algorithm is restricted to two-dimensional polygons. Interestingly 
enough, some recent work has moved away from the use of large complex optimization systems [5]. Position-based 
physics reduces motion planning to linear programming. Instead of dealing with implementing optimization 
code ourselves, we sim­ply use a commercial linear programming library. Goldsmith et al. [12] discuss 
a number of ways optimization is applied in the .eld of graphics. Most of these involve either starting 
or .nishing prob­lems. Furthermore, most are non-linear. We believe that position­based physics is unique 
in the way it uses linear programming to generate a complex motion from start to .nish. Position-based 
physics yields realistic motion for crowded sets of objects. For free-.ying objects, the motion can be 
less reason­able. However, even in situations for which position-based methods give an unrealistic motion, 
there may be other applications. Recent work on manipulation of models makes use of non-physical motion 
[6] [15]. Finally, it is important to note the difference between position­based physics and particle-based 
systems. Examples of particle­based systems are too numerous to note all of them. See [32] [17] [31] 
[33] [10] [9] [21] for recent work. In general, particle­based systems model moving particles with forces 
between them, not rigid colliding objects. Simulating rigid objects using parti­cles requires a very 
steep repulsive energy gradient, and hence particle-based systems are subject to the same dif.culties 
as other acceleration-based methods: small time-steps and long running times.  3 Position-Based Physics 
The philosophy behind position-based physics is to dispense with acceleration, force, velocity, and time. 
The state of the system is the current con.guration (position). The system has a potential energy that 
depends only on the con.guration. There is no notion of kinetic energy. Section 3.1 de.nes position-based 
physics and describes how it can be used for modeling and animation. Section 3.2 gives an algorithm for 
simulating position-based physics on models with a smoothly convex decomposable overlap space: the set 
of forbidden con.gurations is a union of convex regions with smooth boundaries. 2Aregion is star-shaped 
if it contains at least one point which can see the entire boundary. This algorithm uses linear programming. 
Section 3.3 proves that several types of models have smoothly convex decomposable over­lap spaces. Among 
these are models involving translating spheres inside a .xed polyhedron. We describe what modi.cations 
are nec­essary to handle multiple translating polyhedra. 3.1 De.nitions As per typical usage, con.guration 
space denotes the concatenation of the degrees of freedom of the model. For a set of nspheres, the con.guration 
space has 3ndimensions. The free space is the set of con.gurations for which no pair of objects overlap.3 
These free con.gurations are also referred to as valid or non-overlapping.The complement of the free 
space is the set of overlapping, invalid,or forbidden con.gurations. We denote the free space by F. We 
assume that the model has a potential energy which is a con­tinuous and differentiable real-valued function 
on the con.guration space. For con.guration c, the energy is denoted E(c). A valid motion under position-based 
physics is an energy­diminishing path in F. Given a starting con.guration c2F,the goal is to generate 
a continuous and piecewise differentiable curve ,(t)such that 1) ,(0)=c,2) ,(t)2Ffor t.0,3) E(,(t))is 
monotonically decreasing for t.0,3) limt!1,(t)=c1is an equilibrium con.guration. A con.guration cequilis 
an equilibrium con.guration if every valid curve O(t)out of cequil(O(0)=cequil and O(t)2Ffor t.0) is 
non-energy-decreasing: dd t E(O(t)). 0. Note that tis not time and c1may not be the equilibrium state 
reached by a velocity-based or acceleration-based physics with the same potential energy function. However, 
a limiting value of ,(t) is a valid resting position: a pile or clump . To generate a de­cent looking 
animation, we can sample ,(t)in a way that makes it appear that the objects in the model are moving with 
constant or varying velocity, as desired. Also, as shown in Section 4.4, it is possible to add additional 
constraints on the path to make it appear more natural.  3.2 Linear Programming Based Algorithm This 
section gives an algorithm for performing position-based physics on models with a particular type of 
free/forbidden space. The algorithm is proved to have an equilibrium position as a limit point. If the 
energy function is linear, then the algorithm can be implemented using linear programming. 3.2.1 Smooth 
Convex Decompositions Aset S of Rnis de.ned to be convex decomposableif it is the union of a .nite number 
of convex sets. It is smoothly convex decompos­able if it is the union of a .nite number of convex sets 
with smooth boundaries. We use a standard de.nition of smooth: a convex set C is smooth if each point 
on the boundary has a unique tangent plane and outward unit normal vector and if this plane/normal is 
a con­tinuous function on the boundary. Actually, it is easy to show that if Cis convex and if each point 
on the boundary of Chas a unique outward unit normal, then the normal vector varies continuously on the 
boundary. 3.2.2 Algorithm The following is an algorithm for position-based physics when the overlap 
(forbidden) space O=Fis smoothly convex de­composable. Region Ois the union of msmooth convex regions 
O1;O2;O3;:::;Om. 3We consider the exterior of the container to be a .xed object, and hence the de.nition 
of free space includes the container constraint. Let c=c0be the initial con.guration. The algorithm sets 
,(0)=c. The algorithm proceeds in a sequence of steps. Dur­ing the ith step, it constructs the portion 
of the curve from ,(i-1) to ,(i). Let us suppose the algorithm has constructed the curve up to con.guration 
,(i)=ci. Here is how it performs the next step. For each convex region Oj, it constructs the half-space 
H(ci;Oj)as follows. First it projects cionto the nearest point PROJ(ci;Oj)on Oj. It computes the tangent 
plane to Ojat PROJ(ci;Oj). This tangent plane bounds two half-spaces, and H(ci;Oj)is the one which does 
not contain the interior of Oj.  The algorithm computes the convex region  m . I(ci;F)=H(ci;Oj): j=1 
Assuming Fis closed (objects are allowed to touch), it fol­lows that I(ci;F)F. The algorithm computes 
the minimum energy con.guration ci+12I(ci;F)which is reachable by an energy-diminishing path from ,(i)=cito 
,(i+1)=ci+1within I(ci;F). In general, the last step requires some sort of numerical integration. However, 
if the energy function is linear, it can be accomplished us­ing linear programming. Linear programming 
can easily compute the point ci+12I(ci;F)which minimizes the energy. The algo­rithm can set ,(t), i.t.i+1equal 
to the line segment from ci to ci+1.Since I(ci;F)is convex, this segment is valid.  3.2.3 Correctness 
and Convergence The following theorem states that the limit points of the algorithm are equilibrium points. 
This does not mean that the algorithm has a unique limit. If we have a room full of falling objects, 
some objects might already be on the .oor. Any arbitrary motion of an object along the .oor does not 
change the gravitational energy. For odd i, con.guration cicould have a particular object at one end 
of the room. For even i, it could be at the other end of the room. Thus, as the rest of the objects settled 
into a pile , this one object may never come to rest. Nothing in the de.nition of position-based physics 
prevents it from bouncing from one wall to the other forever. In this case, the system will have two 
limit points. Any particular linear programming library will break ties con­sistently. Therefore, it 
will not allow an object to bounce from wall to wall forever. It is also possible to introduce a conservative 
en­ergy term: each object is attracted to its current location. Both of these facts can be used to ensure 
that the algorithm converges to a unique limit. Section 4 illustrates both of these for spheres inside 
a polyhedron. It is probably possible to modify the de.nition of position-based physics and the algorithm 
to disallow bouncing . However, there may be cases in which we want this behavior. Note that bouncing 
is not like rattling. Bouncing does not affect the amount by which the energy is reduced in one step, 
and therefore it does not increase the number of steps required to reach an energy minimum. For velocity-based 
methods, frequent collisions dimin­ish the time-step and greatly increase the time required to reach 
a minimum. We remind the reader that the de.nition of an equilibrium point depends only on Fand the energy 
function E(). An equilibrium point for position-based physics is the same as an equilibrium point for 
any other type of physics. Therefore, the following theorem as­serts that the algorithm converges to 
physically correct piles and clumps . It does not get stuck at a non-equilibrium con.guration. However, 
most models have very many equilibrium con.gurations. The algorithm does not necessarily converge to 
the same equilib­rium as a true simulation of physics. Theorem 3.1 For compact (closed and bounded) F, 
the sequence c0;c1;c2;c3;:::generated by the algorithm has at least one limit point. Each limit point 
is an equilibrium point. Proof: The existence of a limit point is a property of any sequence in a compact 
set. Let climbe a limit point. Suppose climis not an equilibrium point. Therefore, there is a curve O(t)out 
of climwhich diminishes the energy. It follows that the energy decreases out of climin the direction 
v=O0(0)(the tangent vector to O(t)at t=0). For each j, climeither lies outside or on the boundary of 
Oj.If it lies outside, then there exists0such that clim+tv62Ojfor 0t<.If climlies on the boundary of 
Oj,then vmust lie in the tangent plane to Ojat climor it must point into H(clim;Oj). Hence, there exists0such 
that clim+tv2I(clim;F)for 0t< .Also, E(clim+tv)has the same derivative at t=0 as E(O(t)). The conclusion 
is that if the algorithm reached clim, the next step would be able to diminish the energy. Let 8limbe 
the amount of decrease. The algorithm has climas a limit point. The construction of I(ci;F)uses only 
continuous functions. For cisuf.ciently close to clim, the energy decrease 8i =E(ci)-E(ci+1)can be arbitrarily 
close to 8lim.Since E()is also continuous, there must exist some i such that 8lim E(ci)-E(clim)< 2 It 
follows that E(ci+1)<decreases the energy, clim 8 and E(ci)-E(ci+1)=8i lim : 2 E(clim). Since the algorithm 
always cannot be a limit point. This contradicts the assumption that climis not an equilibrium point. 
  3.3 Models with Convex Decompositions This section examines some models with smoothly convex decom­posable 
overlap spaces. It is shown how to apply the algorithm of Section 3.2.2 to the problems of animating 
and generating piles of spheres and polyhedra under translation. 3.3.1 Minkowski Sum. The Minkowski sum 
[24, 13, 27, 28] of two point-sets (of R3in the case of this paper) is de.ned AtB=fa+bja2A;b2Bg: For 
a point-set A,let Adenote the set complement of A and de.ne -A=f-aja2Ag. For a vector v,de.ne A+v=fa+vja2 
Ag. Note that A+v=Atfvg. Suppose we have ntranslating objects A1;A2;A3;:::;An.It can easily be shown 
that Ai+viand Aj+vjoverlap if and only if vj-vi2Ait-Aj. Lemma 3.2 If Cis convex and Sis smoothly convex, 
then CtS is smoothly convex. Proof: It is easy to show that CtSis convex. Suppose pis a point on the 
boundary of CtSsuch that phas two distinct unit normal vectors uand u 0.Since uis a normal at p, pmaximizes 
the dot product u.pover all points in CtS.Since p=c+swhere c2Cand s2Scan be chosen independently, smust 
maximize 000 u.sover all points of S.Yet, p=c+swhere c2Cand 0 s2Shave maximum dot products with u 0.Since 
shas a unique 0000 normal, uis not a normal at s,and u.s<u.s. Therefore 000 u.(c+s)<u.(c+s). Therefore, 
p=c+sdoes not maximize the dot product with u 0. This contradicts the assumption that phas two unit normals. 
Therefore, phas a unique unit normal vector. It is easily shown that if a convex region with unique unit 
normal vectors has continuous unit normal vectors: it is smooth. Corollary 3.3 If Cis convex decomposable 
and if Sis smoothly convex decomposable, then CtSis smoothly convex decompos­able. Proof: Let the decompositions 
be, C=C1 C2... Cl and S=S1 S2... Sm: It can easily be shown that, lm .. CtS= CgtSh: g=1h=1 In other words, 
the Minkowski sum is the union of the Minkowski sum of each possible pair. By Lemma 3.2, each of these 
sums is smoothly convex. 3.3.2 Good Models The following theorem describes the type of problem to which 
we can apply the algorithm of Section 3.2. Theorem 3.4 If 1) only translation is allowed, 2) all objects 
are convex decomposable, and 3) at most one object is not smoothly convex decomposable, then the overlap 
space is smoothly convex decomposable. Proof: For each pair of objects, Aiand Aj, at least one is smoothly 
convex decomposable. Corollary 3.3 implies that the pair­wise overlap space fhvi;vjijvj-vi2Ait-Ajg is 
smoothly convex decomposable. This transforms to a cylinder fhv1;v2;:::;vnijvj-vi2Ait-Ajg in the con.guration 
space for the entire model which is decompos­able into a union of smooth convex cylinders. 3.3.3 Applications 
The main application of this paper is a collection of translating spheres in a polyhedral container. 
Clearly each sphere is smoothly convex decomposable. The remaining object, the complement of the container, 
is polyhedral and therefore convex decomposable: simply cut it along every plane of every face. We can 
not directly apply Theorem 3.4 to the problem of mul­tiple translating polyhedra since a polyhedron is 
convex decom­posable but not smoothly convex decomposable. However, we can smooth a polyhedral region 
Pby adding a small spherical region S. By Corollary 3.3, PtSis smoothly convex decomposable. Of course, 
when we render the motion, we will display the original polyhedra, not the smoothed polyhedra. They will 
have small gaps between them equal to the diameter of S. For moving objects, this will not be noticeable. 
Once, the objects form a pile or clump , we can run the algorithm with smaller and smaller S, perhaps 
halv­ing the radius each time, until the desired accuracy is attained. Li and Milenkovic s algorithm 
(for translating polygons in the plane) uses a somewhat different framework than that of the algo­rithm 
in Section 3.2.2. In essence, it chooses an arbitrary tangent line/unit normal when the normal is not 
unique. This means, for instance, that our compaction algorithm for polygons in the plane might get stuck 
at a non-equilibrium con.guration. We have never seen it get stuck in practice (but we really have no 
indepen­dent way to verify an equilibrium other than visual inspection). It is likely that one could 
safely animate multiple translating polyhedra without getting stuck. However, we have not yet run any 
experi­ments. Baraff [1] indicates that correctly choosing a set of tangents at each non-unique contact 
is NP-complete.  4 Simulating an Hourglass using Position-Based Physics The .rst section of the accompanying 
video tape demonstrates the simulation of an hourglass or egg-timer using position-based physics. The 
main body of the hourglass is shaded as a curved sur­face, but it is actually a polyhedron. Each horizontal 
cross section is a 32-gon, and thus the sides of the hourglass have 160 faces. Ini­tially, 1000 spheres 
are arranged in a 10 by 10 by 10 grid in the upper part of the hourglass. Position-based physics calculates 
a (lo­cal) gravitational energy minimum for the spheres in the base. As a side-effect, it simulates the 
.ow through the narrow waist of the hourglass. The video presents two hourglass simulations. Both are 
shown at 30 frames per second. Each frame is an actual energy minimization step. Rendering was done with 
rendrib.4 The .rst video has 750 frames, and the second has 812 frames. Sections 4.1 through 4.3 describe 
how the .rst video was gen­erated. Section 4.4 shows how extra constraints where added to generate a 
more realistic motion in the second video. The modi.ed algorithm has acceleration and conservative forces. 
This video il­lustrates how the path generated by position-based physics can be controlled to increase 
the realism. 4.1 Pairwise Constraints Instead of working in 3n-dimensional space, we choose a convex 
subset of the pairwise free spaces. We must do this for each pair of spheres and each sphere with respect 
to the hourglass polyhe­dron. Taken together, these constraints are equivalent to I(c;F)of Section 3.2.2. 
For a pair of spheres Siand Sjwith radii riand rjand current cur cur positions (centers) piand pj,de.ne 
cur cur cur ji p-p u= cur cur ij jpj -pij to be the unit vector pointing from Sito Sj. The convex region 
Rij is the set of con.gurations satisfying cur (pj-pi).uij ri+rj;for 1i<jn:(1) The half-space constraint 
pj-pi2Rijprevents the spheres from overlapping, and it is exactly equivalent to one of the half-spaces 
in the .rst step of the algorithm in Section 3.2.2. For a sphere Siand the hourglass polyhedron G,we 
do the fol­lowing. Set h=1.Let qhbe the point on the boundary of Gclosest cur to pi.Let, cur cur i p 
-qh v = hi cur jp -qhj i cur be the unit vector from qhto pi. We create the constraint, -.v cur (2) (piqh)hiri; 
and we throw away all points pof the boundary of Gwhichdonot satisfy cur (p-qh).vhi0: 4The Blue Moon 
Rendering Tools by Larry I. Gritz. (Intersecting a half-space with a polyhedron is easy if the faces 
are all convex: the intersection of each face with the half-space is also convex.) If some part of the 
boundary remains, then we increment hand repeat this process. We stop when no point on the boundary of 
the polyhedron remains. The resulting set of linear constraints on pigiven by all instances of Equation 
2 de.nes a convex region Riwhich is a projection of I(ci;F)of Section 3.2.2 (actually, it can be a superset, 
but that can only improve the convergence). 4.2 Minimizing the Potential Energy For the hourglass example, 
the potential energy is the sum of the z-coordinates of the spheres. This corresponds to the gravitational 
energy of a set of spheres with equal mass. How do we .nd the next con.guration? We need to solve for 
the con.guration that minimizes the gravitational energy under the linear constraints of Equations 1 
and 2. This is linear programming. We simply pass this problem to a commercial linear programming package, 
CPLEX.5 Theorem 3.4 implies that the hourglass algorithm cannot stick unless the actually physical system 
would also. Hence, the spheres .ow down the hourglass without clogging in the middle. 4.3 Box Constraints 
We also bound each sphere to lie in a rotated cube centered at the current position of the sphere. The 
cube has width two times the sphere radius, and it is oriented to have a vertex at minimum z­coordinate. 
This constraint serves to put an upper bound on the maximum distance a sphere can move in any one step. 
This extra constraint serves two purposes. First, it keeps the spheres from falling too fast. In the 
absence of this constraint, a solitary sphere could fall to rest on the ground from an arbitrary height 
in a single step. Second, by limiting the motion of the spheres, we limit the pairs of spheres which 
can collide in the cur­rent step. That permits us to reduce the size of the linear program. We do not 
add a pairwise constraint for two spheres that are too far apart to collide in the next step. We can 
use bucketing to detect nearby pairs of spheres in nearly linear time. 4.4 Acceleration and Conservative 
Forces The reader will notice that the spheres do not accelerate as they fall. We could .x this by detecting 
if a sphere has fallen the maximum amount, and if so, increasing the height of its bounding box by a 
.xed amount. To make this work properly, we must use unrotated boxes, unlike the rotated cubes of the 
previous section. The reader will also notice that the spheres roll to the back of the hourglass. Using 
unrotated boxes makes this effect worse: the spheres fall to the lower-left-rear corner of the box, making 
them fall at an angle. This is an artifact of the simplex method used to solve the linear program. We 
can add a conservative energy term that penalizes each sphere for changing any of its coordinates. In 
particular, we express each variable xias xi =x + i -x . i,where both x + iand x . iare constrained to 
be positive (xicould represent the x, y,or zcoordinate of a sphere). To the objective function, we add 
X + . cconserve (x+x); ii i where cconserveis small compared to the gravitational constant . In our system, 
the gravitational constant is 1 and cconserve =0:001. The second hourglass video illustrates the addition 
of acceleration and conservative forces . 5Version 3.0. CPLEX Optimization Inc. Suite 279. 930 Tahoe 
Boule­vard, Building 802. Incline Village, Nevada 89451-9436. 4.5 Polyhedron-Polyhedron Constraints 
The hourglass example does not require polyhedron-polyhedron constraints. For the record, we describe 
how one could add them to the model. Li s method for constructing a convex subset of the free space, 
the locality heuristic, requires that the interacting polygons be star­shaped. If they are not, they 
must be decomposed into star-shaped components. Extra constraints must be added to ensure that the components 
move as one object. We describe here a method for selecting a convex free region Rijfor a pair of polyhedra 
Piand Pjunder translation. As in the case of modeling spheres, we can construct these regions for each 
pair of polyhedra instead of having to work in R3nas implied by the algorithm of Section 3.2.2. Note 
that this method does not require that Piand Pjbe star-shaped, which is an improvement of Li s result. 
Let Pirepresent the resting position of Pi,and let Pi+pirepresent Pitranslated by pifrom its resting 
position. As stated in Section 3.3.1 Pi+piand Pj+pjdo not overlap if and only if pj-pilies in F=Pit-Pj. 
This is all following theory developed by Li to handle the two-dimensional case. cur curcur For a given 
pairwise con.guration cij =hpi;pji, we con­struct convex region Rijas follows. Set h=1and let qhbe the 
cur cur point on the boundary of Fwhich is closest to pj -pi.De.ne cur cur cur ji p-p-qh w= cur cur hijjpj 
-pi -qhj cur cur to be the unit vector from qhto to pj -pi. Add the constraint, cur (pj-pi -qh).w0: (3) 
hij Throw away all points qof the boundary of Fthat do not satisfy cur (q-qh).whij0: Increment hand repeat 
until no points of the boundary of Fremain. The set of constraints given by all instances of Equation 
3 de.ne a convex region Rijwhich is a subset of the free space for these two polyhedra. This region is 
the projection of I(ci;F)of Section 3.2.2 into the con.guration space of these two polyhedra (actually, 
it can be a superset). For this reason, it is suf.cient to use these pairwise constraints.  5 Non-gravitational 
Potential Functions For some applications, it may be necessary to simulate a constant force, a spring 
force, or an inverse-square law force between spheres. In this section, we describe how this can be done, 
and give some examples. 5.1 Attraction between Spheres. To de.ne an attractive force between spheres, 
we must .rst de.ne the distance between spheres in a way that can be represented in a linear program. 
In the following, 1i<jn,where nis the number of spheres. Let Siand Sjbe spheres which are to attract 
each other. Create a new variable dijwhich represents an approximation to the distance from pito pj.The 
value of dijwill always be a lower bound on the Euclidean distance. Select a set Uof unit vectors. The 
cur set Ushould at least include uij(the unit vector from pito pj) and the six axis-parallel vectors 
(±1;0;0), (0;±1;0), (0;0;±1). Apply the following constraints on pi, pj,and dij: u.(pj-pi)dij;for u2U: 
(4) Adding more vectors to Umakes dija better approximation to the Euclidean distance jpj-pij. However, 
the given Uis suf.cient for cur realistic motion, and the presence of uijensures correct conver­gence. 
For a constant force fijof attraction between Siand Sj(inde­pendent of distance), we can add the term 
fijdijto the potential function for the model. Often, however, one desires a force which dies off with 
distance, such as the inverse-square law. The corre­sponding potential function -fij/dijis nonlinear. 
In this case, we use a linear approximation, dcur 1dij-ij Eapprox(dij)=fij(-+): dcur (dcur)2 ij ij For 
any convex potential function, such as the inverse-square law, the linear approximation is an upper bound 
on the actual potential energy. The con.guration to which the system jumps will there­fore have lower 
energy than expected, and thus the system will con­verge even if it uses this approximation. 5.2 Spring 
Force It is possible to model forces which increase with distance such as a spring force. In this case, 
the potential function is E(dij)=fijd2 ij. This type of function is concave (upwards), and thus the method 
in the previous paragraph does not work. To solve such a model using linear programming, we replace the 
function by a piecewise linear approximation. First, de.ne lvariables 0dij1;dij2;:::;dijl 1and add the 
constraint dij=dij1+dij2+...+dijl.The piecewise linear approximation to the energy function is l X Eapprox(dij)=fij(2k-1)dijk: 
k=1 For kdij<k+1, this energy is minimized when dij1 = dij2 =...=dijk=1and dij(k+1)=dij-k. The value 
of the approximate function is fij(k2+(2k+1)(dij-k))which is a good approximation to fijd2 ij. 5.3 Examples. 
The video illustrates the application of the constant force, inverse­square law force, and spring force. 
In the trampoline example, the border of the 30 by 30 grid of spheres is .xed. Each internal grid sphere 
is attracted to its four immediate neighbors under the constant force. The large sphere falls into this 
grid and comes to rest. We fake the bouncing by playing the sequence forwards and backwards. 5.4 Other 
Possible Applications. The examples we have implemented only scratch the surface of what one could do 
with the current formulation. For example, we could apply these new potential functions to two animations: 
a pearl falling in shampoo and a lava lamp . The shampoo or lamp .uid is a grid-like gas of spheres. 
A constant force at­tracts sphere Sito a .xed grid point gi. The algorithm for modeling attraction of 
a moving point pito a .xed point qiis straightforward from the math given above. The pearl is a single 
sphere in a gravitational potential falling through a shampoo. The lava lamp .uid uses the same model. 
We also add a rising blob of lava .uid subject to an upwards gravita­tional .eld. The beads in the blob 
.uid are subject to a mutually attractive force. For this we choose a potential function which rises 
linearly to a particular value and then stops increasing. This po­tential corresponds to a constant, 
short-range force. This potential function is convex, and thus linear programming can minimize it.  
6 Implementation and Results All examples in the video are a simple mapping of optimization steps to 
frames. We believe that these demonstrate a variety of re­alistic looking motions. If necessary, we could 
modulate the ve­locity by interpolating between frames. Since consecutive frames 0 correspond to motion 
from cto cin the same convex region, every interpolated con.guration would also be valid. 6.1 Running 
Times and Scalability As usual, our program is always in .ux, and it is dif.cult to gener­ate meaningful 
timings. The running time depends greatly on the settings of the parameters to the linear programming 
library. Cur­rently, we use the simplex method. We .nd that reaching 80-90% of optimum requires only 
about one-quarter the time as reaching the optimum objective value. Hence, each step can be accomplished 
in one-quarter the time using only 1/0:8=1:25times as many steps. This is clearly a good trade-off. At 
present, we run each linear pro­gram for 5000 simplex steps, and this always brings us to within 80% 
of optimal. Using these particular methods, we can compute each frame of the second hourglass video in 
about 1.1 minutes on a DEC Al­pha 3000/700 (tm). The entire video can be generated in about 19 hours. 
We ran the program with only 500 spheres, and each frame was computed 2.4 times faster than with 1000 
spheres. Some of the cost is a naive O(n 2)geometric algorithm, and the cost of this can be improved. 
In essence, the cost per step appears to be roughly linear in the number of spheres. Of course, about 
half as many steps are required to simulate the hourglass. Therefore, the cost appears to be roughly 
quadratic in the number of spheres. As we discuss in Section 7, this is not necessarily the last work. 
It is unlikely that distant spheres interact over small numbers of steps. Therefore it should be possible 
to decompose the problem and/or apply multi­scale methods. 6.2 Number of Iterations If we are simply 
generating a pile or clump , we usually do not have an obstruction like the neck of the hourglass through 
which the spheres must pass more or less sequentially. The following ta­ble gives the number of iterations 
for a kby kby kgrid of spheres falling to rest in a box. The number iterations rises surprisingly slowly. 
This compares very favorably with acceleration or velocity­based methods. For these methods time until 
next collision ap­pears to be inversely proportional to the number of spheres and the number of steps 
to be at least linear in the number of spheres. Number of Spheres 27 64 125 216 Number of Iterations 
21 25 39 54 6.3 Comparison with Velocity-Based Methods We attempted to simulate the hourglass with a 
velocity-based method. As expected, collisions caused the time steps to be very small (around 10.5). 
It takes about 150 steps to reduce the energy by one unit. For this example, it would require 2 or 3 
million steps to reach minimum energy. Each step is faster, but only by a factor of two. We estimate 
it would take about 1000 times as long to reach an energy minimum than it does using the position-based 
method of this paper.  7 Conclusion and Future Work Position-based physics and the linear programming 
algorithms we use to simulate it are very good ways to rapidly .nd local energy minima for many interacting 
objects. They are much faster than other physical simulation techniques, and they are certainly useful 
for CAD/CAM applications for which only the .nal con.guration matters. The current techniques do not 
allow rotation in three di­mensions (a moot issue for spheres but not for moving polyhedra), but Li [19] 
has found ways to allow rotation in two dimensions, and it may be possible to generalize this work to 
three dimensions or de­vise other methods. The algorithms presented here do not simulate true physical 
motion: 1) the physics is only semi-Newtonian, and 2) the algorithms use a number of approximations to 
allow us to apply linear programming. However, in graphics appearance and speed are really all that matters, 
and these methods rapidly generate mo­tions which appear realistic. Since no other method can currently 
generate such motions with so little computation, position-based physics and linear programming based 
simulations warrant consid­eration as useful tools of computer graphics. Even for 1000 spheres in a polyhedron, 
the simulation time is faster than the rendering time. For even larger number of spheres, one would have 
to break the set of spheres into zones and sim­ulate within each zone. By switching between overlapping 
zones, one could still generate a good animation. Multi-scale techniques might also be applicable [20]. 
The issue of non-convex sets of valid directions arises for sets of translating polyhedra. However, we 
believe that this potential dif.­culty will not have a practical impact. A dif.cult practical problem 
is that of explicitly computing con.guration spaces (Minkowski sums) for pairs of translating non-convex 
polyhedra. Dealing with rotations will be even more dif.cult. However, we believe these dif.culties can 
be overcome. Position-based physics may one day simulate many highly interacting, translating and rotating 
polyhe­dra, with links and attractive and repulsive forces. Another direction of future work is to handle 
the transition from crowding to freedom. Position-based physics does not do a good job on freely moving 
objects. Section 4.4 describes how to make the falling spheres appear to accelerate. We use another trick 
to make the ball appear to bounce in the trampoline video. A more gen­eral solution would somehow switch 
between the position-based method and an acceleration/velocity-based method in a way that is low-cost 
yet realistic. Acknowledgements: Thanks to Kevin Duffy for implementing many of the algorithms as a summer 
job. Thanks to Lisa Ventry Milenkovic for proofreading and literature search. Thanks to Karen Daniels 
for proofreading and suggestions.  References [1] D. Baraff. Analytical methods for dynamic simulation 
of non­penetrating rigid bodies. Computer Graphics (Proceedings of SIGGRAPH), 23(3):223 232, 1989. [2] 
David Baraff. Curved surfaces and coherence for non­penetrating rigid body simulation. In Forest Baskett, 
edi­tor, Computer Graphics (SIGGRAPH 90 Proceedings),vol­ume 24, pages 19 28, August 1990. [3] David 
Baraff. Coping with friction for non-penetrating rigid body simulation. In Thomas W. Sederberg, editor, 
Computer Graphics (SIGGRAPH 91 Proceedings), volume 25, pages 31 40, July 1991. [4] David Baraff. Issues 
in computing contact forces for nonpen­etrating rigid bodies. Algorithmica, 10(2 4):292 352, 1993. [5] 
David Baraff. Fast contact force computation for nonpenetrat­ing rigid bodies. In Andrew Glassner, editor, 
Proceedings of SIGGRAPH 94 (Orlando, Florida, July 24-29, 1994),Com­puterGraphics Proceedings,AnnualConferenceSeries,pages 
23 34. ACM SIGGRAPH, ACM Press, July 1994. [6] David Baraff. Interactive simulation of solid rigid bodies. 
IEEE Computer Graphics and Applications, 15(3):63 75, May 1995. [7] David Baraff and Andrew Witkin. Dynamic 
simulation of non-penetrating .exible bodies. In Edwin E. Catmull, editor, Computer Graphics (SIGRAPH 
92 Proceedings), volume 26, pages 303 308, July 1992. [8] R. Barzel and A. H. Barr. A modeling system 
based on dy­namics constraints. Computer Graphics (Proceedings of SIG-GRAPH), 22(4):179 187, 1988. [9] 
Jim X. Chen and Niels Da Vitoria Lobo. Toward interactive­rate simulation of .uids with moving obstacles 
using navier­stokes equations. Graphical Models and Image Processing, 57(2):107 116, March 1995. [10] 
N. Chiba, S. Sanakanishi, K. Yokoyama, I. Ootawara, K. Mu­raoka, and N. Saito. Visual simulation of water 
currents using a particle-based behavioural model. Journal of Visualization and Computer Animation, 6(3):155 
172, July 1995. [11] D. Dobkin, J. Hershberger, D. Kirkpatrik, and S. Suri. Implic­itly searching convolutions 
and computing depth of collision. In Proceedings of the Second SIGAL, pages 165 180, 1990. [12] Jeff 
Goldsmith and Alan H. Barr. Applying constrained opti­mization to computer graphics. SMPTE Journal -Society 
of Motion Picture and Television Engineers, 102(10):910 912, October 1993. [13] L. Guibas, L. Ramshaw, 
and J. Stol.. A Kinetic Framework for Computational Geometry. In Proceedings of the 24th An­nual IEEE 
Symposium on Foundations of Computer Science, pages 100 111. IEEE, 1983. [14] James K. Hahn. Realistic 
animation of rigid bodies. In John Dill, editor, Computer Graphics (SIGGRAPH 88 Proceed­ings), volume 
22, pages 299 308, August 1988. [15] Mikako Harada, Andrew Witkin, and David Baraff. Inter­active physically-based 
manipulation of discrete/continuous models. In Robert Cook, editor, Proceedings of SIGGRAPH 95, Computer 
Graphics Proceedings, Annual Conference Se­ries, pages 199 208. ACM SIGGRAPH, ACM Press, August 1995. 
[16] Vincent Hayward, Stephane Aubry, Andre Foisy, and Yas­mine Ghallab. Ef.cient collision prediction 
among many moving objects. The International Journal of Robotics Re­search, 14(2):129 143, April 1995. 
[17] Michael Kass and Gavin Miller. Rapid, stable .uid dynamics for computer graphics. In Forest Baskett, 
editor, Computer Graphics (SIGGRAPH 90 Proceedings), volume 24, pages 49 57, August 1990. [18] A. Kaul, 
M.A. O Connor, and V. Srinivasan. Computing Minkowski Sums of Regular Polygons. In Thomas Sher­mer, editor, 
Proceedingsofthe ThirdCanadianConferenceon Computational Geometry, pages 74 77, Vancouver, British Columbia, 
1991. Simon Frasier University. [19] Z. Li. Compaction Algorithms for Non-Convex Polygons and Their Applications. 
PhD thesis, Harvard University, Division of Applied Sciences, 1994. [20] A. Luciani, A. Habibi, and E. 
Manzotti. A multi scale physi­cal model of granular materials. In Proceedings of Graphics Interface 95, 
pages 136 145, May 1995. [21] H. Mallinder. The modelling of large waterfalls using string texture. Journal 
of Visualization and Computer Animation, 6(1):3 10, January 1995. [22] V. Milenkovic, K. Daniels, and 
Z. Li. Placement and Com­paction of Nonconvex Polygons for Clothing Manufacture. In Proceedings of the 
Fourth Canadian Conference on Compu­tational Geometry, pages 236 243, St. Johns, Newfoundland, August 
1992. Department of Computer Science, Memorial University of Newfoundland. [23] V. J. Milenkovic and 
Z. Li. A Compaction Algorithm for Non­convex Polygons and Its Application. European Journal of Operations 
Research, 84:539 560, 1995. [24] H. Minkowski. Volumen und Ober.¨ache. Mathematische An­nalen, 57:447 
495, 1903. [25] M. Moore and J. Wilhelms. Collision detection and response for computer animation. Computer 
Graphics (Proceedings of SIGGRAPH), 22(4):289 298, 1988. [26] J. C. Platt and A. H. Barr. Constraint 
methods for .exible models. Computer Graphics (Proceedings of SIGGRAPH), 22(4):279 287, 1988. [27] J. 
Serra. Image Analysis and Mathematical Morphology,vol­ume 1. Academic Press, New York, 1982. [28] J. 
Serra, editor. Image Analysis and Mathematical Morphol­ogy, volume 2: Theoretical Advances. Academic 
Press, New York, 1988. [29] Mikio Shinya and Marie-Claire Forgue. Layout out objects with geometric and 
pysical constraints. Visual Computer, 11:188 201, August 1995. [30] John Snyder. An interactive tool 
for placing curved surfaces with interpenetration. In Robert Cook, editor, Proceedings of SIGGRAPH 95, 
Computer Graphics Proceedings, Annual Conference Series, pages 209 218. ACM SIGGRAPH, ACM Press, August 
1995. [31] Richard Szeliski and David Tonnesen. Surface modeling with oriented particle systems. In Edwin 
E. Catmull, editor, Com­puter Graphics (SIGGRAPH 92 Proceedings), volume 26, pages 185 194, July 1992. 
[32] Demitri Terzopoulos, John Platt, and Kurt Fleischer. Heat­ing and melting deformable models (from 
goop to glop). In Proceedings of Graphics Interface 89, pages 219 226, June 1989. [33] Andrew P. Witkin 
and Paul S. Heckbert. Using particles to sample and control implicit surfaces. In Andrew Glassner, editor, 
Proceedings of SIGGRAPH 94 (Orlando, Florida, July 24 29, 1994), Computer Graphics Proceedings, Annual 
Conference Series, pages 269 278. ACM SIGGRAPH, ACM Press, July 1994. 
			
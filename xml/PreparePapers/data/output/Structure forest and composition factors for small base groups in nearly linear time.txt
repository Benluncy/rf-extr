
 Structure forest and composition factors for small base groups in nearly linear time Robert Bealsl Akos 
Seress2 University of Chicago Ohio State University Abstract 1 Introduction A base ofa permutation group 
Gis a subset Bofthe permutation domain such that only the identity of G fixes B pointwise. The permutation 
representations of important classes of groups, including all finite sim­ple groups other than the alternating 
groups, admit O(log n) size bases, where n is the size of the permuta­tion domain. Groups with very small 
bases dominate the work on permutation groups within computational group theory. We use the soft version 
of the big-O notation in­troduced by [BLS1]: for two functions ~(n), g(n), we write ~(n) = ON (g(n)) 
if for some constants c, C > 0, we have f(n) < Cg(n) log n, We address the problems of finding structure 
trees and composition factors for permutation groups with small (ON (1) size) bases. For general permutation 
groups, a method of Atkinson will find a structure tree in 0(n2) time. We give an Ow (n) algorithm for 
the small base case. The composition factor problem waa first shown to have a polynomial time solution 
by Luks [Lu], and recently Babai, Luks, Seress [BLS2] gave an 0 (n3) algorithm. The [BLS2] algorithm 
takes (3(n3) time even in the small base case. We overcome several quadratic and cubic bottlenecks in 
the [BLS2] algorithm to give an 0-(n) Monte Carlo algorithm for the small base case. In addition, we 
show that the center of a small base group can be found in time O (n), lbeals@cs.uchicago. edu 2 ~o~~fuction.mps 
.oti-state.~u Permission to copy without fee all or part of this material is granted provided that the 
copies are not made or distributed for dirsct commercial advantage, the ACM copyright notice and the 
title of the publication and ite date appear, and notice is given that copying is by permission of the 
Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific 
permission. 24th ANNUAL ACM STOC -5/92/VICTORIA, B. C., CANADA e 1992 ACM ()-89791-51 2-7192/C)O0410~ 
16...$1.50 Let Q={l,... , n} and let Sym(fl) denote the symmet­ric group acting on !2, i.e. the group 
of all permutations of G?. For G < Sym(Q), we will represent G by a list of generators. A base for G 
is a subset B = {bl, b2, ... bt}, of $2 with the property that only the identity fixes B pointwise. If 
B is a non-redundant baae, i.e. no proper subset of B is a base, then the following relation is im­mediate: 
2t< IGI<nt. We call G a small base group if G has a base of size t< (log n) for some constant c. By the 
inequality above, this is equivalent to the condition that log IG[ < log n for some constant c . ,(We 
refer to infinite families of groups; the constants should not depend on how large a member of the family 
is chosen,) Important families of groups, including all permu­tation representations of finite simple 
groups except the alternating groups, are small base groups. Cur­rent computational interest centers 
around small base groups, underlining the importance of finding eilicient algorithms for this class. 
Our goal is to design nearly linea~, O-(n), algorithms to obtain quantitative and structural information 
about small base groups. The main results of this paper are the nearly linear time constructions of a 
structure forest, a composition series with permutation representations of the compo­sition factors, 
and the center for small base groups. A structure foresf of the permutation group C < SYm(Q) describes 
the imprimitivity structure in an algorithmi­cally useful way. Its nodes correspond to blocks of imprimitivity, 
and the block corresponding to a node is maximal in the block corresponding to its parent. (The structure 
forest is usually not uniquely associated with G,) A structure forest can serve to guide divide­and-conquer 
algorithms for permutation groups (see e.g. [GHLSW]). We present a nearly linear time algorithm to find 
a structure forest for a small base group. This plays a crucial role at several steps in the composition 
 factor algorithm, and is also of independent interest. (cf. Section 5). The overall architecture still 
follows Theorem 1.1 Let G ~ Sym(Q) be given by a generat­ing set S of size s. Then a structure forest 
for G can be obtained deterministically in time 0(n(log3 [Gl)). In particular, for small base groups, 
the algorithm runs in time O-(sn). A composition series for G is a sequence of subgroups, each normal 
in its predecessor, G = NO b fVI b . . . b Nm = 1 such that for 1 < i ~ m, the factor group iVi-1/lV~ 
is simple. The composition series is in general not unique, but the composition factors Ni _ 1/Ni are 
determined (up to possible reordering) by G. The cen­ter Z(G) of G is the subgroup of those elements 
which commute with each element of G. Theorem 1.2 Let G ~ Sym(t2) be given by a gener­ating set S of 
size s. Then a composition series, to­gether with permutation representations of the compo­sition factors 
of G, can be obtained in Monte Carlo time O(n(logc lG\ + s)). In particular, for small base groups, the 
algorithm runs in time O-(sn). Similar results hold for finding the center. It is reasonable to assume 
that the number s of gen­erators is O(log IGl). Note that the size of the input is sn. Composition factors 
are the basic building blocks of groups. Deeper structural study of a group requires the knowledge of 
the composition factors and, consequently, the solution of algorithmic problems requires the con­struction 
of a composition series. For example, Theo­rem 1.2 has been used by Luks and Seress to determine in nearly 
linear time the maximal solvable normal sub­group and Fitting subgroup (maximal nilpotent normal subgroup) 
in small base groups. The first polynomial time, 0(n8 + sn2), algorithm for finding the composition factors 
was given by Luks [Lu]. Luks s main goal was to demonstrate that the problem is solvable in polynomial 
time. Recently, a more efficient version of Luks algorithm was given in Babai, Luks, and Seress [BLS2] 
with ON (sn3) running time. Special­izing to the small base case, the algorithm in [BLS2] has six subroutines 
with f2(n2) and one with Q(n3) timing; we achieve nearly linear time by breaking these bottle­necks, 
using a host of novel deterministic and random tricks. In particular, the structure forest algorithm 
is used to reduce the problem to the primitive case, and is used to find certain maximal subgroups. Random 
meth­ods include the algorithm of Babai, Cooperman, Finkel­stein, Seress [BCFS] for computing a base 
and strong generating set; as well as a combination of the fast nor­mal closure algorithm of [CF, BCFLS] 
with Babai s construction of nearly uniformly distributed group el­ements [Ba] and a novel trick to preserve 
properness of subgroups through a sequence of random generations Luks s original description [Lu], while 
subroutines have been replaced by much faster ones taking advantage of the new ideas. For the analysis 
of the composition factors algorithm, we depend on the fact that the outer automorphism group of a finite 
simple group is solvable. This re­sult, called Schreier s Hypothesis, is a consequence of the classification 
of finite simple groups. Also, we use the Feit-Thompson Theorem, that non-abelian simple groups have 
even order. The remaining group theory we need is elementary but nontrivial ([SC] ,[PS]). Finding the 
center is elementary and much easier. Polynomial time algorithms for computing Z(G) have been known for 
almost a decade [Lu,Ho,CFL]. Our method, presented in Section 9, is a slight modifica­tion of the [CFL] 
algorithm, also using the results of [BCFS]. 2 Notation and definitions We say that G ~ Sym(Q) is transitive 
if $2 is an orbit of G, and primitive if in addition there is no nontrivial partition of Cl invariant 
under G. If G is imprimitive, a nontrivial G-invariant partition of an orbit of G is called a block system, 
and the sets in the partition are called blocks of imprimitivity. We say that a block system is minimal 
if the number of blocks is minimal, i.e. the action of G on the blocks is primitive. For z c Q, we denote 
by Gc the pointwise stabilizer of z. If A ~ Q we denote by GA the pointwise stabilizer of A and by G{A} 
the setwise stabilizer of A. Definition: A structure tree of the transtive group G < Sym(Q) is a rooted 
tree T with Q as leaves admitting G as automorphisms such that for each node v E T, G acts primitively 
on the children of v. Each level of T corresponds to a block system which is minimally coarser (as a 
partition) than the block system one level below. A structure forest is a union of structure trees, one 
for each orbit of G. A basic tool in all of our algorithms is a strong gen­erating set (SGS) introduced 
by Sims [Sire]. An SGS is a complete set of coset representatives for Gihl in Gi for each group G~ in 
the subgroup tower G=Go~Gl~...~Gt=l where Gi denotes the subgroup of G that fixes the first i points 
of a specified base B = {bl, b2,.. ., bt}. For small base groups,the algorithm of [BCFS] computes a base 
B and an SGS in time O-(n), with t = O-(l). The coset representatives for each group modulo its succes­ 
sor are stored as words of length O(log n) over a set of ON(1) permutations. We will assume that we 
have a fixed base B = {bl, bz, . . . . b,} and SGS for G. We will also use x and y to refer to the first 
two base points, respectively. We denote by r. the coset representative for G= in G that takes x to u, 
and by IJV the coset representative for G~Y in Gc that takes y to v. We will consider other permutation 
actions of G. We say G acts on a set @ if there is a homomorphism from G to Sym(@). The kernel of the 
action is the kernel of the homomorphism, and is a normal subgroup of G. G < Sym(fl) acts faithfully 
on the set @ if the kernel is the identity of G. Kernels of actions can be computed in O-(n) time ([BCFS]). 
The socle of G is defined to be the product of all min­imal normal subgroups of G, and we denote it SOC(G). 
For H ~ G, we define the normal closure of H in G to be the smallest normal subgroup of G containing 
H, and we denote it NcIG (H). We denote by g~z the prod­ uct gz-lglgz, by Hg the subgroup g-lHg, and 
by HG the union Ug~GHg. The normalizer of H in G, de­noted NG (H), is the subgroup of those g E G such 
that H9 = H. The centralizer of H in G, denoted CG(H), is the subgroup of those g E G such that hg = 
h for all h E H. The index IG :HI of H ~ G is the number of cosets of H in G, i.e. lG1/lHl. Let H1, H2, 
..., H~ be groups isomorphic to a group H. For 1< i< klet #J~: H ~ Hi beanisomor­phism. The diagonal 
subgroup Diag(H1 x . . . x Hk) (relative to the given isomorphisms) is the subgroup {(h+ ,..., ho ) I 
h c H}. Letgl,.. ., gk E G. A random subproduct of the gi is a product of the form g; g~ . . . g~k where 
the ei are cho­sen independently from the uniform distribution over {O, 1}. Random subproducts were introduced 
in [BLS1]. The following basic property first appeared in [BCFLS]: Fact 2.1 Let H be a proper subgoup 
of (gl, . . . . g~). Then with probability at least 1/2, a random subprod­uct Of the gi wall not be in 
H. A probability distribution on a set X is c-uniform if the probability of every element is between 
(1 c)/lXl and (1 + c)/lXl. We call gl, . . . . gk c-uniform Erd6s-R4nyi generators for G if random subproducts 
of the gi are e-uniformly distributed in G. 3 Finding a structure forest To obtain a structure forest 
for G, we need to find (in­dependently) a structure tree for each transitive con­st it uent of G. Therefore 
we may henceforth assume that G is transitive Let x denote the first base point bl. For X ~ Q, let X* 
denote X U {z}, and let ~ denote the smallest block of imprimitivity of G cent aining X*. For u E Q, 
let F denote {u}. We introduce the following equivalence relation on Q: for u, v E Q, we write u ~ v 
to mean that z = U. We also introduce a transitive relation on subsets ofQ: for X,Y ~ 0, wewrite X ~ 
Y to mean ~ ~ ~. Observe that ~ restricted to equivalence classes of * is a partial order. The following 
are immediate: Proposition 3.1 For all X ~ Q, X ~ ~ = ~.Cl Proposition 3.2 Let X be an equivalence class 
of -, and A be a block of imprimitivity containing x. If X n A # 0, then~~ A.u The algorithm maintains 
an equivalence relation P on $2\ {x} with the invariant property that for u, v E !2 \ {z}, VPU ~ v -u. 
Let ~ denote the set of equivalence classes of P. We will maintain a partial order R on ~ with the invariant 
property that for X, Y E ~, X RY ~ x~Y. The algorithm makes use of an arbitrary permutation n E Sym(Q) 
such that the cycles of m are the orbits of G=. Note that we do not require that r be an element of G, 
so it may be calculated in linear time from the orbits of Gr. -We use a subroutine GROW which given a 
set X E P, finds 1X1 points of ~ \ X*, or finds all of%\ X* if 1X1 z 1~1/2. First we need a lemma: Lemma 
3.3 For any X EP, for any uc X, G{zl = (GZ, rJ. Proof Let K denote (Gz, r.). Observe that ~ = ii since 
X is a subset of an equivalence class of -. Since D is a block of imprimitivity cent aining z and u, 
both Gc and ru stabilize it, so K < G{i-i}. Let A = XK. Both K and G{z} are unions of cosets of G., so 
to prove K = G{=} it suffices to show that ~ ~ A. First observe that A is a block of imprimitivity: suppose 
g c G with v c A9 n A # A. By multiplying g by an element of K we may assume that v = x. Then g belongs 
to a coset of G= which is cent ained in K, so g c K and A9 = A, a contradiction. since A contains ~ and 
u, by Proposition 3.2 we have ~ &#38; A. Therefore G{%} = K.U Observation 3.4 (Gz, TV) and (r, r.) have 
the same orbiis. D Even though we do not have ~ explicitly, we know that ~ = z{ j. GROW uses an array 
which stores for all v E !2 the last time v was located by GROW, and uses standard search techniques 
to find the or­bit of z under the action of (~, r.), but halts as soon aa min(21Xl + 1, 1~1) points are 
found. The set Y of points found in ~ \ X* is returned. Note that IYI ~ min(lXl, l~\ X*1) as desired. 
Let f? = O(logn) be the length of the word representing Tu. Then 1 steps are required to find the image 
of a point under TU, and GROW takes 0( IX I/) steps to run. The equivalence relation P is initialized 
to correspond to the partition of !2 \ {z} into orbits of Gc. Since any block of imprimitivity containing 
z is a union of or­ bits of G., P is a refinement of -. The ordering R is initialized to be an antichain 
(no two elements are comparable). This is certainly weaker than ~. In the course of the algorithm, we 
add comparisons to R, al­ ways making sure that it remains weaker than ~. For instance, if Y = GROWIX], 
then for any Z c P such that ZnY # 0,weknow that Z ~ X, sowe may add the relation Z RX to R. This may 
create cycles, so we periodically need to run a procedure MERGE, which uses Tarj an s algorithm [Ta,AHU], 
to find strongly con­ nected components of-R and merges them into single equivalence classes of P. This 
maintains the invariant property that P is a refinement of W. Below we present pseudocode for the main 
part of the algorithm: BLOCKIG] Input: G < Sym(Q) Output: A minimal block of imprimitivity properly 
containing {z}. I* Note that G aS primitive if and only if the output is Q. */ Step 1: Run the [BCFS] 
algorithm to obtain coset represent atives ru, u c Q, and to determine the orbits of G.. Step 2: Fix 
r, an arbitrary permutation such that the cycle of zr are the orbits of G=. Step 3: Initialize ~ to be 
the partition of Q \ {z} into orbits of GZ. Step 4: Initialize R to be an antichain. Step 5: for all 
R-minimal X c ~, do 1. Let Y = GROWIX]. 2. if Y = 0 then halt and output X*.  3. for allZc~suchthat 
ZnY#0,do add ZRXto R. Step 6: MERGE. Step 7: goto Step 5. The following lemma establishes the correctness 
of the algorithm: Lemma 3.5 For any X E ~, if GROWIX] = @ then X is a minimal block of imprimitivity 
properly con­taining {z}. Proofl Since GROWIX] = 0 it follows that X* = ~. Since X is a subset of a 
~-equivalence class, we know by Proposition 3.2 that no block of imprimitivity lies strictly between 
{x} and ~. D Standard techniques for UNION-FIND (cf. [AHU]) can be used to maintain ~ in total time less 
than O(n log log n). Most of the time of our algorithm is spent in calls to MERGE and GROW. Lemma 3.6 
The total number of calls to MERGE is O(log n), (even if we use the algorithm to find the entire structure 
tree). Proofi Let Al ~ A2 ~ ... CAk =Q be these­quence of minimal blocks constructed. Since for all i, 
lAil divides Ai+l, we have k < log n. After every call to MERGE until the last one before AL is output, 
the cardinality of R-minimal elements of P which are subsets of Al at least doubles (since they have 
all been GROWN). So at most (logIA111 calls are made before Al is found. Once Al is found, Q is replaced 
by a set of size n/[A11, so at most [log(lA1 l/lA21)l calls are made before AZ is found. Continuing in 
this way, we see that the total number of calls is at most k + log n <2 log n.n Lemma 3.7 The total amount 
of time spent on GROW is O(nllog n). Proof: Let k < log n be the depth of the structure tree obtained. 
Each element i c Q is in an R-minimal set at most k + log n times, by an argument similar to that in 
the proof of the previous lemma. Each call to GROW takes at most O(l) steps per element of the set being 
GROWn, so the total time is O(nllog n).a Theorem 3.8 Assume orbits of G. are given along with length 
! words representing a transversal for G3. Then the total time to calculate a structure tree (omit­ting 
Step 1) is O(n log n(t + log n)). Proofi By Lemma 3.6, the algorithm makes O(log n) calls to MERGE. Since 
at most n arcs are added to R between calls to MERGE, each call is made on an input of size at most n 
log n. Since Tarj an s algorithm is linear time, the total time spent in calls to MERGE, is O(n logz 
n). By Lemma 3.7 the amount of time spent in calls to GROW is O(nl log n). Combining, we get the desired 
time bound. D Remark: / = O(log n) can be achieved using the [BCFS] algorithm. Remark: The only randomization 
is in Step 1. The algorithm may be modified to run deterministically even in the case that the orbits 
of GZ and coset representa­tives are not given [Be].  4 Reduction of the composition factor problem 
In this section we reduct the problem of computing composition factors to that of finding a proper normal 
subgroup of a primitive group or determining that the group is simple. It is enough to find a maximsJ 
normal subgroup IV of G and a permutation representation of G/N in O-(n) time since, in small base groups, 
ON(1) repetitions of this procedure yields a composition series and the com­position factors. Also, it 
is enough to find maximal nor­mal subgroups in pn mitive groups since G acts prim­itively on a minimal 
block system (i.e. minimal num­ber of blocks), and the pullback of a maximal normal subgroup in this 
primitive action provides a maximal normal subgroup in G. A minimal block system can be found in time 
O-(n) by Theorem 3.8. A further reduction is that it is enough to find any proper normal subgroup N in 
a primitive group and a permutation action on a set @ such that N is in the kernel of the action. With 
0-(1) repetitions, we obtain the desired maximal normal subgroup. Lemma 4.1 Let N Q G be given. We can 
find a non­ trivial action of G with N in the kernel in ON(n) time. Proof: Following Luks [Lu], first 
we find i such that G = GiN # Gi+lN. Let H = Gi~lN. We will find the action of G on the cosets of H (this 
will have N in the kernel). Let Hi = H n Gi. Note that any complete set of coset representatives for 
Hi in Gi is a complete set of coset representatives for H in G because if Gi = UHiUj j then G= GiN =UHi~jN 
= UHiN~j = UH~j. j 3j The uj will be non-redundant coset representatives for H as long as they are non-redundant 
coset representa­tives for Hi, since they are all in Gi. Since Gi ~ Hi ~ Gi+l, Hi is the setwise stabilizer 
of a block of imprimitivit y of G1 acting on cosets of Gj+ 1. The action of Gi on the cosets of Hi is 
just the action on this block system, Since the uj are non-redundant, the action of Gi on cosets of H 
is the same as its action on cosets of Hi. The action of J/ is trivial, and since G = GiN we can get 
the action of G.u Corollary 4.2 If a proper normal subgroup of a non­simple primitive group can be found 
in Ow (n) time then the composition factor problem can also be solved in O (n) time. In Section 7 we 
need the following stronger lemma: Lemma 4.3 Suppose N is a normal subgroup of G such that G = GiN # 
Gi+lN but no generators for N are known. Given a subgroup H such that G # H z Gi+lNj we can find the 
action of G on cosets of H in time O (n). Proofi First calculate an SGS for H (using the base l?). Let 
Hi = H n Gi, and coset representatives uj be as above, Also, for each v c {bi+l}G$, compute j(v) such 
that v c {bi+l}H*U~(*). As above, the action of Gi on cosets of Hi is the action of Gi on a block system 
of the cosets of Gi+l, and aj(v) is simply the coset representative assigned to the block containing 
v. For g c G, it is enough to find the action of g on the cosets of H in 0-(n) time. Since G = GiH$ given 
a permutation g E G, we may in O (l) time find T c H (as a word over the SGS for H) such that gr-l e 
Gi. Given g c G, for each coset representative ~j we want to find a coset representative a~ such that 
H~jg = H(rk in O (1) time. TO do this, find r c H such that (ujg)-lr-l c Gi. We have H~ujg = Hajg. Let 
v = (bi+l) o;$ . Then k = j(v) is the k we want, since the quotient Ujgflk 1 c Gi stabilizes the block 
of bi+l and therefore belongs to H. D We shall find a proper normal subgroup either as the normal closure 
of a carefully constructed random ele­ment of G (this method will work if G haa a normal subgroup of 
index < n) or as the kernel of action for G acting on the cosets of an appropriately chosen maximal subgroup 
H, H will depend on the type of the socle of the primitive group G (cf. Section 6.)  5 Preliminary algorithms 
In this section we present some efficient algorithms for working with subgroups of G. The SGS constructed 
by the [BCFS] algorithm enables us to represent any g c G ss a product of t coset representatives of 
sub­groups modulo their successors in the point stabilizer subgroup chain. Moreover, each coset representative 
can be written as a word of length ON(1) over a set of 0-(1) permutations, yielding a word of length 
ON(l) to represent g. Given two permutations represented this way, we can in 0-(1) time find the represent 
at ion of their product. Since an SGS for G is known, it is easy to generate in Ow (1) time a uniform 
random element of G. The following theorem of Babai [Ba] will allow us to quickly generate generate random 
elements of any subgroup of G: Theorem 5.1 Let c, C >0 be given constants, and let c = N-c where N is 
a given upper bound on the order of the group G. There is a Monte Carlo algorithm which; given any set 
of generators of G, constructs a sequence (H, g) # G. To do this, pick gl E G \ H arbitrarily. of O(log 
N) c-uniform Erd&#38;-R6nyi generators at a cost Find gz a random element of (H, gl) \ H. And so on: 
of O((log N)5) group operations. The probability that given gi, find gi+l a random element of (H, gj) 
\ H. If H the algorithm fails is < N-c. is not maximal then after 1 = 0-(n) iterations we will If the 
algorithm succeeds, it permits the construc-have with high probability that the group L = (H, gl) tion 
of ~-uniformly distributed random elements of G is a proper subgroup of G. We compute an SGS for at a 
cost of O(log N) group operations per random L to determine if L = G, in which case we output H. eZement. 
U Otherwise, we replace H by L and repeat.0 Corollary 5.2 Suppose H ~ G is given by s gener­ators (represented 
as words of length O(t log n) over 6 The O Nan-Scott Theorem the SGS). We can generate c-uniform elements 
of H The O Nan-Scott Theorem classifies primitive groupsin O-(s) time.0 into a small number of types 
[Sc,Cam,Lu]. The state- The technique of short representation of products, ment below represents a regrouping 
of the cases to suit combined with the black box normal closure algo-our purposes. rithms of [CF, BCFLS], 
allows us to compute normal Lemma 6.1 Let G be a primitive permutation group ofclosures quickly: degree 
n. Then one of the following occurs: Lemma 5.3 Suppose H ~ G is given by s genera­ (i) G is cyclic of 
prime order. tors (represented as words of length O(t log n) over the SGS). We can compute NcIG(H) in 
O-(s) time.tl (ii) G has a proper normal subgroup of index s n. Proofi We sketch the normal closure 
algorithm of [CF]: (iii) G has a proper minimal normal subgroup N1 with Given generators for H, we want 
to find an element of CG(N1) # 1. HG \ H (if there is one). If H is not normal in G, then (iv) G has 
a normal subgroup M with G/M P Am,a random subproduct g of the generators for G will not m ~ logn/loglogn, 
SOC(G) = N1 x. . . x N~ is the normalize H with probability at least 1/2. In this case unique minimal 
normal subgroup of G, and G actsa random subproduct h of the generators for H will be by conjugation 
as Am on the set of Ni s. Moreover,outside H n H9-1 with probability at least 1/2. So with one of the 
following holds. probability at least 1/4, we have h$ 6 HG \ H. Add h$ to the list of generators of 
H, and repeat o(bg IGI) (a) SOC(G)Z = (Nl)= x . . . x (Nm)=, 1 # (N~)z # times. l Ni . Combining the 
above two results, we can find a nor­(b) SOC(G) = T1 X ... x TV where the T$ are iso­mal subgroup of 
G if one exists with small index: morphic nonabelian simple groups, mlr, and Theorem 5.4 Let G be a 
small base group of degree n. SOC(G)C = Diag(Tl x . . . x T,). Then in time O (n) we can find a proper 
normal sub­ (c) SOC(G) is nonabelian regular. group of G or determine that G has no normal subgroup 
of index ~ n. (v) G is non-abelian simple. Proof: Take gl c G at random. Take successively Proofi Let 
G be a primitive group. If G has a mini­gz C Ncl((gl))at random, gs c Ncl((gz)) at random, mal normal 
subgroup with nontrivial centralizer then G and so on. When we have gl with 1 = O (n), with high belongs 
to case (i) or (iii). Otherwise, G has a unique probability gt belongs to a proper normal subgroup of 
minimal normal subgroup, SOC(G) = T1 x ... x T~ where G, or G has no normal subgroup of index ~ n. To 
the Ti are isomorphic nonabelian simple groups, and determine which is the case, we calculate an SGS 
for r ~ logs n. If r = 1 then T1 s G ~ Aut(Tl) and, by N = Ncl((gl)) and see if N = G.0 Schreier s hypothesis, 
G belongs to case (ii) or (v). If r > 1 then G acts by conjugation transitively on We can use a similar 
technique to embed a subgroup {Tl, ....T.}. Let M be the pointwise stabilizer of a min-H in a maximal 
subgroup of small index: imal block system in this transitive action. Then ill a G and G/M ? L for some 
primitive group L, L ~ S~ forLemma 5.5 Suppose H s G has the property that any some rnlr. If L does not 
contain Am then, by [PS],maximal subgroup K of G containing H has index 5 n. IL!~4m<nandGbelongs tocase(ii). 
IfL=SmThen we can find such a K in time O-(n). then G haa a normal subgroup of index 2. Finally, if 
Proofi First calculate an SGS for H. Finding a max-L = Am then either m < log n/ log log n and G belongs 
imal K ~ H reduces to finding a g c G \ H such that to case (ii) or m ~ log n/ log log n and G is in 
case (iv). The three subcases correspond to the classification of primitive groups in the O Nan-Scott 
Theorem, accord­ ing to the nature of SOC(G)C. D Since IGI is known, we can tell if G is in case (i). 
By Theorem 5.4, we can find a normal subgroup in case (ii). We present an algorithm for csse (iii) in 
Section 7, and case (iv) is treated in Section 8. If none of the algorithms returns a normal subgroup, 
we conclude that G is simple. 7 The case of nontrivial central­izer Throughout this section, we assume 
that G has a proper minimal normal subgroup iV1 with CG(N1 ) # 1. N1 is necessarily regular. If N1 is 
abelian then it is the unique minimal normal subgroup; if N1 is nonabelian then there are exactly two 
minimal normal subgroups, centralizing each other. A common feature of the two sub cases, most important 
for the present discussion, is that in any faithful primitive permutation representa­tion of G, N1 must 
act regularly. Therefore, it is enough to find a maximal subgroup K which intersects N1 non­trivially. 
Then the permutation representation of G on the cosets of K cannot be faithful, since an element of N1 
fixes the point K which would be impossible in a regular action, The normalizer H = NG(G~V ) contains 
the unique nv E N1 which carries x to y. So we are done if we can find H, embed H in a maximal subgroup 
K, and find the action of G on cosets of K. Lemma 7.1 We can find H = NG(G=V) in time O-(n). Proof: Let 
L be the set of tixed points of Gcv. NG (Gzv) consists of those g c G which fix L setwise; moreover, 
NG (G=y ) acts transitively on L. Therefore, to obtain the normalizer of G CY ~ execute the following 
steps: 1. Initialize If to be G=Y. 2. while there is an 1 c Ln~G= \~, let H = (H, al).  3.while there 
isan1E L\x~, let H = (H,mvrt) where v E yG= n L7~-1. (Such a v exists since the normalizer of G.y acts 
transitively on L.) After the second step, H is NG= (G=v), and it is enough to embed H in a subgroup 
which acts transi­tively on L. This is accomplished in the third step. We can increase H at most 0-(1) 
times, so each of steps 2 and 3 executes O*(1) times. Each execution of step 2 or 3 takes O=(ILI) time. 
n Lemma 7.2 Any maximal subgroup K containing H has indez < n. Proof: K contains GZY and a regular normal 
subgroup N, since the normal subgroup contained in K must con­tain a minimal normal subgroup. So [G : 
KI ~ IG : Therefore, we may apply Lemma 5.5 to find K and Lemma 4.3 to find the action of G on cosets 
of K. We now have: Theorem 7.3 Let G be a primitive group with a min­imal normal subgroup whose centralizer 
is nontrivial. Then a proper normal subgroup of G can be found in time ON(n).Cl 8 The case G has a normal 
sub­ group M with GJM = Am, m ~ log ni log log n In this section we assume that G is primitive of the 
type described in case (iv) of Lemma 6.1. We treat each subcase separately, and we will either find a 
nor­mal subgroup of G, or reduce the problem by finding a faithful action of G on at most n/2 points. 
In all subcases, SOC(G) = Tl x ... x T, with Ti isomor­phic nonabelian simple, and ~ acts (by conjugation) 
ss Am on blocks of the Ti for some mlr. Babai, Luks, and Seress [BLS2] have observed a connection between 
this conjugation action and the permutation action of G=. The quadratic bottleneck in the [BLS2] algorithm 
for this case is finding minimal block systems (cf. Sec­tion 3). G = U G. ru, where the coset representatives 
r. can be chosen from N = SOC(G). For g E G=, GZrUg = G=gg-l rug = G.(g-l~tig). So the orbits of G= corre­spond 
to the conjugacy classes of the cosets of G=. Also, G/N E G=/Nc, so conjugating by G. also acts as Am 
on the Ni. Let K Q GZ be the kernel of the conjugation action of G. on the Ni. Then G=/K z Am, and conju­gation 
by K fixes the Ni. Also, the elements of SOC(G) can be considered as m-tuples, with ith coordinate in 
Ni. Let ~i be the projection of SOC(G) onto Ni. Suppose G falls into subcsse (a) of Lemma 6.1, i.e. SOC(G) 
= NIX,.. xNm, SOC(G)= = (Nl)z X . ..x(Nm)z. 1 # (Ni)x # JJi, and G acts b conjugation as Am on the set 
of Ni s. Lemma 8.1 [Lu] Let G be a primitive group of the type described in subcase (a) of case (iv) 
of Lemma 6.1. Then there are points w, y, z c Q such that the coset representatives ~W,TY,~Z of SOC(G)Z 
in SOC(G) have the following properties: J. mi(~v)E (Ni)= for all i except i = 2; 2. 7r~(rZ) ~ (N~)n 
for all i ezcept i = 1; Therefore y can be found in 0-(1) tries, and the .9. r~(rW) C (N~)z for all i 
except i = 2. Furthermore, the subgroup H = (G=v, G~~) is proper, and the action of G on cosets of any 
maximal subgroup containing H is either not faithful or of degree ~ n/2.cl This is true even if the action 
of G on the Ni is not Am. Babai, Luks, and Seress [BLS2] have the following strengthening in the case 
that G acts as Am on the N~: Lemma 8.2 [BLS2] Points w, y, z described in Lemma 8.1 exist with the following 
additional proper­ties: y, z belong to the smallest orbit of GZ, and w is in the smallest orbit of G=. 
The smallest orbits of G= and G, have size O-(l). Proofi See the Appendix.D Therefore, we can find w, 
y, z in 0 (1) tries. Since H = (GXY > GZW) COntainS GSY, the action of G on cosets of H is the action 
of G on a block system of cosets of G .Y. The action of G on cosets of Gzy is the action of G on (z, 
y)G, and can be found in 0-(n) time since the index of G=y in G is 0-(n). The block system corresponding 
to H can be found in 0-(n) time since we have generators for II. Finding the action of G on a maximal 
subgroup containing H is equivalent to finding a minimal block system in the action of G on cosets of 
H, which takes 0 (n) time by Theorem 3.8. This completes the algorithm for subcase (a) of case (iv) of 
Lemma 6.1. Now suppose that G falls into subcase (b), i.e. SOC(G) = T1 x... x T,, Ti isomorphic non-abelian 
simple, and SOC(G)= = Diag(T1 x ... x T.). The points of Q correspond to elements of T -1. Fol­lowing 
Luks [Lu], it is enough to find a point y such that the corresponding element is an involution in T1 
(here we are using the Feit-Thompson Theorem to guarantee the existence of an involution in T1.) Lemma 
8.3 [Lu] Let G be a primitive group of the type described in subcase (b) of case (iv) of Lemma 6.1. Let 
y = X for some involution u c T1. Then the action of G on a minimal block system of (x, y)G is not faithful 
or of degree s n/2a This is true in general when SOC(G)C is diagonal. Babai, Luks, and Seress [BLS2] 
have the following in the case that G acts ss Am on blocks of the Ti: Lemma 8.4 [BLS2] The point y described 
in Lemma 8.3 can be found in the G. orbits of size < log2 n. Furthermore, there are only 0-(1) points 
in such orbits. Proof: See the Appendix.D action of G on {x, y}G can be found in 0-(n) time, since the 
index of G{z,g} z GZY is ON(n). We find the action of G on a minimal block system of (z, y)G in time 
ON(n) by Theorem 3.8. This completes the algorithm for subcase (b) of case (iv) of Lemma 6.1. Finally 
suppose that G is in subcsse (c): G has a unique regular normal subgroup SOC(G) = N1 x. . .x Nm and G 
acts by conjugation as Am on the set of Ni s. In this case we proceed as in Section 7: the normalizer 
H of Gzv intersects N nontrivially, so for any maximal subgroup K containing H, N is not regular in the 
action of G on cosets of K. That does not imply that the action is not faithful, but if it is faithful, 
the action must be on a set of size < n/2. We can find H as in Lemma 7.1. To embed H in a maximal K, 
we first need a result of [BLS2]: Lemma 8.5 [BLS2] Assume that y is in the smallest orbit of G=. Then 
the index in G of G.y is O-(n). Proofi See the Appendix.U Therefore, we can find the action of G on cosets 
of H ~ G=y in time 0-(n). The action on a minimal block system of cosets of H can be found in time ON(n) 
by Theorem 3.8. This completes the algorithm for case (iv) of Lemma 6.1. We have: Theorem 8.6 Let G be 
a primitive group of the type described in case (iv) of Lemma 6.1. Then in time @ (n) we can find an 
action of G which is unfaithful oronaset of~npoints. Cl If none of the algorithms in this section produces 
an action of G which is unfaithful or on ~ n/2 points, we conclude that G is not in case (iv). This completes 
the composition factor algorithm. 9 Finding the center of a small base group Theorem 9.1 Let G be a 
small base group. We can calculate Z(G) in time ON(n). Proofi Let Z(G) < K < C,Sn(G). Then, by a tech­nique 
of Cooperman, Finkelstein, and Luks [CFL], the center of G can be found se fast as an SGS for (G, K). 
I(G, K)l = \KllG/Z(G)l so our task is to find such a K with a small base. Let Al, A2, ... be the orbits 
of G. We can suppose that BnAi # 0exactly for 1< i ~ k, k= Ow(l). Given the action of any element g of 
G on ui<~ A;, this action uniquely determines g and g can be rec~nstructed in O*(n) time; so we shall 
construct K acting only on Ui<k Ai. Let K = ~i<~ Cswn(A,)(GIAi)O CSytn(AiJ(GIA,) is semiregular so 1? 
is a small base group. Moreover, K contains Z(G) restricted to Ui<k Ai. So it is enough to solve th; 
following subproblem. Given G acting transitively on A, find C sYm(A)(G) in O-(lAl) time. Let z c A and 
U = {u e AIuG= = u}. Then 1~1 = lCSY~(A)(G) 1,CSY~(A)(G) acts regularly on U, and for any u c U, the 
unique c c Csym(A)(G) such that z = u can be constructed in ON ( IA[) time. (See Lemmas 4.2-4.4 in [CFL].) 
To find CSym(AJ(G), start with the identity group and repeatedly add generators from Csym(A) (G) which 
increase the orbit of z, until this orbit becomes U. We need 0-(1) generators, each of which takes O 
(lAl) time to construct.0 Acknowledgements: The authors are grateful to L6sz16 Babai and Eugene Luks 
for introducing the first author to the subject and for fruitful conversations with the second author. 
   Appendix The connection between conjugation and Gc-orbits In this section we sketch proofs of the 
results from [BLS2] which we use in section 8. Let G be a primitive group of the type described in case 
(iv) of Lemma 6.1. Proof of Lemma 8.2 In case (a) we have n = INI : (Nl)nlm, and since m z log n/ loglogn, 
we have [Nl : (Nl)=] e log n. Let s be the minimal number of K conjugates for TV c N1 \ (NI )~. Then 
a ~V with k coordinates not in the appropriate (Ni )= has at least (~) S2k-1 conjugates in GZ, and coset 
representatives in the minimum G= orbit have only one coordinate not in (Ni )=. D Proof of Lemma 8.4 
In this case SOC(G) H T , n = IT] -l, so IT[ < log n. For this argument, it is best to consider the elements 
of Q as equivalence classes of the socle, two elements of the socle being equivalent if their ratio is 
diagonal. y E T1 has ~ IT1 lr < log2 n images under conjugation by G=, so we find the (equivalence class) 
of the involution we are looking for in a G= orbit of size < Iogz n. Also, there are only ON(1) elements 
of SOC(G) whose G= orbit is < log3 n, i.e., only 0-(1) equivalence cla3ses are of size < logz n. D Proof 
of Lemma 8.5 In this case, Q is just SOC(G) E P, I 1 l < logn. y G T1 has ~ lTlr < log2 n images under 
G=, so the minimal Gc orbit is O-(l).O  References [AHU] A.V. Aho, J.E. Hopcroft, J.D. Unman: The Design 
and Analysis of Computer Algorithms, Addison-Wesley, Reading 1974, pp. 189-195. [Atk] M.D. Atkinson: 
An algorithm for finding the blocks of a permutation group, Math. Comp. 29 (1975), pp. 911-913. [Ba] 
L. Babai: Local expansion of vertex-transitive graphs and random generation in finite groups, Proc. 23 
d ACM STOC, 1991, pp. 164-174. [BCFS] L. Babai, G. Cooperman, L. Finkelstein, A. Seress: Nearly linear 
time algorithms for permu­tation groups with a small base, Proc ISSAC 91 (Internat. Symp. on Symbolic 
and Algebraic Com­putation), Bonn 1991, pp. 200-209. [BCFLS] ~. Babai, G. Cooperman, L. Finkelstein, 
E. Luks, A. Seress: Fast Monte Carlo algorithms for permutation groups, Proc. 23 d ACM STOC, 1991, pp. 
90-100. [BLS1] L. Babai, E. Luks, A. Seress: Fast management of permutation groups, Proc. 28th IEEE FOCS 
(1988), pp. 272-282. [BLS2] L. Babai, E. Luks, A. Seress: Fast management of permutation groups II, in 
preparation. [BSZ] L. Babai, E. Szemer6di: On the complexity of matrix group problems I, Proc 2@h IEEE 
FOCS (1984), pp. 229-240. [Be] R. Beals: Structure forest for small base groups in nearly linear time, 
in preparation. [BS] R. Beals, A. Seress: Composition factors for small base groups in nearly linear 
time, in preparation. [Cam] P. J. Cameron: Finite permutation groups and finite simple groups, BuU London 
Math Sot. 13 (1981), pp. 1-22. [CF] G. Cooperman, L. Finkelstein: personal commu­nication. [CFL] G. Cooperman, 
L. Finkelstein, E. Luks: Reduc­tion of Group Constructions to Point Stabilizers, Proc L 5SAC 89 1989. 
[Ho] C. M. Hoffman, Group-theoretic Algorithms and Graph liomorphism, Lecture Notes in Computer Science 
136, Springer-Verlag, Berlin, 1982. [GHLSW] Z. Galil, C. M. Hoffmann, E. M. Luks, C. P. Schnorr, A. 
Weber: An O(n3 log n) determinis­tic and an O(n3) Las Vegas isomorphism test for trivalent graphs, J. 
ACM 34 (1987), 513-531. [Kn] D. E. Knuth: Efficient representation of perm groups, C ombinatorica 11 
(1991), 33-44 (prelim­ inary version circulated since 1981), [Lu] E. M. Luks: Computing the composition 
factors of a permutation group in polynomial time, Com­binatorics 7 (1987), pp. 87-99, [PS] C. E. Praeger, 
J. Saxl: On the orders of primitive permutation groups, Bull. London Math Sot, 12 (1980), pp. 303-307. 
[Se] L. L. Scott: Representations in characteristic p, Proc Santa Cruz Conf. on Finite Groups, AMS (1980), 
pp. 319-322. [Sire] C.C. Sims: Computation with Permutation Groups, in: Proc. Second Symp. on Symbolic 
and Algebraic Manipulation, ACM, New York, 1971, pp. 23 28. [Ta] R. E. Tarjan, Depth first search and 
linear graph algorithms, SIAM J. Comp. 1 (1972), pp. 146 160. [Wi] H. Wielandt: Finite Permutation Groups, 
Acad. Press, New York 1964. 
			
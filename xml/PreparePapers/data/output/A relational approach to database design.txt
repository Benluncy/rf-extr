
 A RELATIONAL APPROACH TO DATABASE DESIGN Philip J. Pratt Department of Computer Science Grand Valley 
State Cotlege AllendaIe, Mich. 49401 This paper presents the design methodology that the author teaches 
in a junior level Database Management course at ~-and Valley State College. The methodology is heavily 
grounded in the relational model. Included in the paper is a discussion of critical relationaI model 
concepts necessary for understanding the methodology. key words: Database Design, Relational Model, Normalization 
INTRODUCT10N The purpose of this paper is to present the database design methodology that I teach at 
Grand Valley State Co]]ege in our first Database course. The course is an introduction to the theory 
and practice of database management. It follows a course in ~hich the students have actually implemented 
a small database themselves maintaining their own pointers. The database course covers all of the basic 
models: hierarchical, network (specifically CODASYL), inverted file and relational. The students are 
required to complete projects which involve a CODASYL database, typically including about 9-10 record 
types and 10--12 set types. The students use IDS-II, a major CODASYL system, with COBOL as a host and 
IDP, a query languages on our Honeywell mainframe. In addition they complete projects invoIving the updating 
of =.and retrieval ~rom a relational database using KnowledgeMan on IBM PC's. This course is followed 
by a database project course in which the students, working in teams of 5--6 students, complete a major 
database-oriented project. This project is completed on the mainfrale using COBOL, IDS--II, IDP and several 
utility tools. This project involves the development of a complete menu--driven, screen-oriented application 
system supporting full shared update, full on-line help, journaling, and other features of a normal production 
environment. Permission to copy without fee all or part of this material is geantod provided that the 
copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the 
title of the publication and its date appear, and notice is given that copying is by permission of the 
Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific 
permission. &#38;#169; 1985 ACM 0-89791-152-0/85/003/0184 $00.75 Database design is a crucial topic in 
the first database course. Though database design is extremely important in its own right, the presence 
of the project course adds even more importance to the topic. I present an introduction to a variety 
of database design methodologies, such as the canonical schema of James Martin [I] and the entity--relationship 
model of Peter Chen [23. Since database design is of very special interest to me, I try to read every 
book and paper published on the topic that I possibly can. I have found that there are a number of interesting 
and valuable methodologies that have been proposed for database design but I have never personalIy been 
quite satisfied by any of them. As a result, I have evolved a methodology that I feel is simpler to understand 
and to apply than the other methodologies. The purpose of this paper is to describe this methodoloqy. 
The methodology makes heavy use o~ the relational model. I give a brief introduction to some relational 
model concepts, but I am assuming that readers already have some familiarity ~ith the topic. The design 
methodology presented here is concerned with design at the INFORMATION level, not the PHYSICAL level. 
It is not concerned with the implementation questions faced during the physical design process, although 
there are several points mentioned that do relate to the ultimate PHYSICAL design. In addition, even 
though the methodology is built upon the concepts of the relational model, I feel it is an appropriate 
methodology to be applied even if the final system might be implemented using a CODASYL or hierarchical 
DBMS. In fact, I have even applied it with great success in a situation where the final system was implemented 
using a colIection of indexed files. The next section gives pertinent background on the relational model. 
THE RELATIONAL MODEL In simplest terms a relation is a table, and a relational database is a collection 
of tables. Figure i shows a sample relational database involving information on sales reps, customers, 
orders, order-lines (line-items), and parts. The columns of the table are called attributes, and the 
rows are called tuples. In other words, the tuples are effectively the records and the attributes are 
the fields. A short-hand way of representing the above relational database is to use the mathematical 
notation for tuples as follows: SLSREP (SLSREP-NUMBER, NAME, ADDRESS, TOTAL-COMMISSION, COMMISSION-RATE) 
CUSTOMER (CUSTOMER-NUMBER, NAME, ADDRESS, BALANCE, CREDIT--LIMIT~ SLSREP-NUMBER) ORDER (ORDER-NUMBER~ 
DATE, CUSTOMER-NUMBER) ORDER-LINE (ORDER-NUMBER, PART-NUMBER, NUMBER-ORDERED, QUOTED--PRICE) PART (PART-NUMBER, 
DESCRIPTION, UNITS-ON--HAND, ITEM-CLASS, WAREHOUSE, PRICE) In this notation we first give the name of 
the relation and then inside parentheses we list all of the attributes, In addition we underline the 
attribute that serves as the key or unique identifier. (The topic of keys will be discussed at some length 
later in the paper.) For a more detailed discussion of the relational model itself, as well as issues 
involved in manipulating a relational database, see [3], [4]~ [5] or [6]. We now consider some relational 
model concepts that are fundamental to this design methodology. FUNCTIONAL OEPENDENCE The critical concept 
is functional dependence. An attribute, B, is functionally dependent on an attribute A (or possibly a 
collection of attributes) if a value for A determines a unique value for B. We can think of this as follows. 
If we have all of the corporate data on a desk in front of us, and we are given a value for A, can we 
find a unique value for B? If so, B is functionally dependent on A. For example~ in the CUSTOMER relation, 
is the NAME functionally dependent on CUSTOMER-NUMBER? The answer is YES. If we are given CUSTOMER-NUMBER 
124, we would find the unique NAME, SALLY ADAMS, associated with this CUSTOMER-NUMBER. In the same CUSTOMER 
relation is ADDRESS functionally dependent on NAME? Here the answer would be NO since given the NAME 
SALLY ADAMS we would not be able to find a unique ADDRESS. However, if the organization had a policy 
that states that we cannot have two or more customers with the same name then the answer would be YES. 
In an EMPLOYEE relations is DEPARTMENT-NUMBER (the number of the department in which an employee works) 
functionally dependent on EMPLOYEE-NUMBER? i.e. Given an EMPLOYEE-NUMBERs say 123, do we know that we 
can find a unique DEPARTMENT-NUMBER? The answer is YES if our organizational policy says that each employee 
must be assigned to a unique department, and NO if the policy allows joint appointments. In the relation 
ORDER-LINE of the above example, is the NUMBER-ORDERED dependent on ORDER-NUMBER? NO. This does not give 
enough information. Is it dependent on PART-NUMBER? NO. Again this does not give enough information. 
In reality it is dependent on the combination~ or concatenations of ORDER-NUMBER and PART-NUMBER. Many 
of the following concepts have "functional dependence" at their core, so it is very important to be comfortable 
with the idea. (At this point in the database course, I would typically give a number of exercises similar 
to the examples above concerning functional dependence.) KEYS The next crucial concept is that of a "PRIMARY 
KEY" (or simply the KEY). An attribute A (or collection of attributes) is the PRIMARY KEY for a relation 
if 1. All attributes in the relation are dependent on A. SLSREP I SLSR # : NAME I ADDRESS I TOT-COMM 
I RATE 1 ; 3 | aONES, MARY | 123 MAIN, GRANT~MI l 2150.00 I 5% : ; &#38; : SMITH, WILLIAM | 102 RAYMOND~ADA~MI 
: 4912.50 7% | l 12 : BROWN, SAM I 419 HARPER, LANSING, MI l 2150.00 I 5% | LUST! CST # l NAME : JADDRESS 
: GAL. : CR-LIM : SL # 124 : ADAMS~ SALLY | 4810AK,LANSING~MI | 418.75 = 500 | 3 | 256 : SAMUELS~ ANN 
| 215 PETE,GRANT,MI I 10.75 I 800 | &#38; ; 1 311 | CHARLES, DON : 48 COLLEGE~IRA,MI 200.10 = 300 | 12 
| 315 I DANIELS~ TOM : 914 CHERRY,KENT~MI ! 320.75 | 300 | 6 405 ; WILLIAMS~ AL { 519 WATSON, GRANT,MI| 
201.75 | 800 1 12 ; 1 412 : ADAMS, SALLY I 16 ELM~LANSING~MI | 908.75 : 1000 : 3 | 522 ; NELSON~ MARY 
~ 108 PINE, ADA, MI 49.50 | 800 1 12 | 567 1 BAKER, aOE : 808 RIDGE~HARPER~MI: 201.20 : 300 I 6 : 587 
| ROBERTS, aUDY| 512 PINE,ADA, MI | 57.75 : 500 I 6 1 : 622 I MARTINi DAN | 419 CHIP~GRANT,MI : 575.50 
: 500 : 3 | ORDER { ORD # | DATE ~ CST # = 1 12489 ! 9/02/84 : 124 12491 ~ 9/02/84 : 311 | 12494 : 9/04/84 
I 315 12495 ~ 9/04/84 ~ 256 12498 I 9/05/64 ~ 522 ; 12500 ! 9/05/84 ! 124 ! 12504 : 9/05/84 = 522 = ORDER-LINE 
~ ORD # : PART # I # ORD = QUOTE-PRICE 12489 : AX12 1 11 : 14.95 1 12491 | BZ&#38;&#38; : 1 = 311.95 
| 12491 : BT04 I 1 | 402.99 12494 I CB03 : 4 I 175.00 12495 ~ CX11 : 2 : 57.95 | 12498 : BA74 : 4 : 
4.95 | 12498 I AZ52 : 2 : 22.95 | 12500 I BT04 | 1 ~ 402.99 | 12504 I CZ81 I 2 1 108.99 PART :PART # 
: DESC ! UOH : ITM-ELS : WREHSE ! PRICE ; AX12 ; IRON ~ 104 ~ HW ~ 3 ; 17.95 AZ52 | SKATES | 20 : $6 
: 2 = 24.95 I BA74 : BASEBALL I 40 : $6 I 1 : 4.95 BH22 | TOASTER I 95 HW | 3 I 34.95 ! | BT04 | STOVE 
! 11 ~ AP : 2 | 402.99 1 | BZ66 | WASHER I 52 ! AP I 3 : 311.95 CA14 I SKILLET | 2 | HW ! 3 : 19.95 
CB03 : BIKE | 44 | SG : 1 : 187.50 I ! CX11 : MIXER | 112 | HW | 3 | 57.95 | CZ81 ~ WEIGHTS : 208 ~ $8 
I 2 : 108.99 Figure 1. 2. No sub-collection of the attributes in A (assuming A is a collection of attributes 
and not just a single attribute) also has property 1. For example, is NAME the key for the CUSTOMER relation? 
NO unless there is some special restriction enforcing uniqueness of names, Is CUSTOMER-NUMBER the key 
for the CUSTOMER relation? YES. Is ORDER-NUMBER the key for the ORDER-LINE relation shown earlier? NO 
since it does not determine NUMBER-ORDERED. Is the combination of the ORDER-NUMBER and the PART-NUMBER 
the key for the ORDER-LINE relation? YES since all attributes can be determined by this combination, 
and nothing less will do. Is the combination of the PART-NUMBER and the DESCRIPTION the key for the part 
relation? NO. It is true that ALL attributes of the PART relation can be determined by this combination 
but something less (namely the PART-NUMBER alone) also has this property. The PRIMARY KEY will furnish 
the crucial mechanism for direct access to a unique row in the relation. (There will typically be an 
index or some other structure used to support this access.) Occasionally (but not often) there might 
be more than one possibility for the primary key. For example, in an EMPLOYEE relation both the EMPLOYEE-NUMBER 
and the SOCIAL-SECURITY-NUMBER could serve as the key. In this case one of these is designated the PRIMARY 
KEY. The other is referred to as a CANDIDATE KEY. A CANDIDATE KEY is a collection of attributes that 
has the same property as described in the definition of the PRIMARY KEY presented earlier but which has 
not been chosen to ÷unction in that way. There are two other types of keys that are of interest. If an 
attribute (or collection of attributes) matches the primary key of another table, this attribute is called 
a FOREIGN KEY. For example, in the CUSTOMER relation the field SLSREP-NUMBER is a foreign key. (It matches 
the key in the SLSREP relation.) This is the mechanism that gives relationships between tables. We will 
later talk about FOREIGN KEY rules that are essential for maintaining integrity in the database. For 
example, we may want to prohibit the entering of a row in the CUSTOMER table that includes a SLSREP-NUMBER 
that does not identity a sales rep in the SLSREP table (i.e. a non-existent sales rep). As another example 
we might want to prohibit the deletion of a sales rep from the SLSREP table who is "related to" some 
customers currently in the CUSTOMER table. The final type of key~ while not at all essential, does prove 
to be valuable when the physical portion o( design begins. If an attribute (or collection of attributes) 
is of interest for retrieval purposes it can be designated as a SECONDARY KEY. These do not have to uniquely 
identify anything (although they may). For example~ even though the CUSTOMER-NUMBERis the primary key 
~or the CUSTOMER relation, we may wish to find a customer based on his/her NAME. If so, we might choose 
to designate NAME as a SECONDARY KEY. During the information level of designs what we are really accomplishing 
by doing this is making a note that retrieving a customer based on NAME is a task that will be important 
to us. When we later tackle the PHYSICAL aspect of design this may very well lead us to decide to build 
an index on name. If we did not record this fact during the information level design, we might have to 
repeat some of the same analysis later on. As an example of the above discussion of the various types 
of keys consider the relation EMPLOYEE (EMPLOYEE-NUMBER, SOC-SEC-NUM, NAME, ADDRESS~ DEPARTMENT-NUM, 
... ) We might very well have EMPLOYEE-NUMBER < .... > Primary Key SOC-SEC-NUM < .... > Candidate Key 
DEPARTMENT-NUM < .... > Foreign Key matching Department number in the DEPARTMENT relation NAME < .... 
> Secondary Key NORMALIZATION We now begin the discussion of a very 187 : ~ !~ ~i -¸ ~ important and 
useful process that will enable us to analyze a relation to see if it is "bad", i.e., its basic structure 
permits problems or "anomalies" to occur in the database. In addition, the process also shows a way of 
correcting these problems. This process is called normalization. It is one of the very important contributions 
of relational database theory to the area of database design. There are various types o( "NORMAL FORMS": 
first normal form (1NF), second normal form (2NF), third normal form (3NF), etc. They form a progression 
where a relation that is in 1NF is better than a relation that is not in 1NF; a relation that is in 2NF 
is better yet; and so on. The goal of this process is to allow us to start with a relation or collection 
of relations and produce a new collection of relations that is equivalent to the original collection 
(i.e. it represents the same information} but is free of these problems. For practical purposes, this 
means the relations in the new collection will be in 3NF. (There are higher normal forms that are of 
interest, in theory; but if a sound methodology is followed in normalizing relations, these higher normal 
forms are not of much concern in practical design problems.) DEF. A relation is in first normal form 
if it does not contain repeating groups. As an example, consider the following ORDER relation in which 
there is a repeating group consisting of PART # and NUM-ORD. As can be seen in the example, there is 
one row per order with PART #, QTY-ORD repeated as many times as is necessary. ORDER(ORDER #, PART #, 
NUM-ORD) ORDERI ORD # ~ PRT #1# ORD! PRT #I# ORDI | 12489 ~ AX12 ; 11 I ; 12491 | BZ6~ | 1 I BT04 I 1 
12494 ; CB03 ~ 4 ~ I 12495 I CX11 I 2 ! ! I 12498 | BA74 ~ 4 ; AZ52 ; 2 I 12500 ~ BT04 I 1 ~ I 12504 
! CZ81 ~ 2 ~ ; To convert this relation to INF, the repeating group is removed giving the following: 
ORDER(ORDER #, PART #, NUM-ORD) ORDER I ORD # ~ PRT #~ # ORD ; | 12489 I AX12 | 11 12491 ~ BZ&#38;6 ~ 
1 12491 ~ BT04 ~ 1 12494 ~ CB03 ~ 4 12495 | CXII I 2 | 12498 ~ BA74 ~ 4 12498 I AZ52 ! 2 ! 12500 | BT04 
~ 1 12504 I CZ81 I 2 | Note that the second row o$ the non-normalized relation indicated that PART # 
BZ&#38;6 and PART # BT04 are both present on ORDER # 12491. In the normalized relation, this information 
is represented by two rows, the second and third. The key to the non-normalized ORDER relation was the 
ORDER # alone. The key to the normalized relation, however, is the combination of ORDER # and PART #. 
This will be true in general. In converting a non-lNF relation to 1NF the key will usually expand. Even 
though the following relation is in iNF we will see that there are problems. ORDER(ORDER #, DATE, PART 
#, DESC, NUMBER-ORDERED) In this relation ORDER # determines DATE, PART # determines DESCRIPTION and 
the concatenation of ORDER # and PART # determines NUMBER-ORDERED. ORDER ORD # I DATE I PRT #~ DESC ~# 
ORD~ ; 12489 I 9/02/84 | AX12 I IRON | 11 : 12491 I 9/02/84 I BZ66 ~ WASHER I 1 | 12491 ~ 9/02/84 ~ BT04 
| STOVE ~ 1 | 12494 ~ 9/04/84 ~ CB03 ~ BIKE ~ 4 12495 ~ 9/04/84 ; CXll ; MIXER I 2 12498 ; 9/05/84 ~ 
BA74 ~ BASEBALL| 4 12498 ~ 9/05/84 ; AZ52 ~ SKATES ; 2 12500 ~ 9/05/84 I BT04 I STOVE ~ 1 I 12504 ~ 9/05/84 
~ CZ81 ; WEIGHTS ~ 2 As you can see in the above example, the DESCRIPTION of a specific part (BT04 for 
examp]e) occurs several times in the table. This redundancy causes several problems. It is certainly 
wasteful of space, but that is not nearly as serious as some of the other problems. The problems fall 
into four categories: 1. UPDATE A change to the description of part BT04 requires not one change to be 
made, but several -we have to change each row in which BT04 appears. This certainly makes the update 
process much more cumbersome. 2. INCONSISTENT DATA There is nothing about the design that would prohibit 
part BT04 from having two different descriptions in the database. In fact if it occurs in 20 rows it 
could conceivably have 20 different descriptions in the database!!! 3. ADDITIONS We have a real problem 
trying to add a new part and its description to the database. Since the key for the table consists of 
both ORDER-NUMBER and PART-NUMBER we need values for both of these in order to add a new row. If we have 
a part to add but there are as yet no orders for it, what do we use for an ORDER-NUMBER? Our only solution 
would be to make up a "phony" order number and then replace it with a real ORDER-NUMBER once an order 
for this part is actually received. Certainly this is not an acceptable solution!  4. DELETIONS  In 
the example above, if we delete order 12489 from the database, we also lose the fact that part AX12 is 
called IRON. The above problems occur because we have an attribute, description, that is dependent on 
only a portion of the key, part number and not the complete key. This leads to the definition of second 
normal form (2NF). DEF: A relation is in second normal form if it is in first normal form and if no nonkey 
attribute is dependent on only a portion of the key. We now can name the problem with the above relation: 
it is not in 2NF. While it may be pleasing to have a name for the problem , what we really need, of course, 
is a method to correct the problem. One method is the following: For each subset of the set of attributes 
that make up the key, begin a relation with this subset as its key. In the example, this would give (ORDER 
#, (PART #, (ORDER #, PART #, Next place each of the other attributes with the appropriate key (the minimal 
collection on which it depends). In the above example this yields (ORDER #, DATE) (PART #, DESC) (ORDER 
#, PART #, NUM-ORD, QUOTED-PRICE) Each of these relations can now be given a name that is descriptive 
of the meaning of the relation, such as ORDER, PART, and ORDER-LINE for example. Thus we have replaced 
ORDER | ORD # : DATE : PRT #1 DESC I# ORD: | 12489 I 9/02/84 | AX12 I IRON | 11 : : 12491 : 9/02/84 | 
BZ&#38;6 : WASHER : 1 : : 12491 : 9/02/84 I BT04 : STOVE I 1 : | 12494 : 9/04/84 : CB03 | BIKE I 4 I 
: 12495 : 9/04/84 ! CXll : MIXER I 2 I I 12498 I 9/05/84 : BA74 : BASEBALLI 4 : I 12498 : 9/05/84 I AZ52 
: SKATES : 2 : I 12500 : 9/05/84 I BT04 I STOVE I 1 I 12504 I 9/05/84 | CZ81 | WEIGHTS | 2 I with ORDER 
: ORD # I DATE : : 12489 I 9/02/84 I I 12491 : 9/02/84 I : 12494 I 9/04/84 I : 12495 ! 9/04/84 I | 12498 
| 9/05/84 I ! 12500 : 9/05/84 | I 12504 I 9/05/84 : PART I PRT #| DESC I | AX12 I IRON I : BZ66 ; WASHER 
I I BT04 | STOVE | : CB03 | BIKE | : CX11 : MIXER : BA74 | BASEBALL | : AZ52 : SKATES | I CZ81 : WEIGHTS 
I ORDER-LINE: ORD # : PRT #| # ORD : I 12489 I AX12 I 11 I I 12491 | BZ66 I 1 | | 12491 : BT04 I 1 | 
: 12494 : CB03 : 4 : : 12495 : CX11 : 2 : : 12498 : BA74 | 4 | : 12498 : AZ52 : 2 : : 12500 | BT04 : 
1 : : 12504 : CZ81 : 2 : Note that the problems mentioned have been solved. A DESCRIPTION appears only 
once so we do not have the redundancy that we did in the earlier design. Changing the DESCRIPTION of 
part BT04 to OVEN is now a simple process involving a single change. Since the DESCRIPTION of a PART 
occurs in one single place, it is not possible to have multiple DESCRIPTION's of a PART in the database 
at the same time. To add a new PART we create a new row in the PART relation and thus there is no need 
to have an order exist for that part. Finally, deleting order 12489 does not cause part AX12 to be deleted 
from the PART relation and thus we still have its DESCRIPTION (IRON) in the database. In addition, we 
have not lost any information in the process. The data in the original design can be reconstructed from 
the data in the new design. There can still be problems with relations that are in 2NF. Consider the 
following customer relation: CUST(CUST #, NAME, SLSREP #, SLSREP-NAME) in which CUSTOMER-NUMBER determines 
all of the other attributes. In addition SLSREP-NUMBER determines SLSREP--NAME. CST ICST #I NAME |SL 
#|SLSREP-NAME I I 124 :ADAMS, SALLY I 3 IJONES, MARY I ! 256 ISAMUELS, ANN ! 6 ISMITH, WILLIAMI I 311 
ICHARLES, DON I 12 IBROWN, SAM | : 315 IDANIELS, TOM I 6 :SMITH, WILLIAMI 405 :WILLIAMS, AL I 12 :BROWN, 
SAM I I 412 :ADAMS, SALLY I 3 :JONES, MARY I I 522 :NELSON, MARY I 12 IBROWN, SAM | ! 567 IBAKER, JOE 
I 6 :SMITH, WILLIAM| I 587 :ROBERTS, JUDYI 6 :SMITH, WILLIAMI I 622 IMARTIN, DAN | 3 |JONES, MARY | 
As the above example demonstrates, this relation possesses problems similar to those encountered earlier 
even though it is in second normal form. (Any 1NF relation whose key consists of a single attribute is 
by default in 2NF. There can be no field dependent only on a portion of the key in this circumstance.) 
In this case it is the NAME of a sales rep that can occur many times in the table (see sales rep 12 for 
example}. This redundancy results in the same exact set of problems that were described in the previous 
example. In addition to the problem of wasted space we also have problems with: 1. UPDATE A change to 
the name of a sales rep requires not one change tQ be made but several. Again the update process becomes 
very cumbersome. 2. INCONSISTENT DATA There is nothing about the design that would prohibit a sales 
rep from having two different names in the database. In fact if the same sales rep represents 20 different 
customers (and thus would be found on 20 different rows) the sales rep could have 20 different names 
in the database!!! 3. ADDITIONS In order to add sales rep 47 whose name is MARY DANIELS to the database, 
we must have at least one customer that she represents. If she has not yet been assigned any customers, 
then we either cannot record the fact that her name is MARY DANIELS or we have to create a "phony" customer 
for her to represent. Again this is not a very desirable solution to the problem. 4. DELETIONS  If 
we delete all of the customers of sales rep 6 from the database, then we also lose the name of sales 
rep 6. (There would be no record containing this information.) This problem is due to the fact that 
SLSREP-NUMBER determines SALESREP--NAME but SLSREP-NUMBER is not the key (and thus the same SLSREP-NUMBER 
can appear on many different rows). Any attribute (or collection of attributes} that determines another 
is called a determinant. Certainly the key in a relation will be a determinant. Also, by de÷inition, 
any candidate key will also be a determinant. (Recall that a candidate key is an attribute that could 
also have functioned as the key.) In this case, however, SLSREP-NUMBER is a determinant but it is certainly 
not a candidate key. DEF: A relation is in third normal form (3NF) if it is in second normal form and 
if the only determinants it contains are candidate keys. Note: This is not the original definition of 
third normal form. This definition is often referred to as BOYCE-CODD NORMAL FORM (BCNF) if it is important 
to make a distinction between this definition and the original. This definition is actually preferable 
to the original and consequently we will take it to be the definition of 3NF. We have now named the problem 
with CUST: it is not in 3NF. Again what is needed is a scheme to correct the deficiency in CUST. A method 
to correct this problem is as follows: For each determinant that is not a candidate keys remove attributes 
that depend on this determinant from the relation in question. Create a new relation, with the determinant 
as the key, which contains all of the attributes from the original relation that depend on this determinant. 
Thus, in the relation CUST, SLSREP-NAME is removed (it depends on the determinant SLSREP-NUMBER which 
is not a candidate key) and a new relation is formed consisting of SLSREP-NUMBER (the key) and SLSREP-NAME. 
That is CUST(CUST #, NAME, ADDRESS~ SLSREP #, SLSREP-NAME) is replaced by CUST(CUST #, NAMEr ADDRESS~ 
SLSREP #) &#38; SLSREP¢SLSREP #~ SLSREP-NAME) In terms of the example~ we replace CST iCST #1 NAME |SL 
#1SLSREP-NAME I I 124 IADAMS, SALLY I 3 I~ONES, MARY I I 25&#38; ISAMUELSs ANN I &#38; |SMITHy WILLIAMI 
I 311 |CHARLES~ DON | 12 IBROWN~ SAM I I 315 IDANIELS~ TOM | &#38; ISMITHs WILLIAM| | 405 |WILLIAMS, 
AL | 12 IB~OWN~ SAM | I 412 IADAMS, SALLY | ~ IJONES~ MARY | I 522 INELSON, MARY I 12 IBROWN~ SAM I I 
567 IBAKER~ JOE I 6 ISMITH~ WILLIAM| I 587 IROBERTS~ JUDYI &#38; |SMITHs WILLIAM| I &#38;22 IMARTIN, 
DAN | 3 IJONESs MARY I with CST ICST #1 NAME ISL #i I 124 IADAMS~ SALLY I 3 I I 256 ISAMUELS~ ANN I 
&#38; ! I 311 |CHARLES~ DON % 12 I I 315 IDANIELSs TOM I &#38; I I 405 IWILLIAMS~ AL I 12 I I 412 IADAMS~ 
SALLY I 3 I I 522 INELSON~ MARY | 12 | I 5~7 IBAKER~ ~OE | &#38; I I 587 |ROBERTS~ ~UDYI &#38; I I 622 
IMARTIN~ DAN I 3 I SLSREPI SL # I SLSREP-NAME | | 3 | JONES~ MARY | I 6 | SMITHs WILLIAM I I 12 I BROWN, 
SAM I The above mentioned problems have indeed been solved. A sales rep's name appears once and only 
once, thus avoiding the redundancy and making the process of changing a sales rep's name a very simple 
one. It is not possible with this design to have the same sales rep have two different names in the database. 
To add a new sales rep to the databases we add a row in the SLSREP relation so that it is not necessary 
to have a customer that the sales rep represents. Finally, deleting all of the customers of a given sales 
rep will not remove the sales rep's record from the SLSREP relation and thus we do retain the sales rep's 
name. In addition, all of the data in the original relation can be reconstructed from the data in the 
new collection of relations. There are higher normal forms which are of theoretical interest. There are 
also practical design methodologies which rely heavily on fourth normal form. By taking suitable care 
at the beginning o$ the normalization process~ we can avoid the necessity of considering ~ourth normal 
form and thus will not consider it here. (As an aside9 I have found a valuable exercise for emphasizing 
the concepts of normalization to be the following: Using the types of entities found in a college environment 
(faculty~ students5 departments~ courses, etc.) create an example of a relation that is in 1NF but not 
in 2NF and an example of a relation that is in 2NF but not 3NF. In each case justify the answers and 
show how to convert to the higher forms. This seems to me to reinforce the concepts of normalization 
better than an exercise involving straight normalization of a sample relation.) A final comment is in 
order before we move along to the topic of database design. There are two descriptions of 3NF that I 
think are instructive: 1. A relation in 3NF deals with a sinqle concept. (See [7].) 2. For a relation 
to be in 3NF every attribute depends on the key, the whole key and nothing but the key. (See the discussion 
of normalization in  [5].) While these are certainly not formal definitions that can be applied during 
the normalization process I think they are valuable as reinforcements of the concept. For a much more 
detailed discussion of the normalization process see [3], [4], [5] and [8]. DATABASE DESIGN METHODOLOGY 
In a fashion similar to many design methodologJes~ this methodology involves representing individual 
"user" views~ refining them to eliminate any problems and then merging them into a cumulative design. 
A "user" could be an actual person or group who will use the systems a report the system must produce 
or a type of transaction that the system must support. (In the last two cases, you might think of the 
"user" as the person who will use the report or enter the transaction.) In the design methodology that 
follows~ it is assumed that the users have been interviewed~ report and transaction requirements have 
been gathered and analyzed~ ambiguities have been resolved, etc. In other words~ we have the information 
needed to begin the design process. It is also assumed that appropriate documentation is being created 
and maintained during the design process. One type of documentation is addressed in the description of 
the methodology~ but it is certainly not to be assumed that this is the only documentation that would 
be created during this phase. We now turn to the methodology itself. For each user view in turn we complete 
the following five steps: 1. REPRESENT EACH USER VIEW AS A COLLECTION OF RELATIONS 2. NORMALIZE THESE 
RELATIONS 3. REPRESENT ALL KEYS 4. DETERMINE ANY OTHER RESTRICTIONS 5. MERGE THE RESULT OF THE PREVIOUS 
STEPS INTO THE DESIGN  We will now examine each of these steps in detail. 1. REPRESENT EACH USER VIEW 
AS A COLLECTION OF RELATIONS Represent the user view as a collection of relations making certain to identify 
the keys. In some situations this may not be much of a problem. A "good" and proper design may occur 
to you very naturally. Suppose, for example, that a given user view involves departments and employees. 
Suppose further that each department can employ many employees but each employee is assigned to exactly 
one department, a typical restriction. The design DEPT(DEPT #, DEPT-NAME) EMP(EMP #, NAME, ADDRESS~ 
WAGE-RATE, DEPT #) which may have naturally occurred to you is probably an appropriate design. The real 
question concerns what procedure should be followed if a correct design is not so obvious. The following 
tips can be applied. TIP 1. CREATE A SEPARATE RELATION FOR EACH TYPE OF ENTITY. If a user view involves 
departments and employees, begin by creating a DEPARTMENT relation and an EMPLOYEE relation. If a user 
view involves customers, salesmen and orders, begin by creating a CUSTOMER relations a SALESMAN relation 
and an ORDER relation. Note that this tip does not address what attributes should be included in the 
relation. TIP 2. DETERMINE THE KEY FOR EACH OF THESE RELATIONS. Even though we have not as yet decided 
attributes, we can often determine a key. For example, the key to a EMPLOYEE relation will probably be 
the EMPLOYEE-NUMBER, the key to a CUSTOMER relation will probably be the CUSTOMER-NUMBER, ETC. TIP 3. 
DETERMINE THE PROPERTIES OF THESE ENTITIES. By looking at the user requirements determine the other properties 
of these entities that are of interest. For example, for employees we may need NAME, ADDRESS~ WAGE-RATE, 
HOURS-WORKED, NUMBER-OF-DEPENDENTS, etc., whereas in a CUSTOMER relation we may need NAME, ADDRESS, CUSTOMER-TYPE, 
BALANCE, CREDIT-LIMIT, etc.. These properties will become the other attributes in the relation (in addition 
to the key identified in TIP 2.) TIP 4. DETERMINE RELATIONSHIPS AMONG THE ENTITIES. The basic relationships 
that we will need to contend with are one-to-one~ one-to-many and many-to-many. We consider each of these 
in turn and discuss a method to handle the situation. A. ONE-TO-ONE Suppose each student has exactly 
one advisor and each advisor has exactly one advisee. In this case we would include the key o~ the STUDENT 
relation as an attribute in the ADVISOR relation and the key of the ADVISOR relation as an attribute 
in the STUDENT relation. STU(STU #, NAME, ..., ADV #) ADV(ADV #, ADV-NAME~ ...~ STU #) B. ONE-TO-MANY 
Suppose each student has exactly one advisor but an advisor can have several advisees. In this case we 
would include the key of the ADVISOR relation in the STUDENT relation (but not the reverse>. STU(STU 
#, NAMEr ..., ADV #) ADV(ADV #, ADV-NAME~ ...} C. MANY-TO-MANY Suppose each student could have several 
advisors and each advisor could have several advisees. In this case we create a new relation ADVISES 
whose key is the combination o~ the STUDENT-NUMBER and the ADVISOR-NUMBER. STU(STU #, NAME, ...) ADV(ADV 
#~ ADV-NAME~ ...} ADVISES{STU #, ADV #~ ...) (The other attributes in the ADVISES relation would be those 
attributes that pertain to BOTH the student and the advisor i~ there were such attributes. One possibility, 
~or example~ would be the date when the advisor began advising the student. This would depend on both 
student and advisor.) 2. NORMALIZE THESE RELATIONS NormaIize these relations. The target is third normal 
form. KActually the target ~ is fourth normal form but a little care in the early phases of the process 
will usually alleviate the need of considering ~ourth normal ~orm.) 3. REPRESENT ALL KEYS Identify all 
keys (primary, candidate, foreign, and secondary). Decide on the rules for each of these keys. PRIMARY: 
This is the key. It has been determined in the earlier steps. It cannot accept null (or missing) values. 
(A null value is a concept that is actually supported on some systems. It really means "unknown". This 
is a value that can be assigned in these systems to a given attribute in a particular row. Thus if the 
value for an. attribute is truly "unknown" this is a vehicle for storing that fact. In a system that 
does not support NULLS we could consider storing some phony value in place of NULL.) Certainly we would 
not want the key or any portion of it to be "unknown". (An example of a potential use of NULLS occurs 
later in the paper.) CANDIDATE: If there were any candidate keys (attributes that could have been the 
key but were not chosen) they should be represented at this point. It is not common to have candidate 
keys but if they do exist they should be so noted. SECONDARY: If there were any secondary keys (attributes 
that are of interest strictly for the purpose of special types of retrieval) they should be represented 
at this point. FOREIGN: This is in many ways THE MOST IMPORTANT category in that it is through foreign 
keys that relationships are established and integrity is enforced in the database. For each foreign key 
there are some decisions to be made at this point. To illustrate the issues involved consider the following 
example: DEPT(DEPT #, DEPT-NAME) EMP(EMP #, EMP-NAME, WAGE-RATE, DEPT #) where, as before, the DEPARTMENT- 
NUMBER in the EMPLOYEE relation indicates the department to which the employee is assigned. (NOTE: We 
say that the DEPARTMENT-NUMBER in the EMPLOYEE relation, written EMP.DEPT #, is a foreign key which identifies 
DEPT.) The issues to address are then I. Are nulls allowed? Can we store an employee without having a 
department number for that employee. (Note that there is a concept termed referential integrity that 
states that if we furnish an actual department number (not NULL) for an employee it must be the number 
of a department that exists in the department relation.) Usually the answer to this question will be 
that nulls are not to be allowed. 2. What are the rules for changing a department's number in the DEPT 
relation? If there are currently no employees assigned to that department there is no problem. If there 
is a row in the EMPLOYEE relation that indicates 3ONES is in department 12 and we decide to change the 
DEPT # of department 12 to 112 in the DEPT relation, what do we do about JONES? Do we even permit the 
operation? The answer, of course, depends on the circumstances. It depends on the policies of the organization 
for which we are designing the database. The possible answers to the question are summarized below: a. 
One possibility would be to forbid this change. In this case we say that UPDATE IS RESTRICTED. b. A 
second possibility is to allow the update, but indicate that the DEPARTMENT-NUMBER for any employee in 
the "old" department is to be changed to the "new" department number. In this case we say that UPDATE 
CASCADES. c. The third possibility is not nearly as common as the other two. The idea here is to allow 
the update but change the department number for those employees that are in the "old" department to null 
(provided, of course, that nulls are even allowed).  In this case we say that UPDATE NULLIFIES. 3. What 
are the rules for deleting a department? Again if there are currently no employees assigned to that department, 
there is no problem. If there is a row in the employee relation that indicates JONES is in department 
12 and we decide to delete department 12, what do we do about JONES? Do we even permit the operation? 
The answer, as in the case o÷ update, depends on the policies o~ the organization for which we are designing 
the database. The possible answers to the question are summarized below: a. One possibility would be 
to forbid the operation. In this case we say that DELETE IS RESTRICTED. b. A second possibility is to 
allow the delete and also to delete any employee who was assigned to this department. In this case we 
say that DELETE CASCADES. c. The third possibility is again not nearly as common as the other two. Here 
the deletion is allowed, but the department number for those employees that are in the "old" department 
are changed to null  (provided, of course, that nulls are even allowed). In this case we say that DELETE 
NULLIFIES. The way that I prefer to represent the results of the above decisions is through a form of 
what might be called Pseudo-SQL. The language SQL or Structured Query Language is a language developed 
by IBM and used by a number of relational model database management systems for Data De÷inition and Data 
Manipulation. The language that is used in this methodology is not exactly SQL, but it does have the 
same flavor to it. It is similar but not identical to that proposed by Date in [5]. (He actually called 
it Pseudo-DDL.) In this notation the employee relation might be represented as follows: TABLE EMP /$A 
TABLE OF EMPLOYEE INFO~/ FIELDS (EMP #, NAME, ADDRESS, SOC-SEC-NUM, DEPT #, ...) PRIMARY KEY (EMP #) 
CANDIDATE KEY (SOC-SEC-NUM) SECONDARY KEY (NAME) FOREIGN KEY (DEPT # IDENTIFIES DEPT NULLS NOT ALLOWED 
DELETE OF DEPT RESTRICTED UPDATE OF DEPT.DEPT # CASCADES) In this example we are saying that there is 
a relation (table) called EMP consisting of ~ields EMPLOYEE-NUMBER, NAME, ADDRESS~ SOCIAL-SECURITY-NUMBER, 
DEPARTMENT-NUMBER, etc. The primary key is EMPLOYEE-NUMBER. In addition there is another possible key, 
SOCIAL-SECURITY-NUMBER. We are very interested in being able to efficiently retrieve information based 
on the employee's name, so we have designated NAME to be a secondary key. The DEPARTMENT-NUMBER is a 
foreign key identifying the department to which the employee is assigned (it identi(ies the appropriate 
department in the DEPARTMENT relation). Each employee must be assigned to an actual department so this 
may not be null. We are not to be able to delete a department that contains any employees so, DELETE 
of DEPT is RESTRICTED. It is legitimate to change the DEPARTMENT-NUMBER in the DEPARTMENT relation provided 
that the DEPARTMENT-NUMBER of those employees that are in that department is also changed, thus UPDATE 
CASCADES. Note that the above is an example where the questions were answered in one particular way. 
If organizational policy were different the example would have been different. It may have said that 
nulls were allowed or that UPDATE is RESTRICTED, for example. 4. DETERMINE ANY OTHER RESTRICTIONS Determine 
and document any special restrictions in addition to the ones already documented involving keys. For 
example, a department number must be less than 50, employees with earnings greater than zero may not 
be deleted, the state must be Ohio, Michigan, or Indiana, etc. As an aside it should be noted that many 
of the restrictions that we will have documented in steps 3 and 4 may not be able to be enforced by the 
DBMS. Instead programs will have to assume the burden for enforcing these constraints. It is still crucial 
and appropriate~ h~wever, to address these problems during this design phase. In addition to producing 
a database d~ign, this process will also then produce a list of restrictions that must be enforced by 
programs that process the data in this database. 5. MERGE THE RESULT OF THE PREVIOUS STEPS INTO THE DESIGN 
As soon as we have completed the process involved in steps 1 to 4 abpve~ we can merge this information 
into the overall design. If it happens to be the first user view, then the cumulative i ~ii/i ~ ~ i i¸ 
 ~ ~ design will be identical to the design for this first user. Otherwise we add all of the relations 
for this user to those that are presently in the cumulative design. We now combine relations that have 
the same key (PRIMARY KEY, that is) to form a new relation with this as its key and containing all of 
the attributes from both relations. If there are any duplicate attributes~ we remove all but one copy 
of the attribute. We then check the new design to ensure that it is still in third normal form. If not, 
we convert it to 3NF before proceeding. In addition we add the list of restrictions that we encountered 
 for this user to the list of restrictions in the cumulative design. The above process is repeated for 
each "user" view until all have been examined. At this point the design is reviewed for any problems 
and also to ensure that the needs of all of the individual users can indeed be met. This completes the 
INFORMATION level design and PHYSICAL design can now begin. In a case where the design is to be implemented 
on a relational system and efficiency is not a major concern, it may very well be possible to implement 
the information level design virtually directly. Even if this is not the case, starting with a clean 
INFORMATION design is crucial to any database project. Many projects have been doomed to failure because 
this step was omitted and the analysts immediately started at the PHYSICAL end of the design. DATABASE 
DESIGN EXAMPLE As an example of the application of the above methodology to an actual design problem, 
consider the following set of requirements which must be met by a database-oriented system at a college. 
UPDATE (TRANSACTION> REQUIREMENTS. 1. Enter/edit dormitory information (number and name). 2. Enter/edit 
faculty information (number, name, office number, phone, department number). 3. Enter/edit course information 
 (course code, description, number of credits). 4. Enter/edit prerequisites for a given course. 5. 
Enter~edit sections of courses  for current offerings (schedule code, course code and section letter, 
and the number of the faculty member who is teaching the course e.g. schedule code 2345 is section A 
of course CS253 and is taught by the faculty member whose number is 3). 6. Enter/edit student information 
(student number, name, permanent address, status, dorm number>. Note that status is a code indicating 
the type of student (full--time, part-time, continuing education, etc.) and the dorm number is the number 
of the dormitory in which the student resides provided the student lives in a dorm. 7. Determine if a 
student has had the prerequisites necessary for a given course. If he/she has these prerequisites, enroll 
the student in the course. REPORT REQUIREMENTS. 8. For each department list the code and name of the 
department as well as the numbers and names of all of the faculty in the department. 9. For each dormitory 
list the number and name as well as the student number and name of all of the students living in the 
derm. 10. For each course list its code (e.g. CS253), description, and the codes and descriptions of 
all of its prerequisites. 11. For each faculty member, list all sections of all courses that they are 
currently teaching. 12. Fort each student, list all courses the student has taken as well as the grades 
received. 13. For each section of each course list the schedule code, section letter, course code and 
description, the number and name of the professor who is teaching the course as well as the number, name 
and status of all  students who are taking the course. 14. Given a student's name list the student's 
number. NOTE: In the above example no information concerning volumes or frequencies was given. This 
information is certainly necessary during the physical portion of the design process, but we are not 
going to deal with that here. Neither is any information given concerning storage details of any of the 
fields (length and type). The latter is omitted for the sake of brevity. The requirements listed above 
are obviously sketchy at best, but let us push ahead to apply the design methodology to this example. 
Each requirement will be considered to be a "user view" in the terminology of the methodology. UV 1 (USER 
VIEW I}. There is no particular problem in deciding that this user view should be DORM (DORMITORY-NUMBER, 
NAME) which is in 3NF. The only key o~ any kind is the primary key of DORMITORY--NUMBER. (Note that 
this user view, like many others, does not state specifically anything about one property uniquely identifying 
any of the others. We will assume in each case that the appropriate users have been contacted and it 
is been determined in each case that the "obvious" property, in this case the DORMITORY--NUMBER, is indeed 
a unique identifier.) At this point the design for user view I would be represented in the pseudo-SQL 
described earIier: TABLE DDRM /$ A TABLE OF DORM INFO $/ FIELDS (DORMITORY-NUMBER, NAME) PRIMARY KEY 
(DORMITORY-NUMBER) UV 2. User view 2 is similar to UV 1 in that there is an obvious relation FAC (FACULTY-NUMBER, 
NAME, OFFICE, PHONE, DEPT-NUMBER) There is a problem, however. It certainly would seem that DEPT-NUMBER 
must be a foreign key identifying a row in some DEPARTMENT relation. So far, we have not encountered 
such a relation. The safest thing to do at this point is to assume that there will be a department relation, 
say DEPT(DEPT-NUMBER,...) with other attributes yet to be determined. If, at the end of the design, no 
other attributes have been filled in we could consider dropping this relation from the collection. We 
would also have to determine from the user the assumptions concerning the relationship between faculty 
and departments so we can make the appropriate decision concerning the ~oreign key rules. Let us assume 
that this has been done and the decisions dictate the following TABLE FACT /$A TABLE OF FACULTY INFOt/ 
FIELDS (FACULTY--NUMBER, NAME, OFFICE, PHONEy DEPT-NUMBER) PRIMARY KEY (FACULTY-NUMBER) FOREIGN KEY (DEPT-NUMBER 
IDENTIFIES DEPT NULLS NOT ALLOWED DELETE OF DEPT RESTRICTED UPDATE OF DEPT.DEPT--NUMBER CASCADES) In 
many of the following user views we will just describe the relation(s) involved and leave it to the reader 
to document these relations in pseudo-SQL. UV 3. This view leads to the single relation COURSE (COBE~ 
BESCRIPTION, NUMBER-OF--CREDITS) UV 4. In this user view there really is a many-to-many relationship 
between courses and courses. A course could have many couraes that are prerequisite to it. A course could 
be prerequisite to many other courses. This is then the many-to- many relationship described earlier 
except that the entities on both sides of the relationship are the same tYoe of entity, namely courses. 
The rules for many-to- many relationships described earlier still apply, however, and this view would 
thus include the two relations COURSE (CODE, DESCRIPTION) PREREO (COURSE-GO BE, PREREQ-COURSE-CODE) 
As an example, if CS253 had prerequisites CS151 and CS153, then the two rows (CS253, CS151) and (CS253, 
CS153) would appear in the PREREQ table. If CS253 is prerequisite to CS350 and CS353, then the two rows 
(CS350, CS253) and (CS353, CS253) would appear in the PREREQ table. Notice that this COURSE relation 
is not a new relation and is in fact contained in a relation already encountered in UV 3. Thus it would 
not be added to the cumulative collection of relations. The relation PREREQ is neN~ however, and it is 
worth examining its representation in pseudo-SQL since this is the first many-to--many relationship we 
have encountered in this design exercise. TABLE PREREQ /$ A TABLE OF PREREQUISITE RELATIONSHIPS $/ FIELDS 
(COURSE-CODE, PREREQ-COURSE-CODE) PRIHARY KEY (COURSE-CODE, PREREQ-COURSE--CODE) FOREIGN KEY (COURSE-CODE 
IDENTIFIES COURSE NULLS NOT ALLOWED DELETE OF COURSE CASCADES UPDATE OF COURSE.CODE CASCADES) FOREISN 
KEY (PREREQ-COURSE-CODE IDENTIFIES COURSE NULLS NOT ALLOWED DELETE OF COURSE CASCADES UPDATE OF COURSE.CODE 
CASCADES) UV 5. The relation necessary for this user view is SECT (SCHEDULE-CODE, COURSE--CODE, SECTION-LETTERs 
FACULTY-NUMBER) where FACULTY-NUMBER is a foreign key identifying FACULTY. UV &#38;. The relation necessary 
for this user view is STUDENT(STUDENT-NUMBER, NAME, PERM-ADDRESS, STATUS, DORMITORY-NUMBER)  where DORMITORY-NUMBER 
is a foreign key identifying DORMITORY but in which we could have NULLS ARE ALLOWED (to allow the possibility 
of students not residing in dorms). We would also indicate at this point that status has to be "F '° 
for fulI--time, "P" for part-time, or "C" for continuing education. UV 7. Based on UV 4 we have the relations 
necessary to determine the prerequisites for a given course. We need to have the ability to determine 
the courses taken by a given student. This is actually included in UV 12 which requires listing, for 
each student, all the course that they have taken as well as the grades received. Thus the combination 
of UV and IJV 12 will allow us to determine whether a student has the required prerequisites or not. 
(.See the treatment of UV 12 for details concerning the relation that must be added to support this view.) 
The only new relation that is needed, therefore, is a relation that will allow us to enroll a student 
in the course. The relation to support this is ENROLL(STUDENT-NUMBER, SCHEDULE-CODE) where SCHEDULE-CODE 
is the code for the particuIar section of the course in which the student is to be enrolled. (Do you 
see why this relation is a better choice than ENROLL(STUDENT-NUHBER, COURSE-CODE , SCHEDULE-CODE) which 
~ould be another possibility? Note that in the this example, we are assuming that a student will enroll 
in at most one section of a given course so that knowing a student number and a course code would also 
give us the schedule code.) UV 8. The initial relation that we might try is DEPT--INFO (DEPARTI~ENT-NUMBER, 
NAME, FAC-NUM, FAC-NAME) where (FAC-NUM, FAC-NAME) is a repeating group. Converting this to 1NF yields 
DEPT-INFO (DEPARTMENT-NUMBER, NAME FAC-NUN, FAC-NAME)  or does it? This is what the process would give 
us. Assumes that we have determined, however, that DEPARTMENT-NUMBER is functionally dependent on FAC-NUM. 
Then the key is net the combination of the DEPARTMENT--NUMBER and FAC--NUM but merely FAC--NUM. The correct 
normalization should have been DEPT-INFO (DEPARTMENT-NUMBER, NAME, FAC-NUM, FAC-NAHE)  i.e. the key 
is only FAC-NUM. This violates not 2NF like we might have guessed but 3NF. (Do you see why?) Converting 
to 3NF gives DEPT (DEPT-NUMBER~ NAME) &#38; the database design process we may spot flaws in the collection 
o~ user FAC (FAC--NUH, FAC--NAME, DEPT-NUMBER) Notice that FAC is really a portion of the faculty relation 
encountered earlier. No new attributes have been added. We have some discrepancies in names that we can 
resolve (FAC--NUM <---> FACULTY--NUM, FAC-NAME <--> NAME). If there were any new attributes (LENGTH-OF-SERVICEr 
for example) s this would have been added to the relation that we already had in place. Notice also that 
we now have the DEPT relation that .as discussed in UV 2. UV 9. UV 10. &#38; UV 11. can all be satisfied 
with relations that are currently in place and will not be discussed here. (Exercise: determine the relations 
necessary ~or each of these, normalize them, and convince yourself that the relations obtained in this 
fashion are included in the set of relations already encountered.) UV 12. This user view requires a many-to-many 
relationship between students and courses that adds the following relation to the collection that is 
already in place GRADE (STUDENT--NUMBER, COURSE-CODE, GRADE) where the description in pseudo-SQL of 
this relation would be similar to the description of PREREQ seen in UV 4. UV 13. This user view can be 
satisfied with relations already in place and will not be discussed further here. (Exercise: Try to write 
the collection of relations necessary to support this user view and verify that it is indeed included 
in the current set of relations.) UV 14. This user view would cause us to add NAME as a secondary key 
in the STUDENT relation of UV ~. (Exercise: Write the complete collection of relations in the final information 
level design in pseudo-SQL.) At this point we would review the coilection of relations thus obtained 
matching it against all of the user requirements to make sure they can all be met and also to ensure 
that the final design is in 3NF. When this is complete, the PHYSICAL design process (which is another 
topic in itself) could begin. One final note before we consider some miscellaneous design tips is that 
during requirements. In the above requirements, for example, there are two relations, DEPT and GRADE, 
~or which update requirements scertainly suspect!!! there pecified. have been This no is MISCELLANEOUS 
TIPS I. Should you include an attribute in a relation that is computable from other attributes? For 
example, in an INVE~4TQR¥ relation that contains attributes UNITS-ON--HAND and COST, should you include 
the attribute ON-HAND--VALUE (UNITS-ON--HAND i COST)? In the design example should you include in the 
STUDENT relation the attribute TOTAL-NUMBER-OF-CREDITS (assuming, of course, that there is a need for 
such an attribute) which can be computed by suamin 9 the NUMBER-OF--CREDITS for each of the courses in 
which the student has a passing grade. In both cases, I would answer YES for the information level design 
but you must be sure you document how the result is to be obtained. In the actual implementation, however, 
there are other considerations. If you store an attribute that is computable from others you are creating 
redundancy, update problems, and the possibility of inconsistency in the database. (I~ UNITS-ON-HAND=IO 
and COST=15.00, but ON-HAND-VALUE=f25.00, the information is inconsistent.) This would certainly argue 
against storing the attribute. In spite of these arguments there are two situations in which we really 
should store the attribute. If the Database Management System we are using supports the notion of VIRTUAL 
attributes (attributes that are not physically stored but rather the formula ~or computing this attribute 
is applied whenever-the attribute is requested), then the problems mentioned above disappear. A second 
situation occurs when the computation is complicated involving processing a number of occurrences in 
the database. In this case we may decide to store the result for efficiency. Suppose that every time 
we needed the TOTAL--NUMBER-OF-CREDITS for a given student we had to sue the NUMBER-OF-CREDITS for all 
of the courses they have successfully completed, hie have introduced a high degree o~ overhead, perhaps 
more than we can endure. As an aside, if we do decide to stere the TOTAL--NUMBER-OF--CREDITS as a part 
of the STUDENT relation we should create a UTILITY program that periodically will verify that these numbers 
are correct, i.e. t4e didn't inadvertently update the TOTAL-NUMBER-OF-CREDITS for a particular student 
in such a way that it no longer matches the figure we obtain by summing the NUMBER--OF--CREDITS from 
the individual courses. 2. It is absolutely critical to resolve any questions concerning possible synonyms 
before beginning the design process. If we did not realize that the property that one user called COURSE-CODE 
was called even realizinq the problem that we have created. The same tip also applies to naming the 
relations during the design process but to a much lesser extent. If we have already constructed a relation 
called DEPT and we create a new one called DEPT-INFO that is essentially the same, this will usually 
not cause a problem. The step during which we add the new user view to the existing collection of relations 
calls for combining relations that have the same key. Since this would be true of DEPT and DEPT-INFO 
(provided we had resolved the problems of synonyms among the attributes), these two would be combined 
into a single relation containing the key as well as all the attributes that are in either relation. 
At this point we would then be back to a single relation and no harm has been done. 3. In the above 
example we encountered a foreign key of DEPT--NONBER before we encountered the need for a DEPARTMENT 
relation. It is in general useful to give some consideration to the total collection of user requirements 
before beginning the process. This gives a more global feeI to the process. It also allows us to determine 
an order in which to consider the user views during the design process.  COURSE-NUMBER by another, we 
would probably end up having these as two separate attributes in the database~ not It may very ~ell 
be that one ordering of views is substantially easier to deal with than another. If we bIindIy begin 
the process without first taking a global view we miss the chance of making things a little easier on 
ourselves. 4. There are potentially serious problems involving the use of "NULLS". fie will not go into 
all of the problems here but instead give a mechanism for avoiding the problem (if that is felt to be 
desirable}. Consider the STUDENT relation from the design problem discussed earlier. One of the attributes 
was the foreign key DORMITORY-NUMBER. It was allowed to be null since not every student resided in a 
dormitory. That meant that for some rows in the STUDENT relation the DORMITORY-NUMBER column was empty. 
To avoid this use of null values we could remove the DORMITORY--NUMBER attribute from the STUDENT relation 
and create a separate relation STU-DORM which contains the two attributes STU-NUMBER (the key) and DORMITORY-NUMBER. 
A student would only have a row in this new table if they were indeed living in a dorm. Students not 
living in a dorm would have their normal row in the STUDENT relation but n_o row in the STU--DORM relation. 
5. Note that in the design process we combined relations wherever possible (except in cases like the 
one described in the previous tip). That is, whenever we encountered to relations with the same key they 
were merged to form a single relation. It certainly may be the case that for a variety of physical reasons 
this is not appropriate. The whole system may perform better if some of these relations are split. It 
is my view, however, that this splitting should take place not during the INFORMATION Ievel of design 
but during the PHYSICAL= If there are any considerations encountered during the INFORMATION level design 
that may bear on the decision (to split or not to split) they should be noted during the INFORMATION 
level design process but the actual decision concerning splitting shouId not take place until later. 
CONCLUSION I have personally found the above database design methodology to be simpler to understand 
and apply than the other methodologies that I have considered. Many things that have to be handled in 
special ways (and with special names} in other methodologies seem to fall out automatically. (A detailed 
discussion of the comparison between this and other methodologies was beyond the scope of this paper.} 
I do not advocate presenting this (or any other) methodology as the only methodology in a database course, 
however. Each methodology has aspects which add to the students" understanding of the crucial concepts. 
On the other hand, presenting too many methodologies tends to overwhelm the students. I have found that 
for me it has worked out well to present two methodologies in a general way first, and then this methodology 
in detail. The presentation of the methodology must be followed by a design exercise giving the students 
the chance to apply the concepts to a real problem. No matter how many examples have been presented, 
there is no substitute for "hands--on" experience in this crucial area. For examples of other database 
design methodologies see [1], [2], [53, [63, [83, [9] and [103. For a discussion of the PHYSICAL level 
o~ design see [11] and [12]. REFERENCES 1] Martin, 3ames. Manaqinq the Database Environment. Prentice--Hall, 
(1983). 2] Chert, Peter. The Entity --Relationship Approach to Loqical Data ~ase Desiqn. QED Monograph 
Series~ (1977). 3] Cardenas, Al~onso F. DataBase Manaqement Systems. Second Edition. Allyn &#38; Bacon, 
(1984). 4] Date, C. J. Introduction to Database Systems. Third edition. Addison--Wesley~ (1983~. 5] Date, 
C. J. A quide to DB2. Addison-Wesley, (19843. &#38;] Date, C. J. Database: A Primer. Addison-Wesley, 
~1983). 7] Chamberlin~ D. D. "Relational Data- Base Management Systems", ACM Computing Surveys, Vol. 
8, Number 1, March 1976. 8] Kroenke, David. Database Processinq. Second Edition. SRA, 1983). 9] Vetter, 
M. and Madison, R. N. Database Desiqn Methodoloqy. Prentice Hall, {1981). 10] Howe, D. R. D#ta Analysis 
for Data Bass Des~qn. Edward Arnold, (1982}. 11] Teorey, Toby J. and Fry, James P. Desiqn of Database 
Structures. Prentice Hall, 41782}. 12] Inmon, William H. Effective Data Base Desiqn. Prentice Hail, (1981). 
			

 INTERCALATION THEOREMS FOR TREE TRANSDUCER LANGUAGES* C. Raymond Perrault Dept. of Computer Science 
University of Toronto Toronto, Ontario Abstract We develop intercalation lemmas for the computations 
of the top-down tree transducers defined by Rounds [15] and Thatcher [17]. These lemmas are used to prove 
necessary conditions for languages all of whose strings are of exponential length to be ~tree transducer 
languages. The language {ww:we{a,b}*, lwI=2n,n~0}, which is generable by the composition of two transducers, 
is shown not to be generable by one. The proof technique applies to bottom-up transducers as well. The 
results are related to some subclasses of Woods' Augmented Transition Networks [18] characterized elsewhere 
in terms of tree transducer languages [14]. 0. Introduction The top-down flnlte-state tree trans- ducer 
(T-FST) was defined by Rounds [15] as a generalization to trees of the gener- alized sequential mapping 
(gsm) for strings (Ginsburg [6]). It is a non-deter- ministic transducer, with finite control, which 
reads its input tree from root to frontier, generating output by relabeling, rearranging, deleting and 
duplicating sub- trees of the input. A set of trees is local if it is the set of derivation trees of 
a context-free grammar. Let D O be the class of local sets of trees, and for each n~O, let D n be the 
 class of tree languages obtained by map- ping D O under the composition of n T-FST's. Clearly Dn~Dn+ 
I for all n~0. That D O is properly contained in D 1 was shown by Thatcher [17] and that D 1 is properly 
con- tained in D 2 was shown by Ogden and Rounds [13]. Let the yield of a tree t be the string formed 
by concatenating the symbols labelling the leaves of t, preserving their left-to-right order. For any 
set of *The research reported here was supported in part by the National Science Foundation under 
grant GS-31309 to The University of Michigan. trees T, yleld(T) is the set of yleld(t), for all t in 
T, and for any set of sets of trees U, yleld(U) is the set of yleld(T) for all T in U. Baker [i] has 
shown that all languages in yield(D n) are context-sensltlve, for all ne0. Rounds [16] has shown that 
S, the set of satisfiable formulas, is in yield(Dl) and that y leld(Dl) is NP-com- plete. Since yleld(D 
0 ) is the set of all con- text-free languages, and {a2n:na0} is in yleld(Dl) , yield(D0) is a proper 
subset of yield(Dl). We show in this paper that the language L0={ww:we{a,b} m, m=2 n, n~0} is in yield(D 
2) but not in yield(Dl). The proof is an application of two in- tercalation lemmas for computations 
of T-FST's, of the flavour of Bar-Hillel's . uvwxy lemma for context-free languages [2], Ogden's lemmas 
for stack automata [12], and Nayashi's for nested stack automata [9]. Woods [18] defined the Augmented 
Tran- sition Network (ATN), a generalization of the Recurslve Transition Network (RTN) studied by Conway 
[4] and Lomet [ii]. The RTN is itself an extension of the Finite State Transition Network but where edges 
of the network may be labelled with state names, thus allowing recursive subroutine- llke calls to the 
network. The RTN is weakly equivalent to the Pushdown Store Automaton. The ATN adds registers to the 
RTN and allows transitions to test and change register values. In its full power the ATN recognizes 
all recursively enumer- able sets. In Perrault [14] we have shown the lan- guages accepted by the Basic 
Augmented Transition Network (BATN), a restricted class of Woods' ATN, are exactly those of yield(Dl). 
We have also defined a larger class, the Forgetting ATN (FATN), which recognizes some languages of yleld(D2). 
In section 7 we define the language L 3 which 126 is FATN-recognizable but not in yield(Dl) , hence 
not BATN-recognizable. Section I contains definitions, section 2 discusses elementary properties of ex- 
ponential languages, section 3 defines in- tercalation, section 4 proves the interca- latlon lemmas, 
sections 5 and 6 discuss the non-branchlng input lemma and the expo- nential growth lemma, and section 
7 pre- sents some further results and conjectures. i. Definitions We will be concerned with sets of 
finite, rooted, trees labelled over a finite alphabet. Following Gorn [7] we define a E-tree as a mapping 
from a tree ~omain to a ranked alphabet Z. Definition i.i A tree domain D is a sub- set of J*, the free 
monoid over the posi- tive integers J, such that i. if peD, pl,P2eJ*, and P=PI'P2 then Pl~D, and 2. 
if p.icD, then p. JcD for all 0<J~i. Definition 1.2 A ranked alphabet is a pair (Z,p) where Z--is a 
set of symbols, and O is a subset of ZxN, where N is the set of non- negative integers. Zi={ccZ: 0(c,i)} 
for ik0. We refer to a ranked alphabet E when p is understood. Z is finite if p is finite. Definition 
1.3 A tree over a ranked alpha- bet Z (or Z-tree) is a pair (t,Dt) where D t is a tree domain and t:D~÷Z 
is a function such that if peD t and ~ {i:p.ieDt}l=n then t(p)eZ n. We refer to a tree t when D t is 
understood. If peD t then t(p) is the label of the node of t whose address is p. Let T Z be the set of 
all trees over Z. We denote by t/~ the subtree of t whose root is at p. If t(p)=c and tl=t/l,...,tn=t/n 
are all the immediate subtrees of t, we write t=c(tl...tn) . If t 1 is a subtree of t, we write tl<t. 
The ~ of t is the number of nodes in the longest path between the root of t and its frontier. For any 
set X, Tz(X ) is the set of all Z-trees t but where elements of X can also label the leaves of t. Definition 
1.4 A top-down finite-state tree transducer (T-FST) M is a quintuple (Z,A,Q,P,q0) where I and A are 
the (finite) Input and output ranked alphabets, Q is a finite set of states, q0eQ is the initial state, 
and P is a set of tree productions. To define P we introduce the sets Xn={Xl,...,x n} of variables, 
for all nz0. A tree-production is of the form (q,c(xl... Xn))÷v where qeQ, teen, Xl,...,xneXn, and VeTA(QXXn). 
For example, (ql, C ) + a Xl/\x2 b / ~b (q2.x/2) %,Xl) is a tree production, where ql,q2eQ, ceZ2, a,beA2, 
beA0, and Xl,X2eX 2. A production is linear if no variable occurs on the right more than once. A production 
is non__.~ erasin~ if every variable occurring on the left also occurs on the right. A T-FST H=(Z,A,Q,P,q 
0) is linear (resp. non- ~ ) if all productions of P are linear (resp. non-eraslng). M is deterministic 
if no two productions have the same left-hand side. To apply M to a Z-tree s, let <q,s> be the tree 
obtained by attaching the state q to the root of s. For trees t and u we write t~u if t has a subtree 
t' whose root is labelled (qpc) and whose immediate sub- trees are tl,...,tn, qeQ, CeZn, and (q, C<Xl...Xn))÷v 
is a production of M, and u i~ obtained from t by replacing t' by u t where u' is the result of substituting 
t i for all occurrences of x i in v, l~i~n. is the reflexive, symmetric, transitive closure of ~. For 
any tree s in T Z, and any qEQ, M(q,s )={tETA: <q,s>~t}, that is the set of all trees derivable from 
s starting in state q and which contain no state symbols. Let M(s)=M(q0,s) , M(q,T)= {M(q,s): seT}, 
T~Tz, and M(T)=s~TM(S ). In general M is a partial function. In the remainder of this paper we will 
write (q,(c)n) for (q,c(xl...Xn)) in the left-hand side of productions, for all n~0. Example i.I Let 
Z0={a,y} , Z2={*}, A0={0,1 , a,y} A2={+,*}, Q={d,i}, and P consists of the (numbered) productions O. 
(d, (*) 2) ÷ +(* ((d,Xl) (i,x2)) *((i,Xl) (d,x2))) 1. (i,(*)2) ÷ *((i,xl)(i,x2)) 2. (d,(y) o) ÷ 1 3. 
(i,(y) o) ÷ y 4. (d, (a) O) -+ 0  5. (l,(a) 0) + a Let H=(Z,A,Q,p,d). M is deterministic, non-linear, 
and non-erasing. The follow -o ing is a derivation of M starting in state d on the tree *(y a) in TZ: 
 (d,*) y a * , (applying production 0) /\ /\ 1 a y 0 (productions 2,5,3,4)  Let tEM(s). To each node 
p in s and state q in Q there corresponds a (posslbly empty) set of subtrees of t which are all elements 
of M(q,s/p), i.e., which are all images of the subtree s/p under state q. is obtained as follows: let 
yleld(v)=z{... ! % i  This relation between input and output sub-Zm, zieA0uQ×Xn, l~i~m. Then u =(kiP)(Zl... 
trees is crucial to our argument, and is Zm) where for all isism, z i = if zie A then captured in the 
notion of computation tree , z[, else if z[=(qi,x~) then (qlit~). As W J  previously used by Ogden 
and Rounds [13] usual ~ is the reflexive, symmetric, fran- c  and Baker [i]. For every computation 
of M sltlve closure of ~. For any tree seTz, from an input tree s to an output tree t we and any qCQi 
M(q,s~={teTo: <q,s> p t} is define a computation tree v, which has the the set of all computation trees 
obtained same yield as t but whose interior is  by applying M to s starting in state q. labelled with 
pairs (k,p) where k is the  Again ~(qiT)=s~T~(qis)i ~(s)=~(q0,s) , and number of a production of P 
and p is the address of a node of s. ~(T) =~(qo,T). Definition 1.5 Let M=(Z;A,Q,P,q0) be a T- There 
also exists a function OUTPUT FST. Let 0 be a ranked alphabet such that from T~ to T A which maps computation 
trees 80=A 0 and for all i>0, @i={(k,p): peJ*, into their corresponding output tree by (q,(C)n)~ Y is 
the kth production of P, and replaclng each label (k,p) by the interior lyield(v)[=i}. I Computation 
trees are ele-of the kth production. If tc~(q,s) then ments of T8. yield(t)=yield(OUTPUT(t)), and OUTPUT(t)~ 
M(q,s) . For trees t and u we write tc=~U if t has a subtree t' whose root is labelled Ex_.x~ple 1.2 
Continuing example i.i, (q,c) and whose immediate subtrees are figure 1 shows tcS(s)i and u=OUT2UT(t). 
tl,...,tn, qEQ, CeZn, and (q,c(xl...Xn))÷v The superscript next to each node is the is the kth production 
of M, and u is the address of that node. result of replacing t' by u' in t where u' Definition 1.6 
Let ts~(s). If t 1 is a iFor every string w, lw[ is the length of  subtree of t such that (k,p) is 
the label w. For every set T, ITI is the cardinality  of the root of tl and if the kth production of 
T. of P is (q,(C)n)÷U for some q,c,n,u, then ,/ \=2 ' L ¢%1) ¢~' 3"1 -~ I ---- / \. /\. / I\ /x /x 
0 x a I Figure 1 t' w x ~,.1~.'1.2 *A~'~ x 2 J. , o . , , Figure 2 128 source(tl)=(q,s/p), and sourcetree(tl) 
= s/p. tl is an image of s/p under state q. Definition 1.7 A subset R of T E is rec~ nizable [3] if 
it is the domain of a T-FST M=(Z,A,Q,P,q0). R is local if it is recog- nizable and M has one state. 
 The trees of a local set are the deriva- tion trees of a phrase-structure grammar which is llke a context-free 
grammar except that no distinction is made between ter- minal and non-terminal symbols. Definition 1.8 
D O is the set of all local sets, and for all n~0, Dn+I={M(T): TeD n, M a T-FST}. Any two subtrees of 
a computation tree t~(s) with the same source can be inter- changed. Lemma l.l [Interchange Principle] 
Let M= ~E,~,Q,P~,q0 ) be a T-FST, saTE, and te~(s), and let tl,t2 be subtrees of t such that source(tl)=source(t2). 
If t' is the com- putation tree obtained by interchanging t 1 and t 2 in t, then t'g~(s). 2. Exponential 
languages We will use our intercalation lemmas to prove properties of exponentla ! lan- guages in yield(Dl). 
 Definition 2.1 L is an exponential lan- if there exists a constant K such that for all xcL there is 
an integer n and Ixl=K n. We restrict ourselves to the case K=2 but the results are general. Definition 
2.2 L0=(am:m=2n,ne0}. L I= ~w:w¢{a,b}*, lwI=2 n, n~0}. L 0 can be generated from the set of all non-branchlng 
trees on the symbol a using the productions P={(q,(a) l)+a((q,x I) (q,xl)) , (q,(a)n)÷a}. Each input 
tree of height n is mapped into a balanced binary tree of height n, and hence of yield length 2 n-l. 
The T-FST is deterministic and non-linear. L 1 can be generated from the same set of input trees by adding 
the production (q,(a) 0)÷b to P, making the T-FST non-determlnlstlc on the leaves of the input tree. 
 We will shQw that every exponential language L in yleld(D I) can be generated by a T-FST M and a local 
set R of non- branching trees (lemma 5.3). Furthermore in the exponential growth lemma (lemma 6.1), we 
show that M and R can be chosen so that every string x in L of length 2 n can be generated from an input 
tree s of height no greater than Kn where K depends only on M. A fundamental property of all expo- nential 
languages in yield(D I) is that in any computation tree, subtrees with the same source have the same 
yield length.  Lemma 2.1 Let L=yleld(M(R)) be an expo- nentlal language, M=(Z,A,Q,P,q0). Let seR, ten(s), 
tl,t2<t such that source(tl) =source(t2). Then lyield(tl)l=lyield(t2)l Proof Let x=yield(t), xl=yield(tl), 
x2= yield(t2). There are yl,Y2,yseA* such that ~ =YlXlY~X2Ys. Let nl= x I , n2=Ix21, ns= m YlY2Y3|, 
and Ixi=2 m, so that nl+n2+n3=2 By the interchange principle ylxlY2XlY3 and Ylx2Y2X2Y3 are in L so there 
are m I and m 2 such that 2nl+n3=2 ml and 2n2+ns=2 m2. Hence nl-n2=2ml-2m=2m-2 m2 so that m=ml=m 2 and 
nl= n 2 . Q.E.D. Definition 2.3 L2={ww:wc(a,b} *, lwl =2n, n~O}. Lemma 2.2 L 2 ¢ yield(D2). Proof 
The first mapping generates the trees for L 1, and the second duplicates the output trees of the first. 
Q.E.D. We will show that L 2 is not in yield(Dl). Assuming the contrary we get the following simple 
extension of lemma 2.1. Lemma 2.3 Let L2=yield(M(R)). If s~R, tc~(s), tl,t2<t such that source (tl)= 
 source(t2) , then yleld(tl)=yleld(t~). By interchanging subtrees, it is there- fore easy to show that 
L 2 could be gener- ated by computation trees such that any two subtrees with the same source are in 
fact equal. Such computati ons we call uniform. Definition 2.4 Let M be a T-FST, R a local set, seR, 
ts~(s), sl<s. t is uni~ form in s] if for all tl,t2<t such that source(tl)=source(t2)=(q,sl) for some 
q~Q, then tl=t 2. t is uniform if t is uniform in s. By moving the choice of productions into the input 
alphabet, one can show: Lemma 2.4 Let L=yleld(M(R)), M=(Z,A,Q, P,q0) , R a local subset of TZ, such 
that every x in L has a uniform computation. There exist an alphabet E', a local sub- set R' of TZ', 
and a deterministic T-FST M'=(E',A,Q,P',q 0) such that L= yield(M'(R')). Therefore,  Theorem 2.5 L2{yleld(Dl). 
 Proof: Suppose L2=yield(M(R)). By lemma 2.4 and the exponential growth lemma (6.1) we can assume R 
is a set of non-branchlng trees, M is deterministic, and every string x in L of length 2 n has a source 
tree of height no great@r than Kn, where K depends on M. If KE=IEI , there are at most KZ Kn+2 deterministic 
computations on input trees no longer than Kn, but 22n-i strings in L 2 of length 2 n | which is a 
 contradiction for sufficiently large n. Q.E.D. Cprollar~ 2.6 yleld(Dl)~yield(D2). 3. Intercalation 
Segments and Baker's Lemma. The proof of the exponential growth lemma is based on two intercalation 
lemmas. Each gives sufficient conditions ensuring the presence of a repeatable segment in a computation 
tree. Definition 3.1 Let M=(E,A,Q,P,q0) be a T-FST, R a local subset of TE, seR , te~(s). For all PeDs, 
qeQ, SC(s,t,p,q), the state-count of sip under q in t is the number of images of s/p under q in t. For 
any nodes Pl and P2 in Ds, where Pl is strictly above P2, (Pl,P2) is an interca- lation segment in s 
with respect tP t if the following are satisfied: (i) Pl and P2 define an intercalation segment in 
s in the Bar-Hillel sense, i.e., s(Pl)=s(p2) , (2) for all qaQ, there are at least as many images of 
s/P2 under q as there are of S/pl under q, i.e., SC(s,t,Pl,q) SC(s,t,P2, q) for all qeQ, and  (3) for 
all qeQ, if SC(s,t,p2,q)>0 then SC(s,t,pl,q)>0.  Since R is local, condition (i) en- sures that the 
tree obtained by replica- ting the segment of s between Pl and P2 is in R. Let s 1 be such a tree. Condition 
 (3) ensures that substituting simultane- ously images of s/pl under q for those of s/P2 under q generates 
computation trees derivable from s I. Condition (2) ensures  that as long as only those images of s/pl 
under q of longest yield are used in the substitution process, the yield of the re- sulting computation 
trees need be no shor- ter than yield(t). As in the Bar-Hillel case, the inter- calation segment can 
also be excised, and the resulting yield need be no longer than yleld(t). Also, intercalation can be 
re- peated arbitrarily often. In order for the resulting trees to be computation trees, the address 
half of their labels must be adjusted in the sub- stitution process. The B and ~ functions will "adjust" 
addresses in the intercala- tion and excision cases, respectively. Definition 3,2 Let ~:TsxJ+~T 8 be 
such that ~(t,p)= if IDtl=l then t else if t = (k,Pl) (tl...tn) then (k,p'p$) (~(tl, p ~(tn,P)). Similarly 
9:To×J ÷T8 such)that'S" 9(t,p) = if IDtl=l then t, else if t=(k, p.pl) (tl,...,tn) then (k,pl)(~(tl,P)... 
 ~(tn,p)) , else undefined. We can now de- fine the result of the intercalation pro- cess. Definition 
3.3 Let (Pl,P2) be an interca- lation segment in s with respect to t, and let pEJ + be such that p2=Pl"p. 
 For all nel, l(s,t,Pl,P2,n) , the n..c fold intercalation set of (pl~p 2) in s with respect to % is 
defined inductively. i.i l(s,t,Pl,P2,1)={(s,t)}. 1.2 l(s,t,pl,P2,2) is the set of all pairs (s',t') 
such that 1.2.1 s' is the result of a context-free intercalation between Pl and P2 in B,  1.2.2 t' 
is a computation tree obtained from t by simultaneously substitu- ting for all REQ, and u<t such that 
source(u)=(q,s/p2) a subtree u' satisfying the following 1.2.2.1 u'=~(v,p), 1.2.2.2 v<t and source(v)=(q,s/pl), 
 1.2.2.3 for all v'<t, if source(v')= (q,s/Pl) then lyield(v')[ [yleld(v) I.  1.3. l(s,t,Pl,P2,n+l)= 
U l(sn,tn,Pl,P2,2) , (Sn,tn) el(s,t,pl,P2,n) for all he2.  2. Similarly, l(s,t,pl,P2,0), the exci- 
sion set of (Pl,P2) in s ~ith respect to t is the set of all~airs (s',t') such that 2.1 s' is the result 
of a context-free excision between Pl and P2 in s, 2.2 t' is a computation tree obtained from t by simultaneously 
substituting for all qeQ and v<t such that source(v)=(q,s/pl) a subtree v' satisfying the following: 
 2.2.1 V'=~(u,p), 2.2.2 u<t and source(u)=(q,s/p2) , 2.2.3 for all u'<t such that source(u')= (q,s/P2) 
then lyield(u')le!yield(u)I . Example 3.1 In figure i, (1,1.2) is an intercalation segment in s with 
respect to t, slnce s(1)= s(l.2)=*. There are 2 images of s/l.2 under i, and one each of S/lo2 under 
O, s/l under i, s/l under 0. (s',t')el(s,t,pl,P2,2) of figure 2 is the result of substituting t/l for 
t/l.4, and t/3 for t/l.2 and t/3.2. Lemma 3.1, which follows from defini- tions 3.1 and 3.3 shows that 
intercala- tion behaves as expected. Lemma 3.1 Let R be a local subset of T~, H=(E,A,Q,P,q0) a T-FST. 
Let seR, te~(s~, and (Pl,P2) an intercalation segment in s with respect to t. i. For all nzO, l(s,t,pl,Pe,n)z~. 
 2. For all (Sn,tn)el(s,t,pl,P2,n) , ne0, then sn~R and tnC~(sn). Also if n=0 then lyield(tn) IsIyield(t)~ 
, and if na2 then [yleld(tn) lelyield(t) I The only interesting intercalation segments are those which 
guarantee a strict increase (decrease) in yield length on intercalation (excision). 130 Definition 3.4 
An intercalation segment (Pl,P2) in s with respect to t is pro- ductive is some image in t of a node 
be- tween Pl and P2, excluding P2, branches. Lemma 3.2 Let R be a local subset of TZ, H=(Z,A,Q,P,q 
0) a T-FST, slcR , tlc~(sl) , and (Pl,P2) a productive intercalation segment in s I with respect to 
t I. Let (s0,t0)~l(Sl,tl,pl,pl,0) and for all n>l, (Sn,tn)cl(Sn_l,tn_l,pl,P2,2). Then lyield(tn)[<[yield(tn+l) 
I for all n~0. Definition 3.5 Two intercalation segments (PlpP2) and (rl,r2) in s with respect to t 
are Independent if Pl and r I are distinct and neither dominates the other. Intercalating at (Pl,P2) 
will not change the images of (rl,r2). Lemma 3.3 Let R be a local subset of T E and M a T-FST. Let 
seR, teM(s), and (Pl,P2), (rl,r 2) be independent interca- lation segments in s with respect to t. 
 Let (Sn,tn)cl(s,t,Pl,P2,n) for some n~0. I. (rl,r2) is an intercalation segment in s n with respect 
to t n.  2. (rl,r2) is productive in s n with re- spect to t n iff it is productive in s with respect 
to t. In the intercalation lemmas we give sufficient conditions for the existence of intercalation segments 
in computation trees. Application of these lemmas re- qulr~ the segments found to be productive. This 
can be guaranteed by considering only computations such that every interior node of the input tree have 
an image in the computation tree which branches. The existence of such a computation for every string 
in the yield language is a trivial consequence of lemma 2.2.10 of Baker [i]. Definition 3.6 Let M be 
a T-FST and R a local set. For all s~R, tEN(s), s and t satisfy Baker's condition if for all peD s such 
that p is not a leaf of s, then there is an image of p in t which bran- ches. Ambiguously, we say that 
M and R satisfy Baker's condition if for all xcyleld(M(R)) there exist sER and tc~(s) satisfying Baker's 
condition. Lemma 3.4 For all Lvyield(Dl) there are a local set R and a T-FST M such that Lffiyield(M(R)) 
~nd M and R satisfy Baker's condition. Proof: From Baker [I] it follows that a T-FST M and a recognizable 
set R exist such that L=yield(M(R)). Rounds [15] shows that R can be taken to be local. Q.E.D. Intercalation 
can always be done so as to preserve Baker's condition and/or uni- formity.  Lemma 3.5 Let R be a local 
set, and M a T-FST. Let sER, tc~(s), yield(t)=x, (Pl, P2) an intercalation segment in s with respect 
to t. i. If s and t satisfy Baker's condition then (Pl,P2) is productive and there exists (s',t')~l(s,t,pl,p2,2) 
such that s' and t' satisfy Baker's condition. 2. If t is uniform in some Sl=S/p and (Pl,P2) is in 
s 1 and (s',t')cl(s,tjpl,p2 , 2) then t' is uniform in s'/p. In general it is not_ true that exci- sion 
can be done so as to preserve Baker's condition. Consider the following M and R which generate LI: Exile 
3.1 Let R=(ba*)*b, and M=(E,A,Q, P,2) where E0f(b} , Zl=(a,b}, Ao={a,b}, AlffiA2ffi{a}, Q={O,I}, and 
P contains the following productions: O. (0,(a) 1) + a((0,xl)) i. (l,(a) l) ÷ a((0,Xl)(0,xl) ) 2. 
(O,(b)l) ÷ a((O,xl)(O,xl)) 3. (l,(a) I) + a((l,xl) ) 4. (O,(b)1) ÷ a((1,x~)) 5. (i, (b)o) + a 6. (O,(b) 
O) -+ a  7. (l,(b)0) + b  8. (O,(b)o) + b M maps all trees with n+l occurrences of b to trees of yield 
length 2 n. Note that all even-numbered productions have state 0 to the left, and all even-numbered pro- 
ductions have state i. Consider the com- putation of figure 3, where the nodes of t show only the production 
number, the address of origin being implicit in the level, s and t satisfy Baker's condition. (Pl,P2) 
is a productive intercalation seg- ment. Excising once yields, among others, the computation of figure 
4, where (rl,r2) is an intercalation segment, but it is not productive. No computation tree obtained 
 by excising (Pl,P2) satisfies Baker's condition. s = b I pl-~b 2 I a 0 0 1 4 .7 p2-+b 2 4 I o/\ I 
I I a 0 1 3 3 I I I /\ I I a 0 0 0 0 1 3 I I I i I /\ I a 0 0 0 0 0 0 1 I I I I I I I /\ b 6 8 8 6 6 
6 8 8 I I I I a b b a a a b b Figure 3. s! = b t' = 2 ri- al 0 / 3t I ! I I a 0 0 3 I I I 1 r 2 ÷ a 
0 0 I t 1 / b 6 8 8 8 I I I l b b b b Figure 4. The following lemma, however, obtains: Lemma 3.6 
Let R be a local set and M a T-FST. Let seR, teM(s) satisfy Baker's condition, and t be uniform. Let 
Sl=S/p, (Pl,P2) an intercalation segment in s 1 with respect to t. Then for all (s',t')e l(s,t,Pl,P2,0), 
s' and t' satisfy Baker's condition and t' is uniform in s'/p. To prove the exponential growth lemma 
we would llke to show that every string x of length 2 n has a computation tree in which at most n productive 
excisions can be performed, each excising at most K nodes from the input tree. If x has a uniform computation, 
this will follow directly from lemma 3.6 and intercalation lemma 4.2. However not all strings do. More 
about this problem in section 6. 4. The Intercalation Lemmas Let R be a local set and M=(E,A,Q,P, 
q0 ) a T-FST. Let seR and teH(s) satisfy Baker's condition. We wish to find suf- ficient conditions 
on s and t such that for some pl,p2aDs, (Pl,P2) is an interca- lation segment. By Baker's condition, 
 any such segment will be productive. We prove the following two intercala- tion lemmas. Lemma 4.1 
Let R be a local subset of TE, and M=(Z~A,Q,p,q0) a T-FST satisfying Baker's condition. There exists 
a con- stant B 0 such that for all seR, tEH(s) also satisfying Baker's condition, any path Pl,..-,p 
in s such that Pl is the  root of s, an~ £aB0, contains a produc- tive intercalatlon segment in s with 
res- pect to t. If we require t to be uniform in some sufficiently large subtree sl of s then we can 
find an intercalation segment in Sl rather than at the top of s. Lemma 4.2 Let R be a local subset 
of TE, and M=(E,A,Q,p,q0) a T-FST, satisfying Baker's condition. There exists a con- stant B such that 
for all scR, teK(s) Sl<S, t uniform in Sl, then any path Pl, ...,p£ in sl, where £ZB, contains a pro- 
 ductive intercalation segment in s with respect to t. The heart of both proofs is the com-  binatorial 
lemma 4.3. Let f(i) be any (total) recursive function, and n>l. A sequence {vl}~ of vectors in N n 
is i=l  f-bounded if the sum of components of v i is bounded by f(1). For any two vectors v i and 
vj, vi<v. if each component of v i is no greater t~an the corresponding component of vj. Lemma 4.3 
Let n>l, and let f(1) be a (total) recursive function. There exists a recurslve function y(k) such 
 that any f-bounded sequence of Y(k) vectors in N n contains a non-decreaslng subsequence of length 
k. Let KQ=IQI, KE=IE], Kp=IPi, and K b the maximum yield length of rlght-hand sides of productions in 
P. To prove !emma 4.1, let seR, and te~  (s) satisfy Baker's condition, and let Pl,-..,P-be a path 
in s, where p] is the root£of s. For each ISiS£, and for each ISj~KQ, let vi,jffiSC(s,t,Pi,qj), the 
number of images of s/Pi under state qj in t. For each I~i~£, let vi=(v ~ ,..., Vi,KQ). Let f(1)=m~, 
f is recu~ve and {vi}~ 1 is f-bounded. Therefore if A~y(k) then I~ a non-de- {vi}~= contains  creasing 
subseque=ce {vlj }k , for any S=l  k~0. This ensures that there are in t at least as many images of 
s/Pim+ 1 under q as there are of s/Pim, for all iSm~k-l, and q~Q. To find an intercalation segment 
we must ensure two further conditions: first that the symbols labelling the nodes of origin are the same, 
andsecond, that every state which occurs at the lower level occurs at the upper. It is sufficient to 
find a sequence of K_+I non-decreasing vectors to deal wit~ the first requirement. Since there are KQ 
com- ponents in the vectors, any sequence of more than KQ+I non-decreaslng vectors con- tains two consecutive 
vectors such that no component is zero in the first and posi- tive in the second. Thus we chose B0= y((KE+I)(KQ+2)). 
This completes the proof of lemma 4.1. The proof of lemma 4.1 fails if we try to find a constant K such 
that an interca- lation segment is guaranteed in any K levels of a computation, because the bounding 
function f is no longer indepen- dent of the location of the K levels being considered. On the other 
hand, if t is uniform in some subtree s 1 of s, then to find an in-tercalation segment in s I with respect 
to t it is sufficient to simultaneously find an intercalation segment in s 1 with res-pect to each subtree 
t i of t wh~.ch is an image of Sl under qi, and there at most KQ different such t i. Therefore let Pl,..-, 
p£ be a path in Sl, and for each ISk~KQ, let t k be a subtree of t such that source(tk)=(qk,Sl). There 
may be several such t k but by the uniformity condition, they are all equal. For some k, o~t~ may not 
exist. Define a sequence {vi}~= of l_ K 2 q  vectors in N such that V~= (r~ 1,r~ o, .... where rk, 
= SC(sl,tk,Pi,qj) , the number of subtrees of t k which are images of s/Pi under q~. If t$ is not defined, 
the correspon d ing- r~ ~ s are zero f(1)=K~-Kn is a recur- si~ bounding function f~r ~he sequence 
 As in the proof of lemma 4.1, take B= y((K~+2)(Kr+l) ). This completes the proof of lemma 472. The 
following proof of lemma 4.3 is due to 0gden and Rounds (personal communl- ~ be an f-bounded  cation) 
Let {vi}i= 1 sequence of vectors in N n. Since every infinite sequence of integers has an in- finite 
non-decreasing subsequence, it can be shown by successive refinement that i= 1 has an infinite non-decreaslng 
 (vi}" subsequence, and hence that for all inte- gers k>0 there exists an integer m k such m  that 
{vi}i= 1 contains anon-decreasing se- quence of length k. Let S be the set of all finite sequen- ces 
of vectors in N n which are bounded by f: if Iv I is the sum of the components of v then S={(v I ..... 
Vm):mal , ]vil~f(i), l~iSm}u{A} where A is the empty vector. Define the partial ordering DOM on S such 
that A DOM (v) for all (v) in S, and (Vl, ...,Vm) DOM (Vl,...,Vm,Vm+l) for all (Vl, ...,Vm) , (Vl,...,Vm,Vm+l) 
in S. DOM in- duces an unordered tree v on S, and both S and DOM are recursive since f is. T is an infinite, 
rooted, bounded width tree on the infinite alphabet S, and DOM is the dominance relation on S. Consider 
the tree rk obtained by pru- ning off all the subtrees of T below the nodes where a non-decreasing subsequence 
of length k is found. Let Sk={Z~S:z con- tains no non-decreaslng subsequence of length k+l}. Let DOM 
k be the DOM rela- tion restricted to S k. Since every path of Tk is finite and since the branching under 
each node of ~k is finite, T k is finite by the Infinity Lemma (Konlg [i0]). Therefore S k and DOM k 
are recursive, so y(k), the maximum path length in T k is recursive, which completes the proof of lemma 
4.3. 5. The Non-Branchin~ Input Lemma We now have the tools to show that ex- ponential languages in 
yield(D I) can be generated from non-branching source trees. The crucial part is the following obser- 
vation. Lemma 5.1 Let L be an exponential lan- guage in yield(Dl). No computation tree for a string 
of L contains independent productive intercalation segments. Proof. If two such segments existed, we 
could intercalate at one, or at the other, or at both, each time getting a strict yield length increase. 
An argument simi- lar to that of lemma 2.1 shows this to be impossible. Q.E.D. Therefore all productive 
intercala-  tion segments in such trees must occur along the same path, which we call the productive 
path. The proof of lemma 5.2 uses the intercalation lemmas to show that a constant K 2 bounds the yield 
length of images of subtrees whose root is off the productive path. Rounds [15] shows that for any finite 
set of strings Y, the set of all trees from which Y can be generated under a state q is recognizable 
and hence has a decidable emptiness problem. Thus there exists a constant K I such tha~ any subtree off 
the productive path can be re- placed by a subtree of height no greater than KI, preserving the output 
yield. Lemma 5.2 Let R be a local set, M a T-FST such that M and R satisfy Baker's condi- tion and L=yield(M(R)) 
is exponential. There exists a constant K1 such that for all s~R, ten(s), Sl=S/p, if p does not lie on 
the productive path of s then there exist s{ and s' such that height (s[)SKl, s' is the result of substituting 
s~ for s I in s, s'eR, and yield(t)eyield(M(s')). We can therefore "absorb".in the pro- ductions the 
output of M on the subtrees off the productive path. The non-branch- ing input lemma now follows: Lemma 
5.3 Let R be a local subset of T Z M=(E,A,Q,P,q0) a T-FST such that L=yieldiM (R)) is exponential. There 
exist an alphabet Z', a local subset R' of TE, , and a T-FST M'=(E',A,Q,P',q 0) satisfying Baker's condition 
such that L=yield(M'(R')) and Z' contains no symbols of rank greater than one. For a detailed construction 
and induc- tive proof see Perrault [14]. 6. The Exponential Growth Lemma We can now show that exponential 
lan- guages have non-branchlng source trees whose height is no more than logarithmic in the length of 
the output strings. Lemma 6.1 Let L=yield(M(R)) be an expo- nential language, R a local set of non- 
 branching trees on an alphabet E, M a T-FST satisfying Baker's condition. There exists a constant K4 
such that for all xcLp Ixi=2 n, there is an sER, xcyleld(M(s)), and height(s)~K4n. If we assume that 
every string in L has a uniform computation, then lemma 6.1 follows immediately from lemma 3.4 and 3.6 
since excision can preserve uniformity and Baker's condition. Thus at most n pro-ductive excisions can 
be made in a compu-tation tree for an x of length 2 n. Clear-ly K 4 can be taken equal to B0, the con-stant 
of the intercalation lemma for uniform computations. This and the infor-matlon-theoretlc argument outlined 
earlier are sufficient to show that L 2 is not In yield(Dl). However not every x in an exponential language 
can be obtained via a uniform computation. For example, given M and R of example 3.1, the only strings 
which have uniform computations are those of n n the form a 2 or b 2 for n~l. Consider tree t of figure 
3. The kth node of s labelled b (starting at the root) has 2k-i images in t and each image of the kth 
b-node contains two images of the (k+l)st. Let SC(s,t,p) be the total number of images of s/p in t. Repeated 
application of lemmas 2.1 and 4.2 shows: Lemma 6.2 Let L=yield(M(R)) be exponen- tial where R is non-branchlng. 
There is a constant K 3 such that if pl,p2eD s are such that 2.SC(s,t,Pl)~SC(s,t,p2)~Kb'SC(s,t,p I) 
then the maximum number of images of s/P2 in any image of s/pl is K 3. Thus the growth in the width 
of t is "evenly distributed" across t. But in figure 3, despite the even ~rowth in the width of t, height(s) 
= yleld(t) l, because the a's in the input can "delay" the branching. Consider the tree of figure 5 
obtain- ed by replacing each production number by the state on its left-hand side. Even- numbered productions 
correspond to state O, odd ones to state i. By the inter- change principle, we can obtaln, by chang- 
ing the interior only, the tree of figure 6. The associated production numbers are in- dicated as exponents. 
A computation tree t is said to be homogeneous if whenever Pl and P2 are nodes of s and t 1 and t 2 are 
images of s/Pl under some q, and the string of states labelling images of a/P2 in t I and t 2 are the 
same, then the interior of t l and t 2 above images of s/p2 are the same. Corresponding to the computation 
of figure 6 (which is homogeneous but does not satisfy Baker's condition) is the computation of figure 
7 which does. The essential result is: Lemma 6.3 Any exponential language L in yield(D I) can be generated 
by a T-FST M and a local set of (non-branching) trees R such that every x in L has a homogene- ous computation 
satisfying Baker's con- dition. Thus if Pl and P2 are as in Lemma 6.2,  there are at most "K3+IKQ different 
"in- teriors" between levels Pl and P2 so by 0 0 oj ~o I I J~ 0 0 0 0 /\ I J I 0 0 1 1 1 I I /\ 
I I 0 0 0 0 I 1 I I ~ I I /\ I 0 0 0 0 0 0 1 I I I I I i /\ 0 0 0 0 0 0 0 0 t I I I I I I I a b b a a 
a b b Figure 5 b I b I oo O ° O oo a I b I o/O',oo{",oO o/O"o o o/O oO a I oIO o,O !o a I o,o Oo, O 
a t b I I t I I I ! I a b b a a a b b Figure 6 b 2 ! b i b 2/\ 6 8 2/\ 8 6 2/\ 6 6 2/\ 8 8 I I t I 
I I i I a b b a a a b b Figure 7. Baker's condition Pl and P2 need be at K3+I most K4=K3K_ nodes apart. 
This con- cludes the qproof of lemma 6.1. 7. Conclusion Lemma 6.1 completes the proof of theorem 2.5. 
 Definition 7.1 Define L6={a,b}, and L' - m+l- ~waw,wbw:weL~}, and Lm+l={Wdw:weL~} for all maO. Let 
L(n,m)={yl...Y2n:YiEeLm, i~I~2 n} for all nal, m~l. Finally L3=n~l L (n,m) . mml Strings in L 3 consist 
of an exponen- tial number of strings of the same expo- nential length. Strings in L m can be generated 
deterministically from non- branching trees of height m. Most strings in L 3 do not have uniform com- 
 putations. Strong use of the proof of lemma 6.1 shows: Theorem 7.1 L3eyield(D2)-yield(D1).  L 3 is 
accepted by a Forgetting ATN but not by a Basic ATN(Perrault [14]). Engelfreit [5] and Baker [i] have 
also discussed bottom-up finite-state tree transducers (B-FST), and Baker has shown that if U n is the 
image of the local sets under the composition of n B-FST's then Un~Dn&#38;Un+ I for all ne0. L 2 is in 
yield(U2) so we have actually shown. Corollary 7.2 yield(Dl)~yield(U2)  Using a proof very slmilar 
to that for L 2 (but much simpler) we can show that: Theorem 7.3 L4={we{a,b}*:lwl=2n n~l}e yield(Dl)-yield(U1) 
 Finally, Thatcher [17] noticed that LOeyleld(Ul)-yield(Do) so that Theorem 7.4 yleld(U0)=yleld(D0)~yleld(Ul) 
 ~yield(Dl)~yleld(U2). We conjecture that the entire hier- archy is proper and propose the following 
examples:n for all n~0, let An=(an,bn} . Let L~={weA~:lwI=2 n, n~O} and for all nal, D let Ln+l={Wl...W2m:m~0, 
wleAn+iL~, and fn(Wi)=fn(W j) for all 1~i, is2 m, where fn  is a string homomorphlsm which is the iden- 
tity on An, and the null string elsewhere}. D Conjecture 7.5 Lneyleld(Dn)-yield(Un), for all nel. 
Corollary 7.6 yield(Un)~yield(Dn) " For let U {ww:wcL~}. all n~l, Ln= U Conjecture 7.7 Lneyield(Un+l)-yield(Dn) 
 Corollary 7.8 yield (Dn)~yield(Un+l). The only property of exponential lan- guages we have used is 
that their strings have length given bM a function f satis- fying the unique decomposition property (UDP) 
: for all 0<n1<n2, 0<ml<m2, if f(nl)+f(n2)=f(ml)+f(m2) then nl=ml, and n2=m 2. It is clear that f(n)=n 
does not satisfy UDP. Hardy and Wright [8] show that neither do n 2, n 3 and n 4, although nothing is 
known about n k for k~5. Lemma 6.1 has the obvious generalization: Lemma 7.9 Let f have the unique decompo- 
sition property, and let Leyield(Dl) be such that for all xeL there exists an n and IxI=f(n). Then L 
can be generated by a T-FST M and a local subset R of non- branching trees on some alphabet Z. Rhere 
exists a constant K such tha~ every x in L of length f(n) has a source tree s and height(s)~Kn. Acknowledgment 
 The author wishes to thank W. Rounds and W. Ogden for many conversations and contributions to this paper. 
 Bibliography [i] Baker, B.S., 1973, Tree Transductlons and Families of Lansuages , Doctoral Dissertation, 
Harvard University. [~] Bar-H~llel, Y., Perles, M., and Shamir, E., 1961, On Formal Properties of Simple 
Phrase Structure Grammars, Z. Phonetic, Spraehwissenschaft ~ommunikationsforsehung 14, 143-172. [3] 
B~ehi, J.R., 1964, Regular Canonical S~stems, Archly fur Mathematische Loglk und Grundlagenforschung 
6, 91- iii. [4] Conway, M.E., 1963, Design of a Sepa- rable Transition Diagram Compiler, CACM 6~ 396-403. 
 [5] Engelfreit, J., 1971, Bottomup and Topdown Treetransformations, a Com- parison, Unpublished Report. 
Tech- nische Hogeschool Twente, Netherlands. [63 Ginsburg, S., 1966, The Mathematical Theory of Context-Free 
Lan~uaKes, McGraw-Hill. [7] Gorn, S., 1965, Explicit Definitions and Lin~ulstic Dominoes, Proceedings 
of Conference on Systems and Computer Science, J.F. Hart and S. Takasu (eds.), University of Toronto 
Press.  155 [8] Hardy, G.H., and Wright, E.M., 1938, An Introduction to the Theory of Numb e rs, 
Oxford.  [9] Hayashi, T., 1973, On Derivation Trees of Indexed Grammars -An Exten- sion of the uvwxy-Theorem, 
Publica- tions of the Research Institute for Mathematical Sciences, Kyoto Univer- sity, 9, 61-93. [i0] 
KDnig, D.G., 1950, Theorie der endlichen und unendlichen Graphen, Chelsea. [ii] Lomet, D.B., 1973, A 
Formalization of Transition Diagram Systems, JACM 20, 235-257. [12] Ogden, W.F., 1969, Intercalation 
Theorems for Stack Languages, Procee- dings of ACM Symposium on Theory of Computing. [13] Ogden, W.F., 
and Rounds, W.C., 1972, Composition of n Tree Trans- ducers, Proceedings of 4th ACM Symposium on Theory 
of Computing. [14] Perrault, C.R., 1975, Augmented Transition Networks and Their Rela- tion to Tree 
Manipulating Systems , Doctorai Dissertation, Dept. of Computer and Communication Sciences,  U. of Michigan. 
  [15] Rounds, W.C., 1970, Mappings and Grammars on Trees, Mathematical Systems Theory 4, 257-287. 
 [16] Rounds, W.C., 1973, Complexity of Recognition iln Intermediate Level Languages, Proceedings of 
14th IEEE symposium on Switching and Automata Theory. [17] Thatcher, J.W., 1970, Generalized 2 Sequential 
#lachine Maps, J. Com- puter and System Sc. 4, 339-367. [18] Woods, W.A., 1970, Transition Net- work 
Grammars for Natural Language Analysis, CACM 13, 591-606. 
			
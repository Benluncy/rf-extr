
 Non-standard Stringology: Algorithms and Complexity* # S. Muthukrishnant K. Palem* Abstract Non-standard 
stringology concerns string matching problems, wherein a position in the text (of size n) matches one 
in the pattern)) (of size m), based on very general relationships between the corresponding symbols . 
For example, string matching with don t cares is a simple non-standard string matching prob. lem, wherein 
text andjor pattern positions might have wildcard symbols rather than those drawn from the base alphabet 
X; these wildcards match ever-y sym­bol from Z. The main results in this paper concern the inherent complexity 
of a variety of non-standard string mat thing problems, characterized in terms of algebraic convolutions. 
Non-standard Basic String Matching: For three problems from this family including string mat thing 
with don t cares and its generaliza­tions we prove a lower bound of f2(~( IX 1)) convo­lutions, where 
the (increasing) function ~ depends on the problem. These results are proved in the boolean convolution 
model that we introduce here. We also match this bound by improving or adapting the best­known algorithms 
to this model.  In the RAM model we show, using reductions, that all of these problems encode a variant 
of truncated boolean convolution with integer parameter n. These reductions allow us to infer that any 
improvement to the best known algorithms for these problems (in the RAM) will yield faster algorithms 
for solving param­etrized truncated convolutions of the input vectors.  *This research was partially 
supported by NSF/DARPA un­der grant number CCR-89-06949 and by NSF under grant num­ber CCR-91-03953. 
t Cowat ~~titute of Mathematical science, 251 Mercer Street, New York, NY 10012, USA; muthu@cs.nyu.edu, 
212­998-3061. *IBM Resew&#38; Division, T. J. Watson Research Center, P. o. Box 704, Yorktown Heights, 
NY 10598, USA; kpalem@watson.ibm.tom, 914-984­9846. palemIIMheory.stanford.edu, 415-723-4405. Permission 
to copy without fee all or part of this material is granted provided that the copies are not made or 
distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and Its date appear, and notice is given that copying is by permission of the Association of Computing 
Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. STOC 94-5194 
Montreal, Quebec, Canada @ 1994 ACM 0-89791 -663-8/84/0005..s.50 As we show here, the fastest algorithms 
for the latter problem derived by extending the scheme from [K089] uses 0(min{7r, JR}) convolutions. 
We also derive analogous results for eight other variants of non-standard string matching problems that 
are drawn from the following two families: non­standard counting string matching (eg., variant of classical 
string mat thing, that involves counting num­ber of mismatches at each text position), and non­standard 
threshold string matching (in which the k­mismatches problem is a basic example). Interestingly, all 
of the above results are derived using the structure of the match graph defined by the mat thing relation 
of the given inst ante of the non­standard string matching problem, and its comple­ment. It turns out 
that our lower bounds and re­ductions depend upon the sizes of the induced cliques in these graphs in 
particular, the dominating cliques in the match graph, and the clique edge cov­ers/partitions in its 
complement. We also provide improved deterministic and ran­domized algorithms, as well ae those with 
better ex­pected running times for some non-standard string matching problems. 1 Introduction The field 
of stringoiogy [Ga85] is very rich in prob­lems with substantial mathematical aa well as al­gorithmic 
structure. Quite often, these problems are also well-motivated from an application stand­point. In standard 
stringology a phrase that we introduce here the problems typically involve finding all occurrences 
of a pattern string of size rn in a larger tezt string of size n. The classi­cal string matching problem[KMP77] 
and its higher dimensional variants[KMR72, AC75,Bi77,Ba78, KR87] are examples of such problems. In all 
of these prob­ lems, a text location matches one in the pattern provided the associated symbols are identical. 
In contrast, a large number of problems that arise naturally in practice depend on more demanding no­tions 
of matching that go well beyond checking if the associated symbols are identical. A simple example from 
this (more general) family of problems we refer to these aa non-standard stringology is the well-known 
problem of string matching with don t cares [F P74]. In this problem, each location from the text and/or 
pattern either has a (basic) symbol from the underlying alphabet Z, or a special wild­card symbol @ that 
can match against ever-y sym­bol from X; the goal is to find all occurrences of the pattern in the text, 
under this more general notion of mat thing. String mat thing with don t cares and other problems from 
non-standard stringology are of fundamental interest in text searching systems for instance, in the Unix 
grep[KP84] and the recently developed agrep facility [WM92]. Historically, Fis­ cher and Paterson[FP74] 
provided a very general al­ gorithmic solution which is applicable for a variety of problems from non-standard 
stringology. (For conve­ nience, we will refer to problems from non-standard stringology as non-standard 
string matching prob­ lems). Since then, there have been several additional advances[AL88,Ab87, Ko89,AF91, 
MR92] detailing so­ phisticated algorithmic solutions for a variety of non­ standard string mat thing 
problems. Despite these important developments, the inher­ent complexity and structure of the non-standard 
string matching problems is not understood very well. We contrast this with the deep understanding of 
the inherent time and space complexities of problems in standard stringology[GS83, CP91] [BG91,CC+93], 
in­cluding bounds on the constants in the running times in some cases [G G91,CH92]. The primary thrust 
of our paper is to fill this gap in understanding, of the inherent complexities of a large family of 
problems arising in non-standard stringology. Additionally, we provide algorithms with improved running 
times in some cases. These algorithms include deterministic as well as randomized approaches, and schemes 
with ex­tremely fast expected running times. Our first group of results summarized in Section 1.1 below 
concern the complexity of twelve different non-standard string mat thing problems. First, we provide 
sharp lower bounds for seven of these problems in particular models of computation we introduce here. 
These models are based on clas­sical algebraic convoiutions[AHU74]. Informally, they are derived by replacing 
comparisons in the widely used comparison model [AHiU,WC76,BG91] with the convolution operation. Convolution 
of two 0/1 vectors a and b (vector b that will correspond to the pattern is shorter than vector a that 
will correspond to the text) involves multiplying them without any carry-overs. Formally, given vectors 
a = aoal . . .a~ l and b = bobl . . .b~-1, n > m, their convolution is vector c where Ci = Ej(ai-j x 
bj), for 0 S i S n -1. Depending on the context, these convolutions are defined either on a field of 
polynomials in which case we refer to the resulting operation as a polynomial convolution), or alternately, 
on GF2 in which case we refer to it as a boolean convolution. The resulting computational models will 
be referred to as the polynomial convo­lution (or P~ model or the boolean convolution (or 11~ model respectively. 
Further justifications of the models and precise definitions can be found in Section 2. We also show 
that the best-known algorithms for each of these problems essentially yield upper bounds in the BC or 
PC models that match our lower bounds; these results are summarized in Section 1.1 as well. From these 
facts, it follows that any improvements to the running times of known algorithms for these prob­lems 
must employ techniques that are strictly more powerful than convolutions. Note that alll known effi­cient, 
that is, o(nm) time algorithms for non-standard string matching problems rely on compu~ting polyno­mial 
or boolean convolutions. Second, we relate the complexities of all of these non-standard string matching 
problems, via interre­ducibilities in the RAM, to varieties of parametrized truncated convolutions. This 
problem, with parame­ter r, is a variation of the convolution defined earlier in which, for each ai, 
some terms ai x bj ame left out of the summation. Exactly what terms are left out de­pends on T and a 
boundary specified as part of the in­put with each ai. (See Appendix). As before, depend­ing upon the 
field of operation, this problem could be a polynomial or boolean truncated convolution. It is easy to 
see that the p aramet erized truncated convo­lution is the standard convolution defined earlier in the 
case when T = 1. Truncated conva,lutions were originally introduced by Kosaraju[Ko89] for a single value 
of the parameter n = m, where an algorithm that takes O(@ standard convolutions is given. Ex­tending 
their work we show that parameterized trun­cated convolution can be computed in O(lmin(r, @)) standard 
convolutions; this is the best known upper bound.1 (For convenience, we will refer to param­etrized truncated 
convolutions simply as truncated convolutions. ) Consequent to the reductions (also summarized in Section 
1.1), we can now conclude that irnprovements to existing algorithms for non-standard string match­ing 
in the RAM will imply improved algorithms for truncated convolutions. In particular when T < @, it would 
follow that parameterized truncated convo­lution can be solved using fewer than T convolutions, if the 
running times of existing algorithms for non­standard string mat thing problemsz can be improved. Therefore, 
we show that truncated convolution em­bodies the computational bottleneck in solving a wide variety of 
non-standard string mat thing problems. Our second group of results includes optimal time­ 10n the BC 
or PC model it can be proven that no faster algorithm exists for parametrized truncated convolution. 
2The parameter T gets mapped into a structural aapect of the non-standard string matching problems, which 
we will de­scribe in the sequel. space tradeoffs and fast expected time algorithmic results for non-standard 
string matching problems (both derived as corollaries of the reductions de­scribed in the first group). 
These results are described in Section 1.2. Our third group of results comprise improved randomized and 
deterministic algorithms which are described in Section 1.3. Given the technical nature and number of 
our results, we first give a detailed and comprehensive overview in Sections 1.1, 1.2, and 1.3. The flavor 
of our results can be understood based on this summary and the accompanying discussion of the model and 
related issues in Section 2. We have highlighted one proof each in Sections 3 and 4 to illustrate two 
main technical ideas. The remaining technical details are not included in this extended abstract. 1.1 
Results Concerning Lower bounds and RAM Complexities In this section, we consider twelve non-standard 
string mat thing problems. For conceptual reasons, we group eleven of our problems into three families; 
we will refer to them as basic, count, and threshold non-standard string mat thing problems; they are 
discussed in Sec­tions 1.1.1, 1.1.2, and 1.1.3 respectively. Tree pattern matching is the twelfth problem, 
and we discuss it in Section 1.1.4. Convention in presenting the results: In this paper, when the complexity 
of a problem is stated in terms of number of convolutions, it is as­sumed that each convolution is that 
of two vectors of length n and m where, in the cent ext of non­standard string matching, n and m are 
the number of positions in the text and pattern respectively; in the context of (truncated) convolutions, 
n and m de­note the length of the longer and shorter vectors re­spective y. For example, the best known 
algorithms for computing the boolean or polynomial convolution of vectors of lengths n and m(< n) take 
O(n log m) time on the RAM. Therefore when we say a problem requires (or takes, respectively) d convolutions 
on the RAM, we mean that it requires (or takes, respectively) O(ndlog m) time on the RAM. Also, at various 
places, we state problem A is at least as hard as problem 1?, or B is reducible to A. By this we mean 
that B can be reduced to A in time less than the time taken by the asymptotically fastest algorithm known 
for B. In most cases, our reduction takes linear or near-linear (i.e., O(npolylogm)) time while best 
known algorithms for 1? take significantly more (say, O(n@polylogm)) time. 1.1.1 Bounds and Complexity 
of Basic Non­standard Stringology A simple and illustrative member of this family is the problem of string 
mat thing with don t cares. Recall that in this problem, each position in the text and pattern either 
haa a symbol from the base alphabet or a special don t care symbol @ that matches all the other symbols. 
As usual, let IX! denote the size of the alphabet. In the BC model, we show that this problem re­quires 
Q(log 1X1) (boolean) convolutions. This bound is matched from above since the classical algorithm of 
Fischer and Paterson[FP74] uses O(log IZI) convolu­ tions.  Our approach to deriving the above result 
yields an improvement over the classical and best known algorithm due to Fischer and Paterson[FP74]. 
Specifically, our algorithm takes exactly log 121 +  0.5 log log Ill I+0(1) boolean convolutions whereaa 
the algorithm from [FP74] takes 2 log IE I boolean convo­lutions. The second problem in this family is 
string match­ing with subsets. In this problem, each position in the input strings is associated with 
a specified non-empty subset of the alphabet X. The third problem of string matchmg with ranges is a 
variant of this problem in which each subset is restricted to be a contiguous segment of the ordered 
set X, specified by its end­points. In both these problems, two positions match provided their corresponding 
subsets (segments) have a non-empty intersection. We will now state the main results for both these problems; 
in the case of string mat thing with subsets, we consider the case where the sum of the sizes of all 
the associated subsets in the given problem instance is 0(n).3 In the BC model, we show that these problems 
require Q( IZ 1) (boolean) convolutions. Once again and in both cases, this bound is matched from above 
by a simple adaptation of the RAM algorithms by Abrahamson[Ab87] and Amir and Farach [AF91].  In the 
RAM and when 1X1 ~ @, we show that the truncated convolution problem can be reduced to these problems 
with parameter m = IX 1.4 There­fore, based on our earlier comment, this problem re­  quires at least 
S2( 1X1) boolean convolutions on the RAM when IX! < @, unless truncated convolu­tions can be solved faster. 
The best known al­ gorithms for these problems take O(min{lXl, ~}) convolutions[Ab87, AF91]. 3Clearly 
this sum can be significantly larger than O(n). As our results demonstrate, this restriction is sufficient 
to caDture the dominating term in the complexity of this problem. 4These reductions are ineffective when 
Z > fi in the fol­ lowing sense: a reduction from problem A to problem B is in­ effective if it takes 
more time than the best known algorithms for Aand B. A particularly interesting aspect of the above bounds 
is that we derive all of them by characteriz­ing a common structure that is universal y inherent. To 
explain this structure better, we define the follow­ing (truly) generai string matching (or gsm for short) 
problem. In addition to a text and a pattern, each in­stance of this problem has an associated match 
graph G. A node ti (pj ) in G is defined for each distinct element i: an element could be an alphabet 
symbol, range, or subset of alphabet symbols5 that is associ­ated with a position in the text (pattern). 
An edge in G is defined between node tiand all those nodes that correspond to elements jl, . . . . j~ 
in the pattern, that text element i matches. Clearly, G is a bipartite graph with the nodes derived from 
the text elements in one partition, and those derived from the pattern in another. It is easy to observe 
that the three variants of non-standard string matching mentioned above, can be expressed as special 
cases of the gsm problem. Surprisingly, we were able to show that at a deeper level, the complexity of 
every instance of gsm is completely determined by the structure of induced cliques in the match graph 
G and its complement, namely, the conflict graph GC. An example problem, its match graph G and its conflict 
graph GC are illus­trated in Figure 3. Specifically, In the BC model, we show that solving an instance 
of gsm takes at least Q(cc(GC)) boolean convolutions, where CC(GC) is the clique cover number of GC.6 
The clique cover number of a graph is the smallest number of bipartite cliques in the graph, the union 
of whose (not necessarily disjoint) edges is an edge cover of the graph. Since this fact is true of each 
and every instance of the gsm problem and based on the previous observa­tion, we infer the above-mentioned 
lower bounds for string matching with don t cares, with subsets, and with ranges, by simply specializing 
this very general result. In order to do this, we need to compute the specific value of CC(GC) in each 
case. In the context of string matching with don t cares, this computation involves an interesting use 
of Sperner s Lemma[An87]. The general result concerning clique cover number and its specialization to 
the case of string matching with don t cares will be the first result that we will describe in detail, 
in Section 3. . In the RAM, we use a different structure in G to de­rive the reductions from truncated 
convolutions. For­mally, a dominating clique A of size k in G (Figure 2) 5 Clearly elements can be thought 
of more generally as con­junction of subsets or ranges and so on. Our results extend to such general 
elements as well, though we omit these details here. 6 We additionally show that given a minimal clique 
cover of Gc, the input instance of gsm can be solved using CC(GC) boolean convolutions, and hence this 
bound is matched from above. is an induced subgraph with the following two prop­erties: 1. each partition 
in A has exactly k nodes and, 2. the nodes in each partition can be labeled dis­tinctly by integers 
from the range {1,2, . . . k} such that, a node with label i from a given parti­tion is connected exactly 
to those nodes from the other partition with labels j > i.  The dominating subgraph of a match graph 
G is the dominating clique of largest size in G. We show that any (boolean) truncated convolu­tion with 
parameter IT can be reduced ito an instance of the gsm problem with a dominating clique of size 7r+ 1, 
for 7r = 0(~. 7, s Therefore, any gsm prob­ lem with an dominating subgraph of size ~ will need Q(r) 
boolean convolutions unless truncated convolu­tions can be solved faster. This characterization im­proves 
on the previously best known characterization in [MR92] where the special case of ir = 1 was consid­ered. 
1.1.2 Bounds and Complexity of Non-Standard Counting String Mat thing We now consider the second family 
of four problems. The illustrative example is a variant of (standard) string mat ching[Ka93] with the 
following exception: for each text position i, rather than determining if the pattern matches there, 
we must output a count of the number of positions that the pattern mismatches; here pl is aligned with 
i, pz with i + 1 and so on. With this notion of counting replacing that of deter­mining whether there 
is a match, we get three more non-standard string matching problems, based on the three problems from 
Section 1.1.1, namely, with don t cares, subsets and ranges. For these four problems, we show that: In 
the PC model, all of these problems re­quire Q( [X I) (polynomial) convolutions for IX I ~ @. The best-known 
algorithms for these prob­lems [GG88,Ab87,AF91] match this bound on the PC model. In the RAM and for 
IX I ~ A, we show that the (polynomial parameterized) truncated convolu­tion can be reduced to each of 
these four problems, with parameter n = lx 1.9 As before, this implies 7 once again for lager T, the 
reduction is i]leffective. 8It is assumed the dominating subgraph is provided with the input. This need 
not be always true and it can be implicitly specified, but very easy to find for problems of int crest 
such as string matching with ranges and subsets, from the alphabet set. In general, we have to account 
for the additional complexity of finding this graph, should it not be specified explicitly. 9 StrictlY 
this i5 tme ~~y with the exception of the co~ting variant of standard string matching and string matching 
with that a RAM algorithm that uses less than IX I polyno­mial convolutions for solving any of these 
problems, will yield one that solves truncated convolution using fewer than n convolutions. As in the 
previous case, we derive the above results by specializing them from the more general structural characterization 
of the complexity of (truly) general string counting (or gsc for short) problem. This prob­lem is the 
natural analog of the gsm problem, from Section 1.1.1, except we output the count of the num­ber of mismatches 
at each position of the text. The match graph G of an instance, its complement GC, and its dominating 
subgraph are defined exactly as before. Once again, we note that the four variants of non-standard string 
mat thing mentioned above, can be expressed as special cases of gsc problems. Addi­tionally we use an 
analog of the clique cover number, namely, the clique partition number of a graph, de­fined to be the 
smallest number of bipartite cliques in the graph, the union of whose necessarily disjoint edges is an 
edge cover of the graph. We show: In the PC model, solving an instance of gsc takes at least Q(cP(GC)) 
polynomial convolutions, where cp(GC) is the clique partition number of GC. The technical development 
of this proof is inter­esting and we sketch its development in Section 4, in some detail. The hard part 
of our lower bound proof is the argument that for any algorithm which correctly solves an instance of 
the gsc problem, a cer­t ain bound modeled via a matrix equation is satis­fied (See Section 4). Recently 
Karloff [Ka93] showed that for the counting variant of standard string match­ing problem (the first problem 
to be sketched in the subsection), any algorithm which follows the clsssi­cal Fischer-Paterson approach 
[FP74] needs at least Q(IX]) polynomial convolutions. This result of course, is a corollary of our general 
lower bound above; it is the simple case that shows that for any algorithm which follows the Fischer-Paterson 
approach, the ma­trix equation mentioned above is trivially true. In the RAM, we show that any (polynomial) 
trun­cated convolution with parameter n can be reduced to an instance of the gsc problem with a dominating 
subgraph of size T + 1, provided T < @; this has the usual implication as in Section 1.1.2. 1.1.3 Complexity 
of Non-standard Threshold String Mat thing We now consider the third family of four problems. These problems 
are respectively variants of the four counting problems in Section 1.1.2. Informally, for don t cares. 
However, for these problems we develop an aker­nat e characterization based on cert tin sparse convolutions 
(rather than pammeterized truncated convolutions). With this new characterization, an implication analogous 
to one stated here follows for these two problerm as well. each text position, we determine whether the 
corre­sponding alignment of the pattern yields no more than k mismatches (given a threshold k); equivalently, 
the output for that text position in the corresponding count variant (as defined in Section 1.1.2) must 
be no more than k. If this condition is true, the output for that text position is 1 and O otherwise. 
For the resulting non-standard threshold matching problems, we show: In the RAM and for IXI ~ @, the 
(parameterized polynomial) truncated convolution can be reduced to each of them, with a parameter value 
In I; 10 this has the usual implication. It is straightforward to derive nontrivial complex­ity bounds 
for these problems, for particular values of k (say, k = O or k = m 1), but our characterization here 
holds for every value of k. This involves a non­trivial technique of relating k to the number of zeros 
in the vector b in the corresponding instance of trun­cated convolution. We defer a complete discussion 
of these results to the final version of this paper. 1.1.4 Complexity of Tree Pattern Mat thing Consider 
the problem of tree pattern matching wherein the text and pattern ordered, labeled and rooted trees[H085 
,K089,DGM90]. We show that this problem is reducible to string matching with subsets thereby implying 
that the current bound on the running time for solving this problem, of O(nfipolylog(rn)) [DGM90], is 
optimal (up to poly­log factors) in the BC model; improving it on the RAM will yield better bounds for 
the truncated con­volution problem.  1.2 Additional Consequences of Our Reductions In this section, 
we will sketch two additional conse­ quences of our reductions discussed in the previous sections. 1.2.1 
Time-Space Tradeoff A match graph is trivial if it is a disjoint union of bi­partite cliques, and is 
nontrivial otherwise. We show that for any algorithm which solves a non-standard (basic, count, or threshold) 
string matching problem with a nontrivial match graph as well as count­ing variant of standard string 
matching[Ka93] and the k-mismatches problemll in time T and space S, TS = Q(nrn). (This bound is optimal). 
This follows 10All coment~ rua&#38; in Section 1.1.2 about complexity of counting variants in the RAM 
are pertinent here as well, and they are omitted. 11Note that the ~t&#38; graph corresponding to the 
co~ting variant standard string mat cling and the k-mismat &#38;es prob­lem is always trivial. from the 
matching TS bound for computing a boolean convolution [Ab86], and the fact that our reductions show that 
boolean convolution [Ab86] is embodied in all of the above problem instances with a non­trivial mat ch 
graph. Previously, a time-space bound of Q(rn2/ log m) was known for the problem of (non­standard) string 
matching with subsets [Ab87] when 1~[ = Q(m). Our bound is an improvement since it holds for any non-standard 
matching problem with a non-trivial mat ch graph, when ID I ~ 3. 1.2.2 Sublinear Expected Time Results 
We have shown that if the input vectors are drawn uniformly and randomly, boolean convolution can be 
performed in sublinear time, i.e., o(~ log m) time on the average. This follows from an identi­cal result 
[CL90 ,C92] for the k-mismatches problem [Ga85] and the nature of our reduction from boolean convolution 
to the latter problem.  1.3 Two Algorithmic Results 1.3.1 Randomized Algorithms We provide fast randomized 
algorithms for non­standard basic string matching problems whenever the degree of the graph is at most 
polylogarith­mic in m.lz Our algorithms take O(npolylog(rn)) time whereas previously best known algorithms 
take O(n@ polylog(m)) time for this case. Our approach involves reducing the problem initially defined 
over a large alphabet set, to instances of the same prob­lem over smaller alphabet via the renaming of 
each symbol modulo appropriately chosen primes. 1.3.2 A String Matching Problem Outside Non-standard 
Stringology We study a generalization of string matching left open in [Ab87] which we call the string 
matching with string subsets. This problem is defined the same way aa string mat thing with subsets, 
however with the following exception: elements are now sets of strings (rather than alphabet symbols) 
of equal length. We provide an algorithm for this problem over a general alphabet set which takes 0(nrn075polylogm) 
time; previously, no algorithm running in o(nrn) time was known. This problem seems to be intrinsically 
harder than non-standard basic string mat thing, and is a step in the direction of understanding the 
complex­ity of regular expression rnatching[AHU74] for which no o nrn) time algorithm is known. 12lt 
~a &#38; shown that there is no 10ss of generality in re­stricting the degrees to m.  2 Models and 
Definitions The RAM is the standard model for sequential computation[AHU74]. Comparison Model. In this 
model, an algorithm that performs string matching is allowed to access the text and the pattern using 
only yes-no type queries of the form does tj mat ch pi? ; the complexity of the algorithm is the number 
of such queries asked to solve the problem. Boolean Convolution (B C) model. Consider an algorithm A 
that solves the basic non-standard string matching problem on text t, pattern p and match graph G in 
this model. The algorithm is not charged for any computation on G, but it is allowed to access the text 
or the pattern only using alignment queries for which it is charged. For each alignment query, A identifies 
two sets of elements, one from the text and the other from the pattern. In response, it is given, for 
each text loc~ tion i, a 1 if p placed on t at i leads to an alignment of a text and pattern location 
which respectively contain elements from the two sets of elements identified by A, and a O otherwise. 
The algorithm determines the output finally for each text location by computing the logical OR of the 
bits from various alignment queries for that location. The complexity of the algorithm is the number 
of alignment queries it uses to solve the given non-standard basic string matching problem. Polynomial 
Convolution (PC) Model. An algo­rithm A that solves a counting string matching prob­lem on the PC model 
works much as in the BC model by identifying two sets of elements, one from t and the other from p. In 
response it gets back, for each text location, the number of text and pattern locations which align with 
each other and which cent ain respec­tively the elements identified by A, when the pattern is placed 
on that text location. The algorithm de­termines the output finally for each text location by computing 
the arithmetic sum of the nulmbers from various alignment queries for that location. As be­fore, the 
complexity of the algorithm is the number of alignment queries it uses to solve the problem. Remark. 
As it turns out, the comparison model which haa been highly successful in studying prob­lems from standard 
stringology is too wea,k to study the complexity of non-standard stringology problems since we show that 
any non-standard string matching problem with non-trivial match graph takes Cl(nm) time in this model. 
We also show that such a prob­lem is at least as hard as a boolean convolution on the RAM. This shows 
that the RAM moclel is a very hard model to study the complexity of ncm-standard stringology problems 
since showing a specific lower bound for boolean convolution has been open for long [W86]. 3 Bounds 
and Complexity of Basic String Matching First we derive a general lower bound on the com­plexity of solving 
a basic string matching problem in the BC model in terms of the number of alignment queries. Since we 
claim that each alignment query in the BC model is exactly as hard as computing the boolean convolution 
of vectors of length n and m, this gives a lower bound in terms of the number of boolean convolutions. 
Recall that a clique cover of a bipartite graph G, is a collection of not necessarily edge-disjoint bipartite 
cliques whose union yields G; the clique cover number, denoted cc(G), is the mini­mum number of cliques 
in any clique cover for G. Theorem 1 Solving a basic non-standard string matching problem with match 
graph G on the BC model takes exactly CC(GC) alignment queries. Corollary 1 String matching with don 
t cares takes ezactiy log IZI+O.5 log log 121+0(1) alignment queries on the BC model. Proof. See Figure 
3. We show that a clique cover of the conflict graph G. for the problem of string match­ing with don 
t cares is equivalent to a Sperner s sys­tem [An87]13. The sperner s system is a collection of sets from 
a universe set such that any two sets are in­comparable, that is, no set in the collection is a subset 
of another. Sperner s lemma provides tight bounds on the maximum size of any such collection for a ground 
set of given size. Given the reduction from a clique cover of G= to a sperner system, our lemma follows 
from the asymptotic of the Sperner s Lemma. (a) First we show that from a sperner system, a clique cover 
for GC is generated. Consider a sperner system S={ Sl,..., SIEI } on the universe set S of ~ elements. 
Assign to each vertex i on the bottom and top, a unique subset from this collection. Consider the collection 
C = {Cl, . . . C .} of cliques defined aa follows. For each ~~ E S, let subgraph C i have all those vertices 
on the top which are assigned sets flj such that Ki E Sj and all those vertices on the bot­tom which 
are assigned sets Sj such that tc~ # Sj. We claim that C is a clique cover for GC. (-) Assume that a 
clique cover C = {Cl,..., C.} of GC is given. We construct a collection S = {s1,..., S2} of Z sets, each 
set S i corresponding to some vertex i on the top and the bottom such that any two sets in S are incomparable. 
The sets are sub­sets of the universe set [1 . . . ~]. Consider each clique Ci G C. TO the set Sj corresponding 
to a top vertex in 13we ~USPeCt th&#38; this connection is we~ hewn ~ong re­searchers in Communication 
Complexity. Ci, make i c Sj. We claim that by this construction, two sets S j and sk, j # k, cannot be 
comparable. That completes our reduction. Consider the minimum value of K, denoted by rc~,n such that 
IX I incomparable sets can be constructed from a universe of size ~~in. It follows from our re­ductions 
that CC(GC) = ~min. Sperner s Lemma states that from a ground set of size n, any collection of in­comparable 
sets has size at most (n~z) and there exists a collection of such a size. It follows that (~&#38;~~2) 
= IxI. Therefore, ~min z log 1X1+ 0.510glog 1X1 + O(l).  4 Bounds for Counting String Matching We derive 
a general lower bound on the complexity of solving a counting string mat thing problem in the PC model 
in terms of the alignment queries. Since we claim that each alignment query in the PC model is exactly 
as hard as computing the polynomial con­volution of vectors of length n and m, this gives a lower bound 
in terms of the number of polynomial convolutions. Recall that a ckque partition of a bipar­tite graph 
G is a collection of edge-disjoint bipartite cliques whose union yields G. The clique partition number, 
denoted cp(G), is the minimum number of bipartite cliques in a clique partition of G. Theorem 2 Solving 
any counting string matching problem with match graph G, on the PC model takes exactly cp(GC) alignment 
queries, provided G has at most @ vertices on each of its two vertex sets. Proofi It is easy to see that 
cp(GC) alignment queries are sufficient. We now argue that at least cp(GC) alignment queries are necessary. 
Let (s:, s;)> (%>$), , (S4, S;) be the sets of vertices identified by any algorithm which solves the 
given counting string matching problem. Let Gi be the sub­ graph of GC induced by vertex set (S:, S;). 
We claim that S, the set of all Gi s, must be a clique partition of GC. Our argument is adversary-based. 
We provide a strategy for an adversary to construct a text tand a pattern p and answer the various alignment 
queries consistent with these strings and the match graph G such that after 1 rounds, the algorithm d 
is correct if and only if our claim holds. The text t and p are assumed to be of the same length, namely, 
m. First, assume that the algorithm is static. That is, it identifies all 1 pairs once and for all without 
looking at the responses to the alignment queries14. There are two cases: either each Gi is a clique 
or some Gi is 14 All ~own ~~o=it~ for count string matching problem when lx I < @i are in fact static. 
 not a clique. The latter case is easy and it is omitted here. In the former case, we argue that S needs 
to be an edge partition of GC. Otherwise there exists an edge e = (r, a), called the weak edge, which 
is one of following three types. (1) e is in some Gi but not in G., (2) eis not in any Gi but it is in 
G., or (3) e is in more than one Gi as well as in G=. In each of these cases, adversary sets t = Tm and 
p = CTm; a simple case analysis completes the argument that the algorithm commits an error on this input. 
It is much harder to argue the claim when the al­ gorithm is dynamic, that is, it decides which vertex 
 sets to pick after scanning the response to the previous alignment queries. Intuitively, the adversary 
commits to a number of alignments between the set of vertices in an alignment query; this can be used 
by the algo­rithm while identifying the pair of sets for the subse­quent alignment queries. Two main 
difficulties in this scenario are as follows. In the static case, the adver­sary knows the weak edge 
before constructing the text or the pattern, so he simply constructs the text and the pattern using this 
weak edge. However, when the algorithm is dynamic, the adversary can only guess about the weak edges 
of type (2) and type (3) above. The second difficulty is that the errors made by the algorithm due to 
the different types of weak edges can cancel. That is, by using a weak edge of type 1 in con­junction 
with that of type 2, the algorithm could get the correct number of mismat ches! We can show a strategy 
for the adversary to an­swer the alignment queries carefully in a manner that a dynamic algorithm is 
forced to ensure the claim stated earlier. We omit the (nontrivial) details oft his strategy and the 
proof of its correctness. In our strat­egy, the pattern constructed by the adversary is of size V2 where 
v is the maximum of the number of vertices in the two vertex sets of Gc. That limits the size of the 
match graph in the Theorem. 0 It is convenient to write down the clique partition condition in Theorem 
2 in a different form. Consider an algorithm which solves a count string matching problem with G and 
let the subsets it identifies in the process be S = {( S/, S~), (S~, S~), . . ..(Sl. S~)}. Let A be the 
adjacency matrix for Ge, and for each i, let lli be of same size as A, but representing the edges between 
(S;, S;) in G.. Then, we claim that each Gi must be a clique and in addition, A = ~t Mi. This is equivalent 
to Theorem 2. From the sub-additivity of the rank function (where the rank is over the reals), rank(A) 
< ~~~~ rank(lkf~ ). Also for each i, rank(ll~ ) is exactly 1. Therefore, 1 ~ rank(A). Corollary 2 Solving 
the counting variant of string matching with don t cares over alphabet set E requires at least IXI alignment 
queries tn the PC model. Proof. Consider the adjacency matrix A of the graph GC in Figure 3. Clearly 
rank(A) = 121, which gives the corollary by the preceding discussion. 5 Remarks We note that unlike 
substantial number clf problems in standard stringology which are alphabet-independent algorithms with 
complexity independent of IZ I are known for these problems in the comparison model [KMP77)ABF92,GP92, 
Br93] non-standard string mat thing problems display a direct dependence on the size of the alphabet 
as shown in our lower bound re­sults. It is also of interest to note the intimate relation­ship bet ween 
our lower bound techniques and tech­niques in Communication Complexity [Lov]. Both the cc and cp functions 
are frequently seen in the upper and lower bounds for the communication complexity of functions; there 
they are referred to as cover and tile numbers respectively. 6 Acknowledgements Sincere thanks to Amihood 
Amir, Ravi Boppana, Martin Farach, Howard Karloff, Bill Chang, and Martin Tompa for valuable discussions. 
Bibliography [Ab86] K. Abrahamson. Time-space tradeoffs for branching programs constructed with those 
for straight line programs. 27th Ann $ymp FOCS, 1986, 402-409. [Ab87] K. Abrahamson. Generalized string 
matching. SIAM J. Comp., 1987, 1039-1051. [An87] I. Anderson. Combinatorics of Finite Sets, Oxford Science 
Publications, 1987. [ABF92] A. Amir, G. Benson and M. Farach. Al­phabet independent two-dimensioned matching. 
Proc 2dth Ann ACM Symp. Theory of Comput., 1992, 58-68. [AC75] A. Aho and M. Corasick. Efficient string 
searching: An aid to bibliographic search. Comm, of the ACM, 18(6), 1975, 333-340. [AF91] A. Amir and 
M. Farach. Efficient 2­dimensional Approximate Matching of Non­rectangular Figures. Proc of 2nd Ann ACM 
Symp on Discrete Algorithms, 1991, 212-222. [AHU74] A. Aho, J. Hop croft, and J. Unman. The design and 
analysis of computer algorithms. Addison-Wesley Publishers, 1974.  [AHiU] A. Aho, D. Hirschberg, and 
J. Unman. Bounds on the complexity of the longest com­mon subsequence problem. J. of A CM, Vol. 23, 1976, 
1-12. [AL88] A. Amir and G. Landau. Fast serial and parallel multidimensional approximate array matching. 
Theoretical Computer Science, 81, 1991, 97-115. [Ba78] T. J. Baker. A technique for extending rapid exact-match 
string matching to arrays of more than one dimension. SIAM J. Comput., Vol. 7, 1978,533-541. [Bi77] R. 
S. Bird. Two dimensional pattern match. ing. Information Processing Letters, Vol. 6, No. 5, 1977, 168-170. 
[Br93] D. Breslauer. Dictionary matching with un­bounded alphabet-the uniform length case. Manuscript, 
1993. [BG91] D. Breslauer and Z. Galil. A lower bound for parallel string matching. Proc l?3rd Ann ACM 
Symp on Theory of Comput., 1991,439-443. [C92] W. Chang. Private Communication. [CC+93] R. Cole, M. Crochemore, 
Z. Galil, L. Gssie­niec, R. Hariharan, S. Muthukrishnan, K. Park, and W. Rytter. Optimally fast parallel 
algo­rithms for preprocessing and pattern matching in one and two dimensions. Proc IEEE Symp. on FOCS, 
1993. [CH92] R. Cole and R. Hariharan. On the exact complexity of string matching. Proc IEEE Ann Symp 
on FOCS, 1992, 600-609. [CL90] W. Chang and E. Lawler. Approximate string matching in sublinear expected 
time. Proc IEEE Ann Symp on FOCS, 1990, 116-124. [CP91] M. Crochemore and D. Perrin. Two-way pat­tern 
matching. Journal of ACM, 38, 1991, 651­ 675. [DGM90] M. Dubiner, Z. Galil, and E. Magen. Faster tree 
pattern mat thing. Proc IEEE Ann Symp FOCS, 1990, 145-150. [FP74] M. Fischer and M. Paterson. String 
Match­ing and other Products. SIAM-AMS Proceed­ings, Vol. 7, 113-125, 1974. [Ga85] Z. Gedil. Open Problems 
in Stringology. Com­binatorial Algorithms on Words, A. Apos­tolic and Z. Galil Eds, Springer-Verlag Lecture 
Notes, 1985.1-8. [GG88] Z. Galil and R. Giancarlo. Data structures and algorithms for approximate string 
match­ing. Journal of Compiezity, 4(1988), 33-72. [GG91] Z. Galil and R. Giancarlo. On exact complex­it 
y of string matching: lower bounds. SIAM J Computing, 1991, 1008-1020. [GG92] Z. Galil and R. Giancarlo. 
On exact complex­ity of string mat thing: upper bounds. SIAM J Computing, 1992,407-437. [GP92] Z. Galil 
and K. Park. Truly alphabet­independent two dimensional matching. Proc. of 33rd Ann. IEEE Symp. FOCS, 
1992, 247-256. [GS83] Z. Galil and J. Seiferas. Time space optimal string matching. Journal Comput. Syst. 
Sci, 26(1983), 280-294. [H085] C. Huffman and M. O Donnell. Pattern Matching in Trees. Journal of ACM, 
1982, 68­ 95. [Ka93] H. Karloff. Fast algorithms for approximately counting mismatches. Manuscript, 1993. 
[K089] S.R. Kosaraju. Efficient tree pattern match­ing. Proc IEEE Ann. Symp. on FOCS, 1989, 178-183. 
[KMP77] D.E. Knuth, J. Morris, V. Pratt. Fast pat­tern matching in strings. SIAM Journal on Computing, 
6(1973), 323-350. [KMR72] R. Karp, R. Miller, and A. Rosenberg. Rapid Identification of Repeated Patterns 
in Strings, Trees and Arrays. Proc dth Ann ACM Symp on Theory of Comput., 1972. [KP84] B. Kernighan and 
R. Pike. The UNIX programming environment. Prentice-Hall, NJ, 1984. [KR87] R. Karp and M.O. Rabin. Efficient 
random­ized pattern matching algorithms. IBM Journal of Research and Development, 31(2), 249-260. [Lov] 
L. Lovasz. Communication complexity -a sur­vey. Paths, Flows and VLSI Layout, Korte, Lo­vasz, Promel, 
Schrijver Eds., Springer-Verlag (1990), 235-266. [MR92] S. Muthukrishnan and H. Ramesh. String matching 
under general match relation. Proc 12th FST @ TCS, India, LNCS, Springer-Verlag, Vol. 652, 1992,356-367. 
[W86] I. Wegener. The Complexity of Boolean Func­tions. Wiley-Teubner Series in Computer Sci­ence, 1986. 
[WC76] C. Wong and A. Chandra. Bounds for the string editing problem. J. of ACM, Vol. 23, 1976, 13-16. 
[WM92] S. Wu and U. Manber. Fast text searching allowing errors. Communications of ACM, 35, 1992, 83-91. 
 7 Complexity of the basic non-standard string match­  ing problem on the RAM We first define parameterized 
truncated convolution. Parameterized Truncated Convolution: Let alaz.. .a~ and blb2 -. .bm, n > m, be 
two 0/1 vec­ tors. In addition, each index~ in the vector a has a function parameter h : {1, . . .,n} 
~ {1, . . . } Let m be divisible by ~. The parameterized t~~n~ cated convolution of a and b with integer 
parameter ~, 1 ~ ~ < m, namely ClC2 . . . cn_~+l, is defined ~ follows: Ct = 61<j<m&#38;h(i+j-1)< (j 
mod T)+l (ai+j-1 @ bj) For convenience, we refer to parameterized trun­cated convolution as simply the 
truncated convolu­tion. When the operators @ and @ are respectively the arithmetic x and +, this operation 
is called the polynomial truncated convolution; when the opera­tors @ and @ are respectively the logical 
A and V, this operation is called the boolean truncated convo­lution. Intuitively, consider dividing 
the pattern into dis­joint windows of length ~ aa in Figure 1. For each text location, the h function 
assigns an index into a window. The paramet erized truncated convolution is defined the same way as the 
standard convolution ex­cept that only those terms are considered in which a text location aligns with 
a pattern location of greater index in each window. It is easy to see that for r = 1, this is the stan­ 
dard convolution [AHU74]. For m = m, this is the truncated convolution introduced by Kosaraju [K089]. 
We derive the following extending Kosaraju s result in [K089]. Lemma 1 The parametrized truncated boolean 
con. volution of vectors a and b of length n and m re. spectively can be computed in the RAM model using 
O(min{r, @}) standard boolean convolutions. We now show the connection between parametri­zed truncated 
convolutions and non-standard string mat thing problems. Theorem 3 Solving a basic non-standard string 
matching problem in the RAM model with text t of length n, pattern p of length m and a match graph G 
which contains a given dominating clique C of size k, k ~ 2, is at least as hard as computing the parame. 
terazed truncated boolean convolution of vectors a of length n, bof length m with T= k 1. h(i) = 1 a 
1 w. W*- Ii I I I b 1 1 1 1 1 Ui aligns with b in shaded region. Figure 1: Alignments involving ai in 
parameterized truncated convolution Pattern Elements VIY2 Y3Y4 Yk d x3 x4 xlX2 xk Text Elements Figure 
2: Dominating Clique of Size k 12344 12344 pattern elements D3 % 1 2 3 4 4 el:::nts 12344 GGc Example: 
Pattern: 12#34@l Text: 1234233g54~ Figure 3: Example, Conflict Graph GC and Match Graph G for String 
Matching with Don t Cares 
			

 A Type System for Higher-Order Modules* Derek Dreyer Karl Crary Robert Harper School of Computer Science 
Carnegie Mellon University Pittsburgh, PA 15213 {dreyer,crary,rwh}@cs.cmu.edu Abstract We present a 
type theory for higher-order modules that accounts for many central issues in module system design, including 
translu­cency, applicativity, generativity, and modules as .rst-class values. Our type system harmonizes 
design elements from previous work, resulting in a simple, economical account of modular programming. 
The main unifying principle is the treatment of abstraction mecha­nisms as computational effects. Our 
language is the .rst to provide a complete and practical formalization of all of these critical issues 
in module system design. Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions 
and The­ory; D.3.3 [Programming Languages]: Language Constructs and Features Abstract data types, Modules; 
F.3.3 [Logics and Mean­ings of Programs]: Studies of Program Constructs Type structure General Terms 
Languages, Theory  Keywords Type theory, modularity, computational effects, abstract data types, functors, 
generativity, singleton types 1 Introduction The design of languages for modular programming is surprisingly 
delicate and complex. There is a fundamental tension between *The ConCert Project is supported by the 
National Science Foundation under grant number 0121633: ITR/SY+SI: Language Technology for Trustless 
Software Dissemination . the desire to separate program components into relatively indepen­dent parts 
and the need to integrate these parts to form a coher­ent whole. To some extent the design of modularity 
mechanisms is independent of the underlying language [17], but to a large ex­tent the two are inseparable. 
For example, languages with poly­morphism, generics, or type abstraction require far more complex module 
mechanisms than those without them. Much work has been devoted to the design of modular program­ming 
languages. Early work on CLU [19] and the Modula family of languages [34, 2] has been particularly in.uential. 
Much effort has gone into the design of modular programming mechanisms for the ML family of languages, 
notably Standard ML [23] and Ob­jective Caml [27]. Numerous extensions and variations of these designs 
have been considered in the literature [21, 18, 28, 31, 5]. Despite (or perhaps because of) these substantial 
efforts, the .eld has remained somewhat fragmented, with no clear unifying theory of modularity having 
yet emerged. Several competing designs have been proposed, often seemingly at odds with one another. 
These decisions are as often motivated by pragmatic considerations, such as engineering a useful implementation, 
as by more fundamental considerations, such as the semantics of type abstraction. The rela­tionship between 
these design decisions is not completely clear, nor is there a clear account of the trade-offs between 
them, or whether they can be coherently combined into a single design. The goal of this paper is to provide 
a simple, uni.ed formalism for modular programming that consolidates and elucidates much of the work 
mentioned above. Building on a substantial and growing body of work on type-theoretic accounts of language 
structure, we propose a type theory for higher-order program modules that har­monizes and enriches these 
designs and that would be suitable as a foundation for the next generation of modular languages. 1.1 
Design Issues Before describing the main technical features of our language, it is useful to review some 
of the central issues in the design of module systems for ML. These issues extend to any language of 
similar expressive power, though some of the trade-offs may be different for different languages. Permission 
to make digital or hard copies of all or part of this work for personal or classroom use is granted without 
fee provided that copies are not made or distributed for pro.t or commercial advantage and that copies 
bear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on 
servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 03, January 
15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00 Controlled 
Abstraction Modularity is achieved by using signa­tures (interfaces) to mediate access between program 
components. The role of a signature is to allow the programmer to hide type information selectively. 
The mechanism for controlling type prop­agation is translucency [11, 14], with transparency and opacity 
as limiting cases. Phase Separation ML-like module systems enjoy a phase sep­aration property [12] stating 
that every module is separable into a static part, consisting of type information, and a dynamic part, 
con­sisting of executable code. To obtain fully expressive higher-order modules and to support abstraction, 
it is essential to build this phase separation principle into the de.nition of type equivalence. Generativity 
MacQueen coined the term generativity for the creation of new types corresponding to run-time instances 
of an abstraction. For example, we may wish to de.ne a functor SymbolTable that, given some parameters, 
creates a new symbol table. It is natural for the symbol table module to export an abstract type of symbols 
that are dynamically created by insertion and used for subsequent retrieval. To preclude using the symbols 
from one symbol table to index another, generativity is essential each in­stance of the hash table must 
yield a new symbol type, distinct from all others, even when applied twice to the same parameters. Separate 
Compilation One goal of module system design is to support separate compilation [14]. This is achieved 
by ensuring that all interactions among modules are mediated by interfaces that capture all of the information 
known to the clients of separately­compiled modules. Principal Signatures The principal, or most expressive, 
signa­ture for a module captures all that is known about that module dur­ing type checking. It may be 
used as a proxy for that module for purposes of separate compilation. Many type checking algorithms, 
including the one given in this paper, compute principal signatures for modules. Modules as First-Class 
Values Modules in ML are second­class in the sense that they cannot be computed as the results of ordinary 
run-time computation. It can be useful to treat a mod­ule as a .rst-class value that can be stored into 
a data structure, or passed as an ordinary function argument or result [11, 24]. Hidden Types Introducing 
a local, or hidden , abstract type within a scope requires that the types of the externally visible com­ponents 
avoid mention of the abstract type. This avoidance problem is often a stumbling block for module system 
design, since in most expressive languages there is no best way to avoid a type vari­able [9, 18]. 1.2 
A Type System for Modules The type system proposed here takes into account all of these design issues. 
It consolidates and harmonizes design elements that were previously seen as disparate into a single framework. 
For example, rather than regard generativity of abstract types as an alternative to non-generative types, 
we make both mechanisms available in the language. We support both generative and applicative functors, 
ad­mit translucent signatures, support separate compilation, and are able to accommodate modules as .rst-class 
values [24, 29]. Generality is achieved not by a simple accumulation of features, but rather by isolating 
a few key mechanisms that, when com­bined, yield a .exible, expressive, and implementable type system 
for modules. Speci.cally, the following mechanisms are crucial. Singletons Propagation of type sharing 
is handled by singleton signatures, a variant of Aspinall s and Stone and Harper s singleton kinds [33, 
32, 1]. Singletons provide a simple, orthogonal treat­ment of sharing that captures the full equational 
theory of types in a higher-order module system with subtyping. No previous module system has provided 
both abstraction and the full equational the­ory supported by singletons,1 and consequently none has 
provided optimal propagation of type information. Static Module Equivalence The semantics of singleton 
signa­tures is dependent on a (compile-time) notion of equivalence of modules. To ensure that the phase 
distinction is respected, we de.ne module equivalence to mean equivalence of static compo­nents, ignoring 
all run-time aspects. Subtyping Signature subtyping is used to model forgetting type sharing, an essential 
part of signature matching. The coercive aspects of signature matching (dropping of .elds and specialization 
of polymorphic values) are omitted here, since the required coer­cions are de.nable in the language. 
Purity and Impurity Our type system classi.es module expres­sions into pure (effect-free) and impure 
(effectful) forms. To ensure proper enforcement of abstraction, impure modules are incompa­rable (may 
not be compared for equality with any other module) and non-projectible (may not have type components 
projected from them). It follows that impure modules are also non-substitutable (may not be substituted 
for a module variable in a signature). Abstraction and Sealing Modules that are sealed with a signa­ture 
to impose type abstraction [11] are regarded as impure. In other words, sealing is regarded as a pro 
forma computational effect. This is consistent with the informal idea that generativity involves the 
generation of new types at run time. Moreover, this ensures that sealed modules are incomparable and 
non-projectible, which is suf­.cient to ensure the proper semantics of type abstraction. Totality and 
Partiality Functors are .-abstractions at the level of modules. A functor whose body is pure is said 
to be total; otherwise it is partial. It follows that the application of a pure, total functor to a pure 
argument is pure, whereas the application of a pure, partial functor to a pure argument is impure. Partial 
functors are naturally generative, meaning that the abstract types in its result are new for each instance; 
total functors are applicative, meaning that equal arguments yield equal types in the result. Generative 
functors are obtained without resort to generative stamps [23, 21]. Weak and Strong Sealing Since sealing 
induces a compu­tational effect, only partial functors may contain sealed sub­structures; this signi.cantly 
weakens the utility of total functors. To overcome this limitation we distinguish two forms of effect, 
static and dynamic, and two forms of sealing, weak and strong. Weak sealing induces a static effect, 
which we think of as occur­ring once during type checking; strong sealing induces a dynamic effect, which 
we think of as occurring during execution. Dynamic effects induce partiality, static effects preserve 
totality. Existential Signatures In a manner similar to Shao [31], our type system is carefully crafted 
to circumvent the avoidance prob­lem, so that every module enjoys a principal signature. However, this 
requires imposing restrictions on the programmer. To lift these restrictions, we propose the use of existential 
signatures to provide principal signatures where none would otherwise exist. We show that these existential 
signatures are type-theoretically ill-behaved in 1Typically the omitted equations are not missed because 
restric­tions to named form or valuability prevent programmers from writ­ing code whose typeability would 
depend on those equations in the .rst place [4]. types t ::= Typ M |.s:s.t |t1 ×t2 terms e ::= Val M 
|(e1,e2)|pie |eM |.x f ( s:s) :t.e |let s = M in ( e : t) signatures s ::= 1 |[[ T ]] |[[ t]] |.tots:s1.s2 
|.pars:s1.s2 |Ss:s1.s2 |.( M) modules M ::= s |()|[ t] |[ e : t] |.s:s.M |M1M2 |(s = M1,M2)|piM |let 
s = M1 in ( M2: s) |M :> s |M :: s contexts G ::= |G, s:s Figure 1. Syntax general, so, we restrict their 
use to a well-behaved setting. In the style of Harper and Stone [13], we propose the use of an elaboration 
algorithm from an external language that may incur the avoidance problem, into our type system, which 
does not. Packaged Modules Modules in our system are second-class in the sense that the language of modules 
is separate from the language of terms. However, following Mitchell et al. [24] and Russo [29], we provide 
a way of packaging a module as a .rst-class value. In prior work, such packaged modules are typically 
given an existen­tial type, whose closed-scope elimination construct can make for awkward programming. 
Instead, our account of type generativity allows us to employ a more natural, open-scope elimination 
con­struct, whereby unpackaging a packaged module engenders a dy­namic effect. While these features combine 
naturally to form a very general lan­guage for modular programming, they would be of little use in the 
absence of a practical implementation strategy. Some previ­ous attempts have encountered dif.culties 
with undecidability [11] or incompleteness of type checking [27]. In contrast, our formalism leads to 
a practical, implementable programming language. The rest of this paper is structured as follows: In 
Section 2 we present our core type system for higher-order modules, including the intuition behind its 
design and a brief description of the de­cidable typechecking algorithm. In Section 3 we discuss the 
pro­gramming importance of having both weak and strong forms of sealing. In Section 4 we explain the 
avoidance problem and how it can be circumvented using an elaboration algorithm. In Section 5 we present 
a very simple, orthogonal extension of our core system to provide support for packaging modules as .rst-class 
values. Fi­nally, in Section 6 we compare our system with related work and in Section 7 we conclude. 
  2 Technical Development We begin our technical development by presenting the syntax of our language 
in Figure 1. Our language consists of four syntac­tic classes: terms, types, modules, and signatures 
(which serve as the types of modules). The language does not explicitly include higher-order type constructors 
or kinds (which ordinarily serve as constructors types); in our language the roles of constructors and 
kinds are subsumed by modules and signatures. Contexts bind mod­ule variables (s) to signatures. As usual, 
we consider alpha-equivalent expressions to be identical. We write the capture-avoiding substitution 
of M for s in an expres­sion E as E[ M/s] . Types There are three basic types in our language. The product 
type (t1 ×t2) is standard. The function type, .s:s.t, is the type of functions that accept a module argument 
s of signature s and return a value of type t (possibly containing s). As usual, if s does not appear 
free in t, we write .s:s.t as s .t. (This convention is used for the dependent products in the signature 
class as well.) Finally, when M is a module containing exactly one type (which is to say that M has the 
signature [[ T ]] ), that type is extracted by Typ M.A full-featured language would support a variety 
of additional types as well. Terms The term language contains the natural introduction and elimination 
constructs for recursive functions and products. In ad­dition, when M is a module containing exactly 
one value (which is to say that M has the signature [[ t]] , for some type t), that value is extracted 
by Val M. When f does not appear free in e, we write .x f ( s:s) :t.e as .s:s.e. The conventional forms 
of functions and polymorphic function are built from module functions. Ordinary functions are built using 
modules containing a single value: def t1 .t2 =[[ t1]] .t2 def .x:t.e( x)= .s:[[ t]] .e( Val s) def e1e2 
= e1[ e2] and polymorphic functions are built using modules containing a sin­gle type: def .a.t( a)= 
.s:[[ T ]] .t( Typ s) def .a.e( a)= .s:[[ T ]] .e( Typ s) def et = e[ t] Signatures There are seven basic 
signatures in our language. The atomic signature [[ T ]] is the type of an atomic module containing a 
single type, and the atomic signature [[ t]] is the type of an atomic module containing a single term. 
The atomic modules are written [ t] and [ e : t] , respectively. (We omit the type label : t from atomic 
term modules when it is clear from context.) The trivial atomic signature 1 is the type of the trivial 
atomic module (). The functor signatures .tots:s1.s2 and .pars:s1.s2 express the type of functors that 
accept an argument of signature s1 and return a result of signature s2 (possibly containing s). The reason 
for two different . signatures is to distinguish between total and partial functors, which we discuss 
in detail below. For convenience, we will take . (without a superscript) to be synonymous with .tot . 
When s does not appear free in s2, we write .s:s1.s2 as s1 .s2. The structure signature Ss:s1.s2 is the 
type of a pair of modules where the left-hand component has signature s1 and the right-hand component 
has signature s2, in which s refers to the left-hand com­ponent. As usual, when s does not appear free 
in s2, we write Ss:s1.s2 as s1 ×s2. The singleton signature .( M) is used to express type sharing infor­mation. 
It classi.es modules that have signature [[ T ]] and are stati­cally equivalent to M. Two modules are 
considered statically equiv­alent if they are equal modulo term components; that is, type .elds must 
agree but term .elds may differ. Singletons at signatures other than [[ T ]] are not provided primitively 
because they can be de.ned using the basic singleton, as described by Stone and Harper [33]. The de.nition 
of .s( M) (the signature containing only modules equal to M at signature s) is given in Figure 5. signature 
SIG = sig type s type t =s* int structure S : sig type u val f:u -> s end val g: t-> S.u end ... iscompiledas... 
Ss:[[ T ]] . St:.([ Typ s × int]) . SS:( Su:[[ T ]] .S f :[[ Typ u . Typ s]] .1) . Sg:[[ Typ t . Typ 
( p1S)]] .1 Figure 2. ML Signature Example Modules The module syntax contains module variables (s), the 
atomic modules, and the usual introduction and elimination con­structs for . and S signatures, except 
that S modules are introduced by (s = M1,M2), in which s stands for M1 and may appear free in M2. (When 
s does not appear free in M2, the s = is omitted.) No introduction or elimination constructs are provided 
for single­ton signatures. Singletons are introduced and eliminated by rules in the static semantics; 
if M is judged equivalent to M. in s, then M belongs to .s( M') , and vice versa. The remaining module 
constructs are strong sealing, written M :> s, and weak sealing, written M :: s. When a module is sealed 
either strongly or weakly, the result is opaque. By opaque we mean that no client of the module may depend 
on any details of the imple­mentation of M other than what is exposed by the signature s. The distinction 
between strong and weak sealing is discussed in detail below. Although higher-order type constructors 
do not appear explicitly in our language, they are faithfully represented in our language by unsealed 
modules containing only type components. For example, the kind ( T .T ) .T is represented by the signature 
([[ T]] .[[ T ]]) . [[ T ]] ; and the constructor .a:( T . T ) .( int × aint) is represented by the module 
.s:([[ T ]] . [[ T ]]) .[ int × Typ ( s[ int])] . Examples of how ML-style signatures and structures 
may be ex­pressed in our language appear in Figures 2 and 3. Comparability and Projectibility Two closely 
related issues are crucial to the design of a module system supporting type abstrac­tion: 1. When can 
a module be compared for equivalence with another module? 2. When can a type component be projected 
from a module and used as a type?  We say that a module is comparable iff it can be compared for equivalence 
with another module, and that a module is projectible iff its type components may be projected and used 
as type expres­sions. (In the literature most presentations emphasize projectibil­ity [11, 14, 15].) 
structure S1 = struct type s = bool type t =bool * int structure S = struct type u = string val f = (fn 
y:u => true) end val g = (fn y:t => "hello world") end ... iscompiledas... (s =[ bool] , (t =[ bool 
× int] , (S = (u =[ string] ,( f =[ .y:Typ u.true] ,())), (g =[ .y:Typ t."hello world"] ,())))) Figure 
3. ML Structure Example A simple analysis of the properties of comparability and projectibil­ity suggests 
that they are closely related. Suppose that M is a pro­jectible module with signature [[ T]] , so that 
Typ M is a type. Since type equality is an equivalence relation, this type may be compared with any other, 
in particular, Typ M. for another projectible mod­ule M. of the same signature. But since Typ M and Typ 
M. fully determine M, we are, in effect, comparing M with M. for equiva­lence. This suggests that projectible 
modules be regarded as compa­rable for type checking purposes. Conversely, if M is a comparable module, 
then by extensionality M should be equivalent to [ Typ M] , which is only sensible if M is also projectible. 
Purity and Impurity The design of our module system rests on the semantic notions of purity and impurity 
induced by computa­tional effects. To motivate the design, .rst recall that in a .rst-class module system 
such as Harper and Lillibridge s [11] there can be impure module expressions that yield distinct type 
components each time they are evaluated. For example, a module expression M might consult the state of 
the world, yielding a different mod­ule for each outcome of the test. The type components of such a module 
are not statically well-determined, and hence should not be admitted as type expressions at all, much 
less compared for equiv­alence. On the other hand, even in such a general framework, pure (effect-free) 
modules may be safely regarded as both comparable and projectible. In a second-class module system such 
examples are not, in fact, expressible, but we will nevertheless .nd it useful to classify mod­ules according 
to their purity.2 This classi.cation is semantic, in the sense of being de.ned by judgments of the calculus, 
rather than syntactic, in the sense of being determined solely by the form of expression. Such a semantic 
approach is important for a correct account of type abstraction in a full-featured module language. The 
axiomatization of purity and impurity in our system is based on a set of rules that takes account of 
the types of expressions, as well as their syntactic forms. The type system is conservative in that it 
assumes the worst of an impure module expression, ruling it 2Moreover, in Section 5 we will introduce 
the means to re-create these examples in our setting, making essential use of the same clas­si.cation 
system. incomparable and non-projectible, even when its type components are in fact statically well-determined. 
As we will see shortly, this is important for enforcing type abstraction, as well as ensuring sound­ness 
in the presence of .rst-class modules. In addition, since it is sound to do so, we deem all pure module 
expressions to be compa­rable and projectible. That is, to be as permissive as possible with­out violating 
soundness or abstraction, we identify comparability and projectibility with purity. Finally, note that 
a module is judged pure based on whether its type components are well-determined, which is independent 
of whether any term components have com­putational effects. In the literature different accounts of higher-order 
modules provide different classes of pure modules. For example, in Harper and Lil­libridge s .rst-class 
module system [11], only syntactic values are considered pure. In Leroy s second-class module calculi 
[14, 15], purity is limited to the syntactic category of paths. In Harper et al. s early phase-distinction 
calculus [12] all modules are deemed to be pure, but no means of abstraction is provided. Abstraction 
via Sealing The principal means for de.ning ab­stract types is sealing, written M :> s. Sealing M with 
s pre­vents any client of M from depending on the identities of any type components speci.ed opaquely 
with signature [[ T ]] rather than .[[ T ]]( M) inside s. From the point of view of module equivalence, 
this means that a sealed module should be considered incompara­ble. To see this, suppose that M =([ int] 
:>[[ T ]]) is regarded as comparable. Presumably, M could not be deemed equivalent to M' =([ bool] :>[[ 
T ]]) since their underlying type components are different. However, since module equivalence is re.exive, 
if M is comparable, then M must be deemed equivalent to itself. This would mean that the type system 
would distinguish two opaque modules based on their underlying implementation, a violation of type abstraction. 
A signi.cant advantage of our judgmental approach to purity is that it affords a natural means of ensuring 
that a sealed module is in­comparable, namely to judge it impure. This amounts to regarding sealing as 
a pro forma run-time effect, even though no actual effect occurs at execution time. Not only does this 
ensure that abstraction violations such as the one just illustrated are ruled out, but we will also show 
in Section 3 that doing so allows the type system to track the run-time generation of new types. Applicative 
and Generative Functors Functors in Standard ML are generative in the sense that each abstract type in 
the result of the functor is generated afresh for each instance of the functor, regardless of whether 
or not the arguments in each instance are equivalent. Functors in Objective Caml, however, are applicative 
in the sense that they preserve equivalence: if applied to equivalent arguments, they yield equivalent 
results. In particular, the abstract types in the result of a functor are the same for any two applications 
to the same argument. Continuing the analogy with computational effects, we will deem any functor whose 
body is pure to be total, otherwise partial. The application of a pure, total functor to a pure argument 
is pure, and hence comparable. Total functors are applicative in the sense that the application of a 
pure total functor to two equivalent pure mod­ules yields equivalent pure modules, because the applications 
are pure, and hence comparable. Partial functors, on the other hand, always yield impure modules when 
applied. Therefore they do not respect equivalence of arguments (because the results, being im­pure, 
are not even comparable), ensuring that each instance yields a distinct result. We distinguish the signatures 
of total (applicative) and partial (gen­erative) functors. Total functors have . signatures, whereas 
partial functors have .par signatures. The subtyping relation is de.ned so that every total functor may 
be regarded (degenerately) as a partial functor. Weak and Strong Sealing In our system we identify applicative 
functors with total ones, and generative functors with partial ones. To make this work, however, we must 
re.ne the notion of effect. For if sealing is regarded as inducing a run-time effect, then it is impossible 
to employ abstraction within the body of a total func­tor, for to do so renders the body impure. (We 
may seal the entire functor with a total functor signature to impose abstraction, but this only ensures 
that the exported types of the functor are held abstract in any clients of that functor. It does not 
permit a substructure in the body of the functor to be held abstract in both the clients of the functor 
and in the remainder of the functor body.) The solution is to distinguish two forms of sealing strong, 
written M :> s as before, and weak, written M :: s. Both impose abstrac­tion in the sense of limiting 
type propagation to what is explicitly speci.ed in the ascribed signature by regarding both forms of 
seal­ing as inducing impurity. However, to support a useful class of applicative functors, we further 
distinguish between static and dy­namic effects. Weak sealing induces a static effect, whereas strong 
sealing induces dynamic effect. The signi.cance of this distinction lies in the de.nition of total and 
partial functors. A functor whose body involves a dynamic effect (i.e.,is dynamically impure), is ruled 
partial, and hence generative. Thus strong sealing within a functor body induces generativity of that 
functor. A functor whose body is either pure, or involves only a static effect (i.e.,is dynamically pure), 
is ruled total, and hence applicative. This ensures that applicative functors may use abstrac­tion within 
their bodies without incurring generative behavior. The methodological importance of this distinction 
is discussed in Sec­tion 3. A dynamic effect may be thought of as one that occurs during exe­cution, 
whereas a static effect is one that occurs during type check­ing. Dynamic effects are suspended inside 
of a .-abstraction, so functor abstractions are dynamically pure. However, when applied, the dynamic 
effects inside the functor are released, so that the ap­plication is dynamically impure. On the other 
hand, static effects occur during type checking, and hence are not suspended by .­abstraction, nor released 
by application. Formalization The typing judgment for our system is written G f. M : s, where . indicates 
M s purity. The classi.er . is drawn from the following four-point lattice: W / \ DS \ / P The point 
P indicates that M is pure (and hence comparable and pro­jectible), D indicates dynamic purity, S indicates 
static purity, and W indicates well-formedness only (no purity information). Hence, G fP M : s is our 
purity judgment. It will prove to be convenient in our typing rules to exploit the ordering (written 
C), meets (n), and joins (U) of this lattice, where P is taken as the bottom and W is taken as the top. 
We also sometimes .nd it convenient to use the notation .ds:s1.s2 for a functor signature that is either 
total or partial depending on whether d = tot or d = par, respectively. ' Gf.M : s.C .Gf.M : sGf.M : 
sGf ok ( 1)( 2)( 3)( 4) Gf.' M : sGfW ( M :> s) : sGf.UD ( M :: s) : sGfP s : G( s) G,s:s1 f.M : s2 .C 
D G,s:s1 f.M : s2 G,s:s1 f s2 sig ( 5)( 6)( 7) totpartotpar Gf..s:s1.M : .s:s1.s2 Gf.nD .s:s1.M : .s:s1.s2 
Gf .s:s1.s2 = .s:s1.s2 totpar Gf.M1: .s:s1.s2 GfP M2: s1 Gf.M1: .s:s1.s2 GfP M2: s1 ( 8)( 9) Gf.M1M2: 
s2[ M2/s] Gf.US M1M2: s2[ M2/s] ' Gf.M : Ss:s1.s2 GfP M : Ss:s1.s2 Gf.M : sGf s= s ( 10)( 11)( 12) ' 
 Gf.p1M : s1 GfP p2M : s2[ p1M/s] Gf.M : s Figure 4. Key Typing Rules Some key rules are summarized in 
Figure 4. Pure modules are dy­namically pure and statically pure, and each of those are at least well-formed 
(rule 1). Strongly sealed modules are neither statically nor dynamically pure (2); weakly sealed modules 
are not statically pure, but are dynamically pure if their body is (3). Applicative functors must have 
dynamically pure bodies (5); generative func­tors have no restriction (6). Applicative functors may be 
used as generative ones (7). Variables are pure (4), and lambdas are dy­namically pure (5 and 6). The 
application of an applicative functor is as pure as the functor itself (8), but the application of a 
generative functor is at best statically pure (9). Finally, the purity of a module is preserved by signature 
subsumption (12). The complete set of typing rules is given in Appendix A. The rules for functor application 
(rules 8 and 9) require that the functor argument be pure. This is because the functor argument is substituted 
into the functor s codomain to produce the result signa­ture, and the substitution of impure modules 
for variables (which are always pure) can turn well-formed signatures into ill-formed ones (for example, 
[ Typ s] becomes ill-formed if an impure mod­ule is substituted for s). (An alternative rule proposed 
by Harper and Lillibridge [11] resolves this issue, but induces the avoidance problem, as we discuss 
in Section 4.) Therefore, when a functor is to be applied to an impure argument, that argument must .rst 
be bound to a variable, which is pure. Similarly, projection of the sec­ond component of a pair is restricted 
to pure pairs (rule 11), but no such restriction need be made for projection of the .rst component (rule 
10), since no substitution is involved. Static Equivalence In the foregoing discussion we have fre­quently 
made reference to a notion of module equivalence, without specifying what this means. A key design decision 
for a module cal­culus is to de.ne when two comparable modules are to be deemed equivalent. Different 
module systems arise from different notions of equivalence. If a pure module has signature [[ T ]] , 
it is possible to extract the type component from it. Type checking depends essentially on the matter 
of which types are equal, so we must consider when Typ M is equal to Typ M '. The simplest answer would 
be to regard Typ M = Typ M ' exactly when the modules M and M ' are equal. But this is too naive because 
we cannot in general determine when two modules are equal. Suppose F : [[ int]] .sand e,e ' : int. Then 
F [ e]= F [ e '] if and only if e = e ', but the latter equality is undecid­able in general. A characteristic 
feature of second class module systems is that they respect the phase distinction [12] between compile-time 
and run­time computation. This property of a module system states that type equivalence must be decidable 
independently of term equivalence. This should be intuitively plausible, since a second-class module 
system provides no means by which a type component of a module can depend on a term component. (This 
is not happenstance, but the result of careful design. We will see in Section 5 that the matter is more 
subtle than it appears.) Based on this principle, we de.ne module equivalence to be equiv­alence for 
type checking purposes , or static equivalence. Roughly speaking, two modules are deemed to be equivalent 
whenever they agree on their corresponding type components.3 We write our module equivalence judgment 
as Gf M ~M ' : s. = The rules for static equivalence of atomic modules are the expected ones. Atomic 
type components must be equal, but atomic term components need not be: Gf t= t' GfP M : [[ t]] GfP M 
' : [[ t]] ] ~f M ~ Gf [ t=[ t'] : [[ T ]] G= M ' : [[ t]] Since the generative production of new types 
in a generative functor is notionally a dynamic operation, generative functors have no static components 
to compare. Thus, pure generative functors are always statically equivalent, just as atomic term modules 
are: parpar GfP M : .s:s1.s2 GfP M ' : .s:s1.s2 Gf M ~M ' : .s:s = par1.s2 The complete set of equivalence 
rules is given in Appendix A. As an aside, this discussion of module equivalence refutes the mis­conception 
that .rst-class modules are more general than second­class modules. In fact, the expressiveness of .rst-and 
second-class modules is incomparable. First-class modules have the obvious ad­vantage that they are .rst-class. 
However, since the type compo­nents of a .rst-class module can depend on run-time computations, it is 
impossible to get by with static module equivalence and one 3The phase distinction calculus of Harper, 
et al. [12] includes non-standard equality rules for phase-splitting modules M into structures (Mstat,Mdyn) 
consisting of a static component Mstat and a dynamic component Mdyn. Our static equivalence M ~M ' amounts 
= to saying Mstat = stat in their system. However, we do not identify M ' functors with structures, as 
they do. must use dynamic equivalence instead (in other words, one can­not phase-split modules as in 
Harper et al. [12]). Consequently, .rst-class modules cannot propagate as much type information as second-class 
modules can. Singleton Signatures Type sharing information is expressed in our language using singleton 
signatures [33], a derivative of translu­cent sums [11, 14, 18]. (An illustration of the use of singleton 
signatures to express type sharing appears in Figure 2.) The type system allows the deduction of equivalences 
from membership in singleton signatures, and vice versa, and also allows the forgetting of singleton 
information using the subsignature relation: G fP M : .s( M ') G fP M ' : sG f M ~M ' : s = G f M ~= 
M ' : s G fP M : .s( M ') G fP M : s G f M ~= M ' : s G f .s( M) = s G f .s( M) = .s( M ') When s =[[ 
T]] , these deductions follow using primitive rules of the type system (since .[[ T ]]( M)= .( M) is 
primitive). At other signa­tures, they follow from the de.nitions given in Figure 5. Beyond expressing 
sharing, singletons are useful for sel..ca­tion [11]. For instance, if s is a variable bound with the 
signature [[ T ]] , s can be given the fully transparent signature .( s) . This fact is essential to 
the existence of principal signatures in our type check­ing algorithm. Note that since singleton signatures 
express static equivalence information, the formation of singleton signatures is restricted to pure modules. 
Thus, only pure modules can be sel.­.ed (as in Harper and Lillibridge [11] and Leroy [14]). Singleton 
signatures complicate equivalence checking, since equiv­alence can depend on context. For example, .s:[[ 
T ]] .[ int] and .s:[[ T ]] .s are obviously inequivalent at signature [[ T ]] . [[ T ]] .How­ever, using 
subsignatures, they can also be given the signature .([ int]) .[[ T ]] and at that signature they are 
equivalent, since they return the same result when given the only permissible argument, [ int] . As this 
example illustrates, the context sensitivity of equivalence provides more type equalities than would 
hold if equivalence were strictly context insensitive, thereby allowing the propagation of ad­ditional 
type information. For example, if F : ( .([ int]) . [[ T]]) . [[ T ]] , then the types Typ ( F( .s:[[ 
T ]] .[ int])) and Typ ( F( .s:[[ T]] .s)) are equal, which could not be the case under a context-insensitive 
regime. A subtle technical point arises in the use of the higher-order singletons de.ned in Figure 5. 
Suppose F : [[ T ]] . [[ T ]] . Then .[[ T ]] .[[ T ]]( F)= .s:[[ T ]] ..( Fs) , which intuitively contains 
the mod­ules equivalent to F: those that take members of F s domain and return the same thing that F 
does. Formally speaking, however, the canonical member of this signature is not F but its eta-expansion 
.s:[[ T ]] .Fs. In fact, it is not obvious that F belongs to .[[ T ]] .[[ T ]]( F) . To ensure that F 
belongs to its singleton signature, our type system (following Stone and Harper [33]) includes the extensional 
typing rule: G fP M : .s:s1.s' 2 G,s:s1 fP Ms : s2 G fP M : .s:s1.s2 Using this rule, F belongs to .s:[[ 
T ]] ..( Fs) because it is a function and because Fs belongs to .( Fs) . A similar extensional typing 
rule is provided for products. It is possible that the need for these def .[[ T ]]( M)= .( M) def .[[ 
t]]( M) =[[ t]] def .1( M)= 1 def .tot ..tots:s1.s2 ( M)= s:s1..s2 ( Ms) def .par ..pars:s1.s2 ( M)= 
s:s1.s2 def .Ss:s1 .s2 ( M)= .s1 ( p1M) × .s2[ p1M/s]( p2M) def .( M)= .( M) .( M') Figure 5. Singletons 
at Higher Signatures rules could be avoided by making higher-order singletons primitive, but we have 
not explored the meta-theoretic implications of such a change. Since a module with a (higher-order) singleton 
signature is fully transparent, it is obviously projectible and comparable, and hence could be judged 
to be pure, even if it would otherwise be classi.ed as impure. This is an instance of the general problem 
of recognizing that benign effects need not disturb purity. Since purity is a judg­ment in our framework, 
we could readily incorporate extensions to capture such situations, but we do not pursue the matter here. 
Type Checking Our type system enjoys a sound, complete, and effective type checking algorithm. Our algorithm 
comes in three main parts: .rst, an algorithm for synthesizing the principal (i.e., minimal) signature 
of a module; second, an algorithm for check­ing subsignature relationships; and third, an algorithm for 
deciding equivalence of modules and of types. Module typechecking then proceeds in the usual manner, 
by syn­thesizing the principal signature of a module and then checking that it is a subsignature of the 
intended signature. The signature synthesis algorithm is given in Appendix B, and its correctness the­orems 
are stated below. The main judgment of signature synthesis is G f. M . s, which states that M s principal 
signature is s and M s purity is inferred to be .. Subsignature checking is syntax-directed and easy 
to do, given an algorithm for checking module equivalence; module equivalence arises when two singleton 
signatures are compared for the subsigna­ture relation. The equivalence algorithm is closely based on 
Stone and Harper s algorithm [33] for type constructor equivalence in the presence of singleton kinds. 
Space considerations preclude further discussion of this algorithm here. Full details of all these algorithms 
and proofs appear in the companion technical report [7]. THEOREM 2.1 (SOUNDNESS). If G f. M . s then 
G f. M : s. THEOREM 2.2 (COMPLETENESS). If G f. M : s then G f.' M . s' and G f s'= s and .'C .. Note 
that since the synthesis algorithm is deterministic, it follows from Theorem 2.2 that principal signatures 
exist. Finally, since our synthesis algorithm, for convenience, is presented in terms of in­ference rules, 
we require one more result stating that it really is an algorithm: THEOREM 2.3 (EFFECTIVENESS). For any 
G and M, it is decid­able whether there exist s and . such that G f. M . s. signature SYMBOL TABLE = 
sig type symbol val string to symbol : string -> symbol val symbol to string : symbol -> string val eq 
: symbol * symbol -> bool end functor SymbolTableFun () :> SYMBOL TABLE = struct type symbol = int val 
table : string array = (* allocate internal hash table *) Array.array (initial size, NONE) fun string 
to symbol x = (* lookup (or insert) x *) ... fun symbol to string n = (case Array.sub (table, n) of SOME 
x => x | NONE => raise (Fail "bad symbol")) fun eq (n1, n2) = (n1 = n2) end structure SymbolTable = 
SymbolTableFun () Figure 6. Strong Sealing Example  3 Strong and Weak Sealing Generativity is essential 
for providing the necessary degree of ab­straction in the presence of effects. When a module has side-effects, 
such as the allocation of storage, abstraction may demand that types be generated in correspondence to 
storage allocation, in order to en­sure that elements of those types relate to the local store and not 
the store of another instance. Consider, for example, the symbol table example given in Figure 6. A symbol 
table contains an abstract type symbol, operations for in­terconverting symbols and strings, and an equality 
test (presumably faster than that available for strings). The implementation creates an internal hash 
table and de.nes symbols to be indices into that internal table. The intention of this implementation 
is that the Fail exception never be raised. However, this depends on the generativity of the symbol type. 
If another instance, SymbolTable2, is created, and the types SymbolTable.symbol and SymbolTable2.symbol 
are considered equal, then SymbolTable could be asked to interpret indices into SymbolTable2 s table, 
thereby causing failure. Thus, it is essential that SymbolTable.symbol and SymbolTable2.symbol be considered 
unequal. The symbol table example demonstrates the importance of strong sealing for encoding generative 
abstract types in stateful modules. Generativity is not necessary, however, for purely functional mod­ules. 
Leroy [15] gives several examples of such modules as moti­vation for the adoption of applicative functors. 
For instance, one may wish to implement persistent sets using ordered lists. Figure 7 signature ORD = 
sig type elem val compare : elem * elem -> order end signature SET = (* persistent sets *) sig type elem 
type set val empty : set val insert : elem * set -> set ... end functor SetFun (Elem : ORD) :: SET where 
type elem = Elem.elem = struct type elem = Elem.elem type set = elem list ... end structure IntOrd = 
struct type elem = int val compare = Int.compare end structure IntSet1 = SetFun(IntOrd) structure IntSet2 
= SetFun(IntOrd) Figure 7. Weak Sealing Example exhibits a purely functional SetFun functor, which is 
parameter­ized over an ordered element type, and whose implementation of the abstract set type is sealed. 
When SetFun is instantiated multi­ple times e.g., in different client modules with the same element type, 
it is useful for the resulting abstract set types to be seen as interchangeable. In our system, SetFun 
is made applicative, but still opaque, by weakly sealing its body. Speci.cally, IntSet1.set and IntSet2.set 
are both equivalent to SetFun(IntOrd).set. This type is well-formed because SetFun has an applicative 
functor sig­nature, and SetFun and IntOrd, being variables, are both pure. Recall that a functor containing 
weak sealing is impure and must be bound to a variable before it can be used applicatively. The astute 
reader may notice that weak sealing is not truly neces­sary in the SetFun example. In fact, one can achieve 
the same effect as the code in Figure 7 by leaving the body of the functor unsealed and (strongly) sealing 
the functor itself with an applicative functor signature before binding it to SetFun. This is the technique 
em­ployed by Shao [31] for encoding applicative functors, as his sys­tem lacks an analogue of weak sealing. 
A failing of this approach is that it only works if the functor body is fully transparent in the absence 
of weak sealing, any opaque substructures would have to be strongly sealed, preventing the functor from 
being given an ap­plicative signature. The best examples of the need for opaque substructures in applica­tive 
functors are provided by the interpretation of ML datatype s as abstract types [13]. In both Standard 
ML and Caml, datatype s are opaque in the sense that their representation as recursive sum types is not 
exposed, and thus distinct instances of the same datatype declaration create distinct types. Standard 
ML and Caml differ, however, on whether datatype s are generative.In the presence of applicative functors 
(which are absent from Stan­dard ML) there is excellent reason for datatype s not to be generative namely, 
that a generative interpretation would prevent datatype s from appearing in the bodies of applicative 
functors. This would severely diminish the utility of applicative functors, par­ticularly since in ML 
recursive types are provided only through the datatype mechanism. For example, an implementation of SetFun 
with splay trees, using a datatype declaration to de.ne the tree type, would require the use of weak 
sealing. For these reasons, strong sealing is no substitute for weak sealing. Neither is weak sealing 
a substitute for strong. As Leroy [15] ob­served, in functor-free code, generativity can be simulated 
by what we call weak sealing. (This can be seen in our framework by ob­serving that dynamic purity provides 
no extra privileges in the ab­sence of functors.) With functors, however, strong sealing is nec­essary 
to provide true generativity. Nevertheless, it is worth noting that strong sealing is de.nable in terms 
of other constructs in our language, while weak sealing is not. In particular, we can de.ne strong sealing, 
using a combination of weak sealing and generative functor application, as follows: :1.M) ::( .par M 
:> s =(( . def:1.s)) () The existence of this encoding does not diminish the importance of strong sealing, 
which we have made primitive in our language regardless. 4 The Avoidance Problem The rules of our type 
system (particularly rules 8, 9, and 11 from Figure 4) are careful to ensure that substituted modules 
are always pure, at the expense of requiring that functor and second-projection arguments are pure. This 
is necessary because the result of substi­tuting an impure module into a well-formed signature can be 
ill­formed. Thus, to apply a functor to an impure argument, one must let-bind the argument and apply 
the functor to the resulting (pure) variable. A similar restriction is imposed by Shao [31], but Harper 
and Lillib­ridge [11] propose an alternative that softens the restriction. Harper and Lillibridge s proposal 
(expressed in our terms) is to include a non-dependent typing rule without a purity restriction: G f. 
M1: s1 . s2 G f. M2: s1  G f. M1M2: s2 When M2 is pure, this rule carries the same force as our dependent 
rule, by exploiting singleton signatures and the contravariance of functor signatures: .s:s1.s2 = .s:.s1 
( M2) .s2 = .s:.s1 ( M2) .s2[ M2/s] = .s1 ( M2) . s2[ M2/s] When M2 is impure, this rule is more expressive 
than our typing rule, because the application can still occur. However, to exploit this rule, the type 
checker must .nd a non-dependent supersignature that is suitable for application to M2. The avoidance 
problem [9, 18] is that there is no best way to do so. For example, consider the signature: s =([ T ]] 
. .( s)) × .( s) To obtain a supersignature of s avoiding the variable s, we must forget that the .rst 
component is a constant function, and therefore we can only say that the second component is equal to 
the .rst component s result on some particular argument. Thus, for any type t, we may promote s to the 
supersignature: SF:([[ T]] . [[ T ]]) . .( F[ t]) This gives us an in.nite array of choices. Any of these 
choices is superior to the obvious ([[ T ]] .[[ T ]]) ×[[ T]] , but none of them is com­parable to any 
other, since F is abstract. Thus, there is no minimal supersignature of s avoiding s. The absence of 
minimal signatures is a problem, because it means that there is no obvious way to per­form type checking. 
In our type system, we circumvent the avoidance problem by requir­ing that the arguments of functor application 
and second-projection be pure (thereby eliminating any need to .nd non-dependent super­signatures), and 
provide a let construct so that such operations can still be applied to impure modules. We have shown 
that, as a result, our type theory does enjoy principal signatures. To achieve this, however, our let 
construct must be labeled with its result signature (not mentioning the variable being bound), for oth­erwise 
the avoidance problem re-arises. This essentially requires that every functor application or projection 
involving an impure ar­gument be labelled with its result signature as well, leading to po­tentially 
unacceptable syntactic overhead in practice. Fortunately, programs can be systematically rewritten to 
avoid this problem, as we describe next. 4.1 Elaboration and Existential Signatures Consider the unannotated 
let expression let s = M1 in M2, where M1: s1 and M2: s2( s) .If M1 is pure, then the let expression 
can be given the minimal signature s2( M1) . Otherwise, we are left with the variable s leaving scope, 
but no minimal supersignature of s2( s) not mentioning s. However, if we rewrite the let expression as 
the pair (s = M1,M2), then we may give it the signature Ss:s1.s2( s) and no avoidance problem arises. 
Similarly, the functor application F( M) with F : .s:s1.s2 and impure M : s1 can be rewritten as (s = 
M,F( s) ) and given signature Ss:s1.s2. Following Harper and Stone [13], we propose the use of an elabora­tion 
algorithm to systematize these rewritings. This elaborator takes code written in an external language 
that supports unannotated let s, as well as impure functor application and second-projection, and produces 
code written in our type system. Since the elaborator rewrites modules in a manner that changes their 
signatures, it also must take responsibility for converting those modules back to their expected signature 
wherever required. This means that the elabora­tor must track which pairs are real and which have been 
invented by the elaborator to circumvent the avoidance problem. The elaborator does so using the types. 
When the elaborator invents a pair to circumvent the avoidance problem, it gives its signature us­ing 
an existential . rather than S. In the internal language, .s:s1.s2 means the same thing as Ss:s1.s2, 
but the elaborator treats the two signatures differently: When the elaborator expects (say) a functor 
and encounters a Ss:s1.s2, it generates a type error. However, when it encounters an .s:s1.s2, it extracts 
the s2 component (the elab­orator s invariants ensure that it always can do so), looking for the expected 
functor. Space considerations preclude further details of the elaboration algorithm, which appear in 
the companion technical report [7]. In a sense, the elaborator solves the avoidance problem by intro­ducing 
existential signatures to serve in place of the non-existent minimal supersignatures not mentioning a 
variable. In light of this, a natural question is whether the need for an elaborator could be eliminated 
by making existential signatures primitive to the type system. One natural way to govern primitive existentials 
is with the intro­duction and elimination rules: G f P M : s1 G f s = s2[ M/s] G,s:s1 f s2 sig G f s 
=. s:s1.s2 and G,s:s1 f s2 = sG f s1 sig G f s sig G f. s:s1.s2 = s With these rules, the avoidance problem 
could be solved: The least supersignature of s2( s) not mentioning s:s1 would be . s:s1.s2( s) . Unfortunately, 
these rules (particularly the .rst) make type check­ing undecidable. For example, each of the queries 
? .s:s.[[ t]] =. s ' :s..s:.s( s ' ) .[[ t' ]] and ? ~ ( .s:s.[ t]) = ( .s:s.[ t' ]) : . s ' :s..s:.s( 
s ' ) .[[ T ]] holds if and only if there exists pure M : s such that the types t[ M/s] and t' [ M/s] 
are equal. Thus, deciding subsignature or equivalence queries in the presence of existentials would be 
as hard as higher­order uni.cation, which is known to be undecidable [10]. 4.2 Syntactic Principal Signatures 
It has been argued for reasons related to separate compilation that principal signatures should be expressible 
in the syntax available to the programmer. This provides the strongest support for separate compilation, 
because a programmer can break a program at any point and write an interface that expresses all the information 
the compiler could have determined at that point. Such strong support does not appear to be vital in 
practice, since systems such as Objec­tive Caml and Standard ML of New Jersey s higher-order modules 
have been used successfully for some time without principal signa­tures at all, but it is nevertheless 
a desirable property. Our type system (i.e., the internal language) does provide syntac­tic principal 
signatures, since principal signatures exist, and all the syntax is available to the programmer. However, 
the elaborator s external language does not provide syntax for the existential sig­natures that can appear 
in elaborator signatures, which should be thought of as the principal signatures of external modules. 
Thus, we can say that our basic type system provides syntactic principal signatures, but our external 
language does not. In an external language where the programmer is permitted to write existential signatures, 
elaborating code such as: ( .s ' :( . s:s1.s2) ...) M requires the elaborator to decide whether M can 
be coerced to be­long to . s:s1.s2, which in turn requires the elaborator to produce a M ' : s1 such 
that M : s2[ M ' /s] . Determining whether any such M ' exists requires the elaborator to solve an undecidable 
higher-order uni.cation problem: if s2 = .([ t]) . .([ t' ]) and M = .t:[[ T ]] .t, then M : s2[ M ' 
/s] if and only if t[ M ' /s] and t' [ M ' /s] are equal. Thus, to allow programmer-speci.ed existential 
signatures in the greatest possible generality would make elaboration undecidable. Partial measures may 
be possible, but we will not discuss any here.  5 Packaging Modules as First-Class Values It is desirable 
for modules to be usable as .rst-class values. This is useful to make it possible to choose at run time 
the most ef.cient implementation of a signature for a particular data set (for example, sparse or dense 
representations of arrays). However, fully general .rst-class modules present dif.culties for static 
typing [18]. One practical approach to modules as .rst-class values was sug­gested by Mitchell, et al. 
[24], who propose that second-class mod­ules automatically be wrapped as existential packages [25] to 
obtain .rst-class values. A similar approach to modules as .rst-class val­ues is described by Russo and 
implemented in Moscow ML [29]. This existential-packaging approach to modules as .rst-class values is 
built into our language. We write the type of a packaged module as (| s|) and the packaging construct 
as pack M as (| s|) . Elimina­tion of packaged modules (as for existentials) is performed using a closed-scope 
unpacking construct. These may be de.ned as fol­lows: def (| s|) = . a.( s . a) . a def pack M as (| 
s|) = .a.. f :( s . a) .fM ' def unpack e as s:s in ( e : t)= et( .s:s.e ' ) (Compare the de.nition of 
(| s|) with the standard encoding of the existential type . ß.t as . a.( . ß.t . a) . a.) The main limitation 
of existentially-packaged modules is the closed-scope elimination construct. It has been observed repeatedly 
in the literature [20, 3, 18] that this construct is too restrictive to be ' very useful. For one, in 
unpack e as s:s in ( e : t) , the result type t may not mention s. As a consequence, functions over packaged 
modules may not be dependent; that is, the result type may not men­tion the argument. This de.ciency 
is mitigated in our language by the ability to write functions over unpackaged, second-class mod­ules, 
which can be given the dependent type .s:s.t( s) instead of (| s|) . t. Another problem with the closed-scope 
elimination construct is that a term of package type cannot be unpacked into a stand-alone second-class 
module; it can only be unpacked inside an enclosing term. As each unpacking of a packaged module creates 
an abstract type in a separate scope, packages must be unpacked at a very early stage to ensure coherence 
among their clients, leading to scope inversions that are awkward to manage in practice. What we desire, 
therefore, is a new module construct of the form unpack e as s , which coerces a .rst-class package e 
of type (| s|)back into a second-class module of signature s. The following ex­ample illustrates how 
adding such a construct carelessly can lead to unsoundness: module F = .s:[[ (| s|) ]] .( unpack ( Val 
s) as s) module X1 = F [ pack M1 as (| s|) ] module X2 = F [ pack M2 as (| s|) ] Note that the argument 
of the functor F is an atomic term module, so all arguments to F are statically equivalent. If F is given 
an applicative signature, then X1 and X2 will be deemed equivalent, even if the original modules M1 and 
M2 are not! Thus, F must be types t ::= ··· | (| s|)terms e ::= ··· | pack M as (| s|)modules M ::= ··· 
| unpack e as s G f s1 = s2 G f . M : s G f(| s1|) = (| s2|) G f pack M as (| s|) : (| s|) G f e : (| 
s|) G f S unpack e as s : s Figure 8. Packaged Module Extension deemed generative, which in turn requires 
that the unpack construct induce a dynamic effect. Packaged modules that admit this improved unpacking 
construct are not de.nable in our core language, but they constitute a simple, orthogonal extension to 
the type system that does not complicate type checking. The syntax and typing rules for this extension 
are given in Figure 8. Note that the closed-scope unpacking construct is de.nable as ' let s =(unpack 
e as s) in (e : t) Intuitively, unpacking is generative because the module being un­packed can be an 
arbitrary term, whose type components may de­pend on run-time conditions. In the core system we presented 
in Section 2, the generativity induced by strong sealing was merely a pro forma effect the language, 
supporting only second-class mod­ules, provided no way for the type components of a module to be actually 
generated at run time. The type system, however, treats dynamic effects as if they are all truly dynamic, 
and thus it scales easily to handle the real run-time type generation enabled by the extension in Figure 
8. 6 Related Work Harper, Mitchell and Moggi [12] pioneered the theory of phase sep­aration, which is 
fundamental to achieving maximal type propaga­tion in higher-order module systems. Their non-standard 
equational rules, which identify higher-order modules with primitive phase­split ones, are similar in 
spirit to, though different in detail from, our notion of static module equivalence. One may view their 
sys­tem as a subsystem of ours in which there is no sealing mechanism (and consequently all modules are 
pure). MacQueen and Tofte [21] proposed a higher-order module exten­sion to the original De.nition of 
Standard ML [22], which was im­plemented in the Standard ML of New Jersey compiler. Their se­mantics 
involves a two-phase elaboration process, in which higher­order functors are re-elaborated at each application 
to take advan­tage of additional information about their arguments. This advan­tage is balanced by the 
disadvantage of inhibiting type propagation in the presence of separate compilation since functors that 
are com­piled separately from their applications cannot be re-elaborated. A more thorough comparison 
is dif.cult because MacQueen and Tofte employ a stamp-based semantics, which is dif.cult to transfer 
to a type-theoretic setting. Focusing on controlled abstraction, but largely neglecting higher­order 
modules, Harper and Lillibridge [11] and Leroy [14, 16] in­troduced the closely related concepts of translucent 
sums and man­ifest types. These mechanisms served as the basis of the module system in the revised De.nition 
of Standard ML 1997 [23], and Harper and Stone [13] have formalized the elaboration of Stan­dard ML 1997 
programs into a translucent sums calculus. To deal with the avoidance problem, Harper and Stone rely 
on elaborator mechanisms similar to ours. The Harper and Stone language can be viewed as a subsystem 
of ours in which all functors are generative and only strong sealing is supported. Leroy introduced the 
notion of an applicative functor [15], which enables one to give fully transparent signatures for many 
higher­order functors. Leroy s formalism may be seen as de.ning purity by a syntactic restriction that 
functor applications appearing in type paths must be in named form. On one hand, this restriction provides 
a weak form of structure sharing in the sense that the abstract type F(X).t can only be the result of 
applying F to the module named X. On the other hand, the restriction prevents the system from captur­ing 
the full equational theory of higher-order functors, since not all equations can be expressed in named 
form [4]. Together, manifest types and applicative functors form the basis of the module sys­tem of Objective 
Caml [27]. The manifest type formalism, like the translucent sum formalism, does not address the avoidance 
prob­lem, and consequently it lacks principal signatures. More recently, Russo, in his thesis [28], formalized 
two separate module languages: one being a close model of the SML module system, the other being a higher-order 
module system with applica­tive functors along the lines of O Caml, but abandoning the named form restriction 
as we do. Russo s two languages can be viewed as subsystems of ours, the .rst supporting only strong 
sealing, the sec­ond supporting only weak sealing. We adopt his use of existential signatures to address 
the avoidance problem, although Russo also used existentials to model generativity, which we do not. 
Russo s thesis also describes an extension to SML for packaging modules as .rst-class values. This extension 
is very similar to the existential­packaging approach discussed in the beginning of Section 5, and therefore 
suffers from the limitations of the closed-scope unpack­ing construct. While Russo de.ned these two languages 
separately, he imple­mented the higher-order module system as an experimental exten­sion to the Moscow 
ML compiler [26]. Combining the two lan­guages without distinguishing between static and dynamic effects 
has an unfortunate consequence. The Moscow ML higher-order module system places no restrictions on the 
body of an applicative functor; in particular, one can defeat the generativity of a generative functor 
by eta-expanding it into an applicative one. Exploiting this uncovers an unsoundness in the language 
[6], that, in retrospect, is clear from our analysis: one cannot convert a partial into a total functor. 
Shao [31] has proposed a single type system for modules supporting both applicative and generative functors. 
Roughly speaking, Shao s system may be viewed as a subsystem of ours based exclusively on strong sealing 
and dynamic effects, but supporting both . and .par signatures. As we observed in Section 3, this means 
that the bodies of applicative functors may not contain opaque substructures (such as datatype s). Shao 
s system, like ours, circumvents the avoid­ance problem (Section 4) by restricting functor application 
and pro­jection to pure arguments (which must be paths in his system), and by eliminating implicit subsumption, 
which amounts to requiring that let expressions be annotated, as in our system. It seems likely that 
our elaboration techniques could as well be applied to Shao s system to lift these restrictions, but 
at the expense of syntactic prin­cipal signatures. Shao also observes that fully transparent functors 
may be regarded as applicative; this is an instance of the general problem of recognizing benign effects, 
as described in Section 2. 7 Conclusion Type systems for .rst-order module systems are reasonably well 
understood. In contrast, previous work on type-theoretic, higher­order modules has left that .eld in 
a fragmented state, with various competing designs and no clear statement of the trade-offs (if any) 
between those designs. This state of the .eld has made it dif.cult to choose one design over another, 
and has left the erroneous im­pression of trade-offs that do not actually exist. For example, no previous 
design supports both (sound) generative and applicative functors with opaque subcomponents. Our language 
seeks to unify the .eld by providing a practical type system for higher-order modules that simultaneously 
supports the key functionality of preceding module systems. In the process we dispel some misconceptions, 
such as a trade-off between fully ex­pressive generative and applicative functors, thereby eliminating 
some dilemmas facing language designers. Nevertheless, there are several important issues in modular 
pro­gramming that go beyond the scope of our type theory. Chief among these are: Structure Sharing. 
The original version of Standard ML [22] included a notion of module equivalence that was sensitive to 
the dynamic, as well as static, parts of the module. Although such a notion would violate the phase distinction, 
it might be possible to formulate a variation of our system that takes ac­count of dynamic equivalence 
in some conservative fashion. It is possible to simulate structure sharing by having the elab­orator 
add an abstract type to each structure to serve as the compile-time name of that structure. However, 
this would be merely an elaboration convention, not an intrinsic account of structure sharing within 
type theory.  Recursive Modules. An important direction for future re­search is to integrate recursive 
modules [8, 5, 30] into the present framework. The chief dif.culty is to achieve prac­tical type checking 
in the presence of general recursively de­pendent signatures, or to isolate a practical sub-language 
that avoids these problems.  8 References [1] David R. Aspinall. Type Systems for Modular Programs 
and Speci.cations. PhD thesis, Edinburgh University, Edinburgh, Scotland, December 1997. [2] Luca Cardelli, 
Jim Donahue, Mick Jordan, Bill Kalso, and Greg Nelson. The Modula-3 type system. In Sixteenth ACM Symposium 
on Principles of Programming Languages, pages 202 212, Austin, TX, January 1989. [3] Luca Cardelli and 
Xavier Leroy. Abstract types and the dot notation. In M. Broy and C. B. Jones, editors, Proceedings IFIP 
TC2 working conference on programming concepts and methods, pages 479 504. North-Holland, 1990. Also 
avail­able as research report 56, DEC Systems Research Center. [4] Karl Crary. Sound and complete elimination 
of singleton kinds. In Third Workshop on Types in Compilation, vol­ume 2071 of Lecture Notes in Computer 
Science, pages 1 25. Springer-Verlag, September 2000. Extended version pub­lished as CMU technical report 
CMU-CS-00-104. [5] Karl Crary, Robert Harper, and Sidd Puri. What is a recur­sive module? In SIGPLAN 
99 Conference on Programming Language Design and Implementation (PLDI), pages 50 63, Atlanta, GA, 1999. 
ACM SIGPLAN. [6] Derek Dreyer. Moscow ML s higher-order modules are un­sound. Posted to the TYPES electronic 
forum, September 2002. [7] Derek Dreyer, Karl Crary, and Robert Harper. A type sys­tem for higher-order 
modules (expanded version). Techni­cal Report CMU-CS-02-122R, School of Computer Science, Carnegie Mellon 
University, December 2002. [8] Matthew Flatt and Matthias Felleisen. Units: Cool modules for HOT languages. 
In 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 236 248, Montreal, 
Canada, June 1998. [9] Giorgio Ghelli and Benjamin Pierce. Bounded existentials and minimal typing. Theoretical 
Computer Science, 193:75 96, 1998. [10] Warren D. Goldfarb. The undecidability of the second-order uni.cation 
problem. Theoretical Computer Science, 13:225 230, 1981. [11] Robert Harper and Mark Lillibridge. A type-theoretic 
ap­proach to higher-order modules with sharing. In Twenty-First ACM Symposium on Principles of Programming 
Languages, pages 123 137, Portland, OR, January 1994. [12] Robert Harper, John C. Mitchell, and Eugenio 
Moggi. Higher­order modules and the phase distinction. In Seventeenth ACM Symposium on Principles of 
Programming Languages, San Francisco, CA, January 1990. [13] Robert Harper and Chris Stone. A type-theoretic 
interpreta­tion of Standard ML. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, Proof, Language, 
and Interaction: Es­says in Honor of Robin Milner. MIT Press, 2000. [14] Xavier Leroy. Manifest types, 
modules, and separate compi­lation. In Proceedings of the Twenty-.rst Annual ACM Sym­posium on Principles 
of Programming Languages, Portland. ACM, January 1994. [15] Xavier Leroy. Applicative functors and fully 
transparent higher-order modules. In Conference Record of POPL 95: ACM SIGPLAN-SIGACT Symposium on Principles 
of Pro­gramming Languages, pages 142 153, San Francisco, CA, January 1995. [16] Xavier Leroy. A syntactic 
theory of type generativity and sharing. Journal of Functional Programming, 6(5):667 698, 1996. [17] 
Xavier Leroy. A modular module system. Journal of Func­tional Programming, 10(3):269 303, 2000. [18] 
Mark Lillibridge. Translucent Sums: A Foundation for Higher-Order Module Systems. PhD thesis, Carnegie 
Mellon University, Pittsburgh, PA, December 1996. [19] Barbara Liskov and John Guttag. Abstraction and 
Speci.ca­tion in Program Development. MIT Press, 1986. [20] David MacQueen. Using dependent types to 
express modu­lar structure. In Thirteenth ACM Symposium on Principles of Programming Languages, 1986. 
[21] David B. MacQueen and Mads Tofte. A semantics for higher­order functors. In Donald T. Sannella, 
editor, Programming Languages and Systems ESOP 94, volume 788 of Lecture Notes in Computer Science, 
pages 409 423. Springer-Verlag, 1994. [22] Robin Milner, Mads Tofte, and Robert Harper. The De.nition 
of Standard ML. MIT Press, 1990. [23] Robin Milner, Mads Tofte, Robert Harper, and David Mac-Queen. The 
De.nition of Standard ML (Revised). MIT Press, 1997. [24] John Mitchell, Sigurd Meldal, and Neel Madhav. 
An exten­sion of Standard ML modules with subtyping and inheritance. In Eighteenth ACM Symposium on Principles 
of Program­ming Languages, January 1991. [25] John C. Mitchell and Gordon D. Plotkin. Abstract types 
have existential type. ACM Transactions on Programming Lan­guages and Systems, 10(3):470 502, July 1988. 
[26] Moscow ML. http://www.dina.dk/~sestoft/mosml.html. [27] Objective Caml. http://www.ocaml.org. [28] 
Claudio V. Russo. Types for Modules. PhD thesis, Edinburgh University, Edinburgh, Scotland, 1998. LFCS 
Thesis ECS LFCS 98 389. [29] Claudio V. Russo. First-class structures for Standard ML. Nordic Journal 
of Computing, 7(4):348 374, 2000. [30] Claudio V. Russo. Recursive structures for Standard ML. In International 
Conference on Functional Programming, pages 50 61, Florence, Italy, September 2001. [31] Zhong Shao. 
Transparent modules with fully syntactic signa­tures. In International Conference on Functional Program­ming, 
pages 220 232, Paris, France, September 1999. [32] Christopher A. Stone. Singleton Kinds and Singleton 
Types. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, Au­gust 2000. [33] Christopher A. Stone 
and Robert Harper. Deciding type equivalence in a language with singleton kinds. In Twenty-Seventh ACM 
Symposium on Principles of Programming Lan­guages, pages 214 227, Boston, January 2000. [34] Niklaus 
Wirth. Programming in Modula-2. Texts and Mono­graphs in Computer Science. Springer-Verlag, 1983. A 
Type System Well-formed contexts: Gf ok Gf ssig s ..dom( G) f ok G,s:sf ok Well-formed types: Gf ttype 
GfP M : [[ T ]] G,s:sf ttype Gf Typ M type Gf .s:s.ttype ' '' Gf ttype Gf ttype Gf ssig '' Gf t'× ttype 
Gf(|s|) type Type equivalence: Gf t1 = t2 Gf [ t1] ~[ t2] : [[ T ]] 1 = s21 f t1 = t2 = Gf sG,s:s Gf 
t1 = t2 Gf .s:s1.t1 = .s:s2.t2 ' ' '''' Gf t1 = t2 Gf t1 = t2 Gf s1 = s2 ' '' ' '' Gf t1 × t1 = t2 × 
tGf(|s1|) = (|s2|) 2 Well-formed terms: Gf e : t Gf e : t' Gf t' = t Gf.M : [[ t]] Gf e : t Gf Val M 
: t Gf.M : sG,s:sf e : tGf ttype Gf.M : s Gf let s = M in ( e : t) : tGf pack M as (|s|) : (|s|)G, f 
:[ .s:s.t] ,s:sf e : tGf e : .s:s.tGfP M : s Gf .x f ( s:s) :t.e : .s:s.tGf eM : t[ M/s] ' '' : t'' '× 
t'' '× t'' Gf e ' : tGf e Gf e : tGf e : tGf(e ' ,e '') : t'× t'' Gf p1e : t' Gf p2e : t'' Well-formed 
signatures: Gf ssig Gf ttype Gf 1 sig Gf [[ T ]] sig Gf [[ t]] sig Gf ok Gf ok ' '' ' '' d''' ''' GfP 
M : [[ T ]] G,s:sf ssig G,s:sf ssig Gf .( M) sig Gf .s:s.ssig Gf Ss:s.ssig Signature equivalence: Gf 
s1 = s2 G~M2: [[ T ]] Gf ok Gf ok Gf t1 = t2 f M1 = Gf 1 = 1 Gf [[ T ]] = [[ T ]] Gf [[ t1 ]] = [[ t2]] 
Gf .( M1) = .( M2) ' ' ''''' ' ' ''''' Gf s2 = sG,s:s2 f s1 = sGf sG,s:s 1 21 = s21 f s1 = s2 d' '' d''' 
''' ''' Gf .s:s1.s1 = .s:s2.sGf Ss:s1.s1 = Ss:s2.s 2 2 Signature subtyping: Gf s1 = s2   Notes on 
Appendices Gf ok Gf ok Gf t1 = t2 Gf 1 = 1 Gf [[ T ]] = [[ T ]] Gf [[ t1]] = [[ t2 ]] Appendix A gives 
the type system for our module calculus. Ap­pendix B gives the module typechecking and principal signature 
~ GfP M : [[ T ]] Gf M1 = M2: [[ T ]] synthesis judgements that form the core of our typechecking algo­ 
Gf .( M) = [[ T ]] Gf .( M1) = .( M2) rithm. We omit the judgments for term typechecking (Gf e . t) ' 
' ''''' ''' and unique type synthesis (Gf e . t) for space reasons; they are Gf s2 = s1 G,s:s2 f s1 
= s2 G,s:s1 f s1 sig ( d2) . 1,d =( par,tot) fully detailed in the companion technical report [7]. d' 
'' d' '' Gf .1 s:s1.s1 = .2 s:s2.s 2 ' ' ''''' ''' Gf s1 = sG,s:s1 f s1 = sG,s:s2 f s2 sig 22 ''' ''' 
Gf Ss:s1.s1 = Ss:s2.s 2 Well-formed modules: Gf.M : s ' '' Gf ok Gf ok Gf ttype Gf e : tGf ttype G,s:sf.M 
: s.C D ' ''' GfP s : G( s) GfP () :1 GfP [ t] : [[ T]] GfP [ e : t] : [[ t]] Gf..s:s.M : .s:s.s ' '' 
''' ''' ' par''' ' G,s:sf.M : sG,s:sf ssig Gf.F : .s:s.sGfP M : sGf.F : .s:s.sGfP M : s' par' '' ''[ 
M/s] ''[ M/s] Gf.nD .s:s.M : .s:s.sGf.FM : sGf.US FM : s '' M'' : s'' ''' ''' Gf.M' : sG,s:sf.Gf.M : 
Ss:s.sGfP M : Ss:s.sGfP M : [[ T]] Gf.(s = M' ,M'') : Ss:s' .s'' Gf.p1M : s' GfP p2M : s''[ p1M/s] GfP 
M : .( M) ''' ' ' '' Gf.M : sGf.M : sG,s:sfP Ms : sGfP M : .s:s..GfP p1M : sGfP p2M : s ' '' '' Gf.UD 
( M:: s) : sGfW ( M:> s) : sGfP M : .s:s.sGfP M : s'× s ' ' Gf.M' : sG,s:s'f.M'' : sGf ssig Gf e : (|s|) 
Gf.' M : sGf s'= s.'C . Gf.let s = M' in ( M'' : s) : sGfS unpack e as s: sGf.M : s ~  Module equivalence: 
Gf M1 = M2: s ~~~Gf tGfP M : [[ T]] GfP M : sGf M2 = M1: sGf M1 = M2: sGf M2 = M3: s 1 = t2 Gf M ~M 
: sG~G~Gf [ t1] ~[ t2] : [[ T]] Gf [ Typ M] ~M : [[ T]] = f M1 = M2: s f M1 = M3: s == par' '' par' '' 
 GfP M1:1 GfP M2:1 GfP M1: [[ t]] GfP M2: [[ t]] GfP M1: .s:s.sGfP M2: .s:s.s ~~~par' '' Gf M1 = M2:1 
Gf M1 = M2: [[ t]] Gf M1 = M2: .s:s.s ''' '' Gf s2 G,s:s~~''' ~' 1 = s1 f M1 = M2: sGf F1 = F2: .s:s.sGf 
M1 = M2: s'~' ''' ~''[ M1/s] Gf .s:s1.M1 = .s:s2.M2: .s:s1.sGf F1M1 = F2M2: s~M'' 'f M'' ~M'' '' ''' 
''' Gf M' = G,s:s= ~~ 1 2: s1 2: sGf M1 = M2: Ss:s.sGf M1 = M2: Ss:s.sGf(s = M1' ,M1 '') ~(s = M2' ,M'' 
s:s' .s'' Gf p~p' Gf p~p''[ p = 2 ) : S1M1 = 1M2: s2M1 = 2M2: s1M1/s] 'f M1s ~~'~'' ''' ' G,s:s= M2s 
: sGfP M1: .s:s..1 GfP M2: .s:s..2 Gf p1M1 = p1M2: sGf p2M1 = p2M2: s Gf M1 ~= M2 : .s:s' .s'' GfP M' 
: s' G,s:s' fP M'' : sGf ssig Gf let s = M' in ( M'' : s) ~= M''[ M' /s] : s GfP M1 : .( M2) Gf M1 ~= 
M2 : .( M2) Gf M1 ~= M2 : s' × s'' Gf M1 ~= M2 : s' Gf s' = s Gf M1 ~= M2 : s B Typechecking Algorithm 
 Module typechecking: Gf.M . s ' Gf.M . sGf s'= s Gf.M . s Principal signature synthesis: Gf.M . s 
 Gf ok Gf ok Gf ttype Gf e . t G,s:s' f.M . s'' .C D GfP s . .G( s) ( s) GfP () . 1 GfP [ t] . .([ t]) 
GfP [ e : t] . [[ t]] Gf..s:s' .M . .s:s' .s'' G,s:s' f.M . s'' S C . Gf.F . .s:s' .s'' GfP M . s' Gf.F 
. .pars:s' .s'' GfP M . s' ' par' '' ''[ M/s] ''[ M/s] Gf.nD .s:s.M . .s:s.sGf.FM . sGf.US FM . s' 'fP 
M'' . s'' M'. s' 'f.M'' . s'' 'U .'' GfP M'. sG,s:sGf.' G,s:s'' ..= P GfP (s = M ' ,M ''). s'× s''[ M 
' /s] Gf.'U.'' (s = M ' ,M ''). Ss:s' .s'' ' '' '' Gf.M . Ss:s.sGfP M . s'× sGf.M . sGf.M . sGf e .(|s|)' 
'' Gf.p1M . sGfP p2M . sGf.UD M:: s. sGfW M:> s. sGfS unpack e as s. s ' '' '' GfP M'. sG,s:s'fP M'' 
. sGf ssig Gf.' M '. sG,s:sf.'' M '' . sGf ssig .'U ..= P GfP let s = M' in ( M'' : s) . .s( let s = 
M' in ( M'' : s)) Gf.'U.'' let s = M' in ( M'' : s) . s  
			

 Improved Approximation Algorithms for Rectangle Tiling and Packing Piotr Berman* Bhaskar DasGupta t 
 Abstract We provide improved approximation algorithms for several rectangle tiling and packing problems 
(RTILE, DRTILE and d-RPACK) studied in the literature. Our algorithms are highly efficient since their 
running times are near-linear in the sparse input size rather than in the domain size. In addition, we 
improve the best known approximation ratios, in some cases quite significantly. 1 Introduction We study 
several rectangle tiling and packing problems. These are natural combinatorial problems that arise in 
many applications in databases, parallel computing and image processing. We present new approximation 
algorithms for these problems. In contrast to the previously known results, we meet a crucial demand 
of most of these applications, namely, our algorithms work on sparse inputs and/or high dimensions very 
efficiently. In addition, our algorithms have better approximation bounds than known algorithms. Furthermore, 
the algorithms are simple to implement. In what follows, we will first formally define the problems before 
presenting our results. 1.1 The Rectangle Tiling and Packing Prob-lems We study the following two classes 
of problems. RTILE problem. Given a two dimensional array A 1 of size n x n containing non-negative integers 
2, partition "--"~artment of Computer Science, Pennsylvania State Uni- versity, University Park, PA 16802. 
Email: berman@csa.psu.edu. Supported in part by NSF grant CCR-9700053 and by NLM grant LM05110. tDepartment 
of Computer Science, Rutgers University, Cam- den, NJ 08102. Email: bhaakar@crab.rutgera.edu. Supported 
in part by NSF Grant CCR-9800086. tAT&#38; T Labs -Research, 180 Park Avenue, Florham Park, NJ 07932. 
Emaih muthuQresearch.att.com §Department of Computer Science, Rutgers University, Cam- den, NJ 08102. 
Email: rsuneeta~crab.rutgera.edu 1For the RTILE/DRTILE problems, we will use bold letters to denote arrays/rectangles, 
and respective regular letters to denote their weights. In particular, input array A has weight A, and 
Ri, the ith row of of a two-dimensional array A, has weight Ri. 2All our results will generalize to nl 
× n2 array. Henceforth, when we refer to arbitrary array A we imply one with non-negative integers. S. 
Muthukrishnan t Suneeta Ramaswami§ A into at most p rectangular tiles so that the maximum weight of any 
tile is minimized (a tile is any rectangular subarray, a partition of an array into tiles is one in which 
each element of the array falls in precisely one tile with the tiles being disjoint and the weight of 
a tile is the total sum of all elements that fall in it). Our emphasis is on the sparse version of the 
problem, that is, one in which the total number of nonzero entries in A is at most m which is likely 
to be smaller than n 2, the total entries in A. A natural variant of RTILE is its dual, referred to 
as the DRTILE problem, wherein we are given a bound w and required to minimize the number of tiles needed 
to partition the given array so that no tile has weight larger than w. Another natural variant is the 
straightforward extension of the RTILE/DRTILE problems to d-dimensions, where A is a d-dimensional array 
of size n x n x ..- x n and d-dimensional hyper- rectangles are considered in the tiling. d-RPACK problem. 
Given a set of p weighted d- dimensional, axis-parallel hyper-rectangles with end- points in {1, 2, 3,..., 
n} and a parameter k, find a collec- tion of at most k disjoint hyper-rectangles of maximum total weight. 
The set of all possible hyper-rectangles in d dimensions is n n(d), but p is likely to be significantly 
smaller, that is, the sparse case will be of our interest. The d-RPACK problem on a set of hyper-rectangles 
is equivalent to finding the maximum-weight indepen- dent set in the intersection graph of these hyper- 
rectangles, where there is an edge between two nodes representing two distinct hyper-rectangles if and 
only they intersect (this problem has been studied with an al- ternate definition of the interference 
graph in [BNl:t96]). The dual of the RPACK problem is to find the minimum cardinality subset of disjoint 
hyper-rectaagles with to- tal weight at least w, for some given weight-bound w. Since it is NP-hard to 
even find a feasible solution for this dual problem [FPTal], it cannot be approximated to within any 
factor. Hence, we do not consider this dual problem any further. 1.2 Motivating Applications Rectangle 
tiling and packing problems as defined above are natural combina- torial problems arising in many scenarios. 
For motiva- tion, we will very briefly review one example application scenario for each and leave others 
to be found in the ref- erences. Equisum Histograms in Databases. Databases such as DB2, SQLServer, Oracle, 
Sybase, Ingres etc. routinely keep histograms to optimize query execu-tion [K80]. These histograms attempt 
to capture the distribution of attribute values in the database, for ex- ample, the joint distribution 
of the frequency of at- tribute values (e.g., age, salary, savings, etc.); the goal is to do so using 
limited memory and reliable accuracy. While the study of histograms is fundamental in ar-eas such as 
Statistics, the use of multidimensional his- tograms in databases was initiated in [MD88], and has been 
intensely researched since then (see [P97] for a sur- vey). The RTILE problem is precisely that of construct- 
ing what is known as the Equisum histogram on 2 (more generally d) numerical attributes as defined in 
[MD88]. In this context, A is defined as follows: A[i,j] is 1 if there exist database records with attributes 
values i and j respectively (e.g., salary of 100K and savings 500K, respectively) and 0 otherwise; p, 
the number of tiles, represents the space allocated for the histogram; and w, the maximum weight of a 
tile, affects the accuracy of estimating the joint distribution. This gives the RTILE problem where A 
is a {0, 1}-array. More generally, we may let A[i, j] be the number of database records that have attribute 
value i and j respectively, and we would obtain the RTILE problem with non-negative integral elements. 
Both versions of the problem are of interest in selectivity estimation. (DRTILE problem is the dual of 
RTILE, which is equally interesting for building his- tograms.) | An important feature of this application 
is the spar- sity of the input. That is, A[i, j] is nonzero only for the combination of attribute values 
that are present in the database, which is typically significantly smaller than the set of all possible 
attribute value combinations. It is imperative to exploit sparseness in database applica- tions. RTILE 
and DRTILE problems, and their variants, are also of interest in other applications in load balanc- ing, 
database compression, data partitioning for parallel computers, image and video processing, etc. See 
discus- sion and references in [MPS99, KMP98]. Database Decision Support. Database mining sys- tems generate 
association rules --rules of the form C1 ---~C2, that is, if condition C1 is satisfied in the database, 
C2 follows. Correlation rules of this form need support and confidence to be tagged by database mining 
systems. For numeric attributes, the conditions on the left take the form of clusters (ranges), an anec- 
dotal example being: (Age E [25, 45]) N (Balance E [15K-40K]) --~ (CarLoan = Yes). (Here, there are two 
numeric attributes, namely, Age and Bal-ance. In general, there could be many other nu-meric attributes 
such as Mutual Fund Investments etc.) Study of such clustered association rules can be found in [FM+96a, 
FM+96b, RS99]. Database mining sys- tems can now generate the set of all such rules for a given database, 
given thresholds on confidence and sup- port, and tag each with a weight that shows their gain or value. 
Following that, database decision systems choose a subset of these rules for further development, such 
as marketing. A common formulation of this task is to choose k disjoint rules of largest total gain or 
value (for example, see [FM+96a, RS99] for formulation of this problem and extensive experimental study). 
This is precisely the d-RPACK problem where the d dimen- sions correspond to the numeric attributes. 
Besides the above application, the d-RPACK prob- lem arises in various resource allocation problems. 
It is also a natural combinatorial problem when viewed as the maximum-weight independent set problem 
on the corresponding intersection graph of the hyper-rectangles. In the motivating application above, 
the set of hyper-rectangles that is generated is typically much smaller than the set of all possible 
hyper-rectangles. The focus is therefore on the sparse input case. 1.3 Summary of Our Results and Related 
Re-search Since both the tiling and packing problems are known to be NP-Hard [FPT81, KMP98] in two or 
more dimensions 3, goal is to design approximation algorithms with guaranteed performance bounds. Naturally, 
our fo- cus is to design approximation algorithms with better performance ratios than previously known, 
but addi- tionally, our focus is to design such approximation algo- rithms whose time complexity is efficient 
as a function of the sparse input size (e.g., m+n in the RTILE and DR- TILE problems in two dimensions, 
p in the d-RPACK problem) rather than merely being efficient in the uni- verse size (i.e., n 2 and n 
d, respectively). None of the existing algorithms for these problems fully meet the latter goal. Table 
1 summarizes our main results and compares them with the previously best known results. 4 Note the following: 
Tiling Problems. Our algorithms for the RTILE/DRTILE problems take time linear in the 3The one dimensional 
versions of tiling and packing can be solved in polynomial time by dynamic programming. 4All logarithms 
are in base 2 unless the base is mentioned explicitly. Problem RTILE, A is {0, 1} RTILE DRTILE, A is 
{0, 1} DRTILE, d-dim d-RPACK Our results ratio time-O n+m 1% n+m n+m 2d-1 d(m + n) (L1+ l°gnJ) d-1 
dp log~ p +dn --~-~-~-- + pk log log n p (2=- 1)d-I'F1 k  (L1 + 2 2d 6 L1 + log nJ Previous best ratio 
time-O 9/4 n 2 + p log n % n 2 Table 1: Summary of our main results and comparisons with previous results. 
n 2 + plogn nl0 n d + pd2 a log n n2p +np 2 log n reference [KMP98] [$99] [KMP98] [KMP98] [$99, SS991 
[KMP98] d = 2 only For the RTILE/DRTILE problems, n is the size of each dimension, m is the number 
of non-zero entries in the array (m < n d for a d-dimensional array), and p = A/w. Unless otherwise noted 
A has arbitrary entries. For the d-RPACK problem, p is the total number of hyper-rectangles, n is the 
size of each dimension, k is the number of rectangles to be selected, and 0 < ~ _< 1 and c > 1 are any 
two constants. sparse input size, that is O(m + n) time, and are simple to implement. Packing Problems. 
The (L 1 + lognJ) d-I- approximation algorithm for packing problem takes time almost linear in sparse 
input size (in p). No results were previously known for the d dimensional case; straightforward extension 
of the known result for the two dimensional case [KMP98] would be an ~(log 2d-1 n) approximation taking 
time n n(d). Hence, our result is a substantial improvement. We can further improve the approximation 
ratio of our algorithm at the expense of running time as shown in the table above. This complicates the 
algorithm but it is theoretically interesting that the log n bar- rier does not hold. 1.4 Brief Technical 
Overview of Results Tiling Problems. While previous algorithms used the concept of "thick cuts" or "medium 
cuts" and adopted a divide-and-conquer approach, we adopt a "sweep" based technique and develop the concept 
of "good rectangles" in the array, i.e., those rectangles whose total weight is at least g (for some 
parameter g carefully chosen to justify the approximation bounds) and combine these rectangles, whenever 
necessary, in a local manner. The benefit is that while thick or medium cuts are somewhat expensive to 
find, good rectangles can be found quite simply by sweeping through the input and combining them is also 
algorithmically easy. Thus our algorithms have efficient implementation in the sparse input size as applications 
demand. Somewhat surprisingly, such simple approaches in fact yield improved approximation ratios. The 
improvement in the approximation ratio for the DRTILE problem in d dimensions over the preyi- ously best 
known algorithm uses an alternative lower bound in addition to the usual lower bound considered in [KMP98, 
$99, SS99l. The two lower bounds together lead to an improved analysis of the performance ratio. Packing 
problem. The ([log(n + 1)]) d-I- approximation algorithm that we present uses a divide- and-conquer technique. 
The exact solution at each level is found by "translating" the rectangles in the subprob- lems at each 
node in the level so that their "lower dimen- sional projections" do not interfere. For the improved 
result with approximation ratio ([1 + we do this at several consecutive levels of the divide-and- conquer 
simultaneously. As a result, the algorithm be- comes more involved. 1.5 The Map In Section 2, we present 
some neces- sary definitions. Our approximation algorithms for the RTILE and DRTILE problems are in Section 
3. Sec-tion 4 contains our results on d-RPACK problem. Con- cluding remarks are in Section 5. Due to 
space limita- tions many proofs are omitted. 2 Definitions and Preliminaries Unless otherwise stated, 
all rectangles are axis-parallel and all weights axe non-negative. A d-dimensional hyper-rectangle is 
[Xll, X12] X [X21, X22] X''" X [Xdl , Xd2 ] = ×id=l [xil, xi2], where each [Xil, xi2] is an interval 
on the real line and × denotes the Cartesian product. A 2- dimensional hyper-rectangle is simply called 
a rectangle. Two d-dimensional hyper-rectangles xid=l[x~l,x~2] and ×id=l[Yil, Yi2] intersect if and only 
if [Xil, xi2]N[yil, Yi2] q} for every i. An array is called a {0, 1}-array if all of its entries are 
either 0 or 1; otherwise it is called a general or arbitrary array. A partition of an array A is a collection 
of (axis-parallel) rectangles (also referred to as tiles) that cover A without overlap. The weight of 
a rectangle in a partition of A is the sum of all array elements covered by the rectangle. If a given 
n x n array is sparse, containing m non-zero entries (n _< m < n2), then it can be efficiently represented 
in O(m + n) space using the standard representation as an array of row lists; the list of the i th row 
contains an entry of the form (j, x) for every positive array entry A[i,j] = x and the row lists are 
sorted by the column numbers of the entries. A similar standard sparse representation can be used for 
a d-dimensional array A : a non-zero entry A[Q, i2,..., id] is represented by a (d + 1)-tuple (Q,is,..., 
id ; A[Q, i2,..., id]) and the tuples are lexicographically sorted in their first d coordinates. Hence, 
we assume that our sparse matrices are represented this way. Approximating the Tiling Problem First, 
we describe a general slicing technique that is used many of our algorithms for RTILE and DRTILE problems. 
We then focus on the RTILE and DRTILE problems on {0, 1}-arrays and later consider these prob- lems on 
general arrays. Slicing Arrays. The goal of many of our algorithms is to divide the input array A into 
good rectangles, which will mean rectangles that have weight at most g. Selection of g will depend on 
the particular algorithm. Our algorithms have a common beginning: first, the value of g is established, 
and then the given array A is divided into slices according to the weight limit g. The general scheme 
for the slicing algorithm is shown below. For j < I the rows from Rt[j-1]+l to Rt~] form the jth slice, 
denoted Sj. The rows with numbers larger than t[l - 1] form the remainder slice, Sl. For j < l, we define 
the top of the slice Sj as Tj = Rtj. The other rows of this slice form its base, Bj. t[ol ,- 0; j ~-- 
1; slice_weight ~--0; fori4-1 tondo slice_weight ~-- slice_weight + Ri; if slice_weight > g then t[j] 
~ i; j~--j+l; slice_weight ~-0; l~j LEMMA 3.1. If the input array A has 0 and 1 entries only, we can 
partition it into [2A/g] good rectangles in O(n + m) time. Proof. We can partition A into slices and 
compute all Ri's, Sj's, Tj's and Bj's in time O(n + m). Note that the remainder slice is good and the 
other slices are not. It suffices, for j < l, to divide slice Sj into aj < 2Silt good rectangles. We 
consider three cases. Case 1: Tj <_ g. In this case both Tj and Bj, the top and the base of Sj are good, 
so they form our partition into rectangles. Note that Sj > g, and thus aj = 2 < 2Sj/g. Case 2: Tj > g 
and 2Silt <_ 3. This implies that Bj < g/2. Assume that the first k entries of Tj contain g -Bj l's. 
Then the rectangle formed from the first k columns of Sj must be good, because its weight is at most 
(g -Bj) + Bj. The remaining part of Sj is also good, because its weight is at most Sj -(g -Bj) < -g/2 
< g. Case 3: 2Sj/g > 3. We partition Sj into Bj and a partition of Tj in which all rectangles, with the 
possible exception of the last one, have weight equal to g. If this partition contains 3 rectangles, 
then we clearly satisfy aj < 2Sj/g. If it contains aj _> 4 rectangles, then we have Sj > (aj -2)g > ajg/2, 
and thus aj < 2Silt. Note that after the initial computation of the slices we perform only the linear 
scans of the slice tops, and this can be done in linear time. Q The RTILE and DRTILE Problems on {0, 
1}- arrays. Using Lemma 3.1, we can prove the following result 5 . THEOREM 3.1. The RTILE and DRTILE 
problems on a {0, 1}-array can be approximated to within a factor of 2 in O(n + m) time. Proof. First, 
we prove the result for the RTILE problem. Assume that a given 0-1 array A can be partitioned into p 
rectangles, each of weight at most w. We apply the algorithm of Lemma 3.1 for g = [2A/p] which yields 
a partition of A into at most [2A/g] _< 2A/(2A/p) = p good rectangles. Because g _< 2 [A/p] < 2w, our 
approximation ratio equals 2. Next, we prove the result for the DRTILE prob- lem. With the same assumption 
as before, apply the algorithm of Lemma 3.1 for g = w. This yields a par- tition of A into q < [2A/w] 
good rectangles. Because pw >_ A, we get p > [A/w] >_ t/2 [2A/w] > 1/2q. aWe recently learnt that this 
theorem was also proved inde- pendently in a very recent paper [LP00, Theorems 2 and 3]. The I:tTILE 
and DI:tTILE Problems on Arbitrary Arrays. Using the slicing technique above with a novel method of combining 
slices and using more elaborate accounting of the number of rectangles used, we can show the following 
result (the proof refers to the slicing notation above). THEOREM 3.2. The RTILE problem on arbitrary 
arrays can be approximated to within a factor of 11/~ in O(n + m) time. Proof, Assume that the input 
array A can be partitioned into p rectangles of weight at most w. Our goal is to find a partition into 
p rectangles of weights at most 1lAw. Suppose that x = W/p and y is the largest entry of A. To avoid 
dealing with fractions, we rescale the entries of A so that 5 = max(x, y). It is clear that after the 
rescaling we have w > 5. In the remaining part of this section, we will assume than no array entry exceeds 
5, and that a rectangle is good if its weight does not exceed 11. Therefore it suffices to find a partition 
of A into at most [A/5] good rectangles, or, equivalently, a partition into q good rectangles where 5q 
- A < 5. We will partition each slice separately. If Sj is partitioned into aj good rectangles, we say 
that Sj has the deficit of dj = 5aj -Sj. We need to partition slices in such a way that the sum of their 
deficits is smaller than 5. LEMMA 3.2. Assume that Tj < 6b + 5 for some positive integer b. Then we can 
partition Tj into b good rectangles. Proof, By induction on b. If b = 1, then Tj < 11 and the claim is 
obvious. Otherwise, find the longest initial good part of row Tj. Note that the weight of this part exceeds 
6, otherwise we would extend it by one more term, thus increasing its weight to at most 6 + 5. The remaining 
part of Tj has weight at most (b - 1)6 + 5 and by the inductive hypothesis we can partition it into b 
- 1 good parts. El LEMMA 3.3. Assume that Tj = 6b + 5 + y for an integer b > 2 and a real y < 5. Then 
we can partition Tj either into b good rectangles, or into b + 1 rectangles of weight at most 6 + y. 
Proof. By induction on b. If b = 2, find the longest initial good part of Tj. If its weight is at least 
6 + y, then the remaining part of Tj has weight at most 2× 6+5+y-(6+y) = 11, and we succeeded to partition 
Tj into 2 good rectangles. If this weight is lower than 6 + y, try the same with the longest final good 
part of Tj. If we fail both times, then both parts of Tj that we have obtained have weights between 6 
and 6 + y. Consequently, the remaining middle part has the weight of at most 5 + y. For the inductive 
step, find the longest initial good part of Tj. If its weights is at least 6 + y, then the remaining 
part of Tj can be partitioned into b -1 good parts by Lemma 3.2. Otherwise, its weight is between 6 and 
6 + y and the weight of the remaining part of Tj is at most 6(b - 1) + 5 + y, so it can be partitioned 
in the desired fashion by the inductive hypothesis. Q LEMMA 3.4. If Sj _> 16 then we can partition the 
jth slice with the deficit dj < -1. Proof. We have Sj = 6a -2 + x for some integer a > 3 and a real x, 
0 LS x < 6. By partitioning Sj into a good rectangles we will obtain the deficit of 5a-(6a-2 + x) = 2-a-x 
_< -1. IfTj _< 6a-1 then for b = a-1 we haveTj < 6(b + 1) - 1 = 6b + 5. Using Lemma 3.2 we partition 
Tj into a -1 good rectangles, and Bj provides the a th good rectangle. In the remaining ease we have 
a real y such that 0 < y < 5, T3 = 6a-l+y, andBj = S¢-Tj = 6a-2 +x-(6a-l +y) =x-y-1. Forb=a-lwe have 
Tj = 6b+5+y, thus we can partition Tj according to Lemma 3.3. If this partition contains a -1 good rectangles, 
we can add Bj as the a th good rectangle. If this partition contains a rectangles, each with weight at 
most 6+y, then we can extend these rectangles vertically cover Bj. The weight of an extended rectangle 
is at most 6+y+Bj = 6+y+x-y-1 = 5+x < 11, hence each extended rectangle is good. Q LEMMA 3.5. If Tj < 
11 then we can partition Sj with the deficit d~ _< -1. Proof. We partition Sj into Tj and Bj. Bj is 
good in every slice, and Tj is good by the assumption. The deficit is dj = 10 - Sj < -1. Q Now we will 
provide an algorithm that runs in time O(n + m) that finds a partition of A into at most rA/5] arrays 
of weight at most 11. We partition the input array into slices. The slices satisfying the assumption 
of Lemma 3.4 or Lemma 3.5 are partitioned into good rectangles with the deficit of -1 or less. Below 
we describe how to handle the remaining slices. If Tj > 11 and Sj < 16, we make C D E a preliminary partition 
of S~ into six rectangles. First, we partition Tj into F G H three rectangles, from left to right C, 
D and E, so that the middle rectangle D consists of one entry only, while C < Tj/2 and E _< Tj/2. Next, 
we partition Bj into F, G and H so that these rectangles align as shown above. Before we proceed, we 
need to observe that rectan- gle C U F is good, and that by a symmetric argument, EUH is good as well. 
Indeed, C + F < Sj -(D + E) < s# -%/2 < x6 -11/2 = 101/2. Easy Case: Sj -C -F is good, or Sj -E -H is 
good. We partition S# into two good rectangles. Because Sj > 11, we have deficit d i < -1. Hard Case: 
The easy case does not apply. We will show in a moment that D U G is good, so we can partition Sj into 
three good rectangles. In this case the deficit dj = 15 -S i can be positive, so we may be forced to 
change this initial partition. Therefore we must characterize the weights of the six rectangles that 
are possible in the hard case. Because the easy case does not apply, we can conclude that 22 < (Sj-C-F)+(Sj-E-H) 
= (D+E+G+H)+(C+D+F+G) = Sj +D+G _< Sj+ +B < %+s+(%-n) ~. 28 < 2S i =_ Si > 14  Therefore in the hard 
case we have Sj = 14 + x for some 0 < x < 2, and the deficit is dj = 1 -x, -l<dj <1. We can also show 
that in hard case the following statements are true: (a) Bj=F+G+H<3+x; (b) C+F <3+xandE+H <3+x; (e) 
F<2xandH<2x. Inequality (a) follows from Bj = S -j -Tj = 14+ x- Tj < 14+x- 11.  Inequality (b) follows 
from Sj-C-F > 11 (because the easy case does not apply) and thus C+F < Sj -11 = 3+x. Suppose that (c) 
does not hold, w.l.o.g F > 2x; this and (a) implies G < 3 -x, thus Sj -C -F = (C+F)+D+G< (3+x)+5+(3-x)=11, 
which means that Sj -C-F is good and the easy case applies. By substituting 1 - d i for x, we can rewrite 
(a-c) as follows: (a) Bi = F +G+ H < 4-d fi (b) C + F < 4 - dj and E + H < 4 - dj; (c) F<2-2dj andH<2-2d 
i.  Now for j = 1 .... , ! - 1 we consider the accumu-lated deficit Aj = ~=1 dk. Our goal is to keep 
Aj small, even though some terms in this sum, those that correspond to the hard cases, may be positive. 
Consider the smallest j such that Aj _> 1. Because each deficit is lower than 1, this implies that dj 
> 0 and dj+di_l > O. Our strategy is that whenever Aj >_ 1, we partition again S j_ x u S j, this time 
into 5 rectangles rather than 6. This repartition subtracts 5 from the accumulated deficit, so it drops 
below -3. This way we never let Aj stay above 1 for j < I. To finish, we will need to account separately 
for the remainder slice St that can have larger deficit than 1. In accounting for the remainder slice 
Sl, consider frst the case when the slice St-1 is not an example of the hard case. Then At-1 = At-2 + 
dl-1 < 1 - 1 = 0, hence At < dt < 5. In turn, if St-1 is an example of the hard case, then we can partition 
it into CUF, a rectangle of weight at most 4- dr-1 < 5, Et3 H, a rectangle with the same weight estimate, 
and D D G, a rectangle with of weight at most 5 + 4 -dr-1 < 10. If St _< 1, then we can extend these 
three rectangles vertically up to cover St; if St >l, thendt<4andAt<l+4=5. To finish the proof, we return 
to the case where we need to partition Sj-x U Sj again. Because 0 < dj < 1 and dj-1 > -dj, both slices 
in question are examples of the hard case. We partition Sj into C, D etc., and Sj-I into C', D' etc. 
We must ! C D E C D E have one of: the configura- F G H F G H tions shown here~ or a symmet- C' I D i 
E' C' D' E' ric one. In the F' G' H' F I G I H' left configura- tion, we can use four arrays, the left 
columns of four arrays forms one, the right column another, while the remaining ones are D U G and D' 
U G'. The weights of these arrays can be estimated as follows: C+F+C'+F' < 4-dj+4-di_l = 8-(di+d~_l ) 
< 8; E + H + E' + H' < 8 by a symmetric argument; D+G <5+Bj = 5+4-d¢ <9; D' +G' < 5 + Bj-1 = 5 +4-dj_l 
< 10.  In the right configuration we can use five arrays. The first is Bj-1. The second is CUD of weight 
at most 4 - dj + 5 = 9 + dj < 9. The third is E. The fourth is C' extended upwards, to contain F, G and 
a fragment of H; its weight is at most 4-dj_l+Bj <_ 8- (di_l+di) < 8. The last one is D' U E' extended 
upwards to contain the remaining fragment of H; its weight is at most 5+4-dj_l+2-2d i = ll-(dj_l+d i)-dj 
< 11. This completes the proof of Theorem 3.2. Q Next, we turn our attention to the DRTILE problem in 
d-dimensions. Using slicing techniques, and combi- nation of two lower bounds, we can prove the following 
result. THEOREM 3.3. The DRTILE problem on arbitrary arrays in d dimensions (d > 1) can be approximated 
to within a factor of 2d - 1 in O(d(m + n)) time. Proof. For simplicity of notation, we will assume, 
without loss of generality, that w = 1 (if the weight limit is different, we simply rescale the entries). 
This implies that every entry of A is between 0 and 1. We refer to this condition as A being 1-bounded. 
For convenience, we define a 0-dimensional array to consist of a single entry. Let k* be the minimum 
number of rectangles in a partition of the input array A of total weight A such that each rectangle has 
weight no more than 1. For d = 0 our algorithm returns the input array. For dimension d > 0, our algorithm 
uses the algorithm for dimension d - 1. Assume that B is a d-dimensional array where the the i th index 
ranges between 1 and ni. The projection of B is the (d - 1)-dimensional array B defined by the equation 
below: nd bil,...,~d-1 = Z bil,...,id--l,id id=l The d-dimensional algorithm can be described briefly 
as follows: 1. We find the largest index kl _< nd such that the array A1 formed from the entries of A 
with id E (k0 = 0, ks] satisfies the condition that A--~ is 1- bounded; if kl <nd, we find the largest 
k2 _< nd such that the array A2 formed from entries of A with id E (kl, k2] satisfies the condition that 
~ is 1-bounded, etc. In this way we partition A into s slices A1,..., As. 2. For 1 < r < s apply the 
(d-1)-dimensional algorithm to At, the projection of the r th slice. 3. For 1 < r < s replace each slice 
B from the partition of Ar with B = B x [kr-1 + 1,..., kr].  LEMMA 3.6. In the notation of the above 
algorithm, no partition of A into tiles of weight at most 1 has fewer than s tiles. Proof. For 1 <_ r 
< s we can find an index vector Lr such that the entry of Ar with indexed with t~ would exceed 1 if we 
would extend the range of the last index in A~ from (kr-1, k~+l] to (k~-l, kr+l + 1] (this follows from 
way the algorithm defines kr's). Define ~s as an arbitrary index vector from the proper range. Now we 
define br to be the entry of A with index vector (tr, kr-1 + 1). It is easy to see that no two b~'s can 
belong to the same tile. [] LEMMA 3.7. If the algorithm produces a partition of A into t tiles, then 
the weight of A satisfies 2dA > t-1. Proof. By induction on d. For d = 0 the claim is trivial, so it 
suffices to prove the inductive step. Assume that the r th slice was partitioned into tr tiles. By applying 
the inductive hypothesis to the projections of the slices of A we obtain 8 8 1)A = 2(d-1) _> (tr -1) 
= t-s r=l r-1 On the other hand, the sum of weights of every consecu- tive pair of slices exceeds 1; 
otherwise the projection of their union would be 1-bounded, a contradiction. Thus 2A>s-1 We obtain the 
claim by adding these two inequalities. [] Now, we obtained the following inequalities: t- s _< 2(d- 
1)A < 2(d- 1)k* and s < k*. The approximation bound of our theorem follows form adding these two inequalities 
together. Now we prove the time-complexity of our algo-rithm. Since after Step 1 the projections of differ- 
ent slices are disjoint, it suffices to show how to find the indices kl, k2,..., ks and the projections 
of all the slices in O(m + n) time, assuming that A is given in its standard sparse representation as 
described in Sec- tion 2. For each index j in the d th dimension of A (1 < j < rid) , let Lj be the list 
(in any arbitrary or- der) of tuples (i1,i2,...,id-l,j; A[il,i2,...,id-l,j]). The lists L1, Lu,...,Ln 
can be computed in a total O(n + m) time simply by traversing each of the m (d + 1)-tuples of A and inserting 
these tuples in the appropriate Lj based on their d th coordinate. Since the (d + 1)-tuples of A are 
given in a lexicographi-cally sorted order on their first d coordinates, it is easy to find in O(m) time 
the at most m (d-1)-tuples (Q,i2,...,Q-1), where for every such tuple there is some j and x such that 
(Q,i2,...,id-l,j ; x) is a (d + 1)-tuple of A. Next, we maintain an m-element array B corresponding to 
these at most m (d-1)-tuples. Initially, B[(il, i2,..., id-1)] = 0 for every tuple (Q, i2,..., id-1). 
We examine the lists L1, L2, L3,.  in order and for each entry (Q,i2 .... ,id-l,j ; x) in Lj, we increment 
B[(Q, i2,..., id-1)] by x. We stop as soon as we arrive at an index j such that, after the appro- priate 
Lj has been processed, B[(is,i2,...,id-1)] > 1 for some (i1,i2,..-,id-1). Then, kl is j -1. We reset 
B[(il, i2,..., id-1)] = 0 for all i and continue the same procedure starting from list Lj. This takes 
a total of O(n + m) time. It is easy to compute the projections of each slice also within the same time 
bound. This completes the proof of Theorem 3.3. Q Approximating d-RPACK In this section we first give 
a simple, efficient approxi- mation algorithm for d-RPACK with approximation ra- tio [log(n + 1)] a-a, 
and then show how to further im- prove the performance ratio of the algorithm at the ex- pense of increasing 
the running time. We consider a slightly more general version of the d-RPACK prob- lem where D1,D2,...,Dp 
are the p weighted hyper- d "" e" rectangles, with Di = xj=l[b,j, ,j] having its end- points b~,j, eij 
{1, 2,..., nj}, that is, jth dimension of the hyper-rectangles has its own range {1, 2,..., nj}. We assume, 
without loss of generality, that p = gt(nl). 4.1 ([1 + log hi)d-a-approximation algorithm for d-RPACK 
For a d-dimensional hyper-rectangle Di, let Di --k ot denote the d-dimensional hyper-rectangle xff=l[bi 
J + a, eid + a] and D[ f~ denote the (d -j3)- d-fir b dimensional hyper-rectangle x j= a t ij, eij] 
for 0 < j3 < d. Extend these notations to an arbitrary set X of d-dimensional hyper-rectangles by defining 
X + c~ = {x+alx X} and X -~ = {x-f31x X}. For a set of hyper-rectangles X, let IXI denote the number 
of hyper-rectangles in X. THEOREM 4.1. The general version of the d-RPA CK aproblem can be approximated 
to within a fac- tor of [L=2(L1 + logniJ) of the optimum in O(p(d - --~d 1o 6 nl 1)logep + 2..~=2niloglogn, 
+ pk) = O(dploge p + d log n i ~i=1 niloglogni + pk) time (for any 0 < e < 1). Setting ni = n for all 
i in Theorem 4.1, we obtain: COROLLARY 4.1. The d-RPACK problem can be approximated to within a factor 
of ([1 +lognJ) d-1 of the optimum in O(dplog" p + nlo~l~o~n + pk) time (for any 0 < e <_ 1). Proof-sketch 
of Theorem 4.1. We note that the 1-RPACK problem, which we call as the Interval Pack- ing (IPACK) problem, 
is easily solvable in O(pk) time via dynamic programming technique 6. For notational convenience, let 
q = L1 + log ndJ. We prove the result by induction on d. For d = 1, the result follows di- rectly via 
solution of IPACK. Inductively, assume that we have an algorithm for (d - 1)-RPACK and consider the d-RAPCK 
problem on the set of hyper-rectangles R. We divide R, in O(plogep + ndlo~io~na ) time, into at most 
q disjoint collections R1, R2,..., Rq such that an optimum solution of the d-RPACK problem on each Ri 
is also an optimum solution of the (d - 1)-RPACK problem on R~ -1. By inductive hypothesis, we approx- 
imate the (d -1)-RPACK problem on each R~ -1 sepa- d-1 rately within a factor of lrIi=2 ([1 + log n/j) 
of the op- °Since the endpoints of the p intervals are in {1, 2,..., nl }, they can be sorted in O(p 
+ nl) = O(p) time timum for each R~-I. By pigeonhole principle, the best d-1of all these solutions is 
within a factor of q [L=2 ([1 + logni]) = lyI~d=2([1 + logn~J) of the optimum solution, and the total 
time taken is 0(~= 1 IRi[(d-2) log ~ IRd + d-X n. 1°6n~ IRi]k plog E + nd ---~---) = Ei=2 ~ log log nl 
+ + P log log nd 0 (p(d -1) log e p + ~=2- us logl°glogn±ni +pk) = 0 (dp log ~ p + ~ a n~ + pk) time. 
7 = g g . Here are the ideas behind how to find these sets Ri, R2,..., Rq. For a set X of d-dimensional 
hyper- rectangles and a number a, let us define the following subsets of X: d Int(a,X) = {fir = Xj=l[bj,ej] 
e X, bd _< a _~ed} d Above(a, X) = {rlr = xj=l[bj, ej] X, a < bd} Below(a, X) = {rlr = xj=a[bj, ej] 
 X, ed < a} d To build the sets R1, R2,...,Rq, we will first divide the given set of p rectangles into 
n disjoint groups $1, $2, ., She (some of which may be empty), and com- bine these groups to get Rh..., 
Rq. For clarity, when necessary we will indicate a set St as St(it, it) to empha- size that endpoints 
of any hyper-rectangle x~= 1 [bj, ej] E St(it,jt) satisfy bd, ed E {it,it + 1,...,jt}. Each set Si also 
has a state, which can be varying meaning that the content of Si may be subject to further modifications, 
or fixed meaning that the content of Si will not be subject to any further modification. Modification 
of the content of a set will also be termed as refining the set. We start by setting Sl(1,nd) = R, $2 
= $3 ..... Sn = 0, and setting the state of each set Si as varying. Next, we refine the set $1, $2 and 
$3 by setting Sl(1,nd) = Int([(nd .-}- 1)/2], SI(I, ~d)), S2(I, [(nd --{- 1)/2] --1) = Below([(rid + 
1)/2], Sl(1,nd)) and S3([(nd q- 1)/2] + 1, rid) = Above( [ (nd + l ) /2] , $1(1, nd) ), and set the state 
of Sl(1, rid) as fixed. It is shown in the full version of the paper that the d-RPACK problem on $1 is 
precisely the (d - 1)-RPACK problem on Si -1. We iteratively refine 32(1, [(nd + 1)/2] --1) and S3([(nd 
q- 1)/2] + 1,rid) in a similar manner; complete details are available in the full version of the paper. 
Q 4.2 Further Improved Approximation Ratio for d-RPACK THEOREM 4.2. For every L > 2, the general ver- 
sion of the d-RPACdK problem can be approximated to within a factor of H~=2 ( [1 + log L niJ) of the 
optimum in O(p (L-1)d-l+l k) time. ~Here, we use the simple fact that when we reach the 1-RPACK problems 
at the base level of recursion, all the endpoints of p intervals divided into at most min{p, I-If=a([1 
+ logniJ)} groups can be sorted together in O(p) time. Proof. In the following discussions, each rectangle 
r has the following attributes: weight w(r) and, for coordinate i [1,d], starting and terminating values 
si(r) and ti(r). Such a rectangle is a set of integer vectors x~= 1 [si(r), t~(r)]. The objective again 
is to find a subset S of the set of given rectangles such that its elements are pairwise disjoint, ISI 
<_ k and its total weight, ~res w(r) is maximum. To formulate our approximation algorithm, we will first 
define a very special subproblem which has a polynomial time solution. An instance of d-RPACK is A-restricted 
if A C x id=2 [1, n~] and each given rectangle intersects the set [1, nl] x A. We will show an exact 
algorithm for A-restricted d-RPACK that runs in time O(plAl+lk). We first order the given rectangles 
in such a way that if r ~ r' then sl(r) < sl(r'). Consider a legal solution S--the rectangles in S are 
disjoint and ISI < k. We define the jth element of S to be r S such that I{r' S : r' :< r}[ = j. Next, 
if r is the jth element of S than the jth cut of S is the following subset: {r' S: r' ~ r A tl(r') > 
sl(r)}. If j = IS], then the jth element of S is the terminal element of S. We define the terminal cut 
of S similarly. LEMMA 4.1. If S iS a legal solution with at least j elements, then the jth cut of S has 
at most IAI elements. Proof. Let us order the set A. The first a A such that r N [1, nl] x {a} ~ O will 
be denoted a(r). Because our input is A restricted, a(r) is defined for every input rectangle. Now assume 
that r is the jth element of S, s = sl (r) and T is the jth cut of S. Consider r ~ T. Because r' < r 
we have sl(r') _< s. Because r t T, we have tl(r') >_ s. Thus s [sl(r'),tl(r')]. Now consider r', r" 
 T such that a(r') = a(r") = a. Then s x a r' A r". Because rectangles in T are disjoint, we can conclude 
that r' = r". Thus 1--1 a: T , A which shows that ITI _< [A I. Q LEMMA 4.2. Assume that S is a legal 
solution, [SI < k, r is the terminal element of S and r -< r'. Then S U {r'} is a legal solution if and 
only if r ~ does not intersect any rectangles from the terminal cut of S. Proof. Let T be the terminal 
cut of S. It suffices to show that r' does not intersect any rectangles from S-T. Because every rectangle 
in S precedes r, r" S -T only if tl(r") < sl(r). Because r -< r', 81(r) _< sl(rl). Thus tl(r") < sl(r'), 
which implies that r t N r" = 0. Q Now we can define a plausible jth CUt of a legal solution as a set 
of rectangles C such that ICI < j and C is its own terminal cut. We also say that O is a plausible 0 
th cut of a legal solution. We define of nodes to be pairs (j, S) such that S is a plausible jth cut 
of a legal solution. A pair ((j, S), (j + 1, S')) forms an edge if it is plausible that for some legal 
solution S is the jth cut and S' is the (j+l) st cut. More formally, S is a plausible jth cut, for every 
r E S we have r -4 r' and S ' is the terminal cut of St./{r'}. The weight of this edge is equal to w(r'). 
One can see that there is 1-1 correspondence between legal solutions and the paths in this graph that 
start at (0, ~D). The optimum solution corresponds to the longest path. Because this is an acyclic graph, 
we can find the longest path in time proportional to the number of edges. It is easy to see that we have 
less than plAI/[A[! x k nodes, and that out-degree of a node is lower than p. This finishes the sketch 
and analysis of the exact algorithm for A-restricted d-RPACK. 1 Our approximation algorithm has the following 
d idea. We partition the input set into [Ii=2 [1 + log L niJ subsets, and then we find an exact solution 
for each subset. We start from partitioning the range [1,ni] into [1 + log L ni] subsets. We say that 
the jth lattice is the set of integers that are divisible by L/ but are not divisible by L j+l. Next, 
we say that an interval [s, t] is of class j if it contains numbers from the jth lattice, but it does 
not contain any number from (j + 1) st lattice. In such a case we write class(s, t) = j. It is easy to 
see that class(s, t) < log L t. We partition our input set of rectangle into equiva- lence classes of 
the following relation: r ~ r' if an only if h~=2 class(s,(r), t,(r) ) = class(s,(r'), tc(r') ). Because 
ti(r) _< ni, there are at most x~a=2L1 + logLni j many classes. It remains to show how to reduce the 
problem of finding an optimum solution for a single class. Consider a class C such that r e C ~ A~=2class(si(r),t,(r)) 
= ji. First we find the connected components of C in re- spect to r N r' ~ O. Observe for each component 
D, and r, r' E D the following holds for i E [2, d] [s,(r), t,(r)] N [s,(r'), t,(r)] = 0 [si(r) rood 
L/'+1, ti(r) rood L j'+l] n[si(r') rood/.,/,+1, ti(r) rood/.),+1] Therefore the problems remains equivalent 
if we trans- form every rectangle using rood operations as describe above, and then translate each component 
along xl axis to assure that the rectangles from different components are still disjoint. We define A~ 
= {aL i' : a e [1,L-1]}. After the last transformation set D becomes A-restricted for A = x~d=2A~. 121 
Setting L = 2 c and nj = n for all j, we obtain: COROLLARY 4.2. For every c > 1, there is an approximation 
algorithm for d-RPACK that runs in O(p (2c-1)d-l+l k) time with an approximation ratio of The fastest 
version of this algorithm uses L = 2, and in this case we have IAI = 1 in the proof. For larger values 
of L our estimate for the running time increases drastically, and the result may seem to be of only theoretical 
interest. However, in a practical instance, our estimate can be unduly pessimistic, since the number 
of different plausible cuts is likely to be much smaller than our worst case bound of the number of all 
subsets of the given set of rectangles that have at most [A I elements. Moreover, in different dimensions 
we can use different values of L. The overall effect of these engineering optimizations may be a practical 
algorithm with an approximation ratio better than the one in Section 4.1. 5 Concluding Remarks A general 
open issue is whether the approximation bounds in this paper can be further improved. It is known that 
it is NP~hard to approximate the RTILE problem to a ratio better than 5/4 [KMP98], hence a gap still 
remains. Our algorithm for the RTILE problem for the {0,1}-arrays s in fact shows that there is a hierarchical 
partition of the given array in which the maximum weight of a tile is at most 2 [A/p] since we used [A/p] 
as a (trivial) lower bound on the optimum. It is easy to generate examples such that no tiling exists 
with the maximum tile of weight at most 5/3 [W/p]. Hence, our approach for tiling on {0, 1}-arrays will 
not yield better than 5/a approximation unless new lower bound techniques are used. We used one such 
new lower bound for the DRTILE problem in the proof of Theorem 3.3 (in Lemma 3.6) to get the improved 
approximation ratio of 2d -1. Initially, we suspected that ([l+lognJ) d-1 is a lower bound on the approximation 
ratio that is attain- able for the d-RPACK problem. However, to our sur-prise, we were able to obtain 
an approximation ratio which can be better by any arbitrary constant factor in Section 4.2. It remains 
open to understand the limits on the approximability of this problem, in particular, in d dimensions. 
Also, whether the ideas here will prove useful in applications domains remains to be seen. References 
SThe same effect happens with arbitrary arrays as well. [BNR96] V. Bafna, B. Narayanan and R. Ravi. 
Nonover- lapping local alignments (weighted independent sets of axis parallel rectangles). Discrete Applied 
Mathemat- ics, 41-53, 1996. [FM+96a] T. Fukuda, Y. Morimoto, S. Morishita and T. Tokuyama. Data mining 
using two-dimensional opti- mized association rules: Scheme, Algorithms and Vi- sualization. Proc. ACM 
SIGMOD, 1996. [FM+96b] T. Fukuda, Y. Morimoto, S. Morishita and T. Tokuyama. Mining optimized association 
rules for nu- merical attributes. Proc. A CM Principles of Database Systems, 1996. [FPT81] R. Fowler, 
M. Paterson, and S. Tanimoto. Optimal packing and covering in the plane are np-complete. Information 
Proc. Letters, 12, 133-137, 1981. [KMP98] S. Khanna, S. Muthukrishnan, and M. Paterson. Approximating 
rectangle tiling and packing. Proc Syrup. on Discrete Algorithms (SODA), 384-393, 1998. [KS0] R. P. Kooi. 
The optimization of queries in relational databases. PhD thesis, Case Western Reserve Univer- sity, Sept 
1980. [LP00] K. Lorys and K. Paluch. Rectangle Tiling. Third International Workshop on Approximation 
Algorithms for Combinatorial Optimization (APPROX PO00), Lec- ture Notes in Computer Science 1913, 206--213, 
Sept. 2000. [MD88] M. Muralikrishna and David J Dewitt. Equi-depth histograms for estimating selectivity 
factors for multi- dimensional queries. Proc. of A CM SIGMOD Con f, pages 28-36, 1988. [MPS99] S. Muthukrishnan, 
V. Poosala and T. Suel. On rectangular partitions in two dimensions: Algorithms, complexity and applications. 
Intl. Conf. Database Theory (ICDT), 236-256, 1999. [088] M. H Overmars. Computational geometry on a grid: 
an overview, Theoretical Foundations of Computer Graphics and CAD. NATO ASI Series F40, Edited by R. 
A. Earushaw, Springer-Verlag Berlin Heidelberg, 167-184, 1988. [P97] V. Poosala. Histogram-based estimation 
techniques in databases. PhD thesis, Univ. of Wisconsin-Madison, 1997. [RS99] R. Rastogi and K. Shim 
Mining optimized support rules for numerical attributes. Proc. intl Conf. Data Engineering, 1999. [$99] 
J. P. Sharp. Tiling Multi-Dimensional Arrays. Foun-dations of Computing Theory, 1999. [SS99] A. Smith 
and S. Suri. Rectangular tiling in multi- dimensional arrays. Proc. ACM-SIAM Symp on Dis- crete Algorithms 
(SODA), 1999.   
			
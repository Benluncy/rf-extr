
 RELIABLE HOST-TO-HOST PROTOCOLS: PROBLEMS AND TECHNIQUES Lawrence L. Garlick and Raphael Rom SRI International 
Menlo Park, California 94025 Jonathan B. Postel University of Southern California Information Sciences 
Institute Marina Del Ray, California 90291 Abstract Host-to-host protocols capable of supporting internetworking 
and reliable transmission have been under development for several years. This paper discusses problems 
and techniques related to one type of reliable protocol, which features end-to-end positive acknowledgement, 
retransmission, internetwork addressing capabilities, and ordered delivery. The issues of interest are 
protocol correctness and completeness, protocol efficiency, and complexity of implementation. These will 
be discussed in a framework of three problem areas, flow control, se- quence number space management, 
and reliable transmission of controls. Flow control heuristics using windowing techniques are explored. 
Flow control information is augmented to allow fair apportionment of bandwidth, better bandwidth utilization 
through optimistic credits, flow control credits matched to the type of traffic, and increased performance 
for high precedence connections. Alternatives for selecting the startup sequence num- ber for a connection 
are presented. Techniques and problems of several sequence number space management strategies are presented. 
These include delayed startup, incarnation numbers, and resynchronization. The transmission of controls 
are discussed, with em- phasis on whether or not to share a logical transmission channel between controls 
and data. The effect of data flow control on the delivery of out- of-band signals is an important consideration. 
 The findings are presented both to further the un- derstanding of and to encourage intelligent implementations 
of reliable protocols. Introduction Computer networking has emerged as a significant segment of the 
growing data communications field. At the forefront of computer networking technology is packet-switching. 
Packet-switching networks are being used or implemented for research, military, and commercial applications. 
An important part of the progress in packet-switching technology has been the development of distributed 
protocols. Tremendous development has been done in the area of host-to-host protocols since the first 
major packet- switching network, the ARPA (Advanced Research Pro- jects Agency) network, was designed. 
In fact, the ARPA host-to-host protocol has been the reference point for process-to-process protocols 
for several years. As users have gained experience with networking, new applications, new topologies, 
new network access methods, and new higher level protocols have emerged. The ARPA network host-to-host 
protocol is not suitable for meeting the demands associated with these new developments. For instance 
it does not support some important features like end-to-end acknowledgement, internetworking, and high 
throughput flow control techniques. In the last few years, several efforts have been made to design new 
host-to-host protocols. The most notable of these has been TCP, the Transmission Con- trol Program, which 
was initially designed to be a reliable internetwork host-to-host protocol [I], as well as a solution 
to many of the problems of the ARPA network protocol. Among its reliability features are positive acknowledgement, 
retransmission, and sequencing of data and controls. It guarantees the error free delivery of each mes- 
sage for which it claims successful delivery. Other improvements include duplex connections and the ability 
to use the same network address (socket) in several connections. Even while implementation of TCP proceeds, 
there are still some unresolved important issues to be dis- cussed, solutions to be found. The paper 
is orga- nized around three of the'more important issues--a discussion of flow control techniques, strategies 
for the management of connection sequence number space, and the need for a mechanism to reliably de- 
liver controls. Reference will be made to TCP, since it is representative of a reliable host-to- host 
protocol; however, the problems and techniques discussed in this paper are general in nature and are 
representative of those encountered in any such protocol. It is assumed that the reader is somewhat 
familiar with ARPA network and TCP-like protocols [1], [2], [6]. To assist the reader with recall of 
the basic characteristics of these protocols, a brief ssmmary of TCP features is presented. A glossary 
of abbreviations and terms, and appendices that magnify a few of the more involved issues can be found 
at the end of the paper. TCP: A Reliable Transmission Protocol Network Characteristics TCP does not 
depend on the transmission medium for its reliability, i.e., it is asssmed that the subnetwork may be 
unreliable. The subnet need not ensure the orderly or errorless delivery of subnet packets, or account 
for lost packets. TCP func- tions correctly in the face of large packet lifetimes, and the opening and 
closing of connections in quick succession. 4-58 Connections Logical connections are established for 
process- to-process (user-to-user) communication. TCP connections are full-duplex channels established 
between source and destination sockets (network- wide process names). A socket may be a party to more 
than one connection, but only one connection can exist between any pair of sockets. TCP provides the 
means by which a connection be- tween the processes is established, controlled during the transfer of 
data, and terminated at the completion of the session. Connection management requires the exchange of 
controls between TCP's. There are controls for connection synchronization, out-of-band signalling (interrupt), 
data flushing, resynchronization, and connection closing. As de- scribed below, controls accompany data 
whenever possible to avoid the overhead of separate control packets. Packaging and Headers TCP packages 
user letters (messages) into packets suitable for transmission over a subnetwork. Each letter or partial 
letter is prefixed by a TCP header, which includes fields for addressing, sequencing, acknowledgements, 
flow control, con- trols, and error checking. The header is optionally followed by a block of data. The 
smallest unit of data transfer and the unit of sequencing is the 8-bit byte (octet). Sequencing Sequence 
numbers are used as acknowledgement identifiers and as an ordering mechanism. They are assigned to each 
octet of data and to those controls that need synchronization with the data stream. The data and controls 
sent on a connection may be assigned sequence numbers from the same sequence number space, representing 
one transmission channel, or they may be tagged separately, representing two logical transmission channels. 
Since only one sequence number is sent per logical channel, the packet length and control fields are 
used to determine the highest sequence number consumed by the packet. Reuse of sequence numbers is allowed 
only for du- plicate retransmissions. The sequence number space is managed cooperatively by the sender 
and the receiver. Acknowledgement and Retransmission A TCP acknowledgement represents the successful 
delivery of some number of octets to the receiving process's buffer or to the remote TCP (controls). 
It is sent to the transmitting TCP in the acknowledgement field of a subsequent TCP header. The sequence 
number placed in this field is the highest sequence number acknowledged by the receiver and implies acknowledgement 
of all previ- ous octets. If packets arrive out of order, an acknowledgement cannot be sent for octets 
with se- quence numbers higher than the missing octets, since that would implicitly acknowledge the 
missing data. Packets can be retransmitted at will until they are acknowledged; however, bandwidth may 
be underutilized if improper retransmission policies are followed. Duplicates naturally arise from retransmissions 
that occur prior to the receipt of an acknowledgment and are detected and handled as described below. 
 Packet Acceptance Checking The receiving TCP is responsible for the detection of packets with improper 
sequence numbers. These may have sequence numbers that are either old duplicates <from previous connections) 
or illegal because they are not within an acceptable flow control range. To determine the action to be 
taken for a newly received packet, acceptability ranges are defined. The following three ranges are mutually 
exclusive and collectively exhaustive of the sequence number space. Acknowledge-deliver range (ADR). 
The packet has arrived in-order and does not exceed the re- ceiving process's buffer space. Data will 
be placed in the buffer and an acknowledgement will be generated to indicate successful delivery. Acknowledge-only 
range (AOR). A duplicate packet has arrived, as a result of retransmission. It will be acknowledged, 
but not delivered, since delivery has already occurred. Discard range (DR). An illegal packet has arrived. 
It may be an old duplicate or a packet that cannot be delivered due to flow control. Appendix A provides 
more details of the packet ac- ceptance policy. Flow Control Techniques Introduction Flow control 
is basically a mechanism to prevent the sender of data from overflowing the receiver's buffers. Flow 
control may exist at each level of protocol as well as between levels of protocols, though the latter 
tends to be somewhat implementa- tion dependent. The techniques to be considered here assume that flow 
control information is passed from the receiver to the sender. Flow control information typically reflects 
the receiver's ability to buffer data. The information often represents a count of some resource, such 
as a unit of buffering or a message queue element. A good flow control scheme must handle a whole spectrum 
of problems that result from preventing buffer overflow in the receiver. This section first discusses 
general flow control goals and methods, and then specific techniques that could significantly improve 
protocol performance. The goals and methods of an ambitious flow control scheme include the following: 
 End-to-End Flow Control. Flow control for a particular level of protocol should be exerted at the point 
closest to the final destination. For a host-to-host protocol, this means that flow control information 
is passed between the hosts supporting the communicating processes. Receiver's Allocation. Any flow control 
strategy should consider the buffer space offered by a receiving user, since this repre- sents a depository 
for incoming messages and relieves the protocol module of resource alloca- tion problems. Congestion 
Prevention. The flow control strategy should prevent queueing of messages in the protocol module, so 
that module resources can be used to handle those messages that have a high probability of being delivered 
immediately. Congestion in the subnet can be caused by a positive-acknowledgement, retransmission protocol, 
since each unacknowledged packet is retransmitted. The flow control scheme should make it easy to slow 
or stop transmission from the sender. Deadlock Prevention. When congestion does occur, resources must 
be available to handle traffic-clearing messages. Controls and flow control information must be delivered 
and interpreted even when data is queued. Fair Apportionment and Utilization of Bandwidth. It is important 
to be able to fairly allocate the available host-to-host bandwidth to users, based on a variety of criteria. 
One criterion may be precedence of the user or the connection. Another may be the mode of traffic, e.g., 
interactive traffic may get preference over bulk traffic. In addition, to fully utilize the available 
bandwidth, different flow control strategies may be appropriate for different modes of traffic. Interplay 
With Subnet Flow Control. Often the interfaces between modules representing levels of protocol can cause 
flow control problems [8]. For instance, the subnet flow control of the ARPANET is adversely affected 
whenever a host does not readily accept incoming data from the packet switch (IMP). Retransmission protocols 
are especially flexible in this regard, because they can absorb congested traffic from the subnet and 
discard it if necessary. Exchanging Flow Control Information A windowing scheme to convey flow control 
informa- tion has been used for many different types of protocols. It is an efficient technique that 
is useful whenever positive acknowledgement and retransmission are used for reliable transmission. A 
flow control window is a dynamic range in the sequence number space that defines the current flow control 
credit. The window edges, the range of the window, are defined by the last received acknowledgement sequence 
number (the window's left edge) and the window size. Flow control is exerted by the receiver by issuing 
credits, which represent the receiving process's willingness to buffer data. The window's left edge plus 
the window size give the highest sequence number that can be transmitted with some assurance that it 
will be acknowledged without retransmission. A nonzero window size gives permission to send up to a certain 
sequence number, the right edge of the flow control window. It is an "oversend" to send messages with 
sequence numbers that exceed the window right edge. Oversends will occur occasionally, since the flow 
control information is always slightly out of date and it is possible for the receiver to withdraw flow 
control credits. Oversends are not a problem in a retransmission protocol, because the receiver can always 
discard incoming data without sending acknowledgements (knowing that the data will be retransmitted 
later). Flow Control Between Processes A host-to-host protocol provides a reliable transmission medium 
for communicating processes. Consider the case in which no flow control is used. If the sending process 
knows the buffer sizes used in the receiving process then it can send messages of the right size. It 
will not at- tempt to send a message larger than the receiver can buffer nor will it break up a large 
message unnecessarily. If the sender is unfamiliar with the receiver, it might send messages that are 
too large, resulting in lost data, or send messages that are too short, resulting in inefficiencies. 
The addition of flow control in the transmission medium cannot guarantee that a sender will always send 
the optimum sized message. It is still ideal for the sender to know the receiver's buffer size. However, 
for unfamiliar processes the protocol can repackage messages from the sender into messages that the receiver 
can buffer. It cannot solve the problem of the sender sending buffers that are unnecessarily small, resulting 
in inefficient han- dling in the receiver. Determining the Window Size As the distance increases between 
the modules that support a particular protocol, so does the age of the flow control information. For 
subnetwork packet sending, where the delay to the next packet switch node is minimal, the flow control 
informa- tion is current enough to be useful. For host-to- host protocols that support internetworking, 
the round-trip delay is so large that the flow control information is bound to be inaccurate. The positive-acknowledgement 
and retransmission protocol allows flexibility in determining the correct flow control window size. The 
window size should indicate the willingness of the receiving process to provide buffer space. The window 
size could represent exactly the available buffer space that the user has offered for letter receiving 
 (the conservative strategy), or it could reflect some expected buffer space, based on previous allocations 
(the optimistic strategy). Conservative (Guaranteed) Allocation. The conservative approach to window 
size setting gives the receiving process almost full control over the flow control mechanism. By assuring 
the sender that there will be space for a particular number of octets, the policy reduces discards thus 
re- ducing the number of retransmissions. (Some mes- sages may still be discarded if they arrive out 
of order and sufficient reassembly space is not available.) There are some disadvantages to the conservative 
strategy of window size setting. Flow control in- formation is always slightly out of date when it is 
finally received. The receiving process could have drastically increased or decreased its allo- cation, 
making the information useless. Unless a process provides for double buffering, the window very likely 
will go from a fixed size (whatever the user's buffer is) to zero, each time a message is passed on to 
the receiving process. Depending on the scheduling algorithm in the host, this could result in windows 
of size zero, totally inhibiting message flow. Before messages can flow again, a packet with flow control 
information must arrive at the source. Thus, a round trip delay is experienced between messages and there 
is an in- crease of dataless packets in the network. Another related problem is that large single buffers 
may be used to receive small messages that require immediate delivery to the receiving pro- cess. If 
a window of say size k is advertised and a packet of size << k arrives that indicates imme- diate delivery, 
then the destination buffer is re- turned to the receiving process. The previous flow control credit, 
which was large, is withdrawn and the window becomes zero. In the interim, the sender may have sent several 
small messages tagged for immediate delivery, thinking the receiver has the buffers to accept them. 
The receiving protocol module, knowing that the receiving pro- cess has no available buffer space, will 
advertise a zero window. By the time the window information arrives at the sending protocol module, it 
likely will be an inaccurate report and cause further de- lays. Optimistic Credits. The alternative to 
the conservative approach is to send flow control in- formation that is a good estimate of the expected 
 receiver's available space [3],[7]. Thus, the window size should be a function of previous window sizes 
as well as the current available space. The window size should be an average, weighted very heavily toward 
the current time, so that a process that is truly rejecting data will soon reflect a very small window. 
This method could even be mixed with heuristics to force the window to zero after a fixed period without 
receiving. Optimistic allocation can do much to help solve the problem of drastic window size changes 
experi- enced with the conservative scheme. In granting permission to transmit messages before the user 
has allocated buffer space, it fills the pipe and allows a smoother flow. It is still reliable, be- cause 
any message can be discarded in the receiver since it will be retransmitted later. The disadvantages 
of the method are its instability when faced with very irregular re- ceiving patterns. A poorly behaving 
receiver can still sabotage this policy, but not as easily as with conservative technique. As will 
be shown below, an optimistic strategy may be quite dynamic with respect to recent receiving patterns, 
connection precedence, and the fair sharing of the available bandwidth. It may be possible to determine 
the semantics as- sociated with the window size by exchanging transmission mode or topological information. 
When a connection is opened, the transmission mode (e.g., interactive, bulk) and the topology (e.g., 
satellite link) could be exchanged. This would be used to determine the weighting of previous window 
sizes in calculating the current window. To demonstrate the idea of an optimistic flow con trol policy, 
a method for setting the receive window size is given in Appendix B. Zero Flow Control Windows It may 
be necessary to stop the flow on a connection, i.e., stop all new transmissions and unnecessary retranemissions. 
A zero receive window, sent in packets to the sender, indicates an unwillingless to receive data. The 
protocol module must perform special functions with regard to sending packets into a zero window. If 
neces- sary, new data from the sending process must be rejected, and old unacknowledged data must be 
queued. Opening a window of size zero also presents some special problems [6]. Since a window size can 
ac- company each packet, it seems that the normal data packet and acknowledgement transmissions should 
be sufficient to vary the size of the windows. How- ever, when both protocol modules are showing a zero 
receive window, a deadlock can arise. A data packet cannot be sent because the closed window indicates 
that only controls should be retransmitted; moreover, there may be no data to send. If ACKs are used 
and they arrive out of order, it may be impossible to tell if the window is opening or closing. One 
method of handling the problem of opening a window of size zero is by using a pair of con- trols, one 
sent by the local protocol module that is making its window size nonzero (WOPEN) and one that is sent 
by the foreign protocol module to acknowledge the opening (WACK). These are special controls that must 
be handled immediately, without regard for flow control restrictions. If controls can be blocked bY data, 
as in the present TCP, then the WOPEN must be tagged with, but must not consume a sequence number. Sequence 
Number Space Management The second problem area that needs attention is that of the reliable handling 
of the sequence number space. Two difficulties associated with sequence nt~bers are how to select the 
startup number and how to reliably exchange the selected number with the remote protocol module. The 
exchange of sequence numbers is accomplished by using a "three-way handshake" method [2], [4], [5]. This 
method pro- vides positive acknowledgement of the exchanged se- quence numbers and is sufficient to handle 
the prob- lem of simultaneous connection establishment attempts. The rest of this section will deal with 
the techniques to select startup sequence numbers. In a packet-switching network with alternative rout- 
ing schemes, a packet can have a relatively long lifetime, especially if the topology of the network 
includes satellite links. Due to misrouting, a packet can arrive at its destination minutes or even hours 
late, depending on the topology. A reliable protocol must be able to determine if such a packet is deliverable, 
acknowledgeable, or if it must be discarded without acknowledgement. If during the packet's transit time 
the connection is closed or broken due to a crash with loss of memory, then the packet is no longer valid. 
If the connection is reestablishe~, using the same source and destination addresses, then the arrival 
of the old packet can cause confusion in the receiving protocol module. A reliable mechanism must exist 
to guarantee that the receiving protocol module can distinguish packets of the current connection from 
packets of an old connection. The key issue is the maximum packet lifetime, the time a misrouted packet 
can stay in the network(s). For small self-contained networks with no internetwork connections, this 
time is probably less than a second. For large, interconnected networks, this time could be much longer. 
Below is a discussion of several techniques for sequence number space management. They are ordered by 
size of net- work and simplicity of implementation. Ultimately, methods for handling the internetworking 
protocol are given. Delayed Startup For small networks, problems arising from packets belonging to 
old connections can be solved by waiting the maximum packet lifetime before opening connections, either 
at host startup or following the closing of a connection with the same source and destination addresses. 
Each connection can start wltb sequence number equal to zero since no old packets from an old connection 
exist anywhere in the network. If the maximum packet lifetime exceeds a second, it may not be appropriate 
to wait a second before opening every connection. A solution would be to use delayed startup only after 
a crash and use some kind of connection table to remember the se- quence number for a recently closed 
connection. Eatries in this table need be remembered only for a maximum packet lifetime. Incarnation 
Numbers If packet lifetimes are too large to use delayed startup, an incarnation number approach may 
be suitable. An incarnation number is a unique name for an instance of the protocol module. The name 
(or incarnation number) is sent in each packet and is used by the receiver to filter out packets from 
old connections caused by a crash and restart. The incarnation number is used in con- junction with the 
sequence numbers to uniquely 4-61 identify an octet of data or control. The uniqueness of the incarnation 
number allows the resetting of the sequence number space to zero at initialization of each new path (first 
connection between two users). The incarnation nl~ber may be generated in several ways. The most reliable 
is from nonvolatile stor- age using error detecting and correcting encodings. The old incarnation number 
is read, incremented, and rewritten each time the host restarts. When a new connection is opened the 
current incarnation number is read. The disadvantage of this scheme is that nonvolatile storage has been 
too expensive for small hosts, especially those acting as network access devices. It is expected, however, 
that new technology, such as bubble memories, will overcome this disadvantage. A second method is to 
determine the incarnation number from a clock. The appropriate clock reso- lution and wraparound period 
is a factor of the maximum packet lifetime for the network or interconnected networks. Let us assume 
that the clock has a resolution of one minute and a wraparound period of 256 minutes. The resulting incarnation 
number is 8 bits long, and is used to assure the receiver that any message received with this incarnation 
number is from the active connection and not an old one. The clock method has a slight drawback. If the 
incarnation number clock and the sequence number space both wraparound at the same time, and the host 
crashes just prior to this time, then there is a chance that illegal packets will be in the network when 
a new incarnation number (equal to the old one due to wraparound) and a new sequence number (0) are chosen 
at startup. The probability that the sequence number space does wraparound is extremely small, especially 
if a sequence number space of 2**32 octets is used, as in TCP. The combined probability that the incarnation 
number clock also wraps around is even smaller. No matter which method is used to generate the incarnation 
number, there must be a mechanism to remember the last sequence number used on a connection between a 
specific source and destina- tion pair. When a connection is closed, the protocol module must save the 
last sequence number used. It must retain the number for the maximum packet lifetime. Saving the sequence 
number, the destination, the destination incarnation number, and the time of a closed connection solves 
the problem of the repeated opening and closing of the same connection (source and destination). It does 
not solve the problem created by host computer crashes; the incarnation number handles that. When connection 
establishment is requested, the list of old connections must be searched by <source, destination> pair. 
If a match is found, the sequence number plus one is the first sequence number used when the connection 
is opened. If there is no match, then numbering can start at zero. Management of the old connection list 
entails removal of outdated items. This can be handled, for the most part, during normal searching. 
When list storage becomes scarce, a simple garbage collection routine can be invoked. There are two 
problems with the method using incarnation numbers. First, there is some concern about the size of 
the old connection list. It would not be surprising to see 1000 connections per hour for an average 
host. Allowing a socket to be party to many connections will lead to fewer source and destination pairs; 
thus, many connections will be reused. (This is in contrast to the ARPA network, where restrictions 
in socket usage result in contact connections being used to spawn direct, dynamically named service 
connections.) Another factor that alleviates con- cern about the space required for the old connection 
list is the recent progress in inexpensive memories. The second problem is how to keep the incarnation 
number small enough to be sent in each header and still keep the name space large enough to ensure uniqueness. 
It is felt that an incarnation number field greater than 8 bits is excessive header overhead. To accommodate 
this with the clock method, the resolution of the clock is constrained, which leads to the following 
restric- tion applied at host startup time. When a host comes up after a crash, it must delay at least 
 (maximum packet lifetime) / 2**8 before any connections are opened, so that a unique incarnation number 
is always chosen. A startup delay of one minute is probably sufficient for the internetting case since 
it implies a maximum packet lifetime of 256 minutes. Resynchronization Resynchronization, suggested 
by Tomlinson [4], [5], is another sequence number space management mechanism. Resynchronization is used 
in this paper to denote the mechanism itself, rather than the stage of the mechanism when the actual 
resetting of the sequence numbers is done. The scheme is based on selecting initial sequence num- bers 
(ISN's) from a curve in the sequence- number/time plane derived from a clock. When a new connection is 
opened, its first sequence num- ber is taken from the ISN curve. If the consump- tion of sequence numbers 
is satisfactory, i.e., similar in slope to the ISN curve, resynchronization of sequence numbers need 
not occur. However, if the rate of consumption is too slow, resynchronization may be required to avoid 
colliding with the ISN curve. The ISN curve has a parallel boundary (defining a "forbidden zone") that 
indicates that no new sequence numbers may be assigned and that resynchronization must take place immediately. 
If this is not done and if a crash occurs, sequence numbers assigned in the forbidden zone could conflict 
with the ISN chosen for the new connection. See [4], [5], [6] for further details of the resynchronization 
mechanism. A few of the problems related to implementing resynchronization are discussed below. Understanding 
and Documenting the Problem. Even though the resynchronization method is a workable one, it is not at 
all straightforward. It takes numerous pages and illustrations just to document the concept [4], [5], 
[6]. As has been pointed out in the past by weathered ARPANET protocol implementers, a protocol must 
be reasonably easy to understand and easy to document. After all, if the network is heterogeneous, it 
will be implemented on numerous kinds of hardware by system programmers with various degrees of skill. 
Testing for the Need to Resynchronize. The protocol requires that if a connection is broken due to a 
system crash, the sequence number cho- sen at startup must be one that cannot be con- fused with any 
sequence number still in the net- work for the old instance of that connection. To satisfy this requirement, 
periodic runtime checking must be done to determine if the se- quence number consumption rate is satisfactory, 
i.e., if it is not approaching the forbidden zone. This check must be done at fixed time in- tervals, 
not just when sequence numbers are being assigned. The check may result in the need to resynchronize 
even (and especially) if the connection is idle. Resynchronization and Flow Control. The need to resynchronize 
may occur at any time, and the resynchronization must proceed in a timely man- ner if normal activity 
is to continue. However, since resynchronization means changing from the old sequence numbers to new 
sequence numbers and since the resynchronization control must be acknowledged (marked with an "old" sequence 
num- ber), all data marked with the "old" numbers must be acknowledged before the resynchronization control 
is acknowledged. If data is not being accepted because the user is not receiving, then resynchronization 
cannot proceed. If resynehronization cannot proceed, then neither new controls nor new data may be sent. 
The Loss of a Truly Out-Of-Band Signal. Due to the flow control problem mentioned above, all controls 
can be blocked during a resynchronization process. This includes the interrupt, which is supposed to 
be an out-of- band signal. Losing the out-of-band capability, even in rare instances, is an unfortunate 
defi- ciency. Higher-level protocols that rely on an out-of-band signal could be severely crippled by 
the inability to interrupt a "runaway" process. In fact, it is the runaway process, by not accepting 
data, that will soon force resynchronization and will not be interruptable. Reliable Transmission Of 
Controls Introduction Controls are special commands that are sent be- tween two protocol modules to 
coordinate connection management. Opening and closing of connections, and providing an out-of-band signalling 
mechanism are all part of connection management. If synchronizing sequence numbers or a flushing feature 
are required, then maintenance of the medium might be considered connection man- agement. Thus, a list 
of controls for a particu- lar protocol might look something like the following: OPEN, CLOSE, INTERRUPT, 
FLUSH, SYNCH. To reliably transmit controls, it is necessary to acknowledge their receipt. This means 
different things for different controls; for the case of an OPEN, it could mean the establishment of 
a connection table entry at the receiver. For the INTERRUPT it could mean that the receiving process 
is signalled, via the operating system signalling mechanism. As with sending data, the sequence number 
used for ordering can be used as the acknowledgement iden- tifier for controls. The main question is 
whether to use the same sequence number space for both data and controls. Using the same sequence number 
space is equivalent to having one logical channel for both data and controls. If a separate se- quence 
number space were to be used for controls, then a new logical channel would be necessary. Before discussing 
the tradeoffs involved in one logical channel versus two, some background infor- mation concerning out-of-band 
signals will be pre- sented [10]. An out-of-band signal should be pro- vided that satisfies the following 
criteria: The interrupt should be delivered reliably, i.e., for each one sent, one and only one is 
de- livered to the receiving process. Ordering is not crucial. The interrupt should be independent of 
the data flow control mechanism. An interrupt must be delivered whether or not there are buffers pro- 
 vided for data, whether or not controls are being handled. The interrupt should not inter- fere with 
the reliable delivery of other data and controls. The interrupt is delivered to the receiving pro- cess 
via an. operating system signalling mechanism. Once so delivered, no other semantics are associated with 
the interrupt. The interrupt serves several purposes. For terminal users, it could be the only method 
of getting the attention of a runaway process. For higher-level protocols, it can be used in conjunc- 
tion with a mark in the data stream to synchronize the sender and receiver. Of course, for process-to-process 
communication it can be used to simply signal the receiver that some event has occurred. A Single Logical 
Channel Combining data and controls on the same channel has several advantages. There is savings in 
packet overhead, since data and control piggybacking can occur by sending a single se- quence number 
and packet length. Savings are also realized in the maintenance of a single sequence number space. As 
was discussed earlier in this paper, this is a significant maintenance problem. Two disadvantages of 
the single sequence number space scheme have been discovered recently: reas- sembly of data mixed with 
controls is costly when packets arrive out of order, and a true out-of- band signal is not being provided. 
The first problem is an efficiency matter that has plagued early implementers [9]. User buffer space 
cannot be used for the reassembly of out of order packets because there is no way to know if the unarrived 
packets contain only data or if controls are intermixed with the data. The essence of the second problem 
is that the acknowledgement scheme requires that acknowledgement of a sequence number is i mplicit acknowledgement 
of all preceding sequence numbers. Since interrupts must be acknowledged for reli- ability, the transmission 
of an interrupt can be blocked by data flow control in the receiver. This was noticed early by the TCP 
group [2] and an attempt was made to rectify the matter by giving the interrupt extra semantics--that 
it always flushes unacknowledged data. This solution is probably sufficient unless resynchronization 
meth- ods are used for sequence number selection. As mentioned earlier, delivery of an interrupt should 
not disturb the reliable delivery of data and controls. What does an interrupt that re- sults in the 
flushing of data and controls imply? Flushing of data implies extra semantics on the delivery of an interrupt; 
however, it is accept- able for the known applications. Flushing of cer- tain controls is impossible. 
When the resynchronization method for sequence number se- lection is used, an interrupt cannot be sent 
when a resynchronizing control has just been sent. The resynchronizing control can be blocked by data 
flow control but it cannot be flushed. In this situation, an interrupt cannot flush and thus can- not 
be sent. This could result in an uninterruptable runaway process. A Control Subchannel To provide a 
solution to the reassembly problem and to allow the most general implementation of out-of-band signals, 
a second channel for controls can be used. The method that will be discussed is a control subehannel, 
a concept that reduces the cost of sequence number space management for the control channel. The control 
sequence number is the composite of the data channel sequence number (DCSN) and the subchannel sequence 
number (SCSN). This serves the dual purpose of synchronizing the two streams and using the resynchronization 
mechanism of the data channel for all subchannels. A subchannel allows reliable transmission even when 
the data channel is inactive, without flushing data. From the SCSN, the number of control fields, and 
the last SCSN received, the receiver can determine if subchannel traffic is coming in order and thus, 
whether it can be acknowledged. The field size holding the SCSN determines the wraparound point in the 
SCSN space. The SCSN space is initialized to zero when the DCSN is synchronized. It IS NOT reset with 
each DCSN change. There is no flow control information passed for the subchannel. Discarding controls 
(without acknowledgement) is the flow control mechanism. The subchannel sequence number space is small; 
thus, the protocol module must keep track of the DCSN to which the first SCSN was assigned. If wraparound 
of the SCSN space occurs, in the rare event that many controls are sent while the data channel is blocked, 
then the control channel be- comes blocked. This is very unlikely since a long series of controls must 
contain interrupts, and successfully delivered interrupts will usually cause the receiving process to 
unblock the data channel. Acceptability Test for Subchannel Traffic The acceptability test of items 
on the subchannel is a composite test of both sequence numbers. First the DCSN is checked to see if it 
would be acknowledged if it were an octet received on the data channel. Only if it would have been dis- 
carded will the item on the subchannel be dis- carded. Having passed the DCSN test, the SCSN is checked 
to see if the item is deliverable and acknowledgeable with respect to the SCSN sequence number space. 
The SCSN test is less involved than the DCSN test because there is no flow control range. To be believable, 
the SCSN must fall in the range of SCSN's sent and SCSN's for which acknowledgements have been received. 
This is a check for everything except the existence of old duplicates from old instances of the connection, 
which is made by checking the DCSN. Summary Several problems, solutions, and techniques have been presented. 
The discussions relate to improved efficiency, simplification of implementation, and protocol functionality. 
The motivation for the dis- cussions is more than to improve a specific protocol. It is also to focus 
attention on a set of issues that are common to all reliable host-to-host protocols. Flow control ideas 
have been discussed, with atten- tion to implementation ideas that satisfy fairly ambitious goals. Window 
management techniques have been suggested that could improve efficiency. A window setting method was 
presented that features optimistic credits that are a function of past credits, congestion, and available 
buffer space. Several techniques for sequence number space manage- ment have been given. Methods have 
been presented that are suitable for small networks, with short packet lifetimes. Two methods suitable 
for internetworking have been proposed and compared-- incarnation numbers and resynchronlzation. Finally, 
the alternatives for the reliable transmission of controls were set forth. A single channel for data 
and controls was contrasted with a control subchannel. Correct handling of out-of-band signals was emphasized. 
There are interdependencies involved; that is, some of the stated problems become less severe when oth- 
ers are solved. For example, if resynchronization is abandoned, then the argument for separate chan- 
nels is motivated only by the need for the efficient reassembly of out-of-order packets. The discussion 
of flow control indicated areas that should gain attention as more experience with protocols is gained. 
This should be an area for significant measurement, under many different transmission modes. References 
 [I] Cerf, V. and R. Kahn, "A Protocol for Packet Network Intercommunication," IEEE Transactions on Communication, 
Vol COM-20, No. 5, May 1974. [2] Cerf, V., Y. Dalal, C. Sunshine, "Specification of Internet Transmission 
Control Program," INWG General Note #72, December 1974 (Revised). [3] Sunshine, C., "Interprocess Communication 
Protocols for Computer Networks," Digital Sys- tems Laboratory Technical Note #105, December 1975. [4] 
Tomlinson, R., "Selecting Sequence Numbers," INWG Protocol Note #2, September 1974. [5] Dalal, Y., "More 
on Selecting Sequence Num- bers," INWG Protocol Note #4, October 1974. [6] Postel, J., L. Garlick, R. 
Rom, "Transmission Control Protocol Specification (AUTODIN II)," SRI-ARC Catalog #35938 &#38; #35939, 
July 1976. [7] Sunshine, C., "Factors In Interprocess Communi- cation Protocol Efficiency For Computer 
Net- works," Proc. National Computer Conf., 1976, AFIPS Press, pp 571-576. [8] Herrmann, Jeff, "Flow 
Control in the ARPA Net- work," Networks, Vol I, Number I, June 1976. [9] Burchfiel, J., W. P1ummer, 
R. Tomlinson, "Pro- posed Revisions to the TCP," INWG Protocol Note #44, September 1976. [10] Garlick, 
L., "Out-of-Band Control Signals in a Host-to-Host Protocol," RFC 721, NIC Catalog #36636, September 
1976. Glossary control -- commands passed between protocol modules that are used to coordinate connection 
management. DCSN --data channel sequence number. host -- a computer that is connected to the net- work 
and that executes programs on behalf of its users. A host may provide services to other computers on 
the net- work. ISN -- Initial sequence number; the first se- quence number used when a connection is 
synchronized or resynchronized. MPL --maximum packet lifetime. octet --eight bits. SCSN --subchannel 
sequence number; control channel sequence number. socket -- an entity defining one end of a connection; 
the internetwork-wide name of a process port. subnetwork- the network of computers that provides a communication 
medium for network hosts. The nodes of a subnetwork may function as host interface points as well as 
store and forward computers. TCP --Transmission Control Program and the protocol it implements. window 
--a dynamic range in the sequence number space used in flow control management. Appendix A: Packet Acceptance 
 This appendix provides details of a packet accep- tance testing scheme. It should clarify the possi- 
ble actions the receiving protocol module may take when it receives an arbitrary packet. Remember, the 
receiver is responsible for the detection of packets wlth improper sequence numbers from either old connections 
or ill-behaving senders. For notation, let ADR = acknowledge and deliver range AOR = acknowledge only 
range DR = discard range S = size of sequence number space x = sequence number to be tested FCLE = flow 
control left window edge ADRE = (FCLE+ADR) mod S = Ack-deliver right edge (Discard left edge -I) AOLE 
= the first sequence number received for this connection MPL = maximum packet lifetlme (in sec) TB = 
Total protocol bandwidth (in octets/sec) For any sequence number, x, and packet text length, i, if 
(AOLE <= x <= ADRE) mod S and (AOLE <= x+l-1 <= ADRE) mod S then the packet should be acknowledged. 
 If x and 1 satisfy (FCLE <= x <= ADRE) mod S and (FCLE <= x+l-1 <= ADRE) mod S then x can also be delivered 
to the user; however, ordered delivery requires that x = FCLE. A packet is not in a range only if all 
of it lies outside a range. When a packet falls in more than one range, precedence is ADR, then AOR, 
then DR. When a packet falls in the AOR then an ACK should be sent, even if a packet has to be created. 
The ACK will specify the current left window edge. This as- sures acknowledgment of all duplicates. ADRE 
is exactly the maximum sequence number ever "advertised" through the flow control window, plus one. This 
allows for controls to be accepted even though permission for them may never have been explicitly given. 
Of course, each time a control with a sequence number equal to the ADRE is sent, the ADRE must be incremented 
by one. Appendix B: Window Size Setting To demonstrate the idea of an optimistic policy for window 
size setting, a method for setting the re- ceive window size is given [6]. The scheme satisfies the flow 
control goals discussed earlier. Several parameters have been vaguely unspecified since they can be determined 
only after considerable testing and measurement of a specific implementa- tion. First, some notation: 
B --Total bandwidth of the protocol, given unlimited user resources N --The number of connections RTD 
--Round trip delay between hosts CONGEST-- A congestion factor which reflects available protocol module 
resources (CONGEST =< I) WLT --The long term window W --The current window AVWT --Weighting coefficient 
for available buffer space OLDWT --Weighting coefficient for old window (OLDWT = I - AVWT) Tot --Total 
user buffer space Avail --The unfilled part of Tot The long term window might look like: WLT = B/N * 
RTD * CONGEST. The algorithm used to update the current window is the following. Upon the processing 
of a user's re- ceive request (buffer offering), the local receive window is set so that: W = MINIMUM(WLT, 
Tot). Each time a packet is sent for this connection, the local protocol module sets the receive window 
and the packet header window size field so that W = (AVWT * Avail/Tot) * WLT + (OLDWT * W) (for nonzero 
Tot) and W = OLDWT * W (for Tot = 0). It is important to note that a user's receive buffer is returned 
when an End-of-Letter is received. Thus, a s~all letter sent to a large buffer can cause the Avail and 
Tot to vary abruptly, even though there may be a smooth flow of letters. This window size setting scheme 
meets the goals mentioned in section 3 in the following ways: WLT is dependent upon the number of the 
connections, thereby administering fairness among connections. It also considers the level of congestion 
in the receiving protocol module, assuming some measure of resource availability can be provided. The 
window size will never exceed the bandwidth allocated to the connection. The algorithm may sometimes 
give credit to a "well behaving" process by setting his window to greater than the actual buffer available. 
This window will be reduced if the process does not supply new receive buffers promptly. The current 
window size is dependent upon previous window sizes and upon the rate at which the pro- cess makes letter 
space available. If a process fails to make such space available, its receive window will be reduced 
by OLDWT every time a packet is sent. (A threshold mechanism, by which a window is set to zero when it 
is reduced below the threshold, may be appropriate.) The algorithm can be modified slightly to support 
high throughput for high precedence connections. Parameter WLT can be made dependent on some criterion 
for the high priority traffic. Catego- ries of priority can be used with some guaranteed service (part 
of the bandwidth) given the highest priority categories. 
			
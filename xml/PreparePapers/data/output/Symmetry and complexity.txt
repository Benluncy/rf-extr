
 Symmetry and Complexity 123 Robert Be&#38;1141 L6sz16 Babal ~ , P&#38;l Tak&#38;csi-Nagyl Abstract 
We examine the effect of symmetry on the complexity of Boolean functions and find a remarkably tight 
hier­archy. Generalizing the fact that all symmetric Boolean functions belong to (nonuniform) Z CO, we 
find that the complexity of the class of Boolean functions admitting a given group of symmetries is essentially 
determined by a single parameter of that group. Let G be a permutation group acting on the set of n Boolean 
variables. Let 7(G) denote the set of Boolean functions on n variables which are invariant under G. Let 
~ denote a sequence G. < Sym(Q.) of groups (/S2.[ = n). We say that the language L ~ {O, 1}* belongs 
to the symmetry class ~(~) if the indicator function of L n {O, l}n belongs to Y(Gn) for every n. Following 
Clote and Kranakis, we consider the pa­rameter s(G), the number of orbits of G on the set {O, l} . We 
show that (a) all functions in F(G) are computable by circuits of size, polynomial in s(G) and depth, 
polynomial in log s(G); (b) there exist functions in 3(G) which cannot be computed by circuits of size 
< s(G)/(2 log s(G)). While part (b) is obtained by straightforward count­ing, it demonstrates that part 
(a) is tight. The result in particular confirms the following conjecture of Clote and Kranakis: if s(Gn 
) is polynomially bounded (where G. < S.) then F(g) ~ NC (nonuniform). If in addi­tion the groups are 
transitive, we prove that the left hand side is actually in TCO. oT&#38; ~e~e=ch was pmti~y supported 
by NSF Gr~ts CCR 8710078 and CGR 9014562 1Department of Computer Science, University of Chicago, Chicago, 
Illinois 60637 2 E~tv~s University, Budapest, Hungary H-lo88 31aci@cs.uchicago .edu 4beals@cs.uchicago. 
edu Permission to copy without fee all or part of this material is granted provided that the copies ara 
not made or distributed for diremt GommerGial advantaga, the ACM copyright notice and the title of the 
publication and its data appear, and notice is given that copying is by permission of the Association 
for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or spacific permission. 
24th ANNUAL ACM STOC -5/92/VICTORIA, B. C., CANADA ~ 1992 A(JM ().89791-51 2-7/92 JOO04/0438...$~ .50 
The proof of the main result involves nontrivial el­ementary asymptotic structure theory of permutation 
groups; and a delicate analysis (under new circum­stances) of algorithmic techniques developed largely 
by E. M. Luks in the context of graph isomorphism testing. In the context of isomorphism of sets under 
group action, uniform versions of our results are obtained. 1 Introduction Let Q= {l,.. ., n} and let 
Sym(Q) denote the symmet­ric group acting on !2, i.e. the group of all permutations of !2. Any permutation 
rJ c Sym(fl) naturally induces an action on {O, I}n: for z = (%1, . . .,zn) E {O, l}m, let aY = (Zl,, 
. . . . zn~), where i = io- . We also obtain an action on the set of all Boolean functions ~ : {O, l}n 
-+ {O, 1} by setting ~ (x) = ~(x ). The automorphism group Aut(f) of a Boolean function f consists of 
all a such that f = ~. The symmetric Boolean functions f are defined by the property Aut( f ) = Sym(Q). 
It is well known that these functions belong to a low non-uniform complexity class: non-uniform TCO. 
(For a more detailed study of symmetric functions, see [FKPS].) This simple observation suggests the 
possibility of deeper links between the automorphism group and the complexity of a Boolean function. 
A systematic study of this connection was initiated by P. Clote and E. Kranakis [CK]. Let us define the 
symmetry class Y(G) as the set of Boolean functions f such that G < Aut(j) (the func­tions invariant 
under G). Let ~ denote a sequence Gn < Sym(Q.) of groups (IQ. I = n). We say that the language L ~ {O, 
1}* belongs to the symmetry class 7(G) if the indicator function of L n {O, l}n belongs to F(Gn) for 
every n. Observing that groups having polynomially bounded index in the symmetric group S. have extremely 
sim­ple structure, Clote and Kranakis JCK1 prove that for such sequences ~, ~(~) C TCO (nonuniform). 
They also point out that the really relevant parameter of the groups G~ should be their number of orbits 
in their induced action on {O, 1}n. For G ~ Sym(f2), let s(G) denote the number of string-orbits of 
G, i.e. the number of orbits of the in­duced G-action on {O, l}~. Clote and Kranakis state the following 
beautiful con­jecture [CK, Conj. 33, p. 588] (Conj. 8, p. 65 in the conference paper). This conjecture 
has now become a corollary to our main result. Theorem 1.1 Let g be a sequence of permutation groups 
with polynomially bounded number of string­orbits (i.e. s(G~) = no(l)). Then the symmetry class ~(~) 
is in non-uniform NC. Indeed we prove more generally that the complexity of the symmetry class 7(G) is 
essentially determined by the number s(G) of string-orbits. Theorem 1.2 Let G < Sym(ft). Then (a) all 
func­tions in the symmetry class 3(G) can be computed by circuits of size, polynomial in s(G), and depth, 
polynomial in log(s(G)). (b) There exist functions in F(G) which cannot be computed by circuits of size 
< s(G)/(2 log s(G)). The proof of part (b) is straightforward counting (cf. [Sha], [Lup]). It shows, 
however, that, curiously, unless such a trivial reason prevents the given symmetry class to be recognized 
by circuits of a given size, they will immediately be recognizable with this size in a highly parallel 
manner. In the case of transitive groups, we have an even stronger result. Theorem 1.3 Let g = {G. } 
be a sequence of tran­sitive permutation groups with polynomialiy bounded number of string-orbits (i.e. 
s(Gn) = nO(lJ). Then the symmetry class 3(G) is in non-uniform TCO. These questions are closely related 
to the following gen­eralization of the Graph Isomorphism Problem (Luks [Lul]): String-isomorphism under 
G-action. Let G ~ Sym(f2) (Q = {1,..., n}) and t, y E {O, I}m. Decide whether or not z and y are G-equivalent 
(i.e. belong to the same G-orbit). If so, find the coset of Aut(z) consisting of those u~Gfor which x 
= y. Luks has shown that this problem (assuming G is given by a list of generators) is solvable in polynomial 
time for certain classes of groups, but in general the problem is at least as hard aa graph isomorphism 
[Lul]. On the other hand, at this moment it seems hopeless to parallelize Luks s solutions even in the 
case of 2-groups; the latter would be equivalent to NC-solvability of iso­morphism for trivalent graphs, 
a major open problem in the area [LM]. Our main auxiliary result pertains to this problem and gives an 
upper bound on its uniform complexity. Theorem 1.4 Given a permutation group G by a list of generators, 
one ean solve the string-isomorphism prob­lem under G-action by uniform circuits of size polyno­mia[ 
in s(G) and depth polynomial in log(s(G)). The proof of this result requires the NC-algorithm for basic 
permutation group manipulation [BLS] and therefore it is not elementary (recall that the [BLS] al­gorithm 
depends on consequences of the classification of finite simple groups). This difficulty can be avoided 
if we are interested in the inherently nonuniform problems posed by our main theorem; in this case we 
can ascer­tain that only a small number of groups are encountered throughout the algorithm, and we may 
assume (nonuni­formly) that everything we need about these groups is wired into our circuits in advance. 
Even this elementary proof, however, requires non­trivial estimates from asymptotic group theory [Ba2,3], 
[Py], [BaP].  2 Preliminaries For s = s(n) define NC(s) to be the class of languages computable by nonuniform 
boolean circuits of size S*(l) and depth (log s) O(l). NC1 (s) is defined analogously (depth = O(log 
s)). With a common abuse of terminol­ogy, we will use NC(s) and NC1 (s) to refer to function classes 
as well. We will construct NC(S(G)) circuits to compute the class F(G) of functions admitting G as a 
subgroup of their automorphism group. For u c Q the stabilizer G. is defined as G. = {oc Glu = u}. If 
B S Q we denote by G{B} = {u E G I l? = l?}, the setwise stabilizer of B. We use GB to denote the pointwise 
stabilizer: GB = f)tieBGu. If G = G{B1 we say that B is G­stable. For B < Q,u ESym(Q), if B = B weuse 
UB to denote the restriction of u to B. If B is G­stable, weset GB = {aB Ia c G}. If Gisthe full symmetric 
or the alternating group then we call G a giant. A c Q is a block of imprimitivity if Vu E G, either 
AU = Aor A n A= 0. G is primitive if the only blocks of imprimitivity are Q and the sin­gletons. For 
gl, gz c G [gl, gz] = glgzgl-lgz-l de­notes the commutator of gl and gz, For M, N < G [M,N]=([m,n]Im 
EM,ncN)will stand forthe mutual commutator of M and N. A structure forest F for a permutation group G 
~ Sym(f2) is a forest on which G acts as automorphisms such that the leaves form the permutation domain 
Q and the roots correspond to orbits. Each vertex w can 1. For v c Li, L(v) s L. beidentified with ablockof 
imprimitivity B(v) of the 2.G/Ki YH. G-action on fl, consisting of all leaves below v. l?(v) will denote 
the set of blocks corresponding to the chil-3. For v c Li, Ki R L(v) IC I. dren of the node v, i.e. 
B(v) = {B(u) I uis a child Conversely, for transitive G the third condition implies ofv}. We refer to 
Il?(v)l as the size of the node v. that G is the wreath product of L(v) by G/Ki, In any L(v) < Sym(l?(v)) 
and H(v) < Sym(B(v)) shall denote case Ki ~ L(v)ICJI and G < L(v)/ (G/Ki). the action of Go on l?(v) 
and B(v) respectively. A node We quote a classical result of Holder (cf. Sec.5. 3. v is primitive if 
H(v) is primitive. A node v is called a [KM]). giant node if H(v) is a giant. We call a structure for­ 
 est F primitive if all of its nodes are primitive. If the Theorem 2.2 (H61der) Provided that n # 2,6, 
group is transitive then the structure forest is a struc-Aut(sn) H Sn. 0 ture tree. Here we deviate somewhat 
from the standard terminology, because our primitive structure forest(tree) We represent the coset Go 
by the element u to­is what is usually called a structure forest(tree). If G gether with a set of generators 
for G. Let a string is a group with t orbits, its structure forest consists of $=(zl, . . ..zn ) c {O, 
l}n be fixed. For a, b E !J let t trees 2!1, ..., Tt. Li denotes the set of nodes on level a N b denote 
that x= = Xb. We use the followingi; Lo consists of the roots. We call ki,i = IB(v) I (num­handy notation 
introduced by Luks: For B ~ ~ and ber of children) the degree of Ci in Tj. The subscript j K ~ Sym($l) 
define CB(K) to be {a G K I b -b for will be omitted if G is transitive. ITi will stand for the all b 
E B}. We quote three basic observations, made bypointwise stabilizer of level i. Clearly Ki a G since 
Ki Luks. is the kernel of the G-action on Li. The quotient group G/Ki acts faithfully on .Ci. Proposition 
2.3 We call a group G -Q = H1 x ...x H, a subdirect product of the groups Hi if for every i, mi(G) = 
H;, (a)C~,.~,(K) = CB,(CB,(K)) where ~~ : Q + Hi is the it~ projection. our analY. (b)C~(K, U Kz) = CB(K,) 
U C~(Kz) sis will depend on the following (folklore) lemma (cf. Scott[Sc], Luks[Lu3]). (c)If G < Sym(f2) 
and B s Q is G-stable, then C~(G) is a subgroup of G, and for u c Sym(f2), CB(GU) Lemma 2.1 Let G -Q 
= HI x ...xH. beasubdirect is either empty or a right coset of CB (G). product, where each Hi is a simple 
group. Then after some rearrangement of the factors, we may write The string stabilizer problem is the 
problem of deter­ mining the coset Co (Ga) for some G < Sym(i2), a E Q = (HI x... xHil) x (Hil+l x . 
. . XHi2) X Sym(fl), x E {O, l}n. For the purposes of recursive al­. . . x (H~r_l+l X . . . x Hi. ) gorithms, 
we consider the more general problem of de­ termining CB (Gu), where B is a G-stable set. Formally, 
such that Hij+l z Hij+2 z ...E Hij+l for a~lO< j < . Input: G < Sym(0), a E Sym(f2), x E {O, 1} , and 
B r 1 (where i. = O), and a G-stable subset of ~. G = diag(H1 x . . . X Hil) X diag(~il+l X . . . X 
Hi2) x Output: CB(Ga). . . . x diag(lfi,_l+l X . . . X Hi.), The nonuniform string-stabilizer problem 
is the problem (i.e after appropriate identifications, G consists of the of determining CB (Gu) by nonuniform 
circuits with in­ eiements of the form (~, ....a)(~, ..../3)...(~, ....~)). put u E Sym(Ll). G, B, and 
x are wired into the circuit. 1 As shown by Luks, the string-stabilizer problem is Let L and H be permutation 
groups on sets A and equivalent to the string-isomorphism problem stated B, respectively. We define the 
wreath product of L bY in the Introduction. Indeed, H, denoted L 1 H, as the group of all permutations 
Proposition 2.4 (Luks) m6Sym(A xB)suchthat foraEA,b EB,we The string-isomorphism problem is TCO-equivalent 
to have (a, b)r = (a , b ), where for each b E B, ab is the string-stabilizer problem. an arbitrary element 
of L, and ~ c H. For different b s the permutations Ub are chosen independently, so Proofi Let z, y c 
{O, 1} , and a c Sym(fl) such that lLIHl = lLll~llH1. Forb e B let A~ = Ax{b} ~ Axl?. Y = x (if such 
a u exists it can be found in TCO). The Ab s form a system of imprimitivity for L 1H. Let Then the set 
{r g G I x = y} is exactly (CB(GO))U-l. T be a structure tree for G = L ~H acting on fl = A x B Note 
that if x, G and B are fixed, u depends only on y. such that for some i the nodes in .&#38; correspond 
to the Conversely, let u E Sym(f2), x 6 {O, l}n. Set y = z - , Ab s. T has the following properties: 
and read the above equality backward. D Proposition 2.5 An NC(S(G)) solution of the string­stabilizer 
problem implies Theorem 1.2. Proof: For f G Y(G), computing f reduces in (nonuni­form) TC (s(G)) to the 
string-isomorphism problem, as the set of strings on which f is 1 is a union of G-orbits. The circuit 
recognizes these orbits in parallel, and com­putes the OR of the result. To recognize a single orbit, 
we wire an orbit representative x into the circuit, which on input y computes a a E Sym(Cl) with y = 
x, and outputs 1 if Ca(Gu) is nonempty. 0 The rest of the paper concerns the string stabilizer problem. 
 3 Structure of permutation groups with large alternating  groups acting on their blocks Let Gbeagroup. 
H s Gisacomplement to K SG if HnK=land HK=G. For G~Sym(f2) anda system of imprimitivity B of G we say 
that u ~ G is clean if for every B c l?, if 1? = B then c acts trivially on B. A clean subgroup consists 
of clean elements. Let K be the kernel of the G-action on B. We say that H is a clean complement to K 
if H is a complement to K and it is clean w .r.t. l?. Clearly H H G/K. The observation below is straightforward 
from the definition of a clean complement. Observation 3.1 If H is a clean complement to K, w. r.t. the 
system of imprimitivity B then for every B E B we have G~~l = KB. O The following result is proved in 
[Ba3] (cf. [BKL, Sec. lo]). Lemma 3.2 Let G < Sym(C?) have a depth two struc­ ture tree T such that H(root) 
= AkO and kO ~ 4kl. Then K1 has a clean complement. Proof: Let Cl = {VI, ..., v~O} be level 1 of T. For 
r c G let T denote the action of T on L1. By Bertrand s postulate there is a prime p between Itl and 
ko/2. Take x c G such that 7 is a p-cycle. As kl < p there is an m such that p does not divide m and 
Tm is clean. W.1.o.g. m = 1, and m permutes VI, ..., up cyclically and fixes vi and each of its children 
for i = p+ 1, . . . . ko. Similarly, there exists a clean # G G such that ~ = (vp,..., v21)l). Thus a 
:= [m, r ] is a clean 3-cycle. Let Ui be a conjugate of u with ~i = (vi, Vi+I, %.). (Note that conjugates 
of clean elements are clean.) It is easy to see that for k. odd, the group generated by ul, u3, cr5, 
..., Uko-2 is a clean complement to K1. If ko is even then take A = (al, us)~~o N A4. NOW A,cr4, fY6, 
..., ~&#38;z generate a clean complement to K1. u Note that a clean complement does not necessarily exist 
if ll(root) = Sk,, even if k. is as large as lQ1/2, as the following example shows. Let kl = 2 and G 
? &#38; and let vi(1), vi ( 1) denote the two children of node vi on level 1 (1 < i < ko). For each a 
c S kOlet CT*c G be such that u* (vi) = vo(i) and ~ (u(j)) = %(i)(sw(~)~) (j = 1,2 ; 1< i < ko). Note 
that K1 is the identity in this case and it does not have a clean complement, since each element of G 
which acts on L1 as an odd per­mutation performs a transposition on the fixed blocks. A slight extension 
of the proof of Lemma 3.2 yields the following generalization. Lemma 3.3 Let G ~ Sym(f2) be a group with 
t orbits. Assume G has a structure forest consisting of depth two trees Tl, . . ., Tt such that I. minj 
ko,j z 4 maxj kl,j. 2. G/Kl = AkO,l x . . . x Ako,,, where Ako,j acts on the ko,j children of the root 
of Tj. Then K1 has a clean complement H. 0 Assume that G < Sym($2) is a transitive permutation group 
satisfying the conditions of Lemma 3.2. As K1 has a clean complement we can identify t 1 with the set 
B(root) x B, where Il?l = IB(w)I for each node w G f?(root). We identify B(w) with {w} x B such that 
for each b c B, I?(root) x {ZJ} is an orbit of H. For a c K1, let UW := aBtwJ, and for a ~ Sym(B), let 
&#38; act on fl = B(root) x B by permuting the second components. For S < Sym(B), let S(w) = {5W I a 
c S}, Note that our groups L(w) arise as L(w) = Lw for some L s Sym(13). The following theorem appears 
in [Ba3]. Theorem 3.4 Let G < Sym(f2) be a transitive group satisfying the conditions of Lemma 3..2. 
Let L = L(w) for some w c B(root). Then L has normal subgroups M. s Ml, and G has normal subgroups N1 
and No, No < N1 < Kl, such that 1. NI = (Mlw x.. .x MIWkO)nK1 and No = MOW x ...x Mowk . Nl~\~(%) 2. 
= MIW X ...MIW - X MIW + X ... X  MIW*O . 3. L/Ml = I{l /N1. Ml /Mo is abelian. 4. 5. (~,/N,) = {(a, 
~:gl a, = 1}.  Proof: ,$2 Let Ml := (1, U,03,..., OkO) c K1 }. Clearly til q L. - Claim 3.5 UC M1~(a, 
a-l,l, . . ..l)GKl Proof of Claim: (+) Conjugating (a, a-l, 1,..., 1) by a proper element of If we get 
(l, a, c-l, 1, ..., 1) E Kl, so by the definition of Ml, u C Ml. (~) Assume that @ = (1, u,c73,.. .,a~,) 
= K1. First we show that some element of the form (I, a,l, u q,..., a ko ) also belongs to K1. Indeed 
let ~ = (v1, W, v3) and set @= [7,3] = T-18-173 = (C;l, U, U-1U3, 1,..., 1). Conjugating p by an appropriate 
element of H we get .Q which has (1, u, 1) in the first three positions. Now e = [e ,~-n = (u$~-l!u...!l) 
0 The Claim clearly implies 2, using the definition of N1 in 1. 9 Let us consider the homomorphism p 
: KI A L/Nl defined by: p(ul, ..., CTko)= U2M1 It suffices to show that Ker(p) = N1. Obviously Ker(p) 
> N1. On the other hand suppose that m 6Ker(p). This implies that 7rz c Ml. We are going to prove that 
ml, rs, . . . . xkO are also in Ml. By the Claim there isa# c K1 with # = (T2,T; ,1,..., 1). So md = 
(7r17rz, l,7r3, . . .,mo) so we infer that 7rl, 7r3, ..., ~&#38; E Ml. LetkfO:= {a ELl(a,l,...,l) CKl}. 
4: It is enough to prove that MO z [Ml, MI]. Assume that a, u c Ml. This implies that (a, a-l, 1,..., 
1), (a , a -l,l,..., 1) and the inverses of their conjugates (a-l,l,u,l,...,l), (u -1, 1,(7 , 1, . ...1) 
arein K1. So the product of these elements is ([u, u ], 1, ..., 1) c K1, which means that [a, u ] c MO. 
5 Suppose (q,. . . , U&#38;) G N1/~o, (The ui are cosets of M..) As u~ G M1/Mo for each 1 < is ko 1 
there is a ~(i) G N1/fVO with (r(i))~ = a~-l, (~(i))kO = ui and (m(i))j = 1 otherwise. So we have that 
ko-1 (0,,..., ~ko) ~ do = (L... >Lfjui). i=l i=l but then ~~~1 Ui = iZfo by the definition of M., proving 
5. 0 4 Asymptotic estimates for per­mutation groups In this section we review some inequalities on the 
num­ber of string-orbits of a permutation group and bounds on the order of primitive permutation groups. 
The fol­lowing is immediate: Fact 4.1 IfH s G then s(G) s s(H) s s(G)IG : H]. Let G be a transitive group 
acting on a set !2, 1$21= n. Let {$21,..., ~k } denote a system of imprimitivity of G with block size 
b(1 ~ 6 s n ; M = n). If Li denotes the permutation group of degree b induced on C?i by the setwise stabilizer 
of L?i in G then the groups L~ z L are isomorphic transitive permutation groups. Proposition 4.2 min(s(L) 
 1, k) < log s(G). Proofi G < L 1Sk, which has (k+ y)-l) string-orbits, so by Fact 4.1 s(G) z (k+sy)-l). 
This implies the Proposition. 0 Since b ~ s(L) 1, we obtain in particular: Corollary 4.3 min(b, k) s 
log s(G). 0 Proposition 4.4 Let A be a block of imprimitivity of G and L = G~~l (the permutation grotip 
induced by the setwise stabilizer of A on A). Then s(L) s s(G). Proofi Since A is a block of G, for every 
nonempty X, Y~A, if XT= Yforsomer~G thenr~G{A} and therefore XT = Y for r) = TA E L. So two subsets of 
A are in the same G-orbit if and only if they are in the same L-orbit. 0 By using the following elementary 
estimate [Ba 2,3] we are able to avoid the use of the Classification of Finite Simple Groups. Theorem 
4.5 Let G be a primitive permutation group of degree n not containing An. Then IGI < exp(4@og2n).D Let 
cz z 8 be a constant such that for all x > cz, 2=/2 > exp(4@log2 x) and z logic < Z2/8. Lemma 4.6 Let 
G ~ Sym(fl) and T be a structure forest for G. Assume that for a node w E T with k = IB(w)I, C2 ~ k s 
s(L(w)) s logs(G) and k! ~ s(G). Then Ak ~ L(w). Proofi Suppose that Ak < L(w). If L w) is primitive 
then by Theorem 4.5 IL(w)/ < exp (4 J klog2k), On the other hand 2k > 2k/2, k log k ~ log s(G) > s(L(w)) 
~ IL(w) I ­ a contradiction (assuming k > C2). If L(w) is imprimi­tive then L(w) ~ Sm 1S1 for some m, 
1>1 with ml = k. so k log k ~ logs(G) > s(L(w)) which is impossible for ml = k z C2. Cl The following 
result serves as the basis of the struc­ture to be derived in Section 5. We sketch the proof in the Appendix. 
Theorem 4.7 (BaP) Let G < Sym(Q), Ifll = n, and F a primitive structure forest for G. Then for any t> 
1, if F has no giant node of degree > t then for some absolute constant c1.CI 5 Transitive Case: Structure 
Theory Let G ~ Sym(t2) be transitive and T a primitive struc­ture tree for G. By Theorem 4.7 T has a 
level, which we will call the explosion level, where for all nodes u, the group H(u) contains an alternating 
group of degree at least n/(cl log s(G)). Let us contract the levels below and above the explosion level 
to one level each (keeping the root separate). We obtain a depth three structure tree with kok2 < c1 
logs(G). So we conclude: Theorem 5.1 For every transitive G s Sym(f2) there exists a depth three structure 
tree T, such that kok2 s c1 logs(G) and the nodes on levei 1 are giants. 0 Definition: For w a node in 
T, we denote by $W : GW -i Sym(B(w)) the homomorphism obtained by re­striction to B(w) i.e. @W(L7) = 
a~(wl. Now we can state a refinement of Theorem 5.1. Theorem 5.2 Let G < Sym(Q) be transitive. If there 
exists a depth three structure tree with giants of degree kl ~ max(l + ko, 7) on level 1 then there exists 
another depth three structure tree T* with k; s ko, k; = kl such that the action of K; on level 2 contains 
a full direct product of k; copies of Ahl. Proof: For S < G set ~ = S/(S nK2) (note SnK2 ~S as K2 ~ G). 
For each node u on level 1 we have that Akl ~ @u(~.). We need the following Claim 5.? Let G be as above 
and u a node on level 1. Then ~U (Kl) still contains Ahl. Proof of Claim: As @v(~1 ) 4 ~u (t$u) we ha~e 
$h, (l &#38;(i?l)afikl . For kl Z 5, Akl is simple, so Ak,@&#38;(~l) is either Akl or the identity. We 
show-second case is impossible. Indeed ~ ~ti )~&#38; (Kl ) is a quotient ( group of &#38;u/~l < S m(k 
 1). On the other hand, jl Akl n I/Iu(fiI) = 1 wo ld imply l~ti(~ti) : @u(~l)l ~ [Akl I = kl!, a contradiction 
because k. < kl. 0 We have that El = K1 /K2 is a sub direct power of Ah,. By Theorem 2.1, Kl /K2 is a 
direct power of some diag(Ah, x . . . x Akl ). If the diagonal constituents are single Akl s, we are 
done. If not, we regroup the nodes on levels 1 and 2. Let D1, ..., ~k; be the partition of the nodes 
at level 1 corresponding to the diagonal constituents. Each D~ will be a new level 1 node. For nodes 
u, v E Di, the diagonal linking of H(u) and n(v) gives us a unique bijection uj + vj for 1 < j < kl between 
the children U1, . . . . ukl of u and the children Vi, ..., vhl of v, as by Holder s theorem [KM p.43] 
the automorphism group of Sk or Ak is sk for k > 6. We regroup the level 2 nodes as follows. For 1< i 
< k; and l~j~kl,letl?ij= LL@t~(w). Claim 5.4 The Bij form a system of imprimitivity. From the claim it 
follows that the regrouped tree has the desired properties. Proof of Claim: It suffices to show that 
for any r in G if u = v and (u ) = v for u,v, u , v c D1 then u; = V1 implies (u~ )~ = vj. Assume the 
contrary. So (u~) = V; for some j # 1. Take a ~ c K which fixes U1 but moves uj. The action of rtw-1 
on l?(u) and B(d) is different, so (~K-r-l)~(UJu~(U ) is not a diagonal element but Ttw-1 is in K1, a 
contradiction. 0 As a consequence of Theorem 5.2 we know that for every permutation group G there exists 
a depth three structure tree T either with k. ,kl ,kz ~ C2log s(G) (C2 > 4) or with the following properties: 
 kok2 ~ Cl log s(G).  kl ~ 4 log s(G).  For every node u on level 1, H(u) is a giant.  K1 /1<2 contains 
(Akl )ko.  Definitions: The socle of a finite group G denoted by SOC(G) is the subgroup generated by 
all minimal normal subgroups of G. Theorem 5.5 Let G s Sym(Q) and T a structure tree for G as above. 
If k2! z max(s(G), 7!) and kl > max(4 logs(G), 52) then SOC(K2) = (Akg)k k . We need a calculation. Proposition 
5.6 Let b, k, m be positive integers. If b!z mz2b,b>4, k~max(b,52) and then k < 310gm. Proof: We consider 
three cases: 1. 2b ~ 2k2. Then ~ > (=b+~- ) > 2b  ~ b! 7 () ~ soin this casek~logm, 2. 2k2 > 2b> 
2k. Then assuming k ~ 52. Therefore k <3 log m. 3. 2k ~ 2b. Then  for b ~ 5, a contradiction. So under 
our conditions only the first two cases are possible. 0 Proof of Theorem 5.5: Let w be a node on level 
2. By Proposition 4.2, s(L(w)) ~ log s(G). From our ass­umption k=! = (1.B(w)I) ! ~ s(G), using Lemma 
4.6 we can conclude that Akz < L(w). Following an argument similar to that in the proof of Proposition 
5.3 it can be shown that @W((Kl )W) still contains a giant. Let p= denote the restriction homomorph~m 
111 ~ Sym(L12). As ~~/~z ~~ (A l)kO we can s~ ~~ := p~l((A l)kO) and K2 = K1 n K=. Obviously K1 a KI. 
Claim 5.7 For w C&#38;, @w(K=) ~ @W(~=) ~ Ak,. Proof of Claim: K1 /~1 is an elementary abelian 2-group 
as for all T ~ K1 /~1 and for all v on level 1, (r2)~( l is an even permutation of B(v). Moreover  @W 
((KI)w )/IJ$w~(iI)w) is a quotient group of a sub­group of ~1/K1, so it is also an elementary abelian 
2-group. So @W((~~)W) ~ A ,. Since (1/4)kl > log s(G) ~ s(L(w)) ~ k=, by Lemma 3.3 ~= has a clean complement 
in ~1. Using Observation 3.1 we conclude ,that @W ((@I)w ) = ?bw(~2) z -&#38;2 for each w on level 2. 
1 Note that S := SOC(K2) is a subdirect power of A ,. Then by Lemma 2.1, S is a direct power of some 
diag(Ak, x . . . x Abz ). But for nodes on level 2, their corresponding Akz s belonging to the same diagonal 
constituent is a G-invariant relation. The only non­trivial system of imprimitivity on level 2 is the 
set {~(u) I u is on level 1}. so either S = (AkJklkO or S ~ (Akz )ko is a direct product of k. subgroups 
of the form diag(A a x . . . x Akz), by Theorem 2.2. We show that the latter case cannot happen. If it 
did then for any v on the first level we would have that, A l X/ika < L(v) < Skl XS =. So (2 %:1-1) (s(G)) 
~ s(L(v)) = k=! However this inequality is impossible by Proposition 5.6 with m= s(G), k = kl, and b= 
k=. o Corollary 5.8 Let G satisfy the conditions of Theo­rem 5.5. Then (Ak, ~A ,)k ~ K2 ~ (S , ~&#38;,)kO.o 
6 Luks s Halving Algorithm We describe here an algorithm due to Luks for comput­ ing CB(GU), where B 
is G stable, Let Xl, . . . . xk be a system of imprimitivity for G. These blocks will be fixed at the 
start of the algorithm: the algorithm makes recusive calls to itself, and B will always be a union of 
some of the blocks. We sssume that we have a subrou­ tine for computing C xi (Gu), which runs in parallel 
in time 1?with w processors. Suppose B = Uie{ Xi If III = 1, we use the subrou­ tine for C x, (Go). Otherwise 
we halve the set I. Let 1 = 11 U 12 with [11] = 1/1[/2] and [12[ = [11[/21. Let B1 = (Ji~Il Xi and let 
Bz = lJicI, Xi. Let G* = G{ B,} and {rl, . . ..r~ } be coset representatives for G* in G. Use the Halving 
Algorithm recursively in parallel to find CBl(CB,(G*~ju)) for all j c {1,.. .,r}. In the nonuniform model, 
we can suppose that for each of a system of string-orbit representatives, the groups CB (G) encountered, 
and the coset representa­tives Ti are known in advance. Then to determine the coset CB (Gu) it suffices 
to find a single i for which 6 BI (6 &#38; (G*~ia)) k nOIIt?II@y. In the uniform model, G* can be found 
in NC us­ing the algorithms of [BLS]. The Ti can be found in NC(21ZI) by considering the action of G 
on the power set of 1. After calculating the CBI (CBZ (G* ria)), we use the following Lemma to paste 
them together to make CB(GU). Lemma 6.1 Suppose G* ~ Sym(f,l), rl, . ...7. are given, and (Ji G*T~ is 
known to be a single coset of some unknown group G. Then we can jind this coset in NC(r + IQI). Proof: 
The coset we want is Grl, so it suffices to find generators for G. We have GT1 = Ui G* Ti, so G = lJi 
G*r~T;l. Therefore G is generated by the generators of G* together with the quotients r~T1-1. We can 
reduce the number of generators to O(lfll) in NC using the algorithms of [BLS]. u The time and processor 
bound for the subroutine to compute Cx, (Gu), together with an easy induction on Ill, give US the following 
Lemma. Lemma 6.2 The halving algorithm runs in time poly­nomial in (M+ log IQ!) with polynomial in (4kw 
+ Ifll) many processors. Cl The halving algorithm can be used as the subroutine to compute Cx, (Gu) by 
picking a new block system, such as the one below X1 , . . .Xk in the structure tree. If the structure 
tree can be collapsed to a bounded num­ber of levels of degree O(log s(G)), then the halving al­gorithm 
can be used at every level of the structure tree in NC (S(G)). In other cases, we will need a separate 
algorithm for the lower part of the structure tree. 7 Algorithm: the transitive case This section represents 
the hard part of our algo­rithm. We begin with some simple observations: Observation 7.1 If H ~ G and 
IG : HI is polynomial in s(G) then the string-stabilizer problem for G reduces in NC1(S(G)) to the string-stabilizer 
problem for H. This reduction can be done uniformly if a system of coset representatives for IG : HI 
can be calculated. Observation 7.2 CB(Ga) can be found in NC(lG~ I+ lQ1). Indeed, we enumerate GB in 
parallel and determine which elements of (Gu)B stabilize the coloring of B. Observation 7.3 If B1, . 
. . . Bk is a system of imprim­ itivity for G, with L = G~~ll such that G is the wreath product of L 
by Ak, then CB(GU) can be found in NC(klLl + 1~1). If in addition L = Al~ll, then C~(GU) is essentially 
a counting problem, which can be solved in TCO. The above two observations require a comment. Once we 
find a subgroup of G whose action on B is the same as CB(G), to find CB (G) we need to add generators 
for GB (the pointwise stabilizer of B in G) to our generat­ing set. This is trivial in the nonuniform 
model, as GB can be calculated in advance. In the uniform model, we need the algorithms of [BLS] to construct 
GB in NC. Theorem 7.4 Let G ~ Sym(fl) be transitive. Then (a) all functions in the symmetry class F(G) 
can be computed by NC(S(G)) circuits. (b) There exist func­tions in 3(G) which cannot be computed by 
circuits of size less than s(G)/(2 log s(G)). Proof: Part (b) follows from straightforward counting (cf 
[Sha] ,[Lup]). Part (a) follows immediately from Theorem 7.5 For G < Sym(fl) transitive, Cn(Ga) can be 
calculated uniformly in NC(S(G)), Proof of Theorem 7.5: Assume that s(G) is known. First we construct 
a depth three structure tree T for G, such that kokz < c1 log s(G) and the nodes at level 1 are giants, 
as in Theorem 5.1. If kl ~ max(l + ko, 7) then modify T so that the action of 1<1 on level 2 con­tains 
a full direct product of k. copies of Akl, as in Theorem 5.2. We consider three cases: 1. /cl ~ C2log 
s(G). In this case we use the Halving Algorithm at each level of the structure tree.  2. ICz! > s(G). 
In this case k. is O(log log s(G)), so IG : K1 I ~ s(G) and it suffices to solve the string-stabilizer 
problem for K1. By Corollary 5.8 in this case (Akz 1Akl)kO < K1 ~ (SkQ 1Skl)~O, so the string-stabilizer 
problem is in TCO by Obser­vation 7.3. 3. kz! < s(G). In this case we use the halving --algo­rithm on 
the top level of the tree. When get down to a block B(u) with u at level 1, we know by The­orem 3.4 that 
the group L(u) acting on B(u) has a subgroup H which acts as a clean Ah, on the nodes at level 2. Also, 
by Theorem 3.4, the sub­group K2B(U) which fixes the nodes at level 2 has a subgroup N1 which acts as 
a full direct product inside kl 1 of the blocks on level 2. Since  IL(u) :HNII < 21K :N1[=21L :Mll 
< 21LI ~ 2k2! ~ 2s(G) it suffices to solve the set stabilizer problem for HN1. Let v be a child of u 
on level 2. IHN1 : (HN1)V I = kl ~ s(G), so it suffices to solve the set stabilizer problem for G* = 
(HN1 ).. Let B1 = B(v) and B2 = B(u) \ B(v). Then (G*)B2 is a full wreath product of All by Akl, and 
Iitll [ < kz! < s(G), so CB,(G*a) can be found in NC(S(G)) by Observation 7.3. Since IB11! < s(G), CB, 
(CB,(G*a)) can also be found in NC(S(G)) by Observation 7.2. In the uniform model, s(G) is not known. 
We can, however, calculate a lower bound s for s(G) such that assuming s(G) = s does not contradict all 
three of the above cases. The algorithm will then run in NC(s). The calculation ofs is discussed in Section 
10.CI 8 Reduction of the intransitive case The intransitive case can be reduced to the tran­sitive case 
using a variant of another algorithm of E. M. Luks [Lul] as follows: To find Cn(Gu), let A be the largest 
orbit of G on S2. Use the algorithm for the transitive case to find CA (Gu), and recursively find CQ\A 
(CA (Ga)). Note that in the nonuniform model, we already know the groups CA(G) and C Q\A(CA (G)) in advance. 
Lemma S.1 s((CA(G))n\A)) < s(G). Proofi By reordering, assume that A is an initial seg­ ment of ~. Let 
z denote (Zl, . . . . ~lAl). Let yl, 92 c {O, l}a\A. Th en yl and y2 are in different orbits of CA(G) 
if and only if X Y1 and X YZ are in different orbits of G, as for a c G, (z yI) = x y2 implies a E CA(G).CI 
Lemma 8.2 IAI ~ lf21/logs(G). Proofi G can have at most log s(G) orbits, so the largest, A, must contain 
at least a (1/ log s(G)) frac­tion of the points in Q. 0 Lemma 8.3 The number of recursive calls is O((log 
n)(logs(G))). Proofi By Lemma 8.1, s(G) does not increase during the recursive calls, and by Lemma 8.2, 
]Ql is decreased by a (1 1/ log s(G)) factor with each recursive call. 0 We now have proven the following 
 Theorem 8.4 Let G ~ Sym(fl). Then (a) all func­tions in the symmetry class Y(G) can be computed by IVC(S(G)) 
circuits. (b) There exist functions in F(G) which cannot be computed by circuits of size ~ s(G)/(2 log 
s(G)). In fact, we have Theorem 8.5 For all groups G < Sym(f2), Cn(Ga) can be calculated uniformly in 
NC(S(G)). This clearly implies Theorem 1.4. 9 The Algorithms Below we give pseudocode for the main string 
stabilizer algorithm. STRINGSTABIG, a, B, z] Input: G ~ Sym(f2), a c Sym(f2), B a G-stable subset of 
t-l, x ~ {o,l}IQI. Output : CB(Ga) \* This algorithm makes (J((log s(G))(log ISZI)) recur­sive calls 
to itself. */ Step 1: Let B1 ~ B be the largest orbit of G on B, andiet B2=B\B1. Step 2: Find GIU1 = 
TRANS-STAB[G, a, Bl]. Step 3: Recursively find G2UZ = STRINGSTABIGl, al, B2, z]. Step 4: Output G2U2. 
The following algorithm deals with the transitive case. TRANS-STAB[G, a, B] Input: G ~ Sym(fl),u c Sym($l), 
B ~ !2 an orbit of G. Output: CB(Ga) /* s(G) is assumed to be known. */  Step 1: Construct a primitive 
structure tree T for GB . Step 2: Construct a depth 3 structure tree T by collapsing the levels of T1 
above and below the largest giant. /X By theorem 4.7 we will have kOk2 ~ c1 log s(G). */ Step 3: if 
kl ~ max(l + k., 7) then modify T so that the action of K1 on level 2 contains the full direct product 
Akl 0. I* This is done by regrouping the nodes on levels 1 and 2 as in Theorem 5.2. */ Step 4: if kl 
< C2log s(G) then output HALVE[G, U, B, T, 1, true] and halt. /*In this case all three levels of T have 
degree less than C2log s(G), so the Halving Algorithm used all the way to the bottom level of T runs 
in NC(S(G)). */ Step 5: if k2! > s(G) then Calculate 71, . . . . rr coset representatives for K1 in G. 
output Ui C~(K1~;a), and halt. /* In this c~e r = IG :Kll < s(G). K1 contains (Akz ~Akl )ko by Theorem 
5.5. so the string stabilizer problem for K1 can be solved in NC by Observation 7.3. *I Step 6: Output 
HALVE[G, u, B, T, 1, false]. /* In this case we use the Halving Algorithm on the top level of T, and 
use the subroutine BOTTOM on the bottom two levels. In this case k2! ~ s(G). */ Next we describe the 
repeated halving procedure as applied in Steps 4 and 6 above. The parameter 1 de­scribes the current 
level in the structure tree. The pa­rameter bot is true if the halving algorithm is to be used at all 
levels of the tree. Otherwise, the procedure BOTTOM is used for the bottom two levels of the tree. HALVE[G, 
u, B, T, 1, bet] Input: G s Sym(f2), 0< Sym(f2), B a G-stable subset of $2, T a structure tree for a 
supergroup of G, and 1 a level of T such that B = Uiel B(ui) for some nodes ~; at level 1 of T, and bot 
a boolean flag indicating whether the halving algorithm is to be used recursively all the way to the 
leaves of T. Output: CB(GC) /* We use a subroutine BOTTOM for the bottom two levels of T unless the flag 
bat is set. */ Step 1: if [II = 1 then if bot then if ~ = 3 then Output CB (Gu) else HALVE[G, a, B, 
T, I + 1, bet] else BOTTOMIG, a, B]. /* In the case III = 1, bot = true, and ~= 3, the output CB(GU) 
is either Gu or 0 depend­ing on whether b ~ b where B = {b}. */ Step 2: Select {11, Iz} a partition of 
I with 111I = L+]. Lei B1 = LLCI,B(u~) andBz = B\B1. /* This partition maybe fixed in advance. */ Step 
3: Calculate G* = G{B,I, and {71,..., Tr} coset representatives for G : G . Step 4: For each 1 ~ j s 
r calcuiate G1ffj = HALVE[G* , Tju, B1 , T, 1, bet] . Step 5: Output (Jj~rHALVEIGl, aj, B2, T, ~, botl. 
 Finally, we describe the routine used in Step 6 of TRANS-STAB below the top level. (On the top level 
we use halving.) BOTTOMIG, a, B] Input: G ~ Sym(Q), u c Sym(fl), B a G-stable subset of Q. Output: CB(Ga) 
 /Y GB is assumed to have a depth 2 structure tree T with an alternating group H acting on level 1 as 
a clean complement to K1. This algorithm runs in NC(ko(kl!) + Ifll), and is used on the bottom two levels 
 of the structure tree in the case kz! < s(G). *1 Step 1: Construct N1 as in Theorem 3.4. I* ATl< K1 
acts as a full direct product on any lcl 1 of the blocks at level 1, and IK1 : Nll ~ kl!. */ Step 2: 
Select u a node at level 1. Let Bz = B(u) and B1 =B\B2. Step 3: Calculate rlj. . ., rr a system of coset 
rep­resentatives for (HN1 )U in HK1. Step 4: Find, for each1 < i < T,G ui = CB, (( HNl)u~iu). /* This 
can be done in NC(kO(kl!) + 1~1) by Observation 7.3 as (IIN1)U acts as a full wreath product on B1. 
*I Step 5: Find and output u; CB, (G* ffi). /* This can be done in NC(ko(kl!) + Ifll) by observation 
7.2. */ 10 Uniform vs. nonuniform To prove our main results (Theorems 1. 1 1 .3), we need the nonuniform 
version of Theorem 1.4 only. Below we indicate how to avoid the use of the NC algorithm [BLS] in this 
case. Proposition 10.1 G and z determine a set of O(n) groups which are the only groups encountered by 
the al­gorithm. Proof: G and z completely determine the groups encountered during the algorithm, as CB 
(Ga) is empty or a coset of CB(G). If we are using the Halving Algorithm down to level 1 of the structure 
tree, then the set of halvings corre­sponds to a binary tree with the leaves being the nodes at level 
1 of the structure tree. The Halving Algorithm can be thought of as performing a depth first traversal 
of this halving tree, each node of which is associated with a single group as follows: Associate the 
input group G with the root. The group G* which fixes the current halving is the input to the left child 
of the root. (The phase of the algorithm corresponding to the left child works simultaneously with all 
of the cosets of G* in G.) The output group of the left child is the input group of the right child (which 
again corresponds to a phase of the algorithm which works in parallel on many cosets of this group). 
Therefore, while the number of cosets encountered is large, the number of subgroups is linear in the 
number of points at level 1 of the structure tree. From this, it follows that the total number of subgroups 
 encountered by the string-stabilizer algorithm is linear in IQI.O Recall that in the nonuniform model, 
G and s are wired into the circuit. Therefore any operations which need to be performed on G, such as 
finding coset repre­ sentatives and generators for a subgroup and construct­ ing clean complements, 
can be done in advance. Thus we avoid using the [BLS] algorithm. Next we indicate hitherto ignored details, 
required in the uniform model, of the proof of Theorem 1.4, In the uniform model, generators for G are 
part of the the input to the algorithm, so we need to perform permutation group manipulations in NC, 
using the al­ gorithms of [BLS]. To construct the structure tree, we recognize giants and detect diagonal 
linking. In the Halving Algorithm, we construct pointwise stabilizers of sets, and we reduce large generating 
sets. In case 3 of Theorem 7.5, we construct clean complements. Also, s(G) is not known. Only the algorithm 
for the transitive case makes reference to s(G). We do not need s(G) to construct the depth three structure 
tree, as we simply construct a primitive structure tree and collapse the levels above and below the largest 
giant. Once this is done, we know by Theorem 4.7 that s(G) > 2kakO~ . In addition, if (A~, i A~, )~ ~ 
K1, then by Co~ollary 5.8 we know s(G) ~ min(k2 !, 2~Ii4). So we can calculate a lower bound s for s(G) 
as follows: 1. Initialize s to 2k kO~ 1. 2. If (A~, 1 A~,)kO $ K1 then let s = max(s, min(kz!, 2k J4)). 
  We then run the algorithm as if s(G) = s. By construc­tion of s, one of the cases of Theorem 7.5 will 
hold. The algorithm will run in NC(S), which is acceptable w s(G) ~ S. 11 Transitive Case : TCO result 
In this section we prove a stronger result in the nonuni­form model in the case that G is transitive 
and s(G) is polynomial in n. Theorem 11.1 Let ~ = {Gn} be a sequence of tmn­sitive permutation groups 
with polynomially bounded number of string-orbits (i.e. s(Gn) = no(l)). Then the symmetry class 3(G) 
is in non-uniform TC O. This is an easy consequence of the following: Theorem 11.2 If ~ is a family of 
transitive permu­tation groups Gn acting on an n element set $ln, and s(G~) s n for some positive constant 
c, then for all x E {O, I}n there is a TC circuit computing (on input m) CO(GU) . Note that in the nonuniform 
model, finding a single element of Ca(Ga) is equivalent to calculating Cn(Ga), since Cn(G) is known in 
advance. We need the the following generalization of Observation 7.1: Observation 11.3 Ij H $, G and 
s(H) is polynomial in n then the stn ng-stabthzer problem for G reduces to the string. stabili.ze~ problem 
for H in (nonuniform) ACl . In the case when n ~ s(G) the following stronger ver­sion of Proposition 
4.2 holds: Proposition 11.4 l~s(G) = nc, c ~ O then min(s(L) l,k) < 2C. Proofi By Proposition 4.2 k ~ 
clog n. By Fact 4.1, s(G) ~ s(L ~ s~) = (k+~(~)-l). As this estimate is symmetric in k and s(L) 1, we 
may assume that k = min(s(L), k). For n sufficiently large, n/(c log n)2 ~ 6. Therefore, Corollary 11.5 
Ifs(G) = n then ko, k2 s 2c. Proofi Proposition 11.4 and Theorem 5.1. 0 Proof of theorem 11.2: By Theorem 
5.2 there is a depth three structure tree T for G such that the action ko Let ~ :K1 + S~Ok~ of K1 on 
level 2 contains Akl . be the action of K1 on level 2. Let @ = $o-l(Akl ), and let F be the structure 
forest for G* consisting of the bottom two levels of T. Applying Lemma 3.3 to G*, we obtain a clean complement 
If to K!. Note that S(H) = (~ y,~;1)ko is polynomial in n, as k2 and k. are bounded by the constant 2c. 
By Observation 11.3 it suffices to show that the string-stabilizer problem for II is in TCO. This follows 
from Observation 7.3. 0 Acknowledgements. The first author is grateful to Peter Clote for calling the 
Clote-Kranakis conjecture to his attention. He owes particular gratitude to Gene Luks who taught him 
how to divide and conquer per­ mutation groups. References [Atk] M.D. Atkinson: An algorithm for finding 
the blocks of a permutation group, Math. Comp. 29 (1975), pp. 911-913. [Bal] L. Babai: On the order of 
uniprimitive permuta­tion groups, Annals of Math. 113 (1981), 553-568. [Ba2] L. Babai: On the order of 
doubly transitive permutation groups, Inventions Math. 65 (1982), 473-484. [Ba3] L. Babai: Permutation 
Groups, Coherent Con­figurations, and Graph Isomorphism, D. Sc. Thesis (in Hungarian), Budapest 1984. 
[BaP] L. Babai, L. Pyber: Permutation groups with ex­ponentially many orbits on the power set, J Comb. 
Theory, Series A, to appear. [BKL] L. Babai, W. M. Kantor, E. M. Luks: Compu­tational complexity and 
the classification of finite simple groups, in: Proc. 24th FOCS, 1983, pp. 162 171. [CK] P. Clote, E. 
Kranakis: Boolean functions, in­variance groups, andparallel complexity, S1Aikf3. Comp. 20 (1991), 553-590. 
(Preliminary version: Proc. 4th IEEE Symp. Stucture in Complexity Theory, 1989, pp. 55-66.) [FKPS] R. 
Fagin, M. Klawe, N. Pippenger, L. Stock­meyer: Bounded depth, polynomial size circuits for symmetric 
functions, Theoret. Comp. Sci. 36 (1985), 239-250. [Ha] M. Hall, Jr.: The Theory of Groups, Macmillan, 
New York 1959. [Kn] D. E. Knuth: Efficient representation of perm groups, Combinatorics 11 (1991), pp. 
57-68. [Lul] E. M. Luks: Isomorphism of graphs of bounded valence can be tested in polynomial time, J. 
Comp. Sys. Sci. 25 (1982), 42-65. [Lu2] E. M. Luks: Parallel Algorithms for Permutation Groups and Graph 
Isomorphism, in: Proc. 27th FOCS, 1986, pp. 292-302. [Lup] O. B. Lupanov: On a method of circuit synthesis, 
Izvestia VUZ Radiofizika 1 (1958), 120-140. [LM] E. M. Luks, P. McKenzie: Fast parallel compu­tation 
with permutation groups, Proc. 27h IEEE FOCS (1985), 505-514. [MC] P. McKenzie, S. A. Cook: The parallel 
complex­ity of the abelian permutation group membership problem, in: Proc. 24th FOCS, 1983, pp. 154-161. 
[Py] L. Pyber: The orders of doubly transitive groups, elementary estimates, to appear [Sha] C. E. Shannon: 
The synthesis of two-terminal switching circuits, Bell Syst. Tech. J. 28 (1949), 59-98. [Sire] C. C. 
Sims, Some group theoretic algorithms, in: Lecture Notes in Math. 697 (1978), pp. 108-124. [We] I. Wegener, 
The Complexity of Boolean Func­tions, Wiley Teubner 1987, Chap. 4. Appendix [BLS] L. Babai, E. M. Luks, 
A. Seress, Permutation groups in NC, in: Proc. 19th ACM STOC, 1987, pp. 409-420. Proof of the Babai-Pyber 
Theorem We now sketch a proof of Theorem 4.7[BaP]. Proofi As s(G) the orbits of G, it ~ Hi S(GA*) where 
suffices to prove {Al,..., the theorem Am} are for tran­ sitive groups G. Also, we may restrict ourselves 
to suf­ficiently large t. Assume that t is large enough that for all a ~ 2, tz-l ~ eXp(4@10g2 x). %t 
C3 = 4c2. Let st (n) denote the minimum of s(G) for transitive groups G of degree n with a primitive 
structure tree T with no giant nodes of degree > t.For 1~n~c2t,we have St(n) ~ n+ 1 ~ 2 ~ 2 2/ ~ 2n/I 
3tj. To complete the proof, it is enough to prove the following claim: Claim: For n z c2t, St(n) z t2n/(C 
tl. Proof: By induction on n. Let G be a transitive group of degree n ~ c2t, and T a primitive structure 
tree for G with no giant nodes of degree larger than t.Suppose the claim is true for smaller values of 
n. Collapse the levels of T below level 1 to a single level. Let If = If(root), and let L = L(u) for 
some u E LI. We consider three cases: 1. k-l z c2t. We have Ill! ~ ko!, and for k. > t we have Iffl ~ 
exp(4&#38;log2 ko) soin any caseIll I~ tko-l.By induction, s(L) ~ @l/(4, So s(G) ~ S(~I)/1~[ ~ s(LkO)/l~l 
= S(~)k:/l~[ ~ (t2~1/(@))~ /@-l = &#38;d(c30 as desired. 2. kl < c2t ~ ko. By Theorem 4.5 and choice 
of C2 we have IH[ ~ 2koi2. Also, t ~ 2t = 2@t/cz < 2ko/8 and 2nl(Cs$) = 2hhl(@) ~ 2b@l(@) = 2W~ Combining, 
we obtain s(G) Z S(L)kO/lH[ ~ 2~0/]Hl > 2kolz > t2d(cs0 w desired. 3. kl, k. < c2t. In this case the 
estimate s(G) ~ ( ~k ) suffices. This estimate is symmetric in ko and kl, so we may assume that ko s 
kl. Since kokl = n z c2t, we must have k. ~ 2. Therefore, s(G) z (ko:k )= Ri+ ) w) @(c30 [Wi] H. Wielandt: 
Finite Permutation Groups, Acad. proving the Claim and the Theorem.tl Press, New York 1964.  
			
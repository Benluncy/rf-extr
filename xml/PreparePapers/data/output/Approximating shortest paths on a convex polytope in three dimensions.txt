
 Approximating Shortest Paths on a Convex Polytope in Three Dimensions* Sariel Har-Peledt Micha Sharir$ 
Kasturi R. Varadarajan~ Abstract We present an approximation algorithm that, given a convex polytope 
P with n faces in lR3, points s, tc 8P, and a parameter O < &#38; <1, constructs a path on t3P from s 
to twhose length is at most (1 +E)dP(S, t), where dp (s, t) is the length of the shortest path be­tween 
s and ton 8P. The algorithm runs in O(n . min {1/s 5, logn} + l/e4 5 log(l/&#38;)) time. and is relatively 
simple to implement. We also present an extension of the algorithm that computes approximate shortest 
paths from a given source point on 8P to all vertices of P. Introduction Let P be a convex polytope 
with n faces in IR3. For two points s, tE 8P, let ZP (s, t)denote the shortest * Work on this paper by 
the first two authors has been supported by a grant from the U. S . Israeli Binational Science Foundation. 
Work by Micha Sharir has also been supported by National Science Foundation Grants CCR.9424398 and CCR­93-11127, 
by a Max Planck Research Award, and by a grant from the G.I.F. the German Israeli Foundation for Scientific 
Research and Development. Work by the third author has been supported by NSF Grant CCR-93-01259, an NYI 
award, and matching funds from Xerox Corporation. t School of Mathematical Sciences, Tel Aviv University, 
sariel@math .tau. ac. il ~ s~ho~l of Mathematical sciences, Tel Aviv university, and Courant Institute 
of Mathematical Sciences, New York University, sharir@math. tau. ac. il ~ Department of Computer Science, 
Duke University, krv@cs. duke. edu Permission to make digital/hard copies of all or part of Uds material 
for persoml or classroom use is granted without fee provided that the copies are not made or distributed 
for profit or commercial advantage, the copy­right notice, the titte of the publication and its date 
appear, and notice is given that copyright is by permission of the ACM, Jnc. To copy otberwiae, to republish, 
to post on servers or to redistribute to lists, ~quires specific permission andlor fee. computational 
Geometry 96, Philadelphia PA, USA @ 1996 ACM o-89791-804-5/96/05. .$3.50 path from s to ton 8P. As is 
well known, irp (s, t ) is a polygonal path whose vertices, other than s and t,lie on the edges of P. 
Moreover, if we unfold the faces of P that mp (s, t)traverses, the path becomes a straight segment [17]. 
Hence, to compute np (s, t)it suffices to find the sequence of faces that it traverses. This problem, 
as well as several related ones. have been studied in [2, 3, 5, 6, 11, 15. 16. 17]. The best known algorithm 
for computing the exact shortest path runs in 0(n2 ) time [6]. It is a rather long­standing and intriguing 
open problem whether the exact shortest path can be computed in subquadratic time. This has motivated 
the problem of finding sub­quadratic algorithms that produce only an approxi­mation of np(s, t). That 
is, we wish to compute a path n that connects s and talong 8P, whose length is at most (1 + e)dp(s, t), 
where dp(s, t) is the length of np(s, t),and where e is any prescribed small posi­tive number. A recent 
result in this direction is due to Hersh­berger and Suri [10]. They present a simple algorithm that runs 
in O(n) time, and computes a path whose length is at most 2dP(s, t). Their methodl does not seem to extend 
to yield better approximation factors. There are also several general approximation algo­rithms for shortest 
paths in arbitrary polyhedral en­ vironments [7, 12], but their running times are much worse than quadratic. 
In this paper we present another, relatively sim­ ple algorithm that computes an approximating path 
whose length is at most (1 + c)dp (s, t), for any pre­scribed O < E < 1. (There is no point of specifying 
e > 1, since the algorithm of [10] already solves the problem optimally for &#38; = 1.) The running time 
of the algorithm is O(n.min {1/e15, log n}+l/&#38;45 log(l/&#38;)). The algorithm follows from a sequence 
of easy but technical lemmas, so we begin with an informal description of our approach. We first estimate 
the length d = dp(s, t), using the approximation algo­rithm of [10] mentioned above. We then expand p 
by distance r z E1.5d; call twls expansion Pr. we intersect Pr with a grid whose unit distance is pro­portional 
to r, and form the convex hull of the inter­section. We end up with a convex polytope, denoted as P(r), 
with 0(1/e2 25) vertices, which, for an ap­propriate choice of the grid size, lies in between P and Pr. 
(This bound on the size of the approximat­ing polytope follows from the analysis of [1, 4] on the number 
of vertices of a lattice polytope as a function of its volume; see below for details. ) We now com­pute 
the exact shortest path along 6 P(r) between two points close to s and t,respectively, and connect the 
endpoints of this path to s and to t. We obtain a path o connecting s and t and lying outside P. A main 
technical contribution of this paper shows that the length of o is at most (1 + s)dP (s, t).If we only 
want to approximate dp (s, t), we can stop now. Oth­erwise, we apply an additional step that projects 
c onto 6 P, in a manner that ensures that the length of the projected path is at most the length of the 
initial outer path. The paper is organized as follows. Section 2 intro­duces the required terminology 
and establishes some initial properties. Sect ion 3 discusses the construc­tion of P(r), and proves that 
the shortest path along ~P(r) is a good approximation of the desired shortest path on 8P, for an appropriate 
choice of r. Section 4 presents a simple technique for projecting a path ly­ing outside P onto 8P, and 
Section 5 presents and analyzes the whole algorithm. We conclude in Sec­tion 6 with an extension of our 
algorithm that com­putes approximate shortest paths from a given source point s c 8P to every vertex 
v of P. That is, for each vertex v we compute a path from s to v whose length is at most (1 + ~)dp (s, 
v). The extended algorithm runs in time 0((n/&#38;45)(logn + log(l/&#38;))).  Preliminaries We begin 
with some terminology and some initial ob­servations. For a face $ of the given convex polytope P, we 
denote by Hf the plane passing through f. Given a set A c IR3, and a real number r 20, let A, denote 
the Minkowski sum .4@ B., where B. is a ball of radius r about the origin. That is, A.= z ininlz-yl<r 
. {1 1 For a convex polytope P and for z ~ ~P, let F.(z) = {y yE 8P., lx yl = r} bethe setofpoints of8P. 
 corresponding to z. Clearly, dPr consists of planar faces, each being a translated copy, by distance 
r, of some face of P, of cylindrical faces, each being a portion of a cylinder of radius r about some 
edge of P, Figure 1: A cube P and the inflated set Pr and of spherical faces, each being a portion of 
a sphere of radius r about some vertex of P. Moreover, (i) if x lies in the relative interior of a face 
of P, then l?r (x) is a singleton, consisting of the point lying at distance r from z in the direction 
of the outward normal of the face; (ii) if ~ lies in the relative interior of an edge of P, then F,(z) 
is a circular arc of a circle of radius r about Z; and (iii) if z is a vertex of P, then F.(x) is the 
entire spherical face associated with z. See Figure 1 for an example of such an inflated polytope. For 
any plane H that avoids the interior of P, the positive half-space H+ bounded by H is the one containing 
P. Such a plane is a supporting plane of P if 8P n H # il. Given two planes HI, H2 that avoid the interior 
of P, the wedge of HI, H2 is W(HI. H2 ) = H;nH~. For an open curve ~ c IR.3and for a, b E ~, we denote 
by y(a, b) the portion of ~ between a and b. An outer path of a convex body K is a curve ~ connecting 
two points on OK and disjoint from the interior of K. The length of a curve ~ is denoted by 1~1. A pair 
@ = (a, H) is a supported path of P if a = (Pi, . . . , p~+l ) is a polygonal outer path of P and H = 
(Hi, . . ., Hm) is a sequence of support­ing planes of P, such that pipi+l c Hi, for i = 1,. ... m, and 
pipi+l,pi+lpi+~ c 81V(Hi, H~+l), for ~=1 , . . . . m 1. The folding angle between pipi+l and pi+1pi+2, 
denoted as CY(Hi, Hi+l ), is z minus the dihedral angle of the wedge W(HZ, Hi+l ), for ~=1 , . . . . 
m 1. (Note that this angle depends on the planes Hi, Hi+l, and has nothing to with the ac­tual angle 
between pipi+l and pi+lpi+2.) The folding angle of@ is a(~) = ~~~1 ~(Hi, Hi+l). We will also write Io[ 
as 1~[, and call it the length of o. Note that a shortest path np (s, t) has a natural supported path 
associated with it. (In this special case, each folding angle a(ll~, 17%+1) is larger than or equal to 
n mi­nus the actual angle between p~p~+l and pi+1pi+2; we call this latter angle the ezterior angle between 
these segments.) The following well-known theorem implies that any outer path of P connecting two given 
pointss, tE 8P must be of length at least dp(s, t). Theorem 2.1 (see [13] ) Let F be a convex surface 
bounding a body K, and T a curve that does not meet the interior of K and connects points s and t on 
F. Then the length of T is at least the shortest distance dK (s, t) between its endpoints along the surface; 
it is strictly greater than this distance if the curve does not lie entirely on the surface. Lemma 2.2 
Let P be a convex polytope in lR3, let s and t be points on 8P, and let @ = (cr, ?-t) be a supported 
path connecting s and t. Then, for each r ~ (), there exists an outer path ~ of P. connecting a point 
of Fr (s) with a point o,f F,(t), whose length is 1~ I + ~(~)r. The curve ~ consists of an alternat­ing 
sequence of straight segments and circular arcs of radius r. Proof: Suppose that a = (s = PI,. . . . 
p~+l = t), and U = (HI, ..., H~ ). We replace each segment ptpi+l of u by its projection onto the boundary 
of (H+),, namely, we translate PiPi+] by distance r in th~ direction of the outward normal of H,. We 
denote the translated segment by qiq~ (where qi k the image of pi ). Clearly, the total length of the 
new segments is lot. We also have ql c F~(s) and q~ ~ Fi-(t). We still need to connect the endpoints 
q; and qi+l, fori = 1,. ..,l l. Let W, = (W(H,, HZ+l)),. Clearly, q,q~, q,+l g~+l C WV,. Moreover, both 
q; and qi+l are images of P,+l under the two projections onto H, and onto Hi+l, respectively, and thus 
can be con­nected by a circular arc of radius r about p~+l. The length of this arc is clearly r ~~(Hi, 
Hi+l ). The al­ternating concatenation of the segments qi q; and of these circular arcs yields the desired 
outer path ~. See Figure 1 for an illustration. The total length of the new path is clearly I*I + a(~)r. 
Finally, since P, CW,, for2= l,... , m 1, it follows that T is an outer path of PT, because each point 
of ~ lies on the boundary of one of these inflated wedges. Let @ = (a, H) be a supported path of P, for 
 ff=(pl, . . . ,Pm+l) and?t = (Hi,...,H~). Let U = (u,,..., u*) be the sequence of outward unit normals 
of the planes HI, . . . . H-. We create a curve corre­ sponding to $ on the sphere S of directions in 
the following manner. Let ~i be the shorter great, circular arc connecting Ui to ui+l on S, for i = 1,....m 
 1, and let ~ = u~~l vi. Since l~z[ = a(lli, Hi+l), it follows that m 1 m 1 171= ~ l Yil= ~ (Hi, Hi+l) 
= ( O). i=] i=] We call y the curve oj directions of+. Lemma 2.3 Let P be a convex polytope, let s and 
t be points on 8P, and let O < E < 1. Then there exists a supported path ti = (o, 74) of P, such that 
IVI S (1+ c/2)d~(s, t), and the folding angle a(+) is at most 100/fi. Proof: Let O. = (s = P1, ...,p~+l 
:= t) be a shortest path on ~P froms to t, and let vo := (OO, Ho) be the corresponding supported path, 
where 7i0 = (Hl,..., H~ ). Let TO denote the curve of directions of 00 on the sphere S of directions. 
Cover S by at most 100/&#38; pairwise openly disjoint spherically­convex regions, each cent ained in 
some spherical cap with angular opening W (that, is, each cap is the in­tersection of S with a cone with 
apex at the origin and with opening angle &#38;/2). This can be easily done, by covering S with a grid 
of latitudes and lon­gitudes, with angular spacing of &#38;/2 between them, and by placing the caps so 
that each is centered at a grid point. The number of grid points is for O < e ~ 1. Trimming the caps 
into pairwise openly disjoint spherically-convex regions is also easy to do. For simplicity of exposition, 
we refer to these regions also as caps . Let C = (c1, . . . . cm) be the sequence of caps traversed by 
TO in this order. For each cap c, the intersection -yon c is a collection of great circular arcs. Our 
strategy is to modify ~. into a supported path ~, such that the intersection of the curve of directions 
of@ with each cap is either empty or a single connected great circular arc. For a cap c that appears 
in the sequence C, let i(c), j(c) be the indices of the first and last appear­ances of c in C. From the 
caps c E C such that cn TO consists of more than one connected great circular arc, we pick the cap c 
such that i = i(c) is minimal, and put j = j(c). Let u and u be the first and last normals in c n To. 
By assumption, this intersection consists of more than one great circular arc., where the first such 
arc starts at u and the last arc ends at u . Let v and v be the points on a. such that the planes supporting 
P at v and V have outward normals u and u , respectively (it is easily seen that v and v are unique). 
We shortcut o from w to v as follows (in fact, this shortcutting may increase the length of o a little). 
Draw the planes H, H that support P at v and v and have outward normals u and u , respec­ tively. Note 
that the smaller angle between H and H is at most +. Form the wedge W = W(H, H ) between them that contains 
P. Both v and v lie on dW. (This holds initially, since both v and v lie on 8P. Later we will repeat 
this shortcutting, but in each application the corresponding points v and v will still lie on 8P. ) Let 
a (v, v ) be the shortest path along WV from v to v . .4s noted above, the larger angle 8 between its 
two segments is at least the di­ hedral angle of W, namely z T &#38;. This implies, using the cosine 
law, that la (v, v )1 < (1 + e/2) [vv 1, where IVV I is the straight Euclidean distance between v and 
v .1 Hence jc7*(V, V )/ < (1 +E/2)lc7(V, V )1. We replace O(V, v ) by o (v. v ), and delete from C all 
elements with indices i + 1, ..., j. We also add the plane H to an output sequence H (initialized with 
the plane H arising in the first cap). It is easily seen that the curve of directions of the modified 
path in­tersects c at a single connected great circular arc. By repeating this step as necessary, we 
end up with a supported path @ = (o, ?f) such that the intersection of the curve of directions of ti 
with any cap is either empty or consists of a single connected great circular arc. Note that our rule 
for picking the cap to short­cut ensures that no portion of the path resulting from a shortcut will participate 
in a later shortcut . (In particular, the modified portion of the curve of di­rections after a shortcut 
remains within the current cap, and thus does not penetrate into any cap that has already been processed.) 
This implies that each pair of points v, v between which the shortcuts are made lie on 8P, so the length 
of the new path is at most (1 + e/2)lo01 = (1 + E/2)dP(s, t). We apply a final trimming step to cr, by 
noting that in general o may contain two consecutive segments on each plane lil : %. We therefore replace 
each such pair of seg­ments by a single segment (the sequence % does not change by this trimming). The 
final path @ = (a, H) satisfies the following properties: (i) a does not meet the interior of P. (ii) 
o has at most 100/&#38; edges.  1To see ~hi~, let ~ be the middle vertex of a* (V, ~ ), and Put a = 
IwLI, b= Itjfwl andc= Ivvl. Thenc2 = a2+b2 2abcos0, orcz = (a+ b)2 2ab(l+cos0). Since l+ COSO < l cos@ 
< E/2, we obtain C2> (a + b)2 1 -Since (a+ b)2 ? () 4ab, we have c > (a + b) ~~4, and this is easily 
seen to imply that a+ b< (1+ e/2)c, for O< E~ 1. (iii) dP(s, t) = Iaol s la] s (1 +5/2) dp(s, t). (iv) 
The curve of directions of d) intersects each cap in a single (possibly empt,y) great circular arc. It 
now follows that the total folding angle of @ is bounded by 100/&#38;. Remark 2.4 The previous lemma 
raises the follow­ing interesting open problem: Is it true that the fold­ing angle of any shortest path 
on a convex polytope is bounded by some absolute constant? If this were true, there would have been no 
need for the preced­ing lemma, since we could have used the shortest path itself, and get a folding angle 
that is indepen­dent of E. Consequently, this would have resulted in an improved algorithm for approximating 
the short­est path, for which the second term in the bound for the running time would have been reduced 
to 0(1/s3 log(l/&#38;)). See below for more details, and see [13] for an extension of this open problem 
to shortest paths on arbitrary convex surfaces. Another, some­what weaker open problem is whether the 
sum of the exterior angles (as defined above) between consecu­tive segments of a shortest path on a convex 
polytope is bounded by an absolute constant. This is a weaker problem because, as already observed, the 
exterior angle between two consecutive segments of a shortest path is at most the folding angle between 
the faces cent aining them. Lemma 2.5 Let P, s, t, and c be as above. and let r > 0. For any Sr G Fr(s), 
t? ~ FT(t), there exists an. outer path, of Pr connecting s, with. t,, whose length is at most (1 i-E/2)dP(s, 
t) + 2m-+ 100r/&#38;. Proof: By Lemma 2.3, there exists a supported path I.J of P connecting s to tof 
length at most (1 + E/2)dP(S, t), such that a(@) ~ 100/@. By applying Lemma 2.2 to @, we obtain an outer 
path ~ of Pr whose length is at most (1 + e/2)dP(s. t)+ 100r/fi. which connects some point x E F.(s) 
with some point y c F,(t). Extending y to connect S. to t, lengthens ~ by at most 2m-, so the resulting 
curve satisfies the properties asserted in the lemma.  3 Approximating a Convex Poly­tope Let P be 
a convex polytope in IR3, and let s, t be two points on 8P. Let 6 be a rough approximation of d = dp(s, 
t), satisfying dp(s, t) < 6 s 2dp(s, t). (Such an approximation can be computed in linear time by the 
algorithm of [10].) Let 1 = 26, and let ............... . ................ D . . . . . ..Ar....., 
,, . . . . . ./f. ) . . . . . . . . ............ ..O . ............... .  Figure 2: A polytope P, 
the inflated body P., and the approximating polytope P(r) B(s, 1) be a cube of side 21 centered at s, 
i.e., and let Q = P n B(s, 1). Clearly, s, t 6 8Q. More­over, let c be the shortest path between s and 
ton 8Q. We claim that a is also the shortest path be­tween s and ton 8P. Indeed, since Q ~ P, it follows 
from Theorem 2.1 that, Io( s dp(s, t) < 1, so any point on a must lie in the interior of B(s, 1). Thus, 
to approximate the shortest path on P, it suffices to approximate the shortest path on Q. For b >0, let 
Gb be the grid (hi, bj, Mc) i,j, k ~ Z? {} Let S(r, b) = QrflGb. Let P(r) = Conv(S(r, r/fi)) = Conv(Q. 
n G./m). Figure 2 illustrates (a two-dimensional analog of) the relation between Q, P(r) and P. (in the 
figure, we assume that Q = P). Lemma 3.1 Q Q P(r) C P.. Proof: By definition, P(r) = Conv(Gr ~nQ.) ~ 
Q, ~ Pr. Let v be a vertex of Q, and let 4 be the set of the vertices of the grid cube (or cubes) of 
Gr,fi that contains w. Clearly, the distance between v and any vertex of V is at most fi(r/@ = r. Thus, 
V ~ Q,. It follows that V c Conv(Qr n G~) = P(r), and thus also v c P(r). This readily implies the assertion 
of the lemma. Lemma 3.2 The complexity of P(r) is O ((1+:)3 2). Proof: Since Q = P n B(s, 1) and 1 ~ 
4d, it follows that Q, ~ B(s,4d + r). Let B = B(s,4d + r) n Gr,ti. The convex hull of B is a cube, each 
of whose edges contains 0(1 + d/r) points of Gr/dT. Since, by definition, S(r, r/fi) = Qr fl Grlti C 
B, it follows that lS(r, r/fi)l < IB[ = 0((1 + d/r)3). The claim is now a consequence of the following 
 result of Andrews [1] (see also [4]): Let K be a convex polytope in IR3 whose vertices have all integer 
coor­ dinates. Then the number of vertices of K is at most proportional to {m. In our case, if we scale 
IR3 so that G,jfi becomes the integer grid, the volume of P(r) is bounded by the volume of B, which becomes 
0((1 + d/r)3 ). The claim is now irnmedia,te. Lemma 3.3 Let P be a convex polytope, let s, t be points 
ondP, andletO<E<1,r>().Forany s, E F.(S), tr E Fr(t), there exists a path on, P(r) between s = SS, n 
8P(r) and t = ttrf)dP(r), of length at most (1+ c/2)dP(s, t) + 2nr + lCIOr/fi. By concatenating the segments 
SS and tt to this path, we obtain an outer path of Q = P n B(s, 1) connecting s to t, whose length is 
at most (1+ &#38;/2)dP(s, t) + (27r + 2)r + 100r/@, and which consists of 0((1. + d/r)3/2) segments. 
Proof: By Lemma 2.5, there exists an outer path o of P. connecting the points s, and t,, whose length 
is at most (1 + e/2)dP(s, t) + 2nr + 100r/fi. Let s = ss, ntlP(r) and t = ttrrl OP(r), and let o be the 
curve resulting from concatenating the segments s s, and trt to the beginning and end of o, respectively. 
Clearly, o is an outer path of P(r) connecting s and t ,and its length is at most (1+ s/2)dP(s, t) + 
(2T + 2)r + 100r/fi Iss 1 Thus, by Theorem Itt 1.2.1, the shortest path o on P(r) connecting s and 
t has length at most (1 + e/2)dp(s, t) + (2T + 2)r + 100r/~~ Iss 1 Itt /. By Lemma 3.2, the complexity 
of P(r) is 0((1 + d/r) 3/2 ). Since the shortest path intersects a face of the polytope along (at most) 
a single segment, it follows that, the complexity of o is 0((1 + d/r)3/2). It follows that by concatenating 
the segments SS and tt to the beginning and end of o , respectively, we get an outer path of Q connecting 
s to t,wlhose length is at most (1 + e/2)dp(s, t) + (27r + 2)r + 100r/fi, and which consists of 0( (1 
+ d/r)3i2) segments. Remark 3.4 It is easy to check that Lemmas 3.1, 3.2, and 3.3 also hold if we define 
P(r) as follows: P(r) = Conv(G,,fi n B(s, 1 + r/fi) n P.). This slight modification will be used in 
our approxi­mation algorithm, to be described in Section 5. The algorithm will calculate the shortest 
path between s and t on 8P(r), for r 5 &#38;312dp(s, t)/220. Lemma 3.3 then implies that the length of 
the resulting outer path of Q connecting s to t is at most (1+ ~)dP(s. t). It is easy to see that for 
e < 1, this is also an outer path of P.  4 Projecting an Outer Path to a Polytope In this section we 
present an algorithm for project­ing a polygonal outer path o of a polytope P onto the surface of P. 
The output of the algorithm is a polygonal path aOUf such that: (i) 100U,I ~ Ial. (ii) OOU,C ~P.  (iii) 
a and ooui have the same pair of endpoints. (iv) The number of segments of aoti~ is at most n, the number 
of faces of P. We assume that 8P is triangulated, so each face is a triangle. Let a be the given polygonal 
outer path of P, connecting s c 8P to tE 8P and consisting of m segments. We direct a from s to t.For 
aface ~of P, let p and q be the first and last intersection points of o with Hf. Clearly, the path &#38; 
= a(s, p) UpqUcJ(g, t) is not longer than CT,and a G H;. We denote this op­eration by ProjectPath ToFace( 
f ,cr). This operation can be trivially implemented in 0( Ia[) time, but we will use a different implementation, 
which turns out to be more efficient for our purposes. The projection algorithm is presented in Figure 
3. An illustration of a single step of the main loop of the algorithm is shown in Figure 4. Lemma 4.1 
The operation (A) in the algorithm Pro­jectPath ToPolytope never fails, i.e., there always ex­ists a 
face adjacent to the current s that was not yet vwited. Proof: Assume, for the sake of contradiction, 
that it does fail at some point, call it p. Let F denote the collection of faces of P that contain p, 
and let C = UfGF.f. Let g g F be the last face in F processed by the algorithm such that the segment 
added to uout during this processing had positive length, and let F be the subset of all the faces of 
F that were processed by the algorithm before g. We first claim that p must belong to the segment segte~P 
produced during the processing of g. Indeed, suppose that this were not the case. By construction, the 
portion of o beyond segt,mP is fully contained in the interior of the halfspace Hz. so there is no way 
that the algorithm could have later reached p, which lies on H,~. We next claim that p must be the further 
endpoint of seg, as produced during the processing of g. This is clear if g was the last face to be processed 
(before the algorithm got stuck). Otherwise, p must have been the initial endpoint of seg. This implies 
that, after the processing of g, the path crouf U a contains a cycle starting and ending at p. This, 
however, is impos­sible, because this cycle would have been eliminated during the processing of g. If 
seg # segfe~P during this iteration, then there must exist aface ~ of F such that int H~ no # 0. It follows 
that f had not been visited yet, be­cause otherwise CTOUtU o would have been contained in H]. By assumption, 
the algorithm did process f after g, but did not change then neither n nor rs~ut. This however is impossible, 
because the procedure ProjectPath ToFace(f,a) would have shortcut the ini­tial portion of a. This contradiction 
thus implies that seg = segfe~P during the processing of g. so they both end at p. Let g denote the initial 
endpoint of seg. By construction. p must have belonged to a prior to the processing of g, and ~ must 
have been contained in the cone K = flfe~, H;. Note that, after performing an iteration of the loop for 
a face f, the resulting path aouf U a inter­sects Hf along a single segment seg , and only the first 
segment or the initial vertex of the remaining path a is contained in seg . Furthermore, if. at some 
later stage, the starting point w of the remaining a is not in seg , then a can never return to Hf (from 
now on, its intersection with H,r w-ill be empty). Let g be the last face of F that was processed. Thus, 
just after processing g , only the first seg­ment or the initial vertex of the remaining path a can lie 
on 8K, which means that (a) at that time the first segment of a had contained p, and (b) after leaving 
8K, o could not have returned to it. This however contradicts the fact that, just prior to processing 
g, the path a has passed through q, which does not lie on 8K, and then reached p. This contradiction 
com­pletes the proof of the lemma. Lemma 4.2 The output path cro.t produced by algo­ n thm ProjectPath 
To Polytope(P,c r) satisfies the con­ ditions (i)-(iv). Proof: The algorithm ProjectPath ToPolytope 
per­forms at most n iterations (Lemma 4.1 implies that the algorithm terminates properly.) Each iteration 
of the while loop adds one segment to the polygonal Algorithm: ProjectPathToPolytope( P, a ) Input: Aconvex 
polytope Pandanouterpathu Output: A path ~OUt on the boundary of P begin L7Q~t+ 0 s +-starting-point(a), 
t+-end-point(a) while s# t do (A) CurrentFace +--any face of P containing s and not yet visited ot,~P 
+ Pro,jectPathToFace (Current Face, C) segtemP + ~temp ~ H~urrentFace w + the end-point of segtC~D other 
than s I seg + segtemp (7 P v + the end-point of seg other than s oOUt + uOUt U seg 0 + 7)Wu U(w, t) 
S+- U end while return Ootit end ProiectPathToPolytope  Figure 3: Algorithm for projecting an outer 
path onto the boundary of a polytope output path aout, thus cro~i consists of at most n seg­ments. Each 
such segment is cent ained in the bound­ary of P, thus oout c P. Since ootit is generated from ~ by performing 
a sequence of calls to ProjectPath To-(7 Face, it follows that Iaout I < a. Finally, u.~tand a clearly 
have the same pair of endpoints. We next present a simple technique for performing the operations ProjectPath 
ToFace. This technique is not very efficient, but its cost will be subsumed by the otem v overall running 
time of the main algorithm, presented in the following section. s The idea is to maintain dynamically 
the convex hull of the set V. of vertices of the current path a, in fp CurrentFace ( )$ a manner that 
supports logarithmic-time execution of queries in which we are given a direction n and want to find a 
plane supporting Vc whose outward normal t is in the direction n; more precisely, we want to find a 
vertex of VU incident to that plane. Executing ProjectPath ToFace( f ,a) is then performed as follows. 
Let n be the outward normal direction of Hf (pointing into H~ ). We query our data structure with n, 
and test whether the reported vertex v lies in H;. If so, we output v, delete it from the structure, 
and repeat the query. In this manner, we obtain all Figure 4: A single step of the main loop of Project­the 
vertices of o that lie in H;. By intersecting Hf Path ToPolytope. The intersection points between o with 
the segments of o incident to these vertices, we and HCU~~enfFaCe are highlighted. The segment sv is 
easily obtain the last point of a that lies on Hf, from appended to o~~t, and the rest of ~temp (@@iw 
at which the output of ProjectPath ToFace(f,o) can be v) becomes the new path o-. readily obtained. 
Observe that, after each iteration of the while loop of the algorithm, only the first vertex or the first 
two vertices of the modified path a are new; all other ver­ tices are vertices of the original path. 
This suggests that we maintain in our dynamic data structure only the original vertices of a, so we only 
need to perform deletions, which means that we will have to execute at most m update operations. The 
actual execution of a query will also take into account the (one or two) new vertices of the current 
a, but this will only take additional constant time per query. We use the following naive implementation: 
After each deletion of a vertex, we compute the convex hull of the remaining vertices from scratch, preprocess 
it for extremal point queries using the nested polytope hierarchy of Dobkin and Kirkpatrick (see, e.g., 
[9]). It is then easy to perform in logarithmic time queries of the required type. Since initially we 
have m + 1 vertices, and we perform at most m deletions, the overall cost of initializing and updating 
the structure is 0(m2 log m). The number of queries that we per­ form is at most m + n. This follows 
from the observa­ tion that, for each face $ of P, every query performed while processing f, except for 
the first such query, re­ sults in the deletion of at least one vertex of a. The total cost of the queries 
is thus 0( (m + n) log m). Thus, the overall cost of performing the operations ProjectPathToFace is 0((m2 
+ n) log m). The cost of the remaining steps of the algorithm ProjectPath- ToPolytope is only O(n), since 
each of the other steps of the while loop can easily be implemented in con­ stant time. We have thus 
shown: Theorem 4.3 Let P be a convex polytope with n faces, and let Q be a polygonal outer path of P 
consisting of m segments. One can construct a polygonal path a C 8P with the same endpoints as ~, such 
that Icr ] ~ Ial, and the number of edges of&#38; is at most n. The construction takes O((n + mz) log 
m) time. 5 The Algorithm The approximation algorithm is presented in Figure 5. The procedure ApproximatePathByFactor2(P,s,t) 
is the linear-time algorithm presented in [10], which calculates an approximate shortest path on 8P be­tween 
s and twhose length is at most twice dp(s, t). In our application, we assume that this procedure only 
returns the length of the path that it has com­puted. The procedure CalcShortestPath(Q, s,t) is the al­gorithm 
of [6] that calculates the (exact) shortest path bet ween s and t on 8Q. The algorithm runs in O (m2 
) time, where m is the number of faces of Q. Lemma 5.1 Let P be a convez polytope. let s and t be points 
on 8P, and let O < E s 1. Thte al­gorithm ApproximatePath OnPolytope(P,s, t,&#38;) calcu­lates a path 
on 8P connecting s to t, whose length is at most (1 + &#38;)dP(s. t). Proof: The algorithm calculates 
the polytope P(r), where r < ~3/2dP (s, t)/220, and it then constructs the shortest path between s and 
t on P(r). By Lemma 3.3 and Remark 3.4, the length of the result­ing outer path of P is at most (1 +e)dp(s, 
t), implying that the projected path returned by the algorithm is of length at most (1 + s)dp(s, t). 
Lemma 5.2 The algorithm ApproximatePathOnPoly­ tope (p, S,t,E) can be implemented to run in, tim,e O(n 
. min {1/s15, Iogn} + l/E4 5 log(l/&#38;)), where n is the number of faces of P. Proof: The convex body 
P, can be calculated in linear time. Consider next the steps that construct B n P, and its convex hull 
P(r). We project the top and bottom portions of 8PT and the set B = I?(s, 1 + r/fi) n G,ifi onto the 
zy-plane. Note that the projection B* of B consists of only 0( (2(1 -t r/fi)/r)2) = 0(1/~3) grid points. 
our goal is to locate each point, p of B* in the ry-projections of the top and bottom portions of 8Pr, 
from which it is trivial to find the highest point ph and the lowest point pl of ~ that project to p 
. It then follows that P(r) = Conv(B n P,) is the convex hull of all the points ph, pl just computed. 
we can thus compute P(r) in additional 0(1/:3 log( l/c) ) time (see [14]). We can perform the desired 
point locations in two different ways. The first method uses a straightfor­ward line-sweeping procedure, 
whose running time is O((n + l/c3) log n). In the second method, we take each of the 0(1/s312) lines 
of the grid B* par­allel to the y-axis and intersect it with every edge of the xy-projections of the 
top and bottom portions of 8P,. By applying bucket sorting, it is then easy to trace each of those grid 
lines through both pro­jected boundaries, thereby locating every point of B* in both maps. The overall 
cost of this method is eas­ily seen to be 0(n/s3i2). The algorithm chooses the faster implementation, 
depending on the values of n and e. The execution of CalcShortestPath( P(r) ,s ,t ) takes 0(1/E45) time, 
since the complexity of P(r) is o((l/&#38;3/y2) = o(l/c2 q. The call to ProjectPath ToPolytope(P,o) 
takes, by Theorem 4.3, O((n + 1/~45) log(l/&#38;)) time. Algorithm: ApproximatePathOnPolytope( P,s, t,s 
) Input: A convex polytope P, two points s, tG 8P, and an approximation factor O < c S 1 (lutput: A polygonal 
path o on 8P connecting s to t, of length at most (1 + E)dp(s, t) begin b + ApproximatePathByFactor2 
(P, s, t) r + E3126/440 1+-21s b+-r/d B i--B(s,l +r/fi) fl G,,A = B(s,l + r/Nfi) n {(bi, bj, bk) i.j,k 
c Z} Construct B n P, Construct P(r) + Co-nvexHull(B n Pr) Pick two arbitrary points s, E F,(s), t, c 
F,(t) s + ~P(r) n SST t +-8P(r) n tt. d +-CalcShortestPath (P(r), s , t ) a+ss uo ut t rJ +-ProjectPathToPoly 
tope(P, u) return C7 end ApproximatePathOnPolytope Figure 5: The approximation algorithm Summing up 
all these bounds, it is easily checked that the ove~all running time is bounded by O(n . min {1/El 5, 
logn} + 1/s4 log(l/s)), as asserted. H We have thus obtained our main result: Theorem 5.3 Given a convex 
polytope P with n faces, points s, t 6 8P, and O < E 5 1, one can construct a polygonal path, n c 8P, 
connecting s to t, consist­ ing of at most n segments, and satisfying /cJ15 (1 + s)dp(s, t), in O(n.min 
{1/s15, logn}+l/&#38;4510g( l/e)) time. Extensions We can generalize the above algorithm to compute 
approximate shortest paths from a given source point s on the polytope P to each of its vertices, in 
time 0(n/E4 5(log n + log 1/s)). That is, for each vertex v of P, the algorithm com­putes a path from 
s to v on 8P whose length is at most (1 + e)dp(s, t). We first use the O(n log n)­time algorithm of Hershberger 
and Suri [10] to com­the distance computed is between dp (s, v) and about 2.4dP(s, v). We ~ompute, in 
O(n) time, the Dobkin-Kirkpatrick hierarchical decomposition of the poly­tope P 18]. Using this decomposition, 
we can find in O(log n) time the shortest Euclidean distance be­tween a query point and the polytope. 
To compute an approximate shortest path from s to a vertex v of P, we use a slight variation of the algorithm 
ApproximatePath OnPolytope. Let 65 2.4dP (s, v) be the crude approximation of the shortest path distance 
dp (s, v), obtained by the Hershberger-Suri algorithm. Let 1 = 28. and let r = CE3jzi (as above), where 
c is a small enough constant. We com­pute the polytope P(r), as defined in Remark 3.4, as follows. (The 
method used to compute P(r) is essen­tially the only difference from the algorithm .4pprox­imatePaihOnPoly 
tope; we use the following method because it is more efficient, after some appropriate preprocessing, 
as we note below.) To compute P(r), we need to compute the subset S c G,I,6 of grid points that lie within 
the intersection of the box B(s, 1+ r/ti) and the inflated polytope P~. Note that S is exactly the set 
of points in G,,fi fl B(s, i + r/@ whose distance from P is at most r. We use the Dobkin-Kirkpatrick 
hierarchy to determine, in pute crude approximations of the shortest path dis­ O(lGr/Wfl B(s,l + r/fi)llogn) 
= 0(1/&#38;4 510gn) tances from s to each vertex of P; for each vertex v, time, the points in Gr/fi 
n B(s, 1 + r/v6) that be-[11] long to S. We then compute P(r), the convex hull of S, in additional 0(1/e4 
5 log(l/&#38;)) time. U sing P(r), we proceed as in ApproximatePath OnPolytope [12] to compute an outer 
path between s and v, whose length is at most (1 + e)dp (s, v). Summing up, this procedure takes 0(1 
/&#38;45 (log n + log(l/~)) ) time for [13] a single vertex of P. Iterating over all vertices, we get 
an algorithm that computes approximate shortest paths from s to each vertex of P, in 0(n/~45 (log n + 
log(l/s))) time. [14] Acknowledgments The authors wish to thank Pankaj Agarwal, Boris [15] Aronov, Imre 
B&#38;Any, Alon Efrat, Joe Malkevitch, Subhash Suri, and Boaz Tagansky for helpful discus­sions concerning 
this problem. [16]  References [17] [1] G.E. Andrews, A lower bound for the volumes of strictly convex 
bodies with many boundary points, Trans. Amer. Math. Sot. 106 (1965), 270-273. [2] C. Bajaj, The algebraic 
complexity of shortest paths in polyhedral spaces, Proc. 23rd Allerton Conf. C ommun. Control Comput., 
1985, 510-517. [3] A. Baksan and M. Sharir. On shortest paths between two convex polyhedra, J. ASSOC. 
Comput. Mach. 35 (1988), 267-287. [4] I. B&#38;iny and A.M. Vershik. On the number of convex lattice 
polytopes, Geometmc and Functional Analyszs 2 (1992), 381-393. [5] .J. Canny and J. H. Reif, New lower 
bound tech­niques for robot mot ion planning problems, Proc. 28th Annu. IEEE Symp. Found. Comput. Sci., 
1987, 49-60. [6] J. Chen and Y. Han, Shortest paths on a polyhedron, Proc. 6th ACM Symp. on Computational 
Geometry, 1990, 360 369. [7] K.L. Clarkson, Approximation algorithms for short­est pat h motion planning, 
Proc. 19th ACM Symp. on Theory of Computing, 1987, 56 65. [8] D. Dobkin and D. Kirkpatrick, .4 linear 
algorithm for determining the separation of convex polyhedra, J. Algorithms 6 (1985), 381-392. [9] H. 
Edelsbrunner, Algorithms in Combinatorial Ge­ometry, Springer-Verlag, Heidelberg, 1987. [10] J. Hershberger 
and S. Suri, Practical methods for approximating shortest paths on a convex polytope in JR3, Proc. 6th 
ACM-SIAM Symp. on Dt.screte Al­gorithms, 1995, 447 456. J.S.B. Mitchell, D..M. Mount, and C.H. Papadim­itriou, 
The discrete geodesic problem, SIAM J. Com.­pUt. 16 (1987), 647-668. C.H. Papadimitriou. An algorithm 
for shortest-path motion in three dimensions. Inform. Process. Lett. 20 (1985), 259-263. A. V. Pogorelov, 
Extrinsic Geometry of Convex Sur­faces, Volume 35 of Translations of Mathematical Monographs, American 
Mathematical Society, Prov­idence, RI, 1973.  F.P. Preparata and M.I. Shames, Computational Ge­ometry: 
An Introduction, Springer-Verlag, Berlin 1985. J. Reif and J. Storer, Shortest paths in Euclidean space 
with polyhedral obstacles, J. Assoc. Comput. Mach. 41 (1994), 1013-1019. M. Sharir, On shortest paths 
amidst convex polyhe­dra, SIAM J. Comput. 16 (1987), 561-572. M. Sharir and A. Schorr, On shortest paths 
in poly­hedral spaces, SIAM J. Cornput. 15 (1986), 193-215.   
			

 Coloring Non-uniform Hypergraphs: A New Algorithmic Approach to the General Lov£sz Local Lemma* Artur 
Czumaj t Christian Scheideler¢ Abstract LEMMA 1.1. (Lov£sz [8]) Let A1,... ,An be "bad" The Lov~sz Local 
Lemma (LLL) is a sieve method to prove events in an arbitrary probability space. Let G be a de- the existence 
of certain structures with certain prescribed pendency graph ]or the events A1,... , An. (That is, for 
properties. In most of its applications the LLL does every i, 1 < i < n, the event Ai is mutually independent 
 not supply a polynomial-time algorithm for finding these structures. Beck was the first who gave a method 
of of all the events Aj with (i,j) ~ G.) Assume that there converting some of these existence proofs 
into efficient exist xl,... , xn E [0, 1) with algorithmic procedures, at the cost of loosing a little 
in the estimates. He applied his technique to the symmetric form of the LLL and, in particular, to the 
problem of 2-coloring Pr[Ai]<x, H (1-xj) uniform hypergraphs. (i,j)eG In this paper we investigate the 
general form of the LLL. Our main result is a randomized algorithm for 2-coloring ]or all l < i < n. 
Then non-uniform hypergraphs that runs in expected lineartime. Even for uniform hypergraphs, no algorithm 
with such a ~t runtime bound was previously known, and no polynomial-  Pr[A1 n... n ~i~] > H(1 -x,), 
 time algorithm was known at all for the class of non-uniform hypergraphs we will consider in this paper. 
Our algorithm i=1 and its analysis provide a novel approach to the general LLL that is, with positive 
probability no bad event Ai holds. that may be of independent interest. We also show how to extend our 
result to the c-coloring problem. Many applications of the LLL can be found in the literature (see, e.g., 
[2, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 16, 1 Introduction 17, 20, 21, 22, 23]). In all of these applications 
the LLL The probabilistic method is used to prove the existence only guarantees an extremely small (though 
positive) of objects with desirable properties by showing that a probability that no bad event holds. 
To turn proofsrandomly chosen object from an appropriate probability using the LLL into efficient algorithms, 
even randomdistribution has the desired properties with positive ones, proved to be difficult for many 
of these applica- probability. In most applications this probability is not tions. In a breakthrough 
paper [6], Beck presented aonly positive, but is actually high and frequently tends method of converting 
some applications of the LLL into to 1 as the parameters of the problem tend to infinity. polynomial-time 
algorithms (with some sacrifices made In such cases, the proof usually supplies an efficient with regards 
to the constants in the original applica- randomized algorithm for producing a structure of the tion). 
Alon [1] provided a parallel variant of the algo- desired type. rithm and simplified the arguments used. 
His method There are, however, certain examples, where one was further generalized by Molloy and Reed 
[18] to yield can prove the existence of the required combinatorial efficient algorithms for a number 
of applications of the structure by probabilistic arguments that deal with rare LLL. However, all of 
these approaches can be applied events; events that hold with positive probability which only to the 
symmetric form of the LLL, in which a very is exponentially small in the size of the input. This regular 
structure of the events under consideration is happens often when using the Lov£sz Local Lemma required. 
(LLL). We state it in its general form. Molloy and Reed [18] also found methods that could possibly be 
applied to problems that require the general ~arch partially supported by DFG-Sonderforschungsbereich 
376 "Massive Parallelit~.t: Algorithmen, LLL, but as it was pointed out by the authors, they may Entwurfsmethoden, 
Anwendungen." require to prove some (possibly difficult) concentration- ?Department of Mathematics &#38; 
Computer Science and Heinz like properties for each problem under consideration. Nixdorf Institute. University 
of Paderborn, 33095 Paderborn, Germany. Email: artur@uni-paderborn.de. 1.1 New results. In this paper 
we present a novel SDepartment of Mathematics &#38; Computer Science and Heinz Nixdorf Institute. University 
of Paderborn, 33095 Paderborn, method for turning some applications of the general LLL Germany. Emall: 
chrsch~uni-paderborn.de. into efficient algorithms. We apply it to the problem of 2-coloring non-uniform 
hypergraphs. No polynomial- time algorithm has been found so far for this problem. To start with, we 
first require some notation. Given a hypergraph 7-/ = (V,E), let the (1-)neighborhood N(e) of an edge 
e E E be defined as N(e) = {e' E E\{e} I ef'le' # @}. Similarly, for g C_ E we define N(S) = LJ~se N(e) 
\ g. For any e E E, let lel denote the size of edge e (i.e., the number of nodes e contains). A hypergraph 
7/ = (V, E) is c-colorable if there is a c- coloring of V so that no edge in E is monochromatic (i.e., 
has nodes of only one color). The following result due to Erd6s and Lov£sz [8] follows easily from the 
LLL. THEOREM 1.1. [8] Consider any hypergraph 7/ = (V,E) in which every edge has at least k > 2 nodes 
and no edge intersects more than d other edges. If e (d + 1) < 2 k-1 then 7/ is 2-colorable. We note 
that Radhakrishnan and Srinivasan [20] recently improved this theorem. They showed that if no edge intersects 
more than 0.17. ~. 2 k edges, then for a sufficiently large k hypergraph 7/ is 2-colorable. However, 
their result is also non-contructive. Efficient algorithms for finding a 2-coloring were given by Beck 
[6] and Alon [1]. They show the following result. THEOREM 1.2. [1~ 6] There is a positive constant c 
> 1, such that if e (d + 1) _< 2 k/c, then any hypergraph 7/ in which every edge contains at least k 
nodes and no edge intersects more than d other edges can be 2-colored in polynomial time. Theorems 1.1 
and 1.2 are interesting mostly for uni- form hypergraphs. (Indeed, the way how one could color the nodes 
of a hypergraph 7/ in which every edge con- tains at least k nodes is by reducing each edge to ar-bitrarily 
chosen k of its nodes and solving the prob-lem for uniform hypergraphs.) However, they provide no reasonable 
bounds for non-uniform hypergraphs in which the edge sizes can vary arbitrarily (especially, when some 
edges might be of very small size and some other edges of very large size). One can generalize Theorem 
1.1 to the following result for non-uniform hypergraphs. THEOREM 1.3. Let 7/ be a hypergraph with edges 
el,... ,em. For every i, l < i < m, let Ai be the event that ei is monochromatic. Furthermore, let xi 
= 2 -5~ lell (for a suitably chosen 0 < 5i < 1) for all 1 < i < m. If it holds that Pr[Ai]_<xi H (1-xj) 
ejEN(ei) 31 for all 1 < i < m for the case that each node is colored independently and uniformly at 
random (i.u.r.), then 7/ is 2-colorable. None of the techniques developed so far can be used to construct 
an efficient algorithm for finding a 2-coloring for this class of hypergraphs. We will present a randomized 
algorithm that finds a 2-coloring in an efficient way for the following hypergraphs. THEOREM 1.4. There 
exist constants K, A, g > 0 such that for any k >_ K, O < 5 < A, and O < e <_ g it holds: Consider any 
hypergraph 71 with edges el,... ,era, in which every edge is of size at least k. Let Ai be the event 
that ei is monochromatic, 1 < i < m. Furthermore, let xi = 2 -51~1 for all 1 <_ i < m. If it holds that 
(Pr[Ai]) ~_<xi H (1-xj) ej EN(el) for all 1 < i < m for the case that the color of each node is chosen 
i.u.r., then there is a randomized algorithm that finds a 2-coloring of 7/ in expected time linear in 
 Ei led. REMARK 1.1. In this paper we did not make any at-tempt to optimize the values of K, A and $. 
In our proofs we require e < 1/24, 5 < e2/12, and k >_ 1/5 to obtain a polynomial-time algorithm. For 
a linear-time algorithm we need e <_ 1/242 and 5 <_ ca/2/12. /] at least ~ colors are available then 
we show in Section 5 that the hyperedges are allowed to be of arbitrary size, i.e., K --1. Observe that 
Theorem 1.4 contains as a special case Theorem 1.2. Thus it is its generalization to non- uniform hypergraphs. 
Most remarkable about this the- orem is that we are able to construct an algorithm that runs in expected 
linear time. No such a fast algorithm was known before even for uniform hypergraphs. Theorem 1.4 implies 
the following result, answering an open question of J. Beck. COROLLARY 1.1. Let 7/ = (V, E) be a hypergraph. 
There exist positive constants cl, c2, c3 so that if every edge in 7/ is of size at least cl and for 
every integer k no edge e E E intersects more than c2 lel" 2 c*k edges of size at most k, then one can 
find in polynomial time a 2-coloring of 74, w.h.p. The underlying structure of our 2-coloring algo- rithm 
is similar to that of Beck [6] and Alon [1] for uniform hypergraphs: Step 1: Color each node of 7/i.u.r. 
Step 2: Select nodes that require a recoloring. Step 3: Recolor the selected nodes. The main novel idea 
of our algorithm is a much more restrictive selection of the nodes that need a recoloring and allowing 
edges to be reduced to a fraction of their nodes if necessary. These two features of our algorithm enable 
us to prove that each set of selected edges covers a small (at most logarithmic) number of nodes, with 
high probability. This will allow us to find in polynomial time a 2-coloring even for non-uniform hypergraphs. 
As in the paper due to Alon [1], our approach to bound the runtime of the algorithm is to count certain 
structures that could "witness" a bad behavior of the algorithm. Our structures, however, are chosen 
in such a way that they allow us to obtain much more precise bounds than those obtained by Alon. Their 
investigation is the main new technique in the analysis of our algorithm. Our techniques for the 2-coloring 
problem easily ex- tend to the problem of c-coloring non-uniform hyper- graphs. Many other applications 
also seem to be in reach: Consider any discrete, finite application of the general LLL. Let .A-- {A1,... 
, An} be itsset of events and T = {tl,... ,tin} be the set of independent trials the events are based 
on. Each trial has a set of possible outcomes which may be viewed as its set of colors. Suppose that 
Ai only depends on a set of trials T~ C_ T. Then the problem of making all events in ,4 false can be 
interpreted as a generalized form of the hypergraph coloring problem, where the Ti represent the hyperedges 
and T represents the set of nodes. In this paper we shall only present randomized, sequential algorithms. 
We remark however, that our algorithms for the 2-coloring and c-coloring problem can be transformed into 
deterministic polynomial-time algorithms using the techniques in [3, 10, 19] (see also the discussion 
in [1, p.371] and in [20, Section 3]). Our method can also be implemented as a parallel Arc algorithm. 
Since these two results can be obtained using standard methods, we leave their details to the reader. 
1.2 Organization of the paper. In the next section we will present a polynomial-time algorithm for the 
2- coloring problem. Section 3 contains the analysis of the algorithm. In Section 4 we show how to transform 
the polynomial-time algorithm into a linear-time algorithm. Finally, we present in Section 5 a generalization 
to the c-coloring problem. 2 Description of the Algorithm We first present a polynomial-time algorithm 
for the 2- coloring problem. Consider any hypergraph 7/= (V, E) that fulfills the conditions in Theorem 
1.4, and let e be chosen as in Remark 1.1. Our algorithm consists of three steps. Step 1: Color all the 
nodes of 7-/by choosing for each node one out of two possible colors i.u.r. Before we describe Step 2, 
we first introduce some notation and provide the ideas behind that step. An edge e is called bad if more 
than (1 - 2 e) [el of its nodes have the same color after Step 1. Otherwise the edge is called good. 
That is, a good edge e has at least 2 e [el nodes of each color. Clearly, after Step 1 there might be 
many monochromatic edges left in 7/. In this case we have to recolor certain nodes in these edges. Similarly 
to [1, 6], we shall not only recolor the nodes in the monochro- matic edges, but also those in the bad 
edges. The aim of Step 2.1 is to find a partition of the bad edges into node-disjoint groups (i.e., two 
bad edges from different groups should be node-disjoint). The key feature of our partitioning procedure 
is that we do not consider all the nodes covered by the bad edges. Instead, in the course of the algorithm 
we shall frequently reduce the edges, that is, we shall modify the edges by removing some subset of their 
nodes. After performing Step 2.1, one could (even in polynomial time, as we will show) recolor the nodes 
within each group of bad edges independently of other groups such that all bad edges would become non-monochromatic. 
This, however, could make some of the good edges monochromatic. Therefore, in Step 2.2 we consider the 
good edges that are monochromatic after removing those of their nodes that belong to any group chosen 
in Step 2.1. The aim of Step 2.2 is to either reduce each such edge to the nodes covered by bad edges 
from one group chosen in Step 2.1, or to combine into one group all the groups covering the given edge. 
As we will see, the nodes covered by the groups constructed in Step 2.2 can be recolored independently 
so that now every edge is ensured to be non-monochromatic at the end. Let the set Ui>0 Ei built in the 
algorithm BuildA- Component be ca]led a 1-component. For each 1-component C, let Be denote the set containing 
the edge e0 in C and the edges that were added to C in (*) because they were bad. These edges are called 
the core edges of C'. They play an important role in the recoloring process in Step 3 because, as we 
shall show, our choice of e ensures that it is sufficient to recolor only Step 2: Perform the two substeps 
Step 2.1 and Step 2.2. Step 2.1: set R -- E repeat choose any bad edge e in R call Build_l-Component(e) 
until there are no bad edges left in R Algorithm Build_l- Component (eo): set i = 0 and Eo --- {e0} 
repeat set Ei+l = 0 for all edges e @ Ei do: for all edges e' E N(e) M R do: set e" = elm (U~+~ U~.~Ej 
e*) if ]e" I >_ e [e'[ then remove e ~ from R, reduce it to e" and add it to Ei+l else if e r is bad 
then remove it from R and add it to Ei+l (,) set i = i + l until Ei = 0 Step 2.2: set R = C  repeat 
choose any 1-component C in R call Build_2-Component (C) until R is empty Algorithm Build_2-Component 
(C): set i = 0 and E0 = {e0}, where e0 is any edge in Bc repeat set Ei+l --(N(EO M Be) \ (U~=o Ej) for 
all edges e' E N(E 0 M E* do: set e" = e' M ((.JbeBc b) if le"l >_ ~le'l then reduce e' to e" and add 
it to C else if e' is dangerous then (**) for all 1-components C' in R that overlap with e ~ do: add 
to Ei+l all edges in Be, that intersect e I, remove C I from R, add C' to C and Be, to Bc reduce e' to 
the nodes covered by UbeBc b and add it to C remove e' from E* set i --- i + 1 until Ei = $ Figure 1: 
Step 2 of the algorithm. (a) (b) (c) Figure 2: Illustration to Step 2.1. (a) An example of I I TM b'rY, 
three edges defining set v j=0 ~J. (b) The case when a I I i+1 new edge e' intersects the edges in v:=o 
~J in at least e Iet] of its nodes. In this case e t is reduced to the three I¢ +1 Ej. In Step 3 of the 
algorithm we shall nodes in ~j=0 recolor these three nodes to ensure that e ~ will not be monochromatic. 
(c) The case when a new edge e ~ has ili+l Ej. In a very small intersection with the edges in ~j=o this 
case we do not reduce ¢. If e ~ is good, then the ,  d+l E nodes outside [.Jj=o j will ensure that 
e t will remain monochromatic. However, if e' is bad, then we add it completely to the set Ei+l. the 
nodes covered by the core edges in order to get a non-monochromatic coloring for all edges in C. For 
Step 2.2 we need the following notation. Define C to be the set of all 1-components, and let E* = E \ 
(Ucec C) denote the set of all edges not assigned to any of the 1-components. An edge e in E* is called 
dangerous if at least 2elel of its nodes are covered by core edges 1. Let the set C built in the algorithm 
Build_2-Component be called a 2-component. For each 2-component C, let Bc denote the union of the sets 
Bc, of the 1-components C' it consists of and let Vc be the set of nodes covered by the edges in Bc. 
REMARK 2.1. Let us notice five important properties that we shall frequently use in our analysis and 
which follow immediately from our construction: (1) For every 2-component C, all edges in Bc are bad. 
 (2) For every 2-component C, it holds that UeeC e = Ue6Bc e.  (3) For every edge e in the hypergraph 
H, if it is contained as a reduced edge e ~ in a 2-component C, then te'I > e H. (4) For every 2-component 
C, if Be --{el,... ,et}, then there exists a partition of Vc into W1, . . . , Wl such that for every 
i, 1 ~ i ~ l, it holds that  w~ c e~ and IW~I> (1 -e)led. (5) If an edge e is bad (after completing 
Step 1) then there exists a 2-component which contains either e or the reduced edge of e. 1This definition 
is oriented towards our analysis presented in the next section. For the purpose of the algorithm it would 
be enough to consider only those edges for which all nodes not covered by the core edges are of the same 
color. 34 Step 3: Find a coloring for each 2-component so that all of its edges are non-monochromatic. 
In order to perform Step 3 efficiently, we use the following properties. LEMMA 2.1. (1) For every 2-component 
C there is a coloring of the nodes in Vc such that all edges in C are non- monochromatic. (2) All edges 
that are not assigned to any 2-component cannot become monochromatic by the recoloring process in Step 
3. (3) The 2-components can be recolored independently of each other.  Proof. To prove (1), observe 
that every edge e' in C is either equal to the corresponding edge e in H or is obtained from a reduction 
of e. Since ]eq ~ e lel by Remark 2.1, one can easily verify that the probability bound in Theorem 1.4 
together with the LLL imply that there is a 2-coloring for the nodes in Vc so that every edge in C is 
non-monochromatic, no matter what the color of their nodes outside Vc is. In order to prove (2), let 
us consider any edge e that was not assigned to any 2-component. This means that it was neither bad nor 
dangerous. That is, it has at least 2 e lel nodes of each color and there are less than 2 e lel of its 
nodes covered by core edges. Hence the nodes of e not covered by the core edges are still non-monochromatic, 
and therefore e cannot become monochromatic by the recoloring process in Step 3. Property (3) follows 
from properties (1) and (2) and the fact that the node sets covered by distinct 2- components are disjoint. 
[3 We will prove in the next section (Theorem 3.1) that the number of nodes to be recolored in each 2- 
component is O(logm), w.h.p. Together with property (1) of Lemma 2.1, this allows us to find a proper 
coloring for each 2-component via exhaustive search in polynomial time. Hence, property (3) implies that 
Step 3 can be performed in polynomial time. This results in a polynomial-time algorithm for the 2-coloring 
problem. To obtain a linear-time algorithm we run in two phases. The first phase consists of Steps 1 
and 2 above and the second phase is based on Steps 1 to 3 above, applied independently to each of the 
2-components resulting from Phase 1. We shall describe this procedure in detail in Section 4. This will 
establish Theorem 1.4. 3 Analysis of the Algorithm In this section we prove the following result. THEOREM 
3.1. Ire, 6, and k in Theorem 1. 4 are set as = 1/24, 5 = e2/12, and k = 1/6, then with probability at 
least 1--~ the size of every 2-component is O(log m). In order to prove this theorem, we consider all 
possible structures of a certain kind that could witness a large 2-component. These structures are defined 
in Definition 3.2. For this we need the following definition. DEFINITION 3.1. Given a hypergraph 7t = 
(V, E) and a set of edges E C_ E, let the k-neighborhood of C be defined as £ : k=O Nk(E) = N(E) : k 
= 1 g(Nk-l(8)) \ Nk-2(8) : k > 1 and the k,g-neighborhood of E be defined as Nk,,(E) = uf=,Ni(E). DEFINITION 
3.2. Consider any hypergraph 74 = (V, E). A sequence )'V = (Bo, B1,... , Bd) of edge sets Bi C E is called 
a witness structure of depth d if Bo contains a single edge and * all edges in Bi+l are in the 1,2-neighborhood 
of Bi. A witness structure is called a 2-component witness if d el (1) for every edge e E Ui=o Bi a 
subset of its nodes of size at least (1 -e)]e I can be chosen such that all e ~ are disjoint and (2) 
/or every i E {0,..., d- 1} the edges in Bi+l that are in the 2-neighborhood of Bi can be partitioned 
into sets $1,... , St for some r, such that for every Sj there is a different edge ej E N(Bi) \ Bi+l 
with lej N (Ueesj e')l -~ e lej] (note that e' is the part of e defined in (1)).  Furthermore, a witness 
structure is called valid if all d edges in Ui=o Bi are bad. Let Vw,i = Uees, e denote the set of nodes 
covered d by Bi and let Vw = Ui=o Vw,i denote the set of all nodes covered by )4). We introduce these 
structures, because our aim will be to bound the expected number of valid 2-component witnesses of a 
certain size, rather than trying to bound the expected number of 2-components of a certain size constructed 
by the algorithm. This is important, since the latter method invokes dependencies that seem to be extremely 
difficult to handle, whereas the former method is purely combinatorial in that it is not based on a certain 
selection process. The next lemma enables us to switch to these witness structures. LEMMA 3.1. For any 
2-component C constructed by the algorithm, there is a valid 2-component witness that contains all edges 
in Bc. Proof. In order to construct a suitable witness structure for C, let us simply choose Bi = Ei 
in the Build_2- Component algorithm for all i > 0. It is easy to check that this construction fulfills 
all requirements of a witness structure. Furthermore, by Remark 2.1, our algorithm ensures that disjoint 
node sets can be assigned to the edges in Be so that every edge e E Be is assigned to at least (1 - e) 
lel of its nodes. Moreover, line (**) in Step 2.2 ensures that Property (2) of Definition 3.2 is fulfilled. 
Hence the witness structure constructed above is a 2-component witness. It is also valid since our algorithm 
requires all edges in Be to be bad. [] Lemma 3.1 implies that if there is no valid 2-component witness 
over an edge set B then B cannot form a 2-component. The proof of Theorem 3.1 there- fore follows directly 
from the following lemma. LEMMA 3.2. There exists a positive constant ~/ such that the expected number 
of valid 2-component witnesses of size at least ~/- logm is at most 1/rn. Before we prove the lemma, 
let us first introduce some notation, which will be frequently used in the subsequent sections. DEFINITION 
3.3. Given any edge set g, let Vc denote the set of all nodes covered by edges in g. g is called a core 
witness if for each edge e E g a subset e ~ of its nodes of size at least (1 - e)lel can be chosen such 
that all e' are disjoint. Furthermore, g is called valid if all edges in g are bad. An edge set J: is 
called a 1,2-core witness of g if Y is a core witness and .7: is related to g as Bi+I is related to Bi 
in Definition 3.2 (2). Finally, let ftc denote the maximum number of nodes a valid 1,2- core witness 
of $ can cover. Lemma 3.2 now follows from the following three propositions. PROPOSITION 3.1. There is 
a constant c > 0 so that for every edge e of size larger than c log m it holds that Pr[e is baa~ <_ 1/(2m2). 
In particular, the proba- bility that there is a valid 2-component witness 14; with IVw,o] >_ c logm 
is at most 1/(2m). The proof of this proposition is obvious. Recall that, for every edge of a 2-component 
witness, we can select at least a (1-0-fraction of its nodes that is disjoint from the node sets assigned 
to other edges. Therefore, we can assume that the probability of an edge to be bad is "independent" of 
other edges by considering only the subset of nodes chosen for it and assuming the worst possible case 
for the remaining nodes (cf. Claim 3.3). Furthermore, Property (2) of Definition 3.2 allows us to assume 
that also the probability of an edge to be dangerous is "independent" (in the above sense) of other edges. 
These are key properties which will enable us to obtain the following result. PROPOSITION 3.2. There 
are constants 0 < ~ < 1 and 0 < /3 < 1/2 so that, for any core witness g, we have E[bE] < fllVcI, and 
for every u >_ IVel/2 it holds that Pr[bE >__ u] <__ a ~. Proposition 3.2 will be proven in Section 3.4 
after some preparations in Sections 3.1-3.3. The proof of the next proposition is left out due to space 
limitations. PROPOSITION 3.3. Let a and fl be positive constants with 0 < a < 1 and O < ~ < ½. Let Xo, 
X1,... , be any sequence of non-negative integer random variables satisfying the following four conditions: 
 X0=A,  E[Xi+I [ Xo, X1,... , Xi] ~_ fl" Xi for every i >_ O,  if Xi = 0 then Xi+l = O, and  Pr[Xi+l 
> tlXo,Xl,... ,Xi] <__ ot TM for every i >_ O and every t >_ ½ . Xi.  Then E[~j>0Xj] < 2-A, and there 
is a positive I. A constant c such that for every s > 0 Pr [}-'~j>0 Xj > c.(A+logs)] <__ 1 8 Proof. 
(of Lemma 3.2) In the following, let ld2 de- note a valid 2-component witness. From Proposition 3.1 it 
follows that 1 E[10A2 : IVw.ol >_cl logm}t] ~ 2m ' and from Propositions 3.2 and 3.3 we get that 1 E[I{W 
: IYwl > c2(IYw,ol + log,n)}l] < 2-~ ' for some positive constants cl and c2. Hence, for a sufficiently 
large constant 7, E[I{W : IVwl > 7-1ogm}l ] _< Ell{14; : IVw,ol >_ c~ logm}l] + E[I{W : IWwl ___c2(IVw,ol 
+ logm)}l] 1 1 1 < 2m + 2m m This completes the proof of Lemma 3.2. 3.1 A technical lemraa. In this 
section we present a lemma that will be essential for estimating the expected number'of valid 1,2-core 
witnesses that cover a given number of nodes. Suppose that for every edge e ~ E we have an inte- ger 
random variable Ae which we call its contribution. For any set of edges ~', let the contribution Ay of 
9 v be defined as the sum of the contributions of all edges in .7". Let Sx ~ = {~r C_ N(~) : Ay = A}. 
The next lemma provides an estimation for E[ISx~I]. LEMMA 3.3. Let c and 7 be arbitrary positive constants 
with 3' <1/288. Furthermore, let £ be any set of edges and (Ae)eeN(£) be any vector of contributions 
with the property that (1) the contribution of any edge in N(£) is either 0 or at least 1/7 ,  (e) I{e 
e N(~') : Pr[1 _< A~ < k] > 0}1 < c. 2 0,~, and (3) there is a ¢ > 1/6 so that for every edge e ~ N(£), 
Pr[Ae = k] < 2 -~'~ independently of other events of positive contribution. Then E[IS~I] < 2 -~/2 -2c/16- 
Proof. Let m~ denote the number of all possible candi- dates for sets in Sx C. We first bound mx ~. For 
every set of edges {el,... ,e~} E N(E), a sequence (si,... ,sx) is the contribution-characterization 
of {el,...,e~} if sk = [{1 _< j < r : hcj --k}[. Since there are at most e- 2 "r'k edges of contribution 
k in N(£), there can be at most 1-IkX=l(c'2~~ sets .7" C N(~) that fulfill a k $/e / prescribed contribution-characterization 
(s~,... , s~}. Let 79(A) = {(sx,... ,sx) : sj is a non-negative A . integer and ~=~ 3.sj --A}. Furthermore, 
let 79(A; ~;) = {(s~,... ,sx) ~ ~(~) si .... s~-i = 0}. By our discussion above we obtain ~ (c'20,'k~ 
  E II (~1 ...... x)E k=l Sk ] Sh (~t ..... ~x)~ ~_>t/~: Sk T'(,M1/-/) sk>O The bound given in the 
lemma for the probability that an edge has a contribution of k yields E[ISgl] < ~ II ( e-2o,k.e.2_¢.~ 
(-~t ..... ox)E ~>1/~: Sk "P'(.X ;1/-y) sk>O (e-20,k-c~ s~ 01,..- ,sx)E k>'l/~: It is easy to check 
that, for any s, n > 0, (Tn)~ is maximal for s = n/2. Hence, for any 7 _< 1/72, e2 o,'k -c )s~ ec 2~~ 
ec sk 2 e~'~/3 <_ 2-5- " ~ <_ 2~ " 2-0"~/4 Furthermore, for 7 < 1/288 and ¢ k 1/6 we have E 2-¢'k/4 
~- 2-1/24°' E 2-k/24 ~ 2-12 " 36 . ~_>l/'r k>_O Hence we get f ~ s~ ec < 2-Y Ek>l/~/ 2 -¢'k/4 < 2c/TM 
. H ~e" 2 0,~ c ) ~>_~/~: Sk ~k>0 Thus altogether we obtain --< 2-2¢A/3 E 2c/16 ElSe]  < 2 -2~/3. 
17~(~;1/~)i.2 c/16 For all A, ~; E 1N it clearly holds that IP(,X; ~)l < { o x-~ : ~ <  -1 + E~,=~ 
Ip(~,;~)l : ~>~ Using this in an induction proof yields the following claim. CLAIM 3.1. For all integers 
A,a _> 241 it holds that IP(~; ~)1 < 2~/3~. This completes the proof of Lemma 3.3. [] 3.2 Counting valid 
1-neighborhood sets. In this section we show how to apply Lemma 3.3 to bound the expected number of edge 
sets of certain size that form the 1-neighborhood of a validl,2-core witness. For this we first need 
some simple claims. The first claim follows directly from the LLL formula in Theorem 1.4, and the second 
claim is a result of standard calculations. CLAIM 3.2. For every edge e E E and k > 0 it holds that I{e'E 
g(e): le'l <_ k}l <_ 2 (~'k .e.ln2. lel. CLAIM 3.3. Consider any e C E. If we fix arbitrarily the colors 
of up to e. [e I nodes of e and then randomly color the other nodes, then it holds that Pr[e is baa~ 
< 2 -lel/2 Now we are ready to apply Lemma 3.3. Consider any core witness 8. Let the contribution A~ 
of an edge e be defined either as the size of e if e is bad, or 0 otherwise. Clearly, requirement (1) 
of Lemma 3.3 is fulfilled, since any edge in E must have a size of at least 1/6. Our assumption on E 
and Claim 3.2 together imply that I{e' 6 N(E) : ]e'] < k}] < 2 ~'k- e-ln2- I Ve[ < elV d 2 ~k. Thus 
requirement (2) holds with 1--e -- e = elVE ]. Requirement (3) follows from Claim 3.3 and the definition 
of a core witness. Since all requirements of Lemma 3.3 are fulfilled, the expected number of possibilities 
rTO) of choosing "" E,)~ edges of contribution A for a valid 1,2-core witness of C that belong to N(E) 
satisfies (3.1) r7(1) < 2 -'~/4 " 2 ~Iv~l/16 ~$,A -- 3.3 Counting valid 2-neighborhood sets. In this 
section we show how to apply Lemma 3.3 to bound the expected number of edge sets of certain size that 
form the 2-neighborhood of a valid 1,2-core witness. Let us fix some core witness E. We say an edge e 
E N(E) is of type k if there is a valid core witness :P 6 N(e) \ E with ~-~'e~ }e'[ : k. (Note that e 
can be of different types at the same time if there axe different $-'s of different size.) Recall from 
Definition 3.2 that in order e to be of type k > 0 the number of nodes in e covered by ~ must be at least 
e. [e[. Therefore we must have [e[ < k/e. With this we state the following claims. Claim 3.4 follows 
directly from Claim 3.2, and Claim 3.5 follows from the bound for r7(1) and the fact ~C,,X that the 
size of an edge can be at most k/e in order to be of type k > 0. CLAIM 3.4. For every edge e E E and 
positive k it holds t{e' E N(e) : e' can be of type in {1,... ,k}[ _< 2 k'~/~ .e-ln2. [e I . CLAIM 3.5. 
For every e E E it holds that Pr[e is of type k] < 2 -k/6 For every edge e~ E N($) let us introduce a 
set {ei,( I~{I,"" , ei,x} of copies of e{ (A will be specified be- low). We define the contribution 
A~{,j of ei,] to be j if e{ is of type j and 0 otherwise. Now we apply Lemma 3.3 to the copies of all 
edges in N(E). Clearly, require- ment (1) of Lemma 3.3 holds, since every edge must have a type of either 
0 or at least el6. Requirement (2) follows from Claim 3.4 and requirement (3) follows from Claim 3.5 
and the definition of a core witness. Thus it follows from Lemma 3.3 that the expected number of possibilities 
r'(2) of choosing edges of contribution A for "-'E,A a valid 1,2-core witness of E that belong to N2(E) 
sat- isfies (3.2) r7(2) < 2 -x/12 - 2 ~lvel/x6 "-'$,A -- 3.4 Proof of Proposition 3.2. We are now ready 
to prove Proposition 3.2. Consider any fixed 1,2-core witness E. Let the contribution of E be the sum 
of the edge sizes of its core edges. If E has contribution )% then it must cover v nodes, where (1 -e)A 
< v < A, by Remark 2.1. Thus we can apply the formulas (3.1) and (3.2) from Sections 3.2 and 3.3 to obtain 
the following bound for all v >_ 6elVc [. A Pr[bc >_ v] -- E,t¢ "-'£,A--~ ,~>(1-e)v t¢=O < 164.2 -(1-e)v/12 
 2 eIVel/s < 164- 2 -(1-~)~'/12 -T '/4s < 2 .'/24 . From this it follows that E[~E] _< 6c-IVel + ~ 2 
-~'124 < IVEII2 . ~'>6~-IVEI This completes the proof of Proposition 3.2. 4 A randomized linear-time 
algorithm for 2-coloring In this section we show how to modify the algorithm presented in Section 2 to 
obtain a randomized algorithm that returns a 2-coloring of a hypergraph in expected linear time. In the 
following, let m denote the number of edges and let M denote the sum of the sizes of all edges in the 
input hypergraph. Our algorithm runs in two phases. 4.1 Phase 1. In the first phase we run Step 1 and 
Step 2 of the algorithm presented in Section 2 (however, the e there has to be replaced by Vq). Clearly, 
the time required for Step 1 is O(M). Step 2 also has a runtime of O(M), since for every hyperedge it 
has to be checked at most once via its nodes whether it is bad, and for every node covered by a 1-component, 
the set of edges adjacent to it has to be evaluated at most once. In Section 3 we investigated the structure 
of the 2-components obtained. It follows from Theorem 3.1 that with high probability there is no 2-component 
of size larger than c log m for a sufficiently large c. As we will show, it follows also from the analysis 
presented in Section 3 that the expected number of 2-components of size k is at most m for a suitably 
chosen constant 4. Indeed, since each 2-component of size k has to start from a bad edge e of size less 
than or equal to k, the expected number of 2-components ]4; of size k is bounded by the following sum: 
Pr[YV : Vw,o = {e} is of size k] + Z e: lel<_k/(2 c) Z Pr[e is bad] , e: lel~{k/(2 e)+l ..... k} where 
c is chosen as in Proposition 3.3. We can apply Propositions 3.2 and 3.3 to bound the first term from 
above by I{e : [e I _< k/(2c)} I 2 -k/(2c). By Claim 3.3, the second term is bounded by [{e : [e I > 
k/(2c)} I 2-k/(4 c). Hence, the expected number of 2-components of size k is at most Z 2-k/(2 e) + Z 
2-k/(4 c) _< m 2 -k/(4 c) . e: lel<k/(2 e) e: lel>k/(2 c) 4.2 Phase 2. In the second phase we consider 
each 2- component C obtained after Phase 1 independently. For every C we run Steps 1 and 2 (again, with 
e replaced by V~. Let £c be the event that all of the 2-components obtained out of C after performing 
Steps 1 and 2 are of size at most ~ log [Vc[, where ~ is a suitably chosen constant and Vc is the set 
of the nodes covered by the edges in C. We repeat independently Steps 1 and 2 for C until the event £c 
holds. Then, we perform Step 3 as .described in Section 2. In the following we estimate the running time 
of Phase 2. Since we are using the same algorithm as for the whole hypergraph, we can apply our analysis 
pre- sented in Section 3 to study the 2-components obtained in Phase 2 out of the 2-component C. We start 
with the first part in which, for every 2-component C obtained af- ter Phase 1, we repeat Steps 1 and 
2 until the event £c holds. Then, by Claim 3.2, there are at most [Vc[" 26'k edges of (possibly reduced) 
size at most k in C, where 6' = 6/v~. Since Pr[e is bad] _< 2 -[el/2, the probability that there is a 
bad edge e in C that has a size larger than or equal to cl log [Vc[ is bounded from above by 2_1~1/2 
  < Z IVcl-2 ~'~-2 -'/: eEC: k>cl log IVc[ lel_>c z log IVcl <_ 5" [VcI " 2 -c~l°glVcl/3 Therefore, 
if we choose cl sufficiently large, then with probability at least 1 -l/iV c[ each Vc,o obtained in Step 
2 is of size not larger than cl log [Vcl- Similar argu- ments (by applying Propositions 3.2 and 3.3) 
imply that with probability at least 1 - 1/[Vcl each 2-component within C will cover at most ~ log [Vcl 
nodes, for a suffi- ciently large constant g. Therefore the expected running time in Steps 1 and 2 until 
the event £c holds is of the order of the sum of the sizes of the (possibly reduced) edges in C. Summing 
this over all 2-components, the expected running time is at most O(M). Once the event Cc holds, the running 
time of Step 3 for all the 2-components C1,... ,Cr obtained from C in Phase 2 is bounded by i=1 eECi 
r i=l where Vc~ is the set of nodes in Ci at the beginning of Step 3 in Phase 2 and we have used the 
trivial upper bound [Ci[ _< 21vc, I. Since after Phase 1 the expected number of 2- components with k 
nodes is bounded by 2-rv,m the expected time required to perform Step 3 for all 2- components is bounded 
by  O(IVcl 2~+~) 2-comp. C of Phase 1 = 0 k2¢+2 m "2-~ = o(m). \ k~-I Hence the total expected running 
time of our algorithm is O(M). 5 Extensions to c-coloring In this section we sketch how to extend our 
results to c- coloring. One condition in Theorem 1.4 is that the size of the hyperedges must exceed some 
constant. In the following theorem we demonstrate that this condition can already be avoided if 4 colors 
are available. THEOREM 5.1. There exist constants A',E' > 0 so that for any O < 5 <_ A' and O < e <_ 
E ~ it holds: Consider any hypergraph 74 with edges el,... ,em of any size. Let Ai be the event that 
ei is monochromatic. Further, let xi = 4 -~ led. If it holds that (5.3) (Pr[Ad) ~ < xi I-I (1-xj) ejEN(el) 
for all i E {1,... ,m}, in the case that the color of each node is chosen i.u.r., then there is a randomized 
algorithm that finds a 4-coloring of 74 in polynomial time. Proof. Let us choose £' = E/6 and A' = A/2, 
where 8 = 1/24 and A = 82/12. From Theorem 1.4 and Remark 1.6 we know that in this case there is a 2-coloring 
for all hyperedges in 7/ of size at least 1/A. Thus there are 2 colors left we can use to color the hyperedges 
of size below 1/A. All possible combinations of the 2 sets of 2 colors require only 4 colors, and hence 
a 4-coloring of 7/could be found if the small hyperedges could be 2-colored. For any edge ej of the 
small edges it clearly holds that xj = 4 -~lejl > 2-zxtejE >_ 1/2. Hence, 1-xj <_ 1/2 and therefore Pr[Ai] 
' < zi~jeg(e,)(1-xj) for IN(ei)l > 0 only if 4 -d~d < 1/2. Thus any ei with IN(ei)l > 0 has to have a 
size of at least 3/g. Hence, all ei with leil < 3/g are isolated from all other small edges and thus 
can be colored without any problem. It therefore remains to consider only hyperedges of size k e {3/g,...,1/A}. 
For each of these edges the probability to become monochromatic is less than 2.2 -k, and any of these 
edges can intersect at most (g/3) k other edges without violating inequality (5.3). This suffices to 
use one of the algorithms for 2-coloring uniform hypergraphs to find a 2-coloring for the small hyperedges, 
t:3 We remark that the higher the value of c in Theo- rem 5.1 is, the better are the values that can 
be found for A' and g' (e.g., the property that small hyperedges are isolated from other small hyperedges 
is not needed any more). References [1] N. Alon. A parallel algorithmic version of the Local Lemma. Random 
Structures and Algorithms, 2(4):367-378, 1991. [2] N. Alon, A. Bar-Noy, N. Linial, and D. Peleg. On the 
complexity of radio communication. In Proceedings of the 21st Annual ACM Symposium on Theory of Computing, 
pages 274-285, 1989. [3] N. Alon, O. Goldreich, J. H£stad, and R. Peralta. Simple constructions of almost 
k-wise independent random variables. Random Structures and Algorithms, 3(3):289-304, 1992. [4] N. Alon, 
C. McDiarmid, and B. Reed. Acyclic col- oring of graphs. Random Structures and Algorithms, 2(3):277-288, 
1991. [5] N. Alon and J. H. Spencer. The Probabilistic Method. Wiley-Interscience Series in Discrete 
Mathematics and Optimization, John Wiley &#38; Sons, New York, 1992. [6] J. Beck. An algorithmic approach 
to the Lov~sz Local Lemma. I. Random Structures and Algorithms, 2(4):343-365, 1991. [7] A. Z. Broder, 
A. M. Frieze, and E. Upfal. Static and dynamic path selection on expander graphs: A random walk approach. 
In Proceedings of the 29th Annual ACM Symposium on Theory of Computing, pages 531- 539, 1997. [8] P. 
Erd6s and L. Lov£sz. Problems and results on 3- chromatic hypergraphs and some related questions. In 
 A. Hajnal, R. Rado, and V. T. Sds, editors, Infinite and Finite Sets (to Paul Erdhs on his 60th birthday), 
  volume II, pages 609-627. North-Holland, 1975. [9] P. Erd6s and J. Spencer. Lopsided Lov~ksz local 
lemma and latin transversals. Discrete Applied Mathematics, 30:151-154, 1991. [10] G. Even, O. Goldreich, 
M. Luby, N. Nisan, and B. Veli~kovid. Efficient approximations of product distributions. Random Structures 
and Algorithms, 13(1):1-16, 1998.  [ll] U. Feige and C. Scheideler. Improved bounds for acyclic job 
shop scheduling. In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, pages 624-633, 
1998. [12] H. Hind, M. Molloy, and B. Reed. Colouring a graph frugally. Combinatorica, 17(4):469-482, 
1997. [13] F. T. Leighton, B. M. Maggs, and S. B. Rao. Packet routing and job-shop scheduling in O(Congestion 
+ Dilation) steps. Combinatorica, 14(2):167-180, 1994. [14] F. T. Leighton, B. M. Maggs, and A. W. Richa. 
Fast algorithms for finding O(Congestion + Dilation) packet routing schedules. Combinatorica, 19(3):375-401, 
1999. [15] T. Leighton, S. Rao, and A. Srinivasan. New al- gorithmic aspects of the Local Lemma with 
applica- tions to routing and partitioning. In Proceedings of the lOth Annual ACM-SIAM Symposium on Discrete 
Algorithms, pages 643-652, 1999. [16] C.J. Lu. A deterministic approximation algorithm for a minmax integer 
programming problem. In Proceedings of the l Oth Annual A CM-SIAM Symposium on Discrete Algorithms, pages 
663-668, 1999. [17] M. Molloy. The probabilistic method. In M. Habib, C. McDiarmid, J. Ramirez-Alfonsin, 
and B. Reed, editors, Probabilistic Methods for Algorithmic Discrete Mathematics, pages 1-35. Springer-Verlag, 
1998.  [18] M. Molloy and B. Reed. Further algorithmic aspects of the Local Lemma. In Proceedings of 
the 30th Annual A CM Symposium on Theory of Computing, pages 524- 529, 1998. [19] J. Naor and J. Naor. 
Small-bias probability spaces: Ef- ficient constructions and applications. SIAM Journal on Computing, 
22(4):838-856, 1993. [20] J. Radhakrishnan and A. Srinivasan. Improved bounds and algorithms for hypergraph 
two-coloring. In Pro-ceedings of the 39th IEEE Symposium on Foundations of Computer Science, pages 684-693, 
1998. [21] B. Reed. w, A, and X. Journal of Graph Theory, 27(4):177-212, 1998. [22] J. Spencer. Ten Lectures 
on the Probabilistic Method. 2nd Edition. SIAM, 1994. [23] A. Srinivasan. An extension of the Lov~sz 
Local Lemma, and its applications to integer programming. In Proceedings of the 7th Annual ACM-SIAM Sympo- 
sium on Discrete Algorithms, pages 6-15, 1996.  
			
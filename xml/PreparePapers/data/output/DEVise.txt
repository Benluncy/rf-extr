
 DEVise: Integrated Querying and Visual Exploration of Large Datasets M. Livnyl R. Ramakrishnan, K. Beyer, 
G. Chen, D. Donjerkovic, S. Lawande, J. Myllymaki and K. Wenger Department of Computer Sciences, University 
of Wisconsin-Madison {miron,raghu,beyer, guangshu,donjerko,ssl @ssi,wenger}@3cs.wise.edu Abstract DEVise 
is a data exploration system that allows users to ez-s­ily develop, browse, and share visual presentations 
of large tabular dataaets (possibly containing or referencing multi­media objects) from several sources. 
The DEVise framework is being implemented in a tool that has been already success­fully applied to a 
variety of real applications by a number of user groups. Our emphasis is on developing an intuitive yet 
power­ful set of querying and visualization primitives that can be easily combhed to develop a rich set 
of visual presentations that integrate data from a wide range of application do­mains. While DEVise is 
a powerful visualization tool, its greatest strengths are the ability to interactively explore a visual 
presentation of the data at any level of detail (includ­ing retrieving individual data records), and 
the ability to seamlessly query and combine data from a variety of local and remote sources. In this 
paper, we present the DEVise framework, describe the current tool, and report on our ex­perience in applying 
it to several real applications. 1 Introduction It is being widely recognized that the traditional boundaries 
of database systems need to be extended to support applica­tions involving many large data collections, 
whether or not all these collections are stored inside a DBMS. In this paper we describe an effort to 
apply the query optimization and evaluation techniques found in a DBMS to work on datasets outside a 
DBMS, and to combine querying features with powerful visualization capabilities. The main goals of the 
DEVise project include: . Visual Presentation Capabilities: Users can ren­der their data in a flexible, 
easy-to-use manner. Rather than provide just a collection of presentation idioms (e.g., piecharts, scatterplots, 
etc.), we have developed a simple yet powerful mapping technique that allows a remarkable variety of 
visual presentations to be de­ veloped easily through a point-and-click interface (or e~y-to-write plug-ins 
, if necessary). A distinguishing Permissionto make digitallhardcopy of pwt or all this work for pereonalor 
claasroomuseisgrantedwithoutfeeprovidedthat copieeerenot medeor distributedfor profitor commercialedven­tege, 
the copyright notice, the title of the publication and ita date appeer, and notice ie given that copying 
is by permission of ACM, Inc.To copy otherwise,torepublish,to poston servers,orto redistributeto lists,requirespriorspecificpermissionandlorafee. 
SIGMOD 97 AZ,USA 01997 ACM 0-89791 -911 -419710005...$3.50 feature is that a user can interactively drill 
down into a visual presentation, all the way down to retrieving an individual data record. . Ability 
to Handle Large, Distributed Datssets: The tool is not limited by the amount of available main memory, 
and can access remote data over a network as well as local data stored on disk or tape. Distributed database 
query optimization is carried out to speed evaluation of queries over the Web; we do not die­cuss this 
aspect of DEVise here. The ability to deal with datasets larger than available memory is central to DEVise 
s support for drilling-down into the data. . Collaborative Data Analysis: DEVise enables sev­eral users 
to share visual p-resentations of the data, and to dynamically explore these presentations, inde pendently 
or concurrently (so that some of the changes made by one user are seen immediately by several other users 
browsing the same data).  By integrating querying with data visualization features, DEVise makes it 
possible to optimize data-level accesses that arise due to visual operations more effectively; the se­mantics 
of how different parts of the visual presentation are linked offers many hints for what to index, materialize, 
cache or re-compute. Further, memory can be managed by a single btier manager that supports both visualization 
and query evaluation. The DEVise exploration framework is extremely power­ful, but to appreciate this 
power fully, one must work with the system or at least look at several applications in some detail. This 
is especially true with respect to understanding just how flexible the DEVise visual model (Sections 
2, 3 and 4) really is. The real power of DEVise s visualization capabilities lies in the support for 
interactively exploring the data visually at any level of detail, including retrieving individual data 
records. This results in complex queries being generated through simple visual operations, and effective 
optimization of these visual queries is crucial for interactive use. In this paper, we concentrate on 
describing the visual model and visual operations rigorously in set-oriented terms, to provide a foundation 
for database-style processing of vi­sual queries. The seamless integration of visual queries and database-style 
queries in DEV~se is one of its ~que and most useful features. 1.1 Motivating Examples DEVise is a 
novel tool in many ways, although many exist­ing tools support some of its features. We now present some 
example scenarios to illustrate its capabilities, and to help the reader to understand how it goes bevond 
other related tools. (For details on these app~ication~, including exam­ple full-color DE Vise screens, 
see the DEVise home page at http: /luvv. cs. uisc. edu/-devise) Financial Data Exploration: In collaboration 
with the Applied Securities Analysis program in the UW Busi­ness School, we ve developed an environment 
for integrated visual exploration of financial datasets from several vendors, including Compustat, ISSM 
and CRSP. This application illustrates DEVise s ability to access data from a variety of formats, without 
requiring users to store all data in a common repository, and its use in integrating information from 
manv sources-users can now look for correlations and . trends using the combined information from a 
variety of ven­dors. It also highlights DEVise s ability to support complex, large datasets: for example, 
the Compustat data contains records with over 350 fields, and a hierarchical view of this schema, supported 
by DEVise, makes it much easier to work with. DEVise also makes it e~y to slice such multidimen­sional 
data along any two axes and to correlate the ranges seen in different slices; thus, it allows a user 
to navigate through the multidimensional space to identify interesting regions. The totzd size of the 
Compustat dataset is over IGB. In contrast to the wide Compustat data, ISSM provides trade and quote 
histories for over 5000 stocks; while each history contains just a few fields and relatively few records, 
the total amount of data is enormous. (The IBM history for 1992, for example, contains about a million 
records and is over 20MB. ) DEVise makes it possible to browse several histories simultaneously, at various 
levels of detail, and to move bet ween them easily. Thus, DEVise deals with not only large volumes, but 
also large data complexity. R-Tree Validation: The welLknown R-tree multidi­mensional index organizes 
a collection of points and boxes (which bound spatial objects), Each leaf node (page) con­tains several 
points or boxes, and each index node contains several boxes (each of which bounds all the cent ents of 
a child page ). While developing R-tree algorithms, it is im­portant to understand how different datssets 
are packed into R-trees, and this can be accomplished naturally by vi­sualizing the tree. An R-tree can 
be visualized in DEVise as follows. First, note that each box is a data record with fields (xI., WJ,xh,, 
yh: ); this information can be used to map each data record to a rectangle on-screen. By mapping all 
records in a node, we can see the node as a collection of boxes, and by mapping all the nodes in a given 
level, we see a hor­izontal slice of the R-tree. Given such a visual presentation, the visual operations 
supported in DEVise allow a user to explore the tree, level by level, to scan around in a level and on 
a page, to zoom into a specific region of the tree, and even retrieve individual data records ( boxes 
in leaf nodes, in this example). The visual presentation of an R-tree can be applied to any R-tree dataset, 
since there is a clean separation between the definition of the presentation and the data that it oper­ates 
on; this is analogous to the separation between a query and the input relations in a DBMS. Defining the 
R-tree vi­sual presentation in DEVise is straightforward, and can be done using a point-and-click GUI. 
Thk example illustrates the flexibility of the presenta­tion mechanism. We were able to develop a sophisticated 
presentation for a specialized data structure with ease, using the DEVise point-and-click interface for 
defining new visu­ alizations. It also highlights DEVise s ability to deal with large datasets, and 
demonstrates the value of visual mining for unusual patterns: examining some real datasets (Tiger data 
for Orange county, a few hundred thousand records), we noticed some unusual arrangements of boxes near 
page boundaries, and by retrieving the relevant records (simply by clicking on them!) we were able to 
find some subtle bugs in our R-tree bulk loading algorithms that would otherwise have been extremely 
difficult to spot. Family Medicine and NCDC Weather Data: DE Vise is being used by the UW Family Medicine 
department to provide physicians access to data that is collected and maintained independently by five 
clinics in the Madison area. In addition to the clinic data, which is presented vi­sually in such a manner 
as to allow physicians to look for certain trends and correlations, we provide uniform access to weather 
data for the Madison area from the National Climate Data Center (NCDC) data repository. For exam­ple, 
when a physician looks at a series of patient visits in January 96, she may want to look at the temperature 
in Madison over the same period to see if there is a correla­tion. (The physicians indicated that they 
wanted to look for such correlations!) A common usage pattern is that a physician zooms and scrolls on 
the visit data, which is local, and the linked temperature view must then be automatically uDdated. DE-Vis~ 
does this intelligently, by translating v~su~ operations into queries on the underlying data, and utilizes 
form-based query capabilities at the NCDC archive-one can specify a region and period of interest for 
a particular time-series to ensure that only the desired data is fetched. In this example, visual operations 
generate simple selections on the remote data; more generally, joins of remote or remote and local datasets 
may be involved, and DEVise generates a suitable distributed query evaluation plan and evaluates the 
query accordingly. Cell Image-set Exploration: In this application, we are working with biologists who 
are dealing with large sets of images of cells, where each cell image has an associated record with over 
30 fields, containing information about when and where the image was recorded and details about the content 
of the image. The biologists working with these images are looking for correlations in the records that 
can be used to predict pathological features in the associated images. Using DEVise, we have developed 
a visual pre­sentation that allows a biologist to extract records satisfy­ing certain selection criteria, 
identify subsets of the selected records that satisfy further conditions, and then retrieve the associated 
images at any desired level of resolution. The development of the DEVise application was done using a 
visual interface, using the notions of views, mappings, finks etc. supported by DEVise, and the biologists 
exploration is also done entirely through a visual interface supporting DE Vise s notion of visual queries. 
Executing user operations involves a combination of evaluating SQL-style queries and then updating the 
visual presentation of the results, but the biologists can think (and express desired operations) entirely 
in terms of what they see on-screen. If a biologist finds an interesting correlation in the data, he 
can send an active report to a colleague. The active re­port consists essentially of the definition of 
the visual pre­sentation, and, at the sender s discretion, parts of the actual data being visualized. 
The recipient can open the report us­ing her own copy of the data, see the identical screen as the sender, 
and then proceed to interactively explore the data further. This is extremely useful for collaborative 
analysis of the biologists experimental data. Indeed, the DEVise arch]­tecture makes it possible for 
two or more biologists to con­cumentl y view the same report, so that changes made by one are instantaneously 
visible to others, although the tool does not support this capability yet. Another feature enabled by 
the architecture, and which we are currently working on, is called hyperdata. Biologists may fmd several 
trends, each of which can be shared with others through an active report: in addition, they can create 
a summary presentation (say) that draws upon the underlying data and also points to the various active 
reports of interest. This enables a reader of the summarv rmesentation (which is itself iust another 
ac­ .. tive report) to interactively bring up any ~f the referenced active reports simply by clicking 
on the relevant portion of the summary report; the referenced report can then be in­teractively explored. 
Intuitively, an active report is like a photograph that can come alive -users can scroll, zoom etc. on 
it and hyperdata enables references to other re­ports, not just data values. Soil Sciences Classification: 
This application illus­trates an important point: users often want to generate various kinds of summaries 
of their data, explore the sum­mary information, and then be able to interactively look at the corresponding 
portion of the underlying data. This makes it necessary for the visualization component of DE Vise to 
understand the semantics linking the summary and the summarized data. A research group in Soil Sciences 
is working on automatic classification of forestry-canopy im­ages, which are being generated in large 
numbers as part of the BOREAS field experiments. They want to process images and classify the pixels 
into categories like trees and sky , and even branches , soil , sunlit leaves , etc. We ve combined a 
tool called BIRCH [15], which was developed for finding clusters of points in multidimensional datasets, 
with DEVise to create an analysis environment that they are currently using on a daily basis for classifying 
images. By applying BIRCH, they obtain a collection of clusters, each of which corresponds to a category 
(e. g., trees ). This col­lection of clusters can be thought of as the summary of the data for that image. 
A scientist can iteratively see the clus­ters, refine the parameters of BIRCH, and re-cluster, until 
the clustering is satisfactory. They can then take the data points that are summarized by a cluster, 
say trees , and identify cluaters within this set of points (e.g., sunlit leaves and branches ). The 
crucial point here is how the relationship between clusters (such as trees ) and the points summarized 
by them is preserved, and communicated by BIRCH to DEVise. Such integrated interactive exploration of 
data and summary meta­data is an extremely powerful paradigm, and one of the challenges facing us is 
to develop general mechanisms that allow any analysis tool (e.g., a tool that finds association rules, 
or even an SQL query that finds averages by some group like department!) to communicate the semantics 
link­ing the summary information and the summarized data to DEVise. 1.2 Related Work DEVise is related 
to tools that support data visualization, data integration, distributed query processing, Web browsers, 
and collaborative computing. Clearly, a comprehensive dis­cussion of all the related work is beyond the 
scope of this paper, but we now briefly discuss the relationship of DEVise to well-known tools in each 
of these categories. An introduction to existing visualization software can be found in the surveys by 
Kornbluh[7] and Braham[2]. From the standpoint of data visualization, DEVise is a general­purpose tool 
for visual exploration of tabular datasets, un­like tools like Vis5D [5], LinkWinds [6], Traceview [10], 
Para-Graph [4], etc., that are specialized for a particular ap­plication domain. Other visualization 
tools (e.g., Vis5D, LinkWinds, AVS [14], Khoros [13]) also assume that the datasets are sufficiently 
small for them to run entirely in main memory; such an assumption limits the ability of the tool to go 
back to the source data record from its visual presentation. Recently, the Tioga project at Berkeley 
and the DataSpace project at Bell Labs [11] have also addressed the problem of visualizing large datasets 
[12, 1], which is in­dicative of the growing importance being attached to this is­sue. Their approach, 
however, differs from ours in important ways. DataSpace is not as flexible in terms of the kinds of vi­sualizations 
that can be developed, although it supports 3D rmesentations much better than DEVise (at least currentlv 
) ~oes. However, DataSpace assumes that ~ery large dataae~~ are stored in an external database, where= 
all its data struc­tures are assumed to fit in memory: thus, it cannot handle visualizations in which 
the data to be rendered on-screen exceeds these memory bounds. We have taken a declarative approach to 
defilng our visualization primitives, whereas Tioga supports a more imperative, programming-oriented 
style of defining visual presentations. DEVise is also more comprehensive in its support for distributed 
query optimiza­tion over the Web, its novel btier management features, and its collaborative computing 
features. While DEVise has aspects in common with data integra­tion systems like IBM s DataJoiner, we 
will not cover these aspects in the present paper; we therefore omit discussion of related work in this 
area as well. With respect to collaboration tools, such as groupware like Lotus Notes or workfiow m oducts. 
DEVise is lanzel~ .-? complementary. There is no support in DEVise for many of the functions provided 
by such tools. However, DEVise en­ ables several users to share visual presentations of the data, export 
such presentations over the Web, and to dynamically explore these presentations, independent y or concurrently 
(so that some of the changes made by one user are seen im­mediately by several other users browsing the 
same data). Thus, DEVise adds an important capability for collaborative analysis of large datasets. In 
two previous papers ([3, 8]), we reported on early versions of DEVise, with a focus on how its visualization 
features could be used to develop a variety of applications. While the basic mapping technique has remained 
unchanged in the current version, the visualization capabilities of DE Vise have evolved considerably 
since, and we have added data transformation/querying capabilities and extended the framework to support 
collaborative computing. In this pa­per, for the first time, we give rigorous set-oriented seman­tics 
for all visual operations, thereby establishing a firm connection between visualization in DEVise and 
relational queries, and laying the foundation for database-style opti­mization of visual queries. 1.3 
Paper Outline The rest of this paper is organized as follows. We describe visual presentations in DEVise 
in Section 2, queries over vi­sual mesentations in Section 3. and illustrate the Dower of . L visual 
presentations in Section 4 by showing how sophisti­ cated SQL queries are generated through intuitive 
user-level operations on visual presentations. We briefly discuss data transformation/query capabilities 
and the challenges posed by the DEVise combination of visufllzation and querying, especially in the context 
of Web data, in Section 5. We dis­cuss optimization issues in Section 6 and DEVise support for complex 
tasks such as uniform data/metadata exploration and collaborative data analysis in Section 7. 2 The DEVise 
Visualization Model Visualization in DEVise is based on mapping each source data record to a visual symbol 
on screen. Source data ta­bles are called TData(for tabular data ), and the result of applying a mapping 
to a TData table is a GData (for graphi­cal data ) table, which is a high-level representation of what 
isto be painted on-screen. The actual painting is carried out by drawing routines that are typically 
platform specific (e.g., using X-window primitives or Windows NT drawing primitives); we will not discuss 
the details of how GData is painted any further. Mappings, TData and GData form the building blocks for 
abstractions such as viewsand visual presentations. We define below the various elements of the DEVise 
model and its visual idioms. As an illustration we consider visualization of data in the following tables: 
DEPARTMENT( DID, DNAME, BUDGET, NUHEMPS) department id, name, budget and number of employees ITEM ( ITE141D, 
INAHE, COST, DID ) item id, item name, cost of iten and department selling it SALES ( DATE, ITEPIID, 
CUSTID, NUNBER) items sold, their number and customer ID, on each date (mre/dd) OVERALL.SALES( DATE, 
DID, TOTREV) total sales revenue by dept id and date 2.1 Basic Concepts TDATA: This is a collection of 
records with one or more attributes, along with a schema that specifies the domain (type) of each attribute. 
In our illustrative example, each table (DEPARTMENT, ITEMS, OVERALL-SALES and SALES) represents a TData 
source. We assume that an appropriate type is specified along with the attribute in each schema. GDATA: 
Tocreate a visualization, each TData record is mapped to a visual symbol. A GData record has a set of 
visual attributes: z, U, size, coior, pattern, orientation and shape. MAPPING: This is a function that 
is applied to a TDatarecord to produce aGData record. The mapping is associated with the TData schema 
(and not with the data itself-thus the same mapping may be applied to different data sources with the 
same schema). Figure lshows a visualization of the TDatasources de­scribed earlier. V1 shows TOTREV on 
the y-axis and DATE on the x-axis. Also, each DID is mapped to adif­ferent symbol (square, circle, triangle). 
Each symbol on the screen represents a single TData record. Thus the mapping is (x = DATE , y = TOTREV, 
shape = DID). An alter­native mapping may use a different color for each DID. V 1 is an example of a 
DEVise view and is enclosed in Wl, a DEVise window, both of which we define below. 2.2 View: The Unit 
of Presentation A view is the basic display unit in DEVise, and consists of three layers: the background, 
data display and cursor dis­play. The background includes the actual background on which the data is 
drawn and decorations such as title and axes. The cursor display layer is a data-independent layer that 
gives additional information about the data display layer. For instance, it can be used to highlight 
a portion of the data display, as in view V3 in Figure 1. Before describing the data display layer, we 
observe that each view has an associated mapping and TData, and an associated visual jiher. A visual 
filter is a set of selections on the GData attributes of the view. For instance, a visual filter may 
select a range of x and y attributes and a certain color. View V1 in Figure 1 has a visual filter restricting 
the x-axis to DATEs for the month of July. The data display layer is GData obtained by applying the mapping 
to TData and then selecting the GData records that satisfy the visual filter. We use VGData to denote 
the GData records visible in the data display layer, and view template, or view definition, to refer 
collectively to all components of a view except the TData and data display layer. Intuitively, a view 
template is the data-independent portion of a view, and the VGData, which is computed from the TData, 
is the data­dependent portion. Together, they define a view completely. 2.3 Coordinating Views Cursors 
and links are two kinds of view coordination mech­anisms in DEVise. A cursor allows the visual filter 
of one view (called the source view) to be seen as a highlight in an­other view (the destination view). 
Cursors are bidirectional in that a change in either the source or the destination view causes a corresponding 
change in the other view. For in­stance, Figure 1 shows a cursor with view V 1 as source and V3 as destination. 
Notice that the two views have the same x-attribute and the highlight in V3 extends over the range of 
DATE values displayed in V1, i.e., the month of July. If the highlight is moved over to the month of 
December, View V1 will show the data corresponding to December. A link is a constraint that allows the 
contents of two views to be coordinated. Figure 1 illustrates different types of links supported by the 
DEVise model. A visual link is a selection condition that is added to the visual filters associated with 
each of the linked views (obviously, the GData attribute sets for each of the linked views must contain 
the attributes mentioned in the visual link selection). For example, the views V1 and V2 have a visual 
link on the x axis. This means that both the views display data for the same range of DATE values. So 
if the user zooms in on V1 to see the data for the last week of July, view V2 will also change appropriately. 
A record link links two views (with possibly different TData sources T1 and Tz), on a set of common TData 
at­tributes, say A. A record link requires that the projection of the VGData on the linked attributes 
for first linked view (called the master) should act as a jilter on the TData of the second linked view 
(called the slave). A record link could be either positive or negative. Consider the set of TData records, 
say T, that contribute to the VGData for the first view. (Some TData records do not satisfy the selections 
in the visual filter for the view, and therefore do not contribute to the VGData for the view.) The positive 
(negative) record link intuitively says that the second view should behave as if its TData consists of 
only those records in Tz that have (do not have) the same A values as those in T. A positive record 
WI V6 I = 7/1 DATE 7t31 . ~ ~ I :00000,00 . . . 7/1 . ° DATE . . V2 7/31 I .1 2 DID 3 1 . 1 . A 234 DID 
. W2 V8 V9 W4 . . A . O 9 A A AA DATE 7/1 7/31 lml . L 123 o DID . mmm, COST Vlo W6 f A I 7/1 DATE 7/31 
I / g= Sm of~MS sold for each week in July V5 n d L7/1 7 15 DATE 7/21 7/31 . . Figure 1: An Example of 
a Visual Presentation  link is useful for synchronizing two views that display dif­ ferent attribute 
combinations from the same TI)ata set. A negative record link gives us the ability to do set differences. 
Figure 1 shows a positive record fink from Views V6 to VI on DID. Notice that view V6 shows three DID 
records and V1 shows the TOTREV corresponding to these DIDs only (as indicated by the shape attribute 
of the GData in both the views). The record for DID = 4 has not been selected in V6 and so does not appear 
in V 1. Assuming there are only four DID values, if the record fink had been negative, then V 1 would 
only display TOTREV (for the month of July), for DID =4. An operator link is associated with views that 
are called the link masters and an operator (such as union, intersection, negation or join). The link 
creates a TData source that is the result of applying the operator on the TData(s) corresponding to the 
VGData(s) of the link mas­ters; whether this TData table is materialized or computed as needed in response 
to user operations is implementation dependent. The user can now define a view (called a slave) on this 
TData source by specifying a mapping. Once the slave view is created any visuaf query on the link masters 
would afTect the data in the slave view, just like in a vi­sual or record link. Figure 1 illustrates 
union and join links. View V9 has a join link from views V6 and V7. Thus, the TData records in V6 (DEPARTMENT) 
and V7 (ITEMS) are joined on DID, to produce a new TData source con­sisting of attributes BUDGET, DID 
and COST. Note that the join is performed only on those records (determined by the visual filter) contributing 
to the VGData of the views. View V9 is a visualization of attributes COST and BUD-GET. Contrast this 
with a visual join shown in views V6 and V8 where a join is performed on DID by visual align­ment of 
the x-axes of the views. The visual join in this case gives the same information as the join link at 
a considerably lower cost. View V1O has a union link from views V6 and V7, on the DID attribute. A careful 
reader may have observed that a record link provides a mechanism similar to operator finks for intersec­tion 
and negation operators, without the need for explicitly creating an intermediate TData source. Notice 
however that a record Iink, unlike operator finks, is always binary. An aggregate link is a link between 
two views, with an explicit (user-defined) or implicit (value-based) grouping of attribute vafues for 
the TData in the first view. The second view visualizes some aggregate function (such as sum, average 
) performed on each group of records in the first view. For instance, Figure 1 shows an aggregate fink 
from VI to V4 showing the sum of TOTREV of all departments (whose DIDs appear in VI) for each day in 
July. Another aggregate link exists between views V2 and V5 showing the totzd number of items sold for 
each week in Jufy. The grouping in V5) is defined by the user and in V4 is implicit (every value of DATE). 
2.4 Organizing Complex Visual Presentations A window is a collection of views, together with a set of 
cur­sors and links on these views. A window has an associated layout that specifies the relative location 
of views within the window. A visual presentation is a collection of windows, plus a collection of links 
and cursors that relate views in different, windows. We use visual template to denote the data-independent 
portion of a visual presentation, i.e., a col­lection of view templates, cursors and links for each window 
in the visual presentation, plus the links and cursors that span two windows, Thus Figure 1 is an example 
of a visu~ presentation. Views V 1 and V2 are in a window W 1. PJo­tice the different layouts of views 
in windows WI and W3. DEVise supports other layouts such as tiling and stacking of views. [t also provides 
a mode for transparent overlays of views. These features are not central to the visualization model and 
we do not discuss them further for lack for space. 3 visual Queries Once a visuaf presentation is created, 
a user can express selections on the visual attributes of a view, or change a cursor, and we refer to 
these operations as visual queries. A visuaf query is appfied to a visuaf presentation, and the result 
is another visual presentation. Visuaf queries can be classified into three kinds: WI Create an x-y rubberband 
selection on a view, or zoom in/out in a view, or scroll; these are alf exam­ples of x-y selections. 
In general, a user can express selections on any visible GData attributes. W2 Click on a point in the 
view to display the actual TData record; this is an x-y point selection, but with a different display 
behavior. op3 Move a cursor highlight by first cficking on it and then clicking on the new position to 
whi~h it should be moved. When the user performs one of the above operations on a view V, queries may 
be generated on views that are linked to V. A linked query is a query generated as a side-effect of a 
visuaf query. The presentation of the DEVise visualization model in Section 2 is sufficient for purposes 
of understanding how to create visual presentations and ask visuaf queries, but is not sufficiently rigorous 
to define equivalence of alternative implementation strategies. We now define the semantics of mappings, 
views, cursors, finks and visual queries in DEVise in terms of relational operations on TData. In addition 
to giving queries a formal semantics, this lays the foundation for database-style optimization of visual 
queries. We use the operators selection (u), projection (n) and function composition (o). 3.1 Mappings 
and VGData A mapping p is a function that is applied to a TData record to produce a GData record. In 
the current implementa­tion of DEVise, a mapping is in fact a set of selections {U,, U2,... ,an} such 
that if < > is a record tl,tz,...,tm of TData and < gl, gz, . . . . g~ > is a record of GData, then 
<tl, t2, ..., tm>-%gl <tl, t2, . . . ,tm>= gz <tl, tz, ...,tm >-% g. The mapping function need not be 
one-to-one; several TData records could be mapped to the same GData record. A view V can be represented 
as a 5-tuple (B, UG,p, T, C) where L? represents the background, aG the visuaf filter, p the mapping, 
T the TData associated with the view and C the cursor layer of the view. The GData G associated with 
the view is P(T), and the VGData displayed in the view is aG(G). 3.2 Visual Links A visual link between 
two views on attributes L means that the selection conditions in their visual filters that involve only 
attributes in L are identical. In other words,if views vl(B], aG ,LJ1,T1, C1) and V2(B2, UG2, P2, T2, 
C2) are two views with a visual link on attributes L: cdink(u], W, L) + ~G] = ~G] ~_~ o u~ 2and  UG2 
= U::L 00:12 When any visual query operation changes the visuaf filter on L, both views change accordingly. 
3.3 Record Links To define the semantics of record links, we must identify the set of TData records that 
contribute to VGData for the first linked view. We do this by defining an implicit selection on TData, 
as illustrated in Figure 2. Consider a klew (B, G: c,c) 1 G ) Visusl Filter , G 1 t *T I 9 GDats , G 
 7 t\\ \\\ Mapping, P \  % I TDat.s, T Figure 2: VGData and Implicit TData Selections view Vl = (L31, 
UG1, PI, T1, Cl ). The VGData for this view is a 1 opl (Tl ). Let UT be a selection on TData such that 
applying this selection and then applying mapping p yields the same VGData as before: aG1o P1(TI) = MI 
o UT (Tl) i.e.,  L+opl=p loo T Equivalently, UT can be defined using the following equa­tion: aT(T 
l)= {t c Z I I UG1 o pi(t) is non empty} We can now define the semantics of a record link us­ing the 
selection aT. A record link between two views V1(B1, CTG ,P1, T], cl) and V2(B2, ~G2, p2, T1, C2) implies 
that VGData for Vz is equal to: for a positive record link. lYG~Opzo(l (rT )(Tl) for a negative record 
link. Notice that the two views related by a record link have the same TData component. 3.4 Operator 
Links An operator link consists of master views VI ( Bl, crG1, p ~, TI, Cl ). V2(B2, UG ,u2, T2, C2) 
. . . Vn(Bn, UG , pn, Tn, Cn) and an operator op. Suppose UT1 , aT2 . . . UT I be the TData selec. tions 
(as defined for record links) corresponding to the VG­Data s in VI, Vz, ....V.. Then we can define a 
TData Top given by aT (Tl )opaT2(Tz)op . . . OpaT (Tn). Now a view V(B, UG,p, TOp,C) maybe defined using 
TOp as TData. The VGData for this view will be UGop o (Top) The kind of operator associated with the 
operator fink puts certain constraints on the TData s in the master views, The number of master views 
should be consistent with the arity of the operator op. If the operator is union or inter­section, then 
the TData s T1, ....Tn should have the same schema. Finalfy, for the operation to be a join an appropri­ate 
join condition must be specified with the operator. 3.5 Aggregate Links An aggregate link between two 
views V](Bl, UG , pl, T1, Cl ) and VZ(BZ,a 2, IA2, T2, C2 ) has an associated grouping on attributes 
of G1 or T1 and an aggregation function f, A grouping on attributes Al, 0... Ak provides a grid of values 
of attributes. The aggregate function is computed for each coordinate (Al, .. ,Ak.) on the grid. Let 
Tagg be the TData whose records are of the form (A1, . . .. Am. f(A1, . ... An)). The second view is 
some mapping defined on Tagg. The grouping grid may be implicitly specified by having one point on the 
grid for each vafue of (Al,..., Ak), as a range of attribute values or some other manner which we leave 
unspecified. 3.6 Cursors A cursor links a source view and a destination view, and has two parts: 1. A 
selection on visible GData attributes that operates on the display layer of the destination view, and 
results in highlighting some range of values for the GData at­tributes in the selection. For instance, 
an x-y selection could be shown as a highlighted area with a lighter color. For selections on other attributes, 
a different highlighting technique woufd have to be used; we leave this unspecified, as an implementation 
detail. 2. A selection on the GData of the source view that se­lects the same range as the selection 
on the display layer of the destination view. Note that the GData layer of the destination view is not 
constrained by the  cursor. Formally, a cursor between VI (source) and V2 (destina­tion) imposes the 
following conditions on the visual Ilters of the two views. For the source view, the visual filter should 
be of the form: where u~l is a conjunction of range selections on visible GData attributes in L. For 
the destination view, the wsual filter UG2 can be any selection on GData attributes, but ranges of attributes 
selected by UL t,hatlie within theranges determined by the visual filter aG2 have to be highlighted in 
the display layer.  3.7 Semantics ofa Visual Query A visual query can be represented formally by a 2-tuple 
(op, Vl) where opis one of the three operations described in Section 3, and VI is the view on which the 
operation is performed. A visual presentation consists of a collection of views, {VI, VZ, ..., Vn}andif 
other views arelinkedto Vl by cursors, visual links or record links, additional (sub-) queries are generated 
on these views. We now define the visual query (and sub-queries) gener­ated by each visual operation. 
Let an operation op be performed on view VI represented by (Bl, UC , pl, T1, Cl ). Assume that the following 
(types of) views exist in the visual presentation; this set of views in­cludes an examde of everv kind 
of view that can be affected by a visual query on VI: . View Vz represented by (B2, crG , PZ, Tz, Cz 
) with a vi­sual link vlink(Vl, Vz, L) on attribute L between V] and Vz . . View Vs represented by (B3, 
aG3, ps, T1, Cs) with a record link rlink( V1, V3) from V1 to V3. . View V4 represented by (B4, UG4,P4,T4,C4) 
with a cursor cur90r(V1, V4) that has V1 as source and Vq as destination. . View V5 represented by (B5, 
UG ,p5, T5, C5) with a cursor cur90r(V5, VI ) with V5 as source and VI as des­tination. . View VGrepresented 
by (BG,UG , I@, TG,Ce) with an aggregate fink on attribute L from VI to V6. Let, the  grouping be based 
on values of L. Let the aggregation function be sum(L) and let PS map L to x and sum(L) to y attributes 
of GData. . Views VT and VS represented by (BT, UG7, p7, T7, CT) and (Ba, acs , prJ,TE, C13) such that 
there is an operator link from Vl and VT to VE with the operator being union. We now describe the effect 
of op on VI. Views Vz through Vs are also affected by the visual query on VI; the effect on some of these 
other views can be described directly, and in other cases is described by specifying a subquery that 
is generated as a consequence of op on V1. Several cases arise depending on the nature of operation op, 
which can be one of the three kinds opl, op2 or op3 as described in Section 3: Case I (op = opI ): This 
operation is a selection uG~ on attributes of GData. As a result, the visual filter of VI changes to 
uc~, which means that the VGData displayed in the view is now uG~(P1(T1 )). According to the semantics 
of a visual link, a sub-query (o~l, Vz ) will be generated on Vz, with the selection being CrGI. Thus 
the VGData displayed in Vz is now (a~~~ o / a~l )(P2 (T2)). This is illustrated in Figure 3. Let u~~ 
be the implicit TData selection determined by uG~. Then, due to the record link between VI and V3 the 
(Xl,yz) (X2 ,yz ) m AT I (!41 ,,1 ) I I I , , 1 1 (Xl,yl) Al ? (Xl ,yl ) Al vlink(L. AI) _ (x2,y4) (x2 
,y4)  3-1 * 3LI Al 1 (xl,y3) (xl ,y ) Figure 3: Effect of opl in the Presence of a Visual Link VGData 
now displayed in V3 changes to (u 30p30c7T~)(Tl). If this had been a negative record link, the VGData 
dis­ played in Vs changes to (u op3 o (1 uT~))(Tl). This is illustrated in Figure 3.7. (Xz,yz) (x2 
,y2 ) VI I AZ AZ I_h_w (xl, W-4 (.d ,yl ) Al ,. t (X3,Y4) (>zy4) V3 A3 A  I--nJ11 Li-L Al Al (Xl,y 
) (xlJ ) Figure 4: Effect of opI in the Presence of a Record Link Note that if the record link had instead 
been rlink(Vs, Vj ) then the operation on VI would have no eflect on Vs. Let aG~ be of the form (u~~~ 
o u:;) where u: specifies a conjunction of range selections on visible GData attributes in L.. Then the 
ranges of attributes selected by UL G1 that lie within the ranges determined by the visual filter u 4 
will be highlighted in the cursor layer of Vq. This is illustrated in Figure 5. On the other hand, no 
change occurs in the VGData of Vs due to cursor(Vs, Vl ). The highlighted area in V1 may change depending 
on the visual filter uG1. Due to the operator link from V1 and VT to V8 the TData, T8, corresponding 
to V8 now changes to (a=: U UT ) where aT1 and aTT are the TData selections corresponding to a G] and 
UG7. And the corresponding VGData in V is now ~ch o ~8(aT~ U aT7 ) Note that T1 and Ts mwt be don compatible 
i.e. have same attributes. Finally, if L1, L2, L3, .,. L. are the values of attribute L, in the VGData 
corresponding to V1, then the GData (x2,y2) (X2 .V2 ) (Xz,yz) 1x2 ,y2,) VI vl (X2 ,yz ) source~.----, 
A2 : A2 L.. ---: @ (XI ,yl )  _L El (Xl,yl) Al Opl (xI J1 ) Al (x4,y4) (X4J4) V4 (*Y2) (X2 J 2 ) A3 
III ; (X1,Y1) AS n (xl ,yl ) 4 d4StiNtbll (X3,y3) A (%3,y3) A Figure 5: Effect of opi in the Presence 
of a Cursor (x,y) in V, would be {( L,, sumt(L,)), where t G uc~o P1(T1) and t.L = Li)}. Case z (OP 
= op2): This operation specifies a GData record given by a selection aG~ which is a conjunction of equality 
constraints. The operation results in a popup win­dow displaying the set of TData records: {t ET, o CG 
(fll(t))empty} \ UG:is non This query does not generate any subqueries on the linked views and does 
not have any effect on the display of VI. This is illustrated in Figure 6. G&#38;) ::Al A4=3El Al F@e 
6: Effect of op2 Case 3 (OP = 0P3): This operation changes the position of the cursor highlight on the 
destination view. Thus, the highlight in V] is centered around the new position given by the user. As 
a result a new GData filter a: is created. According to the bidirectional semantics of a cursor, the 
VG- Data displayed in Vs is now given by (u:; o a~~L)(us(Ts)). This is illustrated in Figure 7. We wiU 
see how these definitions provide a foundation for database-style visual query optimization in Section 
6. VLsual Queries and SQL The visual query paradigm enables users who are not database experts to generate 
sophisticated SQL queries through intu­itive graphical operations. We illustrate this now through several 
examples. The point of this section, however, is not to argue that DEVise can be an SQL front-end (al­though 
it is indeed a very good front-end for a large class of SQL queries!). Rather, we demonstrate the close 
interac­tion of data visualization and relational querying in DEVise. Of course, the visual presentation 
offers the-significant ! additional value of rendering the answers in a desired visual VI VI $Ource A2 
A2 n El (Xl,yl) Al * (XI ,yl ) Al (X4,Y4) (X4J4) 3R.*A3m IJI I A4 A4 1  (X3,Y3) (X3.Y3) F@re 7: Effect 
of opa in the Presence of a Cursor form, but we will concentrate on the set of answer tuples in this 
section. Consider a TData schema representing the sales data of a company by location: (latitude, longitude, 
orders, tota-Iatnount). This schema is a single data source and serves as a good example of the range 
of SQL queries that its visual­ization can produce. Let T be a set of such TData records. We create the 
following presentation. Mapping PI gives a scatter plot of totalamount us. latitude and Mapping pZ gives 
a scatter plot of orders us. latitude. This visual presentation is equivalent to the following SQL queries: 
SELECT (t otalamount, latitude ) FROMT SELECT(orders, latitude) FROMT Next, we create a visual link on 
the x attribute. Now the same visual presentation with a fink between Viewl and View2, is equivalent 
to the single SQL query, SELECT(totalamount, latitude, orders) FROMT Now we issue a rubberband query 
, i.e., an x-y selec­tion, on one of the views, say Viewl. Thus we create the selections: 10000 < y < 
20000 AND30 < x < 40 on Vieul 30 <x <40 on Vieu2 due to the x-link. The equivalent SQL queries on View 
1 and View2 respec­tively are: SELECT(totalamount, latitude) FROMT UHERE(10000 < totalamount < 20000) 
 AND (30 < latitude < 40) SELECT(orders, latitude ) FROUT UHERE(30 < latitude < 40) Next, suppose that 
we modify PI and Pz so that longi­tude is mapped to the color attribute. Then, in the original views 
we can see the result of the following SQL queries on Viewl and View2 respectively: SELECT(latitude, 
totalamount, longitude) FROHT SELECT(latitude, orders, longitude) FROMT we create the visual link on 
x between the two views as before. Now if we perform a color selection on any of the views (say View 
I): colorl (longitude = 50) < color < color2 (longitude = 60) we generate the following SQL queries: 
 SELECT (latitude, totalamount, longitude) FROMT WHERE(50 f longitude f 60) : Queryl SELECT (latitude, 
totalamount, longitude) FROM T WHERE( SELECT( snin(latitude) FROt4CJueryl ) < latitude c SELECT( max(latitude) 
FROMC)ueryl )) Consider an aggregate link giving Sum of totalamounts where the aggregation is done on 
the latitude. Ifthis link is created from Viewl to View3, whose mapping is totaiarnount us. latitude 
then we have visualized the SQL query, SELECT (latitude, sum(totalamount)) FROf4 T GROUF BY latitude 
If a visuaf filter of latitude <30, is applied to the view, then the query would have the appropriate 
selection condi­tion added to it. Finally, we consider an operator link with the operation being join. 
Suppose we have another table T1 with the same schema as T, for a different company. Let VI and V2 display 
tables T and T1 respectively, with the mapping being totalamount vs. latitude. Consider a join operator 
link with V 1 and V2 as the masters, join predicate (T.latitude = 2 1.[atitude), creating a TData source 
table with attributes (latitude, totzdamountl, totalamount2). We can then create a visualization of totalamount 
1 VS. totalamount2 in the created table, which gives us the answer to the following SQL query: SELECT 
(T.totalamountl, T2.totalamount) FROM T, T1 UHERE(T.latitude = T1.latitude) In contrast, observe that 
visual links allow us to display theoutput ofsome simplejoine without explicitly computing the join. 
We calf such joins visual joins. For instance, the information computed with a join operator link in 
the above exampie could also be obtained visually: Suppose mapping pI on T is used to create a scatter 
plot of totalorders us. latitude, Pz the same for TI, and we have a visual link on the z attribute. If 
these views are laid out one below the other we can see the totalamount corresponding to the same fatitude 
inthe two views. However the queries evaluated in the two views themselves are: SELECT(totalamount, latitude) 
FROMT SELECT (totalamount, latitude) FROM T1 In fact, since a visual link on z implies that the two views 
have the same range of I attributes, but need not have exactly same attributes we can get a visuaf range 
join by simply creating an x-y rubberband on one of the above views. The resulting query is: SELECT(T.totalamount, 
T1.totalamount) FROMT, T1 WHERE(30 < T.latitude < 40) AND (30 < T1.latitude < 40) Similarly, wecoufd 
write corresponding SQL queries for the more complex visualization in Figure 1. 4.1 Visualizing an SQL 
Query We now show how an example SQL query could be expressed using a visuaf presentation. We use the 
schema for sales data described before for TData7 1. Consider the SQL view generated by the following 
query: SELECT(latitude, longitude) FROMT-l WHERE(totalamount > 20000) AND (50 < longitude f 60) This 
query intuitively asks the following question: Ins given geographical area, which locations hadat,otalamount 
sale greater than a threshold? The foflowing visual presentation achieves this effect. Define mapping 
pI as (longitudes. totaiamount) (Viewl). Create a rubberband on View 1 to select totalamount >20000. 
Define mapping pzas latitude us. longitude (View2). Create a record link from Viewl to View2. This places 
the restric­tionthat the records displayed in View2are also displayed in Viewl. Now select the correct 
subset ofrecordsfrom View2 using a rubberband 50 < longitude< 60. View2 now shows the result of the query. 
Thus a query on TData attributes can be performed by a appropriate sequence of operations on GData. These 
exam­ples hopefully illustrate the power of visual queries, although lack of space prohibits a fuller 
discussion of the expressive power of visual queries. 5 Data Transformation and Querying As DEVise was 
utilized in reaf appficatione, we repeatedly received feedback from users indicating that more sophisti­cated 
database-style query and data transformation capabil­ities were needed. This might seem strange, considering 
that we have just finished discussing how many SQL queries can be effectively expressed in DEVise; in 
part, this was because visual queries in the earfier version of DEVise were not as powerful as the ones 
described in this paper. On the other hand, in enhancing the expressive power visual queries, we found 
ourselves implementing much of a database query fa­cility. After considering this issue, we decided to 
re-design the system to support data transformation and query ca­pabilities within the DEVise engine. 
DEVise now supports a subset of SQL queries (essentially, queries without nested blocks), and extensions 
to support sequence queries are un­der way. An important feature of DEVise is that queries can op­erate 
on both local and remote data sources. At remote sites, if software is available that can provide query 
profil­ing and/or evacuation services, the DEVise optimizer seeks to exploit this; otherwise, it will 
retrieve complete relations and essentially do the rest of the query evaluation at the site where it 
is executing. 6 Optimization Issues Operations on the cursor and background layers are inexpen­sive, 
and optimization must therefore focus on the impact of visuaf queries on the VGData components of views. 
The relational definitions given in Section 3.7 summarize how vi­suaf aueries chamze the VG Data components 
of the aueried .. view, as well as d linked views, and suggest several alterna­tives for query evaluation. 
For example, selections in visuaf filters and links can often be used to filter TData records be­/ore 
applying the mapping associated with the view. These alternative evaluation strategies must be considered, 
their cost estimated, and the alternative with the least estimated cost chosen for execution. This is 
done to a fimited extent in the current version of DEVise, and is an area for further work. To see how 
new optimization opportunities arise because visualization and database-style querying are combined in 
a single tool, consider a very simple example: a view (in DEVise terms) V that is created by mapping 
records from a TData source T. Visuaf operations on V generate database­styIe queries on T. If T is a 
locally stored table, examining the mapping from T to V can tell us what indexes to create on T. For 
a more comdex examrie. consider the followirw sce­nario. Suppose th~t a part~cular selection can inde~d 
be pushed down, and expressed against the TData. If the TData collection is defined by a database-style 
query, rather than being an explicitly stored set of tuples, run-time query evaluation is used to generate 
the tuples as needed. Clearly, knowing about the selections that can be expected this is determined by 
the visuaf presentation helps in planning the database-style query. To take this one step further, a 
vi­sual presentation might contain severaf linked views. Even if selections cannot be pushed, the computation 
of their VG-Data sets (required, say, due to subquenes generated in response to a user operation on a 
linked view) can often be combined, especially if the views share a single TData source. 7 Advanced Exploration 
Tasks In this section, we consider the use of DEVise for two ad­vanced exdoration tasks: integrated ezulomtion 
of data and summary information and col~abomtiv; data ana~ysis. The latter activity is supported by two 
DEVise features: active reports and hyperdata. 7.1 Integrated Access to Data and Metadata Even with intelligent 
btier management, interactive response times cannot be achieved for very large datasets, and too much 
information is lost by compressing a very large vol­ume of data onto a single screen. A powerful paradigm 
for addressing this fundamental moblem is to let users create summarie~ of data (which ar~ typically 
much smaller than the original dataset ) and to browse the summaries, or meta­data, to get an overview 
of the entire dataset. Subsequently, users can look at interesting portions of the data in more de­tail; 
our experience has been that users find it very useful to interleave the browsing of data and metadata. 
The Soil Sciences application described in Section 1.1 is a concrete example of interleaved data and 
metadata brows­ing. The visualization of clusters of image points using DEVise is illustrated in Figure 
8. The important point to be noted in this example is that the clusters produced by BIRCH can be seen 
as a summary of the original data. Users explore the clusters produced by BIRCH to obtain a high­level 
overview of the data, and thereby narrow the scope of subsequent detailed analysis to interesting portions 
of the data. The clusters produced by BIRCH are onfy one example of a summary description of data. Other 
examples of sum­maries include: 1. Statistical measures over subsets of the data. Indeed, such summaries 
are so useful that support is built di­rectly into the current version of the visualization en­gine of 
DEVise. 2. Compressed versions of images [9]. Again, DEVise has built-in support for retrieving images 
at various levels of compression.  7.2 Collaborative Analysis A visual presentation, as we noted earlier, 
has two parts: a data-independent visual template, and a data-dependent VGData. A user can save a visuaf 
template, if desired with some portion of the underlying TData, and send it to an­other user. The recipient 
can then re-create the exact visuaf presentation seen by the sender, if the rest of the TData is also 
available to the recipient, and continue exploring it. This is supported in the current version of DEVise. 
We calf a visuaf template that is used in this manner an active re­port: intuitively, it is like a conventional 
report, except that the reader can interactively explore the data contained in it, i.e., it is active 
. A powerfuf extension that is allowed by the architec­ture, but is not fully supported in the current 
version, is that multiple users can share part of a visual presentation and changes made by one user 
to this part are automatically seen by all users; further, any user can make changes (with a mechanism 
for passing control between users to avoid con­flicting changes). The basic mechanism here is similar 
to active reports; each user runs a copy of DEVise, and only the operations are communicated between 
copies (and exe­cuted independently by each copy). Clearly, this approach places little or no burden 
on network bandwith, in contrast to approaches that ship screen-snapshots. DEVise currently allows field 
values in TData records to be images or text, and these can be GData field values as well. This allows 
the creation of visuaf presentations that look like conventional reports, with text and imagery inter­leaved 
with presentations of tabular data (e.g., bar charts or scatter-plots). The DEVise framework also aflows 
TData and GData attribute values to be a view or a window, ca­pable of being manipulated using all the 
DEVise powe~ we cafl this hyperdata. The tool does not yet support this functionality fully, and is being 
extended in this direction. Clearly, this greatly enhances the vafue of active reports, since they become 
much more expressive. Acknowledgements The work presented in this paper was supported by NASA grant NAGW-3921 
and as a Massive Digital Data Systems (MDDS) project sponsored by the Advanced Research and Development 
Committee of the Community Management Staff. Raghu Ramakrishnan s work was additionally sup ported by 
a Packard Foundation Fellowship in Science and Engineering, a PYI Award with matching grants from DEC, 
HP, IBM, Tandem, and Xerox, and NSF grant IRI-9011563. Figure 8: Clustering References [1] Alexander 
Aiken, Jolly Chen, Michael Stonebraker, and Allison Woodruff. Tioga-2: A direct manipulation database 
visualization environment. In Proc. Interna­tional Conference on Data Engineering, New Orleans, LA, February 
1996. [2] Robert Braham. Math &#38; visualization: New tools, new frontiem. IEEE Spectrum, 32( 11): 19-36, 
Novem­ber 1995. [3] Michael Cheng, Miron Livny, and Raghu Ramakrish­nan. Visual analysis of stream data. 
In Proc. of SPIE -The International Society for Optical Engineering, vol­ume 2410, pages 108 119, San 
Jose, CA, April 1995. [4] Michael T. Heath and Jennifer A. Etheridge. Visualiz­ing the performance of 
parallel programs. IEEE Soft­ware, pages 29-39, September 1991. [5] William Hibbard, Brian E. Paul, David 
Santek, Charles Dyer, Andre Battaiola, and Marie-Francoise Voidrot-Martinez. Interactive visualization 
of earth and space science computation. IEEE Computer, pages 65-72, 1994. [6] A.S. Jacobson, A.L. Berkin, 
and M.N. Orton. Interac­tive scientific data analysis and visualization. Commu­ nications of the ACM, 
37(4):42 52, Apr 1994. [7] Ken Kombluh. Active data analysis: Advanced soft­ware for the 90 s. IEEE 
Spectrum, 31(11):57-83, November 1994. [8] Miron Livny, Raghu Ramakrishnan, and Jussi Mylly­maki. Visual 
exploration of large data sets. In Proc. of SPIE The International .%ciet~ for Optical Engineer­ing, 
volume 2657, San Jose, CA, January 1996. [9] Livny, M. and R.atnakar, V. Quality-Controlled Com­pression 
of Sets of Images. Proceedings of International Workshop on Multi-Media DBMS, pages 109-114, Au­gust 
1996. a Soil Sciences Dataset [10] Allen D. Malony, David H. Hammerslag, and David J. Jablonowski. Traceview: 
A trace visualization tool. IEEE Software, pages 19-28, September 1991. [11] Enc Petajan, Yves Jean, 
Dan Lieuwen, and Vinod Anu­pam. DataSpace: An Automated Visualization System for Large Databases. In 
Proceedings of SPIE, Visual Data Ezplomtion and Analysis IV, volume 3017. The International Society for 
Optical Engineering, 1997. [12] Michael Stonebraker, Jolly Chen, Nobuko Nathan, Car­oline Paxson, and 
Jiang Wu. Tioga: Providing data management support for scientific visualization appli­cations. In Proceedings 
of the 19th Conference on Very Large Data Bases, pages 25-38, Dublin, Ireland, Aug 1993. [13] The Khoros 
Group. Khoros Manual. University of New Mexico, Albuquerque, NM 87131, 1991. [14] Craig Upson, Thomas 
Faulhaber Jr., David Kamins, David Laidlaw, David Schlegel, Jeffrey Vroom, Robert Gurwitz, and Andris 
van Dam. The Application Visu­alization System: A computational environment for sci­entific visualization. 
IEEE Computer Gmphics .9 Ap­plications, 9(4):30-42, July 1989. [15] Tian Zhang, Raghu Ramakrishnan, and 
Mkon Livny. Birch: An efficient data clustering method for very large databases. In Proceedings of A 
CM SIGMOD, Montreal, Canada, 1996. 
			
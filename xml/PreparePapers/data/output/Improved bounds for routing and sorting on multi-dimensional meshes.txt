
 Improved Bounds for Routing and Sorting on Multi-Dimensional Meshes Torsten Sue] Department of Computer 
Science University of Texas at Austin Abstract We show improved bounds for 1-1 routing and sorting on 
multi-dimensional meshes and tori. In particular, we give a fairly simple deterministic algorithm for 
sorting on the d-dimensional mesh of side length n that achieves a running time of 3dn/2 + o(n) without 
making any copies of the elements. We give deterministic algorithms with running times of 5dn/4 + o(n) 
and 3dn/4 + o(n) for the d-dimensional mesh and torus, respectively, that make one copy of each element. 
We also show lower bounds for sorting with respect to a large class of indexing schemes, under a model 
of the meeh where each processor can hold an arbitrary number of packets. Finally, we describe algorithms 
for permutation routing whine running times come very close to the diameter lower bound. 1 Introduction 
The mesh-connected arrays of processors are one of the most thoroughly investigated classes of interconnection 
schemes for parallel processing. While the networks in this class have a large diameter in comparison 
to the var­ious hypercubic networks, they are nonetheless of great importance due to their simple structure 
and their good performance in many applications. A variety of algorith­mic problems have been analyzed 
aa to their complexity on theoretical models of the mesh; probably the two most extensively studied problems 
are those of routing and sorting. For a detailed introduction into these prob­lems, and an overview of 
the most important classes of interconnection schemes, the reader is referred to [14]. Email: torstenQcs 
.ut*xax. edu. Supported by the Texas Advanced Research Program under Grant Nos. 00365S-4S0 and 00365S-461, 
and by a Schlumberger Graduate Fellowship. Permission to copy without fee all or part of tk material 
is granted provided that the copies are not made or distributed for direct commercial advantage, the 
ACM copyright notice and the title of the publication and its date appear, and notice is given that copying 
is by permission of the Association of Computing Machinery. To copy otherwise, or to republish, requires 
a fee and/or specific permission. SPAA 94-6/94 Cape May, N.J, USA 0 1994 ACM 0-89791-671 -9/94/0006..$3.50 
Much of the previous work on meshes has con­centrated on the on-dimensional and two-dimensional cases. 
Particularly the two-dimensional networks are of great practical importance due to their efficient layout, 
and have been used as the basis for a number of existing parallel machines. In contrast, the meshes of 
dimen­sion d >2 (hereinafter referred to as multi-dimensional meshes) have received somewhat lees attention. 
While the problems of routing and sorting on these networks have previously been studied by a number 
of authors, there are still considerable gaps between the best upper and lower bounds. In this paper, 
we focus on the problems of 1 1 rout­ing and sorting on multi-dimensional meshes with con­stant dimension 
d. Formally, a d-dimensional mesh of side length n consists of N = nd processors, where each processor 
is identified by a d-tupel (pI,..., pd) in [n]d. (We use [n] to denote the set {O,..., n -l}.) Two pr~ 
Cessors P = (po , . ..jpd-1) and Q = (qO)... >91)l) are connected by a bidirectional communication link 
iff there exists an i in [dl with ]pj g;I = 1and Pj = qj for all j in [dj with j # i. The d-dimensional 
torus is obtained from the d-dimensional mesh by adding wwp-amund edges between all pairs of processors 
(po, ..., Pd_l ) and (90,..., qd-1) such that there exists an i in [dl with Ipi qil =n land pj=qjforalljin 
[dJwithj #i. We assume that the processors in the network oper­ate in a synchronous mode. In a single 
step of the com­putation, each processor can perform some fixed amount of internal computation, and transmit 
one packet of in­formation (of bounded size) to each of its neighbors. A processor can hold at most a 
constant number of packets at any time. The muting problem is the problem of rearranging a set of packets 
in a network, such that every packet ends up at the processor specified in its destination ad­dress. 
A routing problem in which each processor is the source and destination of at most k packets is called 
a k k routing problem. Most research has focused on the 1-1 routing problem, also called the permutation 
rout­ing problem. In the k k sorting problem, we assume 26 that each processor initially holds k packets, 
where each packet contains a key drawn from some totally ordered set X. Our goal is to rearrange the 
packets in such a way that the packet with the key of rank i is moved to the processor with index [i/kJ, 
for all i. As in the case of routing, moat of the research has focused on the case k=l. The index of 
a processor in the network is deter­mined by an indem ng scheme. Formally, an indem ng scheme for a d-dimensional 
mesh of side length n is a bijection Z from [n]~ to [n~]. If Z(P) = k for solme pro­cessor P = (po, . 
. .,p~-1) in [n]~ and some k in [n~], then we say that processor P has index k. The problem of sorting 
an input with respect to an indexing scheme z is to move every packet y of the input to the processor 
with index Z(Rank (y, X)), where Rank (y, X) :: I{Z ~ X I z < y} 1. An example of a commonly used indexing 
scheme for the two-dimensional mesh is the mw-mujor indezing scheme, which is given by indexing the proc= 
sors from the left to the right, and from the top row to the bottom row. Another important and closely 
r­lated indexing scheme is the snake-like rvw-major otier­ing defined by Z(il, jl) < Z(ia, ja) ~ (il 
< iz) \/ ((ii = ia) A (((ii odd) A (jl < jz)) V ((ii even) A ((jl > jz)))). Both of th= indexing schemes 
can be niiturally extended to multi-dimensional networka; see [1 1] for a formal definition. Sorting 
algorithms on the mesh are usually designed with a particular indexing scheme in mind, and techniques 
suitable for one indexing scheme may not work well at all for others. In the algorithms presented in 
this paper, we assume a blacked snake-like indexing scheme. This indexing scheme is defined by partitioning 
the mesh into blocks of side length na, and using a snake-like indexing scheme inside each~ block, while 
the blocks themselves are ordered according to another snake-like indexing. Similar blocked indexing 
schemes have recently been used in a number of fast sorting algorithms (e.g., see [3, 4, 6, 12]). An 
obvious lower bound for the running time of any algorithm for 1 1 routing or sorting is given. by the 
diameter D of the network. (That is, D = d(n 1) for the d-dimensional mesh and D = dn/2 for the d­dimensional 
torus.) The performance of an algorithm for routing or sorting on theoretical models of the mesh is commonly 
measured by its running time, its queue size (that is, the maximum number of packets any node has to 
store during the algorithm), and of course by factors such as the overall simplicity of the algorithm 
and the demands it places on the local control hnrdware or software. In this paper, we will focus on 
the time complexity of routing and sorting on meshes ancl tori of ar~lt rary constant dimension, and 
we will expmmi our results in terms of the diameter D of the network. 1.1 Previous Results A variety 
of sorting algorithms for the two-dimensional mesh have been proposed, starting with the work of Or­cutt 
[16] and Thompson and Kung [18]. In particular, Schnorr and Shamir [lfl gave a 3n +o(n) time algorithm 
for sorting into row-major order, and showed a nearly matching lower bound of 3n o(n), also independently 
discovered by Kunde [71. This lower bound assumes a model of the mesh, hereinafter referred to as the 
single­packet model, in which each procaor can only hold a single packet at any time. The lower bound 
technique can also be extended to indexing schemes other than row-major [8]; the best general lower bound 
for arbi­ trary indexing schemes is currently at 2.27n [2]. However, these lower bounds do not hold 
for the multi-packet model assumed in this paper, in which any processor can hold a constant number of 
packets at a time. For this model, the only known lower bound is given by the network diameter of 2n 
 2, and recently algorithms with running time 2n + o(n) have been ob­tained [3, 6]. In the case of the 
torus, a lower bound of 3n/2 o(n) has been shown for the single-packet model [8, 17]. In contrast, the 
fastest algorithm for the multi-packet model runs in 5n/4 + o(n) steps [3, 6]. Early examples of sorting 
algorithms for multi­dimensional meshes were given by Thompson and Kung [18] and Nasaimi and Sahni [15]. 
A lower bound of 2D n o(n) for sorting on multi-dimensional meshes wae established for the singl~packet 
model [7, 17]; the bound applies to most of the indexing schemes used in the literature. An algorithm 
with a running time of 2D -n+ o(n) was subsequently described by Kunde [9]. No non-trivial lower bounds 
are known for sort­ing on d-dimensional meshes in the multi-packet model. The best upper bound in this 
model is currently at 2D 5n/2 + o(n). (This result can be obtained from the 7n/2 + o(n) time sorting 
algorithms for the three­dimensionrd mesh in [3, 6].) Hence, for large values of d, this upper bound 
is still nearly a factor of 2 away from the diameter lower bound. This is also true in the case of the 
d-dimensional torus, where the best upper bound is currently at 2D n + o(n). (This bound is implied 
by the 2n + o(n) time sorting algorithms for the three-dimensional torus in [3, 6].) Slightly better 
results have been obtained for per­mutation routing on d-dimensional networks. For this problem, Kunde 
[10] has described algorithms that run in time (d+(d 2)(1/d)llf d-2 J+c)n on the mesh, and in about half 
that time on the torus. For networks of low dimension, this is a significant improvement over previ­ous 
results. However, for larger dimensions this result is again nearly a factor of 2 away from the diameter 
lower bound. In fact, even for off-line routing no better results are currently known. 27 For the problems 
of k-k routing and sorting on d­dimensional networks, there are obvious lower bounds of kn/2 for the 
mesh and kn/4 for the torus, due to the bisection width of the networks. For k ~ 4r, several randomized 
and deterministic algorithms have recently been proposed that match this lower bound, within a lower 
order additive term [5, 6, 12]. 1.2 Overview of the Paper In this paper, we show improved bounds for 
1 1 routing and sorting on multi-dimensional meshes and tori. Our first result is a deterministic algorithm 
for sorting on multi-dimensional meshes of side length n that achieves a running time of 3D/2 + o(n). 
The algorithm has a fairly simple structure, and does not make any copies of the packets. Next, we show 
that the running time of the algorithm can be reduced to 5D/4 + o(n) by making one copy of each packet. 
A similar technique is then ap plied to the multi-dimensional torus, leading to a deter­ministic algorithm 
with a running time of 3D/2 + o(n). In contrsst, the fastest previously known sorting algo­rithms required 
2D -5n/2 + o(n) steps on the mesh and 2D -n + o(n) steps on the torus. Thus, our algorithms improve significantly 
over all previous results for sorting, and in fact even for off-line routing, on multi-dimensional meshes 
and tori. The ideas underlying our algorithms are quite simple, but the techniques used in the design 
and analysis are some­what different from those in previous papers on multi­dimensional networks. While 
we restrict our attention in this paper to constant values of d, the claimed time bounds also hold for 
a limited range of networka of non­constant dimension. In addition, we show lower bounds for sorting 
with respect to a large class of indexing schemes, under a model of the mesh where each processor can 
hold an arbitrary number of packets. Our lower bounds are the first non-trivial lower bounds for sorting 
in the multi­packet model of the mesh, and they imply that our upper bounds are nearly optimal on networks 
of sufficiently high constant dimension under a large class of indexing schemes, (In fact, we are not 
aware of any fast sorting algorithm for multi-dimensional networks that uses an indexing scheme not covered 
by our lower bound.) Using similar ideas, we can also establish a lower bound for selection on multi-dimensional 
meshes. Finally, we describe algorithms for permutation routing on multi-dimensional meshes and tori 
whose running times nearly match the diameter lower bound. In particular, our algorithms achieve a running 
time of D+ cn, for any c >0 and d sufficiently large (depending on c). Due to space constraints, some 
of the proofs have been omitted from this abstract. A more detailed de­ scription of our results will 
be given in a later version of the paper. The remainder of this paper is organized as follows. Section 
2 contains some useful definitions and lemmas, Section 3 gives improved algorithms for sorting on multi­dimensional 
meshes and tori. Section 4 contains our lower bounds. Section 5 describes our algorithms for permutation 
routing. Finally, Section 6 lists some open questions for future research. 2 Preliminaries In this section, 
we give some useful definitions and lem­ mas. We begin with a brief review of a derandomiza­tion technique 
for routing and sorting algorithms re­cently proposed in [6]. In Subsection 2.2, we state some results 
on greedy routing of random permutations. 2.1 Randomization and Unshuffling In the following, we describe 
a derandomization tech­nique proposed in [6], which can be used to convert many randomized algorithms 
for routing and sorting on meshes into deterministic algorithms. The technique is based on an operation 
called sort-and-unshufle. The purpose of this operation is to evenly distribute packets with similar 
destinations (in the case of routing) or sim­ilar ranks (in the case of sorting) over some large region 
of the network, using a combination of local sorting and unshuffling ). In the following, we assume a 
blocked snake-like , indexing scheme on a d-dimensional mesh, where the blocks have side length na with 
2/3 ~ cr < 1. In the first step of the sort-and-unshuffle operation, the pack­ets are sorted inside each 
block. In the second step, the packets of each block are distributed evenly over all the blocks. This 
is done by routing the packet of rank i, O < i < nda, in block j, O < j ~ nd(l-aj, to position j + [i/n~(l-a)j 
. n~(l-a) in block i mod n~(l-~). Note that this second step is an off-line routing problem; the particular 
permutation that has to be routed will be re­ferred to as unshufle permutation. (Note that if we lay 
out the processors of the network in a chain according to the indexing function, then this permutation 
is identical to an (n~(l-a))-way unshuffle operation on the chain.) The structure of this unshuffle permutation 
exhibits many of the nice properties commonly associated with average or random permutations. In particular, 
the unshuffle permutation has the property that the destina­tions of the packets in any region of the 
network are ap proximately evenly distributed over the entire network. As a consequence, the unshuffle 
permutation can in most cases be routed as efficiently as a random permutation. 28 (In fact, this claim 
can be formalized under certain con­ditions.) It was shown in [6] that the sort-and-uns~huffle op eration 
can in many cases be employed as a substi­tute for randomization. Following a scheme originally proposed 
by Valiant and Brebner [19], many random­ized algorithms for routing and sorting on meshes start by aending 
the packets to random intermediate desti­nations. This has the effect of distributing packets with destinations 
close to each other evenly over the network. The aort-and-unshuffle operation simulates this effect in 
a deterministic manner. Using this relationahilp between randomization and the sort-and-unahuffle operation, 
the algorithms of this paper can be described in both ran­domized and deterministic terms.  2.2 Some 
Results on Greedy Routing Routing is used as an important subroutine in many sorting algorithms for fixed-connection 
networks. In the algorithms presented in this paper, we need efficient routing schemes for random permutations 
(in the ran­domized case) and for unshuffle permutations (in the de terministic case). Our routing achemea 
are baaed on an extension of the standard greedy routing scheme. This routing scheme routes a packet 
on a d-dimensional mesh by moving it greedily towards its destination along edgea of increasing dimension. 
In the case of edge contentions, priority is given to the packet with the farthest distance to travel. 
In our extension of this routing scheme, k permu­tations are simultaneously routed by running d copies 
of the above greedy routing scheme. More precisely, we partition the set of packets into d sets SO,..., 
Sal-l of approximately equal size, such that the origins and des­tinations of the packets in each set 
are approximately evenly distributed over the entire network. This can be done either in a randomized 
way, by having each packet choose a random set Si, or in a deterministic way, by locally sorting blocks 
of side length o(n), and defining Si ss the set of packets with a local rank y such that ymodd= i. The 
packets in set Si are then routed along edges of increasing dimension modulo d, starting with dimension 
i and ending with dimension (i -1) mod d. It is a natural question to ask how many random permutations 
can be routed simultaneously under the above routing scheme. To make this queal,ion more precise, we 
define the notions of diameter-optimal and distance-optimal routing. We say that a routing alg­rithm 
on a d-dimensional mesh is diameter-optimal if all packets are delivered to their destination in time 
D + o(n), where D is the diameter of the network. We say that a routing algorithm is distance-optimtal 
if each packet is delivered in time S + o(n), where S is the distance between the source and the destination 
of the packet. In the context of an optimal randomized algo­rithm for k-k sorting, it was shown by Kaufmann, 
Ra­jasekaran, and Sibeyn [5] that up to 4d random permuta­tions can be routed diameter-optimally on d-dimensional 
meshes and tori, with high probability. The same bound can also be shown for the unshuffle permutation, 
leading to the optimal deterministic algorithm for k k sorting in [6]. However, theee results cannot 
be extended to the case of distance-optimal routing. For the standard greedy routing scheme, Leighton 
 [13] has shown that a random permutation can be routed distance-optimally on d-dimensional meshes and 
tori, with high probability. For the extended greedy routing scheme, we can show the following result. 
Lemma 2.1 Up to 2d random permutations can be routed distant-optimally on the d-dimensional torus, with 
high probability. Proofi (Sketch) Due to the structure of the torus, it suffices to consider the movement 
of the packets within a single dimension of the network. Initially, we assign 2 of the 2d random permutations 
to each dimension of the torus. Note that the destinations of the packets in each dimension are evenly 
distributed over all processors in the ring, and the distances between sources and des­tinations are 
evenly distributed over [n/2]. Whenever a packet reaches its destination in the ring, it moves on to 
the next higher dimension. On the other hand, we can assume that any new packet that arrivea in the current 
dimension chooses a random destination within the ring. Thus, we can analyze the movement of the packets 
within the current dimension by considering an appropriate dynamic routing problem, as defined by Leighton 
[13]. O Unfortunately, this analysis does not extend to the case of the d-dimensional mesh without wraparound 
edgea. In fact, it is not difficult to show that even d ran­dom permutations cannot be routed distance-optimally 
on the d-dimensional mesh under the extended greedy routing scheme. Using a more complicated analysis, 
we can show the following results for meshes without wrap around edgea. Lemma 2.2 For d z 3, two random 
permutations can be routed distanceoptimally on the d-dimensional mesh, with high probability. Lemma 
2.3 Up to [d/2J random permutations can be routed distance-optimally on the d-dimensional mesh, with 
high probability. Lemmas 2.1, 2.2, and 2.3 also extend to the case of the unshuffle permutation. We believe 
that the result 29 of Lemma 2.3 can be slightly improved, but we do not yet have an exact bound on the 
number of random per­mutations that can be routed distant-optimally on the d-dimensional mesh. 3 Upper 
Bounds for Sorting In this section, we give improved algorithms for 1 1 sort­ing on multi-dimensional 
meshes and tori. In the first subsection, we describe the basic ideas underlying our algorithms. Subsections 
3.2 and 3.3 contain our algo­rithms for multi-dimensional mesh= and tori, respec­tively. 3.1 Basic Ideaa 
The basic ideas underlying our algorithms are quite sim­ple. Consider the case of the d-dimensional mesh, 
and let C denote the set of processors that have a distance of at most D/4 from the center. It is not 
difficult to see that exactly half of the processors of the network are contained in this center region 
C. Also, no processor in C has a distance of more than 3D/4 from any other processor of the network. 
These observations lead to the following idea for a fast sorting algorithm. In the first phase, we concen­trate 
all packets into the center region C, in such a way that packets of similar ranks are evenly distributed 
over C. This can be done either in a randomized or in a deterministic fashion. Next, we locally sort 
the packets inside each block of side length na (as defined by the blocked indexing scheme) that is contained 
in C. Since all packets were evenly distributed over the center region in the first phase, we can use 
the local ranks of the pack­ets to obtain good approximations of the global ranks, and hence the final 
destinations, of all packets. In the third phase, we route each packet to some location in the block 
containing its approximate final destination. In the fourth phsse, we use local sorting to bring each 
packet to its final destination. Note that no packet has to travel a distance of more than 3D/4 in the 
first or the third phsse. Thus, if we can show that the routing in these two phases can be done distance-optimally, 
then the above scheme runs in time 3D/2 + o(n). In the next subsection, we give a more detailed de­scription 
of a deterministic algorithm based on the ideas presented in this section. We show that the routing problems 
in the first and third phase of the algorithm can be reduced to the simultaneous routing of several unshuffie 
permutations. We also present an even faster algorithm that makes one copy of each packet. In Sub­section 
3.3, we use similar ideas to obtain algorithms for the d-dimensional torus. 3.2 Sorting on Multi-Dimensional 
Meshes In the following, we give fast deterministic sorting al­gorithms based on the ideas described 
in the previous subsection. We assume a blocked snake-like indexing scheme with blocks of side length 
na. In addition, we also sssume an arbitrary fixed numbering of the ndtl-aJ/2 blocks located in the center 
region C, inde­pendent of the indexing scheme. We begin with the following simple algorithm: Algorithm 
SimpleSort: (1) Sort the packets in each block of side length n . (2) Distribute the packets in each 
block evenly over all blocks in C. This is done by routing the packet ofrank i,O~i<nda,inblockj, O<j 
s  n@-a) to pmition j+ [i/nd(l-a)] .nd(l-a) in block > i mod (nd(l-aJ/2) in C. (Here, the numbering 
of the destination blocks is with respect to the arbi­trary fixed numbering of the blocks in C.) Note 
that each processor in C receives exactly two packets. (3) Sort the packets in each block of side length 
na in c. (4) Send the packets in each block in C towards their destinations. This is done by routing 
the packet of rank i, O < i < 2nda, in block j, O < j ~ nd(l-a)/2 of C to position j + (i mod 2nd(2a-1)) 
. nd(l-a)/2 in block li/(2nd(2d-1))]. (Here, the numbering of the source blocks is with respect to the 
arbitrary fixed numbering of the blocks in C.) Note that each pro­cessor in the network receives exactly 
one packet. (5) Perform two steps of odd-even transposition sort between neighboring blocks.  The correctness 
of the above algorithm is implied by the following lemma, which can be proved along the lines of Lemma 
3.2 in [6]. Lemma 3.1 After Step (4) of Algorithm SimpleSort, each packet is at most one block away from 
its destina­tion, Next, we analyze the running time of the above al­gorithm. Clearly, Steps (1), (3), 
and (5) each run in time O(na) = o(n). For the routing in Step (2), the following can be shown. Lemma 
3.2 Step (2) of Algorithm SimpleSort can be reduced to the routing of two partial unshuffle permuta­tions. 
30 Proofi Consider the packets of a single unshuffle per­mutation r. Let S be the set of processors 
that contain a packet with destination in C. In each block, exactly half of the processors are in S, 
and the destinationa of the packets in these processors are evenly distributed over all blocks in C. 
Let # be the partial permutation con­ sisting only of the packets that are initially locnted in S. After 
# has been routed, we move the remaining half of the packets to the proceaaors in S. By routing another 
instance of the partial unahuffle permutation nJ, we can now distribute these remaining packets evenly 
over the blocks in C. Of course, the two instances of # can also be started simultaneously. C By Lemma 
2.2, we know that two partia~ unahuf­fle permutations can be routed distanceoptimally on meshes of dimension 
d z 3. Since no packet has to travel a distance of more than 3D/4, this implies that the rout­ing is 
completed in time 3D/4 + o(n). AISO IBote that the routing problem in Step (4) is exactly the inverse 
of the problem in Step (2), and therefore runs within the same time bound. This establishes the following 
result. Theorem 3.1 For any constant d, there exists a deter­ministic sorting algorithm for the d-dimensional 
mesh with a running time of 3D/2 + o(n) that doea not make any copies of the packets. By Lemma 2.3, up 
to [d/2J unshuffle permutw tions can be routed distanc~optimally on d-dimensional meshes. By modifying 
Algorithm SimpleSort appropri­ately, we can use this extra bandwidth to esta~bliah the following result 
for k-k sorting. Corollary 3.1.1 If k < [d/4J, then there exists a deter­ministic algorithm for k k sorting 
on the d-dimensional mesh with a running time of 3D/2 + o(n) that does not make any copies of the packets. 
We can also get a slight improvement in the running time for 1 1 sorting, by concentrating the packets 
into a smaller center region C. In general, however, the run­ning time of this improved algorithm is 
still (3/2 -t)D, for all c >0 and d sufficiently large (depending on c). Corollary 3.1.2 Let C(r) be 
the set of processors of distance at most r from the center point. If lC(r)l ~ 2nd/d, then there exists 
a deterministic sorting algo­rithm for the d-dimensional mesh with a running time of D+2r+o(n). Next, 
we show that the time for 1 1 sorting can be reduced to 5D/4 + o(n) by making one coF Y of each packet. 
To do so, we modify Algorithm SimpleSort ap propriately; the resulting algorithm is called CopySort. 
Steps (1), (3), and (5) remain the same as in Algorithm SimpleSort. The routing in Step (2) of SimpleSort 
is augmented as follows. As before, we distribute the pack­ets evenly over the blocks in C. In addition, 
we make one copy of each packet, and route this copy to a processor in the unique block of the center 
region C that is located exactly on the opposite side of the center point than the destination processor 
of the original in this step, and that has the same distance from the center point. The routing of the 
copies can be done simultaneously with the routing of the originala, and the entire Step (2) can be implemented 
by routing four partial unshuffle per­mutations. By Lemma 2.3, the routing is completed in 3D/4 + o(n) 
steps for d z 8. The following lemma can be shown using simple geometric arguments. Lemma 3.3 After Step 
(3) of Algorithm CopySort, no processor in the network is more than a distance of D/2 + o(n) away from 
both the original and the copy of any packet. In Step (4) of CopySort, we first delete either the original 
or the copy of each packet, depending on which one is farther away from the destination. Then the re­maining 
packets are routed towards their destination. It can shown that this routing can again be implemented 
by four partial unshuffle permutations. By Lemma 3.3, no packet has to travel more than a distance of 
D/2. This establishes the following result. Theorem 3.2 For any constant d ~ 8, there exists a de terministic 
sorting algorithm for the d-dimensional mesh with a running time of 5D/4 + o(n). For larger values of 
d, this result can again be slightly improved by concentrating into a smaller center region. Alternatively, 
we can also adapt the algorithm to k-k sorting with k < id/8]. 3.3 Sorting on Multi-Dimensional Tori 
In this subsection, we adapt the ideas of the previous subsections to the case of the d-dimensional torus. 
We describe a modification of the Algorithm CopySort from the previous subsection, which we refer to 
as TorusSort. As before, Steps (1), (3), and (5) perform local sorting operations. In Step (2), we distribute 
the packets evenly over the entire network. In addition, we also make a copy of each packet, and route 
this copy to a processor in the unique block in the network that is D/2 steps away from the destination 
processor of the original packet in this step. Step (2) can be implemented by routing two full unshuffle 
permutations; the routing takea time D+ o(n). Then the following lemma can be shown using simple geometric 
arguments. Lemma 3.4 After Step (3) of Algorithm TorusSort, no processor in the network ia more than 
a distance of D/2 + o(n) away from both the original and the copy of any packet. As before, half of the 
packets are deleted in Step (4), and the remaining packets are routed towards their des­tination. This 
routing can be implemented by two par­tial unshuffle permutations. By Lemma 3.4, no packet has to travel 
more than a distance of D/2 + o(n). Using Lemma 2.1 we obtain the following result. Theorem 3.3 For any 
constant d, there exists a deter­ministic sorting algorithm for the d-dimensional torus with a running 
time of 3D/2 + o(n). By modifying Algorithm TorusSort appropriately, and using the extra bandwidth supplied 
by Lemma 2.1, we can establish the following result. Corollary 3.3.1 For any constant d, there exists 
a deterministic algorithm for d-d sorting on the d­dimensional torus with a running time of 3D/2 + o(n). 
Alternatively, we can also get a slight improvement in the running time for 1 1 sorting. As an example, 
we can obtain a fairly simple algorithm for the two­dimensional torus that uses four copies of each packet 
and runs in time 1.375n. In general, however, the run­ning time of the improved algorithm is still (3/2 
-c)D, for all c >0 and d sufficiently large (depending on c). 4 Lower Bounds for Sorting In this section, 
we establish lower bounds for sorting on multi-dimensional meshes and tori under the multi­packet model. 
The lower bounds hold for a large class of indexing schemes, including most of the indexing schemes used 
in the literature. Our lower bound tech­nique is an extension of the Joker Zone argument of Kunde [~ 
and Schnorr and Shamir [17 J to the multi­packet model. An important difference is that our lower bounds 
are based on edge capacity arguments, and do not place any limits on the number of packets that can be 
held inside a single processor. We begin the section with a few definitions. We say that an indexing 
scheme Z of the d­dimensional mesh ia compatible if there exists a ~ < 1 such that for every index i 
c [n~ -n~~], the set of pro­cessors with indices in {i, . . . . i + n~~ -1} contains a complete (d 1)-dimensional 
subnetwork of side length n. (Informally speaking, this means that a compatible indexing scheme has the 
property that a joker zone of n~~ packets suffices to move the final destination of a packet to any processor 
within a (d 1)-dimensional sub-network.) Note that the natural extensions of the row-major, snaldike, 
blocked row-major, and blocked snake-like indexing achemea to multi-dimensional net­works are compatible 
indexing schemes. In the remain­der of this section, we asaume an arbitrary compatible indexing scheme 
with associated constant /?. We use cd,~ to denote the proceaaors of a d­dimensional diamond of radius 
(1 7) . D/4 around the center of a d-dimensional mesh. (That is, the set of pro­cessors that have a 
distance of at most (1-7). D/4 from the center.) The number of proceasora in Cd,v is denoted by Vd,y, 
and the number of processors on the surface of Cd,? is denoted by &#38;,~. Then the following bounda 
can be shown. Lemma 4.1 For any d and any 7>0, we have Vd,? < e-7%df4 -nd and 8 -+d/16 . rid-l. &#38;,.y< 
se 7 4.1 Sorting without Copying We first establish a lower bound for sorting under the restriction 
that no copies of the packets can be made. Our main lemma for this csse is as follows. Lemma 4.2 Let 
d and 7 be chosen such that sd~ ((:+w D-dn9<   nd-v ~ holds for large enough n. If no copying of psckets 
ia al­lowed, then sorting on the d-dimensional mesh with re­spect to an arbitrary compatible indexing 
scheme takea atleast D+(1 7).D/2 -n dn~ steps. Proofi Consider the computation of an arbitrary sort­ing 
algorithm up to time (~ + ~) . D -dnd. At most d. sd,7 packets can enter the diamond cd,~ in each step. 
Thus, the above inequality implies that not all of the nd vd,~ packets that are initially outside the 
diamond can have entered up to this point. Now consider an arbitrary packet located outside the diamond 
at time (~ + ~) . D dn~. This packet has a distance of at least (~+ ~) . D from at least one of the 
corners of the network. (Otherwise, the packet would be in the diamond.) Thus, the present position of 
the packet is independent of the content of a block of side length n~ located in that corner. As we assume 
a compatible indexing scheme, the content of this block can force the destination of the packet to be 
in any processor of a (d -1)-dimensional sub-network of side length n. There exists a processor in this 
sub-network that has a distance of at lead (~ + ~) . D -n from the current position of the lpacket. Hence, 
at least ($ + ~) . D n additional steps are needed under some assignment of values to the corner block. 
0 Theorem 4.1 If no copying of packets is allowed, then for every c ~ O there exists a do such that for 
iill d ~ do, sorting on the d-dimensional mesh with respect to a compatible indexing scheme takes at 
least (3/2 c)D steps. To establish this theorem, we use Lemma 4.1 to show that the condition in Lemma 
4.2 holds for 7 = 3E and d sufficiently large (depending on c), The claim then follows by a direct application 
of Lemma 4.2. Together with Theorem 3.2, this result establishes a sepwation between the complexities 
of sorting with and without copying, for large values of d. Unfortunately, Lemma 4.1 does not give any 
good bounds for small values c}f d. In this case, we can show lower bounds by adapting our argument to 
the particular network in question. [n par­ticular, we can establish the following theorem. Theorem 4.2 
If no copying of packets is allowed, then for d ~ 5 the diameter bound cannot be asymptotically matched 
under any compatible indexing scheme. For the torus, it can be shown that the lower bounds for the single-packet 
model also extend to the multi­packet model, assuming that no copying is allowed. In­formally speaking, 
the reason is that the torus doea not have a center point towards which the packets could be routed. 
4.2 Sorting with Copying Our lower bound techniques can also be extended to a model in which unlimited 
copying of packets is allowed. For this case, we obtain the following result. Theorem 4.3 If unlimited 
copying of packets is al­lowed, then for every c ~ O there exists a do such that for all d ~ do, sorting 
on the d-dimensional mesh with respect to a compatible indexing scheme takes at least (5/4 e)D steps. 
We only describe the main ideas in the proof of the above theorem. The basic idea for this lower bound 
is that we choose the center diamond small enough such that only a small fraction of the packets can 
be routed into this diamond. Next, we argue that the edge band­width of the network does not allow every 
packet to distribute a large number of copies of itself over the net­work. (Formally, the number of communication 
steps required to route copies of a packet to a number of lo­cations in the network is lowerbounded by 
the length of a minimal broadcast tree connecting these locations.) This implies that an appropriate 
loading of the joker zones can force the rank of a packet to be such that no copy is close to its destination. 
However, this technique does not give any non­trivial lower bounds for reasonable valu-of d. We expect 
that some results for smaller d can be ob­tained by adapting our argument to the particular low­dimensional 
network in question. We plan to report the results of such an analysis in a later version of this pw 
per. In the case of the torus, we obtain the following result. Theorem 4.4 If unlimited copying of packets 
is al­lowed, then for every E ~ O there exists a do such that for all d ~ do, sorting on the d-dimensional 
torus with respect to a compatible indexing scheme takes at least (3/2 -c)D steps. The lower bounds can 
also extended to many non­compatible indexing schemes. In fact, it is not difficult to show that the 
above bounds hold for the vast majority of all possible indexing schemes. (A similar result for the singl-packet 
model was described by Kunde [8].) Of course, such a result is not a very good measure for the generality 
of our lower bounds, since most indexing schemes are highly irregular and thus unsuitable for any efficient 
sorting scheme. More important in this respect is that we are not aware of any fast sorting algorithm 
that assumes an indexing scheme not covered by our lower bound. This indicates that any such algorithm 
would probably be quite different from those currently known. 4.3 Selection Using similar ideas, we 
can also show a lower bound of (9/16 c) oD for the problem of selecting the median at the center processor 
of a high-dimensional mesh. A triv­ial lower bound for this problem is given by the radius of the network. 
(That is, D/2 for the multi-dimensional mesh and D for the multi-dimensional torus.) By Lemma 4.1, we 
know that for any c >0 and any sufficiently large d, only a small fraction of the packets can enter c+ 
in the first D/2 steps of any algorithm. Let z be any processor outside Cd,,. Then the set of processors 
that have a distance of at most (5/16 26). D from z contains only a small fraction of the n~ processors 
in the network. This means that up to time (5/16 26). D, no packet located outside C,f,c can be ruled 
out as the median element. Hence, up to (1 c) .D/4 additional steps are necessary to move the median 
to the center processor, and we get the following result. Theorem 4.5 For every c ~ O there exists a 
do such Theorem 5.1 For all d, there exists a deterministic al­ that for all d ~ do, selection on the 
d-dimensional mesh gorithm for permutation routing on the d-dimensional takes at least (9/16 -c)D steps. 
mesh with a running time of D + n + o(n). An upper bound of D + o(n) can be obtained by a modification 
of the sorting algorithms in Section 3. For large values of d, this result can be improved to (3/4 + 
c). D. On the multi-dimensional torus, a running time of (1+6) .D can be achieved for large d, thus coming 
very close to the trivial lower bound of D. 5 Permutation Routing The lower bounds established in the 
previous section are restricted to the case of sorting. In this section, we show the existence of algorithms 
for permutation routing on multi-dimensional networks that nearly match the di­ameter lower bound. The 
algorithms are bssed on sim­ilar idess as the sorting algorithms in Subsection 3. In particular, they 
use a similar reduction to the distance optimal routing of a number of unshuffle permutations. Consider 
the following idea for a randomized rout­ing algorithm. For a packet with source processor z and destination 
processor y, we define S(z, y) as the set of processors that have a distance of at most D/2 from both 
2 and V. Note that S(z, y) is non-empty for all z and y. Thus, a simple two-phase algorithm could route 
a packet with source x and destination y by first sending the packet to a random processor in S(z, y), 
and then to its destination y. If we could solve the resulting two routing problems distance-optimally, 
then we would ob­tain a total running time of D + o(n) for the algorithm. Unfortunately, we do not know 
how to reduce these two routing problems to a small number of random or unshuffle permutations. To do 
SO,we have to modify the above algorithm slightly. We define S (z, y) as the set of processors that have 
a distance of at most D/2+ v from both z and V. In the first phase of the algorithm, we now route each 
packet with source z and destination y to a random processor in S. (x, y). In the corresponding deterministic 
algorithm, we partition the network into blocks of side length na , and distribute all packets with source 
in block X and destination in block Y evenly over Sv (X, Y), the set of blocks that have a distance of 
at most D/2 + v from both block X and block Y. If we choose v such that k . ISV(X, Y) I > nd holds for 
all blocks X and Y, then we can reduce each phsse of the algorithm to the simultaneous routing of k unshuffle 
permutations. For a block X, define c(X) aa the corner processor that is closest to X. Then we can lowerbound 
S (X, Y) by SV(C(X), c(Y)). An analysis shows that for d~4andv = n/2, we have ld/2j . ISV(C(X), c(Y)) 
I ~ nd, and hence we can reduce each phase of the algorithm to the routing of [d/2] unshuffle permutations. 
Using Lemma 2.3, we obtain the following result. The routing scheme can be easily adapted to the multi-dimensional 
torus. For d > 4 and v = n/16, we have 2d. IS (X, Y)l ~ nd, and by Lemma 2.1 we obtain the following 
result. Theorem 5.2 For all d, there exists a deterministic al­gorithm for permutation routing on the 
d-dimensional torus with a running time of D + n/8 + o(n). Finally, a sharper analysis using bounds similar 
to those in Lemma 4.1 shows that in high-dimensional meshes (tori), moat processors have a distance of 
around D/2 from any particular corner (any particular proces­sor). This means that as d incre~s, we can 
choose smaller and smaller values for v. Theorem 5.3 For all c >0, there exists ado such that for all 
d ~ do, permutation routing can be done in time D + m on d-dimensional meshes and tori. 6 Concluding 
Remarks In this paper, we have shown improved bounds for rout­ing and sorting on multi-dimensional meshes 
and tori. While our bounds are nearly tight for high-dimensional networks, we do not obtain very good 
bounds for net­works of small, fixed dimension. In particular, it is an intereating open question whether 
there exists an opti­mal algorithm for sorting on the two-dimensional mesh that does not make any copies, 
or whether any optimal sorting algorithm exists for some d >3. We are currently investigating whether 
the lower bounds for sorting can be extended to arbitrary indexing schemes. One possible approach to 
this problem is to adapt some of the techniques that have been used to show lower bounds for arbitrary 
indexing schemes in the single-packet model [1]. It would also be nice to obtain algorithms for per­mutation 
routing that match the diameter bound more closely. For example, one might try to overlap the two routing 
phases of the algorithm in Section 5, and bound the running time of the resulting algorithm. Finally, 
it is an open question whether the diameter and bisection bounds can be matched simultaneously for routing 
on networks of dimension d >2. Acknowledgements I would like to thank Greg Plaxton and Rajmohan Ra­jaraman 
for helpful discussions. References [12] M. Kunde. Block gossiping on grids and tori: De­ [1] [2] [3] 
[4] [5] [6] [7] [8] [9] [10] [11] Y. Han and Y. Igarashi. Time lower bounds for par­allel sorting on 
multidimensional mesh-connected processor arrays. Information Processing Letters, 33:233-238, 1990. Y. 
Han, Y. Igarashi, and M. Tmszczynski. Index­ing functions and time lower bounds for sorting on a mesh-connected 
computer. Discrete Applied! Math­ematics, 36:141-152, 1992. C. Kaklamania and D. Krizanc. Optimal sorting 
on mesh-connected processor arrays. In Proceedings of the Jth Annual ACM Symposium on Pamlltd Algo­rithms 
and Amhitectunw, pagea 50-59, July 1992. C. Kaklamanis, D. Krizanc, L. Narayanan, and T. Tsantilas. Randomized 
sorting and selection on mesh-connected processor arrays, In Proceedings of the 3ni Annual ACM Symposium 
on Pamlltd Algo­rithms and Amhitectums, pagea 17-28, July 1991. M. Kaufmann, S. Rajasekaran, and J. F. 
!Sibeyn. Matching the bisection bound for routing and sort­ing on the mesh. In Proceedings of the dth 
Annual ACM Symposium on Pamllel Algorithms wad Ar­chitectures, pages 31-40, July 1992. M. Kaufmann, J. 
Sibeyn, and T. Suel. Derandom­izing algorithms for routing and sorting on meshes. In Proceedings of the 
Fifth Annual ACM-SIAM Symposium on Discwte Algorithms, pages 6&#38;679, January 1994. M, Kunde. Lower 
bounds for sorting on mesh­connected architectures. Acts Informatica, 124:121­ 130, 1987. M. Kunde. Bounds 
for l-selection and related prob­lems on grids of processors. In Pmceeding~~ of the dth International 
Workshop on Pamllel Processing by Cellular Automata and Arrays (PARCIILLA), pages 298-307. Springer, 
1988. M. Kunde. Routing and sorting on mesh-connected arrays. In J. H. Reif, editor, VLSI Algotv th ms 
and Amhitectures: Proceedings of the Wd Aegean Work­shop on Computing, Lecture Notes in Computer Science, 
volume 319, pagea 423-433. Springer, 1988. M. Kunde. Balanced routing: Towards the clistance bound on 
grids. In Proceedings of the 3ni Annual ACM Symposium on Pamllel Algorithms und Ar­chitectures, pages 
260-271, July 1991. M. Kunde. Concentrated regular data streams on gridsi Sorting and routing near to 
the bisection bound. In Proceedings of the 32nd Annual IEEE Symposium on Foundations of Computer Science, 
pages 141-150, October 1991. terministic sorting and routing match the bisection bound. In Proceedings 
of the Ist Annual European Symposium on Algorithms, September 1993. [13] F. T. Leighton. Average case 
analysis of greedy routing algorithms on arrays. In Proceedings of the 2nd Annual ACM Sympasium on Pamllel 
Al­gorithms and Amhitectums, pagea 2-10, July 1990. [14] F. T. Leighton. Introduction to Pamllel Algorithms 
and Amhitectunx: Arm ys, %es, and Hypenxdws. Morgan-Kaufmann, San Mateo, CA, 1991. [15] D. Nassimi and 
S. Sahni. Bitonic sort on a meah­connected parallel computer. IEEE l%msactions on Computers, C 28:2-7, 
1979. [16] S. E. Orcutt. Computer OWanization and Algo­m thms for Very-High Speed Computations. PhD theais, 
Department of Computer Science, Stanford University, September 1974. [17] C. P. Schnorr and A. Shamir. 
An optimal sorting algorithm for mesh-connected computers. In Pr­oceedings of the 18th ACM Symposium 
on Theory of Computing, pagea 255-263, May 1986. [18] C. D. Thompson and H. T. Kung. Sorting on a mesh-connected 
parallel computer. Communica­tions of the ACM, 20:263-271, 1977. [19] L. G. Valiant and G. J. Brebner. 
Universal schemes for parallel communication. In Proceedings of the 19th Annual ACM Symposium on Theory 
of Com­puting, pages 263-277, May 1981. 
			

 Reuse R&#38;D: Is it on the right Track Moderator: Mansour Zand, University of Nebraska at Omaha Panelist: 
Gillermo Arango, Manager, Information Technology at Schlumberger WTH. Maggie Davis, Boeing Defense and 
Space Group Ralph Johnson, University of Illinois at Urbana-Champaign Jeffrey S. Poulin, Lockheed Martin 
Federal Systems Andrew Watson, Architecture Director, Object Management Group Introduction and organizational 
issues Mansour Zand In today marketplace, the competitive software developing shop is the one that can 
reduce produce delivery time, increase diversity of the product enhance interoperability, and conform 
to standardization of components. In the past decade, software reuse gradually has started coming into 
the main stream of research and practice as a viable subfield of software engineering. Reuse practice 
has a great potential, more than many other on-going activities in software to improve software development 
process. However,thereisnotssmuchprogressas was expected. There have been many papers and articles in 
technical, professional, as well as trade publications dealing with the issues and prospects, the pros 
and cons, and the incentives and impediments of soflware reuse. This panel will provide an open forum 
on the future direction of reuse R8cD and the degree of its contribution in software development in the 
past 10-15 years. There is little doubt about the reuse R&#38;D contribution, however, there were some 
questions on how significantthe impact has been. Panel participantswill discuss on three differentprospective 
on reuse research and practice. 1- Those mainly involved in research present their point of view, from 
their research on how things have changed, what wncepts have been or should be discarded, and what new 
challenges have emerged. 2- People from industry: software development practitioners, could tell us if 
reuse research has been relevant and useful in their day-to-day work, whether the tools and methods put 
out during the past 10 years have been useful, and what their expectationsarefromusefultoolsandtechniques. 
3- How people in smaWmedium sized shops have benefited from ongoing R&#38;D snd how their needs are different 
from the large scale software shop. Permission to make digital/hard copy of part or all this work for 
personal or classroom uae ia granted without fee provided that copies are not made or distributed for 
profit or commercial advan­tage, the copyright notice, the titla of the publication and its date appear, 
and notice ia given that copying is by permission of ACM, Inc. To copy otherwiaa, to republish, to peat 
on servera, or to redistribute to hats, requires prior specific permission and/or a fee. SSR 97 MA, USA 
@ 1997 ACM 0-89791 -945 -919710005 ...$3.50 One of the major shortcomingof the researchis the lack of 
adequatework in the non-technical issues. Reuse practice has a great potential, fm more of many other 
on-going activities in sotlware, to re-structure the organization of software development shops, thus 
management and organization of these departments are to be reconsidered in the context of the entire 
organization rather than by itself. A lack of a clear organizational strategy continues to be a major 
hindrance on the development of software reuse. Organizations shy away from reuse project as soon as 
budgetary problems are surfacing. Those reuse projects that have been successful normally have organizational-wide 
support. Organizations that lack a plan for systematic reuse, do not have a holistic system development 
and lack the knowledge of long-term organizational strategic advantage may only benefit tlom partial 
success of soflware reuse [zand95]. As indicated by others in this panel software development is bound 
to be changed drastically, if it is not already done in some of the software shops. There are a large 
number of overnight success stories on those software companies that have capitalized on the new technologies. 
Most of those companies have deliberately or were forced to restructure and reorganize their companies 
to gain the maximum reward of the technologies. There has been a lot of emphasis on the establishing 
of reuse culture in organizations. Nevertheless, very few works have been published and most of them 
are now obsolete. New studies on instituting of reuse culture should investigate the impact of Internet 
resources and recent software engineering and specifically reuse paradigms. We need to closely look at 
the non-traditional software shops and learn how they have succeed (or failed) to structure their organization 
around the new technology. The study should include the impacts of the instituting reuse on resources 
(explicitly human resources), management inter and intra organization communication process, etc. There 
is a belief that technology will find its way and force the necessary adjustment. This is a passive view. 
If we do not study the strength and course of the stream, we may go down with the stream rather than 
ride on it. Reference [zand95], M. K, Zand, M. H. Samazadeh, Sofhvare Reuse: current Status and Trends 
, Journal of Systems and Software, Sept. 1995, Reusability research is drifting away from reality  
 Guillermo Arango I will speak from the position of a R&#38;E manager in industry. As I was invited to 
participate in this panel to stimulate debate, you will forgive me if I step on some toes in my enthusiasm 
to challenge some established practices. Three years ago, in response to an invitation by the ACM Symposium 
of Applied Computing, I prepared a short essay [1] sharing my concern about the relevance of (a good 
portion of) software reusability research. For some time we had been witnessing substantial changes in 
the ecology of software development while the basic assumptions and beliefs of reuse research had remained 
stable for over a decade. Things have not changed in the past couple of years if we take the publication 
output of the community as an indicator of its interests and directions. Reality continues to drift away 
from the mainstream of software reusability research. Software reusability is an engineering strategy. 
The various implementations of this strategy can only be justified on practical and economic grounds. 
Most of the research of the reuse community focus on solving specific implementation problems. The value 
of any given implementation, however, depends on the social and economic rules that shape a software 
development environment. As the rules change, environments change, and the immutable implementations 
of the reuse strategy become less attractive. Could these implementations evolve and adapt to changing 
environments? Yes, and to do so, the reuse community must be willing to write off the investment it has 
made on particular classes of implementations and move on. Let us take as sm example a classic concept: 
The Library of Components. As conceived in the late 1970 s it was art intra­company asset; fairly generic 
(although later experience persuaded developers to become problem-domain specific); it was based on the 
notion that you first create a classification scheme and you then populate the collection of components; 
it assumed that the average software developer sat in front of a screen, queried a catalog, and (if lucky) 
she would do black box reuse. Each aspect of the construction and use of that type of libraries fed research 
projects for years and still accounts for a good portion of research papers submitted for publication. 
Away from that particular implementation model, if I look at how developers work, I see first of all 
people who are networked. (The network, as we know it today, was not part of reality in the late 1970 
s). On the developers screens you find fixed windows interfacing with search engines that index the intranet 
repositories and the public Internet, with the corporation people directories, with technology watch 
bulletins. As of late, technical webcasting applications are starting to claim part of the screen real 
estate (these were not part of reality even a year ago). In this environment the capability of an average 
developer to link to information and people grows by orders of magnitude every year. The amount of resources 
available to her grows by orders of magnitude. Furthermore, the link to reusable asset is often mediated 
by a third party, thus blurring the distinction betweenproduct--thereusableservice, mythicalcomponent--and 
Developers,forinstance,notabout worry aboutintegrating, reusing. Themodus operandiofthesepeoplehaveIhtletodo 
whh TheReuserthataccessedTheLibrary. The environment and the workflows of the software developers is 
continually changing, driven by information technology and by market conditions. The implementations 
of the reuse strategy that ignore such workflows are imelevant from sn engineering point of view. The 
sothvare reusability community has am excellent opportunity to make a contribution to the practice of 
software development but the reality of software development is a moving targeh and implementations of 
the reuse strategy must fit the workflows of real developers not of theoreticrd reusers. Reference [1] 
G. Arango. Software Reusability and the Internet. ACM Symposium on Applied Computing, Phoenix, AZ. 1994. 
On practicality of Domain-specific Languages and analysis and Multifaceted reuse Libraries Maggie Davis 
The two trends with the most impact over the past 15 years have been . domain-specific languages and 
analysis and . multifaceted reuse libraries.  The notion of domain specificity has grown into domain 
engineering processes and several competing methods for domain analysis. The notion of domain has been 
applied in industry both from a point of view of domain as a product line or business area and has been 
taken up by the object-oriented community as a way of designing class libraries and object-oriented frameworks 
for specific software applications. The notion of multifaceted reuse libraries has not been as successfully 
applied. Libraries for general use within a corporation are difficult to sustain and the growth of a 
COTS component industry (especially for the 00 languages and  windowing systems) makes them almost obsolete. 
Fromthe point of view of a sottwaretechnologist in the aerospace and defense industry, much of the domain-specific 
research has been hard to transfer to real projects beeause it has been language rather than graphic 
centered. This is a cultural problem, where the engineers who might embrace a new idea are reluctantto 
have to learn what appears to be yet another programming language and another design approach --domain 
analysis. But thisisnota new problem,when you realize how long it has taken 00 languages and approaches 
to be adopted into this culture. The recent technological changes with the growth of intrawebs has made 
it easier to make reuse libraries readily accessible. The availability of full text search engines has 
overtaken the need for painstakingfaceted classification by reuse librarians. Now the problem is to keep 
up-to-date with new commercial releases. The notion of domain analysis and engineering is slowly being 
adopted. This adoption is slowed not by technological problems but business culture ones. There are 
still not very good statistics that show the worth of domain engineering. The most current technological 
problems are connected to software architecture and the upheaval caused by rapid proliferation of JAVA 
appiets. Actually, this is a just a symptom of a deeper problem the rapid change the soflware industry 
is undergoing and the new distribution medium of the World Wide Web. Now, not only do the rapid changes 
in computing hardware affect the 5-6 year development of unprecedented systems, but also the basic software 
infrastructure is rapidly changing. Indeed, the tools used for development are not even stable. Software 
architecture research that shows the ways for isolating or incorporating change is critical. Otherwise, 
those domain­specitic components that the corporation invested its research dollars in are obsolete before 
they are fielded.  Ralph Johnson, Unlike those who wony about what we have to do to make reuse happen, 
I think reuse has already happened and reuse experts have missed it. There is no doubt that the situation 
can be improved and that more research is needed, but developing new tools is not the biggest priority. 
Researchers need to study the tools that people are using right now, like Visual Basic, SmaMalk, and 
Java. They need to look at the processes developers are using, and figure out ways to improve them. They 
need to analyze domains, build component libraries, and develop other reusable assets. They need to practice 
reuse and study the practice of reuse. I ve worked with several groups that have developed a good reuse 
system. Most of what I ve seen fits what everybody says about successful reuse programs; they worked 
in a ruwrow domain, they had strong management suppo~ and they had strong technical leadership. But one 
of the things that has impressed me is how long it takes to succeed at developing reusable assets. In 
all these cases it has taken three or four years of domain analysis and domain engineering, and the groups 
always started with people who had a decade or so of experience in the domain. Developing reusable software 
is hard, and I think one of the reasons that there is not more of it is because few developers crm afford 
the time to do it. It is pretty easy to make a GUI framework like AWT because GUI frameworks have been 
built many times and so there is a lot of domain anrdysis and engineering that can be reused. But what 
about application­specific frameworks? They rarely get described, and so companies that are going to 
build one must start from scratch. Not only is the cost high, but it takes a long time, and most companies 
are not able to work on projects for three or four years without results. This kind of work should be 
done by researchers, because it is research. It requires the long view. Instead, researchers tend to 
focus on enabling technology. But anybody who sells a technology for reuse without providing a library 
of components is a snake oil salesman, a fraud, a charlatan. The hard part is coming up with the libraries. 
If they haven t build their own libraries, how do they know their technology really works? If they have, 
they should be writing books about the library. Even if people can t use the technology because they 
use different platforms or different programming environments, they can still learn a lot by studying 
the libraries. In summary,1believe that reuse researchers should concentrate more on developing reusable 
assets. Instead of developing component librarians, we should develop component libraries. Instead of 
studying domain analysis, we should analyze domains. We should write papers on our designs, not just 
the methods we used to get them. If we do this, we ll have a big impact on the practice of sotlware reuse. 
 On the Contributions of Reuse Research and Development to the State-of-the-Practice in Reuse Jeffrey 
S. Poulin Reuse Research and Development (R&#38;D) has had a positive affect on many practical problems 
faced by industry. Early work on library methods gave the field a focus, and allowed it to grow. More 
recently, research on reuse practices, organizations, domain analysis techniques, and metrics have found 
a place in the daily routine of large industrial development organizations [Poulin97]. Techniques such 
as object-orientation and soRware architectures often rely on software reuse as a uni~ing goal or objective. 
Finally, technologies such as visual programming languages (e.g., Visual Basic (VB)) provide a natural 
medium for developers to unconsciously practice reuse. As Ed Yourdon observes, the real benefit of languages 
such as VB/Powerbuilder may be software reuse rather than the visual paradigm ~ourdon96]. I would like 
to expand on the dynamic relationship between R&#38;D, large-scale software development, and sofhvare 
reuse. We know that new technologies often take a very long time before they move from R&#38;D into general 
acceptance and practice. During this time, our perceptions and expectations with respect to the technology 
often change dramatically. A Growing Need for Technology Ex~erts The world s appetite for software seems 
to have no bounds. This need for sofhvare eventually will (if it has not already) outgrow our development 
abilities. Meeting this sofhvare crisis will require a far more radical change in our approach to software 
development than anything we have conceived of to date. However, I see us meeting this challenge in much 
the same way as the world met another radical technology, the telephone. In 1876 Alexander Graham Bell 
filed for and obtained a patent application for his version of the telephone. Seizing upon the opportunity 
to promote his new invention, Bell introduced the telephone to the world later that year at the Centennial 
Exhibition in Philadelphia Bell s telephone immediately became the talk of the international scientific 
community and one of the most amazing things in America Within a year of the centennial exhibition, Bell 
had installed 230 phones and had established the Bell Telephone Company. Four years after its creation, 
60,000 phones existed; by the turn of the century that increased to two million. Despite its novelty 
and its rudimentary audio quality, the telephone took a quick and fierce hoId on American society. Within 
25 years (about the same time it took for computers to move from the raised floors of a few select corporations 
to the desktop) the telephone became a necessity. However, people neededto workthrougha switchboardoperatorinorderto 
placea call. This mesnt that with the explosive growth of the telephone came an explosive growth in the 
need for operators. By 1910, New York Telephone had 6,000 women working on its switchboards. Projections 
showed that if the growth in telephone use continued, a significant portion of the population would have 
to become operators in order to keep up with the enormous number of calls. The telephone company avoided 
this crisis by assigning everyone a phone number and fielding the rotary-dial phone. This meant that 
everyone essentially became an operator. The computer, like the telephone, has brought a radical change 
to way the world conducts its business. However, computers have traditionally required highly technical 
training to operate and program. With nearly everyone demanding specialized software and custom applications, 
the world will soon find itself hopelessly short of people with this technicrd training. I predict that 
we will address this crisis much as we did with telephone operators. In sho~ we will make programming 
computers accessible to everyone, whether or not they have a technical background. Our challenge comes 
in developing the technologies to make this possible. Evervone Becomes a Programmer Many technologies 
have progressively made programming more accessible to the computer novice; a couple of these deserve 
mention. The designers of COBOL intended to make a language in which managers could program, too. The 
spreadsheet allowed financial analysts to write their own programs to do what they used to do with pencils 
and budget sheets. Visual languages gave computer novices the ability to quickly build useful applications 
with tools on their personal computers. The World-Wide-Web (WWW) has helped make the computer more accessible 
to everyone, and in so doing provided non-threatening opportunities to do simple programming. Not surprisingly, 
the WWW helped populwiw the notion of everyone becoming a programmer. Before the advent of what­you-see-is-what-you-get 
(WYSIWYG) editors for WWW pages, people who wanted to truly experience the WWW had to create their own 
pages using HyperText Markup Language (HTML). However, W WW pages can do much more than simply present 
information; they can interface with other applications and with computers all over the world. People 
who had never programmed soon found themselves authoring simple Common Gateway Interface (CGI) scripts 
so that they could launch their favorite programs from HTML. Even those that missed the CGI experience 
now fsnd themselves using JavaScript, if for no other reason than they want to jazz up their pages with 
bells and whistles that they discovered while surtlng the Internet. I predict that this trend will continue 
and must continue. Why? Because the world cannot meet its own demand for sotlware unless we mske programming 
so easy @at everyone can do it withoutevenknowingthatthey have written a program. The technologies that 
we create today will eventually allow us to do things that currently require the services of professional 
software developers; msny of these technologies will come from the R&#38;D and experiences of the software 
reuse community. References Foulin97] Poulin, Jeffrey S., Measurin~ Sotlware Reuse: princi~les, Practices. 
and Economic Models. Addison-Wesley (ISBN 0-201-63413-9), Reading, MA, 1997. [Simon97] Simon, Kirk, and 
Karen Goodm~ The Telephone, The American Experience Series, WGBH/Boston and the Corporation for Public 
Broadcasting, 1997, http://www.pbs. orglwgbhlpagesfarnexltechnology/telep honehbprogram.htnd. ~ourdon96] 
Yourdon, Ed, Lipstick on a Pig or a Real Silver Bullet?, American Programmer, Vol. 9, No. 11, November 
1996, pp. 25-29. Interfaces, inheritance, and reuse  Andrew Watson It s often said that the term software 
engineering is an oxymoron, since building software systems isn t an engineering disciple but in reality 
somewhere between a black art and a cottage industry. A colloquial British definition of an engineer 
is Someone who can do for ten shillings what any damn fool can do for a pound , and there s a lot of 
buth to this maxim -a good engineer knows how to keep costs down, and a key technique is combining cheap, 
mass-produwd off-the-shelf components (sometimes in interesting and innovative ways) rather than designing 
expensive custom-built parts. For software construction to become a true engineering discipline, much 
higher levels of sotlware reuse must be achieved. To continue with the engineering theme, the key to 
reuse is precise interface specification. Mass-produced engineering components, be they I-beams or integrated 
circuits, are reusable because they have a well-defined inter-hce that presents a relatively simple abstraction. 
There s a lot of detailed materials science expertise encapsulated within the design of a steel RSJ; 
however, the structural engineer that uses it only needs to understand is th~ within prescribed limits, 
the beam deflects elastically under load according to simple formulae. This is the user s abstraction 
of an I-beam; understand the abstraction and you can use the beam without having to delve into the complications 
of how it really works. Cost-effective engineering hinges on creating, using and then repeatedly reusing 
components that provide usetil abstractions. Of course, when I use words like abstraction and encapsulation 
, the modem so!lware practitioner immediately thinks of object-based design and 00 languages. Objects 
certainly have a lot of desirable features -of the design technologies available today they come closest 
to providing the abstractly-defined, reusable components we need. But this isn t to say that everything 
about object technology is wonderful. Ask most programmers to name the fundamental concepts that underpin 
objects and I ll wager that inheritance will be on their list. Implementation inheritance appears to 
promote reuse by allowing the programmer to borrow much of the implementation of an object to build another 
which performs a slightly different fimction. Certainly, in the right hands inheritance can be a powerfid 
tool. Unfortunately, as was pointed out ten years ago [SNYDER87], inheritance violates encapsulation 
and breaks abstractions. In order to inherit some parts of an object s implementation and not others, 
a programmer has to understand all the subtle interactions within the object s code; in effecg he has 
to understand the complex undocumented interfaces within the object. I can write code that inherits from 
small objects 1 wrote myself, but I don t have a hope of inheriting from significant objects someone 
else has written without weeks or months of study. Implementation inheritance, which seems such a useful 
reuse technique, is also helping to keep programming in the cottage-industry era by ensuring that only 
programmers who have served their apprenticeship intimately learning a class library have any chance 
of reusing it to build error-free sotlware. The key to making software construction an engineering discipline 
rather than a huge cottage industry lies not in ad-hoc reuse techniques like inheritance, but in the 
ability to precisely and mathematicallytheinterface describeto a component.I beamsareusefulreuse components 
because their deflection under load obeys mathematical formulae. Logic gates have interfaces expressible 
in Boolean logic. However, today in software we have only the rudiments of formalisms for describing 
our software components. Interface Definition Languages, such as OMG IDL, rigorously describe the low-level 
mechanics of an object s interface, so that our software tools can automatically check their compatibility 
at that level. However, the behavior of the components at higher levels is usually described informally, 
in natural language that s notoriously prone to misinterpretation and, worst of all, can t be processed 
by design tools. This data about objects is sometimes referred to a meta-data , and semi-mystical significance 
is attached to representing it in the same object notations that it s being used to describe, but this 
is a side issue. Until we can rigorously define the interfaces to and behavior of objects using notations 
that can be mechanically processed and analyzed, software reuse on an engineering scale will remain beyond 
our grasp. Reference [SNYDER87] Alan Snyder, Inheritance and the development of encapsulated software 
components in Research Directions in Object-oriented Programming, 1987   
			
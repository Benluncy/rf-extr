
 ROAMing Terrain: Real-time Optimally Adapting Meshes Mark Duchaineau**+ Murray Wolinsky* David E. Sigeti 
Mark C. Miller+ Charles Aldrich* Mark B. Mineev-Weinstein* Los Alamos National Laboratory* . Lawrence 
Livermore National Laboratory+ Abstract Terrain visualization is a difficult problem for applications 
requiring accurate images of large datasets at high frame rates, suchas flight simulation and ground-based 
aircraft testing using synthetic sensor stimulation. On current graphics hardware, the problem is to 
main- tain dynamic, view-dependent triangle meshes and texture maps that produce good images at the required 
frame rate. We, present an algorithm for constructing triangle meshes that optimizes flexible view-dependent 
error metrics, produces guaranteed error bounds, achieves specified triangle counts directly, and uses 
frame-to-frame coherence to operate at high frame rates for thousands of triangles per frame. Our method, 
dubbed Real-time Optimally Adapting Meshes (ROAM), Cses two priority queues to drive split and, pierge 
op- erations that maintain continuous triangulations built from pre- processed bintree triangles. We 
introduce two additional perfor- mance opdmizations: incremental triangle stripping and priority- computation 
deferral lists. ROAM execution time is proportionate IO the number of triangle changes per frame, which 
is typically a few percent of (he output mesh size, hence ROAM performance is insensitive 10 the resolution 
and extent of the input terrain. Dynamic terrain and simple vertex morphing are supported. CR Categories 
and Subject Descriptors: 1.3.3 [Computer Graph- ics]: Piaurellmage Generation - Viewing Algorithms;, 
1.3.5 [Com- puter Graphics]: Computational Geometry and Object Modeling -Gcome&#38;ic Algorithms, Object 
Hierarchies: I.3.7 [Computer Graph- ics]: Three-Dimensional Graphics and Realism - Virtual Reality. Additional 
Keywords: tiangle bintree, view-dependent mesh, frame-to-frame coherence, greedy algorithms. 1 INTRODUCTION 
A complete system to display views of large da&#38;sets at high frame rates consists of components 10 
manage disk paging of geome- try and texture, l$vel-of-detail (LOD) selection for texture blocks, LOD 
for triangle geometry, culling to the view frustum, and triangle stripping. This paper focuses on the 
last rhree of these components, whichdeal with in-memory geometry management. During interactive visualizations, 
many types of geometric data compe[e for limited polygon budgets. Terrain remains one of the mostchallenging 
types because it is not naturally decomposed into parts whose complexity can be adjusted independently, 
and because the qualities required of a triangulation are view dependent. Clas-sic geometry LOD optimization 
algorithms, such. as those of Clark [I] and Funkhouser and S6quin (71, are not immediately applica- ble 
to terrain becausethey require independeptly ddjustable parts. Traditional triangulation optimizations 
[14,2, 15, for example], do not apply direct!y to terrain visualization because they do not ad- . {mumy,sigcti,cha,mariner) 
@lanl.gov. Lo? Alamos, NM ~{duchaincaul,miller86}@Ilnl.gov, Livermore, CA O-81 86-8262-O/97 $10.00 Copyright 
1997 IEEE. mit flexible view-dependent error objectives, and they are much too slow to be used for each 
frame. All of the existing algorithms that can interactively perform view-dependent, locally-adaptiv? 
terrain meshing [12, I I, 17, 19, lo], including ours, rely on a pre-defined multiresolution terrain 
representation that is used to build the adaptive triangle mesh for a frame. An example frame generated 
by the ROAM implemen- tation is depicted in Figure 1, both with and without visible mesh edges. Figure 
2 shows a birds-eye view of the domain mesh. The mesh is typical for ROAM: neighborhoods that are flat 
or distant are triangulared more coarsely than close or rough neighborhoods. Figure 1: Example of ROAM 
terrain. Figure 2: Triangulation for example frame, with eye looking right. Darkregion is outsideview 
frustum, light region is inside, and grey overlaps boundary. .I ROAM consists of a preprocessing component 
and several run- time components. The preprocessing component produces nested, view-independent error 
bounds bottom-up for a triangle bintree. At runtime, four phases of computation are performed per frame: 
1. recursive, incremental update to view-frustum culling 2. priority update only for output triangles 
that can potentially be split/merged in phase 3 3. triangulation update using greedy split and merge 
steps driven by two priority queues (for splits and merges, respectively) 4. as-needed updates for triangle 
strips affected by the culling changes from phase 1, and the splits/merges from phase 3  We evaluate 
our method with respect to twelve criteria of general application as follows: 1. Time required to achieve 
i given triangle count: Our implementation can maintain an optimized mesh containing thousands of triangles 
at 30 frames per second for high-speed, low-altitude flights over rough terrain. The algorithm s run- 
ning time is proportionate to the number of triangle changes per frame, which is typically a few percent 
of the total mesh size. Hence ROAM performance is insensitive to terrain database extent and resolution 
(with the caveat that we must have all the data in memory in the current implementation). 2. Flexibility 
in choosing view-dependent error metrics:  ROAM uses maximum geometric distortion in screen space as 
a base metic and queue priority value. This metric can be enhanced in many ways: ensuring correct visibility 
along specified lines of site, providing correct terrain positions un-der objects, and eliminating back-facing 
detail are examples. 3. Mesh representations (both pre-defined and run-time selected): Our method uses 
a triangle bintree for pre-computation, and builds continuous adaptive meshes by in- cremental, finegrained 
split and merge steps. The triangles are always a right-isosceles shape, and therefore avoid the nu- 
merical problems of thin, slivery triangles. 4. Simplicity of algorithms: ROAM is simple to understand 
and implement because it is centered on split and merge oper- ations of bintree triangles whose structure 
naturally avoids the complex case proliferation and legitimacy rules for selectively refining and coarsening 
within irregular or even quadtree-structured multiresolution spaces, and no special efforts are required 
to avoid discontinuities (cracks) and thin triangles. The greedy priority-queue technique that drives 
the splits and merges provides a simple mechanism for incorporating an ex- tensible set of error-metric 
enhancements. 5. Quality of mesh at a given triangle count: Our algorithm  produces optimal meshes 
in the sense of minimizing the max- imum error bound for monotonicbounds (bounds that don t get larger 
after a split operation). Of course this optimum is achieved over our particular choice of mesh space, 
and larger or better spaces of triangle meshes certainly exist. Our results in actual tests are qualitatively 
excellent. 6. Direct control of triangle counts: ROAM produces meshes with a specified triangle count 
directly. Algorithms that ad- mit only error tolerances can only indirectly control triangle counts by 
hunting for the corresponding error threshold, a pro- cess that is either slow or unreliable. ROAM can 
operate to achieve specified tolerances, but trianglecount specification is preferable for many applications. 
 7. Strict frame rates: ROAM can progressively optimize from frame to frame and stop when the frame time 
is about to ox- pire (although typically only a fraction of the frame time is required). Our motivating 
application, aircraft sensor stimu- lation, requires a strict frame rate governed by the equipment under 
test. In conjunction with processor locking or real-time  operating systems on multi-processor graphics 
systems, our implementation provides a strict frame rate at the highest tri- angle counts that the graphics 
hardware can handle reliably. 8. Guaranteed error bounds: ROAM produces guaranteed bounds on geometric 
screen-space distortions, These bounds are obtained locally by a fast conversion from preprocessed world-space 
bounds to view-dependent screen-space bounds, and globally by the greedy nature of the optimization algo- 
rithm. 9. Memory requirements: We distinguish between preprocess data size and runtime size. Our preprocess 
size is equal to the number of raw, finest-level height samples plus a sin- gle thickness value per bintree 
triangle. The runtimc data structures take up space proportionate to the output mesh size,  I / which 
is minuscule compared to the preprocess data size. 10. Dynamic terrain: Since our preprocessing is fast 
and local- ized, the preprocessed data can be updated quickly when tho terrain is changed by mud slides, 
explosions, etc. 11. Reduced popping : ROAM s use of a screen-distortion mktric and its tendency to make,very 
few mesh changes per frtie naturally reduces disturbing temporal artifacts (pops)~ In some cases it is 
desirable to reduce pops further by verkt +qh+zg, which is easily incorporated in ROAM, 12. General input 
meshes: Although our motivating application and implementation focuses on terrain (in the form of a height 
field),: ROAM s mesh structure applies to manifolds of arbi- trary genus with boundary. A drawback of 
the bintree meshes we use, and more generally any subdivision surfaces, is that irregular input meshes 
must be approximated, albeit as closely 9 pnelikes [4]. ,In addition to these general criteria, ROAM 
was influenced by the specialized requirements of our motivating application, syn-thetic sensor stimulation 
for aircraft undergoing ground-based test- ing with hardware and human controllers in the loop. In this 
setting it is critical to query a nmtime terrain data server for line-of-site (LOS) visibility tests, 
object positions, and so on in addition ta the texture and triangle-mesh queries used fqr,display to 
multiple sen- sors with differing viewpoints and requirements for accuracy and frame rate. Because of 
the approximations made to achieve high framerates, theissues of consistency and correctness for the 
various queries becomes paramount. In earlier approaches, LOS and other queries are made with respect 
to a single current terrain approxima- tion. This at least gives consistency to the various query responses, 
but requires a single lowest common denominate< triangle mesh suitable for all views and sensor frame 
rates, thus degrading quality to unacceptable levels. The philosophy in ROAM is to give re- sponses to 
LOS and position queries that are correct with respect to the finest-level input data, and constrain 
each of the view-dependent meshes to preserve the selected LOS visibilities and positions, The ROAM architecture 
efficiently supports this philosophyi and thus ensures consistency through correctness.  2 RELATED WORK 
A general treatment of multiresolution LOD control is presented by Heckbert and Garland [8], while more 
specific surveys and refef- ences can be found in [3, 11, 191. Triangle stripping cost models and techniques 
are presented by Evans et al. [5]. Greedy algorithms have been applied to terrain triangulation in the 
non-realtime, non-view-dependent setting [6, 15, for example]. A general treatment of subdivisibh &#38;faces 
and conversions from irregular meshes is -given by Eck &#38; al. [4], while a specific application of 
wavdet anal-ysis to terrain LOD is given by Staadt et al. [16]. In the remainder of this section we give 
more detailed overviews of recent published work most closely related to ROAM. -, I Miller [ 121 uses 
a quadtree to preprocess a height field defined on a uniform grid, In a pre-processing phase, vertices 
at each quadtree level are computed using an approximate least-squares fit to the level below. For each 
frame at nm time, a priority queue drives quadtree refinement top-down from the root, thus allowing spec- 
ified triangle counts to be achieved directly. The priority for a quadtree element is a heuristic involving 
view-independent (error in surface) and view-dependent (screen-area coverage) components aimed at minimizing 
the squared error in output image pixel inten- sities, No advantage is made of frame-to-frame coherence, 
and only one type of error metric is developed. A special effort is made to en- sure continuous triangulations, 
but T-vertices are allowed, where a vertex exists on only one side of an edge. Methods for overlaying 
of point, linear and areal features are also discussed. Lindstrom et al, [ll] choose the same space of 
continuous triangle-bintree meshes as we do. They do not recognize the sim- ple bintree structure nor 
the split and merge operations that we present, and so must take special care to maintain mesh continu- 
ity. They obtain high frame rates for large output meshes using a bottom-up vertex-reduction methodology 
enhanced by an elegant block-LOD-reduction algorithm. The block-LOD updates are in- cremental, taking 
advantage of frame-to-frame and object-space co- herence. However, the fine-grained vertex deletion is 
performed bottom-up, which tends to limit performance compared to our fine- grained incremental mesh 
updates. Also, although they use the same base metric of geometric screen-space distortion, the block- 
based optimizations appear to make it difficult to enhance this met- ric. They provide no guaranteed 
error bounds (only level-to-level displacements are considered in the fine-grained LOD reduction). A 
tolerance parameter is used to control the aIgorithm, but the Iack of guaranteed bounds precludes guaranteed 
success in attaining the requested accuracy. A triangle-count parameter is not considered, and would 
be difficult to incorporate with their block-LOD algo- rithm (this precludes support for strict frame 
rates with maximum triangle counts). Memory requirements are similar to ROAM, and dynamic terrain is 
supported. Vertex motphing is not supported, and only height maps are considered. A recursive triangle-stripping 
method is described, but requires corner-turning and does not take advantage of frame-to-frame coherence. 
Willis et al, [17] describe a hierarchical triangulated-irregular- network (TIN) data structure with 
near/far annotations for vertex morphing, along with a queue-driven top-down refinement proce- dure for 
building the triangle mesh for a frame. No automatic pro- cedure is given to build the precomputed TIN 
hierarchies and mor- phing annotations. No consideration is given to controlling errors or triangle counts. 
Specific effort is taken to avoid T-vertices. No advantage is taken of frame-to-frame coherence. Memory 
require ments are higher per preprocessed multiresolution element than in ROAM. The method applies to 
generaI base (coarsest-Ievel) triangle meshes. The vertex-morphing capabilities are powerful and unique 
* (we consider only simple split/merge animations). Xia et al. and Hoppe [19, 10, 181 give similar methods 
for in- teractive, fine-grained LOD control of genera1 TIN input meshes based on view-dependent refinement 
of preprocessed progressive meslr representations [9]. Both algorithms allow flexible view- dependent 
error metrics, and have demonstrated backface detail re- duction based on nested Gauss-map normal bounds. 
Xia et al. use a base metric derived from the edge-collapse operations inherent to progressive meshes, 
which gives only a loose heuristic estimate of geometric or parametric screen-space distortions. Hoppe 
gives a metric that separates non-directional and normal-direction errors, and mentions the possibility 
of modifying this to measure errors in approximating non-linear texture-coordinate mappings. Progres- 
sive meshes are most naturally refined by undoing the edge-collapse operations in exactly the reverse 
order of the preprocess collapse sequence. Complex legitimacy rules are required to allow different refinement 
orders. Only tolerance parameters are given to the view- dependent refinement. In Xia er al., special 
consideration is taken to avoid thin triangles. Hoppe uses a feedback mechanism to per- form rough frame-rate 
regulation. Nested bounds are provided by analyzing neighborhoods defined by the binary vertex trees 
formed during the preprocessing. Although some consideration is given to frame-to-frame coherence, execution 
times are still proportional to the full output mesh size. As a performance enhancement, Hoppe considers 
traversing the active vertices once over the course of mul- tiple frames, but indicates that this complicates 
frame-rate regula- tion. Progressivemesh preprocessing is organized as a global opti- mization process, 
and thus is too slow to support dynamic terrain. Animation of the edge collapse/expand operations reduces 
popping similar to vertex morphing, but introduces degenerate thin triangles temporarily in the process. 
 3 OVERVIEW In the remainder of this paper we describe the ROAM mesh rep- resentation, optimization algorithm, 
error metrics, performance en- hancements and results. In this section, we give an overview of what follows. 
More fundamental than the ROAM algorithm itself is the dy- namic mesh representation based on triangle 
bintrees. In Section 4 we define triangle bintrees and describe the split and merge opera- tions that 
are used to maintain continuous meshes while adding and removing one vertex at a time. Animation of the 
splits and merges is presented as a simple method for obtaining temporal continuity. Applicability to 
surfaces with general topology is considered. Given these fundamentals of the mesh representation, Section 
5 goes on to describe the dual-queue incremental optimization algo- rithm. A simplified version of the 
algorithm is given first that uses only a single split priority queue. We explain why this top-down algorithm 
produces optimal bintree-based triangulations for mono- tonic priorities. A second merge priority queue 
is added to enable incremental optimizations for time-varying priorities. ROAMuses view-independent, 
preprocessed error bounds to fa- cilitate the computation of view-dependent error bounds. In Sec- tion 
6, the metrics, preprocessing and view-dependent conversions are given. In world space, we rely on nested 
bounds using a single number per bintree triangle to define a pie-wedge bound shape. These wedgies are 
readily used to compute per-triangle bounds on screen-space distortionsin the projected up direction. 
We also use wedgies to facilitate computations like view-frustum intersec- tions and LOS tests. We consider 
various enhancements to the basic screen-space geometric distortion metric. For ROAM to operate at high 
frame rates, several performance enhancements are needed. These are described in Section 7: incre- mental 
view-frustum culling, incremental T-stripping, deferring pri- ority recomputations, and progressive optimization. 
Results from experiments with our implementation are given in Section 8. These show the effect of the 
performance enhancements as well as the overall behavior of the algorithm. 4 MESH REPRESENTATION 4.1 
Triangle Bintree Just as the square-shaped quacitree has a triangle-quadtree counter- part, the familiar 
rectangle-shaped bintree [13] has a little-known triangle-shaped counterpart. Figure 3 shows the first 
few levels of a triangle bintree. The root triangle, T = (o. ,210, VI), is defined to be a right-isosceles 
triangle at the coarsest levelof subdivision, L = 0. At the next-finest level, e = 1, the children of 
the root are defined by splitting the root along an edge formed from its apex vertex V. to the midpoint 
uC of its base edge ( ~0, VI). The left child of T is TO = (vC, v,, VO), while the right child of T is 
Ti = (z)~,v~,zI~). The rest of the triangle bintree is defined by recursively repeating this splitting 
process. vo Vl Figure 3: Levels O-5 of a triangle bintree.  4.2 Dynamic Continuous Triangulations Meshes 
in world space are formed by assigning world-space posi- tions W(V) to each bintree vertex. A set of 
bintree triangles forms a continuous mesh when any two triangles either overlap nowhere, at a common 
vertex, or at a common edge. We refer to such con- tinuous meshes as bintree triutzgukztiotzs or simply 
triungulutions. Figure 4 shows a typical neighborhood about a triangle T within a triangulation. We define 
TB to be the base neighbor sharing base edge (ve, vi), TL to be the left neighborsharing left edge (vo, 
va), and TR to be the right neighbor sharing right edge (vi,v,). A key fact about bmtme triangulations 
is that neighbors are either from the same bintree level f2 as T, or from the next finer level e + 1 
for left and right neighbors, or from the next coarser level e -1 for base neighbors. All of these possible 
relationships are depicted amongst the triangles in Figure 4. When T and TB are both from the same level 
e, we refer to the pair (T, TB) as a diamond.A simple splitoperation and its inverse, nzerge,are depicted 
in Figure 4 for a triangulation containing a di- amond. Split replaces triangle T with its children (Tc,Ti), 
and triangle Tn by its children (TBo,Tnl). This split operation intro- duces one new vertex v, at the 
diamond center, resulting in a new, continuous triangulation. If triangle T does not have a base neigh- 
bor Tn, only T is split into its children. Merging can be applied to diamond (T, TB) when the children 
of T and Tn (if Tn exists) are all in the triangulation. In this case, we say (T, TB) is a mergeable 
diunzondfor the triangulation. An important fact about the split and merge operations is that any triangulation 
may be obtained from any other triangulation by a sequence of splits and merges. Splits and merges can 
be animated using vertex morphing to provide a simple form of temporal continuity. For a time interval 
t E [O, 11, consider the split of diamond (T, TB) shown in Figure 4. Instead of moving vC immediately 
to its new position w, = w(v,), let it move linearly over time from the unsplit base-edge midpoint ranmb; 
$~;j~i;~>J).;;Ctl = (1 - t)wm + twc. Me%- Figure 4: Split and merge operations on a bintree triangulatian, 
A typical neighborhood is shown for triangle T on the left. A triangle T in a triangulation cannot be 
split immediately when its base neighbor TB is from a coarser level. To force T to be split, TB must 
be forced to split first, which may require further splits in a recursive sequence. A case requiring 
a total of four splits Is depicted in Figure 5. Such forced splits are needed for the opti- mization 
algorithm in Section 5. Figure 5: Forced splitting of triangle T. .-Base meshes of more than one triangle 
can be used to represent manifold surfaces of arbitrary genus with boundary If tho base mesh can be tiled 
with diamonds, then the split and merge opora- tions may be used freely as in the case with a single 
root triangle. For terrain, a typical base mesh is a single diamond.  5 DUAL-QUEUE OPTIMIZATION The 
split and merge operations provide a flexible framework for making fine-grained updates to a triangulation. 
No special efforts are needed to avoid cracks or T-vertices. This section presents a greedy algorithm 
that will drive the split and merge process. The idea is simple: keep priorities for every triangle in 
the triangulation, starting with the base triangulation, and repeatedly do a forced split of the highest-priority 
triangle. As shown next, this process crc- ates a sequence of triangulations that minimize the maximum 
pri- ority (which is typically an error bound) at every step. The only requirement to ensure this optimality 
is that priorities should be monotonic,meaning a child s priority is not larger than its parent s, Adding 
a second priority queue-for mergeable diamonds-allows the greedy algorithm to start from a previous optimal 
triangulation when the priorities have changed, and thus take advantage of framc- to-frame coherence. 
 5.1 &#38;lit Queue . Suppose that every bintree triangle T is given a monotonic priority p(T) E [0, 
1). As triangulation T is built top-down, we shall main- tain a priority queue GJs containing all of 
the current triangles in T. The top-down greedy algorithm is the following: Let T = the base triangulation. 
For all T E T, insert T into G!,. While T is too small or inaccurate { Identify highest-priority T in 
G!,. Force-split T. Update split queue as follows: { Remove T and other split triangles from QS. Add 
any new triangles in T to Qs. 1 1 This greedy algorithm produces optimal triangulations at every step. 
Consider any other triangulation T that has a Iower maxi- mum priority than T. Clearly T must contain 
only descender&#38; of all the triangles that were forced to be split while building T. Be-cause the 
force-split operation makes the minimum necessary re- finements to preserve continuity, T can not contain 
any ancestors to the triangles in T. Finally, because T has a lower priority, it must contain only descendents 
of at least one triangle in T. There- fore, T has a higher triangle count than T and so T is optimal. 
The total number of splits and merges performed by the top-down algorithm is proportionate to N, the 
number of triangles in the final triangulation T. 5.2 Merge Queue Now suppose that we are given time-varying 
priorities pf (T) E [O, l] for frames f E (0, 1, . . . ), and the problem is to build opti- mal triangulations 
(TO, TI, . . .). If these priorities are changing slowly and smoothly, then the optimal triangulations 
for any two consecutive frames will tend to be similar to one another. In this case, performance will 
be enhanced if we use triangulation Tr-1 as a starting point to build triangulation Tr. This is done 
by main- taining a second priority queue, G&#38;,,, that contains all the mergeable diamonds for the 
current triangulation. The priority for a mergeable diamond (T, TB) is set to the maximum of its two 
triangles prior- ities, max{pf (T) , pf (Tn )}. The incremental greedy algorithm is the following: Iff=O{ 
Let T = the base triangulation. Clear Qs, Qm. Compute priorities for T s triangles and diamonds, then 
insert into Qs and Q,,,, respectively. } otherwise { Continue processing T = Tr-1 .a Update priorities 
for all elements of Qs, Qm. 1 While T is not the target size/accuracy, or the maximum split priority 
is greater than the minimum merge priority { If T is too large or accurate { Identify lowest-priority 
(T, TB) in G?,. Merge (T, TB ) . Update queues as follows: ( Remove all merged children from Qs. Add 
merge parents T, TB to Qs . Remove (T, TB) from &#38;. Add all newly-mergeable diamonds to &#38;,. 1 
) otherwise { Identify highest-priority T in &#38;, . Force-split T. Update-queues as follows: { Remove 
T and other split triangles from Qs. Add any new triangIes in T to Qs . Remove from Q,,, any diamonds 
whose chil- dren were split. Add all newly-mergeable diamonds to 8,. I   j : I Set Tr = T. The incremental 
greedy algorithm produces an optimal mesh Tf that has the same priority as if the top-down algorithm 
had been per- formed on the base mesh. The incremental algorithm does not gen- erally produce optimal 
meshes during the intermediate steps (for example, Tf-1 is usually not optimal for frame f), but it does 
reach optimality using the smallest possible number of split/merge oper- ations applied to Tr-1. The 
total number of splits and merges per- formed is proportionate to AN, defined as the number of triangles 
from Tr and Tr-1 that are not in common. In the worst case, AN can be Nf-r -I- Nf. Situations like this 
are easily detected: there will be a large number of triangles and diamonds whose priorities are between 
the minimum merge priority and the maximum split priority. The remedy in this case is to fall back on 
the top-down al- gorithm, which can be accomplished by initializing T, &#38;?, and Qrn asthoughf=O. 6 
ERROR METRICS This section describes the various error metrics and bounds that are used to compute queue 
priorities. In the remainder of this pa- per we restrict our aftention to height maps. Specifically, 
we as- sume that the vertex-to-world-space maonina w(v) is of the form W(V) = (v,, oy, Z(V)), where (LZ, 
vy) c;k the domain coordinates of the vertex 21. and z(v) is the height at v. We denote the affine height 
map for a binge; triangle T to be ZT(Z,~). We also as- sume that camera coordinate systems and perspective 
transforms are given for each frame. We will continue to use the triangle- neighborhood notation from 
Section 4. 6.1 Nested World-Space Bounds For height-map triangulations, a convenient bound per triangle 
T is a wedgie, defined as the volume of world space containing points (z,y,z) such that (5,~) E T and 
1.~ -.zT(z,~)~ 5 eT for some wedgie thicknesseT > 0. We refer to the line segment from (5, y, Z - eT) 
to (5, y, Z + eT) as the fhichess segme?Zt for 2). Nested wedgie bounds are built bottom-up, starting 
with eT = 0 for all T at finest level L,,. The wedgie thickness eT for a par- ent triangle is defined 
in terms of its children s wedgie thicknesses, eTO and eT,. The tightest nested wedgie bounds are given 
by the formula eT = max(eTo, eTl) + Iz(Vd -ZT(vc>l (1) where ZT( uc) = (z(va) -I- z(vr))/g. Note that 
this computation is fast and localized, which facilitates dynamic terrain. A univariate example of nested 
wedgies is illustrated in Figure 6, along with the chain of wedgies that depend on a particular vertex 
v. 6.2 Geometric Screen Distortion With textured triangulations it is natural to separate geometric 
screen-space distortions from coIor distortions. We assume in this paper that colors for a surface point 
are accurately represented by Figure 6: Nested wedgies for 1-D domain with dependents of v. the texture. 
The remaining image errors can be represented.as purely geometric distortions: the distance between where 
each sur- face point should be in screen space and where the triangulation places the point. Over the 
whole image we measure the maximum of these pointwise distortions. This is the base metric for ROAM. 
Formally, let s(v) be the correct screen-space position for a do- main point v, and ST(v) be the approximate 
position from triangu- lation T. We define the pointwise geometric distortion at v to be dist(v) = Iis 
-ST(v)1&#38;. For the whole image, we define the maximum distortion to be dist,, = rnaxuov dist(v) where 
V is the set of domain points v whose world-space positions w(v) are within the view frustum. In practice 
an upper bound is computed for the maximum distor- tion. For each triangleT in the triangulation, a local 
upper bound on distortion is obtained by projecting T s wedgie into screen space, as shown in Figure 
7. The bound is defined as the maximum length of the projected thickness segments over all v E T. These 
lo- cal bounds are monotonic, and will be used to form queue prior- ities. The maximum split-queue priority 
provides an upper bound on maximum distortion. If a wedgie extends behind the near clip- ping plane, 
the triangle s priority is set to an artificial maximum value and the distortion-bound computation is 
skipped. Figure 7: Distortion bound by projecting wedgie to screen space. Because of the peculiarities.of 
the perspective transform, the maximum projected wedgie thickness does not always occur at one of the 
triangle vertices. This leads to the following upper-bound computation. Let (p, q, r) be the camera-space 
coordinates of a point W(V) without perspective, and without loss of generality as-sume the perspective 
projection is of the form s = (p/r, q/r). The screen-space distortion at v E T is bounded by projecting 
the thick- ness segment at v. Let (a, b,c) be the camera-space vector corre- sponding to world-space 
thickness vector (0, 0, eT). The screen- space distortion at v is bounded by ,b P +a P-U q+b .I d%(v)=Ilr+c--,--7 
(2) r-c r-i-c This can be rewritten as d%(v) = -&#38; ((or -~p)~ + (br - a#) (3) It is straightforward 
to show that the minimum of r2 -c2 and the maximum of (ar -~p)~ + (br - cq)2 occur at the comer vertices 
of T (although not generally the same comer). An upper bound on d%(v) can thus be obtained by substituting 
these minimum and maximum values into Equation 3.  6.3 Line-of-site Correction 7 So far, the queue 
priority was derived solely from the screen--distortion bound for a triangle T. This priority can be 
modified to ensure that selected lines of site are correctly occluded or not, A simple method to do this 
is to change the priorities for any trian- gles whose wedgies intersect the LOS. By setting these priorities 
tq an artificial maximum value, splits will be made preferentially in a manner sufficient to ensure correct 
visibility along the LOS, This method tends to promote more triangle splits than necessary, although 
this excess is typically small in practice compared to the overall triangle count. An example of LOS 
correction is given in Section 8.1. 6.4 Other Metrics We briefly mention other possible metric/priority 
variations that are compatible with ROAM: Ba&#38;face detail reduction: Using nested Gauss-map normal 
bounds (as in [18, lo]), priorities can be set to minimum for triangles whose subtree of triangles are 
all back-facing. Normal distortions: For specular highlights determined by normal vectors interpolated 
from the vertices, priority should be given to triangles having large normal distortions where the highlights 
occur. Texture-coordinate distortion: For curved mappings from SUP face domain to texture coordinates, 
priority should be added proportionate to the size of the screen-space position distor- tions associated 
with the texture-coordinate approximation. Silhouette edges: Specific emphasis can be placed on triangles 
whose normal bounds indicate potential back-face to front- face transitions. View frustum: Wedgies outside 
the six clipping planes can be given minimum priority, as discussed in Section 7.1. Atmospheric obscurance: 
Wedgie priorities can be decreased when fog reduces visibility. Object positioning: To correctly position 
objects on terrain, the priorities of triangles under each object can be artificially in- creased. Clearly 
this list can be extended to suit a variety of applications.  7 PERFORMANCE ENHANCEMENTS In this section 
we describe enhancements that enable the ROAM algorithm to operate athigh frame rates for triangulations 
consisting of thousands of triangles. The first three optimizations decrease the respective computation 
times for their subtasks by more than a factor of ten. The fourth ensures strict frame rates. 7.1 View-Frustum 
Culling We assume the view frustum is defined as the intersection of six halfspaces. Each triangle in 
the bintree (down to the current tri- angulation) is given an IN flag for each of the six halfspaces, 
and an overall label of OUT, ALL-IN or DONT-KNOW, defined as fol- lows: IN is set when the wedgie is 
entirely inside the halfspace, OUT is given when the wedgie is entirely outside at least one half- space, 
ALL-IN is given if all IN flags are set, and DON T-KNOW is given if not OUT or ALL-IN. Updating these 
flags and labels from frame-to-frame is effi- ciently handled by a recursive bintree traversal. If a 
triangle T was labeled OUT or ALL-IN for the previous frame, and.mese labels are correct for the current 
frame, then the subtree foiT does not need to be updated and recursion terminates. Otherwise, T inher- 
its its IN flags from its parent and rechecks its wedgie against the halfspaces not marked IN, setting 
new IN flags if appropriate. If the wedgie is entirely outside any of these halfspaces, T and all its 
children are marked OUT. If all IN flags are set, T and all its chil- dren are marked ALL-IN. Otherwise 
T is marked DONT-KNOW and recursion continues to its children. 7.2 Incremental T-Stripping Significant 
performance gains result from organizing triangles into strips,although optimum stripping is a difficult 
problem [5]. We consider only non-generalized strips (no vertex swapping ). We use a simple, sub-optimal, 
incremental approach that yields average strip lengths of around four to five triangles~ As triangles 
are split, merged or change view-culling status, minimal re-linking of strips is performed. Deleting 
a triangle from a strip causes the strip to be deleted (for a singleton strip), shortened on the end, 
or split in two. New triangles are first inserted as singleton strips, which we subsequently attempt 
to glue to each of the neighboring strip ends. 7.3 Deferring Priority Recomputation The screen-distortion 
priorities of the triangles change as the view- ing position changes, typically in a slow and smooth 
manner. Re calculating priorities of all triangles for every frame is too costly. Instead, priorities 
are recomputed only when they potentially affect a split/merge decision. Given a velocity bound on the 
viewpoint, bounds can be obtained for screen-distortion priorities over time (i.e. a time-dependent bound). 
Also, the crossover priority (defined as the maximum split- queue priority when the incremental split/merge 
process is com- plete) changes slowly from frame to frame (typically around 1% change). Recomputation 
of a triangle can safely be deferred until its priority bound overlaps the crossover priority. A deferral 
list is kept for each of the next few dozen frames. Only the triangles on the current frame s deferral 
list must have priorities recomputed. If time allows, additional triangles may be recomputed in subse- 
quent deferral lists. After recomputation, the triangle is placed on the deferral list farthest ahead 
that will provide safe recomputation scheduling. 7.4 Progressive Optimization To ensure strict frame 
rates, triangulation optimization should stop when the alloted frame time is about to expire. The ROAM 
al- gorithm readily supports this because optimization processing and stripping updates occur one split/merge 
at a time. Of course, early termination yields non-optimal triangulations. However, because the split/merge 
steps are performed in decreasing order of impor- tance, the partial work done is optimal in the sense 
that we have gotten as close to true optimal as time permits while maintaining the specified triangle 
count. We refer to this stepwise processing as pro-gressive optimization. Priority recomputations can 
also be limited based on time available. The only phase of ROAM not amenable to progressive completion 
is view-frustum culling, which fortunately requires only a small fraction of the frame time and is completed 
before priority recomputation and mesh optimization.  8 RESULTS Performance figures were measured on 
an Indigo2 Silicon Graphics workstation with Maximum Impact graphics hardware and a single RlOOOOprocessor. 
These figures were obtained simulating a fighter aircraft in terrain avoidance mode ffying at high speed 
over very hilly terrain . With all incremental features of the algorithm turned on and 3000 triangles 
rendered the total time per frame is approx- imately 30 milliseconds. Of this, 5 milliseconds is spent 
doing the view-frustum culling, 5 milliseconds calculating the queue priori- ties, 5 milliseconds splitting/merging 
the triangles in the mesh and 15 milliseconds outputting the triangle strips. Turning off thepriorityrecomputation 
deferral increases the time calculating the queue priorities to about 43 milliseconds resulting in a 
total frame time of 68 milliseconds. Turning off incremental strip- ping further increases the frame 
time to 140 milliseconds. Finally, turning off incremental split/merge optimization increases the time 
to 210 milliseconds. On a single RlOOOO processor Silicon Graphics Onyx with an Infinite Reality graphics 
board, performance improves so that 6000 triangles can be rendered at 30 frames per second. The subjective 
quality of the terrain geometry is very good. In a high-speed terrain- following scenario over rough 
terrain with 3000 terrain triangles in the mesh, silhouettes appear realistically complex and stable 
and there are virtually no popping artifacts. In a similar flight over less rough but still mountainous 
terrain 1500 triangles suffice to elim- inate perceptible popping. Since the system is capable of produc- 
ing meshes with 6000 triangles or more at 30 frames per second, ROAM appears to completely eliminate 
perceptible popping arti- facts for even the most stringent flight regimes. To understand this qualitative 
assessment better, we measured pop sizes and average number of splits and merges for the same high-speed, 
Iow-altitude loop over very rough terrain. A histogram of pop sizes in pixels (for a 1000 x 1000 image 
with 3000 triangles per frame), is shown in Figure 8. On average, only 43.2 splits and merges are performed 
per frame: In other words, less than 3% of the triangles change, and these few, scattered pops almost 
all measure under 1.5mm on a typical 21 inch workstation monitor. 1 2 3 4 5 6 7 8 9 10 Figure 8: Histogram 
showing relative number of pops versus pop size (in pixels) totaled over the full test flight. t Specifically, 
we use the USGS l-degree DEM data (90 meter post spac- ing) for Northern New Mexico. we test on a circular 
flight 300 meters above the Jemez mountains, with trajectory smoothing, and camera facing in the dir&#38;ion 
of flight. 8.1 Line-of-site Example An example of LOS visibility correction is shown in Figure 9. In 
this example, 8 triangles were stolen from the surrounding ter- rain to provide the correct occlusion 
along the line of site to the centermost box. Figure 9: Left side is before LOS correction, right is 
after.  9 CONCLUSION We have presented ROAM, an algorithm for optimizing uiangula- tions given view-dependent 
error metrics. The method has been im- plemented and provides high-quality triangulations with thousands 
of triangles at hi&#38; frame rates. A novel dual-queue incremen- tal optimization process was combined 
with fast, localized prepro- cessing and several runtime performance enhancements, including incremental 
view-frustum culling, incremental stripping, priority- computation deferral and progressive optimization. 
Critical future issues include management of geometry- and texture-loading from disk, and optimization 
of texture-block LOD.  Acknowledgments This work was performed on U.S. Department of Energy Contract 
W7405-ENG-36, funded jointly by the U.S. Navy and Air Force. We thank James Reus for his assistance in 
the early stages of this work. We also thank our sponsors, who have provided substantial input and feedback 
during these investigations: in particular, we thank Kevin Hannon, Frank Griffo, Ted Wilson, Lenart Clark, 
Don Jackson, Dr. Shah Mahmood, David Purdue, Tom Joyner, Pamela Stewart and David Blake from the Air 
Combat Environment Test and Evaluation Facility at the Naval Air Warfare Center, Patuxent, River, MD; 
and Keem Thiem and Dr. John Fong from the Elcc- tronic Combat Integrated Test Program at the Air Force 
Flight Test Center, Edwards Air Force Base, CA. We also thank Kenneth Lee, Robert Webster, Ronald Pistone, 
Lynn Cline and Fatima Woody at Los Alamos National Laboratory for their valuable assistance. Fi- nally 
we thank the staffs of the Advanced Computing Laboratory at Los Alamos National Laboratory and the Visualization 
Labora- tory at Lawrence Livermore National Laboratory for sharing their expertise and for the generous 
use of their equipment.  References [l] James H. Clark. Hierarchical geometric models for visible surface 
algorithms. CACM,19(10):547-554, October 1976. [2] Jonathan Cohen, Amitabh Varshney, Dinesh Manocha, 
Greg Turk, Hans Weber, Pankaj Agarwal, Frederick Brooks, and William Wright. Simplification envelopes. 
In SIGGRAPH % Proc.,pages 119-128, August 1996. [31 Daniel Cohen-Or and Yishay Levanoni. Temporal continuity 
of levels of detail in delannay triangulated terrain. In Ptvc, W sualization %, pages 37-42. IEEEComput. 
Sot. Press, 1996. c41 Ma&#38;as Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery; and Werner 
Stuetzle. Muldrcsolution analysis of arbitrary meshes. In SZGGRAPH 95 Ptvc., pages 173-182, Augnst 1995. 
t51 Francine Evans, Steven Skiena, and Amitabh Varshney. Opti- mizing tirangle strips for fast rendering. 
In Pnx. Visualization %, pages 319-326. IEEEComput. Sot. Press, 1996. El Robert J. Fowler and James 3. 
Little. Automatic extraction of irregular network digital terrain models. Computer Graphics (SIGGRAPH 
79Ptvc.), 13(2):199-207, August 1979. [71 Thomas A. Funkhouser and Carlo H. St?quin, Adaptive dis- play 
algorithm for interactive frame rates during visualization of complex virtual environments. Computer 
Graphics (SIG. GRAPH 93 PtvC.), pages x7-254.1993. 181 Paul S. Heckbert and Michael Garland. Multiresolution 
motl- eling for fast rendering. In PIVC. Graphics Interface 94, pages 43-50, Banff, Canada, May 1994. 
Canadian Inf. Proc. SOC. 93 Hugues Hoppe. Progressive meshes. In SIGGRAPH 96 Proc., pages 99-108, August 
1996. WI Hugues Hoppe. View-dependent refinement of progressive meshes.In SIGGRAPH 97PIVC.,August 1997. 
c111 Peter Lindstrom, David Keller, William Ribarsky, Larry F. Hodges, Nick Faust, and Gregory A. nmer. 
Real-time, con- tinuous level of detail rendering of height fields, In SIG- GRAPH 96Proc.,pages 109-118, 
August 1996. WI Mark C. Miller. Multiscab Compression of Digital Terrain Data to meet Real 2 Fme Rendering 
Rate Constraints. PhD thesis, University of California, Davis, 1995. 1131 Hanan &#38;met. Applicafionsof 
Spafial Dafa Structures. Addison-Wesley, Reading, MA, 1990. Cl41 William J. Schroeder, Jonathan A. Zarge, 
and William E, Lorensen. Decimation of triangle meshes. Computer Graph. its (SIGGRAPH 92 Proc.), 26(2):65-70, 
July 1992. u51 Clfiudio T. Sifva, Joseph S. B. Mitchell, and Arie E. Kaufman, Automatic generation of 
triangular irregular networks using greedy cuts. In Proc. Visualization 95. IEEE Comput. Sot. Press, 
1995. WI Oliver Staadt, Markus Gross, and R. Gatti. Fast muhiresolu- tion surface meshing. In Proc. Visualization 
95, pages 135- 142.IEEE Comput. Sot. Press, July 1995. 1171 Lee R. Willis, Michael T. Jones, and Jenny 
Zhao. A method for continuous adaptive terrain, In Prvc. IMAGE VII Confer- ence, June 1996. WI J. Xia, 
J. El&#38;ma, and A. Varshney. Adaptive real-time level- of-detail-based rendering for polygonal models. 
IEEE Trans. on Ksualization and Computer Graphics, 3(2), 1997. WI Julie C. Xia and Amitabh Varshney. 
Dynamic view-dependent simplification for polygonal models. In PIVC.Visuallzatlon 96, pages 327-334. 
IEEE Comput. Sot. Press, 1996.  
			
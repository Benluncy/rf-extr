
 VMCM, a PCTE based version and configuration management system K. Berrada, F. Lopez, R. Minot EMERAUDE 
Bull-68, Route de Versailles 78430 Louveciennes FRANCE Abstract VMCM is a version and configuration management 
sys­tem trying to bring together two different technologies: * the P CTE technology and a version management 
system based on composite objects, * the Adele methodology for building configurations  from selected 
versions. The paper presents the model, some design principles and the main benefits which we are expecting 
from this approach. Keywords: software engineering environment, ver­sion management, configuration management, 
PCTE, object management system. Introduction The problem of Version and Configuration management is recognised 
to be a difficult one. One oft he rensons for this is the impressive list of requirements which must 
be met by such a system. A second reason is that it must be implementable and run efficiently to be used 
within real scale projects. A third reason is the necessity of meeting usability requirements such as 
the availability of a friendly user interface, a domain where a very mean­ingful progress has been made 
during the recent years but which still requires important development costs. It is the feeling of the 
authors that the whole prob­lem can be simplified if it is addressed in the context of an Integrated 
Project Support Environment (IPSE) based on a standard framework. This paper describes a Version Management 
and Configuration Management (VMCM) system based on the PCTE public interface [PCTE86], [PCTE87] and 
in particular its distributed Object Management System [GALL86], [MIN088]. Permission to copy without 
fee all or part of this material is granted provided tha$ the wpies aw nvc reeds w distributed for di.ti 
commercial advantage, the ACM copyright notice and the title of the publication and its date appear, 
and notice is given that copying is by permission of the Association for Computing Machinery. To copy 
other­wise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 089791429-5/91/0005/0043 
$1.50 43 A key concern in that approach is to benefit of a fac­torisation of the functionalities which 
are common to all tools of an IPSE, therefore concentrating our efforts on the problems which are considered 
more specific of the version and configuration management. The choice of PCTE brings a well integrated 
solution to many is­sues such as data modeling, security, concurrent access and recovery fonctionalities. 
It also brings a transparent management of a distributed object base, a functional­ity which we consider 
to be of paramount importance in the modern architectures of IPSES designed to sup­port programming in 
the large and all other activities required by the software process. The design of the VMCM system described 
in this document is also taking in consideration the recent evolutions of PCTE in the domain of ver­sion 
management. Within the PACT project [THOM88],[THOM89], [MIN089], a common service for the management 
of versions of composite objects has been defined and implemented. This Version Man­agement Common Service 
(VMCS) [OQUE90] defines a model where it is possible to identify a context within which the existence 
of several versions can be ignored. This notion of transparency is very important in the sense that 
tools can be designed and written without being impacted by the versioning problem. PACT has developed 
version management tools on top of VMCS. These tools have been further enhanced to meet produc­tion quality 
criteria, within the Emeraude [CAMP88] implementation of PCTE. Furthermore, the VMCS in­terface has been 
integrated within the PCTE+ inter­face [BOUD88],[PCTE88a], [PCTE89b] and the emerg­ing ECMA PCTE standard 
[PCTE90]. Concerning the configuration management aspect, there seems to exist at least two different 
philosophies: in the first one, there is a set of controlled ob­ jects. The building of a configuration 
is made by extraction and composition of a set of Ee- Iected components: MOSAIX [THOh185] and Adele [ESTU84] 
,[ESTU85] are examples of such systems. The user can extract simple objects (e.g. source files or configuration 
descriptions) in his working space. He can also create a configuration by running a configurator tool 
which exploits the database of versions. Their differences essentially reside in the method chosen for 
the organisation of versions but they have a similar philosophy. The typical domain on which a user can 
apply opera­tions such as checkout, modification, checkin is at the level of a single file. This approach 
has advan­tages which are described hereafter. A drawback is, however, that objects are generally managed 
at an atomic level (e.g. file) therefore preventing its use by tools requiring an access to several objects 
and their relationships (e.g. an Ada compiler and the various subunits of a library package). Another 
drawback is that a strong boundary is made be­tween the world of objects which are placed under configuration 
control and the others. Establishing relationships between the two worlds is generally not possible. 
in the second one, the user works within the con­text of a configuration which supports the above de­scribed 
transparency concept. Making a new con­figuration consists in creating a new version of an existing (composite) 
configuration. This approach is followed by systems like NSE [NSE88]. It has also been experimented in 
PACT as a direct appli­cation of the VMCS concepts. In the PACT config­uration management system [PCMG89], 
a configu­ration is a composite object. Tools do not need to be modified to work within the context of 
configu­rations. Managing versions of a composite object representing a very large system raises however 
two problems: * it is no more possible to assume that a sin­gle person controls that module. It becomes 
therefore necessary to support parallel evolu­tions of composite objects, followed by a merg­ing process 
which appears to be rather com­plex in the general case, * making several versions of very large compos­ite 
objects would result in too many objects created.  The goal of VMCM is to combine the advantages of 
the two approaches (but not the drawbacks ...). After experimentation of the Pact configuration management 
tools, we arrived to the conclusion that the transparency approach is very valuable to manage versions 
of a soft­ware whose size makes it manageable by a single person. The granularity of such a software 
is higher than a sin­gle source file but can be, for instance, a logical module which physically consists 
of one to ten source files, plus its related documentation and tests. This approach also fulfills the 
transparency principle required to support an easy tool integration. For large systems involving several 
such composite modules, we consider that the first approach becomes a good choice. In particular, we 
have chosen to follow the inter facelrealisation concept and the general organisa­tion of versions of 
ADELE. To summarise the VMCM approach, we adopt two principles: * the versioning of composite objects 
as defined in PCTE and VMCS for the level of granularity cor­responding to a unit of development which 
does not require parallelism, * the organisation of versions in abstract ob-jects[BUXT80] and families 
respecting the inter­face/realisation concept and configuration princi­ples of ADELE, as a methodology 
of work and a general principle to make configurations on the ba­sis of a configuration description language. 
The paper contains a presentation of the requirements which we want to satisfy in VMCM, a description 
of the PACT VMCS and abstract ob­jects concepts, a description of the ADELE configuration manage­ment 
concepts which we have adopted, a description of the VMCM model, a more detailed description of the VMCM 
configu­rator, in conclusion, a discussion about the current imple­mentation and future improvements. 
 This work is carried out in the context of the ATMO-SPHERE project of the ESPRIT CEC programme. It 
constitutes a component of the environment developed by Bull. 2 Requirements This section is a collection 
of the main requirements which we have defined for VMCM. 2.1 Transparency A version management and configuration 
management system must allow existing tools as well as new tools to be easily imported. This suggests 
a system where most tools can access objects and their interrelation­ships without having to be aware 
of the existence of several versions of such objects. In other terms, there should be mechanisms to manipulate 
versions in a trans­parent way. Transparent version management can be characterized by saying that tools 
may execute, refer to objects in the object base, navigate around the ob­ject base, etc, without having 
to use version designation means for accessing the objects and relationships among the objects. 2.2 Addressing 
Versions Some tools however, like configuration management tools, should be able to explicitly designate 
and ma­nipulate several versions of the same object. Therefore a configuration management system must 
allow versions to be managed explicitly. 2.3 Management of objects, attributes and relationships A version 
management and configuration management system must be designed in such way that all other tools required 
in an IPSE are harmoniously integrated. It is therefore required that such a system uses a portability 
and integration platform. The PCTE emerging stan­dard is considered to be a requirement in this context. 
The set of requirements which generally applies to PCTE also applies to VMCM. In particular, it is essen­tial 
that the data modelling facilities support object typ­ing with inheritance, attributes, relationships 
(links), link attributes, multiple schemas, concurrent access, re­covery facilities, access rights and 
security mechanisms. 2.4 Management of Composite objects In a software engineering environment, objects 
can be highly interrelated and have a wide range of structural complexity varying from single objects 
to objects hav­ing many interrelated components. For instance, a user is represented in the object base 
by a single object, a document can be represented by a single object or by a collection of interrelated 
objects (front page, introduc­tion, chapters, sessions, etc). A version and configura­tion management 
system must allow the management of versions of single objects as well as collections of in­terrelated 
objects in a uniform way. To manage versions in uniform way, there should be mechanism to handle versions 
of a collection of interrelated objects as a whole. 2.5 Distribution and Execution The system must allow 
a transparently distributed base of components to be maintained. A degraded mode of functionment must 
be possible if part of the object base is not accessible (volumes un­mounted or workstations disconnected). 
Development must be feasible in parallel (on several workstations or on the same workstation). 2.6 Management 
of versions Within a version management system, it must be pos­sible to create new versions from existing 
ones and to analyse the history of all different versions with facilities to select the needed version, 
according to its attribute values (for example date range, author, target machine, etc). The system must 
enforce the immutability of versions: an existing version that forms part ofa released program or which 
is still in use by another team must be sta­bilised, i.e prevented against any semantically relevant 
modification. All common administration facilities must be avail­able for versions. The space occupancy 
must be con­trolled. 2.7 Management of Dependencies Within a project or even between projects, the different 
entities are interconnected by dependency links. Typi­cal dependencies are: * the procedure call dependencies, 
 * the build dependencies.  Because it is impossible to forsee all the types of de­pendencies that 
are required by users, a configuration management system must provide: * default dependency types: they 
should be used by default if the user does not have specific require­ments, * user defined dependencies: 
the user can customize the dependencies ie. he can define its own types of dependencies. The version 
and configuration man­agement system is able to treat them as well as the default dependency types. 
The dependency graph can be the basis for doing im­pact analysis: before creating an updated version 
of a software component, it is useful to analyse the impact, i.e to determine what configurations may 
have to be revised to integrate this revised component. 2.8 Interface/Realisation concept Software objects 
which are under configuration control must have a well identified interface and (possibly) re­alisations 
of this interface. An interface represents re­sources exported by a component (Ex: procedures, vari­ 
ables, data types, constants, etc) and a realisation con­stitutes the implementation of these resources. 
2.9 Configuration/sub-configuration description A configuration must be seen as a composite ob­ject which 
is composed of a consistent set of objects satisfying a given set of constraints. Let s call sub­configuration 
a configuration which becomes part (is considered as a component object) of a configuration of a higher 
level. It must be possible: * to specify through a powerful configuration lan­guage the constraints to 
be respected for selecting the appropriate versions of components of a config­uration, on the basis of 
the properties which qualify these versions. * to take into account local constraints, i.e con­straints 
which are local to an object, specified in the description of this object and used at configu­ration 
building time. * to include as configuration components, objects which are also configurations (a sub 
configuration). * to define and query the description of a configura­tion as a composite object. 2.10 
Build/rebuild The configuration construction process must be sepa­rated from the derived objects building 
process ( also ~. called build m order to allow: * to build, from the same source object, several de­rived 
objects using different options (debug, target­machine-type, optimize, etc). * to get rid of the derived 
objects of the obsolete con­figurations for space reason, but to allow a rebuild of the derived objects 
in the same conditions, when needed. * furthermore, it must be possible to recognize iden­tical subconfigurations, 
in such way that the build applied to a new configuration does not rebuild the derived objects of the 
subconfigurations which al­ready exist.  2.11 Parallel development It must be possible to control the 
level of parallelism which is defined for the developments. Two styles should be possible: * parallel 
developments on versions issued from a common predecessor version, which implies to offer merging facilities. 
 * single line of versions at a given time, to prevent difficult merging situations to occur.   3 The 
PACT/PCTE Version Management Model The PACT approach to the development of version man­agement tools 
has been to design a common service (a library of routines), called Version Management com­mon service 
(VMCS). The model implemented by this common service hsa been also retained during the de­sign of PCTE+ 
and of the ECMA PCTE standard. The VMCS allows: * to manage versions of any type of object required during 
a project, such as specification documents, workplans, source and object code. * to hide the organisation 
of versions for most of the tools but to allow configuration management tools to designate versions of 
objects on the basis of their names or properties. * to maintain the set of versions of the same ab­stract 
object in such way that the history of the successive versions is kept within the object base.  3.1 
Composite Objects The basis of VMCS is the notion of composite object. A composite object is a graph 
of PCTE simple objects con­nected by composition links in a directed acyclic graph. The root object is 
used to designate such composite ob­jects. It is therefore able to represent composite pro­grams, structured 
documents, test sets, or any other type of composite object. Composite objects can share components and 
can have both internal and external relationships. 3.2 Version History Graph The VMCS model supports 
the maintenance of history of versions by allowing versions of composite objects to be created in such 
way that the history of successive versions is kept. In particular, the model enables tools and users 
to identify ancestors and descendants. The system maintains a predecessor < > suc­cessor relationship 
between two successive versions of composite objects, Considering two successive versions of a composite 
object, such a relationship is maintained between the two root component nodes (or atomic ob­jects) of 
each composite object. It is also maintained for each component object of the two objects. The predecessor 
links have a stability property aJlow­ing the system to enforce that the history of a given version will 
not be altered. Any object which ~has a line of one or more successors cannot be updated unless these 
successors are removed from the history graph (or deleted). Following the application of successive revis­ing 
or snapshoting operations, the graph of predeces­sor < ->successor relationships is therefore a tree. 
In fact, it is also possible to merge parallel branches of the graph, which therefore can constitute 
a directed acyclic graph. The predecessor links can also be exploited by the system in order to support 
a storage space optimisa­tion in a way transparent to the tools. The most at­tractive approach consists 
in a logical copy technique. A composite object can be seen as a structured collec­tion of atomic objects 
(or nodes). Each new version will physically copy the structure but for any compo­nent atomic object, 
the contents (which are usually the most consuming part of the object) need to be physi­cally duplicated 
only if they have been changed. The gain can be important for an object which has several components. 
Size estimations show that the structure information (i.e. all composition links and other re­lationships) 
does not represent more than 10% of the overall space occupied by a composite object in typical cases. 
Therefore, the duplication of the structure does not appear to be a problem. This optimisation tech­nique 
will be developed in the context of the project. It k now planned in the Emeraude implementation of PCTE+. 
3.3 VMCS operations VMCS provides a set of operations that are callable by version and configurate ion 
management tools. These op­erations allow * to create a new version of a composite object by re­vising 
an existing composite object. The new ver­sion will be updatable and the existing version will be stabilised. 
* to create a new version snapshot of an existing version will be stabilised will be updatable. * to 
remove a version of graph of versions, * of a composite object as a composite object. The new and the 
existing version composite object from a to add an existing object as a new predecessor in the graph 
of versions, * to remove a predecessor from a given version, * to compare two successive versions., * 
to test the existence of common ancestor or com­mon descendant versions of two objects in their ver­sion 
graphs. A ,-eui.reoperation B*1O. o- A snapshot operation 3.4 Abstract Objects The main goal of the 
version historic trace of versions of tures can be defined in order sharing common properties. graph 
is to maintain the objects. Additional struc­to group a set of versions Typically, one may group all 
successive versions of a source object within a single set, called abstract object. The abstract object 
can be used as a representative of all these common proper­ties. It is also the means to achieve a uniform 
naming policy of all versions grouped under it. Furthermore, a notion of preferred version can be attached 
to an ab­stract object. 4 The Adele Configuration Concepts Adele [ESTU84] ,[ESTU85] is a configuration 
manage­ment system designed to support software development. The main capabilities of Adele are: * to 
manage files of any type (source, binary, textual document, etc...) * to control access to objects, 
* to maintain the history of versions through naming conventions, * to build configurations by means 
of a configuration description language, * to generate the derived objects of a given configu­ ration 
by means of a build monitor. * to analyse the impact of the modification of a com­ponent on the existing 
configurations. Adele objects can have attributes of two kinds: stan­dard attributes which are defined 
on all the objects, and the users defined attributes. Relationships can be de­fined between objects. 
Adele has defined a methodology for the organisation of the versions. This is based on a notion of family, 
variant and revision. Adele haa a language allowing to describe a set of constraints on versions which 
must be chosen during the configuration process. A key aspect of this organisation is the fact that sev­eral 
versions of the same objects can be said to be real­isat ions of a common interface. This common interface 
contains the common characteristics of a set of versions. Adele has several tools to manage its database, 
to cre­ate versions and configurations, to analyze the impact of a change and to generate the derived 
objects. 4.1 The VMCM system 4.1.1 Introduction The Adele system essentially consists of three parts: 
* a database system allowing Adele objects to be stored and qualified by attributes and relationships. 
* version management tools. * a configuration based on a specific organisation of the database. The 
purpose of VMCM is to integrate the organisa­ tion of versions defined in Adele with an object base 
managed by PCTE and its associated version manage­ ment services. In the context of VMCM, the PCTE object 
database offers all facilities required to implement the Adele database with the advantage of being 
compliant to the emerging standard and allowing integration of other PCTE tools. It also provides a unified 
approach to the management of objects. Objects can be developed in a working space and then placed under 
configuration control. A common data model can be used in both cases and no physical transfer from one 
base to another is required. Furthermore, the objects which are placed under configuration control can 
still be directly accessed by the tools without requiring extraction from the con­ figuration base. An 
important benefit of this approach is the set of PCTE functionalities which implicitly apply to all ob­jects. 
This includes in particular, the concurrent access control (e.g. transactions), the transparent distribu. 
tion mechanisms and an evolution of versioning facilities from simple objects (files) to composite objects. 
The following is a description of the organisation of versions. 4.1.2 Basic Concepts of VMCM Following 
the Adele organisation, the VMCM organi­sation of software objects to be produced consists of families 
of modules . Each module consists of * an interface, * a realisation,  * derived objects.  The family 
gathers also the alternatives and all the revisions of these different objects. In VMCM a family object 
consists of: * a set of interface variants, * a set of properties (attributes or links) which qual­ify 
globally all interface variants of the family.  Such interface variants represent major functional variants 
of the same logical interface. In VMCM, this notion is equivalent to the notion of variants in Adele. 
An interface variant consists ofl * one or more views of abstract interface, * one or more variants of 
abstract realisations, * modules * a set of properties (attributes or links) which qual­ify globally 
all modules of the interface variant.  Different views of the same abstract interface may coexist in 
order to model the different language bindings (C, Ada, C++, etc...) of the same interface or to model 
subsets of the interface. Variants of abstract realisations correspond to differ­ent approaches in the 
implementation of the logical ab­stract interface of the interface variant. An abstract interface is 
an abstract object tailored for the naming of a sequence of revisions of interfaces. Each revision receives 
a sequential revision number within the abstract interface. An abstract interface is also an OMS object 
charac­terised by a set of properties (attributes or links) which qualify globally all its interface 
revisions. An abstract realisation is an abstract object tai­lored for the naming of a sequence of revisions 
of real­isations. Each revision receives a sequential revision number wit hin the abstract realisation. 
An abstract realisation is also an OMS object charac­terised by a set of properties (attributes or links) 
which qualify globally all its realisation revisions. Other objects such as software components or mod­ules 
are mainly designed to contain as components, the derived objects produced by the builder[SIMM91]. Such 
, objects are by nature reusable components and it must be possible to include them in several configurations 
(which are not known in advance). This is typically the case of software components (with their related 
docu­mentation). In this case, an approach allowing to build a com­posite configured object by means 
of selection rules and within the limits of consistency constraints appears to be a useful approach. 
This process of (rebuilding a composite module from more element ar y modules is the main purpose of 
configuration management. A module is a (composite) object consisting of * an interface,  * a realisation, 
 * a set of derived objects,  * a set of associated objects.  * a set of properties (attributes or 
links). As typical associated objects, one may mention the   error reports received on this module. 
An interface is a (composite) object consisting of * one or more objects defining the text of the inter­ 
face, * a set of associated objects concerning the interface,  * a set of properties (attributes or 
links). A typical interface may be represented by one or more include files. As typical associated objects, 
one may mention a requirements document, a specification doc­ument, They may be the document(s) used 
to support  the development of this interface. A reahsation is a composite object consisting ofi * a 
set of source objects supporting the implemen­tation of the interface of the module * a set of associated 
objects, * a set of properties (attributes or links).  As typical associated objects, one may mention 
the architecture documents, the reference tests (and again the objects required to support the web methodology 
in 48 the definition of this realization). Hereafter is a graphic description of the PCTE schema definition 
subset which contains the object types and link types defining the organisation of versions. A rectangle 
represents an object type. A diamond repre­sents a relationship type (i.e. a pair of two link types). 
4.1.3 Dependencies Dependencies can be represented between the families. Such structural dependencies 
are providing information about the graph of actual dependencies which exist be­tween the abstract realisations 
and abstract interfaces. The use.interface is the predefine relationship which represents dependencies 
between realisations and inter­faces or abstractinterfaces. Dependencies to abstract interfaces can be 
set to indicate that they generically apply to all versions of the abstract interface. 4.1.4 Abstract 
Configuration and Configura­ t ion Model Selection Rules Some abstract realisations share as a common 
property, the fact that they represent a configured implementa­tion. Such a configured implementation 
is specified by a text describing how this configuration needs to be built. This text, called configuration 
model selec­tion rules is a property of the abstract configuration. It describes the common selection 
rules to all the con­figurations of the abstract configuration: when instan­cialed, all the configurations 
within the abstract config­uration must satisfy these common select ion rules. 4.1.5 Configuration and 
Configuration In. stance Selection Rules A configuration is a subtype of realisation to which is attached 
the configuration inst antes selection rules. The selection rules describe with the configuration model 
selection rules of the embedding abstract config­uration, the constraints which must be satisfied by 
the realisation selected(by following the dependency links) to be part of the configuration The selection 
principles are described in section 5.3. The same configuration model can be instantiated at different 
times and, as a consequence of the last revision default selection rule, result in different configured 
modules. 4.1.6 Building a Configuration As soon as a configuration is instantiated, the relation­ships 
to all its components are identified and the build­ing phase can be initiated. The builder can produce 
several derived objects for the module (configuration). It is for instance possible to produce executable 
files for various target processors assuming that they share the same port able realisation. 4.2 Customizable 
part A version and configuration management system must be applicable to all types of objects. It must 
be possible to manage versions of documents or graphics as well as   7==7  Figure 1: The main Schema 
Definition Set of VMCM source code or executable code. In addition, composite objects, which are composed 
of several objects possibly hightly interconnected, can be versioned. Therefore the versions of objects 
can be of any type. It would be unrelevant to fix a predefine type for the versions of objects. The VMCM 
system is a generic model. The versions are just of type object . This allows the versions to be of any 
type since any type is a subtype of the type object . This is available for versions of interface and 
versions of realisation. Moreover, the existing tools and the future tools can work with the versions 
of objects in a transparent way. This does not interfere with the version and configura­tion management 
(see requirement 2.1). Similarly, we several types of dependencies can be defined between objects. It 
is out of scope to try to forsee all the dependency types required by users. This depends on the kind 
of application. For example differ­ent languages can involve different kind of dependencies. Therefore, 
to be very generic and to allow any applica­tions to use the versioned objects, we propose two kinds 
of dependencies: * default dependency types, * user defined dependency link types: a mechanism is defined 
to indicate to VMCM what link types are expressing such dependencies. The mechanism is built on top of 
a Metabase Common Service.  This fulfills the requirements described in section 2.6. 5 Principles of 
the VMCM Con­figurator 5.1 Generalities The VMCM model describes an architecture of object types, providing 
a methodology for the naming and stor­age of versions. The objects which are under configura­tion management 
can be highly interconnected and form a semantic graph. This semantic graph is composed of interfaces 
and realisations, where the interfaces are im­plemented by realisation(s) and realisations depend on 
interface(s). All these connections are represented by PCTE relationships, as described before. Let us 
now show the power of the VMCM model by presenting a necessary component of a VMCM system: the configurator. 
This component selects from the ob­ject base, the versions which compose a configuration. It takes as 
input the semantic graph and some selection rules associated with the configuration. When, accord­ing 
to this semantic graph, several versions of the same object can be selected, only the one which best 
satisfies the selection rules, is retained. The configurator does not use the contents of reali­sations 
and interfaces. They can contain source code . .... .. :~ I?!5Ec3 1 J -1 >.­ ? ..­ >.­ 2 ff --­ ~ 
...... ..?!. ..-..-?!. .. ...o-=y ,,-,.­ ., d"'':::. ..?. . ..<..~ .  3 ----,,-­ ------,,. -----,., 
-------~., --,, 4 ---., -..,, ,,--.,+-..-.---.  ,,,-----. s ( 0 -.-o  d I ..4 I -------- s.s -, 
mcrf,ce impicnmm imckcc / rdktim Sc.md,dc ) Figure 2: The configurator selection principles written 
in any language. The con figurator is language independent. 5.2 Result of Configuration Evaluation: Persistence 
of the Evaluation The configurator selects all the interfaces and realisa­tions that compose the configuration. 
As these objects are usually stable, the configurator associates them to objects called modules, which 
can then be used to store as components the derived objects. For each pair of selected interface and 
realisation the configurator gen­erates a module. The dependency links between reali­sation and interface 
are mapped into dependency links between modules. In other terms, to a function fl which uses the interface 
of a functions f2 corresponds a module ml which uses a module m2. In the following schema we show an 
example of a module architecture created by the con figurator from a dependency graph containing 5 interconnected 
families. This graph of modules generated by the configurator can be reused by any other process. Typically, 
it is reused by the builder. Note that it is possible to save the selection of a configuration, just 
by keeping the modules that have been generated, without saving the derived objects generated by the 
builder (cf requirement 2.8 and 2.9). In general, the derived objects can be rebuilt at any time, only 
the selection must be saved (if it is not saved, another evaluation of the same configuration can lead 
to select new versions which have been created after the first evaluation was performed). 5.3 Versions 
of Configurations A configuration is a particular case of realisation. This means that it provides the 
same functionality as a real­isation, ie.: * it can contain source code(s), * it can be the source of 
dependency links, * it is associated to an interface where the scope of the configuration or the way 
to use the configura­tion can be described, * moreover, versions of configurations can be made.  The 
last point is very important. During the life cycle of a project, many configurations are generated and 
evaluated. Some of them delivered. Therefore it is highly important to provide a simple way to create 
and manage versions of configurations. In the VMCM system, configurations are just versioned like any 
reali­sation. During the evaluation of a configuration, the config­urator checks that the selected versions 
satisfy the se­lection rules. These selection rules are specified in ob­jects of type selection-rules 
. Because the successive versions of a configuration will use many common selec­tion rules, the VMCM 
system provides a way to factor­ize the common selections by associating them with the abstract configuration. 
In other terms, rules selection can be associated with * an abstract configuration: it contains the selection 
 rules available for every configuration within the abstract configuration, * a configuration: they 
are the selection rules to be taken into account only for this configuration eval­uation.  5.4 Selection 
Rules Language The language, in which the selection rules must be spec­ified, is upwards compatible with 
the selection language defined in Adele. This is a very simple but powerful language. It allows to define 
imperative rules as well as default rules. The selected objects must satisfy the implicit rules, while 
they may satisfy, if possible, the default rules. The rules can describe constraints on the path of versions 
to be selected or/and on their at­tributes. 5.5 Private Workspace Being able to select versions within 
a private workspace is highly important to test new versions of source code before they are stabilised. 
If the configuration is in a private workspace, the configurate or allows to select ver­sions in private 
workspace (dependency links can lead to objects in private workspace). 5.6 Subconfiguration During the 
evaluation of a configuration, the depen­dency links can lead to another configuration: it is called 
a subconfiguration. It may be interesting to attach some local constraints to this configuration which 
must be checked during the selection of objects within the sub­configuration. It is sufficient to associate 
selection rules to this subconfiguration. They will be checked only for the objects of the subconfiguration, 
not at the upper level where they are unrelevant (see requirement 2.8). 6 Current status and Conclu­sion 
The VMCM system defines a new approach to the ver­sion and configuration management problem. It is based 
on the idea that the two philosophies of PCTE and Adele can be merged together, because they have dif­ferent 
advantages at different levels of granularity. The VMCM model is under development. The con­figuration 
tools have been developed and integrated with the existing version management tools of Emer­aude V12 
[EMER90]. In parallel, a build monitor is being developed by SFGL [SIMM91] and will also be integrated 
to constitute a usable prototype. Pilot ex­perimentations of the prototype are also planned to be made 
within Bull and within GIE Emeraude. Among the issues which need to be addressed in the future, the most 
important is, according to us, the pre­sentation aspects of the tools. This will be addressed in a way 
consistent with the policies defined in the AT-MOSPHERE project. Of the same nature is the integration 
of a mechanism to get meaningful events notified. This also implies rules consistently defined to support 
the whole software life cycle (and not only the configuration management). A third topic on which we 
intend to work in the near future is the development of a mechanism to optimise the storage space occupied 
by successive versions. It is currently envisaged to integrate VMCS with the Emer­ aude V12 server so 
that all storage saving mechanisms can be integrated transparently to the tools. 7 Acknowledgments This 
work has been partly funded by the CEC ES-PRIT programme (project Atmosphere). We want to thank Jean-Marc 
Morel (Bull) and Jean-Michel Bouille (Bull) for they many useful contributions to the design of the mapping 
of ADELE concepts to PCTE, Ian Sim­monds (SFGL) who helped us in keeping consistency with the design 
of his general build tool, Chantal Vivier and Gerard Memmi (Bull) who have also con­tributed to the design 
and quality of the tools developed in VMCM, owing to experimentation plans (in Bull Software Methodology 
organisation), Jim Ferrans and David Hurst (Vista Technologies Inc.), Brian Brown, Anne Kastner and Flavio 
Oquendo (GIE Emeraude) for their useful comments during the design phase. References [BOUD88] Boudier, 
G., Gallo, F., Minot, R., Thomas, I., An Overview of PCTE and PCTE+ , in Proceedings of the 3rd ACM Symposium 
on Practical Software Development Envi­ ronments, Boston, November 1988. [BUXT80] Buxton, J. N., STONEMAN 
-Require­ ments for Ada Programming Support En­ vironments , US Department of Defense, February 1980, 
44p. [CAMP88] Campbell, I., Portable Common Tool Environment , North-Holland, Computer Standards and 
Interfaces, No. 8, 1988. [EST Estublier, J. and Ghoul, S., Un systbme automatique de gestion de gros 
logiciels: la base de programmed Adele , Technique et Science In formatiques, 1984, pp. 253-259. [EST 
 Estublier, J., A Configuration Manager: the ADELE Database of Programs , in Pro­ ceedings of the Workshop 
on Software Engi­ neering Environments for Programming-in­ the-large, Harwichport, June 1985, pp. 140­ 
147. [EMER90] Emeraude V12, General User Documenta­ tion, GIE Emeraude, August 1990. [GALL86] Gallo, 
F., Minot, R., Thomas, I., The Object Management System of PCTE as a Software Engineering Database Manage­ 
ment System , in Proceedings of the 2nd ACM Symposium on Practical Software De­ velopment Environments, 
Palo Alto, 1986, published in SIGPLAN Notices, Vol. 22, No. 1, January 1987. [MIN088] Minot, R., Gallo, 
F., Boudier, G., Oquendo, F., Thomas, I., The Object Management System of PCTE and PCTE+ , in Pro­ ceedings 
of the IEE Colloquium on Stan­ dard Interfaces for Software Tools. London, September 1988. [MIN089] Minot, 
R., Thomas, I., An Overview of the Pact Project , in Results and Progress of Esprit Projects in 1989, 
Volume Inform> tion Processing Systems , November 1989. 52 [NSE88] [OQUE89] [PCMG89] [PCSC88] [PCTE86] 
[PCTE87] [PCTE88a] [PCTE88b] [PCTE90] [THOM85] [THOM88] [THOM89] [SIMM91] Sun Microsystems, Inc. The 
Network Soft­ ware Environment: a Sun Technical Report. 9 October 1988. Oquendo, F. Berrada, K. Minot, 
R., Gallo, F., Thomas, I., Version Mechanisms on the PCTE S Object Management system for supporting Version 
and Configuration Man­agement Tools , 2sd Internation Workshop on Software Configuration Management, 
89. Bull, Eurosoft, GEC Software, ICL, Olivetti, Siemens, Syseca, Systems and Management, PACT Configuration 
Man­ agement Guide , First Edition, First Draft, May 1989. Bull, Eurosoft, GEC Software, ICL, Olivetti, 
Siemens, Syseca, Systems and Management, PACT Common Services -C Language , First Edition, Second Draft, 
May 1988. Bull, GEC, ICL, Nixdorf, Olivetti, Siemens, PCTE -A Basis for a Portable Common Tool Environment 
, C Functional Specifica­tions, Fourth edition, 1986, 342 p. Systems Designers and Mark V Business Systems, 
PCTE -A Basis for a Portable Common Tool Environment , Ada Func­tional Specifications, First edition, 
1987, 299 GIE Emeraude, Selenia, Software Sciences Limited, PCTE+ Ada Functional Specifi­cations , Issue 
3, October 1988, 583 p. GIE Emeraude, Selenia, Software Sciences Limited, PCTE+ C Functional Specifica­tions 
, Issue 3, October 1988, 660 p. European Computer Manufactures Associ­ation. ECMA PCTE Standard. Abstract 
Specification. final draft submitted to ECMA Genaral Assembly November 1990. Thomas, I. and Loerscher, 
J., MOSAIX -A Version Control and History Manage­ment System , in Proceedings of the Work­shop on Software 
Engineering Environments for Programming-in-the-large, Harwichport, June 1985, pp. 128-139. Thomas, I., 
The PCTE Initiative and the PACT project , ACM Software Engineering Notes, Vol. 13, No. 4, October 1988. 
Thomas, I., Tool Integration in the P.4CT Environment , in Proceedings of the 1lth International Conference 
on Software Engi­neering, Pittsburgh, May 1989. Simmonds, I, Configuration Management in a PCTE-Based 
Environment Expected submission to SCM3,Trondheim, June 1191  
			

 Translational Polygon Containment and Minimal Enclosure using Linear Programming Based Restriction Victor 
J. Milenkovic* Abstract We introduce and analyze a new technique Linear Progmm­ming Based Restn ction 
(LP Restriction) for solving trans­lational containment and enclosure problems. The ~ontain­ment task 
is to translate k m-gons into a n-gon container. The enclosure task is to translate k m-gons into a minimum 
area n-gon which is convex with fixed orientation edges. All running times are based on an assumption 
of fixed k and are asymptotic in m and n. Lower bounds are roved for con­ fk tainment in a nonconvex 
container: Q((mn) ) for noncon­ vex polygons and Cl(nk ) for convex polygons. LP restriction ac.Meves 
upper bound O ( (m2 + rnn)2k log n) for nonconvex polygons and O((mn)k log n) for convex polygons. The 
for­mer almost matches the lower bound, and the latter does also for constant m. For arbitrary m and 
k >3, the latter is faster than any other known algorithm for translational con­tainment of convex polygons. 
A proof is given that the area function for fixed-angle convex polygons is Lorentzian. En­closure algorithms 
based on thk result have running times 0((m2 + n)2k-2 (n+ log m)) for nonconvex polygons and O((m + n)2k(n 
+ logm)) or 0(mk-l(n2~+1 + logm)) for convex polygons. We are not aware of any previous run­ning times 
for k-polygon minimum area enclosure. Other containment and enclosure results are given. LP restriction 
demonstrates a useful combination of math­ematical programming and computational geometry which may be 
a paradigm for solving other tasks. We show that the containment and enclosure algorithms are useful 
in in­dustry. Software based on LP restriction has been licensed to industry, and it is the fastest available 
solution to trans­lational containment and enclosure for nonconvex polygons. · University of Miami, Department 
of Math and Computer Science. Email: vjm@cs.miami.edu. This research was funded by the Tex­ tile/Clothing 
Technology Corporation from funds awarded to them by the Alfred P. Sloan Foundation, by NSF grant CCR-91-15 
7993, and by a subcontract of a National Textile Center grant to Auburn University, Department of Consumer 
Affairs. permission to make dlgitalihard copies of ail or pafi of thh material fOr personal or classroom 
uee is granted without fee provided that the copies are not made or distributed for profit or commercial 
advantage, the copy­right notice, the titie of the publication and ita date appear, and notice is given 
that copyright is by permission of the ACM, Ine. To copy otherwise, to republish, to poet on servers 
or to redktributc to tiats, requires specific permission and/or f+. STOC 96, Philadelphia PA, USA Q 1996 
ACM 0-89791-785-5/96/05. .$3.50 1 Introduction A number of industries generate new parts by cutting them 
from stock material: cloth, leather (hides), sheet metal, etc. These industries require good solutions 
to containment or mmirnal enclosure problems. Containment is the question whether a given set of part 
shapes can be fit without overlap­ping into a given container. Minimal enclosure is the prob­lem of minimizing 
the size (area, length, or other measure) of the container for a given set of parts. One might think 
that a few good layouts might suffice for a given industry, but such is not the case. One large apparel 
manufacturer solves about 1500 minimal enclosure problems per week (see Figure 1 for a typical layout). 
Human employees gener­ate these near-optimal solutions by hand, and we estimate that their total compensation 
is about three million doillars per year for that one company. Large companies are highly automated, 
and they could easily substitute software for hu­mans. However, no current software (even our own) can 
re­liably find enclosures withh one percentl of those generated by expert humans for the number of parts 
they routinely lay out (one to two hundred). (See [3, 9, 10, 17] for a survey of current results.) Containment 
is NP-hard [4] even if the parts cannot ro­tate and if the parts and container are rectangles.z Thk hardness 
result assumes the problem size is the number k of parts. We can probably never hope to exactly solve 
k­part containment or enclosure problems for k > 100, espe­cially for nonconvex parts. However, in her 
Ph.D. thesis [3], Daniels demonstrates that the ability to solve transla­tional containment or enclosure 
for modest values of k, such as k < 10, is a very useful tool in finding approximate solutions to problems 
with k > 100. Detecting impossible containment problems is particularly useful. For instance, our software 
finds layouts of a dozen pairs of pants by iirst laying out the large front and back panels. Containment 
is then applied to place the smaller trim pieces in the unused patches of material. For other garments 
types, our enclo­sure algorithm could pack part subsets into rectangles and then one could lay out these 
subsets using known rectangle­packhg strategies. In textile applications, fabric has a gri>in, 10ne percent 
is about the break-even point of labor VS. material costs. The reader will recognize that containment 
is the feasibility question for minimal enclosure, and thus the appropriate complexity question is the 
hardness of containment. 3Appro=&#38;n.ate here means either placing almost all the partlg in the container 
or finding a near-minimum-area container. Setof polygonal parts Strip of fixsd width and unknown length 
Name: 37457C Widuu59.75 in La@: 269.04 in P*: 108 Srmimq a9.54% Packing with 180 degree rotations and 
xy-flips allowed Figure 1: The Marker Making Task in the Apparel Industry (Parts are polygons with 4 
to 100 vertices.) and each part can have only up to eight orientations (hence one can iterate over these 
orientations). In recent work [6], we show how to apply translational containment algorithms to generate 
industrial-quality layouts of many parts with multiple orientations permitted. We conclude that purely 
translational containment and enclosure is useful and appli­cable, even for bounded values of k. Our 
current software can place (translate) k nonconvex m-gons into a nonconvex n-gon, or determine that no 
solu­tion exists, in a few minutes on a desktop workstation for k <10, 4< m <100, and 100< n <400. This 
software has been licensed by Gerber Garment Technologies, the largest provider of textile CAD/CAM software 
in the U. S., and they have incorporated it into their existing CAD/CAM software product. The fastest 
version of our software uses an algorithm called linear progmmming based restriction (LP restriction). 
This paper describes LP restriction and gives a theoretical analysis of its running time for both containment 
and en­closure problems. This analysis is based on the assumption of jized k and expresses the running 
time as a function of m and n. Because fixed-k algorithms me useful, thk is the analysis we really need. 
The following section describes the new results. Section 1.2 gives related work, and Section 1.3 gives 
an outline for the rest of the paper. 1.1 New Results. We use the following shorthand: R-rectangle, C-convex, 
N­nonconvex. Thus the symbol kCN denotes the task of trans­lating k convex polygons into a nonconvex 
container, and all-kCN denotes finding all combinatorially distinct solu­tions, instead of just one. 
For enclosure problems, kNminR denotes translating k nonconvex polygons into a rectan­gle of minimum 
area. For both minR and mine , the edges of the container have fixed orientations. We do not assign a 
meaning to minN . The polygons each have up to m vertices and the container has n vertices (unless it 
is a rectangle). When expressing running times, we assume fixed k. (The constant factor depends on k.) 
If the ex­pression involves both m and n, then log n really stands for max(log m, log n). Two solutions 
to containment are equivalent if there is a nonoverlapping motion that transforms one to the other: they 
are in the same connected component of the set of valid configurations. We prove the following lower 
bounds on the number of connected components (equivalence classes): all-kNN all-kNR all-kRN fl((mn)z~) 
Q(m4~-4) fl(nk) We give containment algorithms with the following run­ning time bounds. Bounds are the 
same for one solution or all solutions: kCN kCC kCR O((mn)~ log n) O((m + n)k log n) O(m~ log m) kNN 
kNC kNR 0((m2 + mn)zk log n) O((m2 + n)2k log n) 0(m4k log m) The runnin time for kRN is that of kCN 
with m = 4, % namely O(n log n). Note that the running times for kNN and kRN are within a factor of log 
n of the lower bounds for these problems. We also give algorithms to compute a minimal area con­ vex 
enclosure with n edges of fixed orientation: kNminC 0((m2 + n)2k 2(n -t logm)) kCminC O((m + r6)2k-2(n 
+logm)) or O(m~-l(n2~- + logm)) One can set n = 4 to obtain the times for minimum rectan­gular enclosure: 
kNminR kCminR O(m4k-4 logm)) O(mk-l log m)) The lower bounds are fairly straightforward generaliza­tions 
of known results. The running time for kNN requires an intricate version of LP restriction plus a very 
careful counting argument. The times for kNC and kNR are corol­laries. It should be mentioned that there 
is a way to achieve the same bounds by naive enumeration, but this naive algorithm is totally impractical 
and is definitely not output­sensitive: running time is Q((mn)2k ) even if no solutioz4 ex­ists. We view 
the proof for LP restriction as an important first step towards an output-sensitive argument. The LP 
re­striction algorithm for kCN is not quite as intricate as the kNN algorithm, but it requires a different 
very careful count­ing argument. The running times for kCC and kCR are corollaries. We know of no other 
way to achieve these run­ning times. To solve the enclosure problems, we must prove that the area function 
for fixed-orientation convex polygons is Lorentzian. Once we have done this, the algorithms for minimum 
convex enclosure are straightforward genera}.iza­tions of the containment algorithms. 1.2 Related Work. 
In general, industrial systems use heuristics which cannot detect unfeasibility or determine if they 
have found the o,pti­mal enclosure. These systems use practical efficiency techn­iques such as inner 
and outer approximations of the parts, and thus the running time increases with the tightness of the 
fit. We have licensed our software including the algorithms described here, and we believe them to be 
superior to what is currently available. 4 Fortune [11] gives a O(mn log mn) time solution to lCN by 
computing the Minkowski sum using a generalized Voronoi diagram. Avnaim and Boissonnat [2, 1] use the 
Minkowskl sum and convex decomposition to solve INN and 2NN in 0(rn2n2 log mn) and 0(m4n4 log mn) time, 
respectively, and Avnaim [1] gives a 0(m14n6 log mn) for 3NN. Devillers [8] gives faster algorithms for 
2CN and 3CN with running times 0(m2n2 log m) and 0(m3n3 log m), Avnaim and Boissonnat also give a solution 
to the 3NP problem, three nonconvex polygons in a pamllelogmm container (this is equivalent to 3NR), 
using time in O(meo log m) [2, 1]. In earlier work, Milenkovic, et al. [7] offer three ap­proaches to 
translational containment. The first is fast al­gorithms for convex shapes: O(mn log n) for 2CN and 0(m3nlog 
n) for 3CN (see also [5, 15]). The second ap­proach is an MIP (mixed integer programming) model for 4Companies 
closely guard their products, and there is no way we can actually compare our algorithms to others short 
of buying very expensive systems, although we do regularly attend trade shows. Inci­ dentally, although 
we do not currently do so, we also could apply prac­tical efficiency techniques, such as inner and outer 
approximations. kNN containment (see [14] for full details). The MIP method takes a minute or two on 
a typical workstation for k < 3 polygons, but is slow for k > 4. The thwd approach ~ a geometric algorithm 
for kNN whkh can find a layout with at most 26 overlap using time in 0(($) k log (~) kss log s), where 
s is a practical complexity measure on the input. There is no theoretical bound on s, but it ranges from 
n to rnn in practice. The geometric containment algorithm uses geometric restriction which is neither 
strictly stronger nor strictly weaker than LP restriction. Daniels [3] has shown experimentally that 
geometric restriction is often stronger than LP restriction. We have not yet implemented an opti­maj 
algorithm for Minkowskl sums of nonconvex polygons. When we do, the geometric containment algorithm might 
possibly be faster than the LP restriction based algorithm on some inputs. More recently, we presented 
the naive LP algorithm [5, 15] with running time () (2kmn :2m2)2k+ L~@~, ~~mn + ~ m2) () for kNN, where 
LP(a, b) is the time to solve a linear program with a variables and b constraints.5 A description of 
the practical versions of the algo­rithms presented here appears in a recent tecfi~cal report [16]. Thw 
report gives the complete detailed LP restriction al­gorithm and analysis for kNN. It also describes 
a related method that uses an overlap linear program (OLP) for over­lap minimization. In practice, using 
LP restriction plus over­lap minimization is faster than LP restriction alone, but we have no proof that 
overlap minimization improves the theo­retical bounds. The technical report also gives experimental results 
on industrial data.s The algorithms presented here match or improve the run­ning times of all previous 
algorithms except for our O(mn log n) 2CN and 0(m3n log n) 3CN algorithms. In fact, we prove here a lower 
bound of fl(nk) time for all­kRN, yet these algorithms solve 2RN and 3RN in O(n log n) time! There is 
no contradiction because these algorithms ret urn only a single solution. So far, we have not been able 
to generalize these algorithms to k >3.  1.3 Outline. Section 2 presents notation and background results 
on Min­ kowski sums. It proves the lower bounds for all-kNN, all­ kNR, and all-kRN, and it describes 
the general framework of the LP restriction algorithm. Section 3 gives the algorithms for kCN, kCC, and 
kCR. Section 4 shows how to apply LP restriction to solve kNN, kNC, and kNR. Fkdly, Section 5 analyses 
the area function for fixed-angle convex polygons and gives the algorithms for kNminC and kCminC. 6The 
latest revision of [15] gives a 0( (rrIn)k+* log n) time algo­ rithm for kGN which is similar to the 
O((mrz)k log n) algorithm pre­ sented here, although it does not use LP restriction. This revision has 
not yet been accepted for publication, and this algorithm has not appeared in any conference proceedings. 
6See http: //www.cs.miami. edu/-vjm and http://dm-ww.harvard .edu/u8ers/students/ KarenBaniels/ Karen_Daniels.html 
for recent papers. 2 Background, Lower Bounds, and Framework Section 2.1 provides background on the Minkowskl 
sum and notation for the configuration spaces used by LP restriction. Section 2.2 proves lower bounds 
for containment. Section 2.3 defines LP restriction and gives the hmework for a contain­ment algorithm 
based on this technique. 2.1 Background and Notation, 2.1.1 Minkowsld Sum. The Minkowski sum [12] of 
two point-sets (of R2 in the case of this paper) is defined A@ B={a+bla~A, b~B}. For a point-set A, 
let ~ denote the set complement of A and define A = { a Ia c A}. For a vector t, define A + t = {a+ tla 
~ A}. Note that A + t = A @{t}. Let IAI denote the number of vertices of A. Known complexities of 1A 
@ BI are: 6( IA121B12) for nonconvex A and B [13], O(lAl[Bl) for convex A [11], O(lAl) for convex ~, 
O(lAl + IBl) for convex A and B [12]. 2.1.2 Configuration Spaces. A containment algorithm translates 
k polygonal regions P1, P2, ..., pk into&#38;polygonal container C without overlap. If we denote PO = 
C to be the complement of the container region, then containment is equivalent to the placement of k+l 
polygons Po, Pl, P2, . . . . Pk in fIonoVerlaP@ng positions. For translations, tiand tj, Pi+ t, and F 
j + tj do not overlap if and only if tj tic Uij, where UiJ = Pi @ P] , OSi, j5k)i #j. (1) The set Uij 
is the tw~dlmensional conjigwation space for placing Pj with respect to Pi. Clearly, U,, = U~,. L@ P 
and U denote the lists of all Pi and U,J, respectively. A configuration of P is a list ((k + 1)-tuple) 
of translations (ti 10~ i ~ k) where tois arbitrarily set to (O, O). A valid configumtion of P satisfies 
A valid configuration is an exact solution to a translational containment problem. For enclosure problems, 
we do not represent the container as ~, and i and j are in the range l~i<j~k.  2.2 Lower Bounds. Lemma 
2.1 For kNN, the set of valid wnfigurations has Q((mn) k ) components. Proofi In Figure 2, the container 
is the entire plane minus a set of n/8 rectangular frames (in black). Each polygon is a set of m/4 squares 
(in grey). The number of ways of putting two squares into two slots is (rn/8)(n/16)(m/8) (n/16) which 
is f2((mn)2 ). Assuming each polygon has small enough squares, we can make thk choice independently for 
k poly­gons. Corollary 2.2 For kNR, there are fl(m4k-4) components. Using the CLP as an oracle, the LP 
restriction algorithm constructs C~h. Solving the CLP with objective (to maxi­mize) d . (th tg) yields 
the vertex ORACLE(C, g, h, d) of 6 ~h which is farthest in the direction d. The algorithm first calls 
the oracle with d = (1,0), (O, 1), ( 1,0), and (01, 1) to generate a convex polygon Q. For each edge 
ab of Q, it El calls the oracle with dab, the outward normal vector to this edge. If thk generates a 
new vertex c, then it replaces ab by ac and cb and recurses. Otherwise, ab is an edge of C~h. Running 
time is output-sensitive: 21C~h I calls to the oracle. The kNN algorithm in Section 4 generates the range 
in a theoretically more efficient manner. Naturally, if the range C~h is empty (infeasible CLP) or if 
C~h (1 Ugb = 0, then we can discard the hypothesis C. 2.3.2 Solving Containment. For a containment algorithm, 
the initial input hypothesis is a list of outer approximations CiJ, U%j ~ C%j, 0 ~ i < j ~ k: bounding 
boxes or convex hulls, for instance. The algorithm first applies LP restriction to its input. If for 
some g, h, Cgh f) Ugh is not convex, then it ChOOSeSa line L to cut Cgh into two halves C;k and C~k. 
The algorithm subdivides C Figure 2: Lower Bound for kNN Containment: n = 48, into C and C+ b~ replaci;g 
thk particular Cgh by either m = 24. (Container is complement of (thin) black regions: Cg-k of C~h. Then 
it recurses on each sub-hypothesis C- and Polygon P; is set of grey squares.) C+. Otherwise (if every 
C!j n Uij is convex, O s i < j s k), the algorithm evaluates the hypothesis: it replaces each C,j by 
C,j n Utj and applies restriction. If the resulting C,J are Proofi Make the actual container very big. 
Let ~ play ROt empty, the set of configurations to,t1,...,tksatisfying the role of the container. Apply 
previous lemma with k -1 t~ ti E C,j, O ~ i < j ~ k will be a convex set of valid and n= m. configurate 
ions. Lemma 2.3 For kRN, there are O(nk ) components. Theorem 2.4 Assuming it terminates, the LP restriction 
based containment algorithm generates at least one solution Proofi As in Figure 3, give the container 
n = (n 4)/8 in each connected component of the space of valid wnji:qura­rooms, each big enough to hold 
a single rectangle P,. The tions. number of ways of placing rectangles into rooms is Proof: LP restriction 
cannot throw away any valid so­n (n I)(n -2)... (n k+l) =Q(nk). lutions. Subdivision also preserves 
the invariant that every solution satisfying C will either satisfy C or C+. Evaluation generates a convex 
subset of the set of valid configurations. Thus the containment algorithm generates a convex cover of 
the set of valid configurations. The theorem follows. 2.3 Framework for LP Restriction.  This section 
gives the framework for solving containment us-In practice, we stop when we have found one solution. 
ing LP Restriction. LP restriction acts on hypotheses. A hy-We use an extension of the CLP called the 
overlap linear pothesis is a list C = (Cij, O < i < j ~ k) of convex polygons program (OLP) to encourage 
the algorithm to find a solution corresponding to the following assertion: there exists a vahd with as 
little subdivision as possible [16]. configuration (to,tI,tz,...,fk)such that tj t, E Cij fl Uij, O 
~ i < j < k. Restriction of a hypothesis replaces each 3 kCN, kCC, and kCR Containment Cij by a subset. 
The restriction is valid if the hypothesis retains the same truth value. Evaluation attempts to find 
The kCN containment algorithm partitions each U,J into a valid configuration for the hypothesis. Subdivision 
splits y-monotone subsets. It then applies the LP restriction con­ a hypothesis C into C and C+ such 
that C is equivalent to tainment framework of the previous section to solve con­ C-or C+. tainment for 
the y-monotone configuration spaces. The fol­lowing section presents the y-monotone containment al­ 
2.3.1 LP Restriction. gorithm. Section 3.2 describes the monotone partitions and proves the running of 
the overall containment algorithm is The constraint that tJ ti c C,l can be represented by O((mn)k log 
n). lCtj ] linear inequalkies, where lC;j I denotes the number of edges of C~j. The constraint linear 
progmm (CLP) is the 3.1 y-Monotone Configuration Spaces. collection of all these inequalities, O ~ i 
< j ~ k. For each g, h, O < g < h S k, LP restriction replaces Cg~ by the This section presents an algorithm 
for kCN under the as­ mnge C ~ of feaaible values of th t$under the constraints sumption that each U%j 
is y-monotone: each horizontal line of the &#38;LP. intersects IZj in a single line segment, a single 
point, or the I Figure 3: Lower Bound for kRN Containment: n = 60. (Container empty set. For this version 
of LP restriction, each Ctj is an infinite horizontal strip of the form aij > ~ > bij. Each con­ straint 
of the CLP is of the form ~j y; ~ aij or yj w z bij, where ti=(G,yi), O$ i<j~k. Initially, the algorlthm 
sets a~j and bij to be the maxi­mum and minimum y-coordinate of Uij, O ~ i < j < k (or +CO and/or m in 
case of unbounded Uij ). To accomplish splitting, the algorithm picks i, j such that there exists ver­tex 
vij = (~iy, yii ) of Uij in the interior of C~j. It uses the splitting line g = yij. If no such v,j exists, 
then all Ctj (1 Uij will be convex trapezoids, and it applies evaluation. Lemma 3.1 Assuming lUil I< 
2m, 1~ i < j ~ k, the y-monotone kCN algorithm runs in time O (logn) . J_J(lUO~l +m) . l~i~k ()  Proofi 
(Summary.) When we solve the CLP, the output configuration will have a set of critical constraints: a 
con­straint is critical if tj-t,= aij(or btj ). Under the assump­tion of general position, no more than 
k constraints can be critical. (Recall that to = (O, O), and so there are only k variables y;.) The hypotheses 
we visit form a binary tree: each C has children C-and C+. We claim that we can label each hy­pothesis 
with a unique set CRIT(C) of k constraints: let CRIT(C) be the critical constraints from one of the calls 
to ORACLE when we restrict C. We can assume that ClUT(C) contains a constraint corresponding to its parent 
s splitting line. If C is an ancestor of C, then CRIT(C) cannot contain thk constraint. If C is a cousin 
of C, then the only way they can have a common configuration is if tj t; lies on the cutting line y 
= yij of their nearest common ancestor. Yet, even in that case one critical set will contain y ~ ~i~ 
and the other will contain y > ytj, so they will not be the same. The cost of solving a CLP depends only 
on k, which is fixed. Each constraint corresponds to a vertex of some Uij. The running time is the number 
of ways of selecting k vertices from the Uij polygons. The log n factor comes from binary search to determine 
the subset of vertices of fJtJ inside Cil. Fhally, the cost of evaluation is constant because each Cij 
n Uij is a trapezoid. 3.2 Nonmonotone Configuration Spaces. Now we return to the original kCN problem. 
The kCN al­gorithm separates each Uil into connected components and then cuts each component into y-monotone 
components by extending a cut upwards from every reflex local y-mrwimum and downwards from every reflex 
local ~-minimum (see Fig­ure 4). Then it calls the y-monotone kCN algorithm with Figure 4: Partitioning 
a Polygon into y-Monotone Compo­nents 1I I111 1I , 1 [ II II I is interior of outlined region. Polygon 
P, is grey rectangle.) Lemma 3.2 For 1 5 i < j < k, U,J has two y-monotone components with up to 2m 
vertices. For 1 ~ i < k, UOZ has O(n) y-monotone components with a total of O(mn) vertices. Proofi For 
1~ i < j ~ k, P, and P, axeconvex with up to m vertices, and therefore Pi @ Pj is convex with up to 2m 
vertices [12]. Its complement U,j = P, @ Pj has two reflex local y-extremes. Fortune [11] proved PO@ 
-P; has O(lPollPi 1) = O(mn) vertices if Pi is convex. He used a generalized Voronoi di­agram. Each component 
of Uoi = PO @ P, must contain a Voronoi vertex, and there are only O(n) of these. Each reflex y-~aximum 
of UO, is a sum of a reflex y-maximum of C = PO and a y-maximum of Pi. But Pi has only one y-mzcdmum. 
Thus Uij has only O(n) reflex ~-maxima (or minima). Theorem 3.3 The kCN algorithm has running time in 
O((mn)k log n). Proof: Since each U,l, l<i<j~k, hasonlytwoy­ monotone components, there are only a constant 
number of ways of selecting a component from each.7 The cost of iterating over all ways of selecting 
a component U&#38; ~ U08 is the sum of O (logn) . ~ (lU&#38;/ + m) , I<i<k ()  every way of selecting 
a single y-monotone component from The constant 2b(b 1)/2 is odious, but it is possible to reduce it 
each U~j. to k! which is reasonable (compared to mb ) [15]. over all such selections. By the distributive 
property, this is algorithm can compute C~h and C~h from Cgk and C:h US­ o (logn) . l-J (Iuotl + no(n)) 
= o((mn)klogn). I<z<k () For kCC and kCR, each UO~ is already y-monotone and has complexity O(n) and 
O(1), respectively. Our claimed running times follow from Lemma 3.1. The running time for kCC (the complement 
of the container is convex) is the same as for kCC since each UO; can be covered by two y­monotone regions 
with O(rn + n) vertices. 4 kNN Containment The kNN containment algorithm follows the tiamework of Section 
2.3. In this case, the initial value of C,J is the convex hull of Uij, O ~ z < j ~ k (some of these Cij 
are equal to the entire plane). After restriction, if some C ij n U,J is not convex, then some edge e 
of this Uij intersects the interior of C~j. The algorithm splits C,$ using the line L contain­ing e. 
It is necessary to modify this algorithm to achieve the 0((m2 + rnn) 2k log n) running time bound. Section 
4.1 gives the running time without modifications. Section 4.2 shows how to reduce the number of calls 
to the ORACLE to 0((nz2 + nzn)2k). Finally, Section 4.3 shows how to dispense with the expensive ORACLE 
function and replace it with a O(log n) time operation. 4.1 Counting Range Vertices. In practice, we 
call the ORACLE function (Section 2.3.1) to compute the vertices of each range. Each time the oracle 
generates a new vertex, we can label it with the critical con­straints of that solution to that CLP. 
This time, there are 2k critical constraints because we now have 2k variables, the x and y coordhates 
of t1,tz,....tk.For a given hypothesis C, the same set of critical constraints can label at most one 
ver­tex in each restricted C ~. The same reasoning as the proof ? of Lemma 3.1 applies. 1 Each new vertex 
in some restricted C~h clearly has not appeared in any ancestor hypothesis. 2) If it appears as a new 
vertex in a cousin hypothesis, its la­bel will be difTerent: one of the critical constraints will have 
a ~ instead of a ~. Hence each label appears 0(k2) = O(1) times. 4.2 Reducing Calls to ORACLE. The LP 
restriction algorithm of Section 2.3.1 is wasteful be­cause it recalculates many old vertices. This did 
not matter for kCN because the extra cost only depends on k. A faster kNN algorithm does the following 
when splitting C;j. Let L be the splitting line, let ab = L fl C,j, and let c,; and C: be the two halves 
. Forl~g<h~k, g#?orh# ~, define C;h to be the result of replacing C,~ by C,; and re­ stricting C@. Define 
C~k analogously. Subdividing C into C-and C+ and restricting both sub-hypotheses is equiva­ lent to calculating 
all the C~h and C,$h polygons. Instead, to do this more efficiently, the algorithm computes C;h: the 
result of replacing Ctj by ab and restricting Cgh. It M clear that C;h = C;h n c~h and it only contains 
new vertices. Assuming the vertices of each C,j are stored in the appro­ priate data structure (such 
as a balanced binary tree), the ing time 0( [fJ7~hI log lc~h /). Details are given in a technical report 
[16].  4.3 Final kNN Algorithm. In fact, it is possible to dispense with the ORACLE and compute each 
vertex of C:h in time O (log n). Suppose the algorithm is at a vertex w of Cjh. It computes the neigh­boring 
vertices of C$ as follows. For each of the 2k critical constraints of v it removes one constraint and 
computes the line C in Rbk corresponding to the remaining 2k 1. It projects L into each Ci3 and intersects 
it with C,j,. It projects the resulting segments back onto L. It projects the intersection of these segments 
into Cgh. Out of the 2k re­sulting segments, the two forming the largest angle are the edges of c~k neighboring 
v. Theorem 4.1 The LP restriction algorithm for all-kNN runs in O((m2 + rrm)2k log n) time. Proofi There 
are 0(m2) or O(rnn) (which are both 0(m2+ inn)) ways that a vertex of Pa can touch the extension line 
of an edge of Pj. Thk implies that the edges Of lJij lie on 0(m2 + mn) lines. Each such line can contribute 
at most two vertices to the convex hull of U,J (the initial C~j ). Thus the total number of constraints 
is 0(m2 + inn). The total number of vertex labels (and hence vertices) is 0((m2 + mn)zk ). The cost of 
generating each new vertex is log&#38;ithmic in the number of previously generated vertices, which is 
0(log(m2 +mn)2k) = O(log n).s All other costs are O(log n) per vertex. Details are given in a technical 
report [16]. For kNC, each IUO, I has O(n) edges, and for kNR, each Uoi is a rectangle. The running times, 
O((m2 + n)2k log n) and 0(rn4k log m) follow from counting sets of 2k critical constraints. 5 kNminC 
and kCminC Enclosure Problems This section gives an algorithm for the lcNminC and kCminC enclosure problems: 
place k polygons into the minimum area convex polygon with edges of fixed orientation. We define the 
area function and prove that it is Lorentzian. As a con­ sequence, for any convex set of configurations, 
the minimum area configuration appears at a vertex. Since our contain­ ment algorithms generate a convex 
cover of the set of vflld configurations, we can compute the minimum area enclclsure by visiting all 
the vertices. 5.1 Convex (Lorentzian) Area Function. Let dl, dz, da,..., d~ be a fixed set of unit vectors 
in coun­ terclockwise order about the origin. Define AREA(rl, dl, rz, dz, . . ..r~. dn) In other words, 
the edge e; of the polygon has outward unit normal vector d~, and its distance to the origin is r~. (We 
al­low the case in which the foot of the altitude from the origin ei+ to be the area of a convex polygon 
bounded by lines d (z, Y) <rl, l~l~n. Recall max(log m, from log n). Section 1.1 that we use log n in 
place of  to the line of the edge does not lie on the edge.) This section gives a formula for AREA and 
proves that it is Lorentzian. ~j+l di+l A 5.1.1 Convexity Theorem. Thk section gives a formula for AREA 
and states the the­orem that it is a convex function on the domain r, > 0, i=l,2, . . ..n. Theorem 5.1 
For any fized area a >0, the set of points of the form (rl, r2, r3, ...,r~) in R such that r, > 0, i 
= 1,2,3,..., nand AREA(rl, dl, rz, dz, . . ..~n. dn) > ~ is convex. More generally, the set of all (rl, 
rz, ..., rn ) with AREA = a consists of two convex hyperbolic sheets, only one of which intersects the 
positive quadrant : ri > 0, i = 1,2, ..., n. To prove Theorem 5.1, we must demonstrate that AREA is a 
Lorentzian quadratic form: it has exactly one positive eigenvalue.g Furthermore, the corresponding eigenvector 
must have all positive components. These facts are enough to establish the theorem. Actually, this section 
proves the theorem in a slightly leas dkect manner. First, it establishes Theorem 5.1 when dl, dz,..., 
dm are equi-angular about the origin. Second, the result is extended to rational angles: the angle between 
di and di+l is a rational multiple of 27r. A continuity argument proves the theorem for general dl, dz,..., 
d~. 5.1.2 Formula for Area. Lemma 5.2 AREA(rl, dl, rz, dz, . . ..r~. d~) = n 2r~r~+l (r? + r?+l) cOS&#38; 
I (3)z 2 sin f?~ inl whew Tn+l = rl, dnfl = dl, and 0~ is the angle between di and di+l. Proofi As depicted 
in Figure 5, suppose edge ei and ei+l share common vertex v,. Since vi lies on both edges, it follows 
that vi . d, = rz and v, . di+l = r,+l. Setting vi = ad~ + bd~+I and solving for a and b yields, r, 
r;+ld, . di+l rt+l ridi . v, = d,+ +1 di+l (4) 1 (d, . di+l)2 1 (di . di+l)z r* ri+l COS@i r,+l 
ra COSOi . da + di+l. (5)1 sin26~ 1 sin2 @i The region of the polygon inside the angle between di and 
di+l h~ area, ~, = (r,di) xvi+ vi x (rt+ldi+l) * ( 2 Ti+l Ti COS 08 Ti rz+l cos(l = + ri+t )di X di+l 
i 2(1 sinz 8,) 2(1 sin2 0,) 2riri+l (r: + r~+l) COS 0, = 2 sin O.i  A quadratic form ~ a., r. ~j 
~rrespOnds tO a symmetric matrix [a;j]. In this paper, the eigenvectors and eigenvalues of the quadratic 
form are defined to be those of the symmetric matrix. Figure 5: Direction vectors di, di+l. Edges ei 
and ei+l at dktance r, and r,+l. Vertex v,. The area of the polygon is the sum over all such regions. 
9 5.1.3 Equal Angle Case. Lemma 5.3 Theorem 5.1 holds if 81 = 82 = % = . = O.. Proofi Let 0 = 2ni/n. 
The vector (rl, rz, ..., r~) is an eigenvector with eigenvalue ~J of the AREA function (of its symmetric 
matrix) if Ti 1 -2(COS@)ri + rt+l = ~r i=l,2,3, . . ..n. J ;! sin O (The left hand is just the partial 
derivative of Equation 3 with respect to r,.) Let u = cos 8 + i sin O be the primitive nth root of unity. 
We claim that for j = O, 1,2, ..., n 1, the complex vector (uP, VJ2~,W3J, ..., Wn$ ) is an eigenvector 
with eigenvalue Cosje Cose AJ=2 sinf3 Note that thhi eigenvector is positive only for j = O. It is 
zeroforj=1orj=n 1,anditisnegative forj= 2,3,4 ,. ... n 2. One can prove the claim by substitution for, 
Aj and ri (= W J ), Ti 1, and ri+l. Divide out a factor of w ] and apply the identity uP + w j = 2 cos 
jO. The claimed eigenvector is complex, but takkg the real or imaginary parts yields n real eigenvectors: 
(1,1,1,...,1); (cosjO, cos 2j@, cos 3j8,..., cos njO), 0< j < n/2; (sin jO, sin 2j0, sin3j8,... , sinnjO), 
0< j < n/2; (1, 1, 1, 1,...,1, l), if n is even. The only eigenvector with positive eigenvalue is (1, 
1,1,..., 1) which clearly points into the (posit ive quadrant . Suppose that (z1, $2, ..., x~) are the 
coordinates of (r~, rz,... , r~ ) with respect to the orthonormal baais of eigen­vectors. Under thk change 
of coordinates, the area becomes Alz; + Azz; + A3Z: + . . . + Amcc~. The constraint AREA ~ a can be written, 
Since only Al is positive, this is indeed a pair of hyper­boloids, only one of which lies in the direction 
of the first eigenvector. This fact implies Theorem 5.1 for the equi-angle case.  5.1.4 Rational Angie 
Case. Lemma 5.4 Thwrern 5.1 is also true if the angles of dl, d2, ds,.. ., d~ are rational multiples 
of 27r. Proofi Let n be the common denominator of all the ratio­nal multiples. Lemma 5.3 implies that 
the theorem is true if we include all rational angles with that denominator. To have only some angles 
with that denominator, we need to selectively eliminate some of the edges. Suppose we want to keep edges 
eh and e~, but we want to eliminate ei, h < i < j. Slightly generalizing Equation 5 tells us that the 
intersection of eh and ej is rh -r~Cos &#38;J V, Vt COS8hj t)hl= dh+ d 1 Sinz @hj 1 Sinz 8h~ J where 
tih~ is the angle between dh and d~. Edge e, wiIl have zero length if its he passes through Vhj: r, = 
Vhj . di. Thki is a homogeneous linear constraint on rh, r,, rj. Adding thk constraint is equivalent 
to intersecting the convex re­gion AREA(rl, dl, rz, dt,. ... r~, d~) 2 a with a hyperplane through the 
origin which of course yields another convex re­gion. Projecting into the space of live dimensions, all 
r. such that i/n is one of the desired fractions, also preserves convexity. 5.1.5 Proof of Lorentzian 
Property. Finally, we can prove Theorem 5.1. Proofi We can approximate the angles of dl, dz, ds,..., 
d~ by rational multiples of 2T. The eigenvalues are roots of the characteristic polynomial and therefore 
vary continuously with angle. Taking the limit with better and better rational approximate ions preserves 
the signs of the eigenvalues and the signs of the components of the unique eigenvector with positive 
eigenvalue. E   5.2 Enclosure Algorithms. Without increasing the running time of any of the contain­ment 
algorithms, we can enumerate all vertices of each con­vex cover of the set of valid configurations. The 
following section shows that Theorem 5.1 implies that the minimum area enclosure occurs at a vertex, 
although we might have to add O(n) extra constraints. Using Equation 3, we can com­pute the area of the 
enclosure at each vertex in O(n) time. Section 5.2.2 describes how to add the extra constraints and otherwise 
modify the containment algorithms to solve the minimum enclosure problem. 5.2.1 Applying Theorem 5.1. 
In an enclosure problem, there is no container polygon. In­stead, we let pk take on the role of PO and 
set tk = (O, O). For a given configuration (tl, tz, ts, ..., tk = (O, O)) of PI, P2, P3, ..., Pk, the 
value of rj depends on which polygon P, + ta sticks out farthest in the direction of dl. Assume for the 
moment that for each dj, thk polygon is unique. In thk case, rl, rt, rs, ..., r~ depend linearly on tl, 
tt, ..., tn. Lemma 5.5 If rl, rz, ra, ..., r~ depend linearly on tl, t2, . . . , t~ at the solution to 
minimum area enclosure, then (tl, t2, t3,..., tk) is a vertex of one of the convex subsets of the space 
of valid configumtion~. Proofi Suppose the minimum area configuration lies in a convex subset C of the 
set of valid configurations but it does not lie at a vertex of C. (Assume it lies on the lowest dimensional 
facet possible.) Let the area be a. Then there must be some dwection At= (Atl, Atz, Ats,..., Atk) such 
that the configuration can move in both of the two dkections At or At without leaving C. By Theorem 5.1, 
the set AREA ~ a is convex, and therefore one of these two dkections will not point into the interior 
of thk convex set. Therefore, we can move the configuration in some direction that does not increase 
the area of the enclosure. We can continue this motion until the configuration is about tcl leave C, 
at which point the configuration is on a lower dimensional facet of C. This contradicts the assumption 
that the stsrting facet was of the lowest possible dimension. Suppose two polygons Ph + kh and P, + t, 
stick out equally far in the dkection d]. Then the mapping from tl,tz,...,tnto rl, rz, rs, ..., r~ will 
not be linear (it will be only piecewise linear) unless we add the constrairrt that l h + th and P; + 
t, stick out equally in that dkectiom Let V$J be the vertex of P, thathas maximum value of Vtj . dj over 
all vertices of P,. The additional constraint on th and t%is (th+vhJ) .dJ=(tt+Vtj). dj. (6) Since there 
are k polygons and n directions dj, there are ,%(Ic l)n/2 = O(n) such constraints.  5.2.2 Modifying 
Containment Algorithms. To solve lcNminC enclosure, we simply add the O 7t) ex­tra linear constraints 
of Equation 6. There are O(rn t ) con­straints arising from possible vertex-edge (actually, edge ex­tension) 
contacts among the polygons. Also, at each vertex of the configuration space, evaluating the area (Equation 
3) uses O(n) time. Since there are only 2(k 1) variables (the coordinates of tl,tz,ts,...,tk-1),the 
total time to find the minimum enclosure is 0((m2 + n)2k 2(n + log m)). As far as lcCminC is concerned, 
each pair of convex poly­gons can have at most O(m) vertex-edge contacts. Apply­ing the same reasoning 
as the previous paragraph yields a running time of O((rn + n)2k 2 (n + log m)) for kCminC en­closure. 
If m is big and n is small, for instance if the enclosure is a rectangle (n = 4), then we can obtain 
a better running time by modlfyi~ the kCN algorithm of Section 3. Since the container pk is the complement 
of a convex pol,ygo% generating a convex cover of the valid configurations takes O(mk -L log m) time, 
the same as (k l)CC containment with n = m. The cover consists of O(rnk-l) convex re­ gions, each with 
constant complexity. Redefine Cij to :stand for the convex range of tj t,over all valid configurations 
(tl, t2, t3,..., tk ). Each C.j has constant complexity. AS the previous section stated, there are O(n) 
additional con­ straints (Equation 6) to be considered. At most 2k --2 of these can be critical. Iterate 
over all 0(n2k-2) waya (of ae- Iecting 2k 2 additional constraints. Checking a particular selection 
takes constant time: if one constraint is applied to [6] K. Daniels and V. J. Milenkovic. Column-Based 
Strip Pack­t~ -th, then Chi is replaced by a he segment; and if two ing using Ordered and Compliant 
Containment. In Proceedings of the ACM Workshop on Applied Computational Geornetvy, constraints are 
applied, ch, is replaced by a point. In all Philadelphia, Pennsylvania, May 27-28, 1996. cases, the complexity 
remains constant. Total time to solve kCminC under th~ method is O(mk-l (n2k-1 + log m)). [7] K. Daniels, 
V. J. Milenkovic, and Z. Li. Multiple Containment Methods. Technical Report 12 94, Center for Research 
in Com­puting Technology, Division of Applied Sciences, Harvard Uni­6 Open Problems versity, 1994. [8] 
0. Devillers. Simultaneous Containment of Several Polygons: The lcNN algorithm misses the lower time 
bound by a factor Analysis of the Contact Configurations. Technical Report 1179, of log n. The kCN algorithm 
also misses by a factor of log n, INRIA, 1990. if m is a constant. However, these results are for finding 
all solutions to containment. We know that we can find a single [9] K. A. Dowsland and W. B. Dowsland. 
Packing Problems. Eu. ropean Journal of Operational Reaearc&#38; 56:2-14, 1992. solution to 3CN in O(n 
10 n) time for constant m, which is % much faster than the O(n log n) running time of the more [10] H. 
Dyckhoff. A typology of cutting and packing problems. .&#38;. general kCN algorithm applied to k = 3. 
ropean Journal of Operations Research, 44:145 159, 1990. · Open Problem I: Establish upper and lower 
time [11] S. Fortune. A Fast Algorithm for Polygon Containment by I+anslation. In Proceedings of the 
12th Colloquium bounds for finding a single solution to kNN and kCN. on Automata, Langwage.s, and Programming, 
pages 189-198. Also prove that the current algorithms are output sen­ Springer-Verlag, 1985. sitive or 
develop output sensitive algorithms. [12] L. Guibsa, L. Ramshaw, and J. Stolfi. A Kinetic Framework 
The solutions to minimum enclosure problems kNminC and for Computational Geometry. In Pr0ceedirag8 of 
the 24th IEEE kCminC require that the convex enclosure have fixed ori-Sympo8ium on Foundations of Computer 
Science, pages 100­111, 1983. ent at ion edges. We are confident that we can solve the more general problem 
of finding the minimum area convex [13] A. Kaul, M.A. O Connor, and V. Srinivasan. Computing hull in 
time 0((m2 + n) 2k-2(m + log n)) for kNminCH and Minkowski Sums of Regular Polygons. In Proceedings of 
the 3rd Canadian Conference on Computational GeometW, Van­ O((m + n)2k-2 (m + log n)) for kCminCH. It 
is not clear couver, British Columbia, 1991. how to generalize the O(mk-l (n2k-1 + log m)) kCminC al­gorithm. 
[14] Z. Li. Compaction A lgor ithrns for Non-Convex Polvgons and Their Applications. PhD thesis, Harvard 
University, Division of . Open Problem II: Prove, disprove, or improve these Applied Sciences, 1994. 
bounds. [15] V. J. Milenkovic. Exact Algorithms for Multiple Containment. Algorithmic, special i8sue 
on Computational GeometW in All of this work only deals with translations, not rotations. Manufactun 
ng, accepted, subject to revi8ion8. . Open Problem III: Generalize these algorithms to [16] V. J. Milenkovic 
and K. Daniels. Translational Polygon Con­ translations and rotations. tainment and Minimal Enclosure 
using Geometric Algorithms and Mathematical Programming. Technical Report 25-95, Cen­ter for Research 
in Computing Technology, Division of Applied 7 Conclusion Sciences, Harvard University, 1995. A combhation 
of techniques from computational geometry [17] P. E. Sweeney and E. R. Paternoster. Cutting and Packing 
Prob­and mathematical programming yields faster solutions to lems: A Categorized, Application-Oriented 
Research Bibliogra­phy. Journal of the operational Re8earch Society, 43(7):691­ containment and enclosure 
than applying techniques from 706, 1992. just one of these areas. Acknowledgements: Thanks to Karen 
Daniels, Lisa Ventry Milenkovic, and Veljko Milenkovic for proofreading and suggestions. Thanks also 
to Shulim Kaliman for sug­gestions on the proof of the Lorentzian property. References [1] F. Avnaim. 
Placement et ddplacerraent de formes n gidea ou articult?es. PhD thesis, Universit6 de Franche-Comt4, 
France, 19s9. [2] F. Avnaim and J. Boissonnat. Simultaneous Containment of Several Polygons. In %oceeding8 
of the 3rd ACM S~mpo8ium on Computational Geometry, pages 242 250, 1987. [3] K. Daniels. Containment 
Algorithms for Nonconvez Polggona with Applications to Lcayoat. PhD thesis, IIarvard University, 1995. 
 [4] K. Daniels and V. J. Milenkovic. Multiple Translational Con. tainment, Part 1: An Approximate Algorithm. 
Algorithmic, special iante on Computational Geometrv in Manufacturing, accepted, nubject to rcvisiom?. 
 [5] K. Daniels and V. J. Milenkovic. Multiple Translational Con­tainment: Approximate and Exact Algorithms. 
In Proceedings of the 6th Annual ACM-SIAM Symposium on Di8crete Algo. tithms, 1995.    
			
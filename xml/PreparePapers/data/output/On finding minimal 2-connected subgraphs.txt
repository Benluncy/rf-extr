
 Chapter20 On Finding Minimal 2-Connected Subgraphs * Pierre Kelsent Vijaya Ramachandrant Abstract for 
finding a maximum independent set.) Define a subset of edges in a 2-edge-connected graph We present efficient 
parallel algorithms forthe problems of to be independent if its removal yields a spanning 2­ finding 
a minimal 2-edge-connected spanning subgraph of a edge-connected subgraph of the graph, Our first prob­ 
2-edge-connected graph and finding a minimal biconnected lem above amounts to finding a maximal independent 
spanning subgraph of a biconnected graph. The parallel set of edges in the input graph (w.r.t the independence 
algorithms for both problems run in polylog time using a system just defined). Similarly, the problem 
of finding linear number of PRAM processors. The problems studied a minimal biconnected spanning subgraph 
of a bicon­ in this paper are of importance in the area of reliable network nected graph may be phrased 
in this setting. Efficient design. deterministic parallel zdgorithms for finding a maximal independent 
set in an independence system are known Introduction for the special case where the size of a minimal 
depen- In this paper we present efficient parallel algorithms dent set is 2 or 3 ([8], [3], [14]). Unfortunately, 
for the for the problem of finding a minimal 2-edge-connected two problems discussed in this paper, a 
minimal depen­ spanning subgraph of a 2-edge-connected graph and the dent set may have size linear in 
the number of edges of problem of finding a minimal biconnected spanning sub­the input graph.graph of 
a biconnected graph. In both cases the corre-To find efficient parallel algorithms, we have to sponding 
problem of finding a minimum subgraph with make use of the special structure of the independencethe desired 
property has been shown to be NP-hard system. Consider the problem of finding a minimal 2­([6]). The 
problems considered here are of importance edge-connected spanning subgraph. Let the input graphin the 
context of network reliability: if the nodes of G have n vertices and m edges. We assume that G the graph 
represent computers and the edges represent is 2-edge-connected. The obvious sequential algorithmthe 
transmission links, a minimal 2-edge-connected sub­finds a minimal 2-edge-connected spanning subgraph 
graph corresponds to a minimal interconnection pattern of G by examining the edges of G one at a time 
and that tolerates any single link failure, while a minimal bi­removing an edge if the resulting graph 
is a 2-edge­ connected subgraph represents a network that will not connected spanning subgraph of G. 
The total time is be disconnected by any single computer failure, dominated by m calls to the algorithm 
for testing 2- A similar problem known as the transitive com­edge-connectivity ([25], [18], [20], [23]), 
giving a time paction problem has been considered by [7] for di­bound of O(rn(n + m)). The time can 
be brought down rected graphs: given a strongly connected digraph, find to O(m + nz) by first finding 
a sparse 2-edge-connected a minimal strongly connected spanning subgraph of it; spanning subgraph of 
G (see section 3). There is a they find an NC-algorithm for the problem. similar sequential algorithm 
with the same time bound All three problems are instances of a more general to find a minimal biconnected 
spanning subgraph of G. problem considered by Karp, Upfal and Wigderson In this paper we present efficient 
parallel algorithms ([13]): they define an independence system to be a for these problems: they both 
run in time 0(log3 n) with finite set together with a collection of subsets, called a number of CRCW 
processors close to (n + m)/ log n independent sets, with the property that a subset of (for the exact 
bound, see end of section 3). These an independent set is independent. In that paper the algorithms are 
the first efficient parallel algorithms for authors give parallel algorithms for finding a maximal these 
problems,independent set given an oracle for testing whether a set In the outer loop of both parallel 
algorithms we find,is independent. (They also consider parallel algorithms in the current subgraph of 
the input graph, a spanning tree that contains the smallest possible number of *Supported in part by 
NSF grant CCR89-10707. redundant edges (i. e., edges that can be removed without t Department of Computer 
Sciences, University of Texas, destroying the desired property -2-edge-connectivity Austin, TX, 78712. 
178 or biconnectivity). A similar step is used in each iteration of the transitive compaction algorithm 
of [7]. We augment such a spanning tree with a minimal set of edges restoring the desired property (2-edge­connectivity 
or biconnectivity). We use tree contraction to construct such a minimal augmentation. This part of our 
algorithm markedly differs from the corresponding step in the transitive compaction algorithm. As in 
[7] we show that O(log n) iterations of this procedure yield the desired spanning subgraph. In the next 
section we present the algorithm for finding a minimal 2-edge-connected spanning subgraph of a graph 
and in section 3 we describe our algorithm for finding a minimal biconnected spanning sulbgraph. 2 Finding 
a Minimal 2-Edge-Connected Spanning Subgraph We ShOW how to find a minimal 2-edge-connected span­ning 
subgraph of a 2-edge-connected graph G , i.e., a spanning 2-edge-connected subgraph of G that does not 
properly contain a spanning 2-edge-connected sub­graph. 2.1 A Parallel Algorithm. Let the 2-edge­connected 
input graph G have vertex set V and edge set E with IV 1= n and IE 1= m. Given a 2-edge­connected graph 
H, an edge e of H is H-redundant if H e is 2-edge-connected; it is H-essential otherwise. Let H be a 
2-edge-connected spanning subgraph of the input graph G. OBSERVATION 1. If an edge is H-redundant, then 
it is also G-redundant. LEMMA 2.1. There is a spanning tree in G that contains at most 2/3 of the G-redundant 
edges. Proo~ An essential component of G is a maximal subgraph of G having a spanning tree of essential 
edges. Let r denote the number of redundant edges in G and c the number of essential components in G. 
Fix a tree T in G with the smallest possible number of redundant edges of G. The tree T contains exactly 
c 1 redundant edges of G. Furthermore, if c > 1, then each essential component of G is incident with 
at least 3 redundant edges in G and hence, c ~ 2/3 . r. The claim follows.n We shall present our algorithm 
for finding a, minimal 2-edge-connected spanning subgraph of G in a top-down fashion. At the highest 
level it has the following struc­ture: Algorithm 1: Finding a minimal 2-edge­ connected spanning subgraph 
of G. Input 2-edge-connected graph G, Output Minimal 2-edge-connected spanning subgraph H of G. 179 
(0) Find a 2-edge-connected spanning subgraph H of G with less than 2n edges. (1) As long as H contains 
redundant edges, repeat the following two steps:  (1.1) Find a spanning tree in H that contains the 
smallest possible number of II-redundant edges. Call this tree TH. Root TH at an arbitrary vertex. (1.2) 
Determine a minimal subset S of the edges in H such that the graph TH + S is 2-edge­connected. Let H 
be the graph TH + S. For step (0) we compute an ear decomposition of G ([18], [20], [23]) and eliminate 
all trivial ears (i.e., those with no internal vertices). The resulting graph, H, is 2-edge-connected 
and has < 2n edges. For steps (1) and (1. 1) we need to determine the redundant edges in H. A separating 
pair of edges for H is a pair (el, ez) of edges of H such that the graph H el e2 is not connected. 
Note that an edge of H is H-redundant iff it does not occur in anY separating pair of edges for H. Hence, 
we identify the redundant edges in H by finding all separating pairs of edges in H. For this we modify 
the vertex triconnectivity algorithm in [4], [23]. We ~sign weight o to H-essential edges and weight 
1 to H-redundant edges and choose for TH a minimum sPanning tree in this graph By lemma 2.1 the tre~ 
TH contains at most 2/3 of the H-redundant edges. By observation 1 and the minimality of the set of edges 
constructed in step (1.2), we see that after O(log n) iterations of algorithm 1, H is a minimal 2-edge-connected 
spanning subgraph of G. We call a set of edges as found in step (1.2) a minimal augmentation for TH. 
To compute a minimal augmentation, we make use of a variant of parallel tree contraction ([22] [19]). 
A leaf chain in a rooted tree T is a sequence of tree nodes < vo, VI, ..., uk > such that v~ is a leaf, 
vi is the unique child of Vi_ ~ for i > 0 and the parent v of V. is either the root of T or it has at 
least 2 children. The vertex v is called the root of the leaf Chazn. The operation Shrink reduces a tree 
by removing the vertices in the leaf chains. Tree contraction reduces an arbitrary rooted tree to a single 
vertex by repeatedly applying the Shrink operation to it. It can be shown ([22]) that O(log n) applications 
of Shrink contract any tree on n nodes to a single vertex. The tree contraction will be performed on 
the tree Tlca rooted at the root of TH: the vertices of Tl,.a are the least common ancestors in TM of 
nontree edges in H (i.e., the lea s of the endpoints of those edges). Vertex v is a child of u in Tlca 
iff v is a descendant of u in TH and none of the internal vertices of the path from u to v in TH is an 
lca of a nontree edge. We now present the algorithm for finding a minimal augmentation for TH. For technical 
reasons we view the tree consisting of a single vertex as having a leaf chain with no root vertex; one 
more iteration of tree contraction will yield the empty tree. The fine-structure of step (2.2) in algorithm 
2 will be developed following lemma 2.2. EN denotes the set of nontree edges in H. Algorithm 2: Finding 
a minimal augment at ion for TH. Input Tree TH, edge set EN. Output Minimal augmentation for TH from 
edges of EN. (1) Initialize : liV := 0, R:= EN, and T := T,Ca. (2) As long as T is non-empty, perform 
the following actions for all leaf chains of T in parallel:  (2.1) Let C be the subset of edges in 
R whose lca is a vertex on some leaf chain of T. Let R:= R C. (2.2) Find a minimal subset A of edges 
in C such that TH + IN + R + A is 2-edge-connected. (2.3) Let IN:= IN U A. (2.4) Remove the leaf chains 
from T. LEMMA 2.2. Upon completion of algorithm 2, IN is a minimal augmentation for TH. Proof. A proof 
by induction on the iteration num­ber shows that the following statement holds before any iteration of 
step (2): (*) TH + IN + R is 2-edge-connected and every edge of IN is essential in TH + IN + R. Upon 
termination, R = 0 is empty and (*) implies that IN is a minimal augmentation for TH.[ Before elaborating 
on step (2.2), we need several definitions. Let V be a subset of vertices of Il. The operation of collapsing 
the vertices of V consists of replacing all vertices in V by a single new vertex v, deleting all edges 
in H whose two endpoints are in V and replacing each edge (z, y) with z in V and y in V V by an edge 
(v, y). In general the resulting graph is a Multigraph even if the original graph is not a Multigraph. 
The condensation of a graph H is obtained from H by collapsing each 2-edge-connected component of H (i.e., 
the vertices in it) into a new vertex (one per component). Note that the condensation of H is a tree. 
In the following H will always have TH as a subgraph; its condensation is to be rooted at the vertex 
into which the root of TH is collapsed. Consider an iteration of step (2). T represents Tic. at the current 
stage of tree contraction (it will change in step (2.4) at the end of this iteration). Let KELSEN AND 
RAMACHANDRAN L =< Vo, . . .,vk > be a leaf chain of T. The path in TH from V. to v~ is termed the stem 
of L. If e is an edge of TH and e is a nontree edge, we say that e covers e if e is contained in the 
fundamental cycle of el in TH. We shall now give a detailed description of our implement ation of step 
(2.2). II. denotes the graph TH + IN + R after step (2.1) of the current iteration and To denotes the 
condensation of Ho. LEMMA 2.3. For any subset A of edges in C, HO+.4 is 2-edge-connected ifl To + A is 
2-edge-connected.~ By lemma 2.3 we may chocse in step (2.2) of algorithm 2 any minimal subset A of edges 
in C such that To + A is 2-edge-connected. We construct such a minimal set of edges in three stages: 
in stage 1 we cover all edges of To that do not lie on any stem of a leaf chain of T; in stage 2 we cover 
all stem edges in To not covered in stage 1; in stage 3 we eliminate some edges added in stage 1 so that 
all the remaining edges are essential. Here is the algorithm for stage 1 of the implemen­tation of step 
(2.2): Algorithm 3: Covering the edges of To that do not lie on a stem of a leaf chain of T. Input Tree 
To, set C of nontree edges. Output Minimal subset Al of edges in C covering the edges of To that do 
not lie on any stem. (1) Let w be the set of leaves of To whose edge to their parent in To does not 
lie on a stem. Let G1 be the graph whose vertices are the nodes in W and whose edges are the edges of 
C between them. Find a spanning forest in G1. (2) For each tree ~ in this forest do the following: 
 (2.1) Root the tree at an arbitrary vertex. Deter­mine the depth of each node in T{. Mark all edges 
in T1 that connect a vertex at even depth with a child (at odd depth). Also, for each leaf in T1 mark 
the unique incident tree edge (if it is not already marked). (2.2) A marked edge in the tree is bad if 
both of its endpoints have at least two marked edges incident with them. For each node at even depth 
eliminate all bad edges to its children. (2.3) If a node at even depth loses all marked edges to its 
children in the previous step, mark a single edge to one of its children in T1. (3) For each leaf in 
VI that is not yet incident with a marked edge (i.e., for each isolated vertex of Gl) mark an arbitrary 
edge of C incident with it. Let Al be the subset of edges in C that are marked. LEMMA 2.4. Al is a minimal 
subset of edges in C covem ng all edges of To not lying on any stem. Proof. Since the lca of any edge 
of C lies on some leaf chain of T, itsuffices to show that Al is a minimal set of edges of C covering 
the leaves in V1. We first show that the edges in Al cover the leaves in M. If v is a leaf in tree TI 
of the forest, then its unique incident tree edge marked in step (2.1) will never be unmarked. Now assume 
that v is not a leaf. If its depth is even, it will certainly be incident with a marked edge after step 
(2.3). If its depth is odd, the edge to its parent in T1 can be unmarked only if one of its children 
is a leaf. The connection to that child is marked in step (2.1) and will never be unmarked. Finally, 
any isolated vertices in G1 (all of whose incident edges of C connect to nodes outside ~) are covered 
in step (3). Hence, every leaf in V1 is covered by an edge of Al. To establish the minimality of Al, 
fix an eclge in Al. If it was marked in step (3), then only one endpoint of this edge is in VI and this 
endpoint will lie on a single marked edge. For the remaining edges of Al, observ,e that edges that were 
bad after step (2.1) were removed during step (2.2) and all edges marked in step (2.3) me good edges. 
Hence, every edge of Al has at least one endpoint in V1 that does not lie on any other edge of Al, and 
therefore Al is minimal.o In stage 1 (given in algorithm 3) we coveredl all edges of To that do not lie 
on any stem and possibly some stem edges. In the second stage we proceed to, cover all uncovered stem 
edges in To. The algorithm we use here is similar to an algorithm in [22] for finding a lminimum feedback-vertex-set 
in a reducible flow graph. Let 111 be the graph If. + Al. Let T1 be the condensation of H1. Fix a leaf 
chain L of T. Let EL be the path in TI consisting of those edges of TI that are edges on the stem of 
L. For vertices u, v cm PL, let u ~ v (u < v) denote the fact that u is a descendant of v in T1 (or a 
proper descendant); for an edge e of C linking distinct nodes of PL we denote by nl [[e), nz(e) the endpoints 
of e such that nl (e) < n2(e). We call nl (e) and ra2(e) the lower and upper endpoints of e, respectively. 
The following algorithm covers the edges of T1 (stage 2); it is performed in parallel for all leaf chains. 
Algorithm 4: Covering the stem edges. Input Tree T1, edge set Cl = C Al. Output Minimal subset Az of 
Cl covering the edges in T1 . (1) For each vertex v on PL find an edge e(v)l in Cl (if there ia one) 
such that nl (e(v)) = v and no edge e exists with nl(e ) = v and n2(e(v)) < n2(e ). 181 (2) Construct 
the auxiliary digraph DL defined as follows: the vertex set of DL is the set {e(v) : v is a vertex on 
PL }. There is a directed edge in DL from e to e iff nl(e) < nl(e ) < ~2(e) < ~2(e ) and no e exists 
with nl(e) < nl(e ) s nz(e) and nz(e ) < nz(e ).  (3) Compute a maximal path in DL starting at e(v) 
 where v is the lowest vertex (i.e., a leaf) on PL. Let Af) be the set of edge of Cl that correspond 
to vertices on this path. Let Az = UL A2 L) . Let H2 be the graph Ill + Az. OBSERVATION 2. The lower 
endpoints of edges in A(L) am all distinct. Furthermore, the upper endpoints 2 (L) of the edges in A2 
are all distinct. LEMMA 2.5. The edges in A2 cover the edges of TI minimally. ProoJ We first show that 
the edges in A&#38;) cover the edges of PL. Assume for a contradiction that e is the lowest edge on PL 
not covered by any edge in A$). Consider the subset S of edges of Cl that cover e. Since H1 + Cl is 2-edge-connected, 
S is nonempty. Let e be an edge of S. Since e is the lowest uncovered edge on PL, the lower endpoint 
of e lies between the endpoints of some edge e c ALL) (may coincide with its upper endpoint). Since the 
path in DL found in step (3) is maximal, e haa a successor edge on the path whose upper endpoint is at 
least as high on the stem as that of e . Hence, that edge covers e, contradicting the assumption that 
e is not covered. To see why A~) is minimal, let e.. . . ek be the edges in A~) in the order they occur 
as vertices on the maximal path in DL. By observation 2 and the definition of DL, the edge from the lowest 
vertex on PL to its parent in T1 is covered only by e.. Furthermore, the lower endpoint of ei+l lies 
strictly above the upper endpoint of ei _ 1. It follows that the edges between those endpoints are covered 
by ei only. Finally, again by observation 2, the highest edge on PL is covered only by ek. Hence, the 
edges of A~) cover the edges of PL minimally. Since each edge in AZ covers edges in exactly one leaf 
chain, we conclude that the edges in A2 cover all the PL s and hence TI minimally.o COROLLARY 2.1. Hz 
is 2-edge-connected. Proof Immediate with lemma 2.3, lemma 2.4, and lemma 2.5.0 IZ2 need not be minimal: 
the addition of A2-edges may render edges in Al H2-redundant. In the third and last stage we take care 
of this problem. We first note an immediate consequence of observation 2. OBSERVATION 3. Every vertex 
of PL is incident with at most 2 edges of A~). Based on this observation the following algorithm elim­inates 
redundant edges in Al. Algorithm 5: Making Al minimal. InputGraph H2, edge set Al. Output Spanning 2-edge-connected 
subgraph H3 of H such that each edge of Al in H3 is essential. For each leaf chain L do: (1) For each 
vertex w on PL incident with at least one edge of AK) (there are at most 2 such edges by observation 
3) ,do: (1.1) Let 13W be the 2-edge-connected component of HI that corresponds to w (possibly, BW is 
a single vertex). Let VW be the set of endpoints in 13W of the edges of A~). (1.2) Process the vertices 
v c VW sequentially aa follows: (1.2.1) If there is a unique edge e c Al incident with the vertex of 
To corresponding to v, remove e from Al. (1.2.2) If either an edge from an endpoint of e to its parent 
in To or an edge on the stem of L covered by e is a cutedge in the resulting graph, we put e back into 
Al. Let H3 be the resulting subgraph of H2. LEMMA 2.6. H3 is a 2-edge-connected spanning subgraph of 
H and each edge of Al is H3-essential. Proof. H3 is 2-edge-connected because an edge e that is removed 
in step (1.2.1) is put back in step (1.2.2) if the removal uncovers any edge previously covered by e, 
Any Al-edge that is H3-redundant haa an endpoint in ~ (see alg. 3) incident with an A2-edge but not with 
another Al-edge, Hence, that edge will be removed in step (1.2.1). Since different edges removed at the 
same time cover disjoint sets of edges in To, an edge is put back in step (1.2.2) only if it is H3-essential 
(uses observation 1) .H LEMMA 2.7, The set A = Al UA2 is a minimal set of edges such that Ho + A is 2-edge-connected. 
Proof By lemma 2.5 and observation 1, each edge of AZ is H3-essential. With lemma 2.6 the claim follows. 
o 2.2 Analysis. We now analyze the processor-time bounds of our algorithm. For the definitions of the 
various PRAM models we refer the reader to the survey KELSEN AND RAMACHANDRAN paper by Karp and Ramachandran 
([12]). One iteration of algorithm 2 can be implemented to run almost opt imally in time O(log n). Only 
the fact that no opt imal algorithms are currently known for bucket sort and for computing connected 
components prevents us from achieving optimal performance. For sorting we use the algorithm of Hagerup 
([11]) which sorts n integers in the range O. . . no(l) in time O(log n) with n log log n/ log n processors 
on a PRIORITY PRAM, We need to compute connected components at several places in our algorithm (see below). 
The most efficient connectivity algorithm ([2]) computes the connected components of a graph with n nodes 
and m edges represented by adjacency lists in O(log n) time on (m+ n)~(m, n)/log n processors of an ARBITRARY 
PRAM. Since more processor-efficient algorithms for these problems may be developed in the future, we 
shall adopt the following conventions: B(n) denotes the number of processors required to sort n integers 
in the range O. . . no(l) in time O(log n); c(n, m) denotes the number of processors needed to compute 
connected components of a graph with n nodes and m edges represented by adjacency lists in time O(log 
n) ; finally, A(n, m) stands for maz{l?(n), C(n, m)}. As mentioned above we have currently B(n) = n log 
log n/ log n (on PRIORITY) and C(n, m) = (n + m)a(m, n)/logn (on ARBITRARY). A step in our algorithm 
is A-optimal if it runs in time O(log n) with rnaz{C(n, 2n), B(n)} processors and is C-optimal if it 
runs in time O(log n) on C(n, 2n) processors. In these definitions we have replaced m by 2n since step 
(0) of algorithm 1 reduces the number of edges that need to be processed to less than 2n. We assume that 
the input graph G is represented by its adjacency lists. Step (0) of algorithm 1 is executed only once, 
Its complexity is dominated by that for finding an ear decomposition in G. This can be done in time O(log 
n) using C(n, m) processors ([18,20,23]). As pointed out earlier O(log n) iterations of algorithm 1 yield 
a minimal spanning 2-edge-connected subgraph of G. We analyze the work done in one such iteration. We 
identify H-redundant edges by finding separat­ing pairs of edges in H. For this we modify the algo­rithm 
for finding triconnected components given in [4], [23]. Thus, we can compute separating pairs of edges 
A-optimally. The complexity of computing TH is the same aa that for computing connected components on 
a graph with n nodes and at most 2n edges; we thus compute TH C-optimally. Algorithm 2 finds a minimal 
augmentation for TH using O(log n) levels of tree contraction. We prepare algorithm 2 by computing Tlca. 
For this we first determine the vertices in TH that are lea s of nontree edges; this can be done optimally 
in time O(log n) using the algorithm of [24]. Next, we define the equivalence relation R on the edges 
of TH by eRe iff there is a path in TH that contains e and et and does not have an lca of a nontree-edge 
as an internal vertex . We compute the classes of R by determining the connected components of the graph 
Ge defined as follows: the vertices of Ge are the edges of TH; there is an edge between (u, v) and (v, 
w) if v is the parent of w, u is the parent of v, and w is not an lca of a nontree edge. If we use u 
to represent the edge from u to its parent in TH, then we can extract the adjacency list for Ge from 
that of TH using list ranking. We finally note that v is a child of u in TICa iff the edge of u to some 
child lies in the same class as the edge from v to its parent. Hence, the following method gives the 
children of v in Tlca: sort the lea s in TH by the equivalence class ccmtaining the edge to their parent. 
From this sorted sequence we can build the adjacency list for Tlca optimally (using list ranking). Thus, 
TIC. can be computed A-optimally. We identify the leaf chains in T with the Euler tour technique on trees 
([27]). This takes time O(log n) Withl n/ log n processors. To prepare for stage 1 (algorithm 3) we compute 
the condensation of Ho. This amounts to cclmputing the 2-edge-connected components of Ho, which can be 
obtained using an ear decomposition algorithm ([18], [20], [23]) that is C-optimal. Step (1) of algorithm 
3 can be done optimally in O(log n) time using list ranking [1]. For step (2.1) we apply the Euler tour 
technique to each tree in the forest. All remaining steps of algorithm 3 take constant time with n processors. 
We now come to stage 2 (algorithm 4). The complexity of computing T1 (condensation of HI ) is the same 
as that for finding 2-edge-connected components in Hi. Steps (l),(2), and (3) reduce to optimal list 
ranking. The work in step (4) is dominated by the construction of DL. We can rephrase the problem of 
determining the edges of DL as follows: given a sequence of < n numbers determine the maximum for ~ 2n 
(possibly overlapping) intervals of this sequence. This can be done using an optimal algorithm of Gabow, 
Bentley, and Tarjan ([5]) that runs in time O(log n) With n/ log n CREW processors. The time spent in 
stage 3 (algorithm 5) is domi­nated by two calls to the algorithm for finding 2-edge­connected components. 
From the discussion above we see that algorithm 5 can be implemented C-optimally. In summary we see that 
one iteration of algo rithm 2 (finding a minimal augmentation for ~~H) runs in time O(log n) on A(nj 
2n) PRIORITY processors (or in time 0(log2 n) on A(n, 2n) EREW processors) ~ Altogether we ~et a running 
time of 0[10E3 n) with 183 C(n, m)/ logz n + A(n, 2n) processors on a PRIOR-ITY PRAM (or 0(log4 n) time 
with C(n, m)/ log2 n + A(n, 2rJ) processors on an EREW PRAM). 3 Finding a Minimal Biconnect ed Subgraph 
In this section we consider the following problem: given a biconnected graph G, find a minimal biconnected 
spanning subgraph of G, i.e., a biconnected spanning subgraph of G that does not properly contain a bicon­nected 
spanning subgraph, There is an obvious similar­ity between this problem and the one discussed in the 
last section. Indeed, many techniques used in the last section will be applicable here. Given a biconnected 
graph H, we call an edge e in H H-redundant if H e is biconnected and H­essential otherwise. With these 
definitions observation 1 holds as well as lemma 2.1 (since a biconnected graph is also 2-edge-connected). 
We shall therefore use the high-level strategy given by algorithm 1 (replacing 2­edge-connected by biconnected 
). We compute a biconnected spanning subgraph H of G with ~ 2n edges by finding an open ear decomposition 
for G ([4], [23]) and removing all trivial ears. By lemma 2.1, O(log n) iterations will yield a minimal 
biconnected spanning subgraph of G. We determine H-redundant edges by computing the separating pairs 
of vertices ([4], [23]) in the graph obtained from H by inserting a new vertex into each edge of H (we 
omit the details). To compute a minimal augmentation (with respect to biconnectivity) for TH, we use 
algorithm 2 (replace 2-edge-connected by biconnected ). We need the following fact. H denotes a subgraph 
of H containing TH. LEMMA 3.1. The intersection of a block of H with TH forms a subtree of TH.~ Let B 
be a block of H . By lemma 3.1 the intersection of B with TH is a subtree of TH. We call the root of 
that subtree the root of B. We call the subset of vertices of B that are different from the root of B 
the core of B. The block condensation of H is obtained by collapsing the core of each block of H into 
a single vertex and replacing multiple edges in the resulting Multigraph by single edges. Note that the 
block condensation of H is a tree. We root the tree at the root of TH. Fix an iteration of algorithm 
2. As in the previous section, we denote by T the tree representing TICa at the current stage of tree 
contraction and we call the path in TH corresponding to leaf chain L of T the stem of L (in TH). We denote 
by HO the graph TH + IN + R after step (2.1) of the current iteration of algorithm 2. The first step 
is to minimally augment Ho so that all the cutpoints in the resulting graph lie on stems (ofleaf chains 
of T) inTH. The following algorithm accomplishes this. Algorithm 6. Eliminating cutpoints that do not 
lie on a stem. Input Graph Ho, edge set C. Output Minimal subset Al of C such that HO+ Al has all its 
cutpoints on stems in TH. (1) Compute the block condensation To of Ho. (2) Let Vj be the set of leaves 
of To that correspond to the cores of blocks whose root (in T~) is not a vertex on a stem (in TH ). Cover 
the leaves in V( minimally with edges of C as in algorithm 3. Call the covering set of edges Al.  Let 
HI denote the graph HO + Al. LEMMA 3.2. For any subset F of C, Ho+F has a~l its cutpoints on stems iff 
F covers the vertices of V1. Proof. Assume that F covers the nodes of%. Con­sider a block B in Ho whose 
root v is a cutpoint of Ho and does not lie on a stem of TH. All leaves of To that are descendants of 
the vertex in To corresponding to the core of B will be covered by an edge of F (since the roots of the 
corresponding blocks do not lie on a stem). Since this holds for any block of Ho whose root is v and 
since the lca of any edge in F lies on a stem, v will not be a cutpoint in Ho + F. If F does not cover 
the leaves in W, then any uncovered leaf in U represents the core of a block in Ho + F whose root does 
not lie on a stem in TH, and hence Ho + F is not biconnected.n COROLLARY 3.1. All cutpoints of HI lie 
on stems in TH. Proof. Immediate with lemma 3.2 and the defini­tion of HI.0 Let H be a subgraph of H 
containing TH and such that all cutpoints of H lie on stems in TH. An external block of H is a block 
whose root lies on some stem in TH but does not include any edge of this stem; a block is internal if 
it is not external. We distinguish external and internal blocks for the following reason: we want to 
find a (minimal) set of edges whose addition to H1 will yield a biconnected graph. If all blocks in HI 
are internal, then the removal of a cutpoint v will break up the graph in exactly two components: one 
component contains all vertices other than v that lie in blocks whose root is v or a vertex below v on 
the stem containing v while the other component contains all remaining vertices (other than v). In this 
case augmenting H1 into a biconnected graph amounts to finding a set of edges connecting these two components 
for any cutpoint v, a relatively easy task as we shall see later. Thus, our goal is to eliminate the 
external blocks in HI. KELSEN AND RAMACHANDRAN Algorithm 7. Eliminating external blocks in HI. Input 
Graph HI, edge set Cl = C Al. Output Subset Az of Cl such that all the blocks of HI + A2 are internal. 
(1) Compute the block condensation TI of HI. Let ~ denote the set of leaves of T1 representing the cores 
of external blocks of H1. (2) Call an edge of Cl external if it links a vertex in the core of some external 
block B of HI with a vertex that lies outside of all the external blocks of HI that have the same root 
as B. Let V. be the subset of nodes in VI incident with an external edge. Cover the nodes of V. minimally 
with external edges using  algorithm 3. Let A;) be the subset of edges of Cl in the cover. (3) Consider 
the graph whose vertices are the nodes of W and whose edges are the edges of Cl between them. In this 
graph collapse the nodes of V, into a single vertex 2, Call the resulting graph H{. Find a spanning tree 
for Hj. Let AZ 2) be the set of edges of Cl in the spanning tree. Let AZ = Ay)uAy). Let Hz be the graph 
HI +A2. LEMMA 3.3. If T is not reduced to a single node, then all the blocks of H2 are internal. Proof. 
Let B be an external block of HI and let vB denote the vertex of Vl representing the core of B. If vB 
E Ve, then it follows from the definition of an external edge that B will be contained in an internal 
block of H2. Now assume VB E Vj V.. H{ is connected since otherwise the union of the blocks represented 
in a connected component of H; not containing z yields a block of Hz + C, contradicting the biconnectivity 
of H2 + C. The existence of a path in H{ from vB to z implies that B will be contained in an internal 
block of H2.fi The following related technical result will be needed in the proof of lemma 3.8. A critical 
endpoint of an edge of A!) is an endpoint of that edge in Ve that is not incident with another edge of 
A$). Note that each edge of A;) has at least one critical endpoint. LEMMA 3.4. Let F ~ C Al Az be minimal 
with the property that H = H2 -I-F is biconnected. All edges of Ay) are essential in H . Moreover, the 
critical (1) endpoints of an H -redundant edge in A2 are covered by edges of F. Proof. Fix an edge e 
in A2(2) . We shall prove that H e has a cutpoint and hence e is H -essential. The graph H; e is not 
connected and therefore it contains a connected component Co not including z. We refer to a block of 
HI whose core is represented by a node of Co aa a block of Co. If Ht e is biconnect ed, some edge e 
of F is incident with a node of C O. Edge e connects the cores of two external blocks that have the same 
root, say r, but are contained in different internal blocks of H2. W.1.o.g., the blocks of Co are contained 
in the internal block of H2 rooted at r-. It can be shown tha,t in this case r separates the vertices 
lying in blocks rooted at r or at a vertex below r from the other vertices. For the second part of lemma 
3.4, note that if aL critical endpoint of an edge e ~ A!) is not covered by an edge of F then H; e has 
a component not ccmtaining z and hence H2 e is not biconnected.[ If T is reduced to a single node in 
algorithm 7, every block of HI is an external block having as root node the root of TH. Thus, A$) =0and 
H2 = Hl + A~) is biconnected because HI + C is biconnected. In this case, by lemma 3.4 (with H = Hz), 
we may immediately proceed to the cleanup phase (a~lgorithrn 10 with As = 0). Henceforth, we shall assume 
that T is not reduced to a single node. Thus, there is a unique block, say 11o, that has the root of 
TH as its root node. We denote the root of It. by r.. For the following discussion we fix a leaf chain 
L of T. Number the vertices on the stem of L that are root:s of blocks of H2 consecutively as rl . . 
. rk, starting at the root closest to To. By lemma 3.1 and lemma 3.3 no two distinct blocks have the 
same root. Denote the block of Hz having root rj by Bj. Define the range of an edge e = (u, v) of C whose 
lca lies on L aa the integer pair (i, j), i ~ j, such that u is a vertex in Bi but is different from 
ri+l and v is a vertex in the core of 13j. We shall make use of the following property of the range. 
LE~~A 3.5. Let e be an edge of C whose lca lies on leaf chain L and whose range is (i, j) (i ~ j). Then 
the blocks Bi . . . Bj of H2 are all contained in a single block of H2 +e while the remaining blocks 
of Hz are also blocks of H2 + e. Proof. With lemma 3.1 and lemma 3.3 it is not difficult to see that 
the blocks Bi . . . Bj are exactly the blocks of H2 that intersect the fundamental cycle of e in TH in 
at least one edge. The claim follows. o We shall now describe how to find a minimal subset A3 of C such 
that H2 + A3 is biconnected. We solve this problem by reducing it to the problem of covering stern edges 
considered in the previous section (algorithm 4). Algorithm 8. Augmenting H2 into a biccmnected graph. 
Input Graph H2, edge set C2 = C Al A2. Output Minimal subset A3 of C2 such that H2 + A3 is biconnected. 
For each leaf chain L do : 185 (1) Let PL be the path B.... Bk , i.e., the vertices of PL are the blocks 
B.... Bk and there is an edge from .Bi-l to Bz for i= I,. ..)k. (2) BY mapping each C -edge of range 
(i, j) to the edge (l?~, Bj) for any i and j, we obtain a (multi) set CL of edges connecting vertices 
of PL. Find a minimal subset AL of edges in CL that cover the edges of PL by using algorithm 4 from the 
previous section.  Let A$L) be the subset of edges of C2 corresponding (L) to edges ofAL. Let A3 = UL 
As . Let H3 be the graph Hz + A3. LEMMA 3.6. H3 is biconnected. Furthermore, all edges in A3 are H3-essential. 
Proof. With lemma 3.5 it follows that H3 is bicon­nected if and only if each edge of PL is covered by 
an edge of AL (i.e., it lies on the fundamental cycle in PL of an edge of AL) for any L. By lemma 2.5 
and the bi­connectivity of Hz+ C, algorithm 4 produces a minimal set of edges covering each PL. We conclude 
that H3 is biconnected and each edge of As is H3-essential.n We now enter the cleanup phase. First, we 
eliminate redundant edges in A2 by resorting to a strategy similar to that used in the last section. 
We need the following result (reminiscent of observat ions 2 and 3). LEMMA 3.7. At most J vertices of 
any block of H2 are incident with an edge of A:). Proof. Fix a vertex (block) Bj on PL. By the definition 
of CL (see algorithm 8, step (2)), an edge of A$) can only be incident in H2 with a vertex in block Bj 
if the corresponding edge of CL has its upper endpoint (i.e., the one closer to B. on PL) at Bj+l or 
its lower endpoint at Bj 1 or is incident with Bj. By observation 3 at most 2 edges of AL are incident 
with Bj. By observation 2 at most one edge of AL has its upper endpoint at Bj+l and at most one edge 
of AL has its lower endpoint at Bj _l. We conclude that at most 4 (L) ­ edges of A3 are incident with 
vertices in Bj. Since the two endpoints of an edge of A3 lie in different blocks of H2, the claim follows.n 
Let As) denote the subset of A2-edges added at step (2) of algorithm 7. Algorithm 9. Removing redundant 
edges from A2. Input Biconnected graph H3, edge set A2. Output Biconnected spanning subgraph HA of H3 
such that every edge of A2 is H4-essential. For each leaf chain L, process first each block B on PL 
that is at an even distance from B. on PL (see algorithm 8) and then each block B at an odd distance 
from B. as follows: KELSEN AND RAMACHANDRAN (1) Determine the subset V~ of vertices of B incident (2) 
Every leaf of ~ that has become uncovered selects with an edge of A$). By lemma 3.7 we have a single 
edge of B. incident with it. Denote the set of edges selected at this step by B1 and denote the  [ V-B[<4. 
graph H4 BO + BI by H~l). (2) Process the vertices v of V~ sequentially as follows: (3) Using algorithms 
7, 8, and 9 find a minimal subset(2.1) If v is a node in the core of an external block (1) . B2 of B. 
 B1 such that H~l) + B2 is biconnected. of H1 incident with a unique edge of AZ m B, remove that edge 
from AZ. Let H~2) be the latter graph. (2.2) Determine if the resulting graph has a cut­ (4) Let B3 
be the subset of edges of BI that have point that is a vertex in l?, If it has one, put both of their 
endpoints covered by edges from the edge back into A2. A2 U A3 U B2. Run algorithms 7, 8, and 9 (starting 
with algorithm 7 with graph H4 2) B3 and edge Let HA be the resulting graph, set B3 as input) to find 
a minimal subset B4 of B3 LEMMA 3.8. H4 is a spanning biconnected subgraph of H and each edge of A2 is 
H4-essential. such that H~2) B3 + B4 is biconnected. Denote the latter graph by H5. Remove from Al all 
edgesProof. First, we show that Hq is biconnected. Fix that are not in H5. an iteration of step (2). 
Let H be the graph H3 LEMMA 3.9. H5 is biconnected and every edge ofminus the edges that have been removed 
at previous Al is H5-essenta al. iterations and that have not been put back. Assume inductively that 
H is biconnected. Denote by F the Proof. Call an endpoint of an Al-edge critical if it is set of edges 
removed during the current execution of in V1 and is not incident with another edge of Al. Since step 
(2.1). Suppose that H F has a cutpoint w in the edges of Al minimally cover the nodes in M, each block 
B of H2 and let e be the edge of B removed in Al-edge has at least one critical endpoint. It follows 
step (2.1). Note that a path in H between vertices z that an edge in B. has at least one endpoint incident 
and y (both # w) avoiding w yields a path between z with an edge of A2 U A3. Hence, each edge e of B1 
has and y in H F + e avoiding w: simply replace every exactly one endpoint covered by an edge of A2 
U A3 and occurrence of an edge of F e on the path by the path in the other endpoint is incident only 
with e. By lemma TH between the endpoints of this edge. Since the blocks 3.2 and lemma 3.8, H$) is biconnected 
and all edges of examined at one time are not adjacent on PL, the new B2 are H5-essential (with observation 
1). To see that path does not contain w. Thus, w is not a cutpoint in the edges of B4 are essential in 
H5, note that each node H F + e. It follows t hat the graph resulting from step (2J B3. Hence, againof 
VI is covered by some edge of H4 (2.2) is biconnected. Hence, Hq is biconnected. by lemma 3.2 and lemma 
3.8, we see that the edges of With the previous argument (and observation 1) we B4 are H5-essential. 
Finally, any edge in B1 B3 has also see that an edge e put back in step (2,2) is essential a critical 
endpoint that is not covered by an edge from in Hq. By lemma 3.4 and lemma 3.6, each H4-redundant AZ 
U A3 U B2 U B4; by lemma 3.2 it is H5-essential,B edge is removed in step (2.1). This completes the 
proof COROLLARY 3.2. The set A = Al U A2 U As is a of the lemma. o minimal set of edges such that Ho 
+ A is biconnected. For removing the redundant edges of Al in H4 we Proof. By lemmas 3.6, 3.8, 3.9 and 
observation 1,0need to use a different strategy since we do not have a An analysis similar to the one 
done in the lastresult such as lemma 3.7. section shows that this algorithm runs within the same Algorithm 
10. Pruning Al. resource bounds as the algorithm for finding a minimal Input Graph H4, edge set Al. 
2-edge-connected spanning subgraph. Output Biconnected spanning subgraph H5 of H4 such that each edge 
of Al is H5-essential. 4 Concluding Remarks (1) Let ~ be the set of leaves of To that correspond to 
The algorithms for the two problems considered in cores of blocks in Ho whose root (in TH ) does not 
this paper have a similar high-level structure: first, lie on a stem (in T~). Let e be an edge of Al. 
A compute a spanning tree of the input graph with the critical endpoint of e is an endpoint of e in ~ 
that smallest possible number of redundant edges; then, find is covered by no other edge of Al, Let llo 
be the a minimal augmentation for this tree. This strategy set of Al -edges whose critical endpoints 
are covered seems useful for finding minimal subgraphs of a graph by edges of A2 U A3. Remove the edges 
in B. from with respect to other properties. In particular this H4 . approach gives similar algorithms 
for the problem of quentially in time O(nz + n log n) ([15]). It is natural. to ask the question if the 
O(log n) bound on the num­ber of iterations of algorithm 1 is tight, andl the re­[16]lated question of 
whether the sequential time bound of O(rn + n log n) can be improved. In recent wcrk ([16]) we resolve 
these questions: we show that algorithm 1 requires @(log n) iterations in the worst case, both for ON 
FINDING MINIMAL 2-CONNECTED SUBGRAPHS 187 finding a minimal k-connected any k). These algorithms can 
be subgraph of implemented a graph to run (for se­ [151 3, manuscript, Department of University of Texas, 
Austin, TX, P. Kelsen, V. Ramachandran, Computer Sciences, January 1990. On jinding minima2 [17] 2-edge-connectivity 
and biconnectivity. We then pro teed to show that, despite of this negative result, there [18] is a linear 
time sequential algorithm for these problems, [19] References [1] R. Anderson, G. Miller, Deterministic 
parallel list [20] ranking, Proc. 3rd Aegean Workshop on CoImputing, Springer Verlag LNCS 319, 1988, 
pp.81-90. [2] R. Cole, U. Vishkin, Approximate and exact paralle[ techniques with applications to list, 
tree, and graph [21] prob2ems, Proc. 27th Ann. IEEE Symp. on Foundations of Comp. Sci., 1986, pp.478-491. 
 [22] [3] E, Dahlhaus, M. Karpinski, An eficient algorithm for the .9iWS problem, Technical Report TR-89-052, 
September 1989, ICSI, Berkeley, CA. [4] D. Fussell, V. Ramachandran, R. Thurimella., Finding triconnected 
components by local replacemerits, Proc. ICALP 89, Springer Verlag LNCS 372, 1989, pp.379­ 393. [5] 
H. Gabow, J. Bentley, R. Tarjan, Scaling and related techniques for geometry problems, Proc. 16th ACM 
 [23]Symp. on Theory of Computing, 1984, pp.135-143. [6] M. Garey, D. Johnson, Computers and Intractability: 
a Guide to the Theory of NP-Completeness, Freeman, San Francisco, CA, 1979. [24] [7] P. Gibbons, R. 
Karp, V. Ramachandran, D. Soroker, R. Tarjan, Transitive compaction in parallel via branch­ing, J. Algorithms, 
to appear. [8] M. Goldberg, T. Spencer, A new parallel algorithm for the maximal independent set probJem, 
SIAM J. [25] Computing, vol. 18, 1989, pp.419-427. [26] [9] H. Gabow, R. Tarjan, A linear-time aJgorithm 
for a special case of disjoint set union, JCSS, vol. 30, 1985, pp.209-221. [27] [10] D. Gusfield, Connectivity 
and edge-disjoint spanning trees, Inform. Proc. Letters, vol. 16, 1983, pp. 87-89. [11] T. Hagerup, 
Towards optimal parallel bucket sorting, Inform. and Comput., vol. 75, 1987, pp. 39-5,1. [12] R. Karp, 
V. Ramachandran, Parallel algorithms for shared memory machines, Handbook of Theoretical Computer Science, 
J. Van Leeuwen,ed., North Holland, 1990, pp. 869-941. [13] R. Karp, E. Upfal, A. Wigderson, The complemly 
of parallel search, J. C. S. S., vol. 36, 1988, pp.225-253. [14] P. Kelsen, An eficient para2Je2 algorithm 
for finding a maximal independent set in hypergraphs of dimension %connected sdgraphs, Tech. Report 
TR-90-16. June 1990, Department of Computer Sciences, University of Texas, Austin, TX 78712. P. Kelsen, 
V. Ramachandran, On finding minimal spanning subgraphs, manuscript, October 1990, De­partment of Computer 
Sciences, University of Texas, Austin, TX 78712. K. Menger, Zur allgemeinen It urventheorie, Fund. Math., 
vol. 10, 1927, pp.95-115. G. Miller, V. Ramachandran, Eficient parallel ear decomposition with applications, 
manuscript, MS RI, Berkeley, CA, January 1986. G. Miller, J. Reif, Parallel tree contraction and its 
applications, Proc. 26th Ann. Symp. on Foundations of Comp. Sci., pp.478-489, 1985. Y. Maon, B. Schieber, 
U. Vishkin, Parallel ear de­composition search (EDS) and st-numbering in graphs, Theoretical Comput. 
Sci., vol. 47, 1986, pp.277-298. C. Nash-WMams, Edge-disjoint spanning trees in graphs, J. London Math. 
Sot., vol. 36, 1961, pp.445­ 450. V. Ramachandran, Fast parallel algorithms for re­ducible f70w graphs, 
Concurrent Computations: Algo­rithms, Architecture and Technology, S.K. Tewksbury, B. W. Dickinson and 
S.C. Schwartz, ed., Plenum press, New York, NY, 1988, pp.117-138; see also Fast and processor-e ficient 
parallel algorithms for reducible flow graphs, Tech. Report ACT-103, November 1988, Coor­dinated Science 
Laboratory, University of Illinois, Ur­bana, Illinois, IL 61801. V. Ramachandran, Parallel open ear decomposition 
with applications to graph bicormectivity and tricon­nectiuity, invited chapter for the textbook Synthesis 
of Parallel Algorithms, J. Reif, ed., Morgan-Kaufmann. B. Schieber, U. Vishkin, On finding lowest common 
ancestors: simplification and paralleli.zation, Proc. 3rd Aegean Workshop on Computing, Springer Verlag 
LNCS 319,1988, pp. 111-123. R. Tarjan,Depth first search and linear graph algo­rithms, SIAM J. Computing, 
vol. 1, 1972, pp.146-160. W. Tutte, On the problem of decomposing a graph into connected factors, J. 
London Math. Sot., vol. 36, 1961, pp.221-230. R. Tarjan, U. Vishkin, An eficient para21e2 biconnec­tivit~ 
algorithm, SIAM J. Computing, vol. 14, 1984, pp.862-874.  
			

 STOC(Milwaukee 1981), 146-157. Reversal Complexity of Counter Machines Tat-hung Chan Department of 
Computer Science University of Minnesota Minneapolis, Minnesota 55455 Abstract It has long been known 
that deterministic 1-way counter machines recognize exactly all r.e. sets. Here we investigate counter 
machines with general recursive bounds on counter reversals. Our main result is that for bounds which 
are at least linear, counter reversal is polynomially related to Turing machine time, for both 1-way 
and 2-way counter machines and in both the deter- ministic and the nondeterministic cases. This leads 
to natural characterizations of the classes P and NP, and hence of the P =? NP question, on the counter 
machine model. We also establish reversal complexity hierarchies for counter machines, using a variety 
of techniques which include translation of Turing machine time hier- archies, padding arguments as well 
as more ad hoc counting arguments. Introduction A counter machine is a multipushdown machine whose 
pushdown stores operate as counters, i.e. have a single-letter alphabet. It is well known ,(Minsky [1961]) 
that deterministic 1-way counter ~machines accept exactly all r.e. sets. As in the case of Turing machines, 
attention is then directed to resource-bounded counter machine com- putations. The most popular resources 
are time, space, and the number of counters. Known results include relations and trade-offs among these 
re- sources, hierarchies based on them, as well as their relations to Turing machine time and space (Fischer 
et al [1968], Greibach [1976]). Most of these results concern polynomial time-bounded counter machines. 
 Another way to measure the resources used in a counter machine computation is to count the maximum number 
of reversals, i.e. alternations from increasing to decreasing and vice versa, that any counter makes. 
So far, only machines with constant reversal-bounded counters have been considered. Baker and Book [1974] 
showed that nondeterministic l-way such machines always accept Permission to copy without fee all or 
part of this material is granted provided that the copies are not made or distributed for direct commercial 
advantage, the ACM copyright notice and the title of the publication and its date appear, and notice 
is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, 
or to republish, requires a fee and/or specific permission. &#38;#169;1981 ACM 0-89791-041-9 /80/0500/0146 
$00.75 in linear time, and gave a semi-AFL characteri- zation of the class of languages accepted. Ibarra 
 [1978] showed that these same machines, like finite automata and pushdown automata, accept sets with 
effectively obtainable semilinear Parikh maps and hence have many decidable properties. Gurari and Ibarra 
[1979] proved that similarly restricted deterministic 2-way machines whose input comes from a single-letter 
alphabet are effectively equivalent to finite automata. In this paper, we consider counter machines 
with general recursive bounds on counter reversals. Whereas every r.e. set can be accepted by a non- 
deterministic 1-way machine with two pushdown stores each of which makes only one reversal (Baker and 
Book [1974]), we show that Main Result For bounds that are at least linear, counter reversal of l-way/2-way 
counter machines is polynomially related to Turing machine time, in both the deterministic and the 
 nondeterministic cases. Hence even for nondeterministic 2-way counter machines, recursiveness of reversal 
bounds implies recursiveness of the sets accepted. Using more precise formulations of the main results, 
we establish reversal complexity hierarchies on the counter machine models. These hierarchies have the 
interesting property that while for bounds that are at least linear, their complexity classes are closely 
related to Turing machine time com- plexity classes, they also contain nontrivial com- plexity classes 
for sublinear bounds. Some impli- cations of the main result for the P =? NP question and for Church's 
Thesis are also dis- cussed. The rest of this paper is organized as follows. Section i establishes the 
notation we use in the paper. In Section 2 we discuss how counter machines can enforce reversal bounds. 
It is shown that many natural functions f(n) can be constructed by deterministic counter machines using 
0(f(n)) counter reversals. Sections 3 and 4 contain our main results. They relate counter reversals on 
the counter machine model to time and space on both the counter machine and the Turing machine models, 
in the nondeterministic and the deterministic cases respectively. Section 5 discusses some of the consequences 
of these relations. In Section 6 we briefly sketch analogous results for 1-way counter machines, while 
in Section 7 we establish reversal hier- archies on the various counter machine models. Section 8 is 
devoted to concluding remarks. 1. Notation We shall assume familiarity with the basic theory of automata 
and formal languages, especially with Turing machines, abbreviated TM's. We use the abbreviation NTM 
when we wish to emphasize that the TM in question is possibly nondeterministic, and the abbreviation 
DTM if it is known to be deter- ministic. A T~i, N~ or DTM will refer to a machine with only one tape 
which serves as both input tape and work tape, unless the discussion pertains to computations that use 
less than linear work space. In such cases, we shall use 2-tape Turing machines in which one tape is 
a read-only input tape and the other tape is a read-write work tape, and refer to them explicitly as 
2-tape TM's, etc. A counter machine, abbreviated CM, consists of a finite control, a 2-way read-only 
input tape with endmarkers Â¢ and $, and finitely many count- ers. The counters can store only nonnegative 
integers, and the finite control can detect whether a counter is empty (i.e. stores zero) or not. Depending 
on the current configuration, i.e. the state of the finite control, the input symbol being scanned, and 
the subset of counters that are empty, the CM can choose, according to a finite set of transition rules, 
to change its state, move the input head one square in either direction, and increment or decrement its 
counters independently by at most one. A CM is deterministic if it has at most one choice of action under 
any configur- ation, and nondeterministic otherwise. By the usual convention, a CM accepts an input by 
enter- ing one of several designated final states with all counters empty. Without loss of generality, 
we also assume that a counter can only switch from decreasing to increasing when it is empty. Formal 
details are omitted and can be found in Hopcroft and Ullman [1969]. We write NCM instead of CM to emphasize 
that the machine can be non- deterministic, and we write DCM for a determin- istic machine. For a positive 
integer k, we write k-CM, k-NCM or k-DCM to indicate that the machine has k counters. For CM's and 2-tape 
TM's, we shall use the prefixes "2-way" and "l-way" to indicate whether the read-only input tape can 
be scanned more than once. In the absence of either prefix, 2-way input is assumed. If M is a TM or a 
CM, we let L(M) denote the set, or language, accepted by M. For a function f(n), a TM M is f(n) time-bounded 
if for every word w ~ L(M), there is an accepting computation of M on w.using at most O(f([wl) ) steps, 
where lwl is the length of w. Note that this definition does not preclude the existence of nonaccepting 
and accepting computations which exceed the given bounds. Similar definitions hold for f(n) space-bounded 
TM's and f(n) reversal- bounded CM's. However, observe that for 2-tape TM's, only space on the work tape 
is taken into account, whereas for CM's the reversal bounds apply to all the counters but not to the 
input head. P (respectively NP) denotes the class of languages accepted by polynomial time-bounded DTM's 
(respectively N~'s). 2. EnfoKcin~.Reversal Bounds In this section, we show that many natural functions 
can be enforced as reversal bounds by counter machines. For convenience, we take a reversal to encompass 
a growth from zero and the subsequent decrement back to zero. (Recall that we assume a counter can only 
switch from decreas- ing to increasing when it is empty.) The rever- sal bounds we consider will be arbitrary 
recursive functions of the length of the input. We say a fucntion f(n) is reversal-constructible if there 
is a DCM which, on input of length n, can create a counter of length f(n), with all counters making at 
most f(n) reversals in the process. A rever- sal-constructible function f(n) can be enforced as a reversal 
bound for 2-way CM's since a 2-way CM can first create the value f(n) and then use it to bound the number 
of counter reversals in the subsequent "true" computation. Thus in fact no computation can exceed the 
f(n) reversal bound. If f(n) is in fact reversal-constructible by a 1-way DCM, then it can also be enforced 
as a reversal bound for 1-way CM's. In this case, the l-way CM will compute f(n) in parallel with the 
"true" computation; it uses extra counters to count the reversals in the "true" computation, and accepts 
iff the "true" computation accepts using no more than f(n) reversals. Clearly, it is possible to have 
nonaccepting computations that exceed the f(n) reversal bound. However, if f(n) ~ n then this possibility 
can be eliminated as follows. In the first pass over the input w, encode w R (the reverse of w) into 
a counter as described in Fischer [1966] while simultaneously computing f(lwl). This encoding uses lwl 
rever-sals. With another ]w] reversals, we can decode R  w and obtain the encoding of w itself. Then 
simulate the original machine, using the value f(lwl) to bound counter reversals. Whenever the original 
machine moves its input head, the sim- ulator will obtain the next input symbol by (destructively) decoding 
the encoded w. Since the original machine is 1-way, there can be at most [w I such input head moves and 
hence lw] ~ f(lwl) counter reversals for decoding. Note that in both the 1-way and the 2-way cases deter- 
 minism is perserved. The following example shows that many famil- iar functions are in fact reversal-constructible 
by 1-way DCM's. Example 2.1 (Reversal-constructible functions) (i) f(n) = n or f(n) = c where c is 
a positive integer can clearly be constructed using a single 1-reversal counter.  (2) Suppose two counters 
hold positive numbers x and y respectively. Then using one auxil- iary counter, we can compute xy in 
a fourth  counter, all counters making at most [~] reversals. We simply increment the fourth counter 
by x for a total of y times, each time restoring x in one counter while destroy- ing it in another. 
 (3) For i = i, 2, let fi(n) ~ 1 be constructible using k i ri(n)-reversal counters. Then: (a) fl(n)+f2(n) 
is constructible using kl+k 2  max{rl(n),r2(n)}-reversal counters.  (b) fl(n)Ãf2(n) is constructible 
using ~+k2+3  fl(n) max{rl (n), r2 (n), [-~----] }-reversal coun- ters. This simply follows from (2). 
 147 (4) (5) (6) (7) f2(n) (c) fl(n) is constructible by implement- ing the exponentiation as f2(n) 
multipli- cations by fl(n). It suffices to use rfl (n) kl+k2+5 max{ r I (n), r 2 (n), f2 (n) l--~---] 
}-re- versal counters. By (i) and (3), all functions that can be constructed from the identity function 
and the positive constant functions by addition, multiplication and exponentiation are rever- sal-constructible. 
This depends on the fact that such functions are nondecreasing, so the function fl(n) in (c) of part 
(3) is either = 1 almost everywhere, or > 1 almost every- where. For the constructions above, the input 
is scanned only once. Using the technique of Ibarra [1978], one can in fact construct k n using only 
two k]-reversal counters but multiple scans of the input: multiplication of a value x in a counter by 
the input length n is implemented as x scans of the input while incrementing an initially empty counter. 
f(n) = [log n 7 can be constructed using three [~-~l-reversal counters. One simply copies n onto a 
counter, and then repeatedly divides by 2, counting the number of such divisions. f(n) = [nl/k I for 
any integer k _> 2 can be constructed using k O(f(n))-reversal count- ers. Call the counters CI,..., 
Ck_ 1 and A. The idea is to compute t,..., t k-I in C1,..., Ck_ 1 for t = 0,1,2,... successively, at 
the same time positioning the input head to a distance of t k from the left endmarker, until a value 
t is reached such that the right endmarker is first detected, i.e. such that (t_l)k < k n < t . A is 
an auxiliary counter. Initially all counters are zero and the input head is on the left endmarker, i.e. 
we are in the con- figuration corresponding to t = O. Induc- tively, to change from the configuration 
for t to that for t+l, we simply apply the binomial theorem, i.e. (t+l) i = i +.-.+ Clt + " I. (*) 
t i + Ci_it i-i Thus the CM holds the binomial coefficients i C., 0 < j < i < n, in its finite memory. 
It 3 uses (*) with i = k to move the input head k k-i +...+ C~t + i Ck_ I t positions to the right, 
using the value of i t in C. and restoring it in C. with the aid 1 l of A. If in the process the right 
endmarker is detected, then simply halt with the answer in C I. Otherwise, for i = k-l, k-2,..., 2, 
use (*) to update C. and finally increment 1 C I by I. Clearly it takes a fixed number of reversals 
for each inductive step~ and since it takes f(n) steps to compute f(n), the counters need only make 0(f(n)) 
reversals. (8) f(n) = [nl/k] m for positive integers m and k  is reversal-constructlble by (7) and 
(3). Note that all the functions in the example can be computed deterministically with one scan of the 
input. 3. Nondeterministic Reversal-bounded 2-way Counter Machines In this section we consider 2-way 
NCM's with general recursive bounds on counter reversals. Minsky [1961] showed that unrestricted l-way 
DCM's accept exactly all r.e. sets. In fact, Fischer's proof of this result (Fischer [1966]) shows that 
 Theorem 3.1 For T(n) ~ n, if M is a T(n) time- bounded NTM (respectively DTM), then L(M) is accepted 
by a T(n) reversal-bounded 1-way 3-NCM (respectively 3-DCM).  For the other direction, in order to 
bound the time complexity of a TM simulator in terms of the reversal complexity of the original CM, we 
have to analyze the computations of CM's with arbitrary recursive reversal bounds. This is done in Lemma 
3.1 below. Our proof of this lemma is a generalization of a proof that Baker and Book [1974,Theorem 5] 
used to obtain linear time bounds for 1-way constant reversal-bounded NCM's; Gurari and Ibarra [1981] 
contains a similar proof for a result related to the emptiness problem of the same 1-way machines. Let 
M be an R(n) reversal-bounded k-NCM with q states. We shall assume, throughout this paper, that R(n) 
z i for all n. Suppose M accepts a word w of length n. Without loss of generality assume that each counter 
increments at least twice in each reversal, and that each operation of M changes at most one counter. 
Then each re- versal goes through 4 modes: zero, nonzero and increasing, nonzero and decreasing, and 
zero again. We can therefore number the statuses of each counter as in Figure i, identifying the final 
zero status of one reversal with the initial  J 'U U"TJ 2 0 3 6 3m- 3 3m Statuses of an m-reversal 
counter Figure I  zero status of the next. The total counter status (TCS) is a k-vector (CSI,..-, CS 
k) where CS. is the status of counter i. By the i above assumptions, this vector can increase by at most 
one in at most one component in each opera- tion of M. If counter i makes r. reversals in a l computation, 
then the TCS starts with (0,...,0) and ends with (3rl,...,3rk), and each change increases the sum of 
the components by exactly i. So the TCS goes through exactly k r = 3 ~ r. + i 1  i=l values. Clearly 
as r. < R(n), r < 3kR(n) + i. 1 Now look at the given accepting computation of M on w, with rl,..., 
r k and r as above. We seek to obtain a "succinct" description of the computation. For this purpose, 
we first manip- ulate the given computation into an equivalent one in some "normal form". Consider 
each of the r subsequences of the computation with constant TCS. We call such a subsequence a segment. 
Each operation has an associated start state s and start input head position p, as well as an end state 
s' and an end position p', with 0 < p, p' < n+l and IP-P'I < i. A sequence of operations in a segment 
is a loop if it starts and ends with the same (s,p) pair. A loop is small if no two operations in it 
start with the same (s,p) pair. Since there are q states and n + 2 input head positions, a small loop 
can have length at most q(n + 2). We now massage each segment into an equivalent one that contains at 
most q(n + 2) chains of consecutive small loops separated by loop-free sequences which perforce have 
length at most q(n + 2). To be precise, for each (s,p) pair that occurs as the starting configuration 
of some operation in the segment, we mark the first such operation. Now repeatedly do the following: 
 (i) look for a small loop of unmarked operations;  (2) remove the small loop;  (3) mark its operations; 
 (4) insert it just in front of the initially marked operation with the same starting (s,p) pair.  
 Notice that because of the initial markings, step (4) is always possible. Each iteration pro- duces 
a valid computation since (i) the (s,p) interfaces obviously remain correct, and (ii) the counter actions 
can be permuted as their totality does not produce a TCS change. The algorithm clearly terminates, with 
at most q(n + 2) marked sequences separated by unmarked loop-free sequences of length at most q(n + 2). 
Note that a marked sequence consists of either a single operation or a single operation preceded by a 
chain of marked small loops on the same (s,p) pair. To summarize what we have done so far, we  present 
a schematic representation of the compu- tation we obtain in Figure 2. One last step remains in the 
conversion to normal form. We seek a succinct description of each chain of small loops. Namely, we want 
to be able to specify such a chain in terms of a small number of distinct small loops. Since small loops 
have length up to q(n+2), the number of distinct small loops can be exponential in n. To suppress this 
exponential explosion, we note that in the same TCS, two small loops on the same (s,p) pair can be substituted 
for each other if they effect the same total change on each counter. The magnitude of such a change can 
be at most q(n+2). Thus we need only use [q(n+2)+l] k dis- tinct small loops for each TCS and (s,p) 
combin- ation. Hence in each chain, replace each small egment I f7 "'"  Iml F 1 L Iml F I L Iml"'" 
 c TCS change m initially marked operation (at most q(n+2) in each segment) L chain of small loops 
 F loop-free sequence (length ~ q(n+2)) Figure 2  loop by a representative, and finally reorder the 
representative loops so that occurrences of the same small loop are consecutive This gives us the desired 
normal form. The normal form computation we have obtained can be viewed as a scheme. By varying the 
numbers of occurrences of the small loops present, we obtain a family of candidate computations on the 
same input word w. It is easy to verify that a candidate computation will be valid iff for each reversal 
of each counter, the total increment equals the total decrement. As in Baker and Book [1974], we set 
up a diophantine system to enforce these conditions. The nonnegative integral solu- tions to this system 
then give rise to valid com- putations on w. The variables in the system are as follows: t = time, i.e. 
the length of the computation x.. = total increment of counter i in the 13 .th 3 reversal Yij = total 
decrement of counter i in the .th 3 reversal z = number of repetitions in the m th chain m  of marked 
identical small loops. k Clearly there are ~ r. x- and y-variables. There l  i=l are r segments, each 
of which has at most q(n+2) chains of small loops. Each chain is made up of at most [q(n+2)+l] k distinct 
types of small loops. Hence there are at most qr(n+2)[q(n+2)+l] k z-variables. The equations of the 
system are = ~. Z + ]  xij m ljm m Pij Yij = ~8ijm zm + ~''13 IfÂ°r j=l ..... ri, i=l ..... k Xij 
= Yij t = Z~ z + ~. mmm Here ~ijm' 8ijm' Xm' Â°ij' Pij and m are numerical coefficients derived from 
the normal form compu- tation. ~.. and 8.. are the total increment and 13m 13m .th total decrement respectively 
in the 3 reversal of counter i due tm one execution of the mthsmall loop. Oii and oii are the corresponding 
increment and decrement due to operations outside the marked small loops. Finally I and ~ are the times 
of m the corresponding sections of computations. Note k that there are 3 ~ r.+l = r equations in the 
 i  i=l system, and that most of the coefficients ~.. ijm and Bijm are 0. In particular, for any i, 
j, m, at least one of ~.. and B.. must be 0. ljm ljm  Before we can obtain bounds on minimal solu- 
tions to the system, we need to estimate the sizes of the coefficients ~.. etc. From now on, we ijm 
shall wherever possible simply use the big 0 notation, it being understood that the suppressed constants 
depend only on the machine M and not on the input word w or on the chosen normal form k computation 
on w. Thus since r and ~ r. are i  i=l 0(R(n)), there are 0(R(n)) x-and y-variables, and 0(nk+iR(n)) 
z-variables. Altogether there are 0(nk+iR(n)) variables in the system. Clearly ~.. , B.. and i are 0(n) 
since a small loop has 13m ljm m length at most q(n+2), and 0.., ~.. and ~ are 1j 1j 0(n2R(n)) . 
Now we use' the following result which is a slight variation of Borosh and Treybig [1976, Theorem 5] 
: Let A be an m Ã n integral matrix, b be an m-vector of integers, and M A be the maximum of the absolute 
values of all minors in A. If the system Ax = b has a nonnegative integral solution x, then it has one 
in which for all j = i,..., n, 2 m < mnM I Ibil" xj Ai=i  When our system is transformed to this standard 
format, the resulting matrix A has r rows and 0(nk+iR(n)) columns. The coefficients of A are 0, -+i, 
-aij m, -~ijm and -I m, all of size 0(n). The right hand side vector b has components 0, 0ij, oij and 
~ whose sum is 0(n2R(n)). Clearly any submatrix of A has order < r, and so has determinant whose absolute 
value is bounded by r![0(n)] r _< rr0(n r+l) _< 0((rn)r+l).  Hence since the system has a nonnegative 
solution (the one corresponding to the normal form compu- tation we obtained), it has one in which each 
of t, xij, Yi'j and Zm is bounded by 0 [rxnk+iR(n) x(rn) 2(r+l) xn2R(n) ] < 0 [R(n) xnk+iR(n) X(n2R(n)) 
2 (3kR(n)+2) xn2R(n) ] 0 [nk+3R(n) 3 (n2R(n))6kR(n)+4 ] < 0 [ (n2R(n)) 6kR(n)+k+6 ] < 0 [ (n2R(n)) 
iBkR(n) ] < 0 [ (nR(n)) 26kR(n) ].  Thus by taking d = 26k, we obtain Lemma 3.1 Let M be an R(n) reversal-bounded 
k-NCM. Then there is a constant d depending on M alone such that for any word w, if M accepts w, then 
 there is a normal form accepting computation of M on w in which (I) there are at most 0(nk+iR(n)) 
chains of ident- ical small loops, each containing at most  0((nR(n)) dR(n)) repetitions,  (2) there 
are at most 0(n2R(n)) operations outside the chains of small loops, and  (3) the total time, hence the 
maximum counter size, is bounded by 0((nR(n))dR~n)),"  " where n is the length of w. Remark 3.1 In 
the proof of Lemma 3.1, we could eliminate the variables xij, YiJ and equate the expressions for them 
directly to obtain a diophan- k  tine system with only ~ ri+l equations. This i=l would lead to a 
smaller value for the constant d but would not affect the asymptotic growth rates of the time and space 
requirements for the TM simulations to be discussed in the remainder of this section. It follows from 
Lemma 3.1 that Theorem 3.2 If M is an R(n) reversal-bounded NCM for some recursive R(n), then L(M) is 
a recursive set. This result can also be obtained from Theorem 5 of Baker and Book [1974]: to determine 
whether M accepts w simply construct a 1-way NCM M' whose finite control encodes both the finite control 
of M and the input w and which has 0(R(n)) 1-reversal counters. It should be compared with Theorem 2 
of Baker and Book [1974], which shows that every r.e. set can be accepted by a nondeterministic 1-way 
machine with two pushdown stores each of which makes only one reversal in any computation. Next we show 
how an NTM can simulate an NCM efficiently: Lemma 3.2 Let M be an R(n) reversal-bounded k-NCM. Then 
M is equivalent to an (nk+2R(n)logn + nk+iR(n)21og n log(nR(n))) time-bounded and (n+R(n)log(nR(n))) 
space-bounded NTM. Proof: By Lemma 3.1, if M accepts a word w of length n, then there is a normal form 
accepting computation satisfying conditions (i) -(3). Now M' uses k tracks on its tape to simulate the 
k counters of M in binary. It simulates M as follows. At some moment, M' has its head on the head position 
of the simulation; M' stores the finite state anH the counter modes of the simulation in its own finite 
memory, and the values of the counters are on the tape, aligned with the current input head position. 
M' can now choose to simu- late an individual operation of M or a chain of identical, legal loops. The 
simulation of an individual operation is straightforward. To sim- ulate a chain of identical, legal loops 
(not necessarily small), M' first tries to find such a loop. Thus it marks down the simulated head position 
together with the simulated finite state on the tape, and then simulates individual oper- ations of M 
until the marked position is re-entered with the recorded state. During these loop-detec- tion simulations, 
M' assumes that the TCS does not change, and accumulates the counter changes rather than updating the 
true counters. If a TCS change is detected nonetheless, as can happen if an empty counter starts increasing 
or an increasing counter starts decreasing, M' aborts. Otherwise, when the looping is detected, M' guesses 
a repetition factor in binary, and updates the counters as though the loop is executed so many times, 
using multiplication and addition or subtraction in binary. In the process, it also verifies that no 
TCS change occurs, i.e. no counter is decremented to a nonpositive value. When the counter updates are 
complete, M' again assumes the configuration at some point in a legal computation of M, and the simulation 
cycle is repeated, until an accepting configuration of M is reached. It is obvious that if M' accepts 
some word w, then M accepts w also. Conversely, if M accepts w, then M' also accepts w simply by simulating 
all operations of M individ- ually. We now analyze the time requirements if we happen to guess the normal 
form accepting computation described in Lemma 3.1. For such a computation, by (3) each binary counter 
has length bounded by dR(n)log(nR(n)) throughout the simulation. By (2), O(n2R(n)) operations of M are 
simulated individ- ually; each operation takes M' O(R(n)log(nR(n))) time to update and realign the counters. 
Hence the individual operations take 0(n2R(n)21og(nR(n))) time to simulate. Next consider the simulation 
of identical small loops. Each small loop has length 0(n), so the total change to each counter by such 
a loop is also 0(n) and has length O(log n) in binary. By carrying these binary totals around with the 
simulated in- put head, M' can simulate each operation of M in the loop-detection phase in 0(log n) time, 
so it takes 0(n log n) time to detect a small loop. By (i) M' need only guess a repetition factor bounded 
 by 0((nR(n)) dR(n)) and hence of length 0(R(n)log(nR(n))). Now multiplication of two numbers of lengths 
0(R(n)log(nR(n))) and O(log n) takes 0(R(n)log n log(nR(n))) time, and the sub- sequent addition or subtraction 
takes 0(R(n)log(nR(n))) time. Hence altogether the counter updates take O(R(n)log n log(nR(n))) time, 
 so that the simulation of a chain of identical small loops takes at most O(n log n + R(n)log n log(nR(n))) 
time. There are 0(nk+iR(n)) such chains to be simulated, altogether taking 0(nk+2R(n)log n + nk+iR(n)21og 
n log(nR(n))) time. This clearly dominates the total time for the simulation of individual operations, 
so the lemma is established, since the entire simulation uses at most O(R(n)log(nR(n))) space for the 
binary counters. From Lemma 3.2 we obtain: Theorem 3.3 Let M be an R(n) reversal-bounded k-NCM. If R(n) 
~ n, then M is equivalent to an R(n)k+3(log R(n)) 2 time-bounded and R(n)logR(n) space-bounded NTM M'. 
If furthermore R(n) is at least exponential, then M' is at most R(n) 3 time-bounded. On the other hand, 
if R(n) ~ n, then M is equiva- lent to an nk+3(log n) 2 time-bounded and n log n space-bounded NTMM'. 
 Combining Theorems 3.1 and 3.3, we get Theorem 3.4 For nondeterministic machines and bounds that are 
at least linear, counter reversal is polynomially equivalent to TM time. 4. Deterministic Reversal-bounded 
2-way Counter Machines The results of Section 3 can be sharpened for deterministic machines. The reason 
is that in a halting computation, once a DCM has completed a small loop without any TCS change, by determinism 
it must keep repeating the same small loop until a TCS change occurs. Such a TCS change can only be the 
zeroing of some counter, since any change from zero to increasing or from increasing to decreasing would 
have already occurred in the first execution of the small loop. Thus there is a con- stant c > q such 
that for sufficiently large n, the computation on an input of length n is divided into constant TCS segments, 
each of which consists of a loop-free sequence of at most cn operations, optionally followed by repetitions 
of a single small loop of length also at most cn. Furthermore, k we know that at most ~ r i segments 
can contain i=l loops since altogether the counters change from k positive to zero ~ r. times. Now let 
m. be the i J i=l maximum length of all counters at the beginning of th the j segment, j = i,..., 
r. Clearly m I = O. We bound m_+lj in terms of m. for j ~ i. Suppose J the jth segment is notended 
by a decrement to zero. Clearly it must be loop-free and can increase any counter by at most cn, and 
so even taking the TCS change operation into account, we see that (i) m~+13 ~ m. + en. J Next suppose 
the jth segment is ended by a decre- ment to zero. If it is loop-free, then (i) again holds. So suppose 
it contains small loops. The maximum length of all counters is at most m. + cn 3 at the beginning of 
the first execution of the small loop. As seen above, the small loop must de- crement at least one counter 
by at least one. Hence it can execute at most m. + cn times. Furthermore, J it can increment any other 
counter by at most cn-l. Thus the maximum increment to any counter is (cn-l)(mj+cn). Hence in this case 
 (2) mj+ 1 ~ mj+cn+(cn-l)(mj+cn) = (cn)mj+~en) 2. Clearly (2) holds for a segment that ends with a decrement 
to zero, whether the segment is loop- free or not. So we can set up a system of such inequalities relating 
IJ to m. for j = l,...,r-2, m~+ J using (2) if the jth segment ends with a decrement to zero and (i) 
otherwise. Solving the system by substitution, we see that tl mr_ 1 (cn)tr-2+(cn)tr-3+...+(cn) where 
i N t I_ ~ t 2 S...~ tr_ 2. To estimate the upper bound, we make the following observations: k k (a) 
tr_ 2 = (l~iri-l)+l.= = i=ll r i, since there are  -151 k exactly I r.-i relations of type (2) in the 
system 1  i=l because the first r-2 segments account for only k r.-i decrements to zero, the last one 
being 1  i=l accounted for by the (r-l) st segment. (b) At most 2k consecutive t.'s can be the same, 
J since in every 2k+l consecutive TCS changes at least one must be a decrement to zero. It then follows 
that k k I r. I r.-i 1 i  mr_ 1 < (2k+l)[(cn) I=I +(cn) i=l +...+(cn)+l] k ~ ri+l = (2k+l) (cn) i=l 
-i cn-i k I ri+l (cn) i=l < (2k+l) ( c-'c~2 k ~r. = (4k+2)(cn)i= 1 1 k ~r. 1 Clearly m. < (4k+2) 
(cn) l=l for j = 1..... r-1. .1 Now the maximum length of any counter during the entire computation must 
be m.+l for some j = 1, 3 ..,r-i, since no counter is incremented after the start of the (r-l) st segment. 
Hence the maximum k ~r. 1 counter length is bounded by (4k+2)(cn) i=l and hence by (4k+2)(cn) kR(n)" 
" since r. ~ R(n) for 1 all i = l,...,k. This establishes Lemma 4.1 Let M be an R(n) reversal-bounded 
k-DCM. Then there is a constant c depending on M alone such that for any word w, if M accepts w, then 
there is a unique accepting computation of M on w in which (i) there are at most 0(R(n)) chains of identical 
small loops, each containing at most  0((cn) kR(n)) repetitions,  (2) there are at most O(nR(n)) operations 
outside the chains of small loops,  (3) the maximum counter size is bounded by  O((cn)kR(n)) , and 
  (4) the length of the computation is bounded by  0(nR(n)(cn)kR~n)),-" " where n is the length of 
w. The simulation in Lemma 3.2 leads to an NTM M' even if the original CM M is deterministic. However, 
an efficient deterministic simulation of a DCM is also possible: Lemma 4.2 Let M be an R(n) reversal-bounded 
k-DCM. Then M is equivalent to an nR(n)21og n time-bounded and (n+R(n)log n) space-bounded DTM M'. Proof: 
By Lemma 4.1, in an accepting computation on an input of length n, we have an O((cn) kR~n))" bound on 
the counter sizes and hence an 0(R(n)logn) bound on the lengths of their binary encodings. The strategy 
of our simulation will be to simulate individual operations of M as in Lemma 3.2, with the counters aligned 
with the input head, but also recording the states in which each input cell is scanned (may be more than 
once) to detect loops. Clearly if M has q states then there can be at most q visits to each input square 
and hence a total of at most qn operations before a loop is detected or a TCS change occurs. If a TCS 
change occurs, M' simply resets the loop-detection me- chanism. If a constant TCS loop is detected, M' 
carries out a simulation as in Lemma 3.2 to com- pute the counter changes" caused by the loop. If no 
counter is decremented in the loop, then M enters an infinite loop and the computation could not have 
been accepting. Otherwise, for the counters that are decremented, M' performs binary divisions and, by 
comparing quotients, determines the number of times the loop is repeated before a TCS change occurs. 
It then simulates all these repetitions in one fell swoop by updating the counters using binary arithmetic. 
After that it resets the" loop-detection mechanism, and resumes the simulation of individual operations. 
The process is carried on until M halts. Clearly the simulator never uses more than O(R(n)log n) space 
for the binary counters. The timing analysis is similar to that in Lemma 3.2. In each segment, one must 
detect a loop in at most 0(n) individual simulations, and there are at most O(n) individual simulations 
following the whole- sale simulation of the chain of loops These take O(nR(n)log n) time. The simulation 
of a single loop to compute its counter changes takes O(n log time. Then the wholesale execution of the 
loops takes 0(log n Ã R(n)log n) = 0(R(n)(log n) 2) time since the division as well as the multipli- 
cation of a p-bit number and a q-bit number takes 0(pq) time. Finally resetting the loop-detection mechanism 
takes 0(n) time. Hence a segment takes 0(nR(n)log n) time to simulate (since n dominates log n), and 
altogether the 0(R(n)) segments take time 0(nR(n)21og n). Theorem 4.1 Let M be an R(n) reversal-bounded 
k-DCM. If R(n) ~ n, then M is equivalent to an R(n)31og R(n) time-bounded and R(n)log R(n) space-bounded 
DTM M'. If furthermore R(n) ~ n log n, then M' is at most R(n) 3 time-bounded. On the other hand, if 
 R(n) ~ n, then M is equivalent to an n31og n time-bounded DTM which is at most n log n space- bounded. 
Theorem 4.2 The polynomial equivalence between counter reversal and TM time also holds for deter- ministic 
machines and bounds that are at least linear. Remark 4.1 With regard to Theorems 3.4 and 4.2, notice 
that for deterministic machines, the poly- nomial bounds are uniform in both directions, whereas for 
nondeterministic machines, the poly- nomial bounds we have are uniform in one direction but not the other. 
 5. Some Consequences In this section, we explore some implications of the results obtained in Sections 
3 and 4. Theorem 5.1 P (respectively NP) is exactly the class of languages accepted by polynomial reversal- 
bounded DCM's (respectively NCM's). Hence P = NP iff polynomial reversal-bounded DCM's are equivalent 
to polynomial reversal-bounded NCM's. Proof: By Theorems 3.4 and 4.2. Remark 5.1 Theorem 5.1 adds to 
the evidence that P and NP are natural, model-independent classes of computational problems. Two other 
classes de- fined in terms of the Turing machine model can also be characterized on the counter machine 
model in a similar manner. Namely, by the results of Fischer et al [1968], polynomial time-bounded 2-way 
DCM's (respectively NCM's) are equivalent to log n space-bounded 2-way 2-tape DTM's (respec- tively NTM's). 
Hence deterministic logarithmic space is equivalent to nondeterministic logarithmic space for 2-way 2-tape 
TM's iff deterministic polynomial time is equivalent to nondeterministic polynomial time for 2-way CM's. 
 It is well known that a T(n) time-bounded 2 multitape TM has an equivalent T(n) time-bounded 1-tape 
TM. Thus for TM's, reduction to i tape involves at most a "square loss" in time. In the case of CM's 
the situation is somewhat different. Greibach [1975] 3 proved that a I-NCM always accepts in time n . 
Thus I-NCM's can be simulated by log n space-bounded 2-way 2-tape NTM's, and hence accept a subclass 
of P. This means that for CM's, it is not always possible to reduce to a single counter. Minsky [1961] 
showed that it is always possible to reduce to two counters. How- ever, the obvious prime-factorization 
encoding produces from a T(n) time-bounded k-CM a T(n) reversal-bounded 2-CM. Since the time complexity 
of an R(n) reversal-bounded k-CM can be exponen- tial in R(n), this method of reduction to two counters 
involves an exponential explosion in reversal complexity. We do not know whether there is an alternative 
way to reduce to two counters with a less severe deterioration in reversal com- plexity. However, by 
combining Theorems 3.1, 3.3 and 4.1 we obtain: Theorem 5.2 Let M be an R(n) reversal-bounded k-NCM, with 
R(n) m n. Then M has an equivalent R(n) k+4 reversal-bounded 3-NCNM'. If M is deterministic, then M' 
is also determinis- 4 tic and at most R(n) reversal-bounded. A similar phenomenon occurs with restriction 
to 1-way input. Again, if one tries to encode the input tape on counters by the method used in the proof 
of Theorem 3.1, then the resulting 1-way CM has reversal complexity equal to the time complexity of the 
original 2-way CM. However, we observe that the equivalent machine M' of Theorem 5.2 is in fact 1-way, 
Hence: Corollary 5.1 For NCM's (respectively DCM's) with reversal bounds that are at least linear, there 
are equivalent 1-way 3-NCM's (respectively 3-DCM's) with only a polynomial (respectively quartic) deterioration 
in reversal complexity.  6. 1-way Counter Machines  In this section, we present analogues of the results 
of the previous sections for CM's with 1-way input. The arguments used are similar to those for 2-way 
machines, and we shall only sketch the modifications that are necessary for proving the new results. 
It will be seen that in general, the simulation bounds are much sharper for 1-way CM's. Consider the 
analysis of accepting computa- tions in the proof of Lemma 3.1. Suppose the machine M is l-way and has 
input alphabet Z. A loop is now defined as a sequence of stationary operations that start and end in 
the same state and the same TCS, and a small loop is one in which no two operations start in the same 
state. Clearly, since M has q states, a small loop has length no greater than q. We can perform the same 
"remove and insert" operations on small loops as before, except that we now maintain (s,a) in- terfaces 
instead of (s,p) interfaces, where a is an input symbol and p is an input position. Hence in a normal 
form computation, each segment is divided into at most qlEl chains of small loops separated by loop-free 
sequences in which there is an input head motion at least once every q operations. Furthermore, each 
chain of small loops consists of at most b q+l subchains of identical small loops, where b is the number 
of transition rules of M. Hence for input of length n, there are altogether at most (3kR(n)+l)qlElb 
q+l chains of identical small loops, and each small loop can change a counter by at most q. Thus the 
resulting diophantine system has 3kR(n)+l equa- tions and 0(R(n)) variables; the matrix has entries of 
size bounded by q, and the right hand side has entries whose absolute values have sum at most 0(R(n)+n). 
By the same arguments as before, we obtain Lemma 6.1 Let M be an R(n) reversal-bounded 1-way k-NCM. Then 
there is a constant d depending on M alone such that for any word w, if M accepts w, then there is a 
normal form accepting computa- tion of M on w in which (i) there are at most O(R(n)) chains of identical 
small loops, each containing at most  O(nR(n)dR(n)) repetitions,  (2) there are at most 0(R(n)+n) operations 
outside the chains of small loops, and  (3) the total time, hence the maximum counter size,  is bounded 
by 0(nR(n)dR~n))," " where n is the length of w. The simulation of Lermna 3.2 can now be sim-  plified 
because the finite control of the simula- tor M' can store all possible small loops of M, so there 
is no need to search for small loops during the simulation itself. Furthermore, counter updates for 
a chain of identical small loops can now be done in a single pass over the binary counters, since they 
involve only additions, subtractions, and multiplications by constants. Hence Lemma 6.2 Let M be an 
R(n) reversal-bounded l-way k-NCM. Then M is equivalent to an (R(n)+n)(R(n)log R(n)+ log n) time-bounded 
and (n+R(n)log R(n)) space- bounded NTM. Theorem 6.1 Let M be an R(n) reversal-bounded 1-way k-NCM. 
 If R(n) ~ n, then M is equivalent to an R(n)21og R(n) time-bounded and R(n)log R(n) space-bounded 
NTM M'. On the other hand, if R(n) ~ n, then M is equiv- alent to an n21og n time-bounded and n log 
n 153 space-bounded NTM M'.  Next consider accepting computations of an R(n) reversal-bounded 1-way 
k-DCM. As before, let mj be the maximum counter size at the beginning of th the j segment. Let n. be 
the distance moved by J th the input head during the j segment. The recur- rence relations bounding 
mj+ I in terms of m. now J become th mj+ I < mj+qnj if the j segment is loop-free and mj+ I _< qmj+q2nj 
otherwise. Solving as before, we obtain t t t I mr_ 1 -< q r-2nl+ q r-3n2+ ...+q nr_ 2 k r where i 
N t I <...m tr_ 2 = i=~iri Since j!inj = n~ k r i mr_ I < n(q i=l +...+q+l) k r.+l i= I i  = n 
9. -i q-1 k r i < 2nq i=l N 2nq kR(n) . This yields Lemma 6.3 Let M be an R(n) reversal-bounded 1-way 
k-DCM with q states. For any word w, if M accepts w, then there is a unique accepting com- putation of 
M on w in which (i) there are at most 0(R(n)) chains of identical small loops, each containing at most 
 O(nq kR(n)) repetitions,  (2) there are at most 0(R(n)+n) operations out- side the chains of small 
loops,  (3) the maximum counter size is bounded by O(nqkR(n)), and  (4) the length of the computation 
is bounded by  0(nR(n)qkR(n)), where n is the length of w. Hence if R(n) < log n then M accepts in 
poly- nomial time. Remark 6.1 Baker and Book [1974, Theorem 3] gives an analogous result for a deterministic 
R(n) reversal-bounded 1-way k-pushdown machine, namely, there is a constant c such that the machine 
accepts in time c n+kR(n) Lemma 6.4 Let M be an R(n) reversal-bounded 1-way k-DCM. Then M is equivalent 
to an (R(n)+n) (R(n)+log n) time-bounded and (R(n)+n) space-bounded DTM M'. Proof: The counters have 
binary encodings of length at most R(n) + log n. It takes a constant number of passes over the counters 
to perform the updates for a chain of identical small loops since only additions, subtractions, and multipli- 
cations and divisions by constants are involved. The timing then follows from Lemma 6.3. Remark 6.2 Notice 
that the simulation of Len~na6.4 requires at least n log n time for all R(n) > i. This is consistent 
with the following facts: (i) there are DCM's with reversal bound R(n) -i which recognize nonregular 
sets, and (2) if lim f(n) 0 then f(n) time-bounded n_~n log n DTM's can recognize only regular sets 
 (Hartmanis [1968, Theorem 2]). Theorem 6.2 Let M be an R(n) reversal-bounded 1-way k-DCM. If R(n) 
~ n, then M is equivalent to an R(n) 2 time-bounded and R(n) space-bounded DTM M'. On the other hand, 
if R(n) ~ n, then M is equiv- alent to an n 2 time-bounded and linear space- bounded DTM. Remark 6.3 
The simlulation bounds in Theorems 6.1 and 6.2 are both very tight, since the set of palindromes L 
I = {w#wR:w E {a,b} +} can be recognized by a 1-way n reversal-bounded  DCM but requires n 2 time on 
an NTM (for a proof, see Hopcroft and Ullman [1969, Theorem 10.7]). Remark 6.4 As compared to the 2-way 
case, the polynomial relation between counter reversal of 1-way CM's and time on TM's is sharper and 
uni- form for both the deterministic and the nondeter- minlstic variants. Some of the results of Section 
5 can also be carried over, suitably modified, to the 1-way case. 7. Reversal Hierarchies for Counter 
Machines In this section, we establish reversal complexity hierarchies on the various counter machine 
models. For reversal bounds that are at least linear, the complexity classes are closely related to TM 
time complexity classes. In fact, various superlinear reversal hierarchies are obtained by translating 
TM time hierarchies. An interesting fegture of these hierarchies is that they can be extended downwards 
to sublinear bounds, using ad hoc counting arguments as well as more general padding techniques. Theorem 
7.1 (Superlinear reversal hierarchy for 2-way DCM's) Let T(n) ~ n 2 be defined by a DTM and be computed 
on log T(n) space. Then for any Tl(n) such that Tl(n) 31og Tl(n) lim = 0 T(n) n-~o the class of Tl(n) 
reversal-bounded 2-way DCM languages is properly contained in the class of T(n)log T(n) reversal-bounded 
2-way DCM languages. Proof: This is a simple translation, via Theorem 4.1, of the result that with T(n) 
as above, for any T2(n) such that T2(n) lim -= 0 T (n) n-~o there is a set which is acceptable by 
a T(n)log T(n) time-bounded DTM but not by any T2(n) time-bounded DTM (Hartmanis [1968, Theorem 7]). 
Notice that this hierarchy result is independent of the number of counters. We can also obtain a sparse 
sublinear re- versal hierarchy for 2-way DCM's by ad hoc argu- ments. Trivially even one reversal is 
better than no reversal. Now consider the language L 2 = {02k: k ~ 0}.  154 L 2 can obviously be recognized 
by a log n reversal- bounded 1-way DCM. However, if it could be recog- nized by a constant reversal-bounded 
2-way DCM, then by the main result of Gurari and Ibarra [1979], it would be regular, an obvious contradic- 
 tion. Hence log n reversals are better than con- stant reversals. Our next step is to show that n 
reversals are better than log n reversals. We shall in fact prove the stronger result that n reversals 
are better than n r reversals for any positive real number r < 1/2. Recall that L I = {w#wR:w c {a,b}+}. 
 It is easy to see that L I can be recognized by a 2-way I-DCM using n reversals. However, we now 
show that r  Lemma 7.1 L I cannot be recognized by any n reversal-bounded 2-way NCM for r < 1/2. 
Proof: Assume, for contradiction, that for some r < 1/2 L I is recognized by some n r reversal-boun- 
 ed k-NCM M. We can assume, without loss of gen- erality, that r is rational. For convenience, we assume 
that M starts its computation by moving its input head onto the # in the initial state, and that the 
very next move causes the head to enter R  the w part of the input; we also assume that M halts by 
moving its input head onto the # from the left. Thus an accepting computation is naturally decomposed 
into left and right tours as shown in Figure 3. Counter statuses (CS's) and I I < ) } right tour I 
< left { Q > I tour )   ( <> I > ) C2 < I < I I (. > t   C < )I > HALT I Figure 3 total counter 
statuses (TCS's) are defined as be- fore. Here the TCS goes through 3knr+l values, from (0..... O) 
to (3nr,...,3nr), since we can as- sume, by part (8) of Example 2.1, that every counter of M makes O(n 
r) reversals on inputs of length n. By Lem~a 3.1, there is a constant a such that M accepts inputs of 
length n r in time < n an For sufficiently large odd n, we take a minimal-length accepting compu- 
tation of M on w#w R for each word w of length n-l Each such computation has length less than 2 " 
r r an nan  n , hence contains at most left tours. n-i 2 We now partition the set of 2 accepting compu- 
tations by several levels of classification: r (i) Divide the whole set into at most n an subsets according 
to the number t of left tours in the computation.  (2) Divide each level (i) set according to the TCS 
values that occur in the left tours.  There are (3n r + I) k distinct TCS values. The number that 
occurs can be v = l,...,3kn r + I. For each such v, there are at most 2r c(3nr+l)k < (3nr+l)kV _< (3nr+l)3k 
n +k v choices. Hence each level (1) set is parti- tioned into at most (3knr+l) x (3nr+l) 3k2nr+k < 
n bnr level (2) sets for some constant b.  (3) Partition each level (2) set according to the TCS values 
that occur in but neither start nor end left tours. These TCS values are said to be closed; the rest 
are open. If there are v distinct TCS values corresponding to the level (2) set, we can have u N v closed 
TCS values. For each u, there are at most C v < v u ~ v v u choices of the u closed TCS values. So 
alto- gether there are at most r r (v+l)v v < (3knr+2) Ã (3knr+l)3kn +i < nCn level (3) sets in each 
level (2) set.  (4) For each level (3) set, for every 2 consec- utive open TCS values, we have a choice 
of whether there is a left tour that starts in the first TCS value and ends in the second. Hence each 
level (3) set can be partitioned into at most 2 v N 2 3knr+l < 2 dnr level (4) sets according to such 
choices, where d is a constant,  (5) For each level (4) set, there is an s < v such that every computation 
in the set con- tains s left tours that change TCS values. Let M have q states. Then each such tour 
2 has q choices of start and end states, so altogether there are at most (q2)S 2v q2(3knr+l) r < q 
~ < 2 en possible state interfaces for these TCS-change tours, where e is a constant. Hence partition 
 each level (4) set into at most 2 enr level (5) sets according to such interfaces;  (6) For each level 
(5) set, the t-s tours that do not involve TCS changes are distributed into at most q2(v-u) <start state, 
end state, TCS value> combinations. Altogether, there are at most ct -s+q 2 (v-u) -i q2(v-u)-i 2 < 
(t+q2v)q v r 2 r < [nan +q2(3knr+l)] q (3kn +i) fn 2r < n ways to do the distribution for some constant 
 f. Partition each level (5) set into level (6) sets according to such distributions.  (7) Partition 
each level (6) set according to the total counter changes effected under each TCS value present. Each 
of the k counters can r an change by at most n under each TCS value, and there are at most 3kn r 
+ i TCS values, so there are at most 2r [ (nanr) k] 3knr+l < n gn  subdivisions for some constant g. 
Hence altogether there are at most r r 2dnr 2 enr x 2r 2r an bn r cn nfn n Ãn Ãn Ã Ã Ãn gn hn 2r 
2hn2rlog n < n = n-i 2 partitions of the 2 computations, where h is a constant. Since r < 1/2, for 
sufficiently large n-i n, 2 2 > 2hn2rlog n, so there are w I, w 2 such that lWll = lw21, w I # w 2, 
whose accepting computations are classified in exactly the same way. We now derive a contradiciton by 
pasting together R  the left tours on w I and the right tours on w 2 to obtain an accepting computation 
on Wl#W 2. This can be done by substituting left tours on w I for left tours on w 2 in the accepting 
compu- tation of w2#w R. Because of the way the class- ification is defined, a one-for-one substitution 
that maintains all the TCS values as well as the state interfaces exists. The resulting string is a valid 
computation because we are guaranteed that the total counter changes under each TCS value re- main unchanged 
from the original valid computa- tion on w2#wR. Putting these facts together, we have Theorem 7.2 The 
following bounds define strictly increasing reversal complexity classes for 2-way DCM's: O,l,log n and 
n. The same TM time hierarchy used in Theorem  7.1 can also be translated into a superlinear re- versal 
hierarchy for 1-way DCM's: Theorem 7.3 (Superlinear reversal hierarchy for 1-way DCM's) Let T(n) z n 
2 be defined by a DTM and be computed on log T(n) space. Then for any Tl(n) such that Tl(n)2 lim 0 
r(n) n-~o  the class of Tl(n) reversal-bounded 1-way DCM languages is properly contained in the class 
of T(n)log T(n) reversal-bounded 1-way DCM languages. This hierarchy, like that for 2-way DCM's, is 
not as sharp as one might desire. However, in this case, by a combination of techniques that have been 
successfully applied to TM time and space, we can obtain a sharp polynomial reversal hierarchy. For 
a function f(n), let Dl(f) stand for the class of languages accepted by f(n) rever- sal-bounded 1-way 
DCM's. Then we have Lemma 7.2 (Translation lemma for 1-way DCM's) Let Rl(n), R2(n) and f(n) be functions 
such that f(n) ~ n is constructible by 1-way DCM's using min{Rl(f(n)), R2(f(n))} reversals. Then DI(RI 
) ~ DI(R2)~DI(RlOf)~ Dl(R2of).  Proof: By the standard padding and unpadding arguments. Theorem 7.4 
(Polynomial reversal hierarchy for 1-way DCM's) For any real numbers r I > r 2 > O, Dl(nr2)~ Dl(nrl). 
Proof: There is a similar hierarchy for NTM space due to Ibarra (Ibarra [1972]). The present proof is 
a simple modification of the proof in Hopcroft and Ullman [1979] (Theorem 12.12) for Ibarra's result. 
Thus it suffices to show that for all positive integers s and t, Dl(n s/t) ~ Dl(n(S+l)/t). For contradiction, 
assume that Dl(n (s+l)/t) ~ Dl(n s/t) for some s,t. For i = 0,1,...,s, applying Lemma 7.2 with Rl(n) 
= n(sÃ·l)/t R2(n) = n s/t f(n) = n (s+i)t, we obtain D I (n (s+l) (s+i)) ~__ D I (n s (s+i)) . The lemma 
is applicable because f(n) = n ~s+i)t can be computed using O((s+i) tn) = O(n) reversals, and Rl(f(n)) 
= n(s+l)(s+i) and R2(f(n)) = n s(s+i) both dominate n. Alternating these s + i inclu- sions with the 
s inclusions: Dl(nS(S+i)) ~__ Dl(n(S+l)(s+i-l)) i = i..... s which hold because s(s+i) ~ (s+l)(s+i-l) 
for i Z i, we obtain Dl(n 2s2+2s) ~__ Dl(nS2). 2s2+s  But by Theorem 7.3 with T(n) = n and 2 Tl(n) 
= n s , we have Dl(n s2) ~- Dl(n2S2+Slog n) C: Dl(n2S2+2s), which yields the desired contradiction. 
Remark 7.1 From the arguments used for 2-way DCM's it easily follows that DI(o) ~.~ DI(1) ~Dl(log n), 
whereas by Theorem 7.4 we have Dl((log n)k) ~ Dl(n r) for all real r > 0 and integer k Z i. Remark 7.2 
Lemma 7.2 also holds for 1-way NCM's. The proof of Theorem 7.4 can then be repeated, with Theorem 7.3 
replaced by Cook's polynomial time hierarchy for NTM's (Cook [1973]) and Theorem 6.1, to obtain a polynomial 
reversal hierarchy for 1-way NCM's. Remark 7.1 is then seen to apply also, since 1-way NCM's with constant 
re- versal bounds accept languages with semilinear Parikh maps (Ibarra [1978]). 8. tonclusion In 
this paper, we have carefully analyzed the computations of counter machines and related them to Turing 
machines. We feel that our analysis has shed light on both the nature of counter machine computations 
and the .intimate relation between unary and binary encodings. The polynomial re- lation between counter 
machine reversal and Turing machine time, together with similar relations in- volving RAM time and RASP 
time (for example, see Aho et al [1974]), suggests that one might strengthen Church's Thesis to state 
that all reason- able deterministic (respectively nondeterministic) sequential models of universial computing 
devices have natural complexity measures that are poly- nomially equivalent to time on the deterministic 
(respectively nondeterministic) Turing machine model. Similar relations involving parallel as well as 
sequential computing devices have also been established; some of the most recent develop- ments were 
reported in Hong [1980] and Dymond and Cook [1980]. Acknowledgements Most of the results in this paper 
are taken from the author's Ph.D. thesis written at Cornell University. The author is deeply grateful 
tohis thesis advisor, Professor Robert L. Constable, and Professor Juris Hartmanis for constant en- couragement, 
and to Professor Oscar H. Ibarra of the University of Minnesota for many useful discussions. This research 
was supported in part by an IBM graduate fellowship. References Aho, A.V., Hopcroft, J.E. and Ullman, 
J.D. [1974], The Design and Analysis of Computer Algorithms, Addison-Wesley, Reading, MA. Baker, B.S. 
and Book, R.V. [1974], Reversal-bound- ed multipushdown machines, J. Comptr. and Syst. Sci. S, 315-322. 
 Borosh, I. and Treybig, L.B. [1976], Bounds on positive integral solutions of linear Diophan- tine equations, 
Proc. Amer. Math. Soc. 55, 299-304. Cook, S.A. [1973], A hierarchy for nondetermin- istic time complexity, 
J. Comptr. and Syst. Sci. 7, 343-353. Dymond, P.W. and Cook, S.A. [1980], Hardware com- plexity and 
parallel computation, Proc. 21st Ann. Symp. on Foundations of Computer Science, IEEE Computer Society, 
Syracuse, NY, 360-372. Fischer, P.C. [1966], Turing machines with re- stricted memory access, Inform. 
and Control 9, 364-379. Fischer, P.C., Meyer, A.R. and Rosenberg, A.L. [1968], Counter machines and 
counter languages, Math. Syst. Theory 2, 265-283. Greibach, S.A. [1975], A note on the recognition of 
one counter languages, R.A.I.RÂ°O. 9, R-2, 5-12. Greibach, S.A. [1976], Remarks on the complexity of 
nondeterministic counter languages, Theoret. Comptr. Sci. i, 269-288. Gurari, E.M. and Ibarra, O.H. 
[1979], Simple counter machines and number-theoretic problems, J. Compt r. and Syst. Sci. 19, 145-162. 
 Gurari, E.M. and Ibarra, O.H. [1981], The complex- ity of decision problems for finite-turn multi- 
counter machines, to appear in J. Comptr. and Syst. Sci. Hartmanis, J. [1968], Computational complexity 
of one-tape Turing machine computations, J. ACM 15, 325-339. Hong, J. [1980], On similarity and duality 
of com- putation, Proc. 21st An n . Symp. on Foundations of Computer Science, IEEE Computer Society, 
Syracuse, NY, 348-359. Hopcroft, J.E. and Ullman, J.D. [1969], Formal Languages and Their Relation to 
Automata, Addison-Wesley, Reading, MA. Hopcroft, J.E. and Ullman, J.D. [1979], Introduc- tion to Automata 
Theory, Languages, and Compu- tation, Addis0n-wesley, Reading, MA. Ibarra, O.H. [1972], A note concerning 
nondeter- ministic tape complexities, J. ACM 19, 608-612. Ibarra, O.H. [1978], Reversal-bounded multicounter 
machines and their decision problems, J. ACM 25, 116-133. Minsky, M.L. [1961], Recursive unsolvability 
of Post's problem of "tag" and other topics in theory of Turing machines, Ann. of Math. 74, 437-455. 
 
			
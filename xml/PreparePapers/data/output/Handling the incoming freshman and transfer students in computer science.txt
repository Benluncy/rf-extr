
 Handl ing the Incoming Freshman and Transfer Students in Computer Science Kenneth Hagel Computer Science 
Department North Dakota State University Computer Science programs throughout the country have had to 
cope with rapid increases in students during the last few years. These students cause additional problems 
beyond those arising from their numbers, This paper presents one proposal for handling the differing 
backgrounds of new students, both freshmen and transfers. A very different approach has been presented 
in {4}. Students enter Computer Science undergraduate programs with three different types of backgrounds: 
(a). the student who Knows nothing about programming a computer; (b) the student who has had at least 
one course in high school or who has learned to program a microcomputer on his own; and (c) the transfer 
student who has had some computer science courses, but whose courses do not correspond closely to your 
own. The students in-the last two groups have similar needs which are significantly different from students 
in the first group, In one of our. introductory courses for the fall, 1983 quarter, out of one hundred 
and fifty students, twenty-three fit the (b) category and tdenty-one fit the (c) category. We expect 
these numbers to increase greatly as high school computer programming courses become more common. These 
experienced students Know much of the material in your first few computer science courses, but are 
missing important pieces of what those courses cover. If they are forced to take those introductory 
 courses, their boredom with material they already Know often will cause them to miss material they 
need to learn. A further problem is the difficulties in determining exactly what they Know and what 
they do not Know. Knowing how to program in Pascal means very different things at different schools, 
for example. Of course, widespread faculty shortages mean a program cannot offer course sequences oriented 
towards each possible type of student background. The next section of this paper discusses one possible 
solution Permission to copy without fee all or part of this material is granted provided that the copies 
are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of 
the publication and its date appear, and notice is given that copying is by permission of the Association 
for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 
&#38;#169; 1984 ACM-0-89791-126-1/84/002/0224 $00.75 to these two problems. Types of Material in The 
Introductory Courses The material covered in introductory computer science courses can be classified 
into seven categories, namely: <I) learning a particular programming language; (2) learning about a computer's 
organization and hardware; (3) simple data structures (queues, stacks, lists, trees and graphs); (4) 
learning how to solve problems; (5) learning how to express algorithms; (6) learning how to use the local 
computer systems; and (7) learning local conventions for documentation, programming style, etc. All incoming 
students regardless of background need to learn (6) and (7). What they need to learn from the first five 
categories depends on their s0ecific backgrounds. Topics (6) and (7) may be covered in a small set of 
computer based instruction modules for students with some computing background. We hope to use computer 
based instruction for large portions of all our language courses within five years{S,9>. A human instructor 
would be available a few hours per week to answer questions. Students would learn the material through 
self-paced modules with frequent computer given and graded examinations. In order to teach (7), through 
computer based instruction, program-wide standards must be in place. These standards for documentation, 
program style and grading policies are extremely difficult to develop, but also very important. By having 
such standards, students do not have to forget the last instructor's requirements and learn the new instructor's 
each quarter. The students feel that the requirements have valid rationales. We are developing these 
policies at North Dakota State University. We have found that the most difficult standards to develop 
are those for program documentation. We started with very detailed requirements similar to those in 
{9}. As we tried to do some sample programs with those standards, we found that much of the requested 
documentation w~s unneeded, The program itself was clear enough in many cases. Worse, the excessive 
documentation made it difficult 224 programs with those standards, we found that much of the re0uested 
documentation was unneeded. The program itself was clear enouoh in many cases. Worse, the excessive 
documentation made it difficult for anyone to manipulate the program at a computer terminal with its 
twenty-four lines of eighty characters ~h. I~le have changed to requirements which consider the self-documenting 
capability of the program and the complexity of the underlylng algorithm. The additional documentation 
should concentrate on interrelationships among data items and among program functions as well as on how 
to use the program. A few microcomputers could be set aside to run these lessons during the week before 
classes and the first week or two of classes. If microcomputers are not available, these lessons could 
be placed on a large computer and accessed through terminals. We have found that the microcomputer's 
ability to interact quickly and to use graphics make the computer based instruction much more effective. 
 Experienced students should be given account numbers for the computing systems when they arrive to allow 
(even encourage!) them to use the system a little before classes begin. If your computing systems charge 
for usage, these accounts could be charged to student orientation and limited to only the first couple 
of weeks of the semester or quarter. At a thirty minute orientation meeting, the account numbers could 
be distributed along with a map of the campus indicating locations and hours of operation for the computer 
terminals and/or microcomputers. New, but experienced students could be shown how to use the CAI modules 
during this meeting. Evaluating Student Backgrounds There does not appear to be any perfect method 
for determining exactly what experienced students know from the first four categories. One workable 
 method involves four short examinations given on the day before registration begins. Almost all new 
students should be available on that day. New students should be told about these examinations and 
their importance at least one month in advance. They should be sent a sample copy for each examination. 
Category (2) may be tested through a twenty minute examination consisting of thirty multiple choice 
questions. A similar examination may be used for category (3). True-false questions seem too easily 
guessed to be reliable indicators of knowledge in this area. The computer can be programmed easily 
to grade these tests. Two one hour tests can be used to check knowledge in categories (I), (4) and (5). 
Each test requires the students to design, describe, and implement a solution to a problem using a given 
description method ( pseudocode, flowcharts, or something else) and programming language. Some care must 
be exercised to ensure that the problems are clearly stated and that the required description method 
is not indicated in terminology peculiar to your program. The appendix gives some sample problems. These 
questions should be graded very carefully by all the Computer Science faculty on the day of the examinations. 
There should be at least thirty minutes between the two examinations to reduce the influence of fatigue. 
 Experienced students who pass all the examinations may be placed in courses beyond the introductory 
sequence. Students who do not pass the multiple choice examination on topic (2), but do pass the other 
three are given a reading list and required to take that examination again during the first quarter. 
These students also are placed in courses beyond the introductory sequence. Initial deficiencies in topic 
(2) material seem to be unimportant factors in success in future courses, we do not feel deficiency in 
this area alone should delay a student for an entire quarter. Before we deal with the students who 
pass some examinations but not all, we have to discuss how the introductory courses are laid out. 
The Introductory Courses Since students come from a variety of backgrounds, the introductory courses 
 should be split into as many independent pieces as possible, subject to a program's other constraints. 
One possible arrangement is an introductory 225 programming-language independent course ~hich covers 
topic (2) from the previous section {computer organization and hardware} as well as beginning to cover 
topics (3)~data structures}, (4) {problem solving}and (5) {algorithm expression}. Separate courses on 
each of several major programming languages could be taken concu-rently or after the core course. The 
introductory course would be followed by another language independent course completing topics (3), (4) 
and (5). Outlines of these courses for a ten week quarter form figures (I), (2), and (3). The Pascal 
course is based on the textbook 0h! Pascal!{3}. See {2,6,7} for other introductory sequences. Offering 
the language instruction separately from the course in Computer Science concepts creates coordination 
problems. The instructors of both types of courses should meet weekly or biweekly to discuss possible 
problems. A graduate teaching assistant assigned to each course can prepare a one or two paragraph summary 
of the material, covered in each class meeting for perusal by other instructors. These summaries can 
be placed in loose leaf notebooks and made available to teaching assistants who provide students with 
programming aid. Students majoring in Computer Science would be required to take both language independent 
courses and learn (either through a language course or elsewhere) your common language (frequently Pascal) 
by the completion of the second course. Subsequent courses may then draw on the facilities of the common 
language when that is appropriate. The two language independent courses together with one programming 
language course cover the material of CSI and CS2 in Curriculum "78{I}, but with a different organization. 
This different organization arises because our courses are offered on a quarter rather than semester 
basis, topics are offered early which the programming language courses need, and we feel that computer 
ethics should be stressed. Placing New, But Experienced Students Students may fail at least one of 
the examinations for any of the following reasons: (I) do not know the common programming language; (2) 
do not know simple data structures; (3) do not know the design description method (pseudocode); (4) 
cannot design a problem solution; or (5) cannot write a program. Every new, but experienced student must 
 see a faculty advisor on the morning of registration. The advisor goes over the examination results 
and gives the student a written placement report indicating what, if anything, the student must do to 
make up deficiencies. .Another cop>" of the placement report is filed in the student's records. Students 
who do not know the common programming language must take the common language course described in figure 
3. Students who do not know &#38;Prays.or stacks are required to start with CS 170 and CS 171 as described 
in figures 1 an~ 2. Students who appear to know arrays and stacks, but do not know the other, simple 
data structures are required to take CS 171, but they are excused from CS 170. Students who do not 
Know pseudocode, but can develop solution desfgns, are placed in the first week only of CS 171 and asked 
to do two designs in pseudocode. If they complete the two designs successfully, they may b~ given credit 
for CS 173: Designing Computer Solutions, a one credit course. Students who cannot develop designs 
are required to take CS 170. If they have no other deficiencies, they "are excused from CS 171. If 
a student cannot write a program in any programming language, he or she must take CS 170, CS 171, and 
CS 161. The Impact of Computer Science's Service Role Computer Science programs have a large service 
load. In many cases, students with other majors are required to learn some computer programming. Many 
of. these other programs allow only a very small number of credit hours in their curricula for this material. 
One or two credit courses in Pascal, Fortran, Basic, Cobol, using software packages, and software packages 
or, microcomputers could be offered by Computer Science to be used by these programs. The other programs 
frequently offer supplementary material oriented towards their own disciplines in one credit courses 
or as parts of other courses 226 CS 170: Introduction to Computer Science I 6 repeat, while ;Weekl ISubjectl 
1 intr.oduction, grading policies, sources for help, what a computer can and cannot do 2 Pseudocode, 
expressing algorithms :3 analyzing an assignment, designing a solut;on 4 structured programming 5 arrays, 
simple numerical proce.ss~ng 6 stacks, expression evaluation 7 characters, strings, string processing 
8 computer, organization, computer model 9 processors, peripherals 10 computer uses in business, sclence, 
engineering and the home Figure i: The First Course CS 171: Introduction to Computer Science II IWeeKl 
ISubjectI i oseudocoOe r.evtew, queues 2 linked lists 3 binary trees 4 t~ees 5 graphs 6 algorithm analysis 
 7 sorting and searching S impact of computers on society 9 ethics in the use of computers i0 careers 
in computer fie~ds Figure Two: The Second Course CS 161: Pascal Programming this course meets twice 
a week IWeek.I ISubject; 1 course overview, samp!e programs 2 assignment, arithmetic, documentation 
requirements 3 case, for, procedures 4 if,. formated i/o 5 character operations 7 recursion, user defined 
types 8 records, arrays 9 sets I0 abstract data types Figure Three: A Language Course References i. 
ACM Curriculum Committee on Computer Science, "Curriculum "78", Communications of the ACM, Volume 22, 
no. 3(March, 1979), pages 147-166. 2. Behforooz, Ali and Onkin P. Sharma, "A One Year Introductory Course 
for Computer Science Undergraduate Program", ACM SIGCSE Bulletin, Volume 13, no. ! (February, 1981>, 
pages 46-49. :3. Cooper, Doug and Michael Clarity, 10h! Pascal t i , W.W. Nortor~ &#38; Co., New York, 
1982. 4. Dersham, Herbert, "A Hodern Ir, troouctory Ccmputer Science Course", ACM SIGCSE Bulletin, Volume 
IS, no. 1 (February, 19Bl>, pages 177-181. 5. Foley, David M., "Program Documentation at Wichita State 
University", ACM SIGCSE Bulletin, volume !5, no. 1 (FeDruary, 1983), pages !33-136.  6. Ford, Gary, 
"A Software Engineering Approach to First Year Computer. Science Courses", ACM SIGCSE Bulletin, Volume 
I4, no. 1 ( February, 1982), pages 8-12. 7. Meinke, John and John Beidler, "Alternatives to the Traditional 
First Course in Computing", ACM SIGCSE Bulletin, Volume i3, no. 1 <February, 1981>, pages 57-61.  8. 
Richards, Thomas C., "Introduction to Computing Via PSI", ACM SIGCSE Bulletin, Volume 14, no. 1 ~ February, 
1982), pages  60-63. 9. Richards~ Thomas C., "Cost Effective ~ethods for. Teaching Introductory Programming", 
ACM SIGCSE Bulletin, Volume ~4~ no. 1 (February, i982>, pages 128-132. 22? Appendix A Sample Examination 
 This test is used to he!p determine which Computer Science courses you need to take. You shou!d do as 
well as you can. If ×ou cannot answer a question completely, answer" as much as you can. The material 
is oriented towards how we do things here and does not necessarily ref!ect xour overall knowledge of 
programming and Computer Science. We use the Pascal programming language as our main programming language. 
if you know Pascal, write the requested programs in PaScal. If you Know another language instead, write 
the programs in that ianguage. We use pseudocode as our way to express designs. Pseudocode has been 
called structured English or tight English or pidgin in some places. If you know a form of pseduocode, 
use it. If you know another way to express a design ( flowcharts or whatever) instead, use that. If you 
do not know any way to express a ~esign, use English. Be as detailed as possible in your description. 
If you cannot solve the given problem, modify it into one as close to the original as possible which 
you can solve. You will have forty-five minutes for. one question. We expect you to spen~ roughly fifteen 
minutes thinking about the or.ob!em, fi÷teer, minutes developing the design, and fifteen m~nutes writing 
the program. If xou feel the problem is not completely specified, make whatever assumptions you need 
and write them immediately after the problem description. You are to design and program the solution 
to the foilowing problem. Read in two character strings. The first is the pattern of up to ten characters 
and the second is the target of up to sixt× characters. Each string ends with a period which is not part 
of the string. ]here are no periods in either string. Write out how many timesthe pattern occurs in the 
target. Example: pattern: aba target: baababababb you should write out 3. Other Sample Examination 
Problems i. Read in a list of one hundred numbers, one per record, and write out the number which occurs 
most often in the list. If two or more numbers occur equally often, write them all out in ascending order. 
 2. Start with a Fahrenheit temperature of 80 degrees. Use a linear search method to find the Fahrenheit 
temperature whose corresponding Celsius temperature is exactly the same. You may use the formula that 
the Celsius temperature, c, corresponding to a Fahrenheit temperature, f, is c = 5/9 * ( f-32> Your 
result need be accurate to only two decimal digits. 3. You read in successive character strings, one 
per record, the last record contains the word DONE and nothing else. This last record should not be included 
in your processing. Find the character string with the longest run of embedded blanks and write it out. 
No string is longer than sixty characters.  4. Read in the integer coefficients for two cubic polynomials 
in a single variable  x. The first record contains the four coefficients for the first polynomial starting 
with the x cubed term. The second record contains the four coefficients for the second polynomial. Print 
out all the integer values of x where the two polynomials have the same value plus or minus 0.5. 5. 
Two numbers are relatively prime if they have no factors in common except the number one. Write a program 
which reads in two positive integers and writes out "yes" if they are relatively prime and "no" if they 
are not. 6. Write a program which reads in a single character string of up to seventy characters and 
writes out the signiture for that string. The string's signiture consists of its characters in alphabetical 
order with duplicates removed and each character followed by the number of times  it occurs in the original 
string.  7. We are given two points in the form of pairs of integers (e.g., (100,320) and (450,30)) 
and we want to figure out whether a line from the first point to the  second goes: 228 a). up and to 
the left; b). up and to the right; c), down and to the left; d). down and to the right; e). straight 
up; f). straight down; g). straight left; or h). straight right. X-coordinates are assumed to increase 
from left to right while y-coordinates inc,rease from bottom to top. write a program which reads in 
the two points and writes out one of the eight strings above to indicate the situation. 8. Write a program 
which reads in a text of up to fifty lines of up to seventy characters each and develops a concordance 
for that text. A concordance lists each word in lexigraphic order (like a dictionary) and gives a list 
of the line numbers for the lines on which that word appears. Assume that every word fits entirely on 
one line, the maximum word length is twenty characters and the maximum number of times a word appears 
in the list is one hundred. Punctuation is limited to the period, comma, semicolon 9 colon, question 
mark, exclamation point, and quotation marks. 
			
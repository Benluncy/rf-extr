
 Bringing Real-World Sdtware Development into the Classroom: A Proposed Role for Public Software in Computer 
Science Education Daniel Nachbar Public Software Institute nachbar@public-software.org http://web.pubIic-software.org/ 
II ,Abstract A proposal is made for, combining ongoing volunteer efforts to produce and Ii-eely distribute 
real- world, consumer-oriented software with the existing curricula in computer science. The differences 
between such an endeavor and currently ongoing free software efforts are described The pedagogical advantages 
of working with and contributing to such an effort are explored Potential enhancements to existing course 
work are discussed, as are some possible new avenues of instruction. The economic viability of such an 
enterprise is also briefly described. ( / Introduction . The idea of providing source code to, others 
for use and study is as old as the field of computing. Colleagues have long shared code for purposes 
of explanation and instruction. Most of the time, such sharing takes place on an informal, small-scale 
basis. In other ways, such as the comp.sources Usenet groups; source code is broadcast for wider use. 
, And on a still larger scale,. there are entire organizations, such as the Free Software Foundation, 
whose sole purpose is to create and freely distribute programs in source code form to the computing community. 
Given such large and long-lived efforts, it is surprising that freely distributed code is not a regular 
feature of computer science instruction. Certainly there have been successes. The GNU C compiler, for 
instance, enjoys wide regard and use. But freely available software is not regularly incorporated into 
instructional material, and students, as part of their course work, rarely contribute to the body of 
freely available source code. Permissionto make digitalih~d copies of all or part of this material for 
personal or classroom use is granted without fee provided that the copies arenotmade or distributed for 
profit or commercial advantage, the copy- right notice, the title oftbe publication and its date appear, 
and notice is given that copyright is by permissiod of the ACM, Inc. To copy otherwise, to republish, 
to post on servers or to rediibute to lists, re&#38;res specific permission and/or fee. SIGSCE 98 AtlantaGA 
USA Copyright 1998 0-89791-994-7/98/2..%5.00 Students rarely work with large collections of source code, 
either freely available or proprietary/private, for two primary reasons. Freely available packages are 
of uneven quality, are not centrally indexed, and often require a great deal of work from instructors 
in, order to prepare lessons. The owners of proprietary software packages are reluctant to risk loosing 
control of their intellectual property in the name of furthering education. Students rarely contribute 
to the body of freely available software for similarly understandable reasons. There is little point 
in making software generally available if it is not going to be generally useful. And making software 
generally useful is an ongoing process. It is not enough to simply place, code on an anonymous ftp site. 
Issues of maintenance, technical support, etc., all need to be addressed. While writing software is certainly 
within the educational realm, providing customer support, maintenance, etc., are not. We suggest that 
there is a missing piece of the puzzle. We see a role for a new type of organization that facilitates 
student experience with and contributions to a large collection8 of freely available, generally useful 
software. This new organization will make large bodies of work available for use by students without 
placing undue burdens on instructors. Similarly, our new organization will fill the gaps (service, support, 
etc.) needed to make the products of student labor truly useful. We coin a new term, Public Software, 
to describe the pool of freely available software that our new organization will maintain and nourish. 
Our Public Software organization will both enhance computer science education and pursue other public 
goods as well. In order to place its educational role in a larger context, we next describe some practical 
issues, such as how this new group will differ from existing free software organizations and be economically 
viable. ,We then outline some of the educational opportunities created. Last, we discuss how such an 
organization would collaborate -with educational institutions. . How Is Public Software Different? Organizations 
that sponsor and develop freely avaiIable software are not new. They vary in formality and focus. Some 
are loose confederations of like-minded developers, such as The Apache Group or FreeBSD. Others are more 
formally organized not-for-profit corporations, such as the Free Software Foundation. The Public Software 
Institute shares many of the goals of other groups. The differences lie primarily in how each goes about 
its work. One consistent feature of current free software organizations is a focus on the development 
and promotion of a particular technological direction. Whether they support a particular programming 
language (Python.org, Perl.org, etc.)- or a complete computing environment (as with the FSF sGNU project), 
current free software groups typically focus on what is being produced rather than how *it is being produced. 
 But our Public Software entity is not limited by a technological focus. There are two advantages to 
this approach. The first is freedom: we can choose technologies that most readily meet the needs of educators. 
The second is ,flexibility: products can be selected to forward a variety of goals. For instance, given 
the recent concerns over> intrusions of privacy by Web browsers, Public Software could be used to create 
programs that provide the public with,a model for software that respects user. privacy. Choosing projects 
that further these broad public ends also greatly enhances the economic viability of Public Software 
(as will be discussed in more detail below). ;. I 1,  Another difference lies in the relationship between 
public and private software development efforts. A happy public-private coexistence has not typically 
been a central goal of other organizations operating in the arena of freely available software. 1 One 
particularly strident view on matters of intellectual property manifests itself in the GNU General Public 
License used by many free software efforts. As one of its most salient features, the GNU license requires 
that if any part of a free software program is incorporated into a work of private software, the whole 
private software:program ,must also be available in source code form.3 Such a requirement makes the free 
software much less useful to the private software industry. Obviously these legal restrictions do not 
apply to the use of freely available tools such as compilers and editors, but their source codes per 
se becomes ess entially off limits. Complex licensing arrangements (the GNU General Public License is 
some 20 pages in length) are also difficult to understand, adding another hurdle to participation and 
use. There is no need to rely upon such legal complexities in order to fulfill the goals of Public Software. 
The distribution of code can be made under fairly simple terms. Placing code into the public domain has 
its own risks, wherein the entire programs can be simply relabelled and sold outright without attribution, 
etc., but a more balanced arrangement can be created with an eye toward ease of distribution and use. 
We would expect that Public Software code would be freely distributed for anyone to use, modify, study, 
freely redistribute, etc. The one exception, other than prohibiting wholesale relabeling of entire programs, 
would be the use of pieces of Public Software source code as part of private software. As mentioned above, 
many free software efforts completely forbid the use of their code in private, binary-only, form. The 
middle ground that we propose would allow the authors of private software to use, modify and study Public 
Software source code just as anyone else might. But, if they wish to incorporate it into programs delivered 
in binary-only form, then they will need to pay a modest licensing fee to the appropriate Public Software 
organization. We will discuss these licenses later. , The last difference we will mention is the breadth 
of services offered to support Public Software programs. Typically, free software organizations only 
produce and distribute programs and their associated documentation, However, the software life cycle 
does not end with delivery of the finished product. In .order to bring aspects of the entire software 
life cycle into the educational arena, our proposed Public Software organization will provide services 
to users. In addition to furthering the breadth of its educational goals, providing support services 
will make Public Software programs a more practical choice for users and help support the Public Software 
operation. It should be clear that since the Public Software source code is freely available, users will 
in no way be compelled to use the services of the organization that distributes the source code. We expect 
that other individuals and organizations will provide such services, However, some users will prefer 
the convenience of one stop shopping for software and support. There is little point in considering the 
educational benefits of Public Software if such an operation is financially unsustainable. Therefore, 
we turn our attention to the issue of paying for the coordination and distribution activities of our 
Public Softw,are organization. Of course as with any worthy cause, philanthropic support may be available. 
But,long-term viability can not be based upon the contributions from a few individuals or foundations. 
In the long term, we see substantial support coming both from end users of Public Software programs and 
from private software developers. We view Public Software as serving a role very much like that of Public 
Television. Public Television coexists comfortably with private television. Public Television even relies, 
to some extent, upon private television for financial support. Similarly, we expect that Public Software 
can coexist with private software and see private software as contributing financial support to Public 
Software. Support from end users will come in two forms. The first is membership dues. As-with Public 
Television, a small portion of users will choose to support public resources even though they are not 
required to do so. To garner the widest possible support, the products created by Public Software should 
include those withI:the .widest possible audience. This makes desktop productivity applications such 
as Web browsers, spreadsheets,- and WYSIWYG word processors the logical choice. Building these popular 
applications as products also provides some interesting educational benefits, as described below. Further, 
producing some of them, particularly information access tools such as Web browsers, will serve to clear 
the fog that currently exists in some current public policy debates. But desktop productivity applications 
are just one example of what can be produced The virtues of Public Software lie primarily not in what 
is produced, but how. The second form of end-user support will come from fees charged for technical support, 
training; etc. As mentioned above, users need more than just software to get their jobs done. If it were 
practical, a Public Software organization would provide support services for free. But unlike using software, 
where each additional user places no particular burden on the software provider, the cost of providing 
support is directly related to the number of people receiving service. As such, it is impractical to 
provide such services for free. We expect third parties will provide support services for Public Software 
just as they do for other freely available software today. Our. Public Software organization would simply 
do cthe same and charge a fee as determined by the market for such,services. The profits resulting from 
providing services will be used to further Public Software. The authors of private software would provide 
support for the Public Software organization by paying licensing fees for the Public Software products 
used in their private binary-only products. For the sake of simplicity, one fee would allow developers 
to use all of the products produced by the Public Software organization. Presumably, large corporations 
would pay more than individuals, but in all cases, these licensing fees will need to be very modest. 
Otherwise, developers will be inclined to turn their backs on Public Software and nothing would be gained 
by-either the private or the public sector. Obviously, individuals and institutions that contribute their 
work to a collection of Public Software would by virtue of that contribution have their licensing fees 
waived. ! New Educational Opportirnities -. Today, most students of computer science complete their course 
of instruction without ever having worked on a very large software project. This situation is analogous 
to a student of agriculture leaving school having never seen a real cow. They will have read about cows, 
done laboratory experiments with milk, and contemplated cows at great length. But much is lost by not 
working with the real beast. Life-size software systems are also beasts. They are untidy, smelly and 
unruly. They have sharp bits and bad habits that can cause great discomfort to the unwary. In short, 
they bite and kick. We do a great disservice to students by sending them into a world of such beasts 
with only abstract warnings of the difficulties they will face. Perhaps the most beastly aspects of real 
projects are their scale and complexity. Even modestly sized systems can contain millions of lines of 
code in scores of modules. Students are frequently admonished about the value of farsighted design, straightforward 
implementation, proper testing and clear documentation. But no amount of jawboning can compare with confronting 
students with a system of a scope and complexity that simply exceeds the comprehension of any single 
individual. The humility imparted by such an experience may, in itself, justify the work of providing 
it. 1 I The availability of large systems also makes practical more thorough instruction in particular 
aspects of system development. For instance, we can create entire courses on testing that draw from different 
aspects of system operation. The testing of GUIs is different from the testing of networking components, 
which is different still from the testing of real-time systems. Further, we can also explore the interactions 
between tests at different levels of system granularity. Similarly rich curricula could be designed for 
technical writing, and so forth. While some of these approaches could draw from pieces of different systems, 
having the work drawn from a single large system . makes the interactions between tests more obvious 
and eliiates the sense that lessons are unrealistically contrived. , Another practical reality of large, 
real-world systems is that they are almost always incomplete. As such, they present an opportunity for 
students to add features and/or modify existing code rather than starting from scratch. The- value of 
readable code, accurate documentation, and, a well-designed regression test suite becomes abundantly 
clear. Large systems are always imperfect, but in these imperfections lies still more educational opportunity. 
In particular, one can provide frighteningly realistic instruction in software maintenance. Initial lessons 
might involve small pieces of code with easy-to-find errors. By the end of the,course, a typical lesson 
might be to provide each student with a million lines of source code and a vaguely worded (i.e., true-to-life) 
bug report. Without a large-scale system on which to work, such a range of lessons would be impossible. 
, The inherent imperfections in large systems also provide opportunity on another dimension. All of the 
avenues of work mentioned above could be enriched by using both well-done and not-so-well-done systems. 
For instance, the near impossibility of properly testing a module with an incomplete or vague specification 
could be nicely contrasted with the same task using a well-done specification. Likewise, modification, 
finding bugs, documentation, etc., could all be explored in systems where the pieces fit well and where 
they do not. : Despite our best efforts, it will be almost inevitable that the source code of Public 
Software projects will contain examples of both good and not-so-good style. As such, it can contribute 
to a literature for critical analysis of software. Over time, as modules are reworked, instructors can 
present students, with the development history of a particular piece of code; Likewise, as rehnplementations 
occur over time, there will be cases where different implementations solve the same problem in different 
ways. Having concrete examples of multiple solutions to the sarne~ problem will be useful for refining 
students critical skills. But perhaps the most unique opportunity created by working with a Public Software 
collection is the view it provides into the life of software after its initial development:,;. For instance, 
a project could be created during one academic year, beta tested with real users during the summer,- 
and then handed back to the implementers when they return the next fall to then respond to user feedback.- 
. I Otheri &#38;ects of the software business can be explored, since our Public Software, organization 
also provides support services for software. It would be quite practical to arrange for students to spend 
some time handling customer support calls, training users, etc. I Such experiences, while never central 
to an academic program, would serve well tom give students a clear sense of the context in which software 
is used. We mentioned earlier that the products of Public Software might well include popular applications, 
such as word processors and spreadsheets. The choice of such applications as targets also has educational 
advantages. Most students will be users of these applications before entering computer science programs. 
Consequently, educators can present students with assignments based on programs with which they are already 
familiar. For instance, they: might: be asked to build a string search mechanism for a word processor 
or a expression evaluator for a spreadsheet..,iSuch, work would be grounded in the real world,1 thus 
avoiding lengthy explanations on the part of the instructors and confusion on the part of students as 
to what is expected. ,i / I, _ Another advantage of basing instruction on common applications is the 
chance for students to look under the hood of applications with which they are already familiar as users. 
The process of demystifying what was previously incomprehensible can be one of the most satisfying aspects 
of any educational endeavor. And lastly we would include the inspirational advantage of having students 
contribute to an ongoing software effort. Or to put it another way, students often feel frustration at 
working long and hard on projects only to have their work discarded at the end of the semester. This 
frustration becomes particularly acute toward the end of a course of study when work is becoming more 
sophisticated and potentially useful. Some solace is gained when students can contribute to ongoing research 
projects, but such opportunities are not always available or practical. The goal would be to provide 
a means for students to make a contribution to a broad public good without distracting instructors and 
students from the educational focus at hand. Collaboration with Educational lnstittitions Obviously the 
first responsibility of educational institutions is to teach. The prospect of working with a collection 
of Public Software is only plausible if the costs of doing so do not exceed the benefits. In the previous 
section, we described some of the educational benefits. Here we describe how to keep the costs of such 
a collaborative process within reason. It will be important for any Public Software organization to do 
as much of the leg work as possible to minimize the preparation needed by individual instructors in preparing 
exercises, etc. For several reasons, we think this task will be less burdensome than might first be imagined 
First, the staff who coordinate the development process will, by the very nature of that work, be intimately 
acquainted with the code in the collection. It will be far less work for them to identify interesting 
tasks and problems than it would be for someone unfamiliar with. the code. Also, some instructors will 
find it useful to craft their own exercises based on Public Software. We assume that some of them will 
be public spirited enough to allow their work to be used elsewhere. In either case, substantial economies 
of scale apply. Public Software projects will not be useful in all, or even most, courses. However, courses 
that focus on Software Engineering will often be appropriate. The educational focus of such courses typically 
centers on the quality of software produced as opposed to the quantity or function of the software (the 
how of software as opposed to the what ). Also, such courses often involve group projects. As such, they 
are more amenable to work on larger modules of code and likely to yield results that are large enough 
to be useful. Use in other courses, such as data structures, Human Factors and Applications Programming, 
will certainly be appropriate in some cases. We also expect that Public Software will provide opportunities 
for many students working on senior-year or master s degree projects. The pedagogical goals of educational 
institutions are most readily forwarded by using Public Software rather than creating and maintaining 
it. But clearly, the use of and contribution to a Public Software collection are not entirely separable. 
For any collaborative effort to be sustainable, the parties involved must see a net gain from the arrangement. 
In this case, the labor provided by the students themselves is harnessed to make the collaboration workable. 
And from the students point of view, the arrangement is beneficial because of the enhanced educational 
opportunities provided along with the fact that, at present, their energy is being dissipated. Other 
Potential Contributions to Research The potential contributions of Public Software to the field of computer 
science are not limited to enhancing instruction. Such a collection could surely be used as a testbed 
for collaborative development technologies, testing methodologies, etc. Few other opportunities exist 
for investigators to have access to a large, dynamic set of code. Private software is typically out of 
reach, and, as mentioned earlier, other free software efforts typically focus on what is being developed 
as opposed to how it is created and maintained. Broader research goals can also be addressed by choosing 
to develop different products. For instance, while we have mentioned spreadsheets as having some advantages 
in terms of attracting popular support and providing a familiar context for students, much the same work 
could be redirected to produce freely available data analysis software. The point, once again, is that 
Public Software, by virtue of focusing on the software development process, is free to address other 
interests as they arise. Conclusion The Public Software Institute was formed to pursue this vision. Operating 
as a not-for-profit educational organization, the Institute will work to combine real-world software 
with computer science education to the betterment of both. _ During the fall 1997 semester, there were 
75 students at two colleges participating in pilot development projects. We are actively seeking more 
schools to work with us. Our plans call for steadily increasing the number of participants over the next 
two years until there are some 500 students at a score of schools involved du&#38;g the fall of 1999. 
We expect our first products to be completed in early 2000. . Admittedly, our organization is still in 
its infancy. Much needs to be done in order to structure the work ahead. One of the first tasks at hand 
is to determine how to make a Public Software collection most useful as a curriculum resource. Obviously, 
the people best equipped to help define those needs are educators in the field We look forward to working 
with instructors on this endeavor. _~ / , * , . ,  _-- ---=a:= . ,, _ , . . _.  
			

 Composite Objects Revisted Won Kim, Elisa Bertino, Jorge F. Garza Microelectronics and Computer Technology 
Corporation 3500 West Balcones Center Drive Austin, Texas 78759 ABSTRACT In object-oriented systems, 
an object may recursively reference any number of other objects. The references, however, do not capture 
any s cial relationships between objects. An im ortant semantic F which may be superimpose B on re ationship 
a reference is the IS-PART-OF relationship between a pair of objects. A set of objects related by the 
IS-PART-OF relationship is collectively called a composite object. An earlier paper [KIM87b] presented 
a model of corn osite objects which has been implemented in the 0 A!ION object-oriented database system 
at MCC. Although the corn osite-object feature has been found quite useful, the m$ el suffers from a 
number of serious shortcomings, primarily because it overloads a number of orthogonal semantics on the 
references. In this paper, first we preseni a more general model of comnosite obtects which does not 
suffer from these shortcomings. F&#38;her, [KIM87b] made an important extended mode versions, physical 
clustering and concurrency control, but also authorization. 1. Introduction Ob ect-oriented data models 
[ANDR87, BANE87a, COP L3 4, FISH871 (and most semantic data models [HAMM81]) allow the definition of 
arbitrarily complex objects as nested objects of arbitrary depth. An object has a number of attributes; 
the value of an attribute is itself an object. An object belongs to a class; a class may be a primitive 
class without any attributes (e.g. integer, string), or may have any number of attributes. An obiect 
wrth an attribute whose value is an obiect which belon to a non-primitive class is a nested object. -AAn 
object may ff ave any number of attributes, and any of the attributes may take values from other non-primitive 
classes. The nesting of objects inherent in an object-oriented data model is a powerful concept; however, 
it does not imply some s ecial relaiionships between objects which may be im -itant to CF classes of 
applications. One important re atronship ifferent p . which should be superimposed on the nested object 
is the Permission to copy without fee all or part of this material is granted provided that the copies 
are not made or distributed for direct commerciaJ advantage, the ACM copyright notice and the title of 
the publication and its date appear, and notice is given that copying is by pemksion of the Association 
for Computing Machinery. To copy otherwise, or to republish, reqkes a fee and/or spzcific permission. 
0 1989 ACM O-89791-317-5/89/OCQ5/0337 $1.50 IS-PART-OF relationship, that is, the notion that an object 
is a part of another object. A set of component objects which form a sin le lo ical entity has been called 
a composite object KIM87b, ST&#38;l68 or a complex object [LORI83, KIM87a]. 4 RION is perhaps the first 
database system which supports an object-oriented data model extended with the IS-PART-OF relationship. 
[LORI83, STON86] report prototyping efforts to extend the relational model of data with complex objects. 
ORION provides direct system support for composite objects as a unit for one type of semantic integrity, 
physical clustering, and locking. [KIM8%] also defines the semantics of versions for composite objects 
by extending the model of versions for non-nested objects; ORION currently supports versions of normal 
objects, but not composite objects. [RABI88] presents the framework for a model of authorization, in 
which an attempt is made to define comnosite obiects as a unit of authorization. Composite objects have 
been found quite useful for a number of anulications of ORION. includine some mechanical CAD ayplications. 
However, the mode7 and implementation of composite objects, as presented in [KIM87b] and implemented 
in ORION, suffer from three major shortcomings. First, the model restricts a comnosite obiect to a strict 
hierarchy of er&#38;.ri~e component objects; that is a component obiect is only Dart of one comnosite 
obiect. This is ccrtainlv the right modei for a physical p&#38;t hierakhy, in which an object cannot 
be part of more than one object. However, this is not acceptable for a logical part kierarclg~; for example, 
an identical chapter may be a part of two different books. Second, the model forces a top-down creation 
of a composite object; that is, before a component object may be created, its parent object must already 
exist. This prevents a bottom-up creation of objects by assembling already existing objects. Third, the 
model requires that the existence of a component object depends on the existence of the parent object; 
that is, if an object ceases to exist, all its component objects are also deleted. This feature is sometimes 
desirable, since it frees the applications from havin to search and delete all nested %.components of 
a deleted o ject. Sometimes, however, it impedes reuse of objects in a complex design environment. The 
objective of this paper is to describe significant semantic extensions to the model of [KIM87b] which 
were necessary to eliminate these shortcomings while retaining the advantages of the previous, more limited 
model. To support the semantic extensions, we needed to extend various aspects of the ORION system implementation. 
In doing so, we further augment the use of composite objects as a unit of authorization, beyond their 
use as a unit of concurrency control established m [KIM87b]. The remainder of this paper is organized 
as follows. Section 2 presents the extended semantics of composite objects. Section 3 describes operations 
which can be performed on composite objects and specific components of a composite object. Sections 4, 
5, and 6 discuss the impacts of the extended semantics of composite objects on schema evolution, versioning, 
and authorization, respectively. Section 7 describes the use of composite objects as a unit of locking. 
Section 8 summarizes the paper. 2. Basic Extensions We will first define the extended semantics of composite 
objects. Then we will formalize essential aspects of the semantics. Further, we will make the discussion 
concrete by providing examples of composite objects, and considering basic implementation issues. 2.1 
Semantics of References We say that an object 0 has a reference to (or references) another object 9, 
if O contains the object identifier (UID) of 0. We will distinguish two types of reference from one object 
to another: weak and composite. A composite reference in turn may be of two types: exclusive and shared. 
A weak reference is the standard reference in object-oriented systems and carries no special semantics. 
A corn osite reference is a weak reference P relationship; a composite augmented with the IS- ART-OF 
reference from 0 to 0 means that 0 is a art of 0 . The semantics of a composite reference is further 
re Pmed on the basis ofwhether an object is apart of only one object or more than one object. An exclusive 
composite reference from 0 to 0 means that 0 is a part of only 0 ; while a shared composite reference 
from 0 to 0 means that 0 is a part of 0 and possibly other objects. We further refine the semantics of 
a composite reference, either exclusive or shared, on the basis of whether the existence of an object 
depends on the existence of its parent object; that is, a composite reference may be dependent or independent. 
A dependent composite reference from 0 to 0 means that the existence of 0 depends on the existence of 
0 ; while an independent composite reference does not carry this additional semantics. The deletion of 
an object will tri er recursive deletion of all objects referenced by the o lect F throughdependent composite 
references (both exclusive and shared). The above discussion reveals the following five types of reference 
between a pair of objects. The composite reference defined in [KIM87b] is only the dependent exclusive 
composite reference. 1.weak reference 2. dependent exclusive composite reference 3. independent exclusive 
composite reference 4. dependent shared composite reference 5. independent shared composite reference 
 The objects related through composite references form a part hierarchy. The classes to which the objects 
in the part hierarchy belong are also organized in a hierarchy called a composite class hiemwhy; each 
class in the hierarchy is called a component class. The root of a composite object is a special object. 
Under the model of [KIM87b], the root of a composite object never changes (because of the top-down creation 
of a composite object). Under our extended model, the root of a composite object may change; that is, 
an object which is the current root of a composite object may become the target of a composite reference 
from another object. A reference from an ob ect 0 to another obiect 0 means that the value of an attribute 
o 10 1s the identifier of 0. The values of an attribute of a class c are instances of a class C: the 
class C is the domain of the attribute of C . If an attribute has a composite reference, the attribute 
is called a composite attribute. The meanings of the terms exclusive compo-ite attribute and shared composite 
attribute should be obvious. We distinguish two types of part hierarchy: physical and logical. In a physical 
part hierarchy, all composite references are exclusive; while a logical part hierarchy may also contain 
shared composite references. The physical part hierarchy is the composite hierarchy currently implemented 
in ORION.  2.2 Formalization of the Semantics We observe that different tvnes of reference oartition 
the set of objects which reference a g&#38;en object into four different sets of ObJects. We may formalize 
a few important aspects of the extended semantics of composite objects in terms of constraints on these 
sets of objects. Definition 1: With respect to an object 0 in a composite object, Ix(O) = (0.i ] 0.i 
has an independent exclusive composite reference to 0) DX(0) = (0.i ] 0.i has a dependent exclusive composite 
reference to 0) IS(O) = (0.i ] 0.i has an independent shared composite reference to 0) DS(0) = (0.i ] 
0.i has a dependent shared composite reference to 0). We formalize the deletion of an object 0 , denoted 
by del(O ), with respect to the four types of composite reference from 0 to another object 0. 1) Independent 
exclusive composite reference from 0 to 0 del(0 ) # > del(0). 2) Dependent exclusive composite reference 
from 0 to 0 del(0 ) = > del(0). 3) Independent shared composite reference from 0 to 0 del(0 ) # > del(0). 
4) Dependent shared composite reference from 0 to 0 del(0 ) = > del(0) only if DS(0) = (0 ).That is, 
the deletion of 0 causes the deletion of 0 only if all other dependent shared composite references to 
0 have been removed; otherwise DS(0) = DS(0) -0 . In the remainder of this paper, we will use the termsparent 
set and ancestor set of an object 0 as the set of objects which have direct or indirect composite references 
to 0, respectively. The term component set of an object 0 will denote all objects directly or indirectly 
referenced from 0 via composite references. Further, given two objects 0 and 0 , we say that 0 is a level 
77 component of 0 if the shortest path between 0 and 0 has n composite references. The five types of 
reference we have defined may be combined to generate arbitrarily complex object topologies . The following 
set of topology rules represents constraints on the ob ect topologies based on the semantics of different 
types of relJerence. In the following, card(S) denotes the cardinality of a set S. Topolog Rule 1: card 
(IX(O)) I 1 card @X(O)) < 1 Topolog Rule 2: card (IX(O)) = 1 = > card @X(O)) = 0 card (DX(0)) = 1 = 
> card (IX(O)) = 0 If an object 0 has an independent exclusive composite reference to it, then it cannot 
have a dependent exclusive composite reference from another object; and vice versa. Topolog Rule 3: (card 
(IX(O)) = 1 or card@X(O)) = 1) = > (card(IS(0)) = 0 and card(DS(0)) = 0)(card (IS(O)) > 0 or card(DS(0)) 
> 0 = >(card(IX(O)) = 0 and card@X(O)) = 0) If object 0 has an exclusive (either independent or dependent) 
composite reference from an object, then it cannot have shared (either independent or dependent) composite 
references from other objects; and vice versa. Topology Rule 4: An object 0 can have any number of weak 
references to it, even when it has composite references to it. Suppose that we wish to make an object 
0 a art of an object 0 through an attribute A of 0 . The P . fo lowmg are the conditions which must be 
satisfied. Make-Component Rule: 1.If A is an exclusive composite attribute, 0 must not already have any 
composite reference to it (exclusive or shared). 2.If A is a shared composite attribute, 0 must not already 
have an exclusive composite reference. The following summarizes the semantics of the deletion of an object 
in a composite object. Deletion Rule: Suppose that 0 is the root of a composite object and that 0 is 
a, component of.0 . = > del(0) if any of following three conditions E$i ) 1. 0 has a dependent exclusive 
reference to 0. 2. 9 6,~ a dependent shared reference to 0 and DS(0) = 3. An ob ect 0 exists such 
that del(cl9) = > del(0 ) and either (3.a) or (3.b) olds:  3.a 0 has a dependent exclusive composite 
reference to 0 3.b 0 has a de endent shared composite reference to 0 and I%(O) = (0 ).  2.3 Syntax 
Extensions class definition To support the extended semantics of a composite reference, we extend the 
ORION s tax for attribute specification in the class definition [BANE8 T a] as follows: (AttributeName 
:init InitialValue]1 DomainSnecl \ :domain :inherit-from Sup&#38;&#38;ss] :document Documentation] :share 
SharedValue] :composite TrueOrNil] :exclusive TrueOrNil] ::dependent TrueOrNil] The keyword composite 
when set to True specifies that the reference is a composite reference. If the keyword exclusive is also 
True, the composite reference is an exclusive composite reference. If the keywords composite and dependent 
are both True, the reference is a dependent composite reference. The default value for both the exclusive 
and dependent keywords is True (to be compatible with the semantics of composite objects currently supported 
in ORION). Below we provide two examples. The first is a physical part hierarchy; and the second a logical 
part hierarchy. Example 1: Let us consider aVehicle composite hierarchy. We require that a vehicle part 
may be used for only one vehicle at any point in time; however, vehicle arts may be re-used for other 
vehicles. The definition for the c Pass Vehicle is as follows (for simplicity we omit the definitions 
of all domain classes): (make-class Vehicle :superclasses nil :attributes ( [I$;;facturer :domain Company) 
0 :domain AutoBody:composite true :exclusive true :dependent nil) (Drivetrain :domain AutoDrivetrain 
:composite true :exclusive true :dependent nil) (Tires :domain (set-of AutoTires) :comnosite true :exclusive 
true :dependent nil) (Color :domain String))) Since all composite attributes in the class Vehicle are 
exclusive references, a set of vehicle components (Body, Drivetrain, and Tires) may be used for only 
one vehicle. However, since the exclusive references are independent, the components can be re-used for 
other vehicles,, if the vehicle which they constitute is dismantled later. The vehicle components may 
exist even if they are not part of any vehicle. Example 2: Let us now consider electronic documents. 
Suppose that a document consists of a title, authors and a number of sections. A sections in turn is 
composed of paragraphs. A document may share entire sections or section aragraphs with other documents. 
Annotations may be adde B to documents; however, they are not shared among different documents. Further. 
documents may contain images that are extracted from files: The following are the definitions of two 
of the classes involved, Document and Section: (make-class Document :superclasses nil :attribute ( :domain 
string) :domain (set-of string)) :domain(set-of Section) :composite true :exclusive nil :dependent true) 
 (Figures :domain (set-of Image):composite true :exclusive nil :dependent nil) (Annotations :domain (set-of 
Paragraph)) :composite true :exclusive true :dependent true)) (make-class Section :superclasses nil 
:attribute ( (Content :domain (set-of Paragraph) :composite true :exclusive nil :dependent true)) The 
attribute Content, defined as a set, is a shared composite reference. Other documents may share any element 
in this set (i.e., any section). A section exists, if it belon to at least one document. Similarly, the 
class Section has a Baragraph shared composite reference. A paragraph may be shared among different sections 
(of possibly different documents). For a paragraph to exist, there must be at least one section containing 
it and thus a document containing it. In the case of Annotations we assume that a given annotation is 
used in only one document, thus the reference is exclusive. The attribute Figures is defined as an independent 
composite reference, since the existence of images does not depend on the documents containing them. 
instance creation The following message is used to make an instance a part of one or more composite objects 
at the time of creation of that instance: (make Class :parent (ParentObject. ParentAttributeName.1 b 
arentObject.2 ParentAttributeName.2 I . . . . . . . (Parent0bject.M ParentAttributeName.M)) :Attribute.l 
value.1 :Attribute.2 value.2 . . . . . . . :Attribute.N va1ue.N). The keyword parent is associated with 
one or rnor;{;;;IParent0biect.i ParentAttributeName.ih Parent0bjkct.i with the attribute Parent&#38;ributeName.i 
is to reference the instance being created. If ParentAttributeName.i is a composite attribute, the new 
instance becomes part of Parent0bject.i. Further, if ParentAttributeName.i is a dependent composite attribute, 
then the existence of the new ObJect will depend on Parent0bject.i. When more than one (Parent0bject.iParentAttributeName.i) 
is sDec/Ei such that Parenk4ttributeName.i is a composite attribute, then the instance being created 
is simultaneous1 made a part of all the specified objects. However, because o lJtopology rule 3, these 
attributes must be shared composite attributes. The topology rules are enforced usin the schema definitions 
for classes of ParentObject.1, Parent8bject.2, . . . . Parent0bject.M. Next, if an already existing ob 
ect is made a part of a composite object through an exclusive re /erence, the system must check if there 
are noother composite references to that object. Similarly, if the object is made a part through a shared 
reference, the system has to ensure that there is no exclusive reference to that object. As discussed 
in [BANES7a], the parent keyword in the make statement is used also for clustering purposes. If several 
objects are specified, then the newly created object is clustered with the first specified parent, that 
is, with ParentObject.1. (However, clustering is only performed if the classes of the two objects are 
stored in the same physical segment.) 2.4 Implementation Given a component of a composite object, the 
user often finds it necessary to determine its arents or ancestors. Further, the system needs to determine 
ef P.iaently the parents or the roots of a given component of a composite object to efficiently support 
locking, versions, and authorization of composite objects. We need to maintain in each component of a 
composite object a list of reverse composite references, that is, object identifiers of the parent objects. 
Although it is often useful for the system to be able to determine directly the roots of a composite 
object for a given component object, we have decided not to keep such Information in each component; 
the reason is that the roots of a composite object may change when composite objects are created in a 
bottom-up fashion. Further, we have decided to keep the reverse pointers in each component object, rather 
than in a separate data structure. This approach allows us to avoid a level of indirection in accessing-the 
parents of a givencomnonent, and simulifies deletion and migration of obtects; however, itcauses the 
object size to increase. The number of reverse composite references in a component object is eaual to 
the number of parent obiects. A reverse composite reference actually consists of a couple of flags in 
addition to the obiect identifier of a narent. One flae (D) indicates whether the object is a dependent 
component 6f the parent; while the other flag(X) indicates whether the object is an exclusive component 
of the parent. The following al orithm for making an existing object 0 apart of another object 6 through 
an attribute A illustrates the use of reverse composite references. 1.Access Object 0. 2. If (A is a 
shared composite attribute and the X flag in a reverse composite reference in 0 is set) or (A is an exclusive 
composite attribute and 0 has any reverse composite reference) then return (error). 3. Insert in 0 a 
reverse composite reference to 0 with the D flag set if A is a dependent attribute the X flag set if 
A is an exclusive attribute.  3. Operations on Composite Objects We now discuss operations on composite 
objects. These operations are used to determine the components, children, parents, and ancestors of an 
object. Most of these operations are rather obvious. However, it is important to realize that the purpose 
of modeling a composite object is above all to define operations which directly make use of the semantics 
of composite objects. 3.1. Determining ancestors and components of an object To determine the components 
of an object, the message components-of is used. (components-of Object [ListofClasses][Exclusive] t&#38;zi]) 
If the argument ListofClasses is specified, the messa e returns only components that belong to the specified 
classes. 6 therwise all components of the object are returned. This message can have another optional 
integer argument, Level. This is used to return components of a given object up to the specified Level. 
If Exclusive is True, only the exclusive components of Object are retrieved; and if Shared is True, only 
shared components are retrieved. If both Exclusive and Shared are Nil, all components are retrieved. 
Similarly, to determine the parents or ancestors of a given object, the messages parents-of and ancestors-of 
are used. (parents-of Object ListofClasses] [Exclusive] tShared]) (ancestors-of Object ListofClasses] 
[Exclusive] FShared]) If the argument ListofClasses is specified, the message returns all parents or 
ancestors that belong to the specified classes; otherwise, all parents or ancestors are retrieved. 3.2. 
Predicates on component classes and instances In [BANE87a] messages that act as predicates with respect 
to class objects and instance objects have been presented. Among others, the message compositep is used 
to determine if an attribute of a class has a composite reference property. (compositep Class [AttributeName]) 
If the argument AttributeName is not supplied, the message returns True if the class has at least one 
attribute with such property. Similar messages are defined to determine whether a class has composite 
attributes with exclusive or shared references, and further the references are dependent. exclusive-compositep 
(Y%&#38; [AttributeName]) Idependent-compositep [AttributeName]). To determine if an object Object1 is 
a part of another object Object2, the following message is used: (component-of Object1 Object2). This 
message returns True if Object1 is a direct or indirect component of Object2. To determine if Object1 
is a direct component of Object2 the following message is used: (child-of Object1 Object2). This message 
returns True if Object1 is a direct component of Object2. We note that to determine if Obiectl is a uart 
of Obiect2, the messagecomponents-of can be used to retri&#38;ve the components of Objects followed by 
a scan of the returned set of objects to check if Object1 is in this set. Therefore the message component-of 
can be seen as a shorthand. Similar messages may be defined for determining whether Obiectl is an exclusive 
or . shared component of Obj&#38;t2. (exclusive-component-of Object1 Object2). This messa e returns 
True if Object1 is an exclusive component of Object2 f t returns Nil if either Object1 is not a component 
of Object2, or it is a shared component. (shared-component-of Object1 Object2). This message returns 
True if Ob ectl is a shared component of Object2. It returns Nil if either &#38; bjectl is not a component 
of Object2, or it is an exclusive component. We note that sending the component-of and exclusive-component-of 
messages in sequence has the same effect as the message shared-component-of. In fact, if (component-of 
ObjecllObject2) returns True and a subsequent execution of (exclusive-component-of Object1 Object2), 
in the same transaction, returns Nil, Object2 is a shared component of Objectl. We note that there is 
no need to define a message for determining if an Object1 belongs to the ancestor set of an Objcct2, 
since in this case the message component-of can be used, by passing to it Object2 as the first argument 
and Object1 as second. Similarly, we can use the message child-of to determine if Object1 belongs to 
the parent set of Object2 4. Schema Evolution Schema evolution is the specification of a set of d amic 
changes to the database schema and the semantics of eat I?of the resents a framework for schema Z%ZZn 
t!E%%!!. &#38; e set of schema changes considered consists largely of changes to the class definitions, 
such as adding and deleting attributes and methods; and changes to the structure of the class lattice, 
such as creation and deletion of a class, and modifications to the IS-A relationshi between classes. 
The framework is extended somewhat in r I! IM87bl to consider composite objects in greater detail. The 
extended model of composite ObJects we presented earlier in this aper requires changes to the semantics 
of several types of SC Eema changes defined in [BANE87b, KIM87b], and also gives rise to new types of 
meaningful schema changes. 4.1 Deletion of a Composite Attribute The following is a subset of the schema 
evolution taxonomy presented in [BANE87b]. The schema change operations in this subset are the ones whose 
semantics must be altered to account for the extended semantics of composite references we Dresented 
earlier in this DaDer. These oDerations involve deletion of a corn ite aitribute. The model of composite 
obiects in IKIM8 7r 1 causes all obiects referenced through a coinposite &#38;ibuteio be deleted if the 
attribute is remo\ed; however, the extended model requires only those objects which are referenced through 
dependent composite attributes to be dropped when the attributes are dropped. Drop an attribute A from 
a class C. This operation causes all instances of the class C to lose their values for attribute A. If 
A is a composite attribute, objects that are referenced through A are deleted in accordance with the 
Deletion Rule (Section 2.2). The attribute must also be dronDed from all subclasses that inherit it. 
 Change the inheritance (parent) of an attribute (inherit another attribute with the same name). Remove 
a class S as superclass of a class C. If this operation causes class C to lose a composite attribute 
A, objects (of other classes) that are recursively referenced by instances of C and its subclasses through 
A are deleted according to (1). Drop an existing class C. If the class C has one or more comnosite attributes, 
objects referenced through the attributks are dropped in accordance with the Deletion Rule (Section 2.21. 
All subclasses of C become immediate iubclasses 01 the superclasses of C.  4.2 Changes to the Attribute 
Type Let us now explore meaningful changes from one type of attribute to a different one in the context 
of the extended model of composite objects. The changes may be one of two types &#38;h respect to implementation: 
state-independent and state-dependent changes. Roughly, a state-independent changeis a change which removes 
a constraint from a composite reference, while an state-depenclent clzange adds a constraint to a reference. 
A state-dependent change requires verification of the X (exclusivity) flag in the reverse composite references 
to the objects involved in the change. The following are the state-inde endent changes to the attribute 
which are meaning K 1 under our extended T semantics 0 composite references. Il. Change a composite attribute 
to a non-compositeattribute. This operation is also defined in [BANE87b]. 12. Change an exclusive composite 
attribute to a shared composite attribute. 13. Change a dependent composite attribute (either exclusive 
or shared) to an independent composite attribute. 14. Change an independent composite attribute (either 
exclusive or shared) to a dependent composite attribute.  State-dependent changes to the composite 
attributes are as follows. Let us suppose that the class C is the domain of an attribute A of a class 
C , and that A is to be changed. Dl. Change a non-composite attribute to an exclusive composite attribute. 
There must be no composite (either shared or exclusive) references to instances of the class C which 
are referenced by instances of the class C . D2. Change a non-composite attribute to a shared composite 
attribute. Topology Rule 3 (Section 2.2) must be verified to ensure that there are no exclusive composite 
references to instances of the class C which are referenced by instances of the class C . D3. Change 
a shared composite attribute to an exclusive composite attribute. Topology Rule 3 must be verified to 
guarantee that there is at most one shared reference to instances of the class C which are referenced 
by instances of the class C . 43 Implementation Implementation of changes to the attribute type involves 
accessing referenced objects and updating the D and X flags in the reverse composite references in them. 
The validi of a state-dependent change depends on the consistency o 7 these flags; that is, if the flags 
are not in a state consistent with the semantic requirements of the change, the change is rejected. For 
this reason, state-dependent changes require immediate verification of the flags. However, state-independent 
changes simply require updates to these flags; as such, the changes may be made immediately or deferred 
until the objects actually need to be accessed. Let us first discuss the two options for implementingstate-independent 
than es. The immediate im lementation of the changes is as fo lows. f Suppose that P a c ass C has a 
composite attribute A whose domain is a class C. Il. Change a composite attribute to a non-compositeattribute. 
This is implemented by accessing all instances of the class C and drop ing reverse composite references 
to instances of the P c ass C . 12. Change an exclusive composite attribute to a shared composite attribute. 
This is implemented by accessing all instances of the class C and turning off the X flag in the reverse 
composite references to instances of the class C . 13. Change a de ndent composite attribute (eitherexclusive 
or r independent composite s ared) to an attribute. This is implemented by accessing all instances of 
the class C and turning off the D flag in the reverse composite references to instances of the class 
C . 14. Change an independent corn osite attribute (eitherexclusive or shared) to a depen (P ent composite 
attribute. This is implemented by accessing all instances of the class C and turning on the D flag in 
the reverse composite references to instances of the class c .  The deferred implementation of state-independent 
changes involves keeping an ovemtion Ion of changes to the attribute types in a classy A class has n 
operation-logs, one for each attribute of which the class is the domain. An operation loe for a class 
C maintains, for each change, the changkrtype and &#38;ange count (CC), as well as the identifier of 
the class of whose attribute C is the domain. Initially, CC is zero and is incremented by one each time 
the type of attribute in a class C is changed. The CC is also an system-defined attribute of the class 
C; that is, each instance of C carries a value for CC, although the value may not be up to date. When 
an instance of C is accessed, the CC of the instance is checked a ainst the CC in the operation log associated 
with the class: if 2 C(mstance) < CC(class), then the flags in the reverse corn site reference in the 
instance must be modified. The changes t r at must be made are the ones with a CC which is greater than 
the CC of the instance. Once the than es have been applied, the CC in the instance is set to the highest 
EC in the operation log. When a new instance of the class C is created, the CC of the instance is set 
to the current value of the CC of the class, since the changes issued before the creation of the instance 
need not be applied to this instance. Now we discuss the implementation of state-dependentchanges to 
attribute types. Operation D2 (changing a weak reference to a shared composite reference) is implemented 
as follows (operation Dl is similar). Again, we suppose that a class C has an attribute A whose domain 
is a class C. Access all instances of the class C and determine all instances of the class C which are 
referenced through A. For all instances of the class C determined above, verify that they have no exclusive 
references. If any instance has an exclusive reference to it, reject the change. Otherwise, add reverse 
composite references to the instances of C. Step 2 above may be very expensive, since there is no reverse 
reference corresponding to a weak reference. Operation D3 (than ing a shared composite reference to an 
exclusive composite re P erence) is implemented in a similar way. 1. Access all instances of the class 
C. 2. Reject the change if an instance 0 exists such that 0 has more than one reverse composite reference, 
and at least one of the reverse composite references is from an instance of the class C . Otherwise, 
turn on the X flag in all reverse composite references to instances of the class C .  5. Versions of 
Composite Objects The extended semantics of corn osite references also necessitate changes to the model 
o P versions of composite objects described in [KIM87b . In this section, we present the extended model 
of versions o Ecomposite objects. 5.1 Review of the ORION Version Model Let us begin with a brief review 
of the model of versions of ob ects implemented in ORION [CHOU86, CHOU88].ORION allows the user to optionally 
declare a class to be versionable, in which case an instance of the class is a versionable object. A 
versionable object is in essence a logical collection of version instances in which one version instance 
has been derived from another version instance. Any number of new version instances may be derived from 
any version instance in a version-derivation hierarchy, giving rise to a hierarchy of version instances 
called a version-derivation hierarchy. The history of derivation of version instances for a versionable 
object is maintained in a genetic irlstance. If an object 0 is a versionable object, an object 0 may 
be bound to (i.e., reference) 0 in one of two ways: statical1 or dynamically. 0 is said to be statically 
bound to 0, 1.r 0 references directly a specific version instance of 0. If 0 references the generic instance 
of 0,O is said to be dynamically bound to 0. If an object 0 is dynamically bound to another object 0, 
the system determines the default version instance of 0 and binds 0 to it. The user may specify the default 
version instance for any iven versionable object; in the absence of a user-specified de Bault, the system 
determines the system default on the basis of a timestamp ordering of the creation of the version instances. 
 5.2 Model of Versions of Composite Objects One difficulty in extending the model of versions of objects 
to a model of versions of composite objects is extending the semantics of a composite reference between 
a pair of instance objects to that between a pair of generic instances and between an instance obiect 
and a generic instance. lKIM87bl takes the view that the semantics ofla composite reference apply to 
a pair of neneric instances, and that thev transfer to one nair of version insyances of the respective 
gene&#38; instances. The following set of rules captures the semantics of versions of composite objects 
corres onding to the extended model of composite objects. ([KI&#38;7b] uses five rules, but we have consolidated 
them into four rules; the reader should recall that [KIM87b] restricts the composite objects to those 
defined through dependent exclusive composite references.) Let us consider a pair of classes C and D, 
and suppose C has a composite attribute A whose domain is D, and both C and D are versionable classes. 
Rule CV-1X: The existence of a composite reference from a generic instance g-cof the class C to a generic 
instance g-d of the class D means that any number of version instances of g-c may exclusive composite 
references to different version instances of have the same composite reference to g-d. the same versionable 
object 0. Rule CV-2X: A version instance may have at most one composite reference to it, if the reference 
is exclusive; or any number of composite references to it, if they are all shared references. A generic 
instance may have more than one exclusive composite reference to it, only if all references are from 
objects that belong to the same version-derivation hierarchy.However, it may have any number of shared 
composite references to it. Rule (Y-4X: When a generic instance g-c is deleted, all generic instances 
to which it has exclusive references are recursively deleted. Further, if a generic instance is deleted, 
all itsversion instances are deleted; and if the last remaining version instance of a generic instance 
is deleted, the generic instance is also deleted. Rules CV-2X and CV-4X together im 1 that the deletion 
of a version instance causes a recursive Bre etion of all version instances statically bound to it through 
dependent references. If the deleted version instance c-i is the only version of the object 0, its generic 
instance g-c is also deleted along with all generic instances which have composite dependent references 
from g-c. Class D legend: 0 0: version generic ver$on~ble instance instance    Figure 1. Deriving 
a new VerSiOn of a composite object 1 t a conse uence of Rule CV-2X, when a version instance c-i of 
the class d is copiedto derive a new version instan-ce crj, and c-i has an exclusive reference to a version 
instance d-k (rather than a generic instance g-d) of the class D, the new version instance will have 
the same exclusive reference that the initial version instance has (as shovvn in Figure la). The reference 
in the new copy is set to the generic instance g-d of the referenced version instance (as shown in Figure 
lb). However, if the reference is a dependent composite reference, it is set to Nil. Rules CV-IX and 
CV-2X together imply that different version instances of the same generic instance g-c may have composite 
references to different version instances of the generic instance g-d, as lon as each version instance 
of g-d is referenced through one exe usive composite reference or only i shared composite references. 
Figure 2 illustrates this. Rule ( Y-3X: The existence of a composite reference from a version instance 
c-i of a generic instance c-g to a version instance d-j of a generic instance d-g implies a composite 
reference from c-g to d-g. Rules CV-2X and CV3X together prevent version instances of different versionable 
objects, say, 0 and 0 , from having Class C I I I Class D legend: 0 on version generic verstltble instance 
instance Figure 2. Versioned composite objects 5.3 Implementation The major issue in implementing versions 
of composite objects is the storage of reverse composite references. Let us consider a composite reference 
from an object 0 to a versionable object 0. 1. If the reference is to a version instance v of 0, - a 
reverse composite reference to 0 is stored in the version instance v. - if 0 is not a versionable object, 
a reverse composite reference to 0 is also stored in the generic instance gof0. - if 0 is a versionable 
object, a reverse composite reference to the generic instance g of 0 is stored in the generic instance 
g of 0.  2 If the reference is to the generic instance g of 0, - if 0 is not a versionable object, a 
reverse composite reference to 0 is stored in the generic instance g of 0. - if 0 is a versionable 
object, a reverse composite reference to the generic instance g of 0 is stored in the generic instance 
g of 0  A reverse composite reference from g of 0 to g of 0 , which we will call a reverse composite 
genericrefemce, has associated with it a counter, called ref-count, which keeps track of the number of 
composite references from version instances of 0 to version instances of 0. The ref count is used to 
determine when a reverse composite generic raerence must be removed. The reason we replicate the reverse 
composite reference, in case 1 above, in a generic instance is as follows. Let us assume that there is 
an exclusive composite reference from an object 0 to a version instance v of 0, and that there is another 
composite reference from an object 0 to the generic instance g of 0. In order to check the legality of 
this latter type of reference, if the generic instance g does not have reverse composite references, 
the system must access all version instances of 0 to verify that either they have no exclusive references 
from other objects or, if there are such references, they are from version instances which belong to 
0 . Class A Class B Class A (W Class B I I legend: 0 00 version generic ve;l~;~ble instance instance 
Figure 3. Reverse composite references for versioned objects Figure 3 illustrates the storage of reverse 
composite references and reverse composite enenc references in version instances and generic instances 
o f versionable objects. For example, the ref-count associated with the reverse composite eneric reference 
from object bl to object al will have a value of kor 2 in Figure 3.a and 3.b, respectively. Let us suppose 
that in Figure 3.b the reference from al.vO to bl.vO is removed. This will cause the reverse composite 
reference from bl.vO to al.vU to be removed. However, the reverse corn site generic reference from bl 
to al p is not removed; only the re -count is decremented by one. Now if the composite reference from 
al.vl to bl.vl is removed, then the reverse composite reference from bl.vl to al.vl is removed. This 
time the reverse composite generic reference from bl to al is also removed, since decrementing ref count 
by one will set it to zero. We also note that if the operatioii parents of is a lied on the generic instance 
bl in Figure 3.b, the restiit wou R be the instance al, even if all composite references are statically 
bound. 6. Authorization The ORION authorization model is based on three fundamental concepts, discussed 
in detail in [RABI88]. The first is the concept of implicit authorization, that minimizes the amount 
of storage needed to represent all authorizations in a system by having the system to deduce authorizations 
from explicitly stored authorizations. The second concept is the positive and negative authorizations 
which differentiate between prohibition and absence of an authorization. The third is the notion of strong 
and weak authorizations. A weak authorization can be overridden by other authorizations, while a strong 
authorization and all authorizations implied by it cannot be overridden. As discussed in [RABI88], the 
combination of these concepts provides a basis for a powerful authorization mechanism. In relational 
database systems, the smallest unit of authorization is a relation or an attribute (column) of a relation. 
For object-oriented applications which deal with a relatively small number of large objects (such as 
documents, design files), it is often useful to be able to authorize access to single objects. Further, 
in systems which support composite objects, it is desirable to include composite objects as a unit of 
authorization, regardless ofwhether a composite object is a collection of a small number of large objects 
or a large number of small objects. If a composite object is aunit of authorization, the user (who created 
the composite object or who has the grant authorization on it) needs to grant authorization on the composite 
object as a single unit, rather than on each of the component objects. Further, when a composite object 
is accessed, the system needs to check only one authorization (for the entire composite object), rather 
than authorizations on all component objects. One novel contribution of KIM87b] is that it shows the 
use of composite objects as a unit o 1concurrency; others had proposed the use of corn osite ob ects 
as a unit of physical clustering and retrieval [LO!&#38;3, dRI85]. In this section, we further augment 
the utility of composite objects by introducing their use as a unit of authorization. To do this we extend 
the notion of implicit authorization to composite classes and composite objects. An authorization on 
a corn osite class C implies the same authorization on all instances o P C and on all objects which are 
components of the instances of C. For example, let us consider a composite class hierarchy consisting 
of the classes Vehicle, Autobody, and AutoDrivetrain. If a user is granted a Read authorization on the 
class Vehicle, the user implicitly receives the same authorization on all instances of Vehicle, and all 
instances of Autobo-dy and AutoDrivetrain which are components of the instances of Vehicle. We note, 
however, that the authorization on Vehicle does not imply the same authorization on all instances of 
Autobody and AutoDrivetrain, since not all instances of Autobody and AutoDrivetrain may be components 
of Vehicle. Further, because of negativeauthorizations, a new authorization issued on a component class 
may conflict with an authorization on the class which is implied by a previously granted authorization. 
In this case, the authonzation subsystem must reject the new authorization. Similarly, an authorization 
on a composite object implies the same authorization on each component of the composite object. For example, 
if a user is granted a Read authorization on the root of the composite object in Figure 4, the user implicitly 
receives a Read authorization on each of the component objects, Instance[k], Instance[m], Instance[nJ, 
and Again, if a new authorization issued conflicts with an existing authonzation, the new authorization 
is rejected. If an instance is a component of more than one composite object, a user can receive more 
than one implicit authorization on that instance. For example, let us consider the composite objects 
in Fi ure 5. If a user receives a Read authorization on the composite o lect rooted at Instance[j], then 
the user implicitly %. receives a Read authorization on Instance[o ]. If the user IS later ranted a Read 
authorization on the composite object rooted at f nstance[k], the user again receives an implicit authorization 
on Instance[o ]. 344 Instance [i] Instance [j] Instance [k] /\ Instance [m] Instance [n] \ Instance 
[o] Figure 4. Example composite object Negative authorizations give rise to conflicts among implicit 
authorizations on objects which are components of more than object. For example, if the user is granted 
a Instance [j] Instance [k] \/ Instance [o ] Instance [o] Instance [p] Instance [q] I Figure 5. Example 
of composite objects The matrix in Figure 6 summarizes conflicts in authorization implied by explicit 
authorizations on two composite objects rooted at Instance[j] and Instance&#38;] in Figure 5. The rows 
indicate all possible authorizations on the composite object rooted at Instance[j] and the columns authorizations 
on the composite object rooted at InstanceF]. The [i,j]-th element of the matrix contains the resulting 
authorizations on Instance 0 1; the symbol Conflict denotes that a conflict arises on the impTiat authorizations 
on Instance[o ]. We consider positive and negative (denoted by y), and strong(s) and weak (w) forms of 
two authorization types, Read (R) and Write(W). For example, s ,W stands for a strong negative Write 
authorization. We note that a (positive) W authorization implies a (positive) R authorization; and a 
negative R authorization implies a negative W authorization [RABISS]. If an object 0 is a component of 
n composite objects, and an authorization is granted on one of the composite objects, the authorization 
subsystem must ensure that the new authorization does not conflict with any of the authorizations on 
0 which are implied by the current authorizations on the composite objects. If there is no conflict, 
the resulting authorization on 0 is the Instance[k] ) I\ sR sWslR*W wR WW wlR wW sR sR SWCOnflict E; 
sR ww SR wlw S W S W S W Conflict :onflic S W S W SW SW Figure 6. Implicit authorization on a component 
object strongest of all the implied authorizations on 0. For example, if a user receives a strong R 
authorization from Instance[j] and a strong W authorization from Instance[k], the authorization implied 
on Instance 0 1 is a strong W authorization, which in turn implies a strong k authorization. Similarly, 
if a user receives a strong -IR authorization from InstanceDI and a strong ,W authorization from Instam+], 
the authorization implied on Instance[o ] is a strong -R authorization, which implies a strong VW authorization. 
When an authorization is granted on a composite object, the authorization component of a database system 
must ensure that there are no confhcts between the authorization being granted and authorizations (either 
explicit or implicit) already on any of the component objects. As an example, if a user receives a strong 
-R authorization from Instance[j], a later attempt to grant the user a strong W authorization on Instance[k] 
will fail. This is because a-R implies a-W, which contradicts the positive strong W being granted. 7. 
Locking [KIM87b, GARZ88] present a locking protocol which recognizes a composite object as a single lot 
able granule. The protocol is applicable to composite objects consisting of exclusive composite references 
(i.e., physical part hierarchies). The protocol introduces three non-conventional lock modes: ISO, 1X0, 
SIXO, corresponding to the well-known lock modes IS, IX, and SIX[GRAY78], repectively. These locks are 
introduced to prevent a transaction from updating/reading a component object of a composite object 0 
while another transaction is reading/updating the entire composite object 0. The compatibility semantics 
of these locks are described in Figure 7. As shown in the compatibility matrix, the main point is that, 
while IS and IX modes do not conflict, the IS0 mode conflicts with IX mode, and IX0 and SIX0 modes conflict 
with both IS and IX modes. To lock an entire corn osite object using this protocol, the root object is 
locked in S or 2i mode, and the root class is locked in IS, IX, S, SIX, or X mode. Further, the corn 
onent classes of the composite class hierarchy are locked in IS 8 ,1X0, S, SIXO, or X - requested mode 
IX s SIX x IS0 IX0 SIXC - IS d A// No d No No IX d No No No No No No S No d No No t/ No No SIX No No 
No No No No No X No No No No No No No No IS0 t/ No d No No d dd IX0 No No No No No A/ t/ No SIXC No 
No No No No ,/ No No Figure 7.Compatibility matrix for granularity locking and exclusive composite object 
locking mode, respectively. The following examples illustrate the protocol. 1.Access the vehicle composite 
object Vi lock vehicle class object in IS mode k lock the vehicle composite instance Vi in S mode c. 
lock the component class objects in IS0 mode. 2. Update the vehicle Vi or its corn onents a. lock vehicle 
class object in Er mode b. lock the vehicle composite instance Vi in X mode c. lock the component class 
objects in IX0 mode.  This protocol allows multiple users to read and update different composite objects 
that share the same composite class hierarchy, as long as they update different composite objects. This 
protocol is only applicable to composite objects consisting of exclusive composite references; as such, 
it must be extended for the shared composite references. Information needs to be maintained about the 
component classes of a composite class hierarchy, and the nature of the references to the component classes. 
A component class of exclusive references is locked as before. However, three new lock modes are introduced 
for the component class of shared references: ISOS (intention shared object-shared), 1x0s (intentionexclusive 
object-shared), and SIXOS (shared intention exclusive object-shared), which correspond to the ISO, 1X0, 
and SIX0 for component classes with exclusive references. Figure 8 shows the compatibility matrix for 
the expanded set of lock modes. Let us consider the ite objects in Figure 9, where revised locking protocol. 
1. Update the composite object rooted at Instance[i] Lock class I in IX mode. k Lock composite ob ect 
Instance[i] in X mode. C. Lock class C in IX b mode. 2. Access the corn osite object rooted at InstanceF] 
a. Lock class R in IS mode. b. Lock composite ob ect Instance[k] in S mode. Lock class C in IS d S mode. 
Lock class W in IS0 mode.  cu ent ---..-- *--I -_A- amo e - - ISO! IX0 - - IS No No d No No IX No No 
No No No S No No No No A/ No No No No NoSIX X No No No No No IS0 d/ d t/ xl IX0 No t/ No xl d SIXC No 
No No No d ISOS No No t/d d 1x0s d No No No No 1x0s No No No No No Figure 8.Compatibility matrix for 
granularity locking and shared/exclusive composite object locking 3. Update the corn osite object rooted 
at Instance[j] a. Lockclass g.m IXmode. b. Lock composite ob ect InstancehI in X mode. c. Lock class 
C in IX d S mode. d. Lock class W in IX0 mode.  Instance [i] , l/any InJny I Instance [c] Instance 
[w] Instance [c ] lnstatice [w ] 1 I Figure 9. Example composite objects This protocol allows us to have 
several readers and writers on a component class of exclusive references, and several readers and one 
writer on a component class of shared references. Therefore, examples 1 and 2 are compatible, while example 
3 is incompatlble with both 1 and 2. This protocol, as is the case with the protocol of [KIM87b], also 
suffers from the restriction that if there is even one reader (writer) via the composite class hierarchy, 
there cannot be any direct readers or writers via the instances of component classes, or vice versa. 
[GARZA88] also describes a locking algorithm which makes use the object identifier of the root of a composite 
object. The algorithm sets a lock on the root of a composite object when a component object is directly 
accessed. The algorithm cannot be used for shared composite references. As an example, let us consider 
the composite objects in Figure 5. Suppose that a transaction Tl requests an S lock on Instance[o ]. 
The algorithm will set locks on the roots of Instance[o ], namely, Instance[j] and InstancepI. This will 
cause all components of the composite objects rooted at Instance[j] and InstanceF] to be implicitly locked. 
Suppose now that another transaction T2 re uests an X lock on Instance[o]. The algorithm will grant T2 
the sr lock, and implicitly locks Instance[q in X mode, which of course conflicts with the implicit S 
lock w I,ich Tl holds on the instance. Both the original Drotocol of IKIM87bl and the extended protocol 
just pr&#38;entid are approcriate lar&#38;ly for conventional short transactions. Unfortunatelv, thev 
mav not be suitable for long-duration transactions. For*iongldur&#38;ion transactions, it may be better 
to lock individual component objects as needed. An appropriate locking protocol for long-duration transactions 
is still a research issue. 8. Summary In this paper, first we presented a new model of corn objects by 
cleanly separating out a number of dl.Perent semantics which the model of composite objects develo in 
KIM87b] overloaded on the reference between a pair of o g d jects.k he new model distinguishes four of 
composite reference, that is, a reference on which the typ S-PART-OF relationshipbetween a pair of objects 
is superimposed. The include independent exclusive, dependent J exclusive, m ependent shared, and dependent 
shared composite references. Next, .we explored the consequences of the new model of composite ObJects 
on the semantics of schema evolution, versioning, authorization, and concurrency control on composite 
objects. [KIM87b] first described the use of composite objects as a unit of concurrency control, augmenting 
the use of composite objects as a unit of physical clustering and retrieval roposed in the literature. 
In this paper, we further enhance B the utility of composite objects by showing their use as a unit of 
authorization. The model of composite objects presented in [KIM87b] has largely been implemented in the 
ORION object-orienteddatabase system at MCC. We are currently re-implementing the composite object feature 
in ORION to reflect the new model we have developed. REFERENCES [ANDR871 Andrews, T., and C. Harris 
Combined Language and Database Advances in an Obiect-Oriented Development Environment., in Pnx. 2ndZntl. 
Co@ on Object-Oriented Pmgrammmg Systems, Languages, and Applications, Orlando, Florida, Oct. 1987. [BANE87a] 
Bane ee, J., H. T Chou, J. E Garza, W. Kim, D. Woelk, N. % allou, H. J. Kim Data Model Issues for Object-Oriented 
Ap lications, ACM Trans. on Office Information Systems, e 01.5, N. 1, 1987. [BANE87b] Banerjee, J., W. 
Kim, H. J. Kim, H. E Ksrfh Semantics and Implementation of Schema Evolutz in Object-Oriented Databases, 
in . ACM-SZGMOD Zntl. Co&#38; on Management of Data, San Francisco, Calif., May 1987. [CHOU86] Chou, 
H. T, and W. Kim A Unifying Framework for Versions in CAD Environment, in Proc. Zntl. Conf on Very Large 
Data Bases, Kyoto, August 1986. [CHOUSS] Chou, H. T, and W. Kim, Versiohs and Change Notification in 
an Obiect-Oriented Database Svstem. in Ptvc. Design Automaation Conference, June 19h8. [COPE841 Copeland, 
G., and D. Maier Makin Smalltalk a Database Systems, in Ptvc. ACM SZGM 8 D Zntl. Conf: on Management 
of Data, Boston, Mass., June 1984. [FISH8 Fishman, D., et al. IRIS: an Object-Oriented a atabase Management 
System, ACM Tmns. on Office Information Systems, Vo1.5, N.l, 1987. [GARZ88] Garza, J. E, and W. Kim Transaction 
Management in an Object-Oriented Database System, in Pnx. ACM-SZGMOD Zntl. Conf on Management of Data, 
Chicago, May 1988. [GRAY78 Gray, J.N. Notes on Data Base Operating Systems, IB t Research Renort: RJ2188. 
IBM Research. San Jose, Calif. 1978. * [HAMM81] Hammer, M., and D. McLeod Database Description with SDM: 
A Semantic Data Model, ACM Trans. on Databare Systems, Vo1.6, N.3, 1981. [KIM87a] Kim, W., H. T Chou, 
and J. Banerjee Operations and Implementation of Complex Objects, in PIVC. Data Engineering Conference, 
Los Angeles, Calif., Feb. 1987. [KIM87b Kim, W., J. Banerjee, H.T Chou, J. I? Garza, D. Woelk E omnosite 
Obiect SUDDOI? in an Obiect-Oriented Database Syste-ms, i; Pmt. 2nd Znk Conf on Object-Oriented Ptvgmmming 
Systems, Languages, and Applications, Orlando, Florida, Oct. 1987. [LORI83 Lorie, R., and W. Plouffe 
Complex Ob ects and T beir Use in Design Transactions, in Pmt. Ll atabares for Engineering Applications, 
Database Week 1983 (ACM), San Jose, Calif., May 1983. [LORI85] Lorie, R., W. Kim, D.McNabb, W.Plouffe, 
A.Meier Supporting Complex Objects in a Relational System for Engineering Databases 1985. [RABI88] Rabitti, 
I?, D. Woelk, W. Kim A Model of Authorization for Object-Oriented and Semantic Databases, in PIVC. Zntl. 
Conf: on Extending Database Technology, Venice, Italy, March 1988. [STEF86] Stefik, M., and D. G. Bobrow 
Object-Oriented Programming: Themes and Variations, 7 he AZ Magazine, January 1986, pp.40-62. [STON86 
Stonebraker, M., and L.Rowe, The Design of Pd STGRES, in Pmt. ACM SZGMOD Zntl. Conf on Management of 
Data, Washington DC., May 1986. 
			
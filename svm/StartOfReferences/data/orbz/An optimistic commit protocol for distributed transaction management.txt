
 An Optimistic Commit Protocol for Distributed Transaction Management* Eliezer Levy Henry F. I<orth Abraham 
Silberschat z Department of Computer Sciences University of Texas at Austin Austin, TX 78712 USA Abstract. 
A major disadvantage of the two-phase commit (2 PC) protocol is the potential unbounded delay that trans­actions 
may have to endure if certain failures occur. By using compensating transactions, we obtain a revised 
2PC protocol that overcomes these difficulties. In the revised protocol, locks are released as soou as 
a site votes to com­mit a transaction, thereby solving the indefinite blocking problem of 2PC. If finally 
the transaction is to be aborted, then its effects are undone semantically using a compen­sating transaction. 
Therefore, Semantic, rather than stan­dard, atomicity is guaranteed. Relaxing standard atomicity interacts 
in a subtle way with correctness and concurrency control issues. Accordingly, a correctness criterion 
is pro­posed that is most appropriate when atomicity is given up for semantic atomicity. The correctness 
criterion reduces to serializability when no global transactions are aborted, and excludes unacceptable 
executions when global transactions do fail. We devise a family of practical protocols that en­ sure 
this correctness notion. These protocols restrict only global transactions, and do not incur extra messages 
other than the standard 2PC messages. 1 Introduction The most common protocol for ensuring atomicity 
of multi-site transactions in a distributed environment is the two-phase commit (2 PC) protocol [Gra78]. 
Typ­ically, the 2PC protocol is combined with the strict two-phase locking protocol [B HG87], as the 
means for ensuring the atomicity and the serializability of trans­actions in a distributed database (e.g., 
[ML086]). The implications of this combination on the length of time a transaction may be holding locks 
on various data items *This research was partially sponsored by NSF Grants IRI­8805215 and IRI-9003341, 
and grants from Unisys Roseville Op­erations and the IBM Corporation. Permission to copy without fee 
sII or part of this material is granted provided that the copies are not made or distributed for direct 
commercial advantage, the ACM copyright notice and the title of the publication and its date appear, 
and notice is given that copying is by permission of the Association for Computing Machinery. To copy 
otherwise, or to republish, requires a fee and/or specific permission. 01991 ACM 0-89791 -425 -2/91 /0005 
/0088 . ..$1 .50 might be severe. At each site, and for each transaction (at least all exclusive) locks 
must be held until either a commit or an abort message is received from the co­ordinator of the 2PC protocol. 
Since the 2PC protocol is a blocking protocol [Ske82], the length of time these locks are held can be 
unbounded. Moreover, even if no failures occur, since the protocol involves three rounds of messages 
(request for vote, vote and decision) the delay can be intolerable. The impact of indefinite blocking 
and long-duration delays is exacerbated in multidatabase systems a specific type of distributed database 
system where several heterogeneous and autonomous database man­agement systems (DBMSS) are integrated 
to enable the processing of multi-site, or global, transactions [hdb90]. Global transactions are processed 
by decom­posing them into local subtransactions that are exe­cuted at the different sites. The integrated 
DBMSS may belong to distinct, and possibly competing business or­ganizations (e. g., competing computerized 
reservation agencies). Therefore, the preservation of local auton­ omy of the individual DBMSS is crucial. 
It is undesir­able, for example, to use a protocol where a site belong­ing to a competing organization 
can harmfully or mis­takenly block the local resources; a phenomenon that can occur under the 2PC protocol. 
Additionally, one of the flavors of local autonomy is defined as the capabil­ity of a site to abort any 
local (sub) transaction at any time before the (sub) transaction terminates [BST90]. Employing the 2PC 
protocol, a site enters a prepared state if it votes to commit a transaction Ti. Once in this state, 
a site becomes a subordinate of the external coordinator, and it can no longer unilaterally determine 
the fate of the local subtransaction of Ti. It is impossible to have a non-blocking commit pro­tocol 
that is immune to both site and link failures [BHG87]. In this paper, we introduce an alternative to 
the standard 2PC protocol that alleviates the virtually inevitable blocking and lengthy delays problems 
yet preserves autonomy. The key concept behind this pro­tocol is the use of compensating transactions 
[KLS90a]. The new protocol is applicable whenever the problem of atomicity of a multi-site transaction 
surfaces. It can benefit distributed database systems in general and multidatabase systems in particular. 
The protocol guarantees semantic atomicity [GM83] rather than the standard all-or-nothing atomicity. 
A salient contribution of this paper is the examination of the consequences of the protocol and this 
relaxed atom­icity notion in terms of serializability, and correctness in general. The importance of 
our study of correct­ness issues is underlined by the growing popularity of advanced transaction models 
that are based on seman­tic atomicity [GM83, GMS87, AGMS87, KR88, Reu89, Vei89, GMGK+90], and by the 
lack of specific correct­ness criteria in this domain. The remainder of the paper is organized as follows. 
Section 2 provides an operational overview of the ba­sic protocol. Several techniques and assumptions 
that we use are clarified in Section 3. In Section 4, we dis­cuss the need for a new correctness criterion. 
Section 5 presents the correctness criterion and a sufficient con­dition for ensuring it. In Section 
6, based on this con­dition, another component of the protocol is presented, whose task is to ensure 
the correctness criterion.  2 The 02PC Protocol In the standard 2PC protocol, a multi-site transaction 
is associated with a coordinator that initiates the pro­tocol by sending a VOTE-REQ message (also referred 
to as PREPARE message) to all participating sites. Upon receipt of this message, a participating site 
votes (by sending a VOTE message back to the coordina­tor) either to commit the particular transaction 
or to abort it. Based on these votes, the coordinator decides whether to commit or abort the transaction. 
Only if all the votes are to commit then the transaction is to be committed. Following this, the coordinator 
transmits its DECISION message to the participating sites. As was mentioned earlier, global serializability 
is ob­tained by combining the 2PC protocol with a 2PL disci­pline. This combined protocol is referred 
to in [BHG87] as distributed 2PL and it works as follows. It is assumed that the coordinator of T; initiates 
the 2PC protocol only after it has received acknowledgements for all of Ti s operations. Therefore, when 
the coordinator initi­ates the 2PC protocol by sending the VOTE-REQ mes­sages, Ti has surely obtained 
all the locks it will ever need. Locks are released only after the VOTE-REQ message has been received. 
Consequently, it is guaran­teed that a transaction releases a lock at any site only after it has finished 
acquiring locks at all sites. Since a two-phased locking discipline is enforced, the dis­tributed 2PL 
protocol guarantees serializability glob­ally. For the well known reasons of avoiding cascading aborts, 
and use of state-based recovery, the exclusive (i.e., write) locks are released only after the decision 
message is received locally. Thus, a strict version of 2PL is used. It is possible to release the shared 
(i.e., read) locks as soon as the VOTE-REQ message is re­ceived. Holding the locks until a DECISION message 
is re­ceived, which is the cause of blocking, is necessary only if the transaction at hand has to be 
aborted. Our re­vised protocol is based on the optimistic assumption that in most cases the protocol 
terminates successfully (i.e., the transaction commits) and therefore the locks can be released earlier. 
This can dramatically reduce waiting due to data contention, thereby improving the performance of the 
system. Such an assumption is valid in most practical distributed environments. Further­more, since the 
commit protocol is initiated only when the transaction at hand has already obtained all its locks and 
completed all its operations, its failure is very unlikely. The validity of the optimistic assumption 
is orthogonal to the protocol correctness. However, if the assumption is unfounded, the overhead incurred 
by the protocol is likely to outweight its benefits. The optimistic 2PC (02PC) protocol is a slightly 
modified version of the distributed 2PL protocol. The same message exchange is carried out as in the 
standard protocol. If a site votes to abort Ti, then as in the standard protocol, an abort vote is sent 
back to the coordinator, and the locks held by the transaction are released as soon as the transaction 
is locally undone (rolled-back). However, if a site votes to commit ~, all Iocks held by Ti are released 
at once, without waiting for the coordinator s final commit or abort message. In this case, we say that 
Ti is locally-committed at that particular site. Observe that a global 2PL discipline is preserved, even 
under the early lock release provision of the 02PC protocol. The uncoordinated local commitment resulting 
in the early release of locks is the crux of the protocol. On the one hand, the early release of locks 
solves the problems of blocking and the local commitment keeps the sites autonomous. On the other hand, 
the uncoor­dinated commitment of updates may violate the stan­dard all-or-nothing atomicity guarantee 
of a transac­tion, if at least one of the sites votes to abort it. A situation may arise where, at some 
sites T~ is locally committed, whereas at some other sites T~ is aborted. In this case, the effects of 
Ti must be undone at sites where it is locally-committed. Undoing the effects of a locally-committed 
Ti is problematic, if not impossible, using standard recovery techniques. The key to an adequate solution 
is the notion of com­pensating transactions. Compensating transactions are intended to handle situations 
where it is required to undo a transaction whose updates have been read by other transactions, without 
resorting to cascading aborts. The concept of compensation is formally de­fined in [KLS90a] and the essential 
details are reviewed in Section 3.2. We propose to use compensating transactions, in conjunction with 
the 02PC protocol, as the means for ensuring transaction atomicity despite of the uncoordi­nated commitment 
of updates at different sites. After voting to commit Ti, a site still carries on with the sec­ond phase 
of the regular 2PC protocol (despite having released the locks held by Ti). If the site receives a de­cision 
message from the coordinator to abort Ti, then it invokes the corresponding compensating transaction. 
Since it is quite likely that the decision would be to commit Ti, the gain by the early release of locks 
should outweigh the overhead associated with those cases re­quiring compensation for Ti. Instead of the 
familiar all-or-nothing semantics, the protocol ensures a similar, though weaker, atomicity guarantee 
referred to as semantic atomicity. Seman­tic atomicity states that when a multi-site transaction is decomposed 
into a set of single-site subtransactions, either all subtransactions are locally-committed (and then 
the entire transaction is committed), or all locally­committed subtransactions are compensated-for and 
all other subtransactions are rolled-back in the stan­dard manner. We note that not all transactions 
are compensatable. Transactions involving real actions [Gra81] (e.g., firing a missile or dispensing 
cash) may not be compensat­able. The adjustment for transactions involving non­compensatable actions 
is simply to retain the locks and delay real actions until a commit message is received (as in distributed 
2PL) in all sites performing these actions. All other sites running subtransactions on be­ half the multi-site 
transaction can still benefit from the early lock release.  3 Transaction Structure In order to proceed 
we must first introduce some assumptions and terminology concerning transaction structure that are used 
in our exposition. 3.1 Transaction Management We distinguish between local and global transactions. 
A local transaction accesses data at a single site, whereas a global transaction accesses data located 
at two or more sites. A global transaction Ti that requires ac­cess to data located at sites S1, S 2, 
. . . . sk is submitted for execution as a collection of local subtransactions Til, Ti2j ..., Tik, where 
~j is executed at site Sj. We make a distinction between a local subtransaction that is executed on behalf 
of a global transaction, and an independent local transaction, Local transactions (i. e., non-subtransactions) 
follow the strict 2PL protocol. This abstraction of global transactions as a set of lo­cal subtransactions 
is most appropriate for understand­ing our protocol and its formal properties. However, several comments 
concerning some practical issues are in order. The decomposition of a global transaction into lo­cal 
subtransactions conforms to one of two models. In the first model, all the requests of a global transaction 
to a particular site constitute the local subtransaction at that site. Each subtransaction can be viewed 
as an arbitrary collection of reads and writes against the local data. That is, no predefine semantics 
is associ­ated with a subtransaction. This model is elaborated in [CP87] and is the standard model in 
distributed databases. Henceforth, this model is referred to as the generic model. The generic model 
is also considered as the general framework in the multidatabases context [BS88, BST90]. An alternative 
model is one in which each global transaction is decomposed into a possibly structured collection of 
local subtransactions, each of which per­forms a semantically coherent task. The subtransac­tions are 
selected from a well-defined repertoire of op­erations (i.e., subtransactions) forming an interface at 
each site in the distributed system. This model is re­ferred to as the restricted model, hereafter, and 
is suit­able for a federated distributed database environments [fdb87]. The distinction between the two 
models be­comes relevant once compensating transactions are in­troduced. Our work applies to both models; 
however, fitting the ideas in each framework is bound to be dif­ferent, and probably easier in the restricted 
model as we explain later,  3.2 Compensating Transactions The compensating transaction that is specific 
to the forward transaction Ti is denoted by CTi. CTi undoes T~ s effects semantically without causing 
the cascading aborts of transactions that have read data updated by Ti. The intention is to leave the 
effects of transac­tions that read from Ti intact, yet preserve database consistency. Therefore, compensation 
for Tj does not guarantee the physical undoing of all the direct and indirect effects of Ti. The state 
of the database af­ter compensation took place may not be identical to the state that would have been 
reached, had Ti never taken place. Compensation does guarantee, however, that a consistent state is established 
based on seman­tic information. In [KLS90a] we formally characterize the outcome of compensation based 
on the properties of Ti and on properties of transactions that have read from Ti. By the nature of compensation, 
CTi is always serialized to come after the corresponding Ti (though not necessarily immediately after). 
 It is guaranteed that once compensation is initiated, it completes successfully. This stringent requirement 
is referred to as persistence of compensation and is rec­ognized in [GMS87, GM83, Vei89, GMGK+90, Reu89, 
KLS90a]. The rationale behind the persistence of com­pensation requirement is the need to preserve (seman­tic) 
atomicity. Initiating a compensating transaction parallels a decision to abort the transaction in the 
tra­ditional setting definitely a non-reversible decision. Observe that persistence of compensation 
implies that there is no need to use a commit protocol to ensure the atomicity of a compe nsa tion transaction 
in a dis­ tributed environment. In the context of the 02PC protocol, compensa­tion is employed as follows. 
If Ti is a global trans­action, CTi is also a global transaction that consists of C~1JCTj29 ...9 CT~k 
of ~oca~ compensating subtransac­tions, one for each site where Ti was executed. Each compensating subtransaction 
is submitted for execu­tion at a site just like any other local transaction, and hence it is subject 
to the local concurrency control. Consider a global transaction Ti that is locally­committed at some 
sites, whereas other sites have voted to abort it. At a site Sj where Ti is locally-committed, CTij is 
a special compensation action, since Ti s up­dates have been exposed. At a site sk which voted to abort 
Ti, the local subtransaction Tik is automatically rolled-back using standard recovery techniques (e. 
g., undo from log). We model undoing a transaction us­ing the standard roll-back recovery, as a special 
case of a compensating transaction where there are no trans­actions that have read from the undone transaction 
[KLS90a]. Thus, a global CT is a blend of standard roll-backs at sites having voted to abort Ti, and 
actual compensating subtransactions at sites having voted to commit Ti. It should be recognized that 
in a system conforming to the restricted model it is easier to apply compen­sation techniques than in 
the generic model. In the restricted model, since each subtransaction performs a semantically coherent 
task, supplying a counter-task can be done in advance and should not be that hard (e.g., a DELETE as 
compensation for an INSERT sub­transaction). With respect to locking, compensating subtransac­tions are 
treated as local transactions rather than as subtransactions of global transactions. That is, they also 
follow strict 2PL locally. The reasons for this important decision are elaborated in the next section. 
The key point to note is that at each site, the local execution over local transactions, subtransactions, 
and compensating subtransactions is guaranteed to be se­rializable.  4 Correctness Issues The local 
uncoordinated commitment and the use of compensating transactions in the 02PC protocol pose some interesting 
questions regarding concurrency con­trol and correctness issues. In contrast to the tradi­tional serializability 
theory which deals only with com­mitted projections of histories [B HG87], the theoretic and modeling 
tools (e.g., serialization graphs) used here, must account for failed transactions and their corresponding 
compensating transactions. One might be tempted to impose serializability over all trans­actions, including 
compensated-for and compensating transactions, as the correctness criterion. Compensat­ing transactions, 
however, possess several special prop­erties that render this extended serializability notion both unattainable 
and inappropriate: Persistence of compensation means that a com­pensating transaction has a simplified 
atomicity notion it can only commit. Consequently, there is no need to use a commit protocol for compen­sating 
transactions in a distributed environment. Avoiding the use of 2PC to terminate global com­pensating 
transactions is critical, since there is no chance to couple locking decisions with the commit protocol 
messages, as it is done in the distributed 2PL and 02PC protocols.  A second problem regarding the scheduling 
of com­pensating transactions stems from the fact that in a site sk that votes to abort a transaction 
Ti, the standard roll-back of Tik is considered as a com­pensating subtransaction; that is, as CTik. 
Such roll-backs are automatic and uncoordinated with the initiation and termination of other compensat­ing 
subtransactions of the same transaction. This is especially true in a multidatabase environment, where 
the preservation of local autonomy dictates that no constraint can be placed on the automatic local roll-back. 
Therefore, serializability of histo­ries with compensating transaction may be again  jeopardized since 
the global scheduling of compen­sating transactions is not regulated and coordi­nated. For example, rolling-back 
a subtransaction Tij as part of CTi and releasing locks once the roll­ back is complete, violates the 
2PL rule for CTi as a whole. We observe that at least in the restricted model the executions of the 
compensating subtransac­tions are semantically independent. That is, there should be no value dependencies 
[DI189] among the different subtransactions. A compensating trans­action in the restricted model can 
be viewed as a set of semantically unrelated subtransactions. This argument and the previous points give 
the impression that the execution of a compensating subtransactions is somewhat independent from the 
execution of its sibling compensating subtransac­tions. This observation is underlined once it is realized 
that compensation, as a recovery activ­ity, is an afier the fact activity. That is, the for­ward transaction 
has executed, and compensation is carried out based on its effects. In support of our observation, we 
cite [Vei89, map89] where a large-scale, commercial application that is predi­cated on this independence 
of compensating sub­transactions, is described. The reasons given above suggest that compensating subtransactions 
should release their locks once they complete their local processing, regardless of the ex­ecution of 
their sibling compensating subtransactions. As a result, serializability maybe lost. That is, a global 
serialization graph may contain cycles with compensat­ing transactions. The independence of the subtransac­tions 
of a compensating transaction implies that it need not see a globally consistent state as a global transac­tion. 
Therefore, cycles whose only global transactions are compensating transactions do not introduce incon­sistencies 
in the database, and should be thus allowed. Another important consideration in designing an al­ternative 
correctness criterion is the following require­ment. A transaction either reads a database state af­fected 
by Ti (and not by CTi), or it reads a state re­flecting the compensatory actions of CTi. However, a transaction 
should never read both uncompensated-for updates of Ti as well as data items already updated by CT~. 
This important constraint is referred to as atom­z city of compensation in [KLS90a] and is elaborated 
in [Lev90]. Our intention is to propose a revised correctness cri­terion that takes into account the 
special properties of compensating transactions and guarantees atomicity of compensation. In the next 
section, we formally present our correctness criterion. Before we proceed, we note that the of loss 
of serial­izability would not be worrisome if sagas [G MS87], or their generalization multi-transactions 
[GMGK+90, KR88, Reu89] are used. Then the 02PC scheme can be employed as it was presented so far, without 
any further adjustments. The rest of the paper, however, addresses the problems of loss of serializability 
and cor­rectness. Theoretical Results Our correctness criterion is stated in terms of serializa­tion 
graphs (SGS) that are a slightly extended version of the standard SGS [B HG87]. For brevity, we omit 
the underlying concept of complete histories that is identi­cal to the definition given in [BHG87]. Let 
T be a set of global transactions {Tl, T2, . . . . Tn}, and let CT be the set of the corresponding compensat­ing 
transactions {CT1, CT2, . . . . CTn}. Also, let L be a set of local transactions {Ll, L2, . . . . Lm}. 
The local serialization graph for a complete local history H over T, CT and .C is a directed graph SG(H)=(V, 
E). The set of nodes V consists of transactions in T U CT and the committed transactions in Z. The set 
of edges E consists of all Ai -+ Bj, Ai, Bj e 7U L7 u L, such that one of Ai s operations precedes and 
conflicts with one of Bj s operations in H. A global SG is an SG that corresponds to a history at more 
than one site. The SG of site a is denoted SGa. Given a set of local SGS, each represented as SG. = 
(Va, E.), the corresponding global SG is defined as SGfM./ = (U V., U E.). Intuitively, a history H is 
correct if the global SG(H) is acyclic, except for cycles that consist of at least one compensating transaction 
and (potentially) local trans­actions. The main result of this section is the derivation of a sufficient 
condition for obtaining the correctness crite­rion and atomicity of compensation. The strategy in obtaining 
the main result is summarized as follows: We identify the types of cycles that are not allowed in global 
SGS, namely regular cycles, and state the correctness criterion formally (Lemma 1). We show that if a 
regular cycle exists in the global SG then certain conditions, called the cycle condi­tions, are implied 
(Lemma 2). We introduce properties of SGS, called stratifica­tion properties whose negation is implied 
by the cycle conditions (Lemma 3). We conclude in Theorem 1 that by ensuring the stratification properties, 
regular cycles are avoided. Theorem 2 identifies the type of compensating transactions for which atomicity 
of compensation is guaranteed by preventing regular cycles, To present our results, we must first establish 
some notation. We use capital letters at the beginning of the alphabet (e. g., A, B, C) to denote either 
compensating or regular global transactions. Also, for a particular history H, the notation A _ B is 
used to denote that there is a directed path (of arbitrary length) between the two transaction nodes 
in SG(H). We define local and global paths to be paths (entirely) within a local SG and global SG, respectively. 
When specifying a local path, the local SG it belongs to, is also specified. (a) (b) (c) (d) T1 T1 T3~T3: 
T1 ! f <22; ?1 ? ? T V:vv T2 + 9 CT1 v : CF1 T3 : T3 ,V, : CT1 v T2 t:!v T1 : CT1 CT1 T2 CT1 ~ T2 CT1 
T2 CT3 : CT3 T2 :V: S(I1 S(I2 S(21 SG2 SGl : SG2: SG3 Crrl SG1 SG2 SG3 cm .~:) +7) L T2 /c ~> T3 T2 
Figure 1: Regular Cycles When considering global paths it is useful to segment such paths into local 
paths, and represent each such local path by its end points. For example, consider the paths A --+B in 
SGI, and B + C --+D in SGZ. The global path A + D is represented by the local paths A+ Bin SGland B+ 
Din SG2. Thus, a representation for a given global path lists the local paths constituting the global 
path in order. This representation is not necessarily unique. A mini­mal representation for a given global 
path is the path representation with the minimal number of local seg­ments (paths). Again, this representation 
is not neces­sarily unique. Accordingly, when we say that a global path includes A, we mean that A appears 
on one of the minimal representations of this path. Example 1. Consider the following local paths: CTI 
--+ Tz in SGI CTI + T2 --+ CT3 in SG2 CT3 + CTI in SG3 Consider the global path CTI --+ CT3. It has two 
rep­resentations: 1. CTl --+ T2 in SG1; T2 + CT3 in SG2 2. CTI --+ CT3 in SG2 The latter being the minimal 
representation, The global path CT1 + CT3 does not inclucle T2. o  A regular cycle is a global cyclic 
path in a global SG that includes at least one regular global transaction. Observe that there are no 
regular cycles in Example 1. Figure 1 demonstrates several regular cycles, by presenting the corresponding 
segments of the local SGS. Lemma 1. Any regular cycle includes at least one compensating transaction. 
0 Our correctness criterion states that a htstory H is correct i~ and only iJ SG(H) contatns no regular 
cy­cles and no local cycles. Since we assume that local histories are serializable, and hence there are 
no local cycles, we focus on preventing regular cycles to ensure correctness. Lemma 2. If ihere exists 
a regular cycle in a global SG, then the following cycle conditions hold: Cl. There exist distinct global 
transactions Ti and TJ such that CTi + Tj at some SGU, and at some other SGb where Tj appears, either 
TJ -+ CTi, or there is no local path between Ti and Tj in SGb. C2. There exist distinct global iransacttons 
T, and T] such that Tj + CTi at some SGa, without having Ti on that ~ath, and at some other SGb where 
Tj appears, either CTi + Tj, or there is no local path between Ti and Tj in SGb. 0 For the purpose of 
avoiding regular cycles we need to identify the pairs of transactions that can cause the formation of 
such cycles. Intuitivelyj regular cycies may be formed when T2 follows another T1 in the SG before the 
latter transaction is globally committed or fully compensated-for. (Consider Figure 1(a) for example). 
Such pairs of transactions are identified as follows: We say that Ti is actzue with respect to Tj if, 
and only if, there exist an SGa where both transactions appear and TJ + Ti is not in SGG, but there is 
a path (in either direction) in SGa between CTi and Tj. Next, we introduce two properties of global SGS 
that are used to stratify the global SG, thereby preventing regular cycles. Each property is present,ecl 
as a formal assertion. We first introduce four predicates that cle­pend on the transaction identifiers 
i and j: Al. At any f7Ga where T3 appears, Ti --+ CT, -+ TJ. A2. At any SGa where Tj appears, TJ ---CTi 
without having Ti on that path. A3. At any SGa where both TJ and T, appear, if there is a path between 
Tj and either Tt or CTi, then the path Ti --+ CTi _ TJ is in SG.. 6.1 Marking Sites The basic building 
block for implementing protocols that are based on the stratification properties is a sim­ ple marking 
of sites. With respect to a specific global  ote:combort Decision: Abort Figure 2: Transitions in the 
marking of a site with respect to a transaction A4. At any SGa where both Tj and T~ appear, if there 
is a path between Tj and CT~ in SG~, it must be the path Tj -+ CTi without having Ti on that path. Using 
these predicates we introduce two stratification properties: S1. (VTi, Tj : T; is active wrt Tj : Al 
V A4) S2. ( d Ti, Tj : Ti is active wrt Tj : A2 V A3) 1 Lemma 3. Cl + -S1, and C 2 + -&#38;2. Theorem 
1. If either one of the stratification properties S1 or S2 hold then there are no regular cycles in the 
global SG. 0 Since we assume local serializability, Theorem 1 gives a sufficient condition for ensuring 
correctness. Theorem 2. If a history H is correct, and if CTi writes at least all data items written 
by Ti, then there is no case where a transaction Tj reads from both Ti and CTi in H (i. e., atomicity 
of compensation is preserved). 0 In [Lev90], we elaborate on other variants of atom­icity of compensation 
and ways to ensure them. Ensuring Correctness In this section, we present two protocols that ensure our 
correctness criterion when the 02PC protocol is employed. As such, the protocols actually complement 
the 02PC protocol. The protocols prevent regular cy­cles in the global SG by implementing the stratification 
properties. We strive for protocols whose execution re­quires no messages other than the standard 2PC 
mes­sages. transaction Ti, a site is either unmarked, or marked. Then, a site is marked locally-committed 
with respect to Ti, or marked undone with respect to Ti. Initially, a site is unmarked with respect to 
a transaction Ti. A site is made locally-committed with respect to Ti once it votes to commit Ti in response 
to a VOTE-REQ message. On the other hand, if the site votes to abort Ti, the site is made undone with 
respect to Tt. A site ceases to be locally-committed with respect to Ti and becomes unmarked with respect 
to that trans­action whenever the site receives the decision message from the 2P. coordinator to commit 
Ti. If the decision is to abort Ti, then the site becomes undone with re­spect to Ti. At some point, 
a site ceases being undone with respect to an aborted transaction and becomes un­marked with respect 
to that transaction. We postpone the discussion concerning this transition to Section 6.2. It is important 
to note that all these transitions in the marking are triggered either by local events, or by mes­sages 
that are already part of the 2P. protocol. Figure 2 summarizes the transitions in the markings. Using 
this marking scheme, we devise protocols that ensure that the stratification properties are sat­isfied. 
Intuitively, the protocol should prevent situa­tions where a global transaction accesses a site that 
is locally-committed with respect to another transaction, as well as a site that is undone with respect 
to that other transaction, since such a situation can result in a regular cycle. Protocols P 1 and P2 
correspond to the stratification properties S1 and S2, respectively. Each of the two protocols can be 
summarized by a rule that restricts the sites a global transaction Tj may access: PI. Let Tj execute 
at a site that is marked with re­ spect to a Ti. Then for each such Ti, either one of the following conditions 
hold: all sites in which Tj executes are undone with respect to T~. . all sites in which Tj executes 
are either locally-committed or unmarked with respect to T;. P2. Let Tj execute at a site that is marked 
with re­spect to a Ti, Then for each such Tz, either one of the following conditions hold: all sites 
in which TJ executes are locally­committed with respect to Ti. s all sites in which Tj executes are either 
un­done or unmarked with respect to Ti. In the context of a multidatabase environment, it is very important 
to notice that PI and P2 do not im­pose anyrestrictions on local transactions. Only global transactions 
are subject tothe restrictionsposed in the protocols. Therefore, the autonomy of local database systems 
is not affected by these protocols. 6.2 Protocol PI In this section, we outline a possible implementation 
of protocol PI, and argue about the correctness of the protocol. Since P2 is in some sense dual to P1 
we do not discuss P2 here, The main challenge in devising an implementation for PI is the timing of the 
transition from undone to unmarked with respect to Ti. Making this transition too early can cause the 
formation of regular cycles. Re­call that PI allows a transaction Tj to access data at sites that are 
locally-committed with respect to Ti as well as access data at sites that are unmarked with re­spect 
to Ti. Therefore, Tj may access a site that is locally-committed with respect to Ti and a site that was 
undone with respect to Ti and was prematurely unmarked. As far as correctness goes, the precondition 
for this problematic transition is formulated as follows. A site Sk that is undone with respect to Ti 
can be unmarked with respect to Ti, if: UDUMO (undone to unmarked). All Tj that have accessed sites that 
are locally-committed with respect to Ti cannot possibly access Sk. It seems that extra messages are 
needed for the de­tection of this condition. However, the fact that global transactions obey the 2PL 
rule can be used to implicitly deduce UDUMO. Namely, we observe that the condi­tion in UDUMO is implied 
by the following: UD UM1. For each site in which Ti executes, there is a transaction that has also executed 
at that site, while that site was undone with respect to Ti. Once a site Sk makes a transition in its 
markings as specified by UDUM1, there can be no Tj that accesses a site that was locally-committed with 
respect to Ti and is about to access Sk. This argument is formalized in the following lemma. Lemma 4. 
UD UM1 tmphes UD UMO. 0 For the implementation of P 1, the marking of sites locally-committed with respect 
to transactions is actu­ally redundant, since the protocol allows transactions to access both sites that 
are locally-committed and un­marked with respect to another transaction. IIence, we can simplify matters 
and avoid the locally-committed marking altogether. JVe introduce data structures for maintaining the 
markings. For each site, Sk, the protocol maintains a set, callecl sitemarks. k, of transaction IDs: 
T, c sitemarks. k ~ Sk is undone wrt T, These marktng sets are updatecl to reflect the transi­tions described 
above, and are read by global tramac­tions in order to ascertain whether execution at a par­ticular site 
complies with the relevant protocol. The fact that a site is unmarkecl with respect to a transac­tion 
is deduced implicitly from the lack of any marliing in the corresponding marking set. In orcler to preserve 
the semantics of the sets as defined above, concurrent accesses to the sets must be controlled. One option 
is to designate special entities for storing these sets in the underlying local databases. As part of 
the database, the sets are accessed by transactions subject to the 2PL rule. Other alternatives are explored 
in [KLS90b]. Each time a subtransaction is invoked at a new site a check is performed to determine whether 
the marliings of the new site comply with the markings of the sites the global transaction has already 
had subtransactions in. For each global transaction, Tj, the protocol main­tains a set, called transmarks.j, 
of transaction IDs: Ti e transmarks.j = Ti E sitemarks.k and Tjh was already invoked The set transmarks.j 
accumulates the markings of sites where Tj already has subtransactions. This set is used for the check 
which is performed by the func­tion compatible(transmarks, sitema~ks). This func­tion returns true if 
the two sets are compatible with each other according to the protocol rules and false otherwise. Since 
only one type of marks is usecl, the compatibility checli is simply: compatible(transmarks, sitemarks) 
return (Vx : x G transmarks : x E sitemarks) The pseudo-code segment R1 below models the conl­ patibility 
check and the corresponding actions. R,l should be executed as the first action of Tjk at sk: R1. if 
compatible(transmu rks.j, sitesitemarks.k) then {trunsmarks.j +--tvansmclrks.k U sitemarks.k start the 
actions of Tjk } eke reject Tjk In case the request to spawn the subtransactions is rejected it can be 
retried later, unless the incompatibil­ity is such that only aborting the corresponding global transaction 
can resolve the situation (e. g., Tj is exe­cuted at a site that is unmarlied with respect to Ti, and 
attempts to spawn a subtransaction at a site that is undone with respect to Ti). Next we describe how 
the transitions in the nlarl<­ings are inll)lelnelltecl. Implementing UDUhfl may be cheaper in terms 
of messages. However, it requires aug­menting the data structures. Keeping track of the set of execution 
sites for each transaction is necessary. Also, it must be possible to determine at what site a marking 
Ti ~ transrnarks.j was added to the transmarks.j set, For brevity, we do not present here the necessary 
augmented data structures. We note, however, that managing these structures does not incur any extra 
messages. The following pseudo-code segments sum­ marize the implementation of P 1: R2. The last operation 
of CTik: sitemarks.k + sitemarks.k U {T~} R3. Whenever UDUM1 is detected: sitemarks.k +-sitemarks.k 
{T;} R3 is executed as part of the transaction that enabled the transition; that is, the transaction 
whose access to Sk made UDUM 1 detectable at that site. Lemma 5. If Tj accesses (reads or writes) a data 
item at site sk while the sate is undone with respect T~, then CTi --+ Tj in SGh. 0 Lemma 6. Let T, be 
an aborted transaction that has executed at site sk. suppose that Ti --+ Ti is not in SGk. If Tj accesses 
a data item at Sk while h sate M unmarked with respect Ti, then either Tj --+ CT~ at all sites where 
both Tj and Ti appear, or CT~ + Tj at all sites where both Tj and Ti appear. 1 Given the above two lemmata, 
we can establish that protocol P 1 ensures that the stratification property S 1 is indeed met. Several 
comments concerning the protocols and their implementation are in order. Considering the proposed implementation 
for P 1, we note that the marking sets induce extra con­flicts among otherwise non-conflicting pairs 
of transactions only if one of the transactions aborts. Thus, again, under the optimistic assumption, 
per­formance is not offset by this overhead . 0 Deadlocks may arise due to contention to the lo­cal marking 
sets. For example, a transactions that read-locks sitemarks. k in order to perform the compatibility 
check, may be blocked while at­tempting to access a regular data item z that is locked by CTik. The compensating 
transaction, on the other hand, may be blocked too, holding a lock on x and attempting to access sitemarks.k. 
One simple way to avoid this deadlock problem is to perform all the accesses to the marking sets as the 
last access of subtransactions. The only problem with this simple remedy is the compati­bility check 
(Rl). Checking for compatibility late results in wasted efforts in case the check fails. An acceptable 
compromise would be to perform the check first and then unlock site marks. k. In case the check succeeds 
and the subtransaction is completed, the check is validated again as the last action of the subtransaction. 
In addition to protocols P1 and P2 there are a va­riety of other protocols resulting from other strat­ification 
properties. For instance, a very simple protocol is one that requires that for each trans­action Tj, 
all sites in which Tj executes are un­done with respect to the same transactions, and are locally-committed 
with respect to no transac­tion. There is a trade-off between the protocol s simplicity and the degree 
of concurrency it allows. Further details on the other protocols can be found in [KLS90b]. Conclusion 
The use of the 2PC protocol to ensure the atomicity of transactions in a distributed environment creates 
severe, yet inevitable difficulties. The 02PC proto­col presented in this paper avoids these difficulties 
by trading standard atomicity for semantic atomicity. As a result of the relaxed atomicity notion, serializability 
may be lost. We propose a correctness criterion that reduces to serializability if no global transactions 
are aborted, and deviates from serializability only to the extent dictated and allowed by the special 
characteris­tics of compensating transactions. The 02PC was augmented by P 1 to preserve this criterion. 
A distinctive feature of the 02 PC/Pi com­bination is that it makes no changes to the message transfer 
pattern or the structure of the standard 2PC protocol. Thus, the 02PC scheme is compatible with the standardization 
efforts of the 2PC protocol, cur­rently underway. References <RefA>[AGMS87] R. Alonso, H. Garcia-Molina, and 
K. Salem. Concurrency control and re­covery for global procedures in feder­ated database systems. Data 
Engineer­ing, 10(3):5 11, September 1987. [BHG87] P. A. Bernstein, V. Hadzilacos, and N. Goodman. Concurrency 
Control and Recovery in Database Systems. Addison-Wesley, Reading, MA, 1987. [BS88] Y. Breitbart and 
A. Silberschatz. Mul­tidatabase update issues. In Proceed­[BST90] [CP87] [DE89] [fdb87] {GM83] [GMGK+90] 
[GMS87] [Gra78] [Gra81] inqs of A CM-SIG MOD 1988 Int em a­iionul Conference on Management of Data, Chicago, 
pages 135-141, 1988. > . Breitbart, A. Silberschatz, and G. R. Thompson. Reliable transaction manage­ment 
in a multidatabase system. In Pro­ceedings of A CM-SIGMOD 1990 Inter­ national Conference on Management 
oj Ddaj Atlantic City, New Jersey, pages 215-224, 1990. S. Ceri and G. Pelagatti. Dtsiributed Database 
Systems, Principles and Sys­tems. McGraw-Hill, New York, 1987. W. Du and A. K. Elmagarmid. Quasi serializability: 
a correctness criterion for global concurrency control in Inter-Base. In Procee[lings of the Fifteenth 
International Conference on Very Large Databases, Amsterdam, pages 347-355, 1989. Special issue on federated 
databases sys­tems. Data Engineering, 10(3), Septem­ber 1987. H. Garcia-hIoIina. Using semantic lmowl­edge 
for transaction processing in a dis­tributed database. ACM Transactions on Database Systems, 8(2):186 
213, June 1983. II. Garcia-M olina, D. Gawlick, J. Klein, K. Kleissner, and K. Salem. Coordinat­ing 
multi-transaction activities. TecImi­cal Report UMIACS-TR-90-24, Univer­sity of Maryland Institute for 
Advanced Computer Studies, February 1990. H. Garcia-Molina and K. Salem. Sagas. In Proceedings of A 
CM-SIGMOD 1987 International Conference on Manage­ment of Data, San Francisco, pages 249 259, 1987. 
J. N. Gray. Notes on database operat­  ing systems. In Lecture Notes in Com­puter Science, Operating 
Systenls: An Advanced Course, }rolume 60, pages 393­ 481. Springer-Verlag, Berlin, 1978. .1. N. Gray. 
The transaction concept: Virtues and limitations, In Proceedings of the Seventh International Conference 
on Very Large Databases, Cannes, pages 144-154, 1981. [lKIMO] [KLS90a] [KLS90b] [KR8S] [Lev90] [map89] 
[MLOS6] [Reu89] [SkeS2] [Vei89] special isslle on het­erogeneous clatabases. ACM Comput~n~ Surveys, 22(3), 
September 1990. H. F. Kortl], E. Levy, and A. Silber­schatz. A formal approach to recovery by compensating 
transactions. In Proceed­ings of the ,$ izleenth International Con­ference on Very Large Daiabases, Bris­bane, 
pages 95-106, August 1990. H. F. Korth, E. Levy, and A. Silber­schatz. An optimistic two-phase com­mit 
protocol. Technical Report TR-90­31, The University of Texas at Austin, Computer Sciences Department, 
1990. J. Klein and A, Reuter. Migrating trans­actions. In Future Trends in Distributed Computer Systems 
in the 90s, Hong A ong, 19S8. E. Levy. A theory of relaxed atomic­ity. Submitted for publication, November 
1990. Multidatabase services on 1S0/0S1 net­works for transactional accounting. Techn­ ical Report hlAP761B, 
SWIFT, INRIA, GMD/FOI<US, University of Dortmund, 19S9. Final Report, Edited by S.lV.I.F.T. Society for 
Worldwide Interbank Finan­cial Telecommunications S.C. 81 avenue Ernest Solvay, B-131O La Hulpe, Bel­gium. 
C. Mohan, B. Linclsay, and R. Ober­marck. Transaction management in the R* distributed database management 
system. ACM Transactions on Database Systems, 11(4):378-396, December 1986. A. Reuter. ConTracts: A means 
for extending control beyond translation boundaries. Presentation at 3rd Work­shop on High Performance 
Transaction Systems, Pacific Grove, CA, September 1989. D. Skeen. Non-blocking commit proto­cols. In 
Proceedings of A CM-SIGMOD 1982 .lnternational Conference on Man­agement of Data, Orlando, pages 133 
147, 1982. J. Veijalainen. Transaction ConceMs in Autonomous Database Environments. R. Oldenbourg Verlag, 
Munich, 1989. 97 
</RefA>			


 Algorithmic Strategies in Combinatorial Chemistry Deborah Goldman* Sorin Istrail~ Giuseppe Lancia ~ 
Antonio Piccolboni ~ Brian Walenz ¶ Abstract Combinatorial Chemistry is a powerful new technology in 
drug design and molecular recognition. It is a wet- laboratory methodology aimed at "massively parallel" 
screening of chemical compounds for the discovery of compounds that have a certain biological activity. 
The power of the method comes from the interaction be- tween experimental design and computational model- 
ing. Principles of "rational" drug design are used in the construction of combinatorial libraries to 
speed up the discovery of lead compounds with the desired biological activity. This paper presents algorithms, 
software develop- ment and computational complexity analysis for prob- lems arising in the design of 
combinatorial libraries for drug discovery. We provide exact polynomial time al- gorithms and intractability 
results for several Inverse Problems -formulated as (chemical) graph reconstruc- tion problems -related 
to the design of combinatorial libraries. These are the first rigorous algorithmic re-sults in the literature. 
We also present results pro- vided by our combinatorial chemistry software package OCOTILLO for combinatorial 
peptide design using real data libraries. The package provides exact solutions for general inverse problems 
based on shortest-path topo- logical indices. Our results are superior both in accuracy and computing 
time to the best software reports pub- lished in the literature. For 5-peptoid design, the com- putation 
is rigorously reduced to an exahustive search of about 2% of the search space; the exact solutions are 
found in a few minutes. 1 Introduction  1.1 The Combinatorial Chemistry Framework Chemical Indices and 
Inverse Design Prob-lems based on them. The area of quantitative structure-activity relationship (QSAR) 
identified for ~Berkeiey, dgoldman@cs.berkeley.edu tSandia National Laboratories, scistra@cs.sandia.gov 
**University of Padova, lancia~dei.unipd.it § UC Davis, piccolboQucdavis.edu ¶Sandia National Laboratories, 
bwalenz@cs.sandia.gov chemical compounds various measures, or indices, that provide correlations with 
the likelihood of biological ac- tivity. There are 2D measures (at the level of the chem- ical graph) 
and 3D measures (at the level of coordi- nates for its atoms in the 3D space). In our context, "biological 
activity" is a complex process of molecular recognition, binding, and possible conformation change between 
one small compound, and a large biological complex (e.g., a protein complex). It is very diffi-cult to 
capture the notion of biological activity within the framework of numerical measures at the compound 
level. However, some measures were found that that work well. One notorious example is the Wiener index 
defined as the sum of pairwise shortest path distances between atoms in the chemical graphs of the compound. 
It correlates with physicochemical characteristics such as the boiling point. A variety of chemical topological 
(2D) and topographical (3D) indices were introduced and much research was performed towards the under- 
standing of their correlation with various types of ac- tivities. A chemical index is a map from the 
set of chemical compounds to the Real numbers. One could think of the co-domain of this function as the 
"activity space". Compounds with similar activity are mapped "close" in the space. Typically huge numbers 
of compounds are mapped to identical, or near identical index values. In a natural way, given some activity 
level/value, or a region in the activity space, one wants to design chemical compounds having that index 
value, or whose index is in that region. Solving these types of inverse problems is the subject of our 
paper. The input data for these computational problems are laboratory experiments, where some lead compounds 
were identified. The problem is to generate new laboratory experiments that will accelerate the likelihood 
of discovering new, more powerful, compounds. In order to do so we have to solve inverse problems based 
on specific indices. One wants several solutions for the inverse problem that are as "diverse" (different 
chemcial structure) as possible. Based on them, a new combinatorial library is created, and new lead 
compounds are discovered. 276 Chemical Graph Reconstruction Problems. New types of graph reconstruction 
problems occur in this area whose solutions are needed for the design of combinatorial libraries. One 
type involves constructing graphs or trees having a given topological index. A sec- ond type involves 
selecting chemical fragments from a library and creating "artificial proteins", called combi-natorail 
peptides, that match a given index. 1.2 Algorithmic Challenges In this paper we will consider in particular 
the Wiener index (the sum of the distances in the graph between each pair of vertices), which is probably 
the most widely known ([1]). The Wiener index, W, was devised by the chemist Harold Wiener in 1947 [2], 
who found a strong correla- tion between W and a variety of physical and chemical properties of alkanes, 
alkenes and arenes. With respect to the inverse problem on unrestricted graphs, we will show that in 
general it has a simple solution both in its decision (does a graph with a given Wiener index exist?) 
and construction versions. The problem however becomes more complex if we add the constraint that the 
graph must be a tree. For this case we give a pseudo-polynomial dynamic programming procedure which builds 
a tree with a given Wiener index (if one exists), but we do not know the complexity of the decision version: 
While analyzing the inverse problem on trees, we come to the definition of a new interesting topological 
property, that is the loads distribution for the edges. We show that finding a tree whose edges have 
given load values is NP-complete, and describe a search procedure which solves the problem very quickly 
in practice. As far as the construction of peptoids is concerned, our work focuses on inverse problems 
based on 2D and 3D QSAR descriptors (which include the Wiener index, but also the Atom Pairs, the Bemis-Kuntz 
histogram of triangles) that have been proven effective in a num- ber of projects for selecting active 
molecules from large databases. Formulated as graph reconstruction prob- lems, a typical inverse problem 
is defined as follows. Given a combinatorial library for peptides with N units, with fragment libraries 
for every position of maximum size L and an integer W, find a set of high diversity peptides whose Wiener 
index is W. We present a polynomial time algorithm, based on dynamic programming, for such inverse problem. 
Fur-ther, we describe a software implementation of a search algorithm, capable of finding all possible 
solutions, that outperform the existing methods proposed in the liter- ature (see e.g. [3, 4, 5, 6]). 
Our strategy is based on an effective pruning of the search space, via the intro- duction of a simple 
computational filter -the flower compression -and show how it can be used to group many graphs which 
have related Wiener indices and discard, at once, whole families of unfeasable solutions without examining 
their members in detail. Our al-gorithms can be easily generalized to find all (or any) feasible molecule 
whose topological index of interest is within some given range from a specific target. Our software package 
OCOTILLO contains the implemen- tations of several algorithms that exactly solve inverse problems based 
on general shortest-paths indices.  1.3 Previous Work Combinatorial chemistry research started in the 
early 1990s (see [5, 7, 8, 9] for early develoments and history). A lot of studies were devoted topological 
indices and correlations with biological activity [10, 11, 12, 13, 14], including an entire book "Chemical 
Graph Threory", N. Trinajstic [15]. Heuristic approaches to combinatorial chemistry design problems are 
discussed in [3, 16]. 1.4 An outline of the paper The remainder of the paper is organized as follows. 
In section 2 we introduce some suitable notation. Sec-tion 3 is devoted to the inverse Wiener index problem 
for general graphs (subsection 3.1) and trees (subsec-tion 3.2). Section 4 discusses the problem of recon- 
structing a tree from its set of splits. In section 5 we address the problem of building a peptoid with 
a given Wiener index. Subsection 5.1 contains a polynomial algorithm, based on dynamic programming, for 
find- ing one such peptoid, while subsection 5.2 describes a fast search procedure capable of listing 
all feasible so- lutions and reports on our computational results of the OCOTILLO package. 2 Preliminary 
Definitions DEFINITION 2.1. Given a graph G = (V, E), by dG(i, j) we denote the shortest path (i.e. with 
the smallest number of edges) between two vertices i and j. If G is a tree, then dG(i,j) is the length 
of the unique path between i and j. We simply write d(i, j) if the graph or tree is understood from the 
context. As is customary, we may often denote by n, or n(G), the number of nodes of a graph. We denote 
by Kn the complete graph on n nodes. Sn is a star on n nodes (all nodes but one are leaves). Pn is a 
path of n nodes. For ease of notation, in the following definition and in the remainder of the paper, 
when we write ~,jey, the summation has to be understood as actually re- v j VI ] V3  Figure 1: A 3-peptoid; 
the three fragments are anchored on a linear scaffold at positions vl, v2 and v3. stricted to pairs of 
distinct vertices. DEFINITION 2.2. Given a graph G = (V,E), its Wiener index w(G) is the total node-to-node 
path length. That is, w(G) = ~'~.i,jev dG(i,j). The following graphs are used to describe formally the 
problem of the combinatorial synthesis of specific molecular structures. DEFINITION 2.3. A (chemical) 
fragment is a graph G with a special vertex v denoted as its anchor, or hook-ing point. A peptoid is 
a graph obtained by join- ing in a linear fashion from left to right, k fragments G1, . . . , Gk via 
a path through their hooking points (Fig- ure i). Note that, when k = 1, a fragment is a spe- cial case 
of a peptoid. For a peptoid D = (V, E), by l(D) := ~icu dG(i,vk) we denote the total distance of all 
vertices from the rightmost hooking point vk. For k = 1, lO gives the total distance from all nodes of 
a fragment to its anchor. We can think of a rooted tree as a special case of fragment whose hooking point 
is its root. Henceforth we have the following definition for rooted trees. DEFINITION 2.4. Given a tree 
T = (V,E) with root v C V, the total distance of its vertices from the root is l(T) := ~,.i~y d(i, v). 
3 The Inverse Wiener Index Problem We have developed graph theoretic results for the reconstruction problem 
based on the Wiener index. 3.1 The inverse Wiener index problem for graphs THEOREM 3.1. For any W # 2, 
5 there exists a graph G such that w(G) = W In order to prove this theorem, we need the follow- ing lemma: 
LEMMA 3.1. For every graph G = (V, E) with diameter 2 and Wiener index W, the graph G' = (V, EU {e}) 
for e ~ E has Wiener index W -1. Proof. Let e --(vl, v2). Clearly riG(v1, v2) = 2 and de, (vl, v2) --1. 
Any other distance is preserved by this transformation. We are now ready to prove Theorem 3.1. Proof. 
Let Go = Sn, the star of size n. We have w(Go) = (n -1) 2 and the diameter of Go is two. Let G1 be the 
graph obtained by adding to Go an edge not already contained in it. G1 is either K~ or has diameter two, 
and by the above lemma w(G1) = w(Go) -1. It it possible to repeat this procedure until the graph obtained 
is Kn and w(Kn) = n(n -1)/2. At any step, the lemma guarantees that w(Gk) = w(Gk-1) -1. Thus each number 
in the interval IN = [n(n -1)/2, (n -1) 2] is the Wiener index of Gk for some k. Since the intervals 
overlap for n > 4, and including the interval values for n = 4, we find for W > 5 there is a graph G 
such that w(G) --W. 1,3 and 4 are the Wiener index of P2 (a path of length 2), K3 and P3, resp. To prove 
that there is no graph G such that w(G) = 2, it is enough to observe that the graph on n nodes with the 
smallest Wiener index is Kn, and the one with the largest is Pn, but w(P2) = 1 and w(K3) = 3. The theorem 
is constructive and leads in a straight- forward way to an algorithm solving the search problem, that 
is outputting a graph with the required given in- dex. Since the size of the graph is polynomial in the 
Wiener index and a number can be represented with a logarithmic number of bits, this algorithm can be 
classi- fied as pseudo-polynomial --that is, it is polynomial in the parameters describing the problem 
but not on the size of the representation of the input. More in detail, the computation time is dominated 
by the time neces- sary to output the graph, that is O(n2). Since for the class of graphs considered 
n(n -1)/2 _< W < (n -1) 2, the time complexity is also O(W). 3.2 The inverse Wiener problem for trees 
The problem we will be concerned with in this subsection is the following: given a positive integer W, 
find whether there exists a tree T s.t. w(T) = W. We will consider also the problem of finding such a 
tree. Clearly, Theorem 3.1 involves non-trees, and thus it does not apply to this more constrained setting. 
Indeed, there are many integers that are the Wiener index of some graph but not of any tree. Using an 
algorithm we will describe in the following, we checked exhaustively for W < 10000 and 159 turns out 
to be the largest such example. This experimental evidence together with the analogy with the case of 
graphs leads to the following conjecture: CONJECTURE 3.1. Every positive integer but a finite set 1 is 
the Wiener index of some tree. The above conjecture appeared first in [17], where it was verified for 
W up to 1206 by a complete enumer- ation of all unlabeled non isomorphic trees of up to 20 nodes. If 
true, it would imply that the decision problem is trivial, but the proof would not necessarily lead to 
an efficient solution of the search problem. 3.2.1 A recurrence relation for the Wiener in- dex It is 
possible to prove a recurrence relation for the Wiener index of trees which is closely related to the 
one we will prove for peptoids in 5.1. Let T = (V, E) be a tree and (vi,v2) an edge. Let T1 = (Vi,Ei) 
and 27.2 = (V2, E2) be the two trees obtained by removing (Vl, v2). Let us assume that T and T1 are rooted 
in vl and 2"2 in v2. We have the following recurrence for w(-), l(-) and n(-): THEOREM 3.2. (3.1) n(T) 
= n(T1) + n(T2) (3.2) l(T) = l(T1) + l(T2) + n(T2) (3.3) w(T) = w(Ti) + w(T2) + l(T1)n(T2) + I(T2)n(T1) 
+ n(Ti)n(T2) Proof. 3.1 is obvious. To prove 3.2 we use the definition of l(-) and rearrange the summations 
slightly, as follows: t(T) = Zd(vl,v) vEV = d(Vl, + E d(vl, v) vEV1 t, EV2 = e(v , + Z v) + 1) + 1 vE 
Vi vE V2 = *(T1) + t(T2) + n(r2) The same technique leads to the proof of 3.3 --r--NNamely:{2, 3, 5, 
6, 7, 8, 11, 12, 13, 14, 15, 17, 19, 21, 22, 23, 24, 26, 27, 30, 33, 34, 37, 38, 39, 41, 43, 45, 47, 
51, 53, 55, 60, 61, 69, 73, 77, 78, 83, 85, 87, 89, 91, 99, 101, 106, 113, 147, 159} w(T) = Z v,wEV = 
Z + Z + v,wE V1 v ,wE V2 Z e(v,w) vE V1 ,wEt'? = w(r~) + w(T2) + Z (d(v, vl)+l+d(v2,w)) vE V1 ,wE V2 
= w(r~) + w(r2) + l(T1)n(r.,) + l(T2)n(T1) + n(Ti)n(T2) 3.2.2 A dynamic programming algorithm for the 
inverse Wiener index problem This recurrence relation leads naturally to a dy-namic programming algorithm 
for the problem of find- ing a tree T with assigned w(T), l(T) and n(T) . The key observation is the 
following: every tree with at least one edge can be decomposed in the way dic- tated by the above recurrence, 
that is by removing an edge. Whatever the edge removed, we obtain two trees Ti,i = 1, 2, and for each 
i, w(Ti) < w(T), l(Ti) < l(T) and n(Ti) < n(T). Let us define a matrix M so that MW, L,N be 1 if there 
is a tree T such that w(T) = W, l(T) = L, and n(T) = N, 0 otherwise. According to the above recurrence 
MW, L,N can be computed if MW,,L,,N, is known for every W' < W, L' < L and N' < N. This implies that 
it is possible to compute the entries of M, starting form the initial value Mo,oA = 1 and evaluating 
to 0 all the entries corresponding to W, L, N values out- side feasible bounds, proceeding in an orderly 
fashion. This algorithm solves as well the inverse Wiener index problem: given W, we compute upper bounds 
for the largest L and N such that the triple (W, L, N) is feasible. Then we fill the matrix M up to the 
entry MW, L,N. If for any L' <_ L, N' < N MW, L,,N, = 0 then there is no tree T such that w(T) = ~V. 
The algorithm can be extended so as to return a tree with the required properties: as it is customary 
in dynamic programming, it is enough to stor~, whenever an entry of M is set to 1, the indexes of the 
two entries to which the recurrence relation has been successfully applied. In our implementation we 
use a technique related to dynamic programming called memoization. Instead of filling the matrix M bottom 
up, this technique ap-plies recursively the recurrence relation. To avoid re-computation of the same 
entries, intermediate results get stored in M. It can be thought of as a top-down version of basic dynamic 
programming. It is worth not- ing that without storage of intermediate results the time complexity would 
blow-up exponentially, because of the repeated recomputation of the same entries in M. This technique 
is valuable when an algorithm can be termi- nated without filling completely the matrix M. Other-wise, 
the number of entries evaluated is the same, but there is a slight overhead due to function calls and 
stack management. For our problem, memoization turns out to be much faster for "yes" instances. For example, 
(524,36,19) is a "yes" instance and requires less than one second to compute, while (525,36,19) is a 
"no" instance, requiring 145 seconds. This example is rather extreme, but this behavior is absolutely 
consistent. This evidence prompts for further research along different lines: quantify and analyze this 
asymmetry between "yes" and "no" instances; exploit it to make the computation more efficient (is it 
safe to "give up" after a reasonably short running time? In exploiting the recurrence, is it faster to 
compute many entries in parallel and stop when the first successful computation is over?) As a further 
algorithmic refinement, already ex- ploited in the above mentioned experimental results, we adopt also 
a divide and conquer strategy, whenever possible. Since there are many possible ways of using the recurrence 
relation, we try first the ones for which n(T1) ~-n(T2). This way we proceed directly to the smallest 
possible sub-problems. This approach is in- effective in the worst case (consider W = (N -I) 2, L --N 
-I, that is a star on N nodes), but suggests a sensible order in which to proceed. The pseudo-code is 
given in Appendix A.  3.2.3 Recurrence relations for the Wiener in-dex of bounded degree trees and k-ary 
trees Often the graphs of molecular structures have in- trinsic constraints on the degree of the nodes. 
For in- stance, when the nodes represent individual atoms and edges chemical bonds between them, we obtain 
a graph whose maximum degree is not greater than 4 ([15]). Unfortunately, Theorem 3.1 does not apply 
to bounded ~egree graphs. On the contrary, the use of graphs with high degree seems essential to its 
proof. The situation is better for trees, since we can develop recurrence relations of the same kind 
of the one in Theo- rem 3.2, and this recurrences lead to dynamic program- ming algorithms similar to 
the one just shown. Let us first deal with bounded degree trees. Besides the quan- tities used so far 
--w(.), l(.) and n(T) --we need two more definitions. Let mdeg(-) be the maximum degree of a tree and 
rdeg(-) the degree of its root. As for The- orem 3.2, let T = (V,E) be a tree and (vl,v2) an edge. Let 
T1 = (171, El) and T2 = (V2, E2) be the two trees ob- tained by removing (vl, v2). Let us assume that 
T and T1 are rooted in vl and T2 in v2. We have the following: THEOREM 3.3. mdeg(T) = max(mdeg(T1), mdeg(T2), 
rdeg(T1) + 1, rdeg(T2) + 1) rdeg(T) = rdeg(T1) + 1 Together with Theorem 3.2, Theorem 3.3 character- 
izes the existence of a tree with the required properties and thus can be used to define a dynamic programming 
algorithm. This time, though, the matrix M contain-ing the partial solutions will have five dimensions, 
to account also for mdeg(.) and rdeg(-). The worst case bound for the running time has to be updated 
accord- ingly. We turn now to k-ary trees. To develop a recur- rence for the Wiener index in this case, 
we still rely on the quantities that proved useful so far --namely w(.), l(-) and n(T) --, but we decompose 
a tree in a differ- ent way. Instead of using cuts as before we exploit the definition of k-axy tree. 
Let T ---- (V~ E) be a k-ary tree and let Ti = (Vi, Ei) be the k subtrees hanging from its root. We can 
prove a yet more complex recurrence for the Wiener index in this case. THEOREM 3.4. (3.4) n(T) = 2 n(Ti) 
+ 1 (3.5) l(T) = Z (l(Ti) + n(Ti)) i (3.6) w(T) = + l(ri) + ,,(rd) + i Z l(Ti)n(Tj) + E 2n(T~)n(Tj) 
i~j i<j The proof is similar to the one for Theorem 3.2 and will be omitted. 4 The SPLITS reconstruction 
problem In this section we address the following tree reconstruc- tion problem: Find a tree such that 
for each edge the sizes of the two shores of the cut that the edge defines are equal to some given input 
values, or report that no such tree exists. As we will see, this problem is closely related to the inverse 
Wiener index problem for trees. We start with some definitions. DEFINITION 4.1. For a tree T = (V, E) 
we define the split an edge e C E, denoted by s(e) as the number of nodes on the smallest shore of the 
unique cut identified bye. The load of the edge, denoted by l(e), is the number s(e) × (n- s(e)) of paths 
in T which contain the edge e. By using the loads, we can rewrite the Wiener index for a tree as w(T) 
= ~-~eeE l(e)- The last bit of the Wiener index and the last bit of n are not independent, as the following 
proposition shows. This result appears also in [17, 18], where it is derived by considering trees as 
bipartite graphs and arguing on the parity of paths. We give a much simpler proof. PROPOSITION 4.1. Any 
tree with an odd number of nodes has an even Wiener index. Proof. For each edge either s(e) or n -s(e) 
is even, so the load is even. The problem of finding a tree of a given Wiener index asks therefore to 
find n - 1 loads whose sum is W. This prompted us to the following question: assume we are given such 
loads; can we find the tree? Since for a fixed n the loads uniquely determine the splits, we can rephrase 
the problem as: given splits sl,..., sn-1 find a tree T such that the edges of T have the given input 
splits. This is a problem of tree reconstruction and the set of splits can be viewed as yet another topological 
property that characterizes a family of trees. Further-more, the problem of reconstructing a tree from 
its set of splits is interesting on its own. Unfortunately, the reconstruction problem turns out to be 
NP-complete THEOREM 4.1. The problem, SPLITS, of reconstruct- ing a tree from its set of splits is NP-complete. 
Proof. We reduce from the problem, 3-PARTITION. In this problem we are given a bound, B, and 3m elements, 
Sl,... ,s3m, such that for each i E {1,... ,3m},B/4 < si < B/2. The problem asks whether there exists 
a partition of the {si} into into 3-element disjoint sets such that the sum~of the elements in each set 
is B. We map the instance of 3-PARTITION to the following instance of SPLITS: the value B + 1 ap- pears 
m times and, for each i, we include the values, si,s~ -1,... ,1. If we are given a yes instance of 3- 
PARTITION, we can build a tree in the following way: the root has m children (an m-star) each corresponding 
to a 3-element set in the solution to 3-PARTITION and then departing from each of these there are three 
paths of length equal to the size of items that belong to that set. It can be easily verified that we 
obtain the given splits. Conversely, suppose we are given a tree with the set of splits listed above. 
We show that it is necessarily of the form we just described. Inductively, the tree must necessarily 
contain 3m paths of length mini{s/} consist- ing of edges with splits min{si}, min{si} -1,... , 1 (for 
example, each edge with a split of two must necessar-ily be connected to an edge with a split of one). 
At this point, we conclude that, in fact, we must have 3m similar paths of length si each starting from 
an edge with split si (which contain the former paths) since we are now only able to attach loads >_ 
min{s~} and, by as- sumption on the si sizes, max{s/} < 2 min{si}: for each edge with split s between 
min{s~} + 1 and max{si}, the only edge with smaller load that we can attach must have load exactly s 
-1. Finally, also from the bounds on the s~, we infer that exactly three paths depart from each leaf 
of an initial m-star, the edges of which all have split size B + 1. As above, the s~ values of the edges 
departing from the star edges provide a solution to the instance of of 3-PARTITION. Since the reduction 
is clearly polynomial time computable, this completes the proof of the theorem. [] The problem of reconstructing 
a tree from its set of splits can be solved by the following enumerative algorithm. Sort the splits so 
as to have sl > ... > sn-1 = 1. Starting with a tree consisting of a single node of weight n, we insert 
the edges one at a time, ending Up with a tree on n nodes, each of weight 1. At step k we 1. look -exaustively- 
for a node i whose weight w~ is larger than sk 2. augment: attach to node i a new node node j, setting 
wj := Sk and decreasing wi to wi -sk.  Note that at step 1 we may have to break ties. The presence of 
these ties is what makes the algorithm exponential, since we may have to backtrack from a wrong choice. 
It is not immediate that this algorithm does indeed work. For instance, the sorting of the .si is crucial, 
as the following example shows: Take n = 4 and sl = s2 = 1, s3 = 2. Then there is no way of placing the 
split 2 after having placed the two splits 1. So we need to show that it is enough to consider the sorted 
permutation of the splits out of the (n -1)! possibilities. PROPOSITION 4.2. If sl > ... > sn-1 is a 
YES instance of SPLITS, then the algorithm terminates with a feasible solution. Proof. We may reason 
backwards by starting from the tree and finding the correct sequence of nodes to augment. Let T be a 
feasible solution. Give weight 1 to each node of T and repeat the following operation, for k = 1 to n 
-1, until T has only one node. Take a leaf i of T of minimum weight among the leaves. Let (i,j(k)) be 
the unique edge out of i. Delete node i and increase Wj(k) as Wj(k) :: Wj(k) -~- Wi. By looking backwards 
at the sequence of trees thus obtained, we see a possible run of the algorithm which augments on j(k 
-1),... ,j(1) creating edges of decreasing splits. This argument also implies that for YES-instances 
there always exists a choice of nodes to augment which requires no backtrack, and indeed this is what 
hap-pened on the vast majority of small examples which we tried initially, before proving that the problem 
is NP- complete. We then performed a more exaustive testing in the following way. We generate an unlabeled 
tree, uniformly at random (as described in [19]), then com-pute its splits and try to reconstruct it 
(or a different feasible solution). Ten instances for each value of n = 10, 20,... , 100 were solved 
immediately, while for n _> 110 the algo- rithm started incurring in some long runs every once in a while. 
By performing the selection at step 1 in an or- derly fashion (i.e. try the available nodes by increasing 
order of weight) we solved all generated problems, for n up to 300, in less than 1 second each. The good 
average performance raises an interesting theoretical question on the probability that the search algorithm 
may find a solution withouth backtracking (or within a small num- ber of tries) on a tree generated u.a.r. 
5 Inverse Problems for Peptoid Design In this section we consider the following problem. In the framework 
of combinatorial chemistry we are given a fragment library, and values (lists, histograms) for some index. 
We want to find combinatorial peptoids (a compound of elements from the given library) that match exactly 
that index. 5.1 A dynamic program for peptoid construc-tion THEOREM 5.1. One can compute in polynomial 
time whether there exists a peptoid with a given Wiener index, W, and, if so, output a solution. Proof. 
We use a dynamic programming algorithm sim- ilar to the algorithm given to find a tree of a particular 
Wiener index. Note that W is bounded by a polyno-mial in the size of the peptoid, N, and the library 
size, L. Assume we have precomputed the Wiener indices of the fragments in the library. Number the anchors 
along the peptoid, say from left to right, by 1 through N. We build up our peptoid from left to right 
by adding a frag- ment from the library to each anchor sequentially. Let l(-) denote the sum of thedistances 
to the rightmost anchor in a peptoid, or the sum of the distances to the anchor of a fragment from our 
library (which is just a peptoid with one anchor). Remove the edge linking the rightmost two anchors 
of a peptoid, P, leaving a smaller peptoid, P', and a fragment, F. The dynamic program- ming algorithm 
follows from the recurrences which we present below. Note that by storing one solution (if one exists) 
in each entry of the table we build, we can out- put a solution with Wiener index W if one exists. The 
recurrences follow. n(P) = n(P') +n(F) l(P) = l(P') + n(P') + l(F) w(P) = w(P') + w(G) + n(P')l(F) + 
n(F)l(P') + n(P')n(F). 5.2 A Fast Enumerative Algorithm In this section, we present a general method 
for inverse problems based on shortest-paths topological indices. We also present results from our software 
package OCOTILLO on actual combinatorial libraries. THEOREM 5.2. The Wiener index of a linear-scaffold 
peptoid constructed with fragments (Figure 1) is N N N W = Z Z [ndj + (j -i)ninj + nflil + Z wi i=l j=i+l 
i=i  where ni is the number of nodes in fragment i, wi is the Wiener index of the fragment and li is 
the sum of the distance from each node to the anchor. Proof. Consider the compound in Figure 1. When 
we compute the shortest path between any two atoms, there are two cases: either the two atoms are in 
the same fragment, or they are not. For all pairs of atoms that are in the same fragment we ~e-compute 
the sum of the distance between each pair and denote this value w --it is just the Wiener index of the 
fragment. For pairs of atoms that are in different fragments, the shortest path between the two atoms 
is always through the two anchors associated with the fragments. We break this path into three components: 
1. The shortest path from atom i to its anchor. 2. The shortest path along the scaffold. 3. the shortest 
path from atom j to its anchor.  The sum of distances between all pairs of atoms in two different fragments 
is: = E iEF. jEF~ = nb E d(i, Va) + nanbd(Va,Vb) + iEF,, jEF~ = nbl~ + nanbd(va,Vb) + nalb where Va 
is the anchor atom of fragment a and na is the number of atoms in fragment a. The Wiener index is now 
the sum of P over all pairs of fragments, plus the sum of the Wiener index of the individual fragments. 
N N N i=l j:i+l i=1 N N N : E E [nilj + ninjd(vi,vj)+njli] + Ewi i:1 j:i+l i----1 If, as in our case, 
the scaffold is a linear chain, then the distance from the anchor of fragment i to the anchor of fragment 
j is IJ - i], and, N N N W .~- E E [nilj Jr (j -i)ninj --t- njl'il "Jr" E wi i=1 j=i+l i=1 We can rewrite 
the Wiener index equation as N N N N N W = E ni E li + E E (j -i)nrnj + E (wi -nili) i=1 ~=z i=1 j=~+l 
i=1 Suppose that we treat the entire scaffold as a single vertex, fort~xample, in Figure 1, we would 
compress vl, v2 and v3 to a single vertex. In effect, we have constructed a peptoid with an unordered 
set of fragments, rather than an ordered list of fragments. This is called the flower compression, and 
is at the heart of our fast search method. THEOREM 5.3. The Wiener index of a flower- compressed peptoid 
is N N N i=l j=i+l i:l 4 7r,. i----i "~'~-! ...... T---'T ...... T'--7----~ .... " ...... I .~ \ ! ! 
! i ! ! 3~"~ --r-"" i' i ...... i I I \ ! ~ i 3~-,. i / \ ] i i i i l I / \ i i i i i i .~ zso~ ! ...... 
, --~_~__~..._.~ .... ._~__._._~ I I /~ ' \i i ! i i i i ~ 9~. -----.~----/--.'-4-.----~-.--.~,A ....... 
~ ...............i............. ~.---.-.~ ....... ~............... o95*, ! i\ :: i ' ! [ ] ~ : ~ : i 
! O'O0~" ~S ~'.~ 72'2 11 ~1~799 ff~6 2S804 29 !4T3 33il 42 £IO Wiener Index Figure 2: The percent of 
constructed flower-configuration peptoids that need to be examined in de- tail. A histogram of the number 
of peptoids with a spe- cific Wiener index follows almost the same curve, which explains why the pruning 
algorithm does not prune uni- formly for all Wiener index --there are just more pep- toids that match. 
The proof closely follows that for Theorem 5.2 and is omitted. We let D be the difference between F on 
a set of fragments and W on a set of fragments given the ordering ~r: N N D(Tr) = W -F = Z E (J - i)n~(i)n,,(j). 
i~l j=i+l For a given set of fragments, the ordering, 7rmi~, with the smallest Wiener index is also the 
ordering with the smallest value of D. This forms our pruning search. If the Wiener index we are looking 
for is smaller than minD + F we do not need to check any orderings for the correct Wiener index. for 
each set of N fragments do if mind + F < Wta~get 4_ maxD + F then examine all orderiugs of the set of 
fragments for Wtarget. else discard all orderings of the set of fragments. As a first approximation to 
the minimum and maximum, we can replace each ni with the smallest or largest value of n in the peptoid, 
for example, N N N 3 - N n~ni~. minD > E E (j -i)n~i~ = 6 i=l j=i+l  t lJ ~ i i -o.i i i ........ . 
. . . ~w 41___i__ ] : ! ,,,~ > ..... +../_....~ ..... &#38;._.~ ..................................... 
~ .._~ il i '. '~! ! : ! ! ! ! a,, r- ...... -2---@ ........ ~ ..... - .... v--~---{--+----~ 5401 
~2 24 28 32 36 10 41 CO Wiener Index Figure 3: The CPU time required to search. However, this bound 
is very weak --at Wiener index 9000, we need to examine 32.8% of the peptoids in detail, compared to 
4.7% when using the optimal values for minD and maxD. CONJECTURE 5.1. Given nl < n2 < ... < aN, the ordering 
for the optimal minimum value of D is: 2i-1 ifi < N/2 7rmin(i) = 2(g-i+l) if i > N/2 CONJECTURE 5.2. 
An algorithm to compute the order- ing for the optimal maximum value of D, given nl <_ n.2 < ... < aN, 
is: Lp := 1; L := 0; Rp := N; R := 0; for i := N downto 1 do if R >_ L then 7rma~(Lp) := i; Lp := Lp 
+ 1; L := L + ni; else 7rmax(Rp) := i; Rp := Rp -1; R := R + ni; For example, i 1 2 3 4 5 6 7 8 ni nTr,~i,~ 
( i ) n.=a= i z~i5 iO fl £ O IO I I l~ Both conjectures have been extensively tested. As seen in Figure 
2, not many flower peptoids pass the test. Computational Results. We tested the perfor- mance of the 
pruning algorithm by searching for a five- fragment peptoid using a fragment library with 350 283 amine 
fragments (resulting in 164 different w,l,n values) for each position. This configuration results in 
2.6e12 possible peptoids. A brute force enumeration using the w, l, n compu- tation explained earlier 
required 51,786 cpu-seconds, or 50.5e6 peptoids per second. For comparison, we can estimate that without 
the w, l, n computation, the enu- meration would be at least (350/165) 5 ~ 43 times as long --about one 
month of cpu time --without even considering that the Wiener index computation is also more difficult. 
Applying the flower-compression prun- ing algorithm achieves a significant speedup as can be seen in 
Figure 3, requring anywhere from 540 seconds (4,860e6 peptoids per second) to 3,500 seconds (750e6 peptoids 
per second). 6 Acknowledgements The authors would like to thank Jean-Loup Faulon and Diana Roe for useful 
discussions regarding this paper. This work was supported in part by Sandia National Laboratories, operated 
by Lockheed Martin for the U.S. Department of Energy under contract No. DE-AC04-94AL85000 and by the 
Mathematics, Information, and Computational Science Program of the Office of Science of the U.S. Department 
of Energy. D. Goldman was supported by an American Fellowship from the American Association of University 
Women Educational Foundation. References <RefA>[1] Fiftieth Anniversary of the Wiener Index, Discrete Applied 
Mathematics Special Issue, Vol. 80, no. 1 Gutman, I., Klavzar, S. and Mohar, B. eds., 122 pages, 1997 
[2] Wiener, H., Structural determination of paraffin boil- ing points, J. Amer. Chem. Soc., 69 (1947) 
17-20 [3] Sheridan, R., P. and Kearsley, S., K., Using a Ge-netic Algorithm To Suggest Combinatorial 
Libraries, J. Chem. Inf. Comput. Sci., 35 (1995) 310-320 [4] Venkatasubramanian, V., Chan, K. and Caruthers, 
J. M., Evolutionary Design of Molecules with Desired Properties Using the Genetic Algorithm, J. Chem. 
Inf. Comput. Sci., 35 (1995) 188-195 [5] Gordon, Douglas J., Bellott, Emile M., and Tenen- baum, Boris, 
Using a Genetic Algorithm to Select an Optimum Combinatorial Library Using a Subset of Available Input 
Materials, Exploiting Molecular Di- versity: Refining Small Molecule Libraries, La Jolla, California, 
February 1-5, 1999. [6] Singh, Jasbir et. al., Application of Genetic Algorithms to Combinatorial Synthesis: 
A Computatorial Synthe- sis: A Computational Approach to Lead Identification and Lead Optimization, J. 
Am Chem. Soc., Vol. 118, (1996), 1669-1676 [7] Gallop, Mark A., Barrett, Ronald W., Dover, William J., 
Fodor, Stephen P. A., Gordon, Eric M., Applica- tions of Combinatorial Technologies to Drug Discov- ery. 
Background and Peptide Combinatorial Libraries, Journal of Medicinal Chemistry, Vol. 37, No. 9 (1994) 
1233-1251 [8] Zheng, Weifaa, Cho, Sung Jin, and Tropsha, Alexan- der, Rational Combinatorial Library 
Design. 1. Focus- 2D: A new Approach to the Design of Targeted Com- binatorial Chemical Libraries, J. 
Chem. Inf. Comput. Sci., Vol. 38, (1998) 251-258 [9] Zheng, Weifan, Cho, Sung Jin, and Tropsha, Alexan- 
der, Rational Combinatorial Library Design. 2. Ra- tional Design of Targeted Combinatorial Peptide Li- 
braries using Chemical Similarity Probe and the In- verse SAR Approaches, J. Chem. Inf. Comput. Sci., 
Vol. 38, (1998) 259-268 [10] Carhart, Raymond E., Smith, Dennis H., and Venkataraghavan, R., Atom Pairs 
as Molecular Fea- tures in Structure-Activity Studies: Definition and Ap- plications, J. Chem. Inf. Comput. 
Sei., Vol. 25, No. 25 (1985) 64-73 [11] Bemis, Guy W. and Kuntz, Irwin D., A fast and ef- ficient method 
for 2D and 3D molecular shape de-scription, J. Computer-Aided Molecular Design, Vol. 6 (1992) 607-628 
[12] Good, Andrew C. and Kuntz, Irwin D., Investigating the extension of pairwise distance pharmacophore 
mea- sures to triplet-based descriptors, J. Computer-Aided Molecular Design, Vol. 9, (1995) 373-379 [13] 
Rouvray, D.H., The Search for Useful Topological Indices in Chemistry, American Scientist, Vol. 61, No. 
6, (1973), 729-735. [14] Sabljid, Aleksandar and Trinajstid, Nenad, Quantita- tive structure-activity 
relationships: the role of topo- logical indices, Acta Pharm. Jugosl., Vol 31, (1981), 189-214. [15] 
Trinajstic, N., Chemical Graph Theory, CRC Press, 1992. [16] Gillet, V. J. and Willett, P. and Bradshaw, 
J. and Green, D.V.S, Selecting Combinatorial Libraries to Optimize Diversity and Physical Properties, 
J. Chem. Inf. Comput. Sei., Vol. 39, No. 1 (1999) 169-177 [17] Lepovid, M. and Gutman, I., A Collective 
Property of Trees and Chemical Trees, J. Chem. Inf. Comput. Sci., Vol. 38, No. 5 (1998) 823-826 [18] 
Bonchev, D., Gutman, I. and Polansky, O., Parity of the Distance Numbers and Wiener Numbers of Bipartite 
Graphs, Commun. Math. Chem., 22 (1987) 209-214 [19] Wilf~ H. S., The Uniform Selection of Free Trees, 
Journal of Algorithms 2 (1981) 204-207 [20] Brown, Robert D. and Martin, Yvonne C., Use of Structure-Activity 
Data to Compare Structure-Based Clustering Methods and Descriptors for Use in Com- pound Selection, J. 
Chem. Inf. Comput. Sci., Vol. 25, (1985) 64-73 [21] Brown, Robert D. and Martin, Yvonne C., The Infor- 
mation Content of 2D and 3D Structural Descriptors Relevant to Ligand-Receptor Binding, J. Chem. Inf. 
Comput. Sci., Vol. 37, (1997) 1-9 [22] Needham, Diane E., Wei, I-Chen, and Seybold, Paul G., Molecular 
Modeling of the Physical Properties of Alkanes, J. Am Chem. Soc., Vol. 110, (1998), 4186-4194 [23] Plunkett, 
Matthew J. and Ellman, Jonathan A., Com- binatorial Chemistry and New Drugs, Scientific Amer- ican, April 
1997, 69-73 [24] Mohar, Bojan, A Novel Definition of the Weiner index for Trees, J. Chem. Inf. Comput. 
Sci, Vol. 33, (1993), 153-154</RefA> A Appendix: pseudo-code for dynamic programming algorithm for the inverse 
Wiener index problem In the pseudo-code description of the algorithm that fol- lows, we assume that the 
matrix M has been initialized to a value "undefined" but for M0,0,1 = 1. tree (W,L,N) ifN3-N<6WV(N-1) 
~>WVL<N-1VL> N(N 1)/2 then - return 0 if MW, L,N ~£ undefined then return MW, L,N if N = 1 then return 
0 forN1 := N/2 to N- l do N2:=N-N1 forL1 :=NI-ltoL-N2 do L2 := L- L1 -N2; for WI := L1 to W -L1N2 -L2NI 
-N1N2 do W2 := W -l~ -L12~:2 - L2N1 -N1N2 if tree(W1, L1, N1) = 1 A tree(VV½, L2, N2) = 1 then MW, L,N 
:: 1 return 1 forL1 :--NI-ltoL-N1 do L2 :-- L -L1 -J¥1 for W1 := L1 to W -L1N2 -L2N1 -N1N2 do W2 := W 
-W1 -L1N2 -L2N1 -NIN2 if tree(W1, L1, N1) = 1 A tree(W:, L2, N2) = 1 then I~IW, L,N :: 1 return 1 MW, 
L,N := 0 return 0    
			

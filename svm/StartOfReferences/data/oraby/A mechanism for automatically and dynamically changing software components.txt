
 A Mechanism for Automatically and Dynamically Changing Software Components KatsuhisaMaruyamaandKen-ichi 
Shims NTT Software Laboratories 3-9-11 Midori-cho Musashino-shi,Tokyo 180,Japan {maru, kshima} @slab.ntt.co.jp 
 Abstract The mechanism presented here can automatically and dy­namically change sojtware components 
by using an enhunced program integration algorithm based on program slicing and labeled graph matching. 
It can make two kinds of changes by: i) decomposing components fimctions and by ii) par­tially exchanging 
their functwns with the modification histo­ries of other components. This mechanism enables so@vare components, 
which are called active components, to modijj themselves into new source codes to meet user requirements 
by imitating past user modi$cations, so they do not require many modifications and not all components 
that might be reused in the future need to be prepared in libraries. 1 Introduction Software components 
at the source-code level are based on the assumption that their functions and forms are fixed. Therefore, 
new programs can be easily and rapidly created if source-code components retrieved from libraries can 
be com­posed without any modification [4][ 11][ 13]. However, not all components required by users can 
be prepared in libraries, since users will require an infinite variety of components over time and component 
producers cannot fully predict fu­ture requirements. Therefore, source-code components must be frequently 
modified to meet user requirements. Modi­fying existing components is troublesome for users, since the 
users must understand the components in detail before making modifications and may modify them incorrectly. 
Methods for analyzing domains [2] and parametrizing com­ponents [9] have been reported to alleviate these 
problems. However, these methods are ineffective in domains whose characteristics are continuously changing, 
because the char­acteristics of the current domain will differ from those of the analyzed domain, or 
because it is difficult to determine fragments to be parametrized in a component when the com- Permiesion 
to make digitel/hard copy of part or all thie work for paraonal or classroom use is granted without fee 
provided that copies are not made or distributed for profit or commercial advan­tage, the copyright notice, 
the title of the publication and its date aPPear, and notica ia 9iven that copying is by permission of 
ACM, Inc. To copy otherwise, to republish, to post on eervers, or to redistribute to Iiats, requires 
prior specific permission and/or a fee. SSR 97 MA, USA @ 1997 ACM 0-89791 -945 -9/97 /0005 ...$3.50 ponent 
is produced. Consequently, conventional source-code components with fixed functions and forms are not 
suitable for software reuse in domains whose characteristics are float­ing, even if these methods are 
used. To meet various user requirements and avoid troublesome modifications in the floating domains, 
source-code compo­nents should have the following abilities, some of which software agents [6][ 16] have. 
The components can dynamically acquire domain spe­cific knowledge from user modifications and store that 
knowledge themselves. The components can always communicate with other components in the same librmy 
and share their acquired knowledge. The components can automatically modify their func­tions and forms 
into new ones that meet user require­ments by applying the acquired and shared knowledge to themselves, 
even if users require components that do not exist in the user libraries. We have developed a new mechanism 
for automatically and dynamically changing software components with the above abilities, which we call 
active components. Here, we define the code of an active component as a conventional source­code component 
included in the active component. In this mechanism, the function of active components is to compute 
the values of variables in the codes of these active compo­nents, and the function is the basic unit 
of changes. The mechanism provides two kinds of changes with regard to dividing and merging the function. 
i) Change by decomposing (Cole) This change extracts new source codes by decomposing the codes of active 
components in accordance with user requirements. ii) Change by exchanging (Cez) This change generates 
new source codes by partially ex­changing the codes of active components with the codes in the modification 
histories of other active components in the same library. In Cole, active components can automatically 
extract indis­pensable codes to meet user requirements by using internal knowledge. In Cex, the active 
components can also auto­matically imitate past modifications of other components by dynamically acquiring 
modification histories in their existing users (programmers) ~~lj ~ ComDonen/S libraries and applying 
the acquired knowledge to themselves. _ kbrary - - - - - - -= - - - - . ~.--j- Thus, the active components 
automatically and dynamically change themselves into new source codes according to user requirements 
and the characteristics of user libraries. There­fore, users do not need to modify active components 
to create new programs by reusing source codes which meet their re­quirements. Moreover, they do not 
need to prepare many active components that might be reused in the future in the user libraries. This 
paper presents a new mechanism for changing active components, and also shows an algorithm that can imple­ment 
the two changes of the active components. The mech­anism achieves Cde by program slicing [14] and Cex 
by an enhanced program integration algorithm based on both program slicing and labeled graph matching 
[8] for program dependence graphs (PDGs) [5]. Program slicing is used to extract a set of statements 
from source codes that may affect the value of interesting variables at a specified program point. Labeled 
graph matching is used to judge whether two PDGs are equivalent with respect to labels at nodes and depen­dence 
between the nodes in the PDGs. Active components with the program integration algorithm replace and combine 
fragments in their codes based on dependencies, and can nec­essarily preserve parts of their functions 
in a changed source code. Our integration algorithm is improved in three ways for appli­cation to more 
kinds of source codes that cannot be integrated by conventional program integration algorithms. 1) The 
al­gorithm uses bounded slices [10] to decompose source codes, and it also uses complements to specify 
modified codes in la­beled graph matching. The bounded slice is an extended static slice with a bound. 
The complements are PDGs constituted by the remaining slices. 2) The algorithm abstracts labels at nodes 
in PDGs to specify codes that can be exchanged in labeled graph matching. 3) The algorithm reconnects 
con­trol dependence edges in a PDG of an integrated source code so that all nodes in the PDG can be reached 
from the start node on its control flow graph (CFG) [1]. Active components with the improved algorithm 
can change a variety of source codes and are likely to meet user requirements without any modification. 
In this paper, we first describes the actions of active com­ponents and the new changing mechanism. Next 
we give definitions, the changing algorithm, and examples of the two changes. Then we compare our mechanism 
with conven­tional methods for automatically modifying or integrating programs. Finally we describe the 
effects of reusing active components and discuss future work.   Changing Mechanism Thissectionshowsthe 
structure and actions of active com­ponents, and explains the details of the two changes: I I / sensing 
I pattern I detfW?Ji@rg b ... -... , ---- L . . . . ..-..,, _.>.-- . .. .L----- -: -------­ source 
codes reuse (compose) Figure 1: Actions of active components 2.1 Actions of Active Components To achieve 
Cde and Cex, each active component must have both an engine and a change rule to perform four ac­tions 
that conventional components are not capable of doing. Figure 1 shows actions of active components. Active 
components sense user requirements and environ­ments which are preserved in the common space of a li­brary. 
Requirements are keywords (strings) that represent the functions of required components. For example, 
area is a requirement for the function of calculating the areas of figures. Environments are the characteristics 
of the library, such as source codes modified by users or broadcast modifi­cation histories. Active components 
determine the patterns for changing themselves based on internal knowledge in their change rules and 
sensed knowledge, and then they generate new source codes according to the determined patterns. If a 
user modifies a source code generated from an active compo­nent, the active component records the differences 
before and after user modification as a modification history in its change rule. Active components also 
brrmdcast their modification histories to share acquired knowledge with other components in the same 
library. Active components stop changing when they do not have new change patterns. To create new programs 
by reusing the active components, users only give their requirements to the libraries and they can reuse 
suitable source codes among the changed source codes in the libraries. 2.2 Change by Decomposing Active 
components can change into new source codes needed foruserrequired functions by program slicing. Decomposing 
a code by slicing with respect to variables of interest is the same as extracting a code that is a necessary 
to compute the values of the variables. In Cole, the mechanism uses a keyword which is associated with 
a slice. Active components have criteria which consist of actl w component source code count line~-: 
;(2 15 (Imect)) ! I count words : $(3,18, {wordct)) ,,;~-  ,I??-7-:-boudedsices * ---slice on variable 
linect = new soks mde Figure 2: Change by decomposing (Cole) pairs of a keyword and a slice, and a 
core which is a common code included in all changed source codes. They compare keywords in criteria with 
strings given as user requirements and decompose their codes into slices linked to keywords which include 
the given string. The criteria and core are previously described by component producers. For this mechanism 
to be performed, two conditions must be satisfied. Keywords must correctly describe the function of the 
variables of interest in the corresponding slices. More­over, users must state what functions they desire 
by using the right keywords. These conditions sounds too hard for pro­grammers or component producers, 
but similar conditions are necessarily required in order for users to find the right components among 
many components. Figure 2 shows Cole. For example, an active component X has keywords count 1 ines and 
 count words in a change rule. The corresponding slice is put to the right of each keyword. Suppose X, 
which has the code of the UNIXt utility WC,senses count as a requirement. Then X can change into two 
source codes: slice V for counting lines and slice W for counting words in input text, since the keywords 
corresponding to these slices both include the string count . V and W have some of the functions of X, 
and both include the core which is a slice read file for reading a text file. 2.3 Change by Exchanging 
Active components can guess future modifications to them­selves and can generate new source codes in 
Cex, since source codes similar to codes frequently modified in the past are modified in the same way 
when they are reused. The mechanism to perform Cex is based on the expectation that programmers are likely 
to imitate past modifications of sim­ilar programs to programs which they are creating. To achieve Cex, 
active components record modification his­tories when their changed source codes are modified by users 
t UNIX is a registered trademwk in the United States ~d other cOttntfleS, exclusively licensed through 
X/Open Company, Ltd. (a) Phase1:recording modification histories. P slice on variable @ oftp* ,,finger1?.nt~y 
x seosing broadcasting <Sp, .$Q> .\\\ w. Sp ------. sen.ring ---- ---Cde rema Y lacing rfingerfinger 
ex i generating R .ew source code----­ <- =&#38;~lll (b) Phase 2: exchanging codes with broadcastmorhfication 
Isistories Figure 3: Change by exchanging (Cez) and broadcast the modification histories within existing 
li­braries. Moreover, they also acquire the broadcast modifi­cation histories of other active components 
and partially ex­change the functions of their original codes with those in the acquired modification 
histories. In the mechanism, source codes are defined as similar if slices that have the same func­tions 
are derived from these codes. This mechanism partially exchanges the similar source codes among ones 
extracted by Cole, which are likely to satisfy some of the required func­tions. Thus, active components 
can change only source codes which possess part of functions of original active components and which 
are associated with user requirements. Figure 3 shows Cex, which is divided into two phases: 1) recording 
modification histories and 2) exchanging codes with broadcast modification histories. In Figure 3(a), 
an active component X changes a source code P by Cole. When X senses that P has been modified into a 
source code Q by a user, X derives several slices SP, from P and SQJ from Q based on their functions 
by bounded program slicing, and also derives complements S~a for SPZ from P and S~j for SQ3 from Q. To 
specify modified slices, the mechanism uses a complement which is the code remaining after a slice has 
been removed from the original code. If S~i and S~j are equivalent by labeled graph matching, pre-or 
post-modified statements are enclosed in each of slices Spl (= SP) and s~j (= SQ), since the complement% 
or s~j indicates a non-modified code. Finally, X specifies pairs of exchangeable slices (SP, SQ), both 
of which include codes differing between P and Q, and also records these pairs in its change rule. Thus, 
X can acquire knowledge of the modification of P into Q. In Figure 3(b), X broadcasts its pairs of exchangeable 
slices (SP, SQ) in its existing library and an active component Y changes asourcecode Rby Cole, when 
A orY senses user requirements. When Y senses (Sp, SQ), Y derives several slices SRk by bounded program 
s]icing. If SRk and SP are equivalent by labeled graph matching, SRk (= SR) is a slice to be exchanged. 
Then Y replaces SP (= SR) in R with SQ and combines SQ with a non-exchanged code which is the remainder 
S-Rof the replaced slice SR. Finally, Y can automatically and dynamically generate a source code R by 
exchanging SR with SQ of the modification history. Thus, Y can adapt its form according to the past modifications 
of X. Suppose, for example, that X changed the code of the UNIX utility jlp and jip has been modified 
into @pt by auser in phase 1. In phase 2, Y can generate not only the code of the UNIX utility jinger 
but also rjingert which contains part of the function of rfrp. This happens because X broadcasts the 
history of modifyingflp into rjlp and Y exchanges part of the function ofjnger with part of the function 
of @p.  3 Preliminaries This section defines terms needed in making an algorithm for changing active 
components. 3.1 Language of Source Codes The codes of active components are written in a procedural 
programming language, which is a simplified Pascal-like lan­guage. In this language, expressions contain 
scalar variables, constants, signs, logical operators, relational operators, mul­tiplication operators, 
and addition operators. Statements are either assignments, compound statements (begin-end), con­ditional 
statements (if-then and if-then-else), loops (while), input statements (read and readLn), or output statements 
(write and writeLn). Function calls and non-scalar variables (e.g., arrays and pointers) are excluded 
from the language, since it is difficult to exactly analyze the dependence of these language elements. 
Moreover, the proposed algorithm can detect nodes to be reconnected in the exchanging phase of Cex only 
when each node in a combined PDG has one in­coming control dependence edge. Thus, the language does not 
include jump statements that may create a node with two or more incoming control dependence edges in 
PDGs. The mechanism uses PDGs to change codes. A PDG consists of a set of nodes with either an assignment 
or a condition and a set of dependence edges with the sort. A data dependence (definition-use) that exists 
from anodepto a node qis denoted by p +d q. A control dependence that exists from p to q is denoted by 
p +C q. A dependence can be denoted by pd q, if the dependence is either a data or control dependence. 
And clef(p) is a set of variables defined at a node p, and use(p) is a set of variables used at p. The 
node(G) is a set of nodes inaPDGG, and edge(G) is a set of edges in G. t @pand ghrger are utilitiesthatindirectlyaccesshostsoutsidea 
firewall througha proxy server. 3.2 Bounded Program Slicing The mechanism uses bounded slices [ 10], 
which are extended static slices with bounds, to extract codes with an arbitrary scale from part of large-scale 
source codes. Bounds are defined by a set of nodes CRP(nU, nl ) in a constrained reachable path [10], 
which is the union of forwardly reachable paths from an upper node n. to a lower node n~on a CFG and 
backwardly reachable paths from nl to nu. Users can freely point to nu and nt in any source codes. Bounded 
slices are made by walking over data and control dependence edges in the specified bounds on PDGs. A 
bounded slice for a target PDG is defined as follows: Definition 1 Ns is a set of nodes that can reach 
node nl on the target PDG when traversing nodes in CRP(nu, nl ) and may affect the values of variables 
in variable set v at nl. A bounded slice ~(n=, nl, v) is a subgraph that consists of nodes in Ns and 
edges between nodes in N.s on the PDG. In this paper, bounded slices are simply called slices, since 
every slice is a bounded slice. To indicate non-modified codes between pre-and post-modified source codes, 
the mechanism introduces a complement which is a PDG of the remaining slice and is defined as follows: 
Definition 2 N.s is a set of nodes in ~(nv, nf, v) and Nc is a difference set between CRP(n., nl ) andNs 
(Nc = CRP(nu, n{) Ns). A complement ~ (nu, nl, v) is a sub­graph that consists of nodes in Nc, null-nodes 
that replace nodes in N.s, and edges between nodes in both Ns and Nc on the PDG. A null-node has no label 
to change the value of any variable when executing this node. Active components must automatically determine 
slicing cri­teria (nu, nl, v) based on dependencies in Cez so that each of their functions is necessarily 
included in one or more derived slices. An upper node n~ has variables without respect to incoming dependence 
edges (n. E {n I clef(n) use(n) # 0}). A lower node nl has variables without respect to outgo­ing dependence 
edges (nl G {n I use(n) clef(n) # 0}), and v is an element in the power set of these variables at n[ 
(v E {vJ Iw ~ [use(nt) -deaf]}).  3.3 Labeled Graph Matching and Abstracted La­bels The mechanism uses 
labeled graph matching [8] to judge equivalence (isomorphic in [8]) between two PDGs by map­ping both 
nodes and edges of one graph to nodes and edges of the other graph. Equivalence is defined as follows: 
Definition 3 Two PDGs G1 and G2 are equivalent in kz­beled graph matching if and only if all four of 
the following conditions hold: 1) G1 and G2 have the same number of nodes and the same number of edges. 
2) there is a 1-to-1 and onto mapping M from the nodes in Gl to the nodes in Gz. 3) for every edge p 
-+ q in Gl, there is an edge Lf(p) ~ 5 (c >= A) and (c e Z) AI(q) in G2 of the same sort. 4) for all 
nodes p in GI, labels at p and M(p) in Gz are exactly the same. All variable names, constants, and operators 
in labels at non­modified nodes are equal before and after modification, since the two PDGs are derived 
from the same codes. However, the simple labeled graph matching to specify slices to be exchanged frequently 
fails, since the PDG to be exchanged and the PDG in a broadcast modification history are derived from 
different codes, and labels in these PDGs are not equal. To specify slices to be exchanged, the mechanism 
can abstract labels at nodes on two PDGs before comparing, and can also replace variable names in a PDG 
with ones in the other PDG when comparing abstracted labels. Abstracting labels and replacing variable 
names enables slices derived from the codes to be exchanged to match slices in a variety of modification 
histories, so a variety of new source codes are generated. The equivalence of two PDGs with abstracted 
labels is defined as follows: Definition 4 Two PDGs are equivalent in abstracted labeled graph matching 
if and only if the following two conditions hold in addition to conditions 1), 2), and 3) in Definition 
3: 4) for all nodes p in G1, abstracted labels at p and M(p) in G2 are the same. 5) there area l-to-1 
and onto mapping kf~ from the labels in GI to the labels in Gz, and a 1-to-1and onto mapping MV from 
the variables in GI to the variables in Gz. A procedure for abstracting labels takes the following steps 
1, 2, and 3 in order, and repeats step 3 until the abstracted labels have only one predicate. step 1) 
It replaces relational operators (=, <>,<,>, <= >=), assignments, input statements, and output state­ments 
with predicates, and formalizes labels into logical expressions. It also replaces parentheses ( and ) 
with brackets [ and ] to keep the priority of operations. step 2) It deletes constants, signs, and operators 
that do not have terms on both left and right sides. step 3) It substitutes a new predicate for an expression 
that consists of a logical operator (or, and, not) and two terms on both sides of the operator based 
on the prior­ity of logical operators or brackets. It simultaneously applies the substitution to all 
expressions that have the same priority. Figure 4 shows an example of abstracting and matching la­bels. 
Labels at rank O, which can no longer be abstracted, have one predicate and all variables in original 
labels. A procedure for matching abstracted labels makes a lattice of abstracted labels for each node 
in the two compared graphs. It also chooses an abstracted label from each of the two lat­tices and tries 
to apply the unification of the two chosen labels with respect to every pair of the combination of predicates 
and variables in the labels. If there are pairs of abstracted or ((c>= a ) or (xcO)) new predicate step 
1J 4 PI (c, Al and P2 (C, Z ) / (n<5)0r(95cn) or [p3 (c, a ) or p4 (x, 0)1 and (m z O) ~ step 1 step 
2~ , pll (n, 5)0r P12 (95, n) 3 PI (c) and P2 (c) and p13 (IIS,O) or [p3 (c)or p4 (x)] , -----J step 
2 step 3 ~ ,.­ b pll (n) or P12 (n) 2 D1 (c) and D2 (c) or .D5 (c. x) . and D13 (m) step 3 + MV:(c, nt, 
{x, m) + skp 3 1 P6 (c)or P5 (c,x) ~ pll (n) or p14 (n, m) J step 3 step 3 ~ 0 p7(c,x) * * p15(n,m) match 
ML: p~[c)= P1l (n):{!,(c>= N) and (C <= z) , (n < 5Y t p5 (c,x) =p14 (n, m): { (c >= a ) or (x < O) , 
(95 < n) and (m> 0) 1 Figure 4: Abstracting and matching labels labels in which the unification is successful, 
the procedure chooses a pair of the unified labels either of which belongs to the highest rank and stores 
pairs of predicate and variable names in the chosen labels. These pairs are used to coor­dinate labels 
that correspond to the predicates and variables after the exchange of codes. In the procedure, abstracted 
label matching fails if there is no pair of unified labels. For example, in Figure 4, two abstracted 
labels are equal at rank Oand rank 1, but fail at rank 2 or higher and at unequal ranks because the number 
of predicates or variables in the labels is not equal. The procedure chooses a pair of the labels at 
the highest rank 1, and stores the pair of labels (predicates) M,c and the pair of variable names k.fv 
in Figure 4. This procedure can absorb differences in variable names, predicate names (relational operators, 
assignments, input statements, and output statements), sorts of logical opera­tors, and scales of terms 
(the number of logical operators in a term), but it is sensitive to the number of variables in the compared 
labels, because pairs of variables at one pair of the corresponding nodes are consistent with pairs of 
variables at other pairs of nodes in abstracted labeled graph matching. 3.4 Exchangeable Slices The 
mechanism uses exchangeable slices to record or broad­cast modification histories. Exchangeable slices 
defined by Definitions 1, 2, and 3 are as follows: Definition 5 Complements for pre-and post-modified 
bounded slices SP and SQ are denoted by S; and S;, and a set of pairs of complements that are equivalent 
in labeled graph matching is denoted by U* = {(S>i, S~j ) IS~i s S~j }. (SP, SQ) is a pair of exchangeable 
slices, if all of the following hold: 1) s; and S~ are equivalent ((S;, S~) E U*). 2) Neither S; nor 
S; are empty (S; # @A SG # 0). 3) S; is not included in every pre-moditied complement s~, @S}i(S~ @ S;i 
A (S~i> s~j) E ~ )).   4 Changing Algorithm This section shows an algorithm and supplementary proce­dures 
for achieving Cde and Cex. 4.1 Basic Algorithm A basic algorithm ActiveComponent is shown in Figure 5. 
Each active component runs separately and never re-senses the same requirements or environments during 
the period of changing for one requirement. The basic algorithm mainly consists of three phases, which 
are explained in detail below. (1) When sensing user requirements (Figure 5[ 1]), an active component 
decomposes its code by bounded program slicing and extracts new source codes by Cde (Figure 5[2] [3]). 
Then it broadcasts its modification history (SP, SQ) and FPQ in its existing library (Figure 5[4][5]). 
 (2) When sensing modified code Q (Figure 5[6]), an active component derives all source codes described 
in its change rule (Figure 5[7]). If it derives P, which is an original source code of Q, it specifies 
the difference between P and Q and records this difference in its change rule (Figure 5[8] [10]). (3) 
When sensing broadcast modification histories of other active components (Figure 5[ 11]), an active component 
ex­changes part of its code with codes in the sensed modification histories and generates new source 
codes by internalizing the past modifications of others in Cex (Figure 5[12][13]).  4.2 Procedure for 
Decomposing A procedure decompose in Figure 6 decomposes codes of ac­tive components in Cole. The procedure 
compares each key­word in its change rule with a user requirement and detects a keyword keyword that 
includes a string Req(Figure 6[1][2]). It obtains slicing criteria that correspond to the detected key­words 
from the change rule and applies bounded program slicing based on the criteria to its code (Figure 6[3][4]). 
It checks whether a source code S includes the core in its change rule and appends only source codes 
that passed through the check to the set Cde (Figure 6[5][6]). 4.3 Procedure for Recording A procedure 
record in Figure 7 specifies the difference be­tween source codes before and after user modification, 
and records modification histories in the recording phase of Cez. P is an original source code and Q 
is the modified one. The procedure derives slices Sp and SQ in Definition 1 and complements S&#38; and 
S~ in Definition 2 (Figure 7[ l]). If S; or S~ includes edges between null-nodes, these comple­ments 
are not equivalent. Moreover, these edges are abso­lutely included in the modified codes and are irrelevant 
to the non-modified codes. Therefore, the procedure reduces S; and S~ before labeled graph matching by 
removing edges between null-nodes and gathering null-nodes at one point so as not to destroy the dependencies 
between non-null-nodes algorithm ActiveComponent declare Cole, Cex: sets of new source codes (patterns); 
Req: a keyword given by users (a string); P, Q: source codes; FPQ: a set of node pairs; (5 P, SQ): a 
pair of exchangeable slices; H: a set of tuples of exchangeable slices and node pairs; begin do //an 
active component is continuously running  [1] if-a Req then // determineschanging patterns by Cd. [2] 
Cde := deeompose(Req); [3] generates new source codes in Cole; [4] for each (SP, SQ ) and its FPQ in 
tbe change role do [5] broadcasts the (SP, SQ) and FPQ; od [6] etae if -that P is modified into Q then 
// derives all source codes describedin the change role [7] Cde := decompose( al 1 ); [8] if P E Cde 
then // specifies the modification between P and Q [9] H := record(P, Q); [10] a(sp, sQ)SrSd FpQOf HirI 
tfEChSIl&#38;SUk;6fi [11] ekif Wti(sp, sQ) aod FpQthen // determines changing patterns by Cez [12] Cez 
:= exchangc(Cde, Sp, SQ, FPQ); [13] generates new source codes in Cez; E6 Od end /i rrnderfinesindicate 
the actions described in Section 2.1 Figure 5: Basic algorithm procedure decompose(Req) returns Cde 
declare Req, ke~word: strings; Cole: a w of source codes; S: a source code; nu, tq: nodes; v: a variable 
set; -  Cde :=0; [1] for eachkeyword c { keywordsin the change rule} do // detects a vafid keyword 
for a user requirement [2] if Req is a substring of keyword or Req is all then // obtains a slicing criterion 
that corresponds to keyword // and applies bounded program slicing to the code [3] (n=, nl, v) := slicing_$riteria(keyword); 
[4] S := a source code of S(nW, rq, v); [5] if the core in the change rule~ S then [6] Cde:=Cde U{ S}; 
fi tied return (Cole); end Figure 6: Procedure for decomposing (Figure 7[2]). Next it compares the reduced 
complements S; and S~ and finds a set of node pairs FC between these complements (Figure 7[3]). If SF 
and S~ are equivalent by labeled graph matching in Definition 3, (Sp, SQ ) is a candidate for a pair 
of exchangeable slices. Then it selects a pair of exchangeable slices (SP, SQ) that satisfy Definition 
5 among the candidates (Figure 7[4]). Moreover, it finds a set of node pairs F, in (SP, SQ) by labeled 
graph matching for subgraphs of slice SA included in SP and SB included in SQ (Hgure 7[5]). It deducesa 
set of node pairs F~ in (Sp, SQ) from nodes in F. and Fs, and dependence edges between these nodes (Figure 
7[6]). It returns sets of tuples of slices SP and SQ and node pairs FPQ (Figure 7[7]-[9]) and an active 
component records the set If in its change rule. Using procedure mcord(P, Q ) returns H declare F ,Q: 
source codes; GP, GQ: PDGs; SP, SQ: slices; S, U, H: sets of tuples of slices and node pairs; SCP, SCQ: 
sets of slice and complement pairs; ~c, F,, Fd, FPQ: sets of node pairs; F: a family of F= or F,; St, 
S~, S; , S~ : complements; V: a set of variable pairs; match: boolean of equivalence; begin // derives 
sets of sliceandcomplementpairs Gp :. PDGof P; GQ :. PDGof Q;  [1] SC p := slicing; SCQ := slicing(G~ 
); u:= 0; for each (SP, S~) E SCP do for each (SQ, S~) E SCQ do // reduces complements by removing edges 
between null-nodes // and gathering null-nodes at one point [2] St := reduce(S~); S~ := reduce(S~); 
// non-abstractedlabeledgraphmatching [3] (match, F,V) := matching(S~ , S~ , NO); if match. SUCCESS 
then foreach FcEFdo U =UU{(Sp, SQ, Fe)}; odfi Odod // selects exchangeable stices among U by Definition5 
 [4] S:= { (SP, SQ, F =)c U [SP and SQ areexcharrgeableslices}; H:=O for each (SP, SQ, FC) 6 Sdo // 
finds pairsof nodes in (Sp, SQ) [5] F:= subgraph(Sp , SQ); for eachFSE F do // deduces pairs of nodes 
in (SP, SQ) from FcandFs  [6] Fd := dedue@Fc, F., GP, GQ); [7] FPQ :=F, UFd; [8] H:=l#U { (SP, SQ, FPQ) 
};od [9] ~tum (If); end Figure 7: Procedure for recording bounded slices and complements in labeled 
graph matching to specify many pairs of exchangeable slices that include user modifications and to find 
many pairs of corresponding nodes between the specified slices is a feature (improvement 1) of our algorithm. 
  4.4 Procedure for Exchanging A procedure exchange in Figure 8 partially exchanges codes of active 
components with broadcast modification histories in the exchanging phase of Cex. TheprocedurederivesslicesSRinDefinition 
1(Figure8[1]), and compares SR with SP by abstracted labeled graph match­ing in Definition 4, and specifies 
a slice SR to be exchanged into SP (Figure 8[2]). Abstracting labels in labeled graph matching to specify 
many slices to be exchanged is a fea­ture (improvement 2) of our algorithm. If SR and Sp are equivalent, 
the procedure replaces several nodes in SR on GR with nodes in SP by using FRP and also replaces several 
nodes in SP on GR with nodes in SQ by using FPQ (Fig­ure 8[3]). Nodes that are in FRP but not in FPQ 
on GR1 are replaced with null-nodes after two replacement phases. The replaced nodes have original labels 
at pre-replaced nodes in GR. Next it combines SQ and GRI in a procedure combine procedure excharrge(Cde, 
SP, SQ, FPQ ) returns Cez declare Cde, Cez: sets of source codes; R, R : sourcecodes; Sp, SQ, SR: sti~; 
s;: a complement; SCR: a set of slice and complement pairs; N: a node set; V: a set of variable pairs; 
FRP, FPQ: sets of node pairs; F: a family of FRP; N,: sets of node pairs; GR, GR1, GR2, GR3, GR4: PDGs; 
7 .: a family of N.; match: boolean of equivalence; begin Ce2 :=0; for eachR E Cde do // derives a set 
of slim which maybe exchanged into SP [1] GR := PDG of R; SCR := Slichg(GR); for each (SR, S~) E SCR 
do // S; is not used // abstracted labeled graph matching  [2] (match, F, V) := I13iItd@(SR, SP, YES); 
if match . SUCCESS then for each FRP GF do // rep]~s .Odes in SR with nodes in either Sp or SQ [3] GRI 
:= EphXX(GR, FRP, FPQ); //N is a set of nodes to be deleted N :={P I(r, p) E FRP A (p, g) @-FPQ }; // 
combines SQ and the remainder SR of SR [4] (GR2, T. ) := combine(GRl, SQ, N); for each N, E T. do GR3 
:= a copy of GR2; //N, is a set of pairs (n E PD(p), m 6 successor(p)) // for node p to be deleted in 
N for each (n, m) 6 N, do // recomects corm-d dependence edges edge(GR3) := edge(GR3) U {rA -+ m}; od 
// inserts clef-order dependence edges // and classifies flow dependence edges [5] GR4 := inSeKt-Cl~Sify(GRj 
); // reconstitutes GR4 into a source code R [6] R := ReconstitutePmgram( GRd ); if R # FAILURE A core 
~ R then Cez:=Cez U{ R };fi Od Odfiodod return (Cez); end Figure 8: Procedure for exchanging (Figure 
8[4]). GR2 consists of the remainder S; of SR and part of SQ. The following explains the combine in detail. 
The procedure combine merges nodes and edges in SQ and GRl, and deletes edges whose source or destination 
is a null­node. If this procedure were to unconditionally delete these edges, however, some nodes could 
not be reached from the start node on the CFG. Therefore, the procedure reconnects control dependence 
edges to be deleted to other nodes in order that new edges do not affect original data dependencies on 
the combined PDG and that all nodes can be reached from the start node on its CFG. Reconnecting control 
dependence edges to make a success of integrating two PDGs even thought the edges lost the destination 
as a result of nodes being deleted is a feature (improvement 3) of our algorithm. Consider a control 
dependence graph (CDG) [5] that is made by extracting all nodes and control dependence edges from the 
combined PDG. A set of nodes that are on paths from the entry node to a node n in the CDG is denoted 
by ciom(n). A set of nodes that are on paths from a node n to nodes without outgoing edges in the CDG 
is denoted by pdom(n). The procedure combine computes sets of nodes Ill(m) and Pll(m) for a node m to 
be deleted by referring to dom(n) and pdom(rz). lD(m) and Pll(m) are defined as follows: lD(m) = {q Iq 
E dom(m) A q# m A q# null-node A ~3r(q E dom(r) AT E dom(m))} PD(m) = {q IpE ID(m) A q E pdom(p) A q 
is if-orwhile-node } Nodes in ID(m) are depended on by node m and can di­rectly reach m without going 
through other nodes. Nodes in PD(m) have the same dependence edges as nodes among lD(m). The procedure 
combine also determines a node to be reconnected instead of m according to PD(m) and the sort (either 
T (true) or F (false)) of a control dependence edge e whose source is node m. Tkke one node n among PD(m). 
Ifthesort ofe is T, n can be reconnected to m. If the sort of e is F and n is if-node, n can be reconnected 
to m. By using PD(m), the parts inconsistent with the non-exchanged part in the combined PDG are minimized. 
In the reconnection, the procedure replaces labels and variable names in SQ with non-abstracted labels 
and variable names in SR by using FRP detected when comparing SR and Sp by abstracted labeled graph matching. 
After reconnecting edges, the procedure deletes unnecessary edges connected to null-nodes. The procedure 
exchange reconstitutes the combined PDG into a source code by the algorithm ReconstituteProgram [3] (Figure 
8[5][6]). Before applying this algorithm to the com­bined PDG, clef-order dependence edges must be inserted 
into the PDG and flow dependence edges must be classified under loop-carried edges and loop-independent 
edges. How­ever, this insertion and classification depend on the context in which the nodes and edges 
are merged, so they are expensive to compute. To achieve the insertion and classification sim­ply, this 
procedure uses original PDGs, which are the slice SQ and the remainder .~R. The procedure inserts clef-order 
dependence edges in the original PDGs into the combined PDGs and projects the sorts of flow dependence 
edges in the original PDGs onto the edge in the combined PDGs. If the reconstitution is successful and 
the reconstituted source code includes the core, an active component generates the new source code R 
.   5 Examples This section shows examples of Cde and Cex with active components Histogram and TextFormat 
in Figure 9. 5.1 Example of Decomposing Both Histogram and TextFormat have a code and several criteria. 
The symbol + in criteria denotes the union of the set of nodes in a bounded slice and the set of additional 
nodes represented by node numbers. Neither Histogram nor TextFormat has a modification history. Suppose 
that a requirement count is given to the li­ ; 4 1[ Figure 9: Examples of active components brary. 
Histogram or TextFonnat extracts five or one new source codes by the procedure decompose in C de, respec­tively. 
These active components sensed the string count , applied bounded program slicing to their codes, and 
extracted the new source codes. In Figure 10, P is one of the source codes extracted from Histogram and 
R is a source code extracted from TextFonnat .  5.2 Example of Recording The following is what Histogram 
does by using the pro­cedure record. Suppose that P in Figure 10(a) is modified into source code Q in 
Figure 10(b) by a user. P counts the number of letters and numerals, and Q distinguishes between uppercase 
and lowercase letters in addition to the function of P. In Figure 10, the numbers to the left of statements 
in a source code are identifiers for nodes in its PDG. Statements with + have been modified by a user. 
To clearly understand this example, consider slices SP12 and SQ35 in Figures 10(a) and lo(b) derived 
by Histogram . Histogram reduces complements S~12 and S~35. Figure 11 shows S;,2 which indicates a non-modified 
code and its re­duced complement S&#38;12 . In this example, S~[2 and S~q~ are equivalent in labeled 
graph matching and SP 1z and SQ35 satisfy Definition 5, then (SPIZ, SQ35) is one pair of ex­changeable 
slices. SQ35 ) and a set of pairs of nodes (SP12, F, are shown in Figure 12. Histogram finds a set of 
node pairs F, by labeled graph matching between subgraphs which are slices with respect to variables 
ch and deduces a set of node pairs Fd from both F= and Fs. FS and Fd are also shown in Figure 12. Dotted 
nodes in Figure 12 indicate the differ­ence between SP1z and SQ35, which are affected by the user modification. 
Finally, Histogram records six modification histories including SQ35) and FP12Q35 = F. U Fd in (SP12, 
 P.o.edu.e H., t~9~.m C.V.. ch: char; u.L le::er S. Procedure HlsLogran_...>L_le:crs; var :h: char; procedure 
Text:. var c: char rmaL_cO.nL_rate: letter, d~git: ~nceger; letter, d~git: ~nteger; l~ne: ,nteger; ,umercase, 
lowercase: .nteger; blank, other: ~nteger; rate: real;.pl . ,[+ Dpercase := c: 4 ql+ lowercase := O 
rl ,2 ? ::.: E2Ezl r2 qb;,ch;o E!EEzEl . p3 read(chl ; . q4 r3 while ch .> ~OF do . q5 while ch 
.> EOF do r4 read(c); begin beg.n ,5 while .<> EOF do .P4 . ps if lch>=, A,) and (ch. =! 2,) * @+ if 
(ch>=,A,l and (ch<=,Z,) begin or Ich>. ,a, ) and (ch.. pzf) then uppercase :. uppercase , 1 16 lf C. 
CR the . ~7+ .P6 letter :. letter + 1; $ ,8+ else if (ch>.<a,) and (ch..<z,) then rl line := line + 
1; * q9+ lo ercase :. lowercase + 1; dl if (c= o,)or (c=TAB) then p7 if lch>. ,0,) and (ch.. 49,) then 
qlo if (ch>=,O,) and (ch<.,9,) then 1$ blank := blank + 1 P8 digit := cigit + 1; qll digit := dig~t + 
1; else .P9 read (ch) .q12 read (chl r!O others := others + 1; end; end; rl I read [C] *q13+ letter := 
uppercase + lowercase; end; PIO writeLn[letter) ; q14 writeLn [letter) ; r12 writeLn(linel ; q15+ writeLnlumercase) 
; rt3 writeLn (blank) : q16+ writeLn[lowercase) ; r14 writeLn (others) ; PII writeLn(diszit 1 q17 writeLnldi91t) 
,!5 rate := blank / line; +:modified statements end. end r16 wrlceLn (rate) , *:SP,2=; (DI,~lo, [l~tt~~)) 
*:~QJF~(ql,qi t, [kttIX}) end. *:Sm6zj(rl, r13, [blank)) (a) p (pm-modified) (b) Q (post-mcdfied) (c) 
R (to be exchanged) Figure 10: Source codes which are pre-modified, post-modified, and to be exchanged 
Figure 11: Reducing the PDG (s~12 + s~12 ) .k Ientrv --DI--. D1OI ~ Fc = { cdry,entry >,< p2, q3 >, c 
p7, q10 >,< P8, qll >,< plO, q14 > } F~={<p3, q4>, . { read(ch) , read(chy ) <fiqs>, ~~~~[ ch <> EOF 
, ch<> EOF t <p9,q12>} . { read(ch) 1, I read(ch) I Fd={<~l, a13>} I letter:= O . letter:= uorweae + 
10WrM,W I Figure 12: Pair of exchangeable slices (SP12, S~35) its change rule. 5.3 Example of Exchanging 
The following is what TextFormat does by using the pro­cedure exchange. Suppose that a requirement count 
is r9T . match . H Y) Q matchingnode$ FR36P1~ <r2, pk. { blank:= O , letter:= O ) <r4, p3> { read(c) 
, mad(ch) 1 cr5, IA> ( c <D EO~, ch<> EOF I L m .+ p5> { c = , ch>= A and chc= 2 }, I c . TAB , ch> 
a and c31<= z } <r% prb { blank := blank + 1 , letter := letter+ 1 } <rll, plb [ rad(c) , rad(eh) ] 
 nodes to be replaced in FR36P12and Fp,2Q35 r r2 + pl +-q13 r5--p4+q5 r8 --p5 --nult r4+p3--q4 rll -p9 
+ qt2 r9.-p6.-llilu Figure 13: Matched slices SP12 and SQ35 given to the library again. Histogram again 
changes five source codes including P by Cde and broadcasts its six pairs of exchangeable slices. TextFormat 
again changes R in Figure 1O(C)by Cde and senses the broadcast modification history that is both (Splz, 
SQ35) and # p(zQss. R counts the number of blanks (spaces and tabs), other characters, and total lines, 
and calculates the ratio of blanks for one line. To clearly understand this example, consider S~31j in 
Fig­ure 1O(C).SR36is the slice to be exchanged, because SR36is equivalent to pre-modified SP Iz in abstracted 
labeled graph matching. Figure 13 shows matched slices SR36and SP 1z, pairs of nodes and labels ML in 
F R36P12,and pairs of variable names Mv between SR36 and SP 12. TextFormat replaces several nodes in 
SR36on the PDG of R with nodes in SP12by using ~RMpI 2, and also replaces several nodes in SPIZ with 
SQ35 by using FP12Q36,as expressed in the bottom box shown 177 R: deleted node Figure 14: Combined 
PDG (SQ35 + ~~36) changeable dices Figure 15: Screen shot: example of Cex in Figure 13. Nodes p5 and 
p6 will be deleted because the nodes corresponding to p5 and p6 are not in FP12Q35. Next TextFonnat combines 
the replaced SQ3S and the remainder ~~3bof .5 ~31j.A combined PDG is shown in Figure 14. Dot­ted nodes 
were in SQ35 and appeared after the replacement. Nodes with broken lines were in ~R36and remain after 
the replacement. The bold lines denote the nodes and edges that were in SQ35 and merged into the combined 
PDG. In Fig­ure 14, conditional node q6 or q8 is a candidate node that the deleted edge e. = R +c(~) 
r10 reconnects to because of nodes in PD(R) and the sort of e, is F. Then TextFonnat reconnects the edges 
and reconstitutes the combined PDGs into source codes. Finally, TextFotmat automatically and dynamically 
generates twelve new source codes from R by Cez. Figure 15 shows a screen shot which contains His­togram 
with modification histories and a new source code pro~.m ..h. c race : var c: cb.ar; line,k.ank, others 
: integer; uppercase: ~r.teger; lowercase: Integer: rate: real; be~in 11 r3 + !44  + ql  + q2  + q5 
 Iii rl  + q6  + ql  rlo + q8 + q9  +q12 lke :. 1; others :. C; read(c) ; uppercase :. O; lowercase 
:. O; while c c> EOF do beg~n ifc =CR then line := llne + 1; ifc. ,, then uppercase :. uppercase + 1 
else begin others := others + 1; if c = TAB then  lowercase := lowercase + 1 end; read(c) end; r12 
writeLn (line) ; +q13 blank != uppercase + lowercase; r{ 3 writeLn [blank) ; d4 writeLn [others ) ; rl 
5 rate :. blank / line; r16 writeLn (rate] . d d (a) R; (reconnect to q6) pr.9.. m =ou.t-rate 2; var 
c: char; llne,blaak,~thers: integer; uppercase: integer; lowercase: integer; rare: real; bmin 11 r3 + 
q4  + ql  + q2  + q5  1% rl  + q6  + q7  + q8  + 49  r10 +q12 r12 +q13 r13 rl 4 r15 rlb lhe 
:= 1; others :. O; read(c) ; uppercase : = O; lowercase : = O; while c .. E9F do begin ifc =CR the line 
:= line . 1: ifc. ,, then upeer.ase := uppercase + 1 else ,fc . TAB then lowercase:= lowercase + 1 else 
others := others + 1; read(c) end; writeti llinel ; blank := uppercase + lowercase writeLn (blank) : 
writeLn (others) ; rate := blank / line; wr. teLn (rate] II end. (b) R> (r&#38;onnect to q8) Figure 
16: Source codes that are generated by Cex  by TextFotmat . Two of the new source codes R! and R; from 
R are shown in Figure 16, when reconnecting q 10 to q6 or q8. Statements with + are automatically modified 
by TextFomntzt . R{ distinguishes between spaces and tabs, counts the number of spaces, tabs, characters 
other than spaces, and total lines, and calculates the ratio of blanks for one line. Rj distinguishes 
between spaces and tabs, counts the number of spaces, tabs, characters other than spaces and tabs, and 
total lines, and calculates the ratio of blanks for one line. R{ and Rj are different in terms of the 
values of variable others after exe­cution. The values of variable line in R, R;, and R; are equal after 
execution, that is, TextFonnat preserves the function of counting the number of total lines while changing 
its code. Sequences that produce the values of variable blank in R, Rj, and R! indicate that the modification 
history between P and Q, that is the difference in distinguishing between up­percase and lowercase letters, 
is reflected in R; and Rj as distinguishing between spaces and tabs. The numbers of slice pairs and new 
source codes in this ex­ample are listed in Table 1. Histogram found six pairs of exchangeable slices 
by comparing two complements 1120 (= 20 x 56) times and broadcast these pairs into its exist­ing library. 
TextForma[ sensed the broadcast modification histories and generated twelve new source codes from R by 
comparing two slices 306 (=6 x 51) times. The total number of source codes generated from R by TextFormat 
in Cex is the sum of reconnected nodes for each combined PDG. The functions of P, Q,R and the new source 
codes from R are listed in Table 2. The new source codes are different in terms of the initial values 
of variables uppercase and lowercase, and the displayed value of variable blank. Slices t Source codes 
] Hi~togram ITextFormat new source codes bv Cde 5 1 pre-moditied slices (SPi, S~i ) ~ Table 1: Number 
of derived slice pairs and generated new source codes Functions of source codes counts letters and numerals 
counts uppercase letters, lowercase letters, and numerals (distinguishingbetween uppercaseand lowercase 
letters) counts blanks (spaces and tabs), other characters, and lines, and calculates the ratio of blanks 
distinguishesbetween spaces and tabs, counts spaces, tabs, and characters other than spaces, (... same 
as R) distinguishesbetween spaces and tabs, counts spaces, tabs, and characters other than spaces and 
tabs, (... same as R) requiresthe initiafvalueof uppercase in R{ requires the initial value of uppercase 
in R! requires the initial values of uppercase and lowercase in R; requires the initial values of uppercase 
and lowercase in R; displays the initial value of Mank in R{ displaystheinitialvalueof blankin R! requiresthe 
initialvalueof uppercase, and displaysthe initialvalueof blank in R; requiresthe initiafvalueof uppercase, 
and displays the initial value of blank in R; requiresthe initialvaluesof uppercase and lowercase, and 
displays the initial value of blank in R; requires the initial vahtes of uppercase and lowercase, and 
displays the initiat vahse of blank in R: Table 2: Functions of new source codes  6 Related Work This 
section compares our mechanism with conventional methods for automatically modifying programs. It also 
ex­plains that conventional program integration algorithms are insufficient for achieving our mechanism 
and improvements in our algorithm. 6.1 Program Modification by Using Cases The TA system [15] automatically 
modifies programs by us­ing a case-based approach to learning programming like the mechanism of Cez. 
TA finds a program with a similar speci­fication to a user s specification by analogical skill, specifies 
incorrect code fragments, and stores a patch which consists of a correct fragment modified by a user 
and the incorrect fragment. When another specification is given, TA discovers patches that can be applied 
and generatesa new program. However, TA does not strictly specify codes which are af­fected by user modified 
fragments or replaced fragments. Therefore, generated programs cannot guarantee the func­ tions of modified 
codes or non-modified codes. Moreover, TA may yield many programs irrelevant to the original pro­gram 
by applying inadequate patches to the original program. Our proposed mechanism is implemented by a program 
inte­gration algorithm based on dependencies in programs. This algorithm analyzes dependencies for statements 
that are mod­ified by users or are to be replaced, and strictly specifies modified codes and codes to 
be exchanged. Therefore, the algorithm can guarantee that a new integrated source code preserves part 
of the function of the original source codes and can reduce the number of source codes which incorrectly 
reflect user modifications. 6.2 Program Integration Algorithms The algorithms HPR [7], YHR [17],and 
PDI [12] have been proposed for semantics-based program integration. These algorithms can automatically 
integrate two programs which have been independently modified from an original program and guarantee 
that variant codes in the two modified programs are integrated consistently into the original program. 
The algorithm we require to achieve Cez must be able to integrate two programs derived from different 
programs with different structures or labels, since active components ex­change their codes with codes 
of others in Cex. However, both HPR and PDI can be applied to two programs only when the programs are 
derived from the same program and have common nodes in the original program. Therefore, both HPR and 
YHR are insufficient for integrating two programs that do not have common nodes. Moreover, the algorithm 
for Cez must be able to generate a variety of source codes, although an integrated program is partially 
inconsistent with the tar­get programs to be integrated, since the active components change new source 
codes to meet many kinds of user re­quirements. However, HPR, YHR, and PDI strictly limit the non-interfering 
programs which can be integrated by them, since they never permit the integrated programs to be incon­sistent 
with the original programs. Thus, these algorithms are unsuitable for achieving Cex. We developed an 
algorithm which has three improvements described in Section 4 to overcome the restrictions in the conventional 
algorithms, This algorithm can be applied to many kinds of codes and can guarantee that modified codes 
in an integrated program are consistent with the target programs. Therefore, active components can generate 
a variety of new and meaningful source codes. 7 Conclusions This paper has described active components 
with a new mechanism for automatically and dynamically changing their codes and an algorithm that achieves 
the mechanism. The mechanism is achieved by an enhanced program integration algorithm based on bounded 
program slicing and abstracted labeled graph matching. It provides two kinds of changes by decomposing 
their codes and partially exchanging their codes with codes in modification histories which reflect the 
characteristics of their existing libraries. Active components are quite different from conventional 
components, since they provide two advantages: Active components can automatically generate new source 
codes which are likely to meet user requirements without any modification, even if users require compo­nents 
which do not exist in user libraries. . Active components can dynamically generate new source codes that 
are affected by past frequent modi­fications and will be often reused in user libraries. Because of 
these advantages, users do not need to modify codes of active components to create a variety of programs. 
Moreover, users do not need to prepare all components that might be reused in user libraries, although 
the characteristics of the libraries are unspecified. For example, in Section 5, TextFonnat imitates 
the same modification for Histogram as distinguishing between uppercase and lowercase letters and generates 
twelve new source codes in Table 2 that were not prepared in the user library, even if the users do not 
apply the same modification to TextFotmat . The users can reuse the new source codes without any modification. 
We believe this work will help solve some of the problems re­lated to source-code reuse and hope that 
it will provide a basis for further studies on software evolution. However, there are several remaining 
issues in the proposed mechanism. If the mechanism specifies too small and too general dif­ferences of 
codes (e.g., the modification of i : = i + 1 into i := i l ), it generates a large number of source codes 
that may be irrelevant to user requirements. If a lot of new source codes are being generated, how do 
programmers retrieve the required one among them or how do programmers verify that the selected source 
codes are what they desire? Can component producers write keywords that correctly describe the functions 
of source codes extracted from ac­tive components or that are useful for programmers to retrieve the 
source codes? Moreover, can the program­mers state what funct]ons they desire by using the right keywords? 
Our algorithm leaves room for the improvement of the computational cost, since we developed the algorithm 
in order to mainly confirm that the mechanism is ex­ecutable and we ignored its space or time complexity. 
Particularly, the algorithm for matching graphs with ab­stracted labels should be refined. We plan to 
provide new methods for writing user require­ments with logical expressions. These methods will let users 
can give active components requirements that are more exact and complex than keywords so that source 
codes irrelevant to the requirements will not be generated or so that suitable source codes for the requirements 
will be automatically se­lected. In addition to the above methods, we will introduce a method for representing 
the function of slices with logical expressions to clarify the function of generated source codes and 
to select suitable source codes for user requirements. Moreover, we have been refining the algorithm 
and embed­ding the methods for treating programming language with multi-procedures and pointers into 
our mechanism to make practical experiments with active components. Acknowledgments We would like to 
thank Dr. Atsuhiro Goto, Dr. Naohisa Taka­hashi, and Mr. Hideaki Suzuki for helpful discussions. We thank 
the reviewers for their helpful comments. References <RefA>[1] A. V. Aho, R. Sethi, and J. D, Unman. Compilers: 
Principles, Techniques, and Tools. Addison-Wesley, 1986. [2] G. Arango. Domain analysis methods. In Software 
l?eusabil­ity, pages 1749. Ellis Horwood, 1994. [3] T. Bafl, S, Horwitz, and T. Reps. Correctness of 
an algo­rithm for reconstituting a program from a dependence graph. Technical Report TR-947, Computer 
Sciences Dept. Univ. of Wisconsin, Madison, WI, July 1990. [4] T. Biggerstaff and C. Richter. Reusability 
framework, as­sessment, and directions. IEEE Software, 4(2):4149, March 1987. [5] J. Ferrante, K. J. 
Ottenstein, and J. D. Warren. The program dependence graph and its use in optimization. ACM Trarrs­actions 
on Programming Lzmguages and Systems, 9(3):319­349, July 1987. [6] M. R, Genesereth and S, P. Ketchpel, 
Software agents. Com­munications of the ACM, 37(7):48-53,147, July 1994. [7] S. Horwitz, J, Prins, and 
T. Reps. Integrating noninterfering versions of programs. ACM Transactions on Programming Lunguages and 
Sysrems, 11(3):345-387, July 1989. [8] S. Horwitz and T. Reps. Efficient comparison of program slices. 
Acts Informatica, 28:713-732, June 1991, [9] C. W. Krueger. Software reuse. ACM Computing Surveys, 24(2):131-183, 
June 1992. [10] K.MaruyamaandN.Takahashi.Extractingreusablesoftware componentsby using boundedprogram 
slicing. Transaction on Information Processing Society of Japan, 37(4):520-535, April 1996. (in Japanese). 
 [11] J. M. Neighbors. An assessment of reuse technology after ten years. Proceedings of the Third International 
Conference on So@are Reuse, pages 6-13, 1994. [12] S. Nishimura. Pdi algorithm: An atgorithm for program 
differ­ence integration, Journal of Computer Soflware, 12(5):85 99, September 1995. (in Japanese). [13] 
R. Prieto-Dhz. Status Report: Software Reusability. IEEE Software, pages 61-66, May 1993. [14] M. Weiser. 
Program slicing. IEEE Transactions on Software Engineering, 10(4):352-357, July 1984. [15] R. S. Williams. 
Learning to Program by Examining and Mod­if ying Cases. Proceedings of Case-Bared Reasoning Work­shop, 
pages 463474, March 1988. [16] M. Wooldridge and N. R, Jennings. Agents theories, archi­tectures, and 
languages: A survey. Lzcture Notes in Artificial Inteiigence, 890:1-39, 1995, [17] W. Yang. A new algorithm 
for semantics-based program integration. Technical Report TR-962, Computer Sciences Dept. Univ. of Wisconsin, 
Madison, WI, August 1990.  Software Reuse: Joint Session with ICSE</RefA> 97  
			

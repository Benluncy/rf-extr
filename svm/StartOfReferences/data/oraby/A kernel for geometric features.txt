
 A kernel for geometric features Alan Middleditch and Chris Keade Centre for Geometric Modelling and 
Design Brunei University, Uxbridge UBS 3PH UK  Abstract This paper provides a rationale for its abstract 
data definitions of geometric features. These definitions are used as the basis of a suite of functions 
to support feature modelling. It assumes that implementations of the proposed functions will make use 
of a solid modelling kernel that supports objects with a disjoint cellular structure and persistent cell 
identifiers. It is intended that most of the functions required for the manipulation of features can 
be provided by overloaded kernel functions; new functions are necessary only to provide feature specific 
operations. Unlike most features in the literature, the features of this paper are not design features, 
manufacturing features or features for any other specific application. They are geometric structures 
that support such applications. Thus, the disjoint cellular structure of a modern solid modelling kernel 
is enhanced to include a hierarchy of geometrically overlapping features. A feature at any node in the 
hierarchy is defined in terms of instances of multiple sub-features combined using any object construction 
function of the kernel. Such instancing allows multiple versions of any feature to be modified simultaneously 
via the master. Introduction The software system described in this paper is intended to support applications 
traditionally supported by computer aided design systems. In this context some rationale is provided 
for the need to model hierarchies of geometric objects, but such feature hierarchies are also useful 
for modelling human and other biological forms. This paper does not address the functions required in 
a solid modelling kernel, but assumes that feature functionality would be implemented in terms of such 
kernel functions. Most of the required feature functions can be provided by overloaded kernel functions, 
new functions being necessary only for feature specific operations. Thus, the paper assumes the existence 
of a modern solid modelling kernel that supports objects with the disjoint cellular structure. Such a 
kernel is exemplified by (an early draft of) the Djinn interface definition [Armstrong97]. Two questions 
have not been adequately resolved in the literature: - What is a feature? What is a particular kind of 
feature such as a slot? From the viewpoint of this paper, a feature is a data structure that represents 
the structure of a geometric object. Like [Chen95:1, Chen95:2 and RossignacBO], this paper is concerned 
only with the generic structure of such objects and operations thereon to support any application view 
of a feature. Thus, unlike most features in the literature (see [Salomons93] for a review), it is not 
concerned with the nature of a form-feature, nor with the nature of particular form-features. The features 
of this paper are not design features, manufacturing features or features for any other specific purpose. 
Such considerations, together with the management of multiple views of the same object in terms of different 
feature decompositions, are the domain of users of the proposed functionality. This paper is concerned 
with multiple instances of a single feature, but not with instances (e.g. slots) of a (form) feature 
class. From the viewpoint of this paper, a feature instance is merely a geometric transformation of another 
feature. Instances of the same feature thus form an equivalence class defined by the admissible transformations. 
A typical form-feature may be defined in terms of such an equivalence class. Any object that can be constructed 
using the underlying modeller may be defied in terms of the features of this paper. In principle, any 
modeller would suffice as an alternative, but the proposed feature functionality could not be implemented 
in terms of many current solid modelling kernels. Requirements Features Mechanical components and other 
objects are typically designed in terms of form-features. Such features embody both geometric and non-geometric 
data and are specific to the application. For example, they capture design function or production process. 
Form-features may also be designed in terms of other features, thus creating a feature hierarchy. For 
example, the bearing of figure 1 may be designed as the combination of a cylindrical tube (feature), 
a .fillet (feature) and a flange (feature), the latter consisting of a circular plate (feature) and a 
circle of bolt hole (features). Figure 1 Figure 1 shows that form-features may be positive or negative. 
Negative features inherently overlap positive features, but two positive or two negative features may 
also overlap. For example, protrusions on an engine block, each designed for fixing a specific component, 
or the slots of figure 2. A building or mechanical assembly consists of a set of physically disjoint 
components, each of which also may consist of disjoint components. Adjacent components of such assemblies 
often have nominal bounding geometry with the same co-ordinate values. Such common geometry must have 
distinct representations because the components may have different surface properties. Thus, a feature 
hierarchy consisting of distinct features which may overlap is also necessary to model assemblies and 
sub-assemblies. A process plan for component manufacture by machining consists of a sequence of machining 
operations, each removing some material from a work-piece. This requires the final component to be modelled 
as the initial work-piece together with a set of voids. These voids are features of an object that define 
regions outside that object. Such manufacturing features also may overlap, e.g. machine tool fixtures 
often have orthogonal T-slots that cross each other. Both assemblies and individual components may have 
distinct features that differ only in their location and orientation. If it is appropriate for design 
changes to effect all such features, they must be considered to be instances of the same feature. Thus, 
a feature is defined in its own co-ordinate system and each instance is associated with the relationship 
between that system and the co- ordinate system of the feature of which it forms a part. Modern parametric 
and feature based CAD systems allow relatively few parameters to define a large range of components. 
Unfortunately, the parameters that define the appropriate part family may not be known at the design 
stage. Therefore, it must be possible to subsequently instate a dimension as a parameter without affecting 
other parameters, i.e. to extend a part family. This facility is not provided by most current CAD systems. 
To summarise: CAD systems should support form-features that constitute a hierarchy of overlapping feature 
instances specified in terms of a relatively small extendible set of parameters. Constraints In preference 
to co-ordinates, modern computer aided design systems define objects in terms of dimensions and other 
geometric relationships such as angles, distances, parallelism, orthogonality, incidence, and tangency. 
Such systems solve a set of equations that capture these properties and the solution provides parameters 
to define object geometry. Variations of an object are produced by changing one or more parameters, re-solving 
the equations and modifying the geometry to reflect the new parameters. Constraint based design imposes 
relationships between features, such as the distance between holes. Sets of such relationships often 
relate a feature to more than one other feature. This often leads to the deduction that it should be 
possible for a feature to have more than one parent and thus, that a hierarchy is an inappropriate structure 
for feature based design. In contrast, this paper suggests that it is only the constraint relationships 
for which a strict hierarchy is inadequate and for which a general graph is necessary. Irrespective of 
the constraints between them, features remain hierarchical because a feature is physically composed of 
its sub-features. R C S  4 b) H H S S 04 40 R c) R 4 Figure 2 For example, a cuboid B with two intersecting 
slots R and S and a hole H in the bottom of their region of intersection (fig. 2a) may be considered 
as four sub-features of the same parent, i.e. block B less the union of two slots R and S and hole H 
(fig. 2~). Alternatively it may be treated as the block combined with a single negative feature consisting 
of the union of three sub-features (fig. 2d). In contrast, relative locations of the features can be 
defined by constraints that form a cyclic graph (fig. 2b): arcs a, b and d represent incidence relations 
between the hole centre H and the slot centre lines R and S and the block centre B respectively, and 
c represents an orthogonal@ relation between the slot centre lines. To summarise: Composite features 
in a feature hierarchy may be defined by a sequence of construction operations and may be represented 
by an acyclic graph, whist design constraint relationships usually require a cyclic graph for their representation. 
 Background Modern CAD systems are deficient due to the lack of:- * well defied facilities for object 
modification, l facilities for the design of parameterised object families, and l robust modification 
facilities. The fist two deficiencies are different facets of the same problem because well defined 
equivalence class of objects. modification functions define an Three kinds of geometric following examples:- 
modification are exemplif ied by the translation and orientation (point mappings), tweaking (e.g. vertex 
or face translation) and blending, and hole diameter modification (changes to intrinsic geometric parameters). 
The fist kind of modification is inherently well-defined, but the second may have ill-defined consequences. 
The third may behave in either way; for example, the radius of a sphere may be changed directly or by 
changing a scale factor. Modifications of the third kind involve 3D-object faces or 2D- edges whose shape 
is defined by relatively few geometric parameters. Unfortunately, the effect of parameter modification 
is ill-defined because those parameters do not necessarily define location or extent. For example, a 
change in the radius of the top circular edge of figure 3 may or may not be associated with changes to 
the bottom edge on the same circle. If the enlarged edge extends beyond originally adjacent edges, it 
may or may not be truncated at those edge boundaries and such truncation is ill- defined! Figure 3 Also, 
changes to the bounding surfaces (edges) of a 3D-object (2D-object) may necessitate changes to its internal 
cellular structure, but such changes are also ill-defied. For example, the object with the enlarged circular 
edge in figure 3b admits all the dotted lines as candidates for internal structure. The ambiguities of 
figure 3 are absent from the set-theoretic (CSG) approach to geometric modelling, but most current CAD 
systems are based on boundary representations (B-Reps). Unfortunately the ambiguities also arise in representation 
independent modellers such as Djinn because no geometric structure is exposed. The difficulty of providing 
well-defined semantics for operations such as tweaking and edge blending leads to limited tweaking in 
both [Armstrong971 and [Rossignac90] and to the latter s use of ad hoc corrective volumes for feature 
tweaking. Modern CAD systems provide more extensive facilities but they suffer from ill- defined semantics 
and thus unexpected results [Rossignac90, Hoffmann93, Chen95:l and Chen95:2]. What should happen to a 
face of a plane faced polyhedron when a single vertex is moved? Unfortunately, any parametric family 
based on ill-defined modification functions is actually defined by the system implementation and subsequent 
versions may produce different results [Shapiro95]. Although most current CAD systems are based on boundary 
representations of solid objects, it is well known that the successful manipulation of such representations 
is very sensitive to computation errors. This problem is aggravated by the application of variational 
techniques (i.e. constraints) directly to the boundary representation because there is no human operator 
to find an alternative to a construction that fails. Such problems are far less severe in two dimensions. 
The modification of a vertex of a straight edged polygon can be well defined in a way that conforms with 
the intuition that the edges remain straight. Reasonable definitions also are possible for curved edged 
polygons. This leads to more extensive variational techniques in 2D than in 3D. e.g. Pro-Engineer from 
Parametric Technology Inc.. Most, if not all, current CAD systems achieve object modification by rebuilding 
the object after editing a construction history. Part families are thus produced by controlling history 
edits in terms of small finite sets of parameters. This approach is inappropriate because conslruction 
history is not part of a design, and a major problem arises because related geometric elements in different 
instances of a family inevitably acquire a different identifier [Kripac94]. This is a significant problem 
for applications that use such identifiers in their own data structures. Set-theoretic (CSG) representations 
are inherently robust but applications are concerned with the faces and edges absent from such representations. 
They are also inherently parametric because primitive objects such as cubes are specified by their size. 
Unfortunately such primitive parameters define families of objects that would not intuitively be associated 
with each other and cannot be used to define some natural families [Shapiro95]. Well defined object modification 
semantics prohibit modifications defied in terms of boundaries alone. This leads [Rossignac90, Chen95:l 
and Chen95:2] to conclude that robust modification requires set-operations. The observation that boundaries 
are needed for interaction, constraint definition and tweaking, but solids must be modified, leads to 
the growing consensus for hybrid models (e.g. [Gomes91] and references therein). This is interpreted 
by [Shapiro951 as a requirement for the ability to edit consistent set-theoretic and boundary representations. 
Paraphrasing [Shapiro95], two problems remain to be solved before this can be achieved:- * Given a set 
of parameters that define a set-theoretic representation, fiid a subset of solids (i.e. parameter ranges) 
with similar boundaries. - Given a set of relationships between boundary elements that define a boundary 
representation, find a subset of solids with the same set-theoretic representation. These are very difficult 
problems related to the conversions between set-theoretic and boundary representations required by true 
hybrid modellers. Proposed approach The hybrid model viewpoint derives from known and predicted algorithms. 
In contrast, this paper starts from the premise that useful object modification operations with well 
defined semantics exist. It is less concerned with modification semantics than the definition of a part 
in terms of any well defined modification operations. The integrity problem thus becomes a problem for 
the modelling kernel. The remainder of this section and the next section are concerned with l the properties 
of a solid modelling kernel required for feature modelling, and l the requirements for a feature modeller 
to support constraint based design. Object modification Well defined object modification semantics demand 
modification definitions in terms of object abstractions that are independent of representation. Such 
modifications are exemplified by those of the Djinn kernel interface [Armstrong97]. They may or may not 
require dual set-theoretic/boundary representation representations and conversions between them, but 
that is an implementation issue. Since well defined object modification semantics prohibit modifications 
defined in terms of boundaries alone, an object modification cannot directly reflect a modification of 
its boundary. However, modification parameters can be derived from relationships between boundary elements. 
This approach provides appropriate tools for variational design without sacrificing well defined semantics 
that enable the construction of robust implementations. Part families Since part families may be defined 
in terms of boundary relationships, boundary elements must have identifiers that are consistent across 
such a family. This implies that identifiers must persist through the modifications that convert one 
family member into another. Previous attempts to solve this problem try to match boundary elements in 
models before and after modification [Kripac94, Chen95:2]. This approach is necessarily ad hoc , may 
provide ambiguous results and may fail unpredictably. Such techniques are a consequence of deficiencies 
in underlying modellers such as ACIS. They are an unnecessary adjunct to Djinn modifications [Armstrong971 
that allow applications subsequent access to all identifier dependencies. For example, the identifier 
of a face that is sub-divided can be subsequently accessed via the sub-face identifiers. Figure 4 Even 
with correct correspondence between identifiers in successive models, object modifications that cause 
topological changes to the boundary cause problems when geometry is specified in terms of those boundaries. 
For example, consider a problem of [Chen95:2] where a chamfer is made on one segment of an edge sub-divided 
by a slot (fig. 4a). When the slot parameters change, the edge is reconnected and the chamfer is applied 
to the entire edge (fig. 4b). If the original slot parameters are subsequently re-instated, both segments 
are chamfered (fig. 4~); original configuration with those parameters is not re-instated! In the proposed 
approach, the desired behaviour is explicitly specified in terms of feature parameters. Thus, the chamfer 
feature extent and position is defined in terms of block and slot faces and a conditional constraint 
that depends on the intersection of the edge of the block feature with the slot feature. Unexpected behaviour 
on object modification is avoided because all constraints are applied between boundary elements of features 
at the bottom of the hierarchy. In contrast [Chen95:2] defines features with respect to sub-divided or 
merged boundary elements and ambiguities must be resolved by geometric compilation . Evolving parameterisation 
and part families are accommodated by specifying nominal part geometry to represent basic shape and adding 
parameters as constraints on that shape. Such a specification is inevitably under-constrained, but if 
the constraints are solved with minimum change, the part is well defined and satisfies all the relevant 
conditions. Additional constraints/parameters can be added to provide future parameterisations provided 
there is no conflict with previous constraints. The proposed approach does not prevent parameterisations 
that define families of parts with topologically different boundaries such as those of figure 4. Although 
it is often considered that parts of a single family should have the same boundary topology, this can 
be assured when necessary by inequality constraints. Such constraints can be used also to prevent modifications 
violating a form-feature class (e.g. changing a pocket to a slot). System architecture The proposed approach 
is reflected in the software architecture of figure 5. The solid modelling kernel is concerned with manipulation 
and interrogation of mixed dimension cellular objects such as those of Djinn. Such objects can be modified 
only by transformations or geometric parameter changes defined for complete objects, even if the effect 
is a local one such as an edge blend. Consfr ained feature modailing kernel II I Constrained Fealu re 
Mocleller 1 Cons1 raint F&#38;o Iv er 1 Feature ModeHer I Figure 5 The features module manages a structure 
of features, each feature consisting of a single object or a construction sequence for the associated 
object in terms of kernel operations. Together with the latter, it constitutes a viable feature modelling 
kernel. Parameters for feature constructors can be computed by an object independent constraint resolver 
that embodies algorithms such as those in [Latham96a] and [Latham96b]. The relationship between the feature 
structure and constraints is managed by the constrained feature module. The final module of figure 5 
represents a set of functions overloaded to manipulate objects, feature hierarchies and constrained feature 
hierarchies, together with feature and constraint specific functions. The architectural separation of 
feature structures from kernel objects and the definition of features in terms of constructors is similar 
to the geometric compiler approach of [Hoffmann that separates feature based object specification from 
the underlying modeller. It differs in the separation of feature structures from constraints. The architecture 
of figure 5 is also different to the Selective Geometric Complexes (SGC) of [RossignacfB] where feature 
operations are closely tied to the representations of the underlying kernel modeller. The SGC approach 
decomposes set-theoretic operations into sub-division, selection and simplification. Djinn functionality 
could be implemented using the ideas of SGC without the simplification step and the feature modifications 
of this paper could be implemented using that simplification. This compatibility between SGC and Djinn 
is reflected in the similarity between Djinn and the Constructive Non-Regularised Geometry (CNRG) of 
[Rossignac91]. The remainder of this paper is concerned with features and their manipulation, not with 
the generation of modification parameters using constraints or otherwise. Feature modelling The features 
of this paper are designed to satisfy the requirements discussed previously for feature based applications 
and to conform with the proposed software system architecture. Feature hierarchy The proposed features 
form a directed acyclic graph that represents a strict hierarchy (i.e. a tree) of physical features. 
The feature structure is not a tree because nodes are shared to represent multiple instances of a single 
feature. The explicit model of a feature hierarchy enables the application to access the geometry of 
individual features and the geometry of individual objects at the bottom of that hierarchy. Ibis eliminates 
much of the need for the history files used for geometric modification by most current solid modelling 
systems. When a feature is eliminated, its hierarchically descendent features and feature instances are 
eliminated if they are not also descendants of ancestors. Such elimination is not possible with feature 
structures such as that of [Gomes91] where the general graph nature of constraints between features is 
reflected in the feature structure. It may be convenient to define intersection features, e.g. an edge 
feature whose point-set is the set intersection of two sheet feature point-sets. Such a feature cannot 
be a sub-feature of both features from which it derives. The application must explicitly assign such 
features to a particular parent and this logically separates them from the geometry of intersection. 
Unfortunately, geometric modifications that cause an intersection to move do not correspondingly move 
the feature derived from that intersection. To maintain such dependencies, these features must be re-computed 
by the application and their defining parameters subsequently modified. Parameters used to modify a given 
feature can be derived from constraints between the geometry of any descendent feature instance and that 
of any descendent of any ancestor feature. This is a consequence of the partial order inherent in a tree 
structure. It is more general than the approach of [Chen95:2] where a feature is specified in terms of 
prior feature geometry in a strict total order. A strict hierarchy of features is also advocated by [Rossignac90], 
but he then discusses modifications of a procedural model, i.e. a strict order? The partial order allows 
two sub-features of any feature to be (externally) defined in terms of each other with no precedence. 
For example, consider a slot relatively located with respect to a protrusion on the face of a block. 
In contrast to [Chen95:2], either can be modified without violating their relative location. If either 
is deleted, the other is under-constrained, but its location with respect to the block does not need 
to change unless other modifications require it so to do. The point-set of each feature is defined in 
a local co-ordinate system related to that of its parent feature by a transformation. This enables, for 
example, a distance constraint between two faces on different features to be satisfied by moving one 
feature with respect to the other by changing its transform. Although the proposed feature structure 
embodies instructions for modelling operations, unlike [Chen95:2] it is not merely an instruction stream 
to be executed. For example, after new feature parameters have been externally computed, the feature 
hierarchy can be updated incrementally. This allows changes to the boundary structure to be used to update 
the current constraint structure before further results of prior constraint resolution are used to modify 
ancestor features. This eliminates the need for the unreliable operation to determine boundary element 
correspondence. Single features The modelling community distinguishes two distinct kinds of feature [Pratt88], 
i.e. volume features and features consisting of collections of faces and other boundary elements. The 
approach of this paper supports both kinds of feature and also mixtures of volumes and boundary elements, 
provided they are valid objects in the underlying modeller. However, unlike some systems, face features 
are not used to implicitly represent volumes. Explicit conversion facilities are specified, but their 
result is a large equivalence class, reflecting an operation that remains an open issue [Pratt88]. Features 
may be associated with point-sets of any dimension, defined in a space of equal or higher dimension. 
Thus, a 2D polygon may be defined in a two dimensional space or on a plane in a three dimensional space; 
polygons in 2D are distinct from polygons in 3D even when the latter lie on the XY-plane. This distinction 
is necessary in order to be able to define modifications in terms of embedding or bounding geometry. 
For example, a constraint on the distance behveen a point and a circular disc in 2D depends only on the 
disc s boundary, but its interior is also relevant in 3D. This functionality imposes demands on the 
Thus, a feature may be evaluated to provide its associated object underlying modeller that are met by 
Djinn. A Djinn object is by applying the composition operator to the objects resulting from created in 
the space of its own dimension, e.g. a rectangle is its feature instance evaluation. defined in 2D. but 
subsequent transformations may map that rectangle into a space of higher dimension. A ZD-transformation 
retains a 2D definition, but a 3D-transformation implicitly adds a third co-ordinate of zero to all points 
before transformation; the final result is three dimensional even if that co-ordinate remains zero. In 
order to eliminate the unexpected anomalies of [Hoffmann93], [Chen95: l] effectively provides semantic 
definitions for the sweep operations of Pro-Engineer from Parametric Technology Inc. The proposed approach 
is similar to Chen s use of set operations for feature attachment, but it is not limited to sweep features 
with control of profile and sweep extent. Any feature may be specified in terms of others using any sequence 
of construction and modification operations. Thus, the features of this paper are not the cells of [Rossignac91], 
[Gomes91] or Djinn; features may intersecf but cells may not. However, features can be implemented in 
terms of cells. Feature abstractions The geometric features of this paper have structure, construction 
sequence and an associated object with an associated point-set. Neither the object nor its point-set 
form part of the feature, but they may be derived from it. Geometric features are defined in terms of 
objects as follows: . Each feature is accessed by an identifier that is unique over all features of a 
single feature hierarchy. . A feature hierarchy is a set of features, defined formally as a partial function 
from the identifiers to features and feature instances, each with auxiliary data:- Feature-hierarchy 
c Identifier H ((Feature u Feature-instance) X Aux) The hierarchy is a consequence of the definition 
of a feature in terms of indirectly accessed sub-features, i.e. sub-feature instances. A feature instance 
is a feature identifier and a transform:- Feature-instance c Identifier x Transform Each feature and 
each feature instance is associated with an object which can be derived from its definition. The point-set 
of a feature instance s object is obtained by applying its transform to the point-set of the instanced 
feature s object. . A feature is defined formally as either an object or a composition:-Feature c Object 
u Composition A composition consists of an operator and indirectly identified feature instances. The 
operator is a partial function that corresponds to a sequence of kernel modelling functions:- Composition 
c c (Seqk(Identifier) x k_Composition), ke Z+ where k_Composition c Seq,(Object) f--) Object, and Seqk(E) 
is notation for an ordered multi-set of k elements from the set E, i.e. Seqk(E) = (1. . . k) -_) E. Each 
object is associated with a point-set defined in a space of a specific dimension. The feature instance 
transform locates the co-ordinate system of the point-set of the instanced feature s object in the co-ordinate 
system of the feature of which the instance is a constituent:- Transform c sn ++ !31m . Auxiliary data 
associated with a feature or feature instance consists of an integer attribute that identifies application 
data and its previous identifier to record a change made to avoid identifier conflict:- Aux c Z x Identifier 
Example A feature hierarchy H with no attributes that consists of the union of two instances 14 and Is 
of object sub-features Fz and Fs respectively could be defined as follows: H= ( 1 -+(F,auxl ), 2 + ( 
F2, aux2 ), 3 -+ ( F3, aux3 ). 4+(b,aux4), 5 -+ ( 15. aux5 ) >, F = ( (4.5). _ u _ >. 14 = (3, I ), 15 
= ( 2, I x where auxl E Aux, I is the identity transform, and uf is the operator of [Armstrong et al, 
19971 to unite cellular objects.  Definitions The previous definitions of a feature hierarchy are completed 
by invariants defied in the next sub-section using the following relations:- * Featurq is a partial function 
from identifiers to all features of hierarchy H. It is defied by composing the map H with the map that 
selects the first element of the result, then taking the sub-set of the composite map by restricting 
the range to features:- FeatureH E Identifier c, Feature Featurer.t = (H; 1st element) B Feature The 
remaining elements of the range of feature hierarchy H provide similar partial functions for feature 
instances and auxiliary data:- InstanceH E Identifier c-) Feature-Instance InstanceH = (H; 1st element) 
B Feature-Instance Auxili~~y~ E Identifier ++ Aux . A~xiliq~ = (H; 2nd element) The partial function 
from feature instance identifiers to the instanced features is defined by:- InstanceOfH E Domain(hstancqj) 
+-3 Domain(FeatureH) hsti3nceOfH = (hstancq; l st element) The inverse of this function provides the 
relation for all instances of a given feature:-InstancedByH E Domain(Featurw) e, Domain(InstanceH) InstancedByB 
= InstanceOfB~l The feature instance identifiers of a given composite feature are related to the latter 
s identifier by the one to many relation:- PartH E Domain(Instance&#38; H Domain(FeatureB) PartBe = (FeatureB 
w Composition); 1st element; Contains  where Contains E S%(E) u E (s Contains a) = (a E Range(s)) The 
relation between features and their instances together with that between instances and the features of 
which they are a part is defined by the one to many relation:- ParentOfB E Domain(H) c) Domain(H) ParentOfH 
= InsmnceOfB u Pe  The transitive, reflexive closure of this relation provides all ancestor features 
or instances of a given feature or instance:- AncestorOfB E Domain(H) tt Domain(H) Am%.toflfB = ParentOft,* 
where the transitive closure of relation R is R+ = R , R = R, and Rn+t =Rn; R aa z+ and the transitive 
reflexive closure of relation R is R = R+ u (a+ajaE Domain(R)) Identifiers of the immediate sub-features 
of a given composite feature are related to the latter s identifier by the composition of relations:- 
ChildFeatureB E Domain(FeatureH) c) Domain(Featurm) ChildFeatureB = PartB- ; InstanceOfH . Identifiers 
of all sub-features of a given composite feature are related to the latter s identifier by the transitive 
closure of the immediate sub-feature relation:- hSCeIIdenffeatI.UeH E Domain(FeatureH) +$ Domain(Featurq) 
Descendenffeaturq = ChtidFeatureH+  Invariants . All identifiers in a composite feature are feature 
instance identifiers:- V H E Feature hierarchy . d (ids, C) E (Range(FeaturqI ) nComposition) Range(ids) 
c Domain(InstanceH) The identifier in a feature instance is a feature identifier:- V H E Feature hierarchy 
V (id,T) E kInge(hStanCeH) id E Domain(Feamrw)  . There are no cycles in the graph formed by links from 
features to the instances from which they are constructed and from those instances to the instanced features:- 
V H E Feature hierarchy V id E Domain(FeatureB) (id, id) e DescendentFeatureH  . Exactly one feature 
in a hierarchy is not instanced:- V H E Feature hierarchy Cardinality (Domain(FeatureB) - Domain@stancedByB)) 
= 1 Root(H) is used to denote the identifier of this root feature of hierarchy H:- Root E Feature-hierarchy 
-+ Identifier (Root(H)) = Domain(FeatureH) -Domain(InstancedByH) . The single non-instanced feature 
in a hierarchy is an ancestor of all other features. V H E Feature hierarchy . {Root(H)) x (Domain(FeatureH) 
-(Root(H)]) c DescendentFeatureB  Identifiers and attributes This section defines the properties of 
identifiers and attributes for features and feature instances. It uses concepts that reflect those of 
Djinn cell identifiers and attributes [Armstrong97]. Common attribute and identifier properties Each 
feature and feature instance retains the same identifier and attribute values over a store/retrieve 
cycle. Modifications of a feature or feature instance transform do not change any identifier or attribute 
(identifiers may disappear due to deletions). Modifications of an object feature at the bottom of the 
 hierarchy have no effect on its identifier or attribute. When a feature is copied, the identifiers and 
attributes of its constituent cells and sub-features are inherited by equivalent cells and sub-features 
of the new feature. When feature hierarchies are combined, sub-features, feature instances and cells 
of the new hierarchy inherit their identifiers and attributes from the operands of combination unless 
there is an identifier conflict.  Additional properties of identifiers All functions to manipulate 
feature hierarchies (including Djinn functions overloaded to accept feature hierarchies as an alternative 
to Djinn objects) use identifiers to reference sub-features and feature instances. Each feature and feature 
instance has an identifier that is unique among the features and feature instances of the single feature 
hierarchy of which it is a part. Identifiers are assigned to features and feature instances when they 
are created. All feature access functions cope with identifiers that do not represent any feature or 
feature instance in the accompanied hierarchy and indicate this situation on return. This simplifies 
the application s treatment of features and feature instances that are eliminated during hierarchy modification. 
 Additional properties of attributes Each feature and feature instance may be associated with (possibly 
non-geometric) data maintained by the application and identified by an attribute. Different features 
and feature instances may be associated with the same attribute. Applications can associate only one 
attribute with a feature or feature instance.  Attributes are identified by strictly positive integers 
and zero identifies the null attribute. The null attribute is associated with each new feature or feature 
instance when it is created explicitly or by feature combination.  Feature manipulation A feature hierarchy 
interrogation function either acquires properties of . a feature, l a feature s equivalent object or 
that object s cells, l an object feature at the bottom of the feature hierarchy, or l a cell of an object 
feature. Acquisition of feature data such as the sequence of the feature instances for which it is constructed, 
requires feature specific interrogation functions. All other interrogations can be achieved by overloading 
the solid modeller kernel functions to accept a feature hierarchy and feature identifier as an alternative 
to an object. Feature hierarchy modification functions either l create a new feature hierarchy defined 
in terms of existing feature hierarchies and their constituent objects without affecting those constituents, 
 l modify object features or their cells, or l modify the operation or operands of a feature s combination 
 function, or its sub-feature instance transformations. As with interrogation, the fit two classes of 
operation can be achieved by overloaded kernel functions. The last requires new feature specific functions. 
Unfortunately, the generalisations of the previous two paragraphs do not precisely define the extended 
semantics of overloaded kernel functions. When the operand type is a Djinn object, overloaded Djinn functions 
perform the normal Djinn operation. When it is a feature hierarchy and an identifier of a feature at 
the bottom of that hierarchy, the normal operation is applied to that object feature. When the identified 
feature is composite, the normal operation is applied to the equivalent object or an analogous feature 
operation is applied. Thus, some operations on a feature s equivalent object do not require the application 
explicitly to evaluate the hierarchy. The semantics of functions to perform these operations can be found 
in [Middleditch96]. The remainder of this paper describes the new feature specific functions.  Feature 
manipulation functions Feature creation A Djinn object is explicitly converted to and from a feature 
hierarchy using the functions: Object to feature Given an object D... Change that object into a feature 
hierarchy H consisting of a single feature whose associated object ls the given object. Feature to object 
Given a feature hierarchy H consisting of a single feature . . . Evaluate that hierarchy to create the 
associated Djinn object D. Thus objects can be created, converted to features and subsequently combined 
to form a feature hierarchy. Sometimes however, it is more convenient to create the complete object before 
conversion to a multi-feature hierarchy. Unfortunately, the identification of prospective sub-features 
is non-trivial even when feature recognition is not involved. Prospective sub-feature identification 
involves the selection of part of an object whose boundary is usually incomplete! For example, a solid 
boss feature is evident from its exposed faces, but those faces do not completely define that feature 
where it connects to the remainder of the object. In contrast, a set-theoretic sub- expression precisely 
defines a feature, but such expressions are not accessible at the Djinn interface because it is intentionally 
representation independent. Since these difficulties reflect an unresolved research issue [Pratt88], 
scope for implementors to exploit future research is provided by a feature identification function that 
produces a member of an equivalence class:- Create feature Given a feature hierarchy, the identifier 
of a leaf feature, a set of the latter object s bounding face cell identifiers and a union/difference 
flag... Change the feature into the equivalent union or difference of two feature instances, one whose 
point-set is partially bounded by the given faces. The identified feature can be any shape whose exposed 
bounding faces are those given. Unfortunately, if the feature is subsequently moved to expose more of 
its boundary, different results could ensue from different implementations, but this merely reflects 
the unresolved research issues. Feature recognition is even more difficult than feature identification. 
Although it remains a research issue, a precise definition is possible [Parry-Barwick941. This definition 
is the basis of the function:- Recognise feahwe Given a feature hierarchy, the identifier of a leaf feature, 
an object, a transformation class and a union/difference flag... Change the feature into the equivalent 
union or difference of two feature instances, one whose point-set is a prescribed transformation of the 
given object s point-set. Once again, the result is the member of an equivalence class because all faces 
of the recognised feature are not usually exposed, and scope remains to implement future research results. 
Hierarchy manipulation Feature hierarchies are created and modified by overloading kernel functions to 
combine and partition objects [Middleditch96]. This section summarises feature specific functions. Figure 
6 The hierarchy elimination operator !! converts a feature hierarchy into a single feature with all 
the same cell boundaries. For example, consider the feature hierarchies of figures 6b and 7b. Figure 
6b represents the union of the features of figure 6a. and figure 7b represents the 4 features union of 
figure 7a. Hierarchy elimination changes the hierarchies of figures 6b and 7b to the single feature hierarchies 
of figures 6c and 7c respectively. (In contrast to figures 6b and 7b, the leaves of the trees in 6c and 
7c represent cells, not features.) r-r-1 B B i 4 ! I *, hh b) *I 4 Bl '% !!<<a, b>, ul> A2 8, - El2 
8, JA, fA2 Figure 7 The cells of the single feature equivalent to a feature hierarchy are obtained by 
recursively obtaining the cells of its sub-features, transforming them and combining the results using 
the composition operator. This recursion terminates with the objects (sets of cells) at the bottom of 
the feature hierarchy. The feature extension to Djinn proposed by this paper provides a function to eliminate 
any feature sub-hierarchy:- Eliminate hierarchy Given a feature hierarchy H and the identifier i of a 
feature or feature instance... Replace the given feature by an object feature with the same cell boundaries. 
 This hierarchy elimination:- 139 changes the given features to the equivalent object feature, destroys 
all feature instances and features lower in the hierarchy than the given feature provided the latter 
are not referenced elsewhere, and has no effect on features above the given feature. Unaffected and 
transformed cells retain their attributes and identifiers if possible; cell identifier conflicts are 
resolved by Djinn in the same way as feature identifier conflicts, New cells acquire the null attribute 
and new identifiers. Djinn creates a map to relate new identifiers to the identifiers of the cells from 
which the new cells derive. This map can be interrogated by the Djinn functions Dj-Get-New-Labels and 
Dj-Get-Old-Labels. However, since the map captures only one cell derivation, these functions are probably 
useful only when a single hierarchical level is eliminated. The result of feature hierarchy combination 
has a level that is often redundant. For example, when each operand is the union of two features, it 
may be preferable for their union to be a feature hierarchy whose root is the union of four features 
rather than a three level hierarchy. Elimination of the redundant level is achieved by the operator ! 
that creates a hierarchy whose root feature has immediate sub-features that are the features at the second 
level of the original hierarchy. Thus, set-combination without an additional level in the hierarchy is 
the result of the operation !(A uf B). Elimination of any single level in a feature hierarchy is achieved 
by the function: Reduce hierarchy Given a feature hierarchy and the identifier of a sub-feature... Remove, 
using the operator !, the top level of the sub-feature hierarchy. Mechanical components that are the 
same except for a few features may be created by changing individual features in a copy. This is facilitated 
by the function to substitute features whilst retaining the feature structure: Replace feafure Given 
two feature hierarchies and the identifier of a sub-feature of the first hierarchy... Replace the given 
sub-feature with the primary feature of the second hierarchy. Sub-features of the replaced sub-feature 
hierarchy that are instanced outside that sub-hierarchy are retained as copies. Since copied features 
inherit their identifiers and attributes, features may be copied, modified and then used to replace the 
original. This approach retains as many identifiers as possible. Features in a feature hierarchy are 
accessed by overloaded kernel selection and navigation functions and the following feature specific navigation 
functions:- Parent feature Given an object and the identifier of a feature instance . . . Return the 
identifier of the feature containing that instance. Child instances Given an object and the identifier 
of a feature . . . Return the identifiers of all feature instances in the given feature. Feature inslances 
Given an object and the identifier of a feature . . . Return the identifiers of all instances of the 
given feature. Instanced feature Given an object and the identifier of a feature instance . . . Return 
the identifier of the instanced feature.  Summary and conclusions This paper is not concerned with 
design features, manufacturing features or features for any other specific application. Rather, it develops 
geometric structures and functions to support these and many other applications. A formal definition 
is provided for these geometric features in terms of the objects of an arbitrary solid modeller. The 
paper shows that modem CAD systems can be built using a hierarchical structure of overlapping instances 
of geometric features. Such features can be specified in terms of a more complex structure of geometric 
constraint relationships, but there is no need for a more complex feature structure. This approach separates 
issues of solid modelling, feature modelling and constraints and thus enhances clarity of software specification 
and maintainability. It also allows the solid modeller to be used alone and the feature modeller to be 
used without constraints. The proposed feature manipulation facilities can be implemented in terms of 
a cellular solid modelling kernel provided it supports an appropriate persistent cell identification 
facility, and object modifications are representation independent. The Djinn interface for a solid modelling 
kernel is a suitable component of the proposed feature modeller. Most Djinn functions can be overloaded 
to accept a feature of a hierarchy as an alternative to a Djinn object. Relatively few new functions 
are necessary to provide feature specific operations. Acknowledgements The research described in this 
paper was partially supported by the UK EPSRC under grant CR/J-18712. It reflects significant contributions 
and criticisms from Alastair Patterson and members of the Geometric Modelling Society. References <RefA>Armstrong 
C., Adrian Bowyer A., Cameron S., Corney J., Jared G., Martin R., Middleditch A., Sabin M., Salmon J., 
Woodwark J., Djinn . . A geometric interface for solid modelling , To be published, Information Geometers, 
1997. Chen X. and Hoffmann C. M., Towards feature attachment , Computer Aided Design, Vol. 27, No. 9, 
September 1995. Chen X. and Hoffmann C. M., On editability of feature based design , Computer Aided Design, 
Vol. 27, No. 12, December 1995. Gomes A. J. P. and Teixeira J. C. G. , Form-feature modelling in a hybrid 
CSG/BRep scheme , Computers and Graphics, Vol. 15, No. 2, 1991. Hoffmann C. M. and Juan R., Erep, an 
editable, high-level representation for geometric design and analysis , Technical report CER-92-24, Computer 
Science, Purdue University, 1992. Hoffmann C. M., On the semantics of generative geometry representations 
, Technical report CSD-TR-93-062, Computer Science, Purdue University, September 1993. Kripac J., Topological 
identification system -A mechanism for ,persistently naming topological entities in history-based Iparametric 
solid models , Ph.D. dissertation, Czech ltechnical university, Prague, 1994. Latham R. S. and Middleditch 
A. E., Geometric constraint processing algorithms based on an ianalysis of constraint type , Internal 
Technical Memorandum BRU/CAE/96:7. Brunel University, UK, September 1996. Latham R. S. and Middleditch 
A. E., Connectivity analysis: a tool for processing geometric constraints , Computer-Aided Design, Vol. 
28, No. 11, pp !>17-928, November 1996. Middleditch A. E.. and Reade C., Geometric features: an extension 
to a solid modelling lcernel , Internal Technical Memorandum BRU/CAE/96:6, Hrunel University, UK., September 
1996. Parry-Barwick S. J. and Bowyer A., Minkowski sum of set-theoretic models , Proceedings of CSG 94 
Conference, pp 101-116, Information Geometers Ltd.. 1994. Pratt, M. J. Synthesis of an optimal approach 
to form-feature modelling , ASME Computer and Engineering Conference, San Francisco, USA, August 1988. 
Rossignac J. R. and O Connor M. A., SGC: A dimension independent model for point-sets with internal structure 
and incomplete boundaries , Geometric Modeling for Product Engineering, Proc. 1988 IFIP/NSF Workshop 
on Geometric Modeling, Eds. M Wozny, J. Turner and K. Preiss, Rensselaerville, NY USA, September 1988. 
 Rossignac J. R., Issues on feature-based editing and interrogation of solid models , Computers and Graphics, 
Vol. 14, No. 2, 1990. Rossignac J. R. and Requicha A. A. G., Constructive non-regularised geometry , 
Computer Aided Design, Vol. 23, No. 1, January 199 1. Salomons 0. W., van Houten F. J. A. M., Kals H. 
J. J., Review of research in feature based design , Journal of Manufacturing Systems Vol. 12. No. 2, 
pp 113- 132, 1993. V. Shapiro, D. L. Vossler, What is a parametric family of solids , Solid Modeling 
95, Salt Lake City, Utah, USA, 1995.</RefA>  
			

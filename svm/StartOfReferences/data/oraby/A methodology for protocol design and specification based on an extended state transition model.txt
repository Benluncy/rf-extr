
 A ~0D0~EGY K)R PROTOCOL E~Z~ ~ S~IFIC.ATION BA~nON~EX~ENDED STATE TRANS~I~ ~D~L ~ a~mg CNCP Telec~,,-,unica~ons 
Toronto, Ca~ ABSTRACT A lot of effort is being dedicated world-  wide to defining Open Systems Interccnnection 
(OSI) protocol standards and tools for formally describing them. Hc~ever, little work is done in developing 
methods for applying these tools to the development of new protocols. This paper presents such a methodology 
based on OSI and software engineering principles. It provides general guidelines for designing pro- tocols 
based on an extended state transition formal description technique (FDT). It enEoha- sizes a systematic, 
analytical and algorithmic approach to achieve ~t~letaness of protocol specification during the protocol 
design process. Its possible application to the development of OSI protocol standards is discussed and 
suggested for study by the standards cu,,Lunity. 1. Introduction Due to the complexity of designing 
and specifying a complete set of standards for OSI [Zim~, there has been a growing interest in both the 
International Telegraph and Telephone Consul- tative Committee (CCITT) and the International Organization 
for Stardardization (ISO) in developing methods for formally describing the services and protocols of 
OSI. Of these methods, the Extended Finite State Machi~ Specification, also called the Extended State 
Transition (EST) model [ISO/TC97/SCI6/ N1347], has reached the higher level of maturity and acceptance 
because of its familiarity to protocol designers and implementors. The EST method has two forn%s of representation: 
a graphical form and a program- like linear form. This paper presents sane user guidelines for applying 
the linear form to the design and specification of protocols. The S.70 Teletex transport protocol [$70] 
was d~osen as the example in this paper because a) it is a well-known protocol which is inte- grated 
in the OSI transport protocol standard Permission to copy without fee all or part of this material is 
granted provided that the copies are not made or distributed for direct commercial advantage, the ACM 
copyright notice and the title of the publication and its date appear, and notice is given that copying 
is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires 
a fee and/or specific permission. &#38;#169; 1984 ACM 0-89791-136-9/84/006/0034 $00.75 as Class O, b) 
transport protocol Class O is used within the CCITT and ISO FDT groups as basic trial example specification, 
and c) it is complex enough to demonstrate bow the user guidelines can be applied. Reference is also 
made to OSI transport protocol class 1 [Tran] when required. Section 2 presents a short description 
of the extended state transition FDT used. Section 3 presents the major steps in the design of OSI protocols 
as the basis for a methodology. These steps are service analysis and specification, and protocol specification. 
 Section 4 elaborates on a protocol design metlXX~oiogy which consists of mathods for a) partitioning 
service and protocol elements, b) developing a formal service specification, c) deriving protocol elements 
from the service speci- fication, d) stepwise refinement of tb~ ixutocol specification to represent the 
relationships between protocol elements and service primitives, and e) choosing data structures. It suggests 
that campleteness of protocol specification should be achieved during the design process and not through 
post-design analysis and maintenance. An al~>- rithmic approach to achieve the completeness of the stepwise 
refinement process and hence the protocol specification is presented. Section 5 outlines bow the extended 
state  transition model FDT could possibly be applied to tb~ development of OSI protocol standards. 
It is finally suggested that such a methodology be studied and defined within the standards c~,~nity. 
 2. Extended State Transition Model FDT This paper is restricted to an FUr for protocol specification. 
The more general applications of KE are cove.red m [Boeh 82]. FIE ix~vides the means for precisely specifying 
oat,mmication protocols in the form of an abstract representation of their essential requirements and 
aspects. It should allow the production of accurate, unambiguous, sufficiently ccmplete, implementation-independent 
specifications which could hopefully be automatically verified and implemented. The FD~ used in this 
paper is a preliminary version of the extended state transition model developed by Subgro~o B of the 
ISO/TC97/SCI6 WGI ad hoc group on FEE [ISO/TC97/SC16~1347]. This is a descriptive method ~hich combines 
the event-driven finite state machine model of protocols with the power of the high-level programming 
language Pascal. Pascal is used to express the 34 processing routines and data structure qoez-atione 
associated with each state transition. In the extended state transition model, a system is viewed as 
consisting of interconnected modules, ~ch of which is an extended finite state transition machine. For 
example, Figure 1 shows a model of a transport layer service provider (or "system") cc~prising of a transport 
entity module, a mapping module and a local buffer module. A module may participate in two types of 
interactions, n~nely: a) an exchange of control information with a local module to initiate or coordinate 
the execution of some function in a user/provider relationship (a "service primitive" interaction) ; 
 b) an exchange of a Protocol Data Unit (P~J) with a remote peer module to cooperatively execute some 
procedure (a PDU interaction). The set of interactions (or interaction primitives) between a given module 
and another module in its environment is called a channel. The specification of a module includes an 
entm~ration of the interaction ~oints through which it interacts with its enviror~ent. Each module is 
defined in terms of:  a) a state space, which defines all the (internal) states in which the module 
my be at any possible poilfc in time; b) the possible transitions from each state to a "next" state. 
 The state space of a module is specified by a set of variables. A possible state is characterized by 
the values of these variables. One of these variables is called "STATE". It represents the "ma~or state" 
of the module. In a given major state, the possible transitions which may occur depend on the values 
of some of the state space variables (an enabl~g predicate), and possibly on the receptio~ input interaction. 
If several transitions are possible at some given time, the model asstmles that an in~plementation will 
execute only one transition at the t/me. The choice is not specified but the transitions my be assigned 
a relative priority. The operation of executing a transition performs some action which may change the 
values of variables--and------may initiate some output interaction(s) with the envircrm~ent. Tb~ possible 
transitions of a module are defined by the specification of a number of transition types. Each transition 
type is characterized by: a) the enabling condition- this includes:  - the present mawr state (FROM 
clause)  - an optional input interaction (~ clause)  - an optional additional enabling predicate (PROVIDED 
clause)  b) the operation of the transition- this includes: - the next major state (TO clause)  
- the action (BEGIN stat~,ent ~hich my include  the generation of output interaction(s)) The syntax 
of the FUr gives the specifica- tion writer total flexibility in presenting the definition of transition 
types. However, there are two mawr approaches to organizing the transitions, namely: a) an interaction-oriented 
approach, in which transitions are ordered according to the input interaction. Transitions with the same 
 clause are collected and possibly nested together; b) a state-oriented approach, in %4hich the transitions 
are ordered according to their present major state, that is the FROM clause. The interaction-oriented 
approach provides a disciplined approach to the stepwise refinement of the protocol specification as 
elaborated below. This paper provides some user guidelines for developing a cc~plete specification of 
the transi- tion types. They are based an the state diagrams shown in Figure 2 for the error-free connection 
establishment procedure of the S. 70 transport layer procedure (class 0). Separate diagrams are shown 
for the calling end and called end for simplicity of presentation. 3. Elements of Protocol Design and 
S~cifica - The major work on FUr in the OSI context has so far been in defining the model, concepts 
and language for transcribing and formally represent- ing or analysing existing protocols such as X.25 
or S.70. There has been little work on using the FUr as an aid in the design and development of new protocols. 
We believe that it should be possible to start formalizing protocol design through an FDT and OSI principles. 
 Protocol design encompasses all these activities ccncerned with refining the definition of some u~,,i~nications 
service requirements into the specification of a protocol whose hnpl~menta- tion will satisfy those requirements. 
It is usually preceded by a service definition step which consists of identifying and producing a formal 
statement of the service requirements from the user point of view. Protocol design consists of two mjor 
steps: a) service analysis and specification, and b) protocol specification. The service analysis and 
specification step focuses on the protocol functions which would be required to realize the user requirements. 
It identifies in more technical details what is to be done but not how it is to be accc~plished. The 
service specification defines all the functions from the point of view of the system as a whole independently 
of its internal layered structure. The protocol specification step completes the analysis and produces 
a protocol description in terms in which it can be i[mpl~mented and tested. In this respect, protocol 
specification is an inherent aspect of protocol design. The protocol specification defines the distribution 
of f~%ctions to the various entities in each layer of the syst~n and the %ray they operate. There is 
a close analogy between these protocol design steps and certain stages of the software life cycle [Wass]. 
The service analysis and specification step corresponds to the software requirements analysis and definition 
stage. The protocol specification step covers both the soft- ware architectural (or preliminary) and 
part of the detailed design stages. During the design of pre-OSI protocols (such as HE,C, X.25, S.62, 
S.70), no formal service specifications were available. At best, there might have been a definition of 
the service in user-oriented terms (e.g. Recommendation F200) for which the protocol (e.g. Recommendation 
$62)was designed. The practice typically consisted of defining the functions and protocol elements in 
a piecemeal, indeperdent manner, then consolidating them together, if required, in a procedural description. 
State diagrams would typically be left out (e.g. HDLC or S.70) or added as an afterthoughtl Then, the 
rigorous analysis of the protocol or in~lementation experience would uncover inconsistencies and ambiguities 
bet%~_n the different parts of the specification. Much time and effort would be spent in enhancing, unifying 
and harmonizing these parts. Due to the ever-increasing complexity of OSI protocols, there is a need 
for a more disci- plined approach to the protocol design process. The objective is to produce a better 
unified and h~zed protocol right from the start. This could be accomplished by a methodology ~hich is 
based on sound OSI principles. It should follow rigorously the steps in the protocol design process and 
require specific deliverables for in- depth review at the completion of each step. .The com~x)nents 
of such a methodology are: a) partitionirg principles; b) rules for formally defining protocol functional 
requirements in terms of service primitives. A service primitive is "an abstract, i~plementation independent 
element of an inter- action between a service-user and the service- provider at a service-access-point". 
The result- ing deliverable is a service s~ecification [Boch 80], for example t21e transport service 
definition domanent [Trans]. c) rules for deriving protocol elements from the service specification, 
and completely describing the behaviour of the interact/rig modules in terms of the relationships between 
protocol elements, service primitives and pos- sible orders of execution. A protocol element may be a 
protocol data unit, which is inter- changed between peer ocrmmalication entities, or a mapping to a local 
function, e.g. a service primitive. The resulting deliverable is a ~rotocol s~ecification [Boch 80], 
for example the transport protocol specification document [Tran]. 4. FDT User Guidelines for Protocol 
Desist and S~cification The guidelines are based on existing practices and principles. Some of the proposed 
rules have actually been informally used in the development of new protocols such as for access to message 
handling systems [~$23. However, the major examples given in this paper are in terms of how the S.70 
transport protocol could have been formally developed because S.70 is a well- known simple protocol suitable 
for illustrating the principles. 4.1 Partitionin~ Methods Partitioning is a key technique which is 
extensively used to master the complexity of protocol design. It is tb~ conceptual deccmposi- tion of 
a system or specification into smaller ccnponents in order to facilitate its understand- ing, validation 
and implementation. Two major partitioning methods used in protocol design are: logical phase partitioning 
and functional partit- ioning. Logical phase partitioning is the basis of the proposed methodology for 
the design of OSI protocols. It consists of grouping the service primitives to derive protocol elements. 
It also provides the framework for the stepwise refinement of the protocol specification as presented 
below. However, in order to effectively apply the stepwise refinement process, the internal structure 
of the service provider needs to be elaborated. This requires a form of functional partitioning which 
decomposes a system into relatively independent components. These components could also be modelled as 
individual finite state machiD~s. Service primitives could be defined to express the interactions between 
the components. An appropriate functional partitioning structure is normally evident from the functional 
analysis inherent in the process of deriving protocol elements after logical phase partition- ing. A 
simple functional partitioning structure which is applicable to S.70 and Class 0 is shown in Figure i. 
If necessary, further decomposition is possible through a more in-depth analysis of the protocol elements 
and their interrelation- ships. An example is the decomposition of the H~uC Classes of procedures into 
the functional crmi0onents called link set up, source (of data), sink (of data), PF-control (poll/final 
bit procedure), clock (timer operation), transmission (FCS error check, buffer management), and d~eck- 
pointing (poll/final bit error recovery) [Boch 773. The structuring concepts used in that example seem 
generally applicable to the specifi- cation of OSI protocols ~hose components are reus- able in several 
contexts, e.g. the transport protocol classes. However, such a level of decomposition is not required 
for simpler proto- cols such as those for Teletex (S.62, S.70). 4.2 Developin 9 the Service S~ecification 
 It is desirable that the user service requirements definition be presented in, or at least d~able into, 
atomic, user-oriented capabilities called service elements ~MHSI]. This identification and definition 
of the most elemen- tary functions required wpuld ensure ccrmplete coverage of the service requirements. 
 As an example, some service elements which could be defined for the Transport Layer Service [Trans] 
are: Called Address, Calling Address, Expedited Data Option, Quality of Service, and TS- user data. These 
are some capabilities which the Transport provider allows the Transport users to interchange.  4.2.1 
Service Primitives The objective of the service analysis step is to produce a more formal representation 
of the capabilities corresponding to or realizing the service elements. There should be some guidelines 
 for developing this representation in terms of service primitives. One guideline is to define service 
primitives by logically packaging ~ogether the service elements in a n~nner that the occur- rence of 
the primitive represents a logically indivisible event which has some meaning to the service-user. Effectively, 
the service elements become parameters in one or more service primi- tives [~$2]. For example, the transport 
layer service elements mentioned above are ccmponents of the T-Connect request and T-Connect indication 
primitives. 4.2.2 Logical Phase Partitioning In a service specification, the service  primitives should 
be grouped together according to their types and interrelationships [ISO/TC97/ SCI6/N897] in order to 
permit the methodological derivation of protocol elements. Primitives could be of four types: a) request 
or response by a service-user; b) indication or o0nfim by a service provider. The primitives are grouped 
according to a) whether the service is unconfirmed or confirmed, and then in b) phases of cperation. 
A service is said to be unconfirmed if a request primitive originated by a service-user results only 
in an indication primitive to the remote service-user. For example, the Transport connection release 
service is an unconfirmed service consisting of the T-D-req and T-D-ind primitives. A service is said 
to be confirmed if additionally the r~note service-user issues a response primitive which results in 
a confirm primitive to the originating service-user. For example, the Transport connection establishment 
service is a confirmed service consisting of the T-C-req, T-C-ind, T-C- resp and T-C-conf primitives. 
 A phase of operation is a set of service primitives which together perform some logically related services 
with a well defined meaning to peer service-users. Each service primitive may form part of unconfirmed 
or confirmed groups or be otherwise unrelated. For example, the transport service is divided into three 
phases: connection establishment, data transfer and connection release. 4.3 Deriving Protocol Elements 
from Service S~cification The criteria for deriving protocol elements are based on the functions performed 
by the layer. These functions are a) those which are visible to the user (i.e. service elements or service 
primitive parameters), and b) those which are required for the internal management of the layer in order 
to realize the OSI (N )-service primitives from the (N-l)-service primitives, for exanple to ensure data 
integrity, synchroniza- tion, error control. A possible method for deriving protocol elements consists 
of the following steps: i) consider each phase in turn;  2) for each phase, consider each service request 
primitive in turn and A) map it directly into one or more protocol elements (an E1 set) in association 
with its service indication primitive, if any. B) define additional protocol elements which are required 
to cc~olete the interactions initiated by set E1 in point 2a). Criteria include: BI) does an E1 protocol 
element demand a protocol response, e.g two-way handshake? If so, the acceptance add rejection protocol 
elements need to be defined though they are not part of an end-to-end confirmed service. This is the 
case, in S.70, of TCC as a rejection of a TCR and, in class i, the case of DC as an acceptance of DR 
[Tr~]. B2) need for indicating an error in reception of an E1 protocol element e.g. with an incorrect 
parameter. This is the case of the S.70 Transport Block Reject (TBR) or Class O Error (ERR) protocol 
element. B3) need for error recovery protocol elements. This is the case of the Class 1 RJ protocol 
element. C) if the service request primitive is part of a confirmed service, the related service response 
primitive is n~pped directly into one or more protocol elements in association with its service confirm 
primitive. This is the case, in S.70, of TCA in response to TCR. 3) for each phase, repeat step 2 for 
any primitive not considered in step 2, e.g. un- related indication primitive. This is the case of the 
N-D-ind initiated within the network layer. The application of this method to S.70 and Transport protocol 
classes 0 and 1 is sum%3rized in Figure 3. It also ~ the steps under which the protocol elements are 
derived. 4.4 Ste~wise Refinement of Protocol S~ecifica- tion This is a critical step of the protocol 
 design process. For a design to be a successful solution, it should be simple and closely related to 
the structure of the problem in a natural manner. A natural solution to the protocol design problem is 
provided by an interaction-oriented FDT approach which also ensures cclmpleteness. 4.4.1 C~leteness 
 A protocol specification is considered to be ccmplete when it has defined the effects of all possible 
input interactions from the envirorm~nt to the specified module in all relevant situa- tions. In a specification, 
the reception of some input interaction (with some specific parameter values) in sane mDdule state could: 
a) result in a defined normal or error transition, or b) be correctly ignored, or c) be unintentionally 
omitted. The latter case is an "unforeseen error" due to incomplete or incorrect asstmptions about the 
possible errors in the real wprld environment [Boch 82]. The distinction between the last two cases is 
not always evident. In a complete proto- col specification, the possibility of "unforeseen errors" should 
not arise, and the occurrence of an undefined context should be intentionally ignored and treated as 
an irrelevant situation. The refinement algorithm presented below fulfils this condition. The ~mount 
of error situations to be defined is subject to debate. It is argued that some error cases need not be 
standardized because they may have local significance only. However, it is important that protocol standards 
identify and suggest actions for all error cases (including local ones) which should not be ignored so 
as to: a) serve as an implementation guide and avoid deadlock situations due to unforeseen error situations; 
 b) allow development of robust and resilient implementations. The implementation of transitions for 
handling local errors provides an important debugging tool during system integration testing. Such transitions 
could be selectively enabled or disabled at run-time. Provided that the interfaces (channel type definitions) 
are not changed, it should be possible to isolate the protocol module from side effects due to modifica- 
tions, additions or complete redesign of the modules with which it interacts. If each ~dule impl~_nts 
this self-protection mechanism then the system beccmes easier to maintain. 37 4.4.2 Al~orithm f~- Interaction-Oriented 
Speci_fi- cation Refinement In an interaction-oriented approach, there is a need to consider all the 
possible states for each input interaction together with the relevant context variables. These variables 
are those associated to the sequence of preceding interac- tions ~hich led to the state under consideration. 
The proposed methcxl shown in Figure 4 to achieve this o~leteness has the following basis: a) by following 
the logical sequence inherent in the methods described above for logical ~ partitioning and protocol 
element derivation, we have a stepwise algorithm for identifying all possible input interactions. These 
should include interactions for possible exception ocmditions. The latter are service primitives used 
by the (N+l)-entity to reject the (N)-entity's output interactions or by the (N-I)- entity to indicate 
significant events. b) the algorithm is refined by providing rules for considering all the situations 
in which an input interaction may occur. Situations are categorized as: noz~al, rejection, abnormal. 
A normal situation exists when the interacting entities cooperatively and correctly execute the interaction 
in the correct state(s) as defined by the protocol. A rejection situation occurs when an entity receives 
an input interaction in conformity with the protocol (that is, in the correct state(s)) ~It cannot execute 
it. If this is due to some acceptable or defined cc~itions, the receiver then issues an output interaction 
to indicate the rejection to the requestor. The rejection conditions include parameter errors in received 
interaction, internal constraints of the receiving entity, inability of receiver to satisfy requested 
function. An abnormal situation occurs when an input interaction is received in an incorrect state(s). 
It may arise due to an incorrect implementation of the p~i/interface (i.e channel) specifications or 
unforeseen perturbations cr failures of the environment. c) a systematic, disciplined approach to the 
consideration of each category of situations separately for each input interaction eliminates "unforeseen 
errors". The algorithmic structure and presentation format of the specification implicitly provide guidelines 
as to the context variables to be considered. d) as a global check of oa~leteness, the interaction-oriented 
specification for an (N)- entity should contain a ~ clause for all protocol data units (P~J' s) and all 
service primitives, which may be issued by the (N+I) or (N-I) entities. The (N)-entity issues its service 
primitives as output interactions. The stepwise l~rotocol specification refine- ment method illustrated 
by the algorithm in Figure 4 refers to J/~ut interactions only. The service primitives are first partitioned 
in phases of operation as described above. The major steps of the algorithm for each l~hase in turn are: 
 AI) derive or extend the state transition diagra~description for normal operation; A2) for each interaction 
occurrence, consider the possible rejection and abnormal situations and note any new interactions or 
states introduced; A3) extend the state transition diagram/ description with new interactions from step 
A2; A4) extend the state transition diagra~ description with interactions used for exception conditions. 
 When all the phases have been considered, the actions corresponding to the cccurrem~e of each interaction 
in each of the new state, intro- duced in steps A1 to A4, are def~-~. Figure 5 shows a partial specification 
resulting frcm the application of this algorithm to the connection establishment and release phases of 
S. 70. It also indicates the order in which the refinement was progressed. Its purpose is to show the 
mapping between input and output interactior~ and the clear separation between normal, rejection and 
abnormal situa~ons. All other details are abstracted out. A cause parameter of the T-D-ind primitive 
is used to formalize the treatment of local error conditions for the guidance of imple- mentors. Such 
a usage is possible because the primitive can be invoked at any time by the TS- provider. Step A1 is 
performed by a straightforward refinement of the service specification according to the groups of primitives 
within the phase as defined above. An ~K~R%firmed service group is refined by formally defining the mapping 
of its service request primitive into local functions and P~J's end the m~pping of these PDU's into service 
indication primitives. A confirmed service group is refined by formally defining the mapping of its additional 
service response primitive and associ- ated PDU's into service confirmation primitives. This is illustrated 
by substeps 1 to 4 in Figure 5. Step A2 may result in new interactions, typically the PDU' s defined 
during protocol element derivation for rejecting other PDU's or indicat/ng errors. This is illustrated 
by sub- steps 5 to 8 in Figure 5. In step A3 the handling of these new input interactions (substeps 
9 to ii in Figure 5) may lead to new states. The i~pact of these new states on existing interactions 
is postponed to the end of the phase refinement process in order to simplify and minimize the mm~er of 
iterations. In step A4 (substeps 12 to 14 in Figure 5), care should be taken on the possibility that 
the service primitive used for rejection could also be used for another function, such as entering a 
ne~ phase. This provides a natural basis for choosing the order in which phases are to be considered. 
For S.70, it is natural to consider the release phase (substeps 13 to 14 in Figure 5) after the establishment 
phase.   4.5 Choice of Data Structure Re~resent@tions During the interaction-oriented refinement 
process, new context variables need to be defined to represent the states. While defining the semantics 
(actions) of the transitions, the protocol syntax (data representation, coding) has to be developed in 
parallel. In particular there is a need to choose intermediate data structures, such as data buffers. 
These are used in mapping the user data representation, given in the service primitives, into the protocol 
data representation which is transferred in the PDU. Such a d~oice could also be made in the partitioning 
step. The formalism of abstract data types  developed for software engineering seems to be applicable 
to the FUr based on the extended state transition model [Boch 82]. General guidelines for selecting 
appropriate data structures include: a) the chosen data structure should give the user a clear appreciation 
in the siniolest manner possible of the capabilities available in the protocol and their possible usage; 
 b) the operations on the chosen data structure should closely reflect the functions invoked by the PDU's. 
As an example, in a Teletex ~t protocol formal specification, a CC,~,L~d Document Start may cause the 
receiver to open a doctm~ent file in which subsequent text is written. A Command Document Continue after 
a d~t interruption my cause the receiver to reopen a selected ~t file and posit/on it to the point where 
the document is to be linked and c~erwritten, as needed; c) the chosen data structures should help a 
protocol implementor in understanding the protocol and deriving a straightforward data mapping to his 
memory and file management systems; d) they should be i~plementation-indepen- dent and acc(lalrx~ate 
a wide range of in~plemen- tation environments. As an example, in a Teletex dooanent protocol formal 
specification, a docu- ment may be implemented as a file of records in which each record represents a 
Teletex page or a set of linked files each of which represents a Teletex page. 5. A~lication to OSI 
Protocol Development The development of any protocol of some complexity is highly iterative. Protocol 
stand- ards are usually developed by sizable committees. A cc~mittee would typically design a protocol 
by successively defining the functions (from the service definition), semantics, syntax and state diagrams. 
Each step may be developed by several parallel independent subgroups and the steps may overlap. An editor 
is appointed to consolidate the natural language descriptions produced by all the subgroups into a single 
~t. His role is to ensure a tmiformity of style as well as identify any iD~onsistency between the different 
texts or any omission and ambiguity. However, the imprecise nature of natural languages and the complexity 
of the protocol make the editor's task rather difficult. The extended state transition model FUr provides 
a useful tool for the editor to formally analyze and record the agreements made by the different groups. 
The resulting formal specification could act as a catalyst for ~-ifom understanding of the agreements. 
An interaction- oriented format would provide a check on tb~ correctness of the relationships between 
the service specification and the agreements. This parallel development of natural language and FUr specifications 
would reduce inconsistencies and promote cccmpletenes s. In order to benefit most from the methodology, 
it is suggested that: a) sub-groups be assigned to study, in parallel, functions for each specific phase; 
b) sub-groups record their agreements ~n a standard format such as the following: - Name of protocol 
element  -Description of function - Condition for and action to be taken on  - Condition for and action 
to be taken on reception  -Special considerations c) editor integrates the different subgroup reports 
by applying the interaction-oriented specification refinement algorithm to produce a formalized specification 
which identifies the abr~rmal situations; d) whole group reviews the formalized specification for consistency, 
accuracy and ecnlsleteness. It decides whether aknormal situa- tions can be ignored and, if not, identifies 
them specifically with possibly a suggested action to guide the implementor. 6. Conclusion A lot of 
effort is being dedicated to defining 0SI protocol standards and tools for formally specifying them. 
However, little work is done in developing methods for applying these tools to the design and specification 
of ccx~plete, accurate and correct protocols. Internatior~l standards development commit- tees should 
give deeper consideration to this topic so that ccmpatible, as well as truly robust and resilient, implementations 
could be developed. The methodology proposed in this paper could be an input to such a study. It enphasizes 
a systematic analytical approach to achieve completeness during the protocol design process. The desirable 
result of the study should be user guidelines ~hich could be part of the standards on formal description 
techniques. Guidelines on tb~ formalization of protocol functions, such as multiplexing and flow control, 
within this framework are also required. The systematic aD~ consistent application of these user guidelines 
to the design and specifica- tion of OSI protocol standards would ensure a uniform understanding by all 
interested parties. This would prcmote their wider acceptance and timelier implementation, thus bringing 
OSI a step closer to realization. AckDxDwled~ement The author expresses his deep appreciation to G.V. 
Bochn~u%n for his valuable comments on the preliminary outline which gave birth to this paper, and his 
continuous support. References  <RefA>[ Boch 77] G.V. ~ and R.J. Chung, "A formalized specification of HDLC 
classes of procedure". Proc. Nat. Tell. Conf., Los Angeles, C~, Dec. 1977, Paper 3A.2. [Boch 80] G.V. 
Bochmann and C.A. Sunshine, "Formal methods in communication protocol design". IEEE Trans. O0mmun., 
vol. COM-28,pp. 624-631, Apr. 1980.  [Boch 82] G.V. ~ et al., "Experience with formal specifications 
using an extended state transition model", l~:~'.~: Trans. C~L,L~n., VOI. COM-30,pp. 2506-2513, Dec. 
1982. [ ISO/TC97/SCI6/N897 ] "Data Processing-Open Systems Interconnection-Service conventions". [ISO/TC97/SCI6/N1347] 
"A FDT based on an extended state transition model (Working Docu~_nt, November 1982) ".  [MHSI] "Draft 
]~-~a~.~ndation X.400: Message [Trans] "Information processing systems-Open Handling Systems: System 
M0del-Service Elements systems interconnection-Transport services (Version 2)". Dec. 1982. definition". 
ISO/DP8072. [~S2] "Draft R_~ecmmm~ation X.411: Message [Wass] A.I. Wasserman, "Information system Handling 
Systems: Message Transfer Layer". Dec. design methodology". In: P. Freeman, A.I. 1982. Wasserman (Ed.), 
"Tutorial on software design [S70] "Recommendation S. 70, Net',~rk-indepen-techniques (third edition)", 
rRRR, pp.25-44, 1980 dent basic transport service for Teletex". [Zimm] H. Zimmermenn, "OSI reference 
model -CCITT, Yellow Book, Fascicle VII.2, 1980. the ISO model of architecture for Open System~ [Tran] 
"Information processing systems-Open Interconnect_ion", ~ Trans. C~m~., Vol. G3M- systems interconnection-Transpor 
t protocol 28, pp. 425-432, Apr. 1980.</RefA> specification". ISO/ DP8073. Trane rt-User  TSAP Local Buffer 
" Transport-Entity ~ule Module mapping TCA AND TCA-ok T-C-resp AND T-C-resp-ok T-C-conf TCA Mapping 
I Module NOte: Channel  Note: Each transition is labelled as follows input interaction AND ~redicate 
 Interaction output iNteractlon Network-Service Provider  Figure 2 -State Diagrams for S.70 Error 
Free Figure I - Model Of Trans~o~-t Service Provider Connection Establishment Procedure Phase Service 
Protocol Elements Primitives  S.70 Class 1 IClass .0  Connection T-CONNECT request T-C-req TCR(A),TBR(B2) 
CR(A),ERR(B2) CR(A),ERR(B2) Establishment indication T-C-ind TCR(A) CR(A) CR(A) response T-C-resp TCA(C),TBR(B2) 
CC(C),ERR(B2) tCC(C),ERR(E2) confirm T-C-conf TCA(C) CC(C) CC(C) Data T.-DATA request T-DT-req TDT(A),TBR(B2) 
DT(A),ERR(B2) DT(A),ERR(B2),AK(BI), Transfer RJ(BI,B3) indication T-DT-ind TDT(A) DT(A) DT(A) I .... 
 Connection T-DISCONNECT request T-D-req TCC(BI),TBR(B2), DR(BI),ERR(B2), DR(BI:A),ERR(B2), N-D-req(A) 
N-D-req(A) OC(al) Release indication T-D-ind TCC(BI),N-D-DR(BI),N-D-DR(BI,A) ind(A,3) ind (A,3) Note: 
The references in parenthesis correspond to the steps in section 4.3 Figure 3 - Derivation of Protocol 
Elements from Service Primitives 40 I i mr~ N~ ~ ~ P~ I J flow, e.g I interactio~ and S state~: N:-I 
 I =x~omity with the ~-oe.ocol in ~ate ~ J 1 Define r~ tran~iti~ ~ to sltuati=m ~,ere ~ i ~ De Lx~ceued 
in stete suDeet J. These are rejection situatlcxm. I  ~mo~ml slb~ti=~ ~ a ~ of I~:m. I end of Z interacti~ 
 I | Define transitlone ~..£xx~/ng to occurrence of each I of the N interactlo~ in each of the ~ stat~.intro- 
 l 1.( ~ TS~.T-C-reg ( FR~4 cal lirg-idle ( pRmm_~ T-C-reg-~k TO ~ait-for-TC~ ( S~GIN mRping.TCR;... 
~:  5.( ~ NU~ T-C-req-~ TO SAME (* ~ar~ter error') ~IN TS~.T-D-ind (T-C-req-error):... ~,~; (*suo~mtion*) 
FR~ Cwait-fi=c~, calling-data-trar~fer, calle~-ta]e, ~ait-for-TC-r.~,~ae, called--4~ta-trar~ fer ] TO 
Idle (* initial state, no~ in Figure 2*) ~IN ~aRplng.~-D-~g (lo~1-er~r-ty~e) : ... T~P .T-D-ind ( local-error-type 
) ;  //////////////////////////////////////////////////////////////////  2.( ~ ~.~ ( ~ celle~-J~le 
( PK)Wr, m~ T~R-~ TO ~ait-~om4~=-re~L~nse ( ~ TSAP.T-C-Ind (cck-lnectic~-req~est); ... ~2~);  6.( Ra:~IU~ 
~[E TCR-~ TO SAME ( ~ ~.TOC (_-~_u,--):... E~D; (* s.70, 5.5.6.1 *) ( FR:M [calllng-idle, wait-for-TQ%, 
call/rig-data-transfer, ( walt-~or-TC-ru~, calle~]ate-trans f~'] ( TOS~E ( SSSIN ~ging.TSR;... ~',~; 
 ///////////////////////////////////////////////////////////////// 3. ( ~ TSAP.T-C-resp ( ~ ~alt-for-TC-~ 
 ( PR3~q~ T-C-remp-~k TO called-data-transfer ( E~SXN maRging.'r'C~: ... ~,;  7.( ~ HOT T-C-resp-~ TO 
called-idle sRping.~:c (cause): ... TSAP.T-D-ind (T-C-resp-errcc); (*suggestion*) FK~M [calling-14Lie, 
%~t-f~, calling-0ata-trans~r, called-idle, called-date-trans£~] TO idle E~GI~ maRping.N-4)-req (lc~:al-er:~r-type);... 
TSAP.T-D-i~ (l~cal~ype) :  //I/I/I/I////////////////////////////H//////////////////////////  4.( ~ 
~i~.~c.~ ( FR~4 ~ait- for-T~ ( ~ ~ TO callir~ta-transfez ( 88~N TSAP.T-C-~x~f;... ~; 8.( ~ ~Ur TOR-~k 
TO calling-iale (*,my re=7 ~ ~*) ( l~srs %~saP.T-D-ira (L~ametez-~Ba~b...~a); ( FRCM NOr wait-for-~ TO 
 ( ~ w~=;~. ~m;... ( (* ac~ate err~ r~ovary *) IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII 
9.( ~ ,~oFtrg.TCC (ca~) ( FROM ~t-for-ToA TO calllng-iale (*may retry cr clear*) ( -~n-IN T~P.T-D-ind 
(cauu);... ~): 11. ( ~ ~ ~mlt-~o~ ~o SN4E ( ~ZN m~pin~.~e~;... ( (*a~-.ivate err~ r~overy*) ( E~; IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII 
10.( w~ ~.*m~ ( ~AN'IS'~.TETOS~,~ ( ~GINo.. ( (*ex~Ine reject ~ause a~ 6a~ ~:ti~n*) ( E~:  IIII/111/1111/1111111/11111/I/11111111111/11111111111111111111111 
12. ( ~ TSAP.T-D-req ( PR~H %mit-~or-~C-re~i=(mse ~0 called-idle ( ~ ~.TCC (cauae);... ~; (*rejectic~ 
of T-C-ind*)  13. ( F~CI4 H~? v~it-for-TC-resp~me TO idle  ( ~I~ mapping.N-~-reg (norml-clear);...~): 
(*p'~u~ d~u~e*) ////////////////////////////////////////////////////////////////// 14. ( a~ .aRping.~-P-i~ 
(cause) ( FR~4 ~/~ATE TO idle ( ~ TSAP.~-P-L~ (eause);...~); IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII 
Note: Numbers to the left indicate the ~ in ~ refk~nt was progTesud in accor~nce wi~h Figure 4 in~ associated 
set of tradition. Figure 5 - Partial Specifica~ for S. 70 Ccx~ecti~ EstahLishm~t and Rnlea~ Phuu  41 
  
			

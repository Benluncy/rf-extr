
 A Framework for Implementing Hypothetical Queries Timothy Griffin Richard Hull Bell Laboratories, Lucent 
Technologies Bell Laboratories, Lucent Technologies gritiin@research .bell-laba.com huU@research.bell-labs. 
com Abstract Previous approaches to supporting hypothetical queries have been eager : some representation 
of the hypothetical state (or the corresponding delta) is materialized, and query eval­uation is filtered 
through that representation. This paper develops a framework for evaluating hypothetical queries us­ing 
a lazy approach, or using a hybrid of eager and lazy approaches. We focus on queries having the form 
Q when { 11~ where Q is a relational algebra query and U is an update expression. The value assigned 
to this query in state DB is the value that Q would return in the state resulting from ex­ecuting U on 
DB. Nesting of the keyword srhenis permitted, and U may involve a sequence of several atomic updates. 
We present an equational theory for queries involving when that can be used as a basis for optimization. 
This theory is very different from traditional rules for the rela­tional algebra, because the semantics 
of uhen is unlike the semantics of the algebra operators. Our theory is based on the observation that 
hypothetical states can be represented as substitutions, similar to those arising in functional and logic 
programming. Furthermore, hypothetical queries of the form Q when {U} can be thought of as representing 
the suspended application of a substitution. Using the equa­tional theory we develop an approach to optimizing 
the eval­uation of hypothetical queries that uses deltas in the sense of Heraclitus, and permits a range 
of evaluation strategies from lazy to eager. Introduction The need for accessing hypothetical database 
states arises in many application areas. This includes version management, decision support, active databases 
(where rules may access the deltas and potential future states specified by proposed updates), and integrity 
maintenance. We focus on hypothetical queries with form Q when {U} where Q is essentially a relational 
algebra query (which may involve nested uhen s) and {U} represents a hgpothettcd state. Here U is an 
update expression, expressed in a lan- Permission to mske digital/hard copy of part or ell this work 
for personal or classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advan­tage, the copyright notioe, the title of the publication and its date 
appaar, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, 
to post on servers, or to redistribute to Iiata, requirea prior specific permission and/or a faa. SIGMOD 
97 AZ, USA @ 1997 ACM 0-89791-91 1-4/97 /0005 . ..$3.50 guage that mimics the update expressions of SQL, 
which may include a sequence of atomic updates. The value as­signed to this qnery in state DB is the 
value that Q would return in the state that is reached from DB by executing update U. Such queries are 
fundamental to all applications that involve hypothetical database states. Previous approaches to supporting 
queries against hypo­thetical states have been eagen some representation of the hypothetical physical 
state (or the corresponding delta) is materialized, and then query evaluation is filtered through that 
materialized representation. This includes version man­agement systems, the Heraclitus database programming 
lan­guage prototypes [GHJ96, DHR96], and implementations of hypothetical relations (e.g., see ~S83]). 
The eager ap­proach makes sense for applications where many queries are made against a single hypothetical 
state. However, effective optimization of queries requires the development of a rich, systematic space 
of evaluation strate­gies. The first of two contributions of this paper is to present a wide spectrum 
of evaluation strategies for hypothetical queries, ranging from eager evaluation of hypothetical states 
to lazy evahration of hypothetical statea. An evaluation strategy for a hypothetical query, Q when {U}, 
is lazy if it first reformulates Q uhen {U} into an equivalent, non­hypothetical query Q , and then evaluates 
Q using conven­tional techniques. Our framework provides a means of mov­ing along the entire spectrum 
between eager and lazy evalu­ation, allowing evaluation strategies that are eager, lazy, or hybrid. The 
main difficulty encountered in developing this frame­work was the lack of an equational theory to bridge 
the gap between the relational algebra and expressions involving hy­pothetical states. The second contribution 
of this paper is to fill this gap. The central observation underlying our the­ory is that hypothetical 
states can be represented as sub­stitutions, similar to those arising in functional and logic programming. 
Using this insight, we construct a Hypothet­ical Query Language, called HQL, that incorporates substi­tutions 
= explicit syntactic constructs. These provide an intermediate representation of hypothetical update 
expres­sions, that can be manipulated without going outside of the language. We now briefly describe 
the language HQL. Hypotheti­cal queries are generalized expressions of the form Q when ~, where ~ is 
a hypothetical-state expression that can be an up date expression, {U]; an explicit substitution of the 
form {QI/RI,..., Q~/R~] (which means, intuitively, that rela­tion R, is to be replaced by the query Qi 
); or an expression constructed by an operation that composes substitutions. The construct Q when q can 
be viewed as the suspended ap­plication of the substitution represented by q An equational theory for 
HQL can be developed as a combination of ( 1) a conventional equational theory for the relational algebra, 
(2) an equational theory of explicit substitutions, and (3) a set of equations that relate hypothetical 
states of the form {~} to explicit substitutions. The fully lazy evaluation strategy is achieved by trans­forming 
each hypothetical-state expression into an equiva­lent explicit substitution, and then applying these 
substi­tutions to queries in their scopes, to obtain a pure rela­tional afgebra query. The fully eager 
evaluation strategy is achieved by transforming each hypothetical-state expression into an explicit substitution, 
materializing a full or partial representation of this substitution and storing it in an envi­ronment, 
and filtering the evaluation of queries in its scope through this environment. Hybrid strategies arise 
by com­bining these two approaches in the evaluation of a hypothet­ical query. The framework can be used 
in conjunction with existing techniques for the physicaf representation of hypo­thetical states, e.g., 
the deltas of the Heracfitus languages. The framework developed here can provide the basis for a fufl 
optimizer of hypothetical queries. We leave, as fu­ture work, the development of cost estimation techniques 
for execution plans of hypothetical queries, and heuristics for reducing the space of reasonable plans. 
Related work. The framework developed here is inspired in part by the Heraclitus languages, which support 
hyp~ theticaf queries and the keyword when. HQL is more gen­eraf because hypothetical-state expressions 
do not have to be implemented using deltas. Furthermore, the use of ex­plicit substitutions reveals optimization 
opportunities not previously explored. Explicit substitutions were first presented in [ACCL91] where 
they are used to model A-reduction and to serve as a formaf intermediate language between functional 
program­ming languages and closure-based implementations. An­other interesting application of expficit 
substitutions is the reduction of higher-order unification to first-order equational unification [DHK95]. 
For a survey of calculi of explicit sub­stitutions for ~-terms, see [Les94]. Hypothetical queries are 
closely related to the familiar notion of weakest preconditions [Dij75, Dij76, Gri81]. In the database 
context, a formula ~ is a weakest pre-condition for formula a with respect to update U if for each database 
state DB, O holds in DB if and only if a holds in the result of applying U to Dl?. Several algorithms 
for con­structing preconditions ~ have been presented (see for ex­ample, [Qia90, Qia91]) that rewrite 
a based on the form of U. Evaluating @ corresponds to the lazy strategy in the sense that no hypothetical 
states are materialized. In our approach, ~ is simply expressed as a when { U ~, and we are then free 
to rewrite this formula into any number of forms, for either lazy, eager, or hybrid evacuation. Hypothetical 
queries have been studied in the logic pro­gramming community, e.g., see [GR84, GR85], and the dat­alog 
community, e.g., Hypothetical Datalog [Bon90, Bon95]. In the database context, the combination of recursion 
and hypotheticafs can lead to an increase in expressive power and/or data complexity. For example, [Bon90] 
shows that datalog (without negation) extended by hypothetical inser­tions and deletions has EXPTIME 
data complexity, an in­crease over the PTIME data complexity of datalog. The proofs of some of these 
complexity results use algorithms that involve eager, lazy, and hybrid evaluation of hypothet­ical states 
in the course of query evaluation. However, the emphasis of this work is on expressiveness and complexity, 
rather than optimization. Outline. Section 2 introduces examples that motivate the need for an equational 
theory of hypothetical queries. Sec­tions 3 and 4 develop the formal basis for our work. In par­ticular, 
a simple language called HQL is introduced. This language includes constructs for building and manipulating 
hypothetical states, and for accessing them using when. The connection between hypothetical state expressions 
and sub­stitutions is worked out in detail. A key result in this de­velopment gives the mapping of hypothetical 
queries into pure relational algebra queries. This mapping provides one method for evaluating HQL queries 
 translate HQL queries to the relational algebra and then use standard optimization techniques. Section 
5 develops a more generaf framework for opti­mizing and evaluating hypothetical queries, that incorp~ 
rates both eager and lazy evaluation of hypothetical-state expressions. This is based on an equational 
theory of ex­plicit substitutions that can be used together a conventional equational theory for the 
relational algebra to rewrite hypo­thetical queries into an optimized form. Section 6 concludes with 
general research questions. Due to space limitations, the exposition here is very terse. More details, 
and proofs of theoretical results, may be found in [GH97]. 2 Simple query and update languages This section 
presents severaf examples illustrating different strategies for evaluating hypothetical queries, and 
indicating how our approach provides a unifying framework for gener­ating these strategies. Example 2.1 
illustrates the traditional eager approach to processing hypothetical queries, a lazy approach based 
on the use of substitutions, and a hybrid in between these. Examples 2.2 and 2.3 show useful optimizations 
stemming from the perspective of substitutions. Finally, Example 2.4 shows one pitfalf of the purely 
lazy approach. Example 2.1: [Hypothetical queries usingalternatives] Con­sider an application in which 
queries against many hypo­thetical states are to be considered and compared. A tree of potential updates 
might be constructed, where each edge is labeled with an hypothetical update expression. A node w in 
the tree corresponds to the hypothetical state produced by applying all of the hypothetical update expressions 
in the path from the root to node v. One might ask the query Q = ((Q1 when m) (Qz when m)) when m where 
Q1, Q2 are relational algebra queries, qs is the hypo­thetical update expression associated with a path 
from the root to some node v, and ql and ~ are the hypothetical update expressions associated with two 
possible extensions of this path. Intuitively, Q is asking for the difference of the value of Q1 under 
hypothetical update ql vs. the value of Qz under hypothetical update rD, assuming already the hypothetical 
update qs. (a) [Eager approach] Most of the existing literature on hy­pothetical queries advocates an 
eager approach to mate­rializing hypothetical states. The basic idea is to evafuate expressions of form 
Q when q in two steps: (i) (part of) the hypothetical state specified by q is materialized, and (ii) 
the evaluation of Q is filtered through it. If nested uhen s are present, then we must be careful about 
(iii) how the evalu­ation steps are ordered. We illustrate in terms of the proto­type implementation 
of the relational Heraclitus described in [GHJ96]; a simifar approach is taken with hypothetical relations 
(e.g., [WS83]). With regards to (i), Heraclitus uses deltas to represent partially materialized hypothetical 
states. A delta holds the sets of tuples to be inserted and deleted from each relation affected by the 
hypotheticti state. For (ii), speciaLpurpose generahzations of the relational algebra operators are used 
to filter query evaluation against a delta (see Subsection 5.5). We now consider (iii). The Heraclitus 
implementation uses a run-time when stack . At any point in the compu­tation, the top of this stack essentially 
holds the materialized delta reflecting the hypothetical state that is currently be­ing used for filtering. 
We briefly indicate how this is used to evaluate Q above. First, a delta As corresponding to q3 is computed. 
Then a delta Al corresponding to ql is com­puted, by evaluating V1 filtered against the current top of 
the stack. A new delta A; is formed, that captures the net effect of As and Al, and pushed onto the stack. 
Now Q1 is evaluated, filtered against the top of the stack. The stack is popped and again pushed for 
evaluation of Q2, and finally the results of the two queries are difference. In general, a materialized 
representation of a hypotheti­cal state will become out-of-date if the underlying database state is modified. 
(b) [Lazy approach] An alternative approach, which is lazy with regards to the evacuation of hypothetical 
states, is to build relational algebra queries Q} s (QI when m ) when7N QZ = (Q2 when qz) Whenm and 
then evaluate Q; Q;. The queries Q! and Q; can be found using the framework developed in this paper. 
We illustrate this using the following query, where R and S have the same arity, Q] = Qz = R w S, and 
where the join condition is not specified. [ ((R WS) iihen {irM(R, a,o.so(S))J) ­ ((R NS) when {in9(R, 
u~>so(S ))}) ] (1) uhen {de/(S, aA<60(S))] Note that in the absence of the outer hypothetical update, 
we would expect the query to yield the non-empty result u30<A~50(S) M S. We consider now the construction 
of Q!. We begin with the query ((R WS) when {ins(~, aA>30(S))}) when {de/(S, aA<60(S))}. We replace 
the two hypothetical-state expressions using ex­plicit substitutions (see Section 3). ((R NS) when {R 
U cTA>so(S)/R]) when {S CA<60(S)/S]. We now apply the inner substitution to the query: {(RU UA>30(S)) 
~ S) When {s -UA<~o(s)/s}. Applying the second substitution we have (RU uA>30(S -OA<Go(S))) W (S -UA<,O(S)) 
s (~u UA>30(UA~60(S))) ~ (uA~60(S)) s (R UUA260(S)) CU(rTA260(S)) Analogously, query Q; can be transformed 
into (R U cTA~Go(s)) N (cTA~,, (S)). It folfows that the overall query (1) is equivalent to the empty 
query ~. Importantly, this analysis can be performed without reference to the underlying database state. 
(c) [Hybrid] In some cases, hybrids of the eager and lazy approaches may also useful. Suppose in query 
Q that the hypothetical state of q3 gives new values for relations R and S, and that the subqueries Q1 
and Qz involve many occurrences of R and S. Suppose further that, for i = 1,2, the relation names affected 
by qi occur only once or twice in Q,. In this case it may make sense to use an evaluation strategy guided 
by (QY Q;) when 93, where Q: = (Q, when 91). In this caae, V3 is evaluated eagerly, and q] and qz are 
evaluated lazily. . The next two examples describe optimizations based on the fact that hypothetical 
states can be viewed as substi­tutions. The first uses the classical operation of composing substitutions. 
Example 2.2: [Families of hypothetical queries] In some applications multiple queries might be asked 
against the same hypothetical state. (a) [Using composition] As a simple illustration, suppose that (~ 
when {ins(R, UA>30(S))}) when {de/(S, UA<61)(S))} will be asked for many queries ~. As in Example 1(b), 
we could evaluate such queries by converting to explicit substitutions (~ when {R U mA>30(S)/R~) uhen 
{S uA<60(S)/S} and then applying the two substitutions into Q. However, it might reduce work to compute 
the composition of the two substitutions, and use that composition repeatedly. As developed in Sections 
3 and 5 below, we continue the trans­formation by first using # to represent the composition of hypothetical-state 
expressions, @ when [ {S -UA<sO(S)/S} # {RU UA>30(S)/R} ], then expanding the definition of composition 
to obtain @ when {CTA2SO(S)/S, R U UA>SO(S aA<60(S))/R], and finally using algebraic simplification 
to arrive at ~ when ~uA260(S)/S, R U uA2so(S)/R~. Under a lazy strategy, theAnew substitution can be 
ap­plied to each of the queries Q. This substitution remains valid even if the underlying database state 
is changed. Un­der the eager strategy, the substitution can be (partially) materialized, and used to 
filter evaluation of the @ s. (b) [Another hybrid] To generalize a bit, suppose now that in a single 
state DB theexpression ((QI uhenql) (02 When 6)) when 773, ­ is to be evaluated with many different 
values for Q1 , Qz. and J72. In this case it might make sense to materialize part of V3 for use with 
QI when ~1, and to materialize part of n3#r/2 for use with 6. . The next example uses the classical technique 
of binding removal in substitutions. Example 2.3: [Binding removal] Suppose that many queries of the 
form ~ when {imr(lZ, c,(S)); del(S, u,(R)); ins(T, mXR)} are to be answered for different 6 s. Direct 
application of the technique of Example 2.2 suggests that the substitution {R u ap(s)/R}#{s -crq(R)/s}#{7 
u TJ(R)/T} should be computed. Suppose however that none of the queries @ will involve relation name 
S. This permits us to avoid computation of the fulf composition. In particular, the middle substitution 
can be dropped from consideration. This stems from a classical equivalence for substitutions, namely 
 sub(E, u) -sub(E, [a {t/v}]) where uisa substitution, t/v isa binding in u, and variable v is not 
free in expression E. In the case of eager evacuation this will reduce work on the underlying data, and 
in the case of lazy evahration this will reduce work in the optimizer. . The final example shows that 
transforming to a fully lazy equivalent of an hypothetical query Q can lead to an expo­nential blow-up. 
This is one motivation for exploring both lazy and eager forms of evaluation of hypothetical queries. 
We also illustrate two ways that the blow-up maybe avoided in practice. Example 2.4: Consider the query 
Q = ((... (( h when {El(I?l)/Ro]) when gE2(~)/R1}) uhen ... uhen {En(R~)/R.-I}) where for each i, E,(R, 
) is a relational algebra query whose only relation name is R,. (In the examples below, the in­tended 
arities of relations can be inferred from the context.) Note that expression Q is linear in n, and that 
the fully lazy equivalent of Q is ~d~f J%(~2(.. .( En(Rn)). ..)). (a) [Exponential blow-up] Suppose 
that expression E,(R, )is Ri xR, for each i. Then @ is exponential in n. Also, if the relations Ri are 
non-empty, then the value of red(Q) is also exponential in n. (b) [Relational algebra rewriting can help] 
Suppose that E, (R,) = R, xR, for each i except for one j, where EJ(Rl ) {R, R,/R,, ] by {Q/R,,}. Next, 
several applications of binding-removal (as in Example 2.3) will yield Q = ((... (( Ro When{E~(ll~)/&#38;]) 
when {&#38;( R2)/RI]) when .-. ) when {~/RJ l }) Now a series of compositions and binding-removals can 
now be used to obtain ... = RO when %~/RoJ G ~ (c) [Eager evaluation may win] Suppose that each Ei has 
the form rAo...An (uA,_, <oR, ) n TAo...Am(uA,>ORt)t) If these intersections are small, then an eager 
evacuation strategy will be most efficient. . 3 A Language for Simple Hypothetical Queries As mentioned, 
a key observation of this paper is that hyp~ thetical states can be represented as substitutions. In 
this section, we introduce a very simple language of hypotheti­cal states for the purpose of making this 
connection precise. The main points we want to develop here are that (1) substi­tutions can be treated 
as updates, that (2) updates can be treated as substitutions, and that (3) alf instances of when can 
be eliminated by application of substitutions. In the next section, we will apply these ideas to the 
design of a more generaf language for hypothetical queries. 3.1 Syntax and Semantics A database schema 
is a collection of relation names 2 = {z,,..., Z.}, each of a fixed arity. We assume that a database 
schema 2 is fixed for this discussion. We will use R, RJ, S, SJ to range over the names of Z. We will 
define a language with queries Q, updates U, and hypothetical queries H. Hypothetical queries H EH are 
defined by the grammar  H ::= Q when {UJ In any database state, this construct represents the value 
that Q would have in the state reached by executing update .. u. Relational algebra queries Q c RA are 
generated by the grammar Q ,,= R base relation I {t} singleton set I uAQ) selection I TX(Q) projection 
I QuQ union I Q(7Q intersection I QxQ cartesian product I QMQ join I Q-Q difference is R, R]. Then the 
size of the query @ is exponential in n, but its value is@ (the empty query). This equivalence can be 
found using the equational theory developed in Section 5. In particular, an afgebra rewriting rule can 
be nsed to replace We have included some redundancy in the operators here, because that will be usefnl 
in the context of query opti­mization. In the formaf language we use coordinate position rather than 
attribute name to identify fields of a tuple or re­lation. (However, in examples we may use attribute 
names.) We assume the nsual typing rules concerning the arities of query expressions (see [U1188]). 
Ive also omit discussion of the particular syntax for specifying selection and projection conditions. 
Simple updates U EU are generated by the grammar u ::= ins(l?, Q) insert the value of Q into R I del(R, 
Q) delete the value of Q from R / (U:u) sequence The set of all relations (of arbitrary arity) is denoted 
by R. A (database) state is a function DB mapping every relation name S E 2 to a relation DB(S) 6 ~ of 
the ap­propriate arity. The set of all database states is denoted Dt3. Each syntactic category has an 
associated semantic func­tion, DB+ R, [Q] : [u] : I?B + DE?, [H] : Ill?+ R. The semantic function [Q] 
is defined in the usual way. The function [U] is defined recursively as [ins(R, Q)](DB) = DB[R -[R U 
Q](DB)] [del(l?, Q)](DB) = DB[R -[R -Q](DB)] [( U,; UZ)](DB) = [Uz]( [UI](DB) ) Here the notation DB[R 
+-V] denotes the database state DB such that DB (R) = V and DB (S) = DB(S) when R# S. In practice, if 
a database is currently in state DB and update expression U is executed, then the database wilf move 
to state [U](DB). The semantics of hypothetical queries is simply defined as [Q rrhen{U}](DB) = [Q]([U](DB)). 
3.2 Substitutions in the abstract As we indicated in Section 2, the query Q when {U] can be simplified 
using substitutions. We now present an ab­stract theory of substitutions, similar to what can be found 
in [L1087], that wilf be used to make this connection more precise. A partial function p : 2 * WI is 
caUed a substitution if for every S c dom(p) the arity of S is equal to the arity of P(S). The set of 
all substitutions over RA is denoted by E(RA). We will use the notation p = {Q1/Sl,..., QJ/Sj}, to denote 
the substitution p where dom(p) = {S1, ....SJ} and P(S: ) = Q,. Given a substitution p and a query Q, 
the function sub(Q, p) denotes the query that results from replacing every occurrence of a name S in 
Q with the query p(S), for each S c dom(p). For any substitution p, the query sub(Q, p) is called a substitution 
instance of Q. Example 3.1: Let p = {(S R)/R, a,(R) /S} and Q = {XX(R x S)) u V. Then sub(Q, p) = (rz((S 
 R) x aJR))) U V. o Given substitutions PI and P2, we define the composition of P] and P2, denoted 
y] #1.L2, to be the unique substitution ,M such that dom(ps) = dom(pl) u dom(pz), and for any SE dom(ps), 
 sub(p2(S), /41) S c dom(p2) P3(5) = PI (s) otherwise { The use of # here is compatible with the use 
of this symbol in Heraclitus (see [GHJ96, C,H97]). The condition that dom(~l#~z) = dorrr(pl ) U dom(pz) 
is required in order to guarantee that PI #p2 is unique, as a substitution. Without this condition we 
could always pad out the substitution with bindings of the form S/S. It is eaaily verified that Lemma 
3.2: For each substitutions P1, pz, and P3, and each query Q, we have sub(Q, P1#P2) = sd(sub(Q, P2), 
Pi), and pl#(p2#p3) = (pl#p2)#v3. Example 3.3: Suppose that P1 = {(S-R)/R, u,(R)/S}, p2 = {(rr#(R M 
T))/s, ap(s)/v}. Then PI XPZ is equaf to {(S -R)/R, (rrg((S -R) N T))/S, uP(aq(R))/V}. n Remark 3.4: 
The standard mathematical notation for the composition of two functions, g : A~ B and~ : B~ C, is ~ o 
g, which denotes the unique function h : A~ C such that for every a c A we have h(a) = j(g(a)). Our use 
of the phrase the composition of p] and PZ is consistent with this in the following sense. Let ~ = Aq.sub(g, 
p) be the substitution function from RA to 7LA that applies the substitution p to its argument. Then 
we have PX.P2 = P< o ;2. In other words, for each query Q, 3.3 Substitutions as Updates The substitution 
P= {Q1/Sl,. ... QI/&#38;} can can also be viewed as an algebraic representation of the update that simultaneously 
replaces table Si with the value of query Q,. Put another way, the update represented by p executes the 
j operations Si :=Q, in parallel. To arrive at the value of sub(Q, p) in state DB, we can either evaluate 
sub(Q, p) in DB or we can execute the abstract update represented by ~ and then evaluate Q in the resulting 
state. To make this more precise, we simply define apply(DB, p) to be the database state DB such that 
R c dom(p)[AR)](DB)  D~ (@= DB(R) otherwise { Lemma 3.5: Let Q be any query and p be any substitu­tion. 
Then for every database state DB, [sub(Q, p)](DB) = [Q](app~y(DB, p)). When substitutions are viewed 
as updates, then compo­sition corresponds to sequential execution: Lemma 3.6: Let PI and IQ be substitutions. 
Then for every dat abaae state DB, apPkXDB, 1.Ll#P2) = app~y(app~~(~B, AI), 142). Remark 3.7: There 
is a subtle difference between treat­ing a substitution as a syntactic replacement and treating it as 
an update. This difference can easily lead to some con­fusion. Let ~ = M.applg(d, p) be the update function 
from DB to DB that applies the substitution as an update. The preceding lemma is telling us that IKG2 
= ;2  o ;1. If we compare this with the equation of Remark 3.4, pl#@2 = P-10;2, Example 3.11: Let 
U be the update described in Ex­ample 3.8. If Q = TX(S) D4V, then the corollary teUs us that evaluating 
Q when {U} will always be the same as evaluating sub(Q, p) = XX(S aP(R u Ql)) w V. Unlike the hypothetical 
query Q when {U], this query could be optimized using standard techniques. . 4 HQL: Hypothetical Query 
Language we see that when substitutions are viewed as updates, then the composition operator corresponds 
to composing updates functions in the opposite order that the corresponding sub­stitution functions are 
applied. It helps to remember that the first equation defines how we can realize the transition to a 
new state in two steps, whereas the second equation is telling how to anticipate the effects of this 
transition before it has actually taken place. This difference can be expressed in the equation [(z 
0 till = llQ]((F2 o fi)(DB)), which clearly illustrates the reversaL . 3.4 Updates as Substitutions 
We now go in the other direction and show that updates can be transformed into substitutions. Given an 
update U, we shall define the substitution slice(U) that has the same effect as U when it is treated 
as an abstract update. We use the name slice because it represents an operation that is similar in many 
ways to progmm slicing [HR92]. If Rc ciom(slice(U)), then we can think of the query Q = (slice(U))(R) 
as representing the slice of U that is relevant to R. Put another way, as far as R is concerned, the 
update U has the same effect as executing R:=Q. The substitution slice(U) is defined recursively as 
slice(ins(R, Q)) = {(R u Q)/R} .dice(del(R, Q)) = {(R -Q)/R} slice((Ul ;Up)) = .dice(U1)#skce(Uz) Example 
3.8: Let U= (ins(R, QI );del(S, UP(R))). Then slice(U) = dice( ins(R, Q1 ))# slice(del(S, UP(R))) = 
{(R U QI)/R}#{(S -CTp(R))/S} = {(R U @)/R, (S -CTP(RU Ql))/S}. Using Lemma 3.6 we obtain the foflowing. 
Lemma 3.9: For each update U and each database state Dl?, apply(lll?, slice(U))= [U](DB). This lemma 
and Lemma 3.5 allow us to show that a hypothetical query Q when {U] can be evaluated in the current state 
since it is equivalent to a substitution instance of Q. Theorem 3.10: Let Q be a query and U be an update. 
For each database state the 7?A query sub(Q, siice(U)) has the same value as the hypothetical query Q 
when {U]. That is, for each state DB, [Q when{ U}](DB) = [sub(Q, slice)]. The previous section demonstrates 
how (1) substitutions can be treated as updates, how (2) updates can be expressed aa substitutions, and 
how (3) hypothetical queries can be ex­pressed as substitution instances. We now introduce syntac­tic 
constructs into the query language that represent sub­stitutions and the application of suspended substitutions. 
That is, we take the meta-level functions of the previous section and add them to the language as ezpiicit 
syntactic objects. This is similar in spirit to the work of [ACCL91], where explicit substitutions are 
used to represent suspended A-reductions. 4.1 Syntax of HQL HQL will include a grammar for hypothetical-state 
expres­sions q and for explicit substitutions c. We extend the gram­mar of 9?A queries to that of l?Ahyp: 
Q ::= I Q uhen q hypothetical query That is, hypothetical queries can now occur at any nesting level 
within queries. Hypothetical-state expressions q E MS are defined by the rule explicit substitution q 
:7 iuJ hypothetical state reached by U I q#q composition while explicit substitutions c E &#38; are 
defined by the gram­mar E ::= {Q1/Sl,..., QS]]S]] j~O where the Qi are RAhYP queries and the Si are 
distinct names from 2. 4.2 Direct Semantics for HQL The direct semantics of HQL is defined by the functions 
The function [Q] is simply obtained by extending the se­mantic function defined in Section 3 with the 
equation [Q when q](DB) = [Q]([q](DB)). The function [q](DB) is defined as [.. . ,Q,/S,, . . .](DB) 
= DB[.. ~,S, -[QJ](DB), ~] [{ U]](DB) = [U](DB) [m # nl(DB) = [ml([v]l(DB)) This reflects the direct 
computational interpretation of a hypothetical-state expression. We shall now see that any q can be transformed 
into an equivalent abstract substitution. 4.3 Reduction : A Substitution Semantics for HQL We define 
a function red(q) (called reduce) that maps any partial state expression 71to an abstract substitution 
red(q) E X( ??d). In addition, we define a function red(Q) that trans­forms any Q c RAhyp into a query 
red(Q) E Rd. These functions are defined in a mutually recursive manner as fol­lows. (Here u.op denotes 
any unary algebraic operator, and b-op denotes any binary afgebraic operator. ) red(-. ., QSJ,J )-..) 
= {.. ,red(Qj)/SJ,. ..} red({U]) = 9hce(U) red(ql # v2) = red(ql )# red(qz) and red(R) =R red({t}) = 
{t} red(u-op(Q)) = u-op( red(Q)) red(Ql b-op Q2 ) = (red(QI)) b-op (red(QZ)) red(Q when V) = sub(red(Q), 
red(q)) Note that this transformation makes explicit the relation­ship between the meta-level and object-level 
constructs. It clearly illustrates the fact that hypothetical state expres­sions can be viewed as substitutions 
and that in an hypothet­ical query Q when q , the expression when q can be viewed as a suspendedsubstitu 
tion. Of course these remarks assume that the direct semantics and the reduction semantics are in agreement, 
which is proved by the following theorem. Theorem 4.1: If Q E RAhyp, then red(Q) E Rd. Fur­thermore, 
for each database state DB, each query Q E 7ZAhyp, and each hypothetical-state expression q 1 i?Ql(~~) 
= iIrMQ)M~~) z. MD~) = wMDE d~)). Note that this is a generalization of Theorem 3.10. 5 Optimization 
The reduction semantics presented in the last section pro­vides one strategy for evaluating HQL queries 
 a query Q c Rdhyp can be reduced to the query red(Q) E Rd. This allows hypothetical queries to be optimized 
using standard techniques developed for 72A. It also suggests one approach to implementing HQL on top 
of standard relational database systems. This section develops a more general framework for op­timizing 
and evaluating hypothetical queries, that incorpm rates both eager and lazy evaluation of hypotheticsd-state 
expressions. A central component of this framework is an equational theory for HQL, which is a combination 
of (1) a conventional equational theory for the relational algebra, (2) an equational theory of explicit 
substitutions, and (3) a set of equations that relate hypothetical states of the form {U} to explicit 
substitutions. The equational theory is con­sidered in Subsection 5.1. Another ingredient of the optimization 
strategy is the notion of Evaluable Normal Form (ENF). An arbitrary HQL query Q can be converted into 
one or more equivalent ENF queries Q using the equational theory as a set of rewriting rules. ENF is 
defined in Subsection 5.2. The syntax tree of an ENF query Q can be used to guide a systematic execution 
of the operators in Q . Each explicit substitution present in Q will be materialized during this execution, 
and subqueries within the scope of the explicit substitution will be filtered against that materialization. 
Thus, for a given HQL query Q, the choice of an equivalent ENF query Q is in effect the choice of how 
eager or lazy the evaluation of Q. Subsection 5.3. introduces the notion of explicit sub­stitution value 
or xsub-value . These are physical values that can be associated with explicit substitutions. Two op­erators 
involving xsub-values are also introduced. Subsection 5.4 presents two algorithms for evaluating ENF 
queries, which are based on the use of xsub-vafues. The first performs a systematic depth-first traversal 
of an ENF syntax tree. The second permits some clustered eval­uation of individual algebraic operations 
(e.g., combining a join with selects and projects immediately above or below it). If the hypothetical 
updates in an HQL query Q change only a smalf portion of the data, then it is not efficient to compute 
the full value of the associated explicit substitu­tions. Subsection 5.5 considers a generalization of 
one of the query evaluation algorithms to use delta values, in the sense of Heraclitus. 5.1 An equational 
theory for HQL This subsection presents a family of equivalences that can be used for rewriting HQL queries. 
Some of the equiva­lences stem from properties of substitutions (e.g., see [HS86, L1087]), and others 
stem from the interaction of when with the relational algebra operators. The family of equivalences involving 
constructs from HQL is called EQUIVWh~~, and is shown in Figure 1. In this figure, u-op (b.op) denotes 
an arbitrary unary (binary) re­lational algebra operator. Some definitions are needed for the rules in 
Figure 1 called substitution-simplification and commute-hypotheticals . If e is an explicit substitu­tion 
and R a relation name, then el -R denotes the explicit substitution obtained from e by deleting the binding 
with right-side R (if any). The mutually recursive definition of functions @e and dom is presented in 
Figure 2. Intuitively, fie(E) is the set of relation names occurring free in E, For hypothetical-state 
and update expressions E, dorn(E) is the set of relation names that are defined by E. In essence, these 
functions articulate the scoping rules for the when construct. It can be verified that the equations 
of EQUIVWhen are sound (proof omitted). Soundness continues to hold if equa­tions for the relational 
algebra are incorporated into the sys­tem. 5.2 Evaluable Normal Form (ENF) This subsection defines a 
normal form for HQL queries, and describes a family of syntax trees that we use to represent queries 
in this form. An HQL query is in evaluable normal ~orm (ENF) if it does not use composition (#) or expressions 
of the form{ U]. This means that all hypothetical-state expressions are in the form of explicit substitutions. 
Note that for an explicit sub­stitution of form {..., Q/R,...], the when construct may occur within Q. 
We use specialized syntax trees to represent ENF queries. Each node u of the syntax tree for an ENF query 
has a label, denoted as label(v), that is either a relational operator, or a relation name, or rrhen 
, or { } . These trees differ from conventional relational algebra trees in that (a) the uhen R when 
s ~ Q, if, E E,. and Q/REc El #?* E {Pl when zl/.S1,,.., P~ when zl/Sm, R whenE G R, ife6g,a snd R has 
no binding in E {t} when q s {t} (u.op(Q)) when v ~ u_op(Q1 when q) (QI b-op Q2) whenn s (QI whenv) 
b-op (QZ when q) push-when-into-algebTa-expressions ~in.s(R, Q)] s {del(R, Q)] . {(u,;U, )] : conved-to-ezplicit­(Q 
when ql)when q2 : {( RuQ)/R} {(R -Q)/R} {u, } #{U2} substitutions Q when (q2#q1) replace-nested-when 
(m *9)2) *n3 = n] * (rf, * 7/3) associativity Q,, IR1 . . .. Q.. IR,,II El={Q,lRI, . . ..%Y/%Y   where 
E2 = (P, /s,,..., Psm)m) {R,,,..., R,k} = dom(q) dom(e2) compute-composition Q when c . Q when el_~, 
if R @jree(Q) Q whene s Q when e/_R, if (R/R) c c Qwhen{} s Q substitution-simplification (Q when qI) 
when q2 = (Q when 17z) when qI if dorn(ql) ~ dorn(~2) = dom(ql) nfree(qz) = dom(~2) njree(ql) = @ commate-hypotheticals 
 Figure 1: The family EQUIVW~en of equivalences for HQL expressions Jree(Q) all relation names in Q if 
QE ?ZA dom(Q)=O if Q a query expression  Jree(Q when q) jree(q) U (J~ee(Q) - dom(q)) QE7?A+andq E%5 
dom(ins(R, Q))=R dom(del(R, Q))=R }ree(ins(R, Q)) jree(Q) dom((Ul;U2))=dom (Ul) U dom(C.J2) jree(del(R, 
Q)) jree(Q) free ((U, ;UZ)) jree(fll) u (jree(U2) -dom(U1))  dom({Q1/Rl, . . .. Qn/Rn})={Rl . . . ..Rn} 
dom(q1#q2)=dom(q1) u dorn(~2)  jree({Q1/R1,. . ., Qn/Rn}) U{jree(Q, ) I i E [1, n]} dom({U})=dom(U) 
jree({U]) free(U) free(~~#~~) ~ree~ql ) U (jree(~z) -dom(ql ))  Figure 2: Definition of functions fee(-) 
and dorn(.) keyword is present, as an infix binary operator, and (b) an explicit substitution {Ql /RI, 
....Qn/Rn ] is represented as follows: the parent node is labeled by I }, and has n chil­dren. For each 
i there a child corresponding to query Q:. Also, the edge to that child has label Ri. 5.3 Explicit substitution 
values Evaluation of an ENF query involves the construction of re­lations, and and of physical values 
corresponding to explicit substitutions. This subsection introduces the notion of ex­plicit substitution 
value , and describes algebraic operators that use it. In particular, we develop an equation that de­scribes 
how explicit substitution values should be combined when evrduating ENF queries with nested uhen s. In 
general, we are interested in evaluating an ENF query in the context of a fixed database state, DB. As 
defined in Section 3, the semantics of an explicit substitution e is a function from DB to DB. Thus, 
the value of E(DB) is a full database state. In practice, if a relation name R EZ is not in dom(~) there 
is no point in replicating the value of DB(R) when constructing the value of ~(DB). An ezpiicit substitu­tion 
wake, or xsub-ualue, is a (partial) function E that maps relation names in 2 into relations, where relation 
E(R) has the same arity as relation name R for each R E dom( E). We often denote an xeub-wdue as a set 
E = {J1/Rl, . . . . .7n/Rn} of binding pairs, where each .7i is a physicaJ relation. The family of xsub-values 
is denoted by &#38;SV. One basic operator involving xsub-values is apply, that maps database states and 
xsub-valuee to database states. This is defined by  E(R) if R c dorn(E)apply(DB, E)(R) = DB(R) otherwise 
{ There is a natural mapping [.]z.va~ such that for each explicit substitution e we have [c]=- ., : 
Df3 + tsv. This is defined by [{ Q1/Rl,..., Qn/R.llz-..dDB) = { UQl](DB)/RI ,..., [Qn](DB)/Rn } It 
is clear that for each query Q, explicit substitution E and state DB, applv(DB, [e]r-vai(DB)) = fEll(DB) 
 We now develop an operator for combining xsub-values, which is closely related to the compose operator 
for explicit substitutions. We call this operator smash , denoted ! , because it is analogous to the 
smash operator for delta values in Heraclitus. The smash of xsub-vahee El and E2 has domain dom(El ) 
U dom(E2), and is defined by Ez(R) if R E dom(E2) (E, !E2)(R) =  El(R) if R E dom(El) dom(Ez) { E(R) 
REdom(E) fiiterl(R, E) =  Ill?(R) R @ dom(E) { filterl(Q whene, E) = fiherl (Q, E ! filterl (e, E)) 
Figure 3: The function ~ilterl It is straightforward to verify for explicit substitutions el and EZ and 
state DB that Ikl #  521z.d~m = ~~l]z-ual(~~) ! lIe21x-vaiawh(~~, [~l]z.tJd(~~))) The following equation 
describes how smash can be used to combine nested xsub-values during the evaluation of ENF queries. For 
each query Q we have: [(Q vhenez) vhene~](DB) = [Q when (c1 # e2)](DB) = iIQl(aPP~Y(DB, [~l]z-va/(DB) 
! [ezllz-~~~applg(DB, ll~Ilx-~~/(DB)))). 5.4 Evaluation of ENF queries using xsub-values A variety of 
algorithms can be developed for evaluating ENF queries using xsub-values. This subsection presents two 
such algorithms. This first is relatively straightforward, and ex­poses the basic approach to filtering 
the evaluation of a query by an xsub-value. The second improves the first, by permitting clustered evaluation 
of relational rdgebra opera­tors (e.g., combining a join with a select). Additional algo­rithms are presented 
in [GH97]. For the first algorithm we shall use a function ~dterl with signature ~ilterl : HQL expressions 
x &#38;SV x DB + (72.U ESV). We generally assume that the database state is given by the context, and 
so omit the third argument when mentioning this function. The recursive definition of jilter] is given 
in Figure 3. In that figure, on the left side of the equality the symbols u-op and b-op are in the syntax 
of the relational algebra, and on the right side they indicate the application of algebraic operators 
to relations. The function fiiterl is constructed so that evaluating filter-l (Q, @ in state DB yields 
[Q](apply(DB, E)). Intu­itively, the function ~dter-1 does a depth-first traversal of the syntax tree 
of an ENF query Q. When encountering a when node, the right child is processed before the left child. 
The definition of ~ihe rI on individual relation names performs the actuaf filtering by an xsub-value. 
The action of filter-l on the keyword uhen has the effect of smashing together all of the xsub-values 
that affect a given subquery. (This corresponds to the behavior of the run-time when stack in the implementation 
of Heraclitus described in [GHJ+ 93].) Algorithm HQL-1. Let Q be an HQL query in ENF, and DB a state. 
The value Q in DB is obtained by evaluat­ing jiiterl (Q, { }), i.e., ~ilterl applied to Q and the empty 
xsub-value. Proposition 5.1: Algorithm HQL-I is correct. A significant weakness of Algorithm HQL-1 is 
that it does not permit grouping of relational algebra operators into single physical operations, as 
frequently occurs in traditional optimizers for relational algebra queries. For example, the algorithm 
would not permit the grouping of a join and a select in a query such as R N a(S). We now modify the algorithm 
to permit some grouping. Suppose that Q is an ENF query and T its syntax tree. The basic idea of the 
modified algorithm is to identify and collapse certain subtrees of T thatcorrespond to pure rela­tional 
algebra queries, and to permit the use of an optimized query processing algorithm on those queries. Example 
5.2: Let T be the syntax tree of query Q = (QI vhensl) ~ (R M c7(Qz when c2)). Using the collapse operator 
defined below, tree collapse(T) will have a root v labeled by SI M(R N 17(SZ)) that haa three children. 
The first child will be the root of (the tree of) Q1 uhen cl, the second child will be root of Qz when 
ez, and the third child wifl have label R. . We now define the operator collapse that maps ENF syntax 
trees into a variant of ENF syntax trees. In this variant, nodes can be labeled by relation names in 
2, by when , by { } , and by relational algebra queries of the form QISl,..., Sk, Rl, R~],R~], where 
RI,. ... R~ aredis­tinct relation names in Z and S], . . . . Sk are new relation names. A node labeled 
QIS1, . . . . Sk, RI, ....R~] wilf have k + m children. Below the first k children will be subtrees with 
root node labeled by uhen , and the remaining m chil­dren will be leaves, labeled by R1,... , R~, respectively. 
The definition of collapse is recursive on the structure of ENF syntax trees. Suppose first that ENF 
syntax tree T has structure To when {T] /R1, . . . . T*/R~J . Then collapse(T) is defined to be  collapse 
when{ coliapse(Tl )/Rl, . . . . coilapse(T~)/R~}. If ENF syntax tree T is a single node labeled by R 
EZ, then collapse(T) = T. Finally, suppose that T is an ENF syntax tree with root node v, which is labeled 
by a relational algebra operator. Lentil, ..., ILkbe the nodes below v whose labels are rela­tion names 
or when, such that each node between u and w is labeled by a relational operator. Let T1,. ...Tm be the 
sub­trees below the nodes among UI, . . . . u that have label when, and let R], ..., R,$ be the relation 
names occurring aa labels Oful, ..., u~. Let Q IS1, . ... S~, Rl, ...,Rk] denote the re­lational aJgebra 
query that corresponds to the subtree of T withroot vandleavesu1,....u~,whereS], ....S~ arenew relation 
names corresponding to subtrees TI, ..., Tm. Then collapse(T) is the tree that has root v, where the 
label of v is Q [Sl, . . .. S~. Rl, ..., Rk], v has m + k children, the first m children are the roots 
of coiiap.se(7 l ), . . . . co/lapse(T~ ), respectively. and the latter k children are leaves and are 
labeled by RI,. ...Rk, respectively. We shall also use the function ~ilterz, which is essen­tially the 
same as filterl but for collapsed trees. To describe ~ilterz, we view filter, as a mapping involving 
subtrees of ENF syntax trees (as opposed to expressions from HQL). Function filtem is identic.d to ~ilterl, 
except for its behav­ior on nodes with labels of form Qti(SI , . ., .Sm, RI, . , Rk). Suppose that rJis 
such a label, with subtrees T1, . . . . T~ be­low the first m children. For xsub-value E, we have fi/terz(Q. 
[&#38;,..., Sm, Rl, Rk], R?),-/?) = let S1 = ~ilter-z(TI, E) in letS~ = jilterz(Tm, E) in eval-~ilter_z(QISl, 
..., S*, RI,. ..,R~], E) The function evalJilter_z can be based on any conven­tional (optimized) algorithm 
for evacuating relational alge­bra queries, with the modification that each relation R, men­tioned explicitly 
in QIS1,. ... S~, RI, ..., R~] is filtered by xsub-value E (analogous to the action of ~iiterl on individ­ual 
relation names). Importantly, evai.~ilter-x might clus­ter severaf relational operators together into 
a single physicaf operator. Algorithm HQL-2. Let Q be an ENF query with syntax tree T. The value of Q 
in state DB is now computed as fiherz(collapse(T), { }). Using Proposition 5.1, the following is easily 
verified. Proposition 5.3: Algorithm HQL-2 is correct. 5.5 Generalization to use deltas Frequently, the 
hypothetical changes to a database state specified by an hypothetical update {U} will modify only a small 
fraction of the state. This observation is central to the optimizations studied in connection with both 
hypothetical relations [WS83] and Heraclitus [GH J96]. We now consider how Algorithm HQL-2 can be generalized 
to permit the use of explict delta values, following the spirit of Heraclitus. We begin by defining the 
notion of delta value, and il­lustrating how delta values can provide a substantial per­formance gain 
over xsub-values. A delta value is a (partial) function A that maps relation names in Z to pairs of re­lations, 
where the two relations in A(R) have the same ar­ity as R, for each Rc dom(A). We often denote a delta 
valueasasetA = {( Dl, Il)/R1, . . ..(D~. I~R~}~} of bind­ing pairs, where each D: and 1, is a physical 
relation. If RE dom(A) and A(R) = (D, 1), we sometimes denote D by R; and denote I by RI. Also, if R@ 
dom(A), then we define R~ =Rx =0. The family of delta valuesl is denoted by DV. One basic operator involving 
delta values is apply, that maps database states and delta values to database states. This is defined 
in anafogy to apply for xsub-vahres, by apply (DB, A)(R) = (( DB(R) Rx) U R:). 1]n Hera~]jt ~ [GHJM], 
a delta value A is rewired to ~atisfY the condition that for each R, R~nRf = 0; this condition is not 
required for the treatment here. IVe now illustrate how the use of delta values can sig­nificantly improve 
performance over the use of xsub-values. Consider a simple hypothetical query Q = (RM S) when {U]. Under 
Algorithm HQL-2, we might first transform the hy­pothetical update {U} into an explicit substitution 
of the form E= {Ql /R, Qz/S). Let DB be a database state, and suppose that the difference between DB(R) 
and [Qlj(DB) is relatively small (e.g., about l% of the size of DB(R)) and fikewise for Qz. Under Algorithm 
HQL-2 the complete val­ues of [Q1](DB) and [Qz](DB) will be computed, and the join will be performed 
using these new relations. Foflowing Heraclitus, an efficient alternative can be de­veloped by using 
special-purpose operators, that essentially combine delta application with relational algebra operators. 
For example, suppose that in state DB, the delta corre­sponding to c is A. (We ll be more specific about 
comput­ing A shortly. ) To compute RNS when c we can compute RwS when A using the join-when operator 
of Heracli­tus. (We put when in quotes, because the delta value A is a semantic object, rather than a 
syntactic object. ) This algebraic operator takes six physical relations as operands. In particular, 
join-uhen(DB(R), DB(S), Rx, Rx, S~, S~ ) computes the value of [ (DB(R) -RJ U@ ]M[ (DB(S) -S~) uS: ]. 
 But instead of computing this as most conventional SQL optimizers might, the j oin-vhen operator can 
be optimized for the case where the delta relations are relatively small. For example, one of the implementations 
of join-when de­scribed in [GH J+ 93] is a variant of the sort-merge aJgorithm for join. In this variant, 
all six operands of j oin-vhen are sorted, and the merge simultaneously tests for (i) the join condition, 
(ii) membership in R when A, and (iii) mem­bership in S when A. As discussed in [GHJ+ 93], for small 
deltas the cost of evaluating a join under a delta is only nom­inally more expensive than evaluating 
the join without the when. (As a general rule of thumb, if the delta has size ZYO of the base relations, 
then the join-when will take an additional 2270 of time over the time for a join of the base relations. 
) More generally, references [GHJ+ 93, GHJ96] describe how to use j ok-when and analogous operators to 
efficiently evaJuate hypothetical queries of the form Q when A, where Q is an arbitrarily deep relational 
algebra query. We use evai-jilter-d(Q, A) to denote the result of using such an al­gorithm. We assume 
that for each relational algebra query Q and state DB, the result of eval-jilter_d(Q, A) in DB is equal 
to [Q](apply(DB, A)). There are some trade-offs in connection with the choice of a delta value A associated 
with an explicit substitution e. One possibility, which is very precise, is that for each relation name 
RE dom(c) we set R; = DB(R) [e(R)](DB)  R: = [e(R)] (.DB) DB(R). This might be prohibitively expensive 
to evaluate. Fortu­nately, more approximate delta values can be used. We say that a delta vahre A captures 
xsubvalue E in state DB if appiy(DB, A) = appJy(DB, E). As part of our generaliza­tion of Algorithm HQL-2, 
we describe below an approach for building deltas that capture explicit substitutions, which in many 
cases will be more efficient than the precise approach just described. filter~(QIT~,..., TRl R, Rk], 
A)k], A) = let S1 = ji/tcr3(Tl , A) in letS~ = jilter3(T~, A) in eua/-jiher-d(Q[Sl , . . . . Sm, RI, 
. . . . R~], A) filters({del(Q, l?)], A) = {( fi~ters(Q, A), 0)/R} fi~ters(#ins(Q, R)], A) = {(0, filters(Q, 
A))/R} jilter3({U; Aj, A) = jilters ({U}, A) ! jilters({A], A! filier3({U], A)) jilterS(Q uhen {U}, A) 
= Figure 4: The function filters In analogy to the smzsh operator for xsubvalues, we define a smash 
operator for delta values. The smash of delta values Al and AZ, denoted Al !A2, is that delta value A 
with domain equal to dom(Al ) u dom(Az ), and such that R; = (R~, R~,)uR~, RI = (R~, R~,)u R:, for 
each R in dom(A). Let cl and cz be explicit substitutions and DE a state. If Al captures [cl]=-Va/(DB) 
in DB and Az captures [sz]=-val(applV( DB, Al)) in applg(DB, Al), then Al !Az captures [cl # .52]=-V=r(DB) 
in state DB. Fur­thermore, for each relational algebra query Q we have [(Q vhen SZ) when EI](DB) = [Q 
~hen (e, # CZ)](DB) = result of eval.~ilter-d(Q, A1!Az) in DB. This is analogous to the equation presented 
in Subsection 5.3 for explicit substitutions that relates uhen and smash, and describes how deltas should 
be combined when evrduating queries under nested rrhen s. In our generalization of Algorithm HQL-2 we 
shall use a method for computing delta values that is based on the sequence of atomic inserts and deletes 
that make up an hy­pothetical update. To this end, we modify the notion of ENF. An HQL query is in modified 
ENF ( mod-ENF) if it satisfies the definition ENF, except that instead of explicit substitutions, all 
hypothetical updates present in the query have the form {AI; ...; An}, where each Ai is an atomic insert 
or delete. We now describe Algorithm HQL-3, a generalization of Algorithm HQL-2 that uses delta values. 
The new algorithm is based on a recursively defined function ~i~ters, which is defined in Figure 4. Operator 
jilters takes two arguments: the collapse of a mod-ENF tree and a delta value. In Figure 4, A ranges 
over atomic deletes and inserts, and U ranges over update expressions of the form Al, ....An, where each 
A, is an atomic delete or insert. Of particular interest is the treatment by filter3 of hyp~ thetical 
updates of form {U}, where U = Al; ...;An where each Ai is an atomic delete or insert. It can be verified 
that if A captures xsub-value E in state DB and e is an explicit substitution equivalent to {U}, then 
f ilters({ U], A) cap tures the xsubvalue [c ] Z-val(apply(DB, E)) in state apply(DB, E). Algorithm HQL-3: 
Let Q be an mod-ENF query with syn­tax tree T. Construct collapse(T). The value of Q in state DB is now 
computed as filter3(collapse( T), { }), i.e., the application of ~ilte~s to collapse and the empty delta 
value. Using Proposition 5.3 and properties of eval-f ilter-d the following can be shown. Proposition 
5.4: Algorithm HQL-3 is correct. 6 Concluding Remarks This paper develops a framework for optimizing 
hypothet­ical queries, that allows exploration of a broad spectrum of implementation strategies from 
the purely eager to the purely lazy. The core of the framework is an equational the­ory and family of 
rewriting rules, that is analogous to and compatible with the equational theory and rewriting rules used 
for optimizing relational algebra queries. The relation­ship between the two theories is explored further 
in [GH97]. The framework developed in this paper can be used as the basis for a complete optimization 
strategy for hypothet­iczd queries. For this, several extensions will be needed, in­cluding techniques 
for estimating the cost of execution plans involving xsub-values and delta values; heuristics whereby 
optimizers can reduce the space of queries that will be con­sidered for execution (e.g., see [GI)87, 
Gra93]); and tech­niques for evaluating sequences of closely related hypothet­ical queries (as described 
in Examples 2.2. Although we have not presented the details here, it is possible to extend our framework 
along several dimensions. First, the framework extends to query languages that in­clude bags and aggregation. 
Second, the framework extends to update languages that include constructs such as con­ditionals, procedures, 
temporary tables, and aborting con­structs. Such constructs don t extend the expressive power of the 
update language, but they do dramatically incresse the conciseness with which programs can be written. 
Of course, there are limits to the direct application of our tech­niques. It may be, for some extensions 
to the update lan­guage, that Q uhen U is expressible in RA, but not ss a sub stitution instance of Q, 
or that it is simply not expressible in 72A (for similar results in the context of preconditions, see 
[BGL96]). This extended abstract hss not treated several constructs found in the Heraclitus languages. 
For example, the keyword whencan be applied to hypothetical-state expressions on the left, e.g., ql 
when ~ . Incorporating such expressions illu­minates subtleties concerning the semantics of hypothetical­states; 
these are explored in the full paper [GH97]. Acknowledgements. We would like to thank Latha Colby, Leonid 
Libkin, and Gang Zhou for their helpful comments on drafts of this paper. References <RefA>[Gra9.3] G. Graefe. 
Query evaluation techniques for large [ACCL91] [BGL96] [Bon90] [Bon95] [DHK95] [DHR96] [Dij75] [Dij76] 
[GD87] [GH97] [GHJ+93] [GHJ96] [GR84] [GR85] M. Abadi, L. Cardelli, P. Curien, and J. Levy. Explicit 
substitutions. Journal of Functional programming, 1(4):375-416, 1991. M. Benedikt, T. Griffin, and L. 
Libkln. Verifi­able properties of database transactions. In Proc.  ACM Symp. on Principles of Database 
Systems, pages 117-127, 1996. A. J. Bonner. Hypothetical datalog: Complexity and expressibility. Theoretical 
Computer Science, 76:3-51, 1990. A. J. Bonner. The logicaf semantics of hypotheti­cal rulebases with 
deletion. Journal of Logic Pro­ gramming, 1995. G. Dowek, T. Hardin, and C. Kirchner. Higher­order unification 
via explicit substitutions. In IEEE Symposium on Logic in Computer Science, pages 366-374, 1995. M. Doherty, 
R. Hull, and M. Rupawalla. Struc­tures for manipulating proposed updates in object-oriented databases. 
In Proc. ACM SIG-MOD Symp. on the Management of Data, pages 306-317, 1996. E. W. Dijkstra. Guarded commands, 
nonde­terminacy and formal derivations of programs. Comm. ACM, 18:453-457, 1975. E. W. Dijkstra. A Discipline 
of Programming. Prentice-Hall, 1976. G. Graefe and D. J. DeWitt. The EXODUS optimizer generator. In Proc. 
ACM SIGMOD Symp. on the Management of Data, pages 160­172, 1987. T. Griffin and R. Hull. A framework 
for imple­menting hypothetical queries. Technical report, Bell Laboratories, Lucent Technologies, 1997. 
In preparation. S. Ghandeharizadeh, R. Hull, D. Jacobs, et aL On implementing a language for specifying 
ac­tive database execution models. In Proc. of Inti. Conf. on Very Large Data Bases, pages 441-454, 1993. 
S. Ghandeharizadeh, R. Hull, and D. Jacobs. Heraclitus: Elevating deltas to be first-class citizens in 
a database programming language. ACM Trans. on Database Systems, 21(3):370­426, 1996. D. M. Gabbay and 
U. Reyle. N-Prolog: An ex­tension of prolog with hypothetical implications. I. Journal of Logic Programming, 
1(4):319-355, 1984. D. M. Gabbay and U. Reyle. N-Prolog: An extension of prolog with hypothetical implica­tions. 
II: Logicaf foundations and negation as fail­ure. .lournal of Logic Programming, 2(4):251­283, 1985. 
 [Gri81] [HR92] [HS86] [Les94] [L1087] [Qia90] [Qia91] [u f188] [WS83] databases. .-IC.V Computing Surteys, 
25(2):73­170, 199:3. David Gries. The Science of Programming. Springer-Verlag, 1981. S. Horwitz and T. 
Reps. The use of program dependence graphs in software engineering. In Proceedings of the Idth International 
Conference on Software Engineering, 1992. J. R. Hindley and J. P. Seldin. Introduction to Combinators 
and A-Calculus. Cambridge Univer­sity Press, 1986. P. Lescanne. From Au to Av -a journey through calculi 
of explicit substitutions. In ACM SIGPLA N-SIGA CT Symposium in Principles of Programming Languages (POPL), 
pages 60-69, 1994. J. W. Lloyd. Foundations of Logic Programming (Second Edition). Springer-Verlag, Berlin, 
1987. X. Qian. An axiom system for database trans­actions. Information Processing Letters, 36: 183 189, 
1990. X. Qian. The expressive power of the bounded­iteration construct. Acts Informatica, 28(7) :631 
656, October 1991. Jeffrey D. Unman. Principles of Database and Knowledgebase Systems, Vol. I. Computer 
Sci­ence Press, Potomac, Maryland, 1988. J. Woodfill and M. Stonebraker. An implemen­tation of hypothetical 
relations. In Proc. of Ml. Conf. on Very Large Data Bases, pages 157-165, September 1983.</RefA>  
			

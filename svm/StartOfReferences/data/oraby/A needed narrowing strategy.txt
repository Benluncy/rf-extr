
 A Needed Narrowing Strategy Sergio Antoy Rachid Echahed Michael Hanus Dept. of Computer Science IMAG-LGI 
MPI Informatik Portland State University CNRS Im Stadtwald Portland, OR 97207 F-38041 Grenoble D-66123 
Saarbriicken U.S.A. France Germany antoy@cs .pdx. edu echahed@imag. f r michael@mpi-sb. mpg. de Abstract 
Narrowing is the operational principle of languages that integrate functional and logic programming. 
We pro­pose a notion of a needed narrowing step that, for in­ductively sequential rewrite systems, extends 
the Huet and Lkvy notion of a needed reduction step. We de­fine a strategy, based on this notion, that 
computes only needed narrowing steps. Our strategy is sound and complete for a large class of rewrite 
systems, is op­timal w.r.t. the cost measure that counts the number of distinct steps of a derivation, 
computes only indepen­dent unifiers, and is efficiently implemented by pattern mat thing. Introduction 
In recent years, most proposals with a sound and com­ plete operational semantics for the integration 
of func­ tional and logic programming languages [5, 10] were based on narrowing, e.g., [6, 1.5, 17, 19, 
37, 44]. Narrow­ing, originally introduced in automated theorem proving [46], solves equations by computing 
unifiers with respect to an equational theory [14]. Informally, narrowing uni­ fies a term with the left-hand 
side of a rewrite rule and fires the rule on the instantiated term. Example 1 Consider the following 
rewrite rules defin­ ing the operations less than or equal to and addition for natural numbers, which 
are represented by terms built with O and s; O<x -true RI s(X) < 0 -+ false R2 5(X) <S(Y) -X <Y R3 O+x+x 
R4 s(X) +Y -s(X +Y) R5 Permission to COPY without fee all or part of this material is granted provided 
that the copies are not m8de or distributed for direct commercial adventaga, the ACM copyright notice 
end the title of the publication and ita date appear, and notice ie given that copying ia by permission 
of the Association for Computing Mnchinery. TO copy otherwise, or to republish, requires a fee end/or 
specific permission. POPL 94-liT34, Portland Oregon, USA @ 1994 ACM 0-89791 -636-9B4fOOl ..$3.50 The 
rules of < will be used in following examples. To narrow the equation Z + s(0) N s(s(0)), rule R5 is 
applied by instantiating Z to s(X). To narrow the resulting equation, s(X + s(0)) = s(s(0)), R4 is ap­ 
plied by instantiating X to O. The resulting equation, s(s(0)) w s(s(0)), is trivially true. Thus, {Z 
~ s(0)} is the equation s solution. A brute-force approach to finding all the solutions of an equation 
would attempt to unify each rule with each non-variable subterm of the given equation. The result­ing 
search space would be huge even for small rewrite programs. Therefore, many narrowing strategies for 
limiting the size of the search space have been pro­posed, e.g., basic [25], innermost [15], outermost 
[12], outer [49], lazy [9, 36, 44], or narrowing with redun­dancy tests [3 I]. Each strategy demands 
certain condi­tions of the rewrite relation to ensure the completeness of narrowing (the ability to compute 
all the solutions of an equation.) Our contribution is a strategy that, for induct avely se­quential 
systems [1], preserves the completeness of nar­rowing and performs only steps that are unavoidable for 
solving equations. This characterization leads to the optimality of our strategy with respect to the 
number of distinct steps of a derivation. Advantages of our strategy over existing ones include: the 
large class of rewrite systems to which it is applicable, both the op­timality of the derivations and 
the independence of the unifiers it computes, and the ease of its implementation. The notion of an unavoidable 
step is well-known for rewriting. Or-thogonal systems have the property that in every term t not in normal 
form there exists a re­dex, called needed, that must eventually be reduced to compute the normal form 
of t~24, 30, 39]. Further­more, repeated rewriting of needed redexes in a term suffices to compute its 
normal form, if it exists. Loosely speaking, only needed redexes really matter for rewrit­ing in orthogonal 
systems. We extend this fact to nar­rowing in inductively sequential systems, a subclass of the orthogonal 
systems. Restricting our discussion to this subclass is not a limitation for the use of narrowing in 
programming lan­guages. Computing a needed redex in a term is an un­solvable problem. Strongly sequential 
systems are, in practice, the largest class for which the problem be­comes solvable. Inductively sequential 
systems are a large constructor-based subclass of the strongly sequen­tial systems. After some preliminaries 
in Section 2, we present our strategy in Section 3. We formulate the soundness and completeness results 
in Section 4. We address our strat­egy s optimality in Section 5. We compare related work in Section 
6. Our conclusion is in Section 7. Due to lack of space we omit the proofs of the theorems, but the interested 
reader will find them in [3]. 2 Preliminaries We recall some key notions and notations about rewrit­ 
ing. See [11, 29] for tutorials. Terms are constructed w.r.t. a given many-sorted sig­nature Z. We write 
Par(t) for the set of variables occur­ring in a term t.Equational logic programs are gener­ally constructor-based, 
i.e., symbols, called constructors, that construct data terms are distinguished from those, called defined 
functtons or operations, that operate on data terms (see, for instance, the Equational Interpreter [40] 
and the functional logic languages ALF [19], BA-BEL [37], K-LEAF [16], LPG [6], SLOG [15]). Hence, we 
assume that K? is a constructor-based term rewrztmg system consisting of rewrite rules of the form 1 
-+ r, where 1 is an innermost term, i.e., the root of ! is an operation and the arguments of 1 do not 
contain any operation symbol. Substitutions and unifiers are defined as usual [1 1], where we write mgu(s, 
t) for the most general unajier of s and t. We write a < a [V] iff there is a substitution ~ with a (x) 
= ~(a(z)) for all variables z c V. Two sub­stitutions n and a are independent on a set of variables V 
iff there exists some z c V such that a(x) and o- (z) are not unifiable. An occurrence or positzon p 
is a path identifying a sub term in a term. t1Pdenotes the sub term oft at posi­tion p, and t[s]P denotes 
the result of replacing t 1P with s in t. A term rewriting system %? is orthogonal if for each rule 1 
-+ r c 72 the left-hand side i does not contain multiple occurrences of one variable ( Ieft-iineartty) 
and for each non-variable subterm /lP of/ there exists no rule 1 -+ r E R such that llP and 1 unify (non-overlapping). 
A rewrite step t -+P, l-+. s is the application of the rule 1-r to the redez tlP, i.e., s = t[a(r)]P 
for some sub­stitution a with t]p= u(i).A term is in normal form if it cannot be rewritten. Functional 
logic programs compute with partial information, i.e., a functional ex­pression may contain logical variables. 
The goal is to compute values for these variables such that the expres­sion is evaluable to a particular 
normal form, e.g., a constructor term [16, 37]. This is done by narrowing. Definition 1 A term t is narrowable 
to a terms if there exist a non-variable position p in t (i.e., t 1P is not a variable), a variant 1 
-+ r of a rewrite rule in 7? with Var(t) n Var(l -+ r) = 0 and a unifier u of t1Pand 1 such that s= u(t[r]p).this 
case we write t -P, In I+,, aS. If u is a most general unifier of tlpand i, the narrowing step is called 
most generai. We write to~. tnif there is a narrowing sequence to ~p,, RI, ~1 1 P2, R2, c2 . ..+ t~withu 
=u~o. ..ouzool. P~,&#38;,u* Since the instantiation of the variables in the rule 1 -+ r by u is not 
relevant for the computed result of a narrow­ing derivation, we will omit this part of a in the example 
derivations in this paper. Example 2 Referring to Example 1, A + B ~A,~,,{~W,(0),~~~} s(O + O) and are 
narrowing steps of A + 1?, but only the latter is a most general narrowing step. Padawitz [42] too distinguishes 
between narrowing and most general narrowing, but in most papers narrowing is intended as most general 
narrowing (e.g., [25]). Most general narrowing has the advantage that most general unifiers are uniquely 
computable, whereas there exist many independent unifiers. Dropping the requirement that unifiers be 
most general is crucial to the defini­tion of needed narrowing step, since these steps may be impossible 
with most general unifiers. Narrowing solves equations, i.e., computes values for the variables in an 
equation such that the equation be­comes true, where an equatton is a pair t= t of terms of the same 
sort. Since we do not require terminating term rewriting systems, normal forms may not exist. Hence, 
we define the validity of an equation as a strict equal­ity on terms in the spirit of functional logic 
languages with a lazy operational semantics such as K-LEAF [16] and BABEL [37]. Thus, a substitution 
u is a solutlon for an equation tN t iff u(t) and a(t )are reducible to a same ground constructor term. 
Equations can also be interpreted as terms by defining the symbol x as a binary operation symbol, more 
precisely, one operation symbol for each sort. Therefore all notions for terms, such as substitution, 
rewriting, narrowing etc., will also be used for equations. The semantics of% is defined by the following 
rules, where A is assumed to be a right­associative infix symbol, and c is a constructor of arity 0 in 
the first rule and arity n >0 is the second rule. CX5C -true C(Xl,..., Xn)XC(yl, Yn), Yn) ~ A;=l(&#38;zxfi) 
trueAX -X These are the equalzty rules of a signature. It is easy to see that the orthogonality status 
of a rewrite system is not changed by these rules. The same holds true for the inductive sequentiality, 
which will be defined shortly. With these rules a solution of an equation is computed by narrowing it 
to true an approach also taken in A -LEAF [16] and BABEL [37]. The equivalence between the reducibility 
to a same ground constructor term and the reducibility to true using the equality rules is ad­dressed 
by Proposition 1. Our strategy extends to narrowing the rewriting no­tion of need. The idea, for rewriting, 
is to reduce in a term only certain redexes which must be reduced to compute the normal form of t. In 
orthogonal term rewriting systems, every term not in normal form has a redex that must be reduced to 
compute the term s nor­mal form. The following definition [24] formalizes this idea. Definition 2 Let 
A = t --+U,/+, t be a rewrite step of some term tinto t at position u with rule i ~ r. The set of descendants 
(or restduals) of a position v by A, denoted v \ A, is I ifu=v, :V} ifu$v, v \ A = {upfq such that rlP, 
= z} ifv=upq and llP=x, where z is a variable. The set of descendants of a position v by a rewrite derivation 
B is defined by induction as follows {v} if B= f), v\B= { uve~l~ ~ \ B if B = B B//, A position u of 
a term t is called needed iff in every rewrite derivation oft to a normal form a descendant of tluis 
rewritten at its root. A position uniquely identifies a subterm of a term. The notion of descendant for 
terms stems directly from the corresponding notion for positions. A more intuitive definition of descendant 
of a position or term is proposed in [30]. Let tL t be a reduction sequence and s a sub term of t. The 
descendants of s in t are computed as follows: Underline the root of s and perform the reduction sequence 
tL t .Then, every subterm oft with an underlined root is a descendant of s. Example 3 Consider the operation 
that doubles its ar­gument by means of an addition. The rules of addition are in Example 1. double(X) 
~ X + X R6 In the following reduction of double( O + O) we show, by means of underlining, the descendants 
of O + O. doubie(O + O) +L,~~ (O + O)+ (O&#38;O) The set of descendants of position 1 by the above re­duction 
is {1, 2}.  3 Outermost-needed narrowing An efficient narrowing strategy must limit the search space. 
No suitable rule can be ignored, but some posi­tions in a term may be neglected without losing com­pleteness. 
For instance, Hullot [25] has introduced 6a­sic narrowing, where narrowing is not applied at po­sitions 
introduced by substitutions, Fribourg [15] has proposed tnnermost narrowang, where narrowing is ap­plied 
only at an innermost position, and Holldobler [22] has combined innermost and basic narrowing. Narrow­ing 
only at outermost positions is complete only if the rewrite system satisfies strong restrictions such 
as non­unifiability of subterms of the left-hand sides of rewrite rules [12]. Lazy narrowing [9, 36, 
44], akin to lazy eval­uation in functional languages, attempts to avoid un­necessary evaluations of 
expressions. A lazy narrowing step is applied at outermost positions with the excep­tion that inner arguments 
of a function are evaluated, by narrowing them to their head normal forms, if their values are required 
for an outermost narrowing step. Unfortunately, the property required depends on the rules tried in following 
steps, and looking-ahead is not a viable option. We want to perform only narrowing steps that are necessary 
for computing solutions. Naively, one could say that a narrowing step t-+P,/_+r,t is needed iff p is 
~ a position of t,u is the most general unifier of t1Pand 1, and a(tlp)is a needed redex. Unfortunately, 
a sub­stantial complication arises from this simple approach. If t is a normal form, the step is trivially 
needed. How­ever, some instantiation performed later in the deriva­tion could <undo this need. Example 
4 Referring to Example 1, consider the term t = X < Y + Z. According to the naive approach, the following 
narrowing step oft at position 2 would be needed, since X < Z is a normal form. This step is indeed necessary 
to solve the inequality if s(x), for some term x, is eventually substituted for X, al­though this claim 
may not be obvious without the re­sults presented in this note. However, the same step becomes unnecessary 
if O is substituted for X, as shown by the following derivation, which computes a more gen­eral solution 
of the inequation without ever narrowing any descendant of tat 2. Thus, in our definition, we impose 
a condition strong enough to ensure the necessity of a narrowing step, no matter which unifiers might 
be used later in the deriva­tion. Definition 3 A narrowing step t +P, B, ~ t is called needed or outemnost-neede 
cliff, for every q > u, pis the position of a needed or outermost-needed redex of q(t), respectively. 
A narrowing derivation is called needed or outermosi-needed iff every step of the derivation is needed 
or outermost-needed, respectively. Our definition adds, with respect to rewriting, a new di­mension to 
the difficulty of computing needed narrowing steps. We must take into account any instantiation of a 
term in addition to any derivation to normal form. Luckily, as for rewriting, the problem has an efficient 
solution in inductively sequential systems. We forgo the requirement that the unifier of a narrowing 
step be most general. The instantiation that we demand in ad­dition to that for the most general unification 
ensures the need of the position irrespective of future unifiers. It turns out that this extra instantiation 
would eventu­ally be performed later in the derivation. Thus we are only anticipating it, and the completeness 
of narrow­ing is preserved. This approach, however, complicates the notion of narrowing strategy. According 
to [12, 42], a narrowing strategy is a func­ tion from terms into non-variable positions in these terms 
so that exactly one position is selected for the next narrowing step. Unfortunately, this notion of nar­ 
 rowing strategy is inadequate for narrowing with arbi­trary unifiers, which, as Example 4 shows, are 
essential to capture the need of a narrowing step. Definition 4 A narrowing strategy is a function from 
terms into sets of triples. If S is a narrowing strategy, t is a term, and (p, 1 --+ r, u) G S(t), then 
p is a position of t,1-+ r is a rewrite rule, and u a substitution such that t-+P,/+,,.u(t[r]p)a narrowing 
step. is We now define a class of rewrite systems for which there exists an efficiently computable needed 
narrowing strat­egy. Systems in this class have the property that the rules defining any operation can 
be organized in a hi­erarchical structure called definitional tree [1], which is used to implement needed 
rewriting. This note gener­alizes that result to narrowing. The symbols branch, rule, and exempt, used 
in the next definition, are uninterpreted functions used to clas­sify the nodes of the tree. A pattern 
is an innermost term contained in each node. Definition 5 T is a partial definitional tree, or pdt, with 
pattern m w.r. t. a constructor-based rewrite sys­tem 72 iff one of the following cases holds: 7= branch(n, 
o, TI, . . . . 7k), where T is a pattern, o is the occurrence of a variable of ~, the sort of ml~ has 
constructors cl, ..., c~, for some k > 0, and foralliin {l,..., k}, Z is a pdt with pattern 7r[c~(Xl, 
..., X~)]~, where n is the arity of Ci and XI, . . . . X~ are new variables. T= rule(~, 1 + r), where 
r is a pattern and 1-r is a rewrite rule in K! such that I = x. T= ezempt(~), where r is a pattern and 
1$ ~ for every rule 1 + r in 7?. T is a dejinitionai tree of an operation f iff 7 is a pdt with f(X1, 
. . . . X.) as the pattern argument, where n is the arity of f and Xl, ....X~ are new variables. We call 
inductively sequential an operation f of a rewrite system 72 iff there exists a definitional tree 7 off 
such that the rules contained in 7 are all and only the rules defining f in %?. We call inductively sequential 
a rewrite system Z? iff any operation of R is inductively sequential. Example 5 We show a pictorial representations 
of def­initional trees of the operations defined in Example 1. A branch node of the picture shows the 
pattern of a cor­responding node of the definitional tree. A leaf node of the picture shows the right 
sides of a rule contained in a rule node of the tree. The occurrence argument of a branch node is shown 
by emboldening the corresponding subterm in the pattern argument. Y1 + Y2 0+Y2 S(Y3) + Y2 Y2 S(Y3 + Y2) 
05X2 S(X3) < X2 true S(X3) <0 S(X3) < S(X4) I false Inductively sequential systems are constructor-based 
and strongly sequential [1]. We conjecture that these two classes are the same. Inductively sequential 
systems model the first-order functional component of program­ ming languages, euch as ML and Iilaske!i, 
that establish priorities among rules by textual precedence or speci­ ficity [28]. We now give an informal 
account of our strategy. The patterns of a definitional tree are a finite set par­tially ordered by the 
subsumption preordering and com­plete in the sense of [23]. Let t = .f(tl, . . . . t~) be a term to narrow. 
We unify t with some maximal element of the set of patterns of a definitional tree of ~. Let T de­note 
such a pattern, ~ the most general unifier of tand r, and T the pdt in which ~ is contained. If T is 
a rule pdt, then we narrow r(t)at the root with the rule con­tained in 7. If T is an exempt pdt, then 
r(t)cannot be narrowed to a constructor-rooted term. If T is a branch pdt, then we recur on ~(t I~), 
where o is the occurrence contained in T and r is the anttctpated substitution. The result of the recursive 
invocation is suitably com­posed with ~ and o. The details of this composition are in the formal definition 
presented below. We derive our outermost-needed strategy from a mapping, J, that implements the above 
computation. A takes two arguments, an operation-rooted term t and a definitional tree T of the root 
of t,and non­deterministically returns a triple, (P, R, u), where P is a position of t,R is either a 
rule 1 -+ r of Ill or the distinguished symbol ? , and a is a substitution. If R = 1 + r, then our strategy 
performs the narrowing step t-P,I+T,O u(t[~]p).If R = ?, then our strat­egy gives up, since it is impossible 
to narrow t to a constructor-rooted term. In the following definition, pattern(7) denotes the pattern 
argument of T. Definition 6 The function A takes two arguments, an operation-rooted term t and a pdt 
T such that pattern(T) and t unify. The function J yields a set of triples of the form (p, R, a), where 
p is a position of t,R is either a rewrite rule or the distinguished symbol ? , and u is a unifier of 
pattern(7) and t.Thus, let t be a term and T a pdt in the domain of J. The func­ tion J is defined by 
strong arithmetical induction on the number of occurrences of operation symbols in tand by structural 
induction on 7 in Figure 1. The function A is well-defined in the third case since, by the defini­ tion 
of pdt, there exists a proper subpdt ~ of T such that pattern(~) and tunify if tlois constructor-rooted 
or a variable. Similarly, A is well-defined in the fourth case since this case can only occur if t 10 
is operation­ rooted. In this case ~var(t~ is a constructor substitution since T is a linear innermost 
term. Since tis operation­ rooted and o # A, r(tlo) has fewer occurrences of oper­ ation symbols than 
t.Since tlois operation-rooted, so is ~(t 10). By the definition of pdt, pattern s ~(t 10), i.e., pattern 
and r(tl.)unify. This implies that J is well-defined in this case too. As in proof procedures for logic 
programming, we have to apply vartants of the rewrite rules wzth fresh var~ables to the current term. 
Therefore, we assume in the fol­ lowing that the definitional trees contain new variables if they are 
used in a narrowing step. The computation of A(i!, 7) may entail a non-deter­ministic choice when 1 
is a branch pdt the integer i when t[0is constructor-rooted or a variable. The substi­tution r when tlois 
operation-rooted is the anticipated substitution guaranteeing the need of the computed po­sition. It 
is pushed down in the recursive call to A to ensure the consistency of the computation when t is non­linear. 
The anticipated substitution is neglected when t10is not operation-rooted, since the pattern in z is 
an instance of r. Hence, a extends the anticipated substi­tution. Example 6 We trace the computation 
of A for the ini­ tial step of a derivation of X < Y + Z, which was dis­ cussed in Example 4. A(X < 
Y + Z, branch(Xl < x2,1, . .)) A(X < Y + Z, branch(s(X3) < X2,2,.. .)) A(Y + Z, branch(Y~ + Yz, 1,.. 
.)) A(Y + Z, rule(O + Y2, Rq)) (A, R,, {Y ~ O,YZ E+ Z}) (A, RA, {Y i-+ O,YZ ~ Z}) (2, R4, {X * s(X3), 
X2 ~ O+Z, Y ~ 07Yz ~ Z}) (2, R4, {X ~ s(xs),xz ~ O+Z, Y w O,YZ I-+ Z}) We are interested only in narrowing 
derivations that end in a constructor term. Our key result is that if ~, on input of a term t,computes 
a position p and a substitu­tion u, and q extends u, then q(t)must eventually be narrowed at p to obtain 
a constructor term. Eventu­ally is formalized by the notion of descendant, which, initially proposed 
for rewriting [24], is extended to nar­rowing simply by replacing -+U, 1+~ with +U, 1+~, m in Definition 
2. Theorem 1 Let R be an ~nductively sequential rewrite system, t an opera tzon-rooted term, and T a 
dejintttona! tree of the root oft. Let (p, R, a) G A(t, T) and q extend IY, 2.e., ~ > u. 1. In any narrowing 
derivation of q(t) to a construc­tor-rooted term a descendant of q(t/P) is narrowed to a constructor-rooted 
term. 2. If R = i + r, then t *P,R,c u(t[r]P) 2s an outer­most-needed narrowing step. 3. If R = ?, 
then ~(t) cannot be narrowed to a con­structor-rooted term.  We say that a narrowing derivation is computed 
by A iff for each step t P,R,.t of the derivation, (p, R, u) belongs to A(t, T).The function A implements 
our nar­rowing strategy as discussed next. The theorem shows (claim 2) that our strategy A computes only 
outermost­needed narrowing steps. The theorem, however, does not show that the computation succeeds, 
i.e., a narrow­ing step is computed for any operation-rooted, hence ex­pectedly narrowable, term. This 
requirement may seem essential, since to narrow a term all the way a strategy should compute a narrowing 
step, when one exists. In­deed, in incomplete rewrite systems, A may fail to com­pute any narrowing step 
even when some step could be computed. (A, R, rngu(t, m)) if T = rule(m, R); (A, ?, rngu(f, T)) if T 
= exempt(m); (p, R, o) if T = branch(~, o,T1, . . ., Tk), t and pattern(z) unify, for some i, and A(t,7-) 
3 (p, R,u) c A(t, Z); (op,R,uo~) if T = branch(fi, o, Tl, . . . . Tk), t and pattern(~) do not unify, 
for any i, 7-= mgu(t, n), T is a definitional tree of the root of r(tlo),and (p, R, u) G A(r(tlo), T 
). Figure 1: Definition of A Example 7 Consider an incompletely defined opera­ tion, j, taking and returning 
a natural number. f(o) -+ o The term t= f(s(f(0))) can be narrowed (actually rewritten, since it is 
ground) to its normal form, f (s(0)). The only redex position of t is 1.1, but A returns the set {(l,?,{})}. 
The inability of ~ to compute certain outermost-needed narrowing steps is a blessing in disguise. The 
theorem (claim 3) justifies giving up a narrowing attempt as soon as the failure to find a rule occurs 
without further at­tempts to narrow t at other positions with the hope that a different rule might be 
found after other nar­rowing steps or that the position might be deleted [7] by another narrowing step. 
If (p,?, m) G A(t, T), no equation having u(t) as one side can be solved. Any amount of work applied 
toward finding a solution would be wasted. This is an opportunity for optimization. In fact a(t) may 
be narrowable at other positions different from p and an equation with a(t) as a side may even have an 
infinite search space. However, any amount of work applied toward finding a solution would be wasted. 
Example 8 Consider the following term rewriting sys­tem for subtraction: x o-+x RI s(X) s(Y) ~ X Y R2 
 This term rewriting system is inductively sequential and a definitional tree, T, of the operation - 
has an ez­empt node for the pattern O s(X), i.e., the system is incomplete and (A, ?, {}) G A(O S(X), 
T). Therefore we can immediately stop the needed narrowing derivation of the equation O s(X) x Y Z 
while there would be infinitely many narrowing derivations for the right-hand side of this equation. 
The definition of our outermost-needed narrowing strat­egy does not determine the computation space for 
a given inductively sequential rewrite system in a unique way. The concrete strategy depends on the definitional 
trees, and there is some freedom to construct these. For a discussion on how to compute definitional 
trees from rewrite rules and the implications of some non­deterministic choices of this computation see 
[1]. As we will show in Section 5, this does not affect the op­timality of our strategy w .r. t. computed 
solutions. But in case of failing derivations a definitional tree which is unnecessarily large could 
result in unnecessary deriva­tion steps. E.g., a minimal definitional tree of the operation <c in Example 
8 has an ererrzpt node for the pattern O s(X). However, Definition 5 also allows a defini­tional tree 
with a branch node for the pattern O s(X) which has ezernpt nodes for the patterns O s(0) and O S(S(X1 
)). Our strategy would perform some un­necessary steps if this definitional tree were used for narrowing 
the term O s(t), where t is an operation­rooted term. These unnecessary steps can be avoided if all 
branch nodes in a definitional tree are useful, i.e., there is at least one rule node in each branch 
subpdt. However, the non-determinism of the trees of certain operations makes it possible that some work 
may be wasted when a narrowing derivation computed by A terminates with a non-constructor term. The problem 
seems inevitable and is due to the inherent parallelism of certain operations, such as %; this issue 
is discussed in some depth in [1, Display (8)]. The problem occurs only in terms with two or more outermost-needed 
nar­rowing positions, one of which cannot be narrowed to a constructor-rooted term. 4 Soundness and 
completeness Outermost-needed narrowing is a sound and complete procedure to solve equations if we add 
the equality rules to narrow equations to true. The following proposition shows the equivalence between 
the reducibility to a same ground constructor term and the reducibility to true using the equality rules. 
Proposition 1 Let R be a term rewriting system with­ out rules for z and A. Let R be the system obtained 
by adding the equality rules to 1?. The following propo­ stt~ons are equivalent for all terms t and t!: 
1. t and t are reducible m R to a same ground con­structor term. 2. t z t M reducible in R to true , 
 The soundness of outermost-needed narrowing is easy to prove, since outermost-needed narrowing is a 
special case of general narrowing. Theorem 2 (Soundness of outermost-needed narrow­ ing) Let %? be an 
inductively sequential rewrite system extended by the equality rules. If t z tl $0 true is an outermost-needed 
narrowing derwation, then ~ M a solutton for t $3 t . Outermost-needed narrowing instantiates variables 
to constructor terms. Thus, we only show that outermost­needed narrowing is complete for constructor 
substitu­tions as solutions of equations. This is not a limitation in practice, since more general solutions 
would contain unevaluated or undefined expressions. This is not a lim­itation with respect to related 
work, since most general narrowing is known to be complete only for irreducible solutions [42], and lazy 
narrowing is complete only for constructor substitutions [16, 37]. The following the­orem shows the completeness 
of our strategy, A, and consequently of outermost-needed narrowing. Theorem 3 (Completeness of outermost-needed 
nar­rowing) Let R be an inductively sequential rewrite sys­tem extended by the equahty rules. Let o be 
a con­structor substitution that M a solutton of an equatzon t c t and V be a finite set of variables 
contai­ning Var(t) U Var(t ). Then there exxsts a derivation t E t SCJ true computed by A such that a 
< CT[V]. The theorem justifies our earlier remark on the rela­tionship between completeness and anticipated 
substi­tutions. Any anticipated substitution of a needed nar­rowing step is irrelevant or would eventually 
be done later in the derivation, and thus, it does not affect the completeness. Anticipating substitutions 
is appeal­ing, even without the benefits related to the need of a step, since less general substitutions 
are likely to yield a smaller search space to compute the same set of solu­tions.  5 Optimalit y In 
Section 3 we showed that our strategy computes only necessary steps. We now strengthen this characteriza­ 
tion by showing that our strategy computes only neces­ sary derivations of minumum length. The next theorem 
claims that no redundant derivation is computed by A. Theorem 4 (Independence of solutions) Let 72 be 
an inductively sequential rewrite system extended by the equality rules, e an equation to solve and V 
= Var(e). Let e ~. true and e ~vl true be two dwttnct derwa­ tions computed by A. Then, u and CT are 
independent on V. We now discuss the cost and length of a derivation computed by our strategy. If p is 
a needed po$ition of some term t,then in any narrowing derivation of tto a constructor term there is 
at least one step associated with p. If this step is de­layed and p is not outermost, then several descendants 
of p may be created and several steps may become nec­essary to narrow this set of descendants, e.g., 
see Ex­ample 3. However, from a practical standpoint, if terms are appropriately represented, the cost 
of narrowing tat (some descendant of) p is largely independent of where the step occurs in the derivation 
oft. We formalize this viewpoint, which leads to another optimality result for our strategy. Definition 
7 Let t --+P,,a, t ,for i in some set i,+r,,of zndices I = {l,...,n}, be a narrowing step such that for 
any distinct i and j in 1, pi and @ are dis­joint and Ui ov~ = ~~ oUi. We say that t is narrow­able to 
t m a multistep, denoted t -{P,,lt.+~z,o~),el t , iff t = o ~E1 ui(((t[rl]P1 )[r2]P2) . . . [rn]P~), 
where o ~e~ a; denotes the composition Uri 0 ...0 U2 0 al (the order is irrelevant. ) When we want to 
emphasize the difference between a step as defined in Definition 1 and a multistep, we re­fer to the 
former as elementary. Otherwise, we identify an elementary step with a multistep in which the set of 
narrowed positions has just one element. A narrowing multistep can be thought of as a set of elementary 
steps performed in parallel. In fact, the conditions that we impose on the positions and substitutions 
of each ele­ mentary step from which a multistep is defined imply that in a multistep the order in which 
substitutions are composed and positions are narrowed is irrelevant. To claim that our strategy is optimal, 
we assign a (cost to both a step and a derivation. By convention, an elementary step has unit cost. However, 
it does not seem appropriate, for practical reasons, to set the cost of a multistep equal to the number 
of positions narrowed in the step. We will justify our choice after giving our definition of cost. For 
any set 1 and equivalence relation N on 1, Ill de­notes the cardinality of 1, and 1/-denotes the quotient 
of 1 modulo -. Definition 8 Let a = . . . be a narrowing @Pwfl +(P;,%)C:)ie12 J:)(EI, (multi) derivation. 
The symbol -n denotes the equiv­alence relation on In defined as follows: for any i and j in In, i -n 
j iff the subterms identified by these indices have a common ancestor, more precisely, there exists some 
rn, less than n, such that for some position q in tm, both o ~~~.+,~~+l(t~lpi+l) and o ~~~.+,~~+l(t~lp:+,) 
are descendants of o ~~1~+1 ~~+1 tm g ( 1) We call a fami/y any maximal subset of equivalent indices. 
The cost of the n-th step of a is the number of families in In, i.e., lln/wm 1. The cost of a, denoted 
cost(a), is the total cost of its steps. We say that a family is complete iff it cannot be en­larged, 
and we say that a step is complete iff all its families are complete, more precisely, In is complete 
iff if i is in In, then for any position q of o ~~~.u~+l(t~ l) such that p: and q have a common ancestor 
in some term of a, there exists some j in In such that q = @n. We say that a derivation is complete iff 
all its steps are complete. If I is the set of indices of a narrowing step and z and j belong to I, then 
i w j iff pi and pj are, using an anthropomorphic metaphor, blood related. A complete derivation is characterized 
by narrowing complete fam­ilies, i.e., sets containing all the pairwise blood related subterms of a term. 
Note that the blood related sub­terms of a term are all equal and that their positions are pairwise disjoint, 
thus all of them can be included in a multistep. Our choice of cost measure is suggested by the observation 
that if t--+P,and qand p are R,.t ,blood related positions, then narrowing tat q (when t is being narrowed 
at p involves no additional computa­tion of a substitution and/or a rule, and consequently no additional 
computation of a substituting term (the in­stantiation of the right side of a rule, ) since the reducts 
of blood related subterms are all equal, too. This im­plies that all the members of a family could be 
shared in the representation of t.When this is being done (as in efficient implementations of narrowing 
[19]), a multi­step entailing a whole family does not differ, in practice, from an elementary step. Theorem 
5 If a = t AO u is a complete outermost­ needed narrowing muit~derivation of a term t into a con­ structor 
term u, then a has minimum cost. I.e., for any muhiderivation /3 = t <o u, cost(a) s cost(@. Elementary 
steps are easier to understand and to imple­ment than multisteps. To achieve optimality, we need multisteps 
only as far as blood related terms are con­cerned. Full sharing of blood related subterms implies that 
no family ever contains more than a single member, in practice, and thus any elementary step becomes 
triv­ially complete. In turn, this equates derivations of min­imum cost with those of minimum length. 
Techniques for rewriting terms with shared subterms go under the name of term graph rewriting [47] and 
adapting them to narrowing, for the systems we are considering, poses no major problem [4].  6 Related 
work There are three research topics related to our work: (1) the concept of need as the foundation of 
laziness, (2) strategies for using narrowing in programming, and (3) implement ations of narrowing in 
Prolog. 6.1 Narrowing and need Seminal studies on the concept of need in rewriting ap­pear in [24, 39]. 
Subsequent variations and extensions, e.g., [7, 21, 27, 30, 33, 40, 41, 45, 48], do not address nar­rowing, 
but limit the discussion to rewriting. We have introduced a concept of need for narrowing that extends 
a similar concept for rewriting. We have shown that the concept of need for narrowing is inherently more 
com­plicated than that for rewriting. In orthogonal systems, a reduction step has one degree of freedom, 
the selection of the position, but a narrowing step has two, both the position and the unifier. We have 
discussed only inductively sequential sys­tems. Further research will extend this class to strongly sequential 
and/or weakly orthogonal systems. The ex­tension to weakly orthogonal systems would weaken our strong 
optimality result, but include additional non-determinism. Sekar and Ramakrishnan [45] pro­pose necessary 
sets as a generalization of the notion of need for weakly orthogonal systems. Antoy [I] sug­gests rewriting 
necessary sets of redexes using para!lel definitional trees and a function analogous to A. This approach 
can be extended to narrowing without major problems. 6.2 Narrowing strategies The trade-off between 
power and etliciency is central to the use of narrowing, especially in programming. To this aim, several 
narrowing strategies, e.g., [9, 12, 13, 14, 15, 16, 18, 20, 22, 31, 35, 36, 37, 38, 44, 49] have been 
pro­posed. The notion of completeness has evolved accord­ingly. Plotkin s classic formulation [43] has 
been relaxed to completeness w.r.t. ground solutions (e.g. [15]) or completeness w.r. t. strict equality 
and domain-based in­terpretations, as in [16, 37]. The latter appear more ap­propriate for narrowing 
as the computational paradigm of functional logic programming languages in the pres­ence of infinite 
data structures and computations. We briefly recall the underlying ideas of a few major strategies and 
compare them with ours using the follow­ing example. We choose a strongly terminating rewrite system 
with completely defined operations, otherwise all the eager strategies would be immediately excluded. 
Example 9 The symbols a, b, and c are constructors, whereas f and g are defined operations. f(a)-a RI 
f(b(X)) -+ b(f(X)) R2 f(c(X)) -+ a R3 Rq g(b(X), a) + a R5 g(b(X), b(Y)) -c(a) R6 g(b(X), c(Y)) -+ b(a) 
R7 9( C(X), Y) ~ ~(a) d~,x) + b(a) R8 The equation to solve is g(X, f(X)) w c(a). Our strat­egy computes 
only three derivations, only one of which yields a solution.   9(X) f(x)) %c(a) l, R., {xwcz} b(a)= 
c(a) 9(X, f(.~)) w e(a) l, R.s, {X++. (XI)} b(a) = C(U) 9(X, f(x)) = e(a) 1 2, Rz, {X+ b(X~)} g(b(X1), 
b(f(X1))) x c(a) ~{} true  Basic narrowing [25] avoids positions introduced by the instantiation of 
previous steps. Its completeness, and that of its variations, e.g., [20, 22, 31, 35, 38], is known for 
convergent rewrite systems (see [35] for a sys­tematic study.) This strategy may perform useless steps 
and computes an infinite search space for our bench­mark example. Innermost narrowing [15] narrows only 
innermost terms. It is ground complete only for strongly terminat­ing constructor-based systems with 
completely defined operations. It may perform useless steps and it com­putes an infinite number of derivations 
for our bench­mark example. Outermost narrowing [12, 13] narrows outermost operation-rooted terms. This 
strategy is complete only for a restrictive class of rewrite systems. It computes no solution for our 
benchmark example. Outer narrowing [49] selects an inner position only when a step at an outer position 
is impossible. This strategy is complete for constructor-based systems. Outer narrowing behaves as needed 
narrowing on the benchmark example, however the strategy is not char­acterized as computing needed steps. 
Furthermore, [49] describes the enumeration of derivations for E­matching, but not the computation of 
derivations for general E-unification. Lazy narrowing [9, 16, 18, 37, 36, 44], similar to outer, narrows 
an inner term only when the step is demanded to narrow an outer term. For these strategies, the qual­ifier 
lazy is used as a synonym of outermost or de­mand driven, rather than in the technical sense we pro­pose. 
The completeness of these strategies is generally expensive to achieve: [18] requires an ad-hoc implemen­tation 
of backtracking, with the potential of evaluat­ing some term several times; [16] requires flattening 
of functional nesting and a specialized WAM-like machine in which terms are dynamically reordered; [37] 
requires a transformation of the rewrite system which, for our benchmark example, increases the number 
of operations and lengthen the derivations. To summarize, the distinguishing features of our strat­egy 
are the following: with respect to eager strategies, completeness for non-terminating rewrite systems; 
with respect to the so-called lazy strategies, a sharp char­acterization of laziness; with respect to 
any strategy, optimality and ease of computation. 6.3 Narrowing in Prolog Implementations of narrowing 
in Prolog [2, 8, 26, 32] are proposed as a prototypical and portable integration of functional and logic 
languages. For example, [8, 26] have been proposed as an alternative to the specialized machines required 
for K-LEAF [16] and BABEL [37] re­spectively. The most recent proposals [2, 32] are based on definitional 
trees and appear to compute needed steps for inductively sequential systems, although both methods neither 
formalize nor claim this property. The scheme in [2] computes } directly by pattern matching. The patterns 
involved in the computation of ~ are a su­perset of those contained in a definitional tree. This is suggested 
by claim 1 of Theorem 1 that shows a strong need for the positions computed using J not only the terms 
at these positions must be eventually narrowed, but they must be eventually narrowed to head normal forms. 
The resulting implementation takes advantage of this characteristic and its performance appears to be 
superior to the other proposals. 7 Concluding remarks We have proposed a new narrowing strategy obtained 
by extending to narrowing the well-known notion of need for rewriting. Need for narrowing appears harder 
to handle than need for rewriting to compute a needed narrowing step one must also look ahead a potentially 
infinite number of substitutions. Remarkably, there is an efficiently algorithm for this computation 
in induc­tively sequential systems. We have contained our discussion to narrowing oper­ [3] ation-rooted 
terms. This limitation shortens our discus­ sion and suffices for solving equations. Extending our results 
also to constructor-rooted terms is straightfor­ ward. To compute an outermost-needed narrowing step 
of a constructor-rooted term it suffices to compute an [4] outermost-needed narrowing step of any of 
its maximal operation-rooted subterms. We have shown how our strategy is easily imple­ mented by pattern 
matching, and we have reported, in the previous section, its good performance in Pro­ [5] log with respect 
to other similar attempts. We have also shown that our strategy computes only indepen­ dent and optimal 
derivations. Although all the previ­ ously proposed lazy strategies have the latter as their [6] primary 
goal, our strategy is the only one for which this result is formalized and proved. We want to conclude 
with a general assessment of the overall quality of the narrowing strategy used by [7] a programming 
language. The key factor is the trade-off between the size of the class of rewrite systems for which 
the strategy is complete and the efficiency of its com­ putations. We prove both completeness and optimality 
for inductively sequential systems. We believe that it is possible to extend our result to strongly sequential 
[8] systems and, in a weaker form, to weakly orthogonal systems. [9] Acknowledgement Aart Middeldorp 
suggested us how to prove [34] our conjecture that the classes of inductively sequential sys­ tems and 
constructor-based strongly sequential systems [10] are the same. We would like to acknowledge the support 
of The Oregon Center for Advanced Technology Education (OCATE) for parts of the collaborative efforts 
that lead [11] to the writing of this paper. The research of Michael Hanus was supported in part by the 
German Ministry for Research and Technology (BMFT) under grant ITS 9103 and by the ESPRIT Basic Research 
Working Group 6028 (Construction of Computational Logics). [12] References [13] ,<RefA>[1] S. Antoy. Definitional 
trees. In ALP 92?, pages 143­ 157. Springer LNCS 632, 1992. [2] S. Antoy. Lazy rewriting in logic programming. 
[14] Technical Report 90-17 , Rev, 2, Portland State University, Portland, OR, 1992. (Submitted for publication). 
 S. Antoy, R. Echahed, and M. Hanus. A needed narrowing strategy. Technical report, MPI-I-93­243, Max-Planck-Institut 
fur Informatik, Saarbrii­cken, 1993. H. Barendregt, M. van Eekelen, J. Glauert, R. Ken­ neway, and M. 
Sleep. Term graph rewriting. In PARLE 87, pages 141-158. Springer LNCS 259, 1987. M. Bellia and G. Levi. 
The relation between logic and functional languages: a survey. Journal of Logic Programming, 3(3):217-236, 
1986. D. Bert and R. Echahed. Design and implementa­tion of a generic, logic and functional programming 
language. In ESOP-86, pages 119 132. Springer LNCS 213, 1986. G. Boudol. Computational semantics of term 
rewriting systems. In M. Nivat and J. C. Reynolds, editors, Aigebraac methods in semantics, chap­ter 
5. Cambridge University Press, Cambridge, UK, 1985. P. H. Cheong. Compiling lazy narrowing into Pro­log. 
New Generation Computing, 1992. (to appear). J. Darlington and Y. Guo. Narrowing and unifi­cation in 
functional programming -an evaluation mechanism for absolute set abstraction. In Proc. of the Conference 
on Rewriting Techniques and Appli­cations, pages 92 108. Springer LNCS 355, 1989. D. DeGroot and G. Lindstrom, 
editors. Logic Pro­gramming, Functions, Relattons, and Equations. Prentice Hall, 1986. N. Dershowitz 
and J. Jouannaud. Rewrite systems. In J. van Leeuwen, editor, Handbook of Theoretical Computer Science 
B: Formal Methods and Seman­tics, chapter 6, pages 243 320. North Holland, Am­sterdam, 1990. R. Echahed. 
On completeness of narrowing strate­gies. In Proc. CAAP 88, pages 89 101. Springer LNCS 299, 1988. R. 
Echahed. Uniform narrowing strategies. In Pro­ceedings of the Third International Conference on Algebraic 
and Logic Programming, pages 259-275, Volterra, Italy, September 1992. M. J. Fay. First-order unification 
in an equational theory. In Proc. dth Workshop on Automated De­duction, pages 161-167, Austin (Texas), 
1979. Aca­demic Press. [15] L. Fribourg. SLOG: A logic programming lan­guage interpreter based on clausal 
superposition and rewriting. In Proc. IEEE Internai. Symposium on Logzc Programrnang, pages 172 184, 
Boston, 1985. [16] E. Giovannetti, G. Levi, C. Moiso, and C. Palami­dessi. Kernel LEAF: a logic plus 
functional lan­guage. The Journal of Computer and System Sci­ences, 42:139 185, 1991. [17] J. A. Goguen 
and J. Meseguer. Eqlog: Equal­ity, types, and generic modules for logic program­ming. In D. DeGroot and 
G. Lindstrom, ed­itors, Logzc Programming, Functaons, Relations, and Equations, pages 295 363. Prentice 
Hall, 1986. [18] W. Hans, R. Loogen, and S. Winkler. On the interaction of lazy evaluation and backtracking. 
In Proc. of the dth International Symposium on Programming Language Implementation and Logic Programming, 
pages 355-369. Springer LNCS 631, 1992. [19] M. Hanus. Compiling logic programs with equality. In Proc. 
of the %d Int. Workshop on Programming Language Implementation and Logic Programming, pages 387-401. 
Springer LNCS 456, 1990. ~20] A. Herold. Narrowing techniques applied to idem­potent unification. Technical 
Report SR-86-16, SEKI, 1986. [21] C. M. Hoffmann and M. J. O Donnell. Implementa­tion of an interpreter 
for abstract equations. In Ilth ACM Sympostum on the Prtnciple of Programming Languages, Salt Lake City, 
1984. [22] S. Holldobler. Foundations of Equational Logtc Programming. Springer LNCS 353, 1989. [23] 
G. Huet and J .-M. Hullot. Proofs by induction in equational theories with constructors. JCSS, 25:239-266, 
1982. ~24] G. Huet and J.-J. L6vy. Computations in orthog­onal term rewriting systems. In J .-L. Lassez 
and G. Plotkin, editors, Computational logzc: essays tn honour of Alan Robznson. MIT Press, Cambridge, 
MA, 1991. Previous version: Call by need com­putations in non-ambiguous linear term rewriting systems, 
Technical Report 359, INRIA, Le Ches­nay, France, 1979. ~25] J.-M. Hullot. Canonical forms and unification. 
In Proc. 5th Conference on Automated Deductzon, pages 318-334. Springer LNCS 87, 1980. [26] J. A. Jim6nez-Martin, 
J. Mariiio-Carballo, and J. J. Moreno-Navarro. Efficient implementation of lazy narrowing into PROLOG. 
In LOPSTR 92, 1993. Previous version: Some Techniques for the Effi­cient Implement ation of Lazy Narrowing, 
Technical Report -FIM.75/LyS/92, Facultad de Informatica, Universidad Politecnica de Madrid, 1992. ~27] 
J. R. Kennaway. Sequential evaluation strategies for parallel-or and related reduction systems. An­nals 
of Pure and Apphed Logic, 43:31 56, 1989. ~28] J. R. Kennaway. The specificity rule for lazy pattern-matching 
in ambiguous term rewrite sys­tems. In Third European Symp. on Programming, pages 256 270, 1990. LNCS 
432. [29] J. W. Klop. Term Rewriting Systems. In S. Abram­sky, D. Gabbay, and T. Maibaum, editors, Hand­book 
of Logic in Computer Science, Vol. II, pages 1 1 12. Oxford University Press, 1992. Previous version: 
Term rewriting systems, Technical Report CS-R9073, Stichting Mathematisch Centrum, Am­sterdam, 1990. 
[30] J. W. Klop and A. Middeldorp. Sequentiality in or­thogonal term rewriting systems. Journal of Sym­bolic 
Computation, pages 161 195, 1991. Previ­ous version: Technical Report CS-R8932, Stichting Mathematisch 
Centrum, Amsterdam, The Nether­lands, 1989. [31] S. Krischer and A. Bockmayr. Detecting redundant narrowing 
derivations by the LSE-SL reducibility test. In Proc. RTA 91. Springer LNCS 488, 1991. [32] R. Loogen, 
F. Lopez Fraguas, and M. Rodriguez Artalejo. A demand driven computation strategy for lazy narrowing. 
In Proc. of the 5th Interna­tional Symposium on Programming Language Im­plementation and Logtc Programming, 
pages 184 200. Springer LNCS 714, 1993. [33] L. Maranget. Optimal derivation in weak lambda­calculi 
and in orthogonal terms rewriting systems. In 17thAnnual Symp. on Prznctpies of Prog. Lan­guages, pages 
255 269. ACM, 1990. [34] A. Middeldorp, August 1993. Personal Communi­cation. [35] A. Middeldorp and 
E. Hamoen. Counterexamples to completeness results for basic narrowing (ex­tended abstract). In Proceedings 
of the Third In­ternational Conference on Algebrazc and Logzc Pro­gramming, pages 244 258, Volterra, 
Italy, Septem­ber 1992. [36] J. J. Moreno-Navarro, H. Kuchen, R. M. Rodriguez-Artalejo. Lazy narrowing 
machine. In Proc. Second International on Algebraic and Logic Programmmg, 317. Springer LNCS 463, 1990. 
Loogen, and in a graph Conference pages 298 [37] J. J. Moreno-Navarro and M. Rodriguez-Artalejo. Logic 
programming with functions and predicates: The language BABEL. Journa/ of Logic Program­ming, 12:191 
223, 1992. [38] W. Nutt, P. R&#38;y, and G. Smolka. Basic narrowing revisited. Journal of Symbolic 317, 
1989. [39] M. J. O Donnell. by Equations. [40] M. J. O Donnell. ming Language. Computing Springer LNCS 
Equationa/ MIT Press, Computation, 7:295 in Systems Described 58, 1977. Logic as a Program­1985. [41] 
M. J. Oyamaguchi. Nv-sequentiality: A decidable condition for call-by-need computations in term rewriting 
systems. SIAM Journal on Computation, 22(1):114-135, 1993. [42] P. Padawitz. Computtng in Horn Clause 
Theories, volume 16 of EATCS Monographs on Theoretical Computer Science. Springer, 1988. [43] G.D. Plotkin. 
Building-in equational theories. Ma­chine Intelligence, 7:73 90, 1972. [44] U. S. Reddy. Narrowing as 
the operational seman­ tics of functional ternat. Symposium 138-151, Boston, [45] R. C. Sekar and ming 
in equational tiality. In Proceedings Symposium on Logic 230-241, Philadelphia, [46] J. R. Slagle. Automated 
ories with simplifiers, languages. In Proc. IEEE In­on Logac Programming, pages 1985. I. V. Ramakrishnan. 
Program­logic: Beyond strong sequen­ of the Ftflh Annual IEEE in Computer Science, pages PA, June 1990. 
theorem-proving commutativity, and tivity. Journal of the ACM, 21(4):622-642, [47] M. R. Sleep, M. J. 
Plasmeijer, and M. C. Eekelen, editors. Term Graph Rewriting for the­associa­1974. J. D. van Theory and 
Practice. J. Wiley &#38; Sons, Chichester, UK, 1993. [48] S. Thatte. A refinement of strong sequentiality 
for term rewriting with constructors, Information and Computation, 72:46-65, 1987. [49] J.-H. You. Enumerating 
outer narrowing deriva­tions for constructor-based term rewriting systems. Journal of Symbolic Computation, 
7:319-341, 1989.  </RefA>
			


 A Fixpoint Calculus for Local and Global Program Flows * Rajeev Alur Swarat Chaudhuri P. Madhusudan 
University of Pennsylvania University of Pennsylvania University of Illinois, alur@cis.upenn.edu swarat@cis.upenn.edu 
Urbana-Champaign Abstract We de.ne a new .xpoint modal logic, the visibly pushdown µ-calculus (VP-µ), 
as an extension of the modal µ-calculus. The models of this logic are execution trees of structured programs 
where the procedure calls and returns are made visible. This new logic can express pushdown speci.cations 
on the model that its classical counterpart cannot, and is motivated by recent work on visibly pushdown 
languages [4]. We show that our logic naturally captures several interesting program speci.cations in 
program ver­i.cation and data.ow analysis. This includes a variety of program speci.cations such as computing 
combinations of local and global program .ows, pre/post conditions of procedures, security prop­erties 
involving the context stack, and interprocedural data.ow analysis properties. The logic can capture .ow-sensitive 
and inter­procedural analysis, and it has constructs that allow skipping pro­cedure calls so that local 
.ows in a procedure can also be tracked. The logic generalizes the semantics of the modal µ-calculus 
by considering summaries instead of nodes as .rst-class objects, with appropriate constructs for concatenating 
summaries, and naturally captures the way in which pushdown models are model-checked. The main result 
of the paper is that the model-checking problem for VP-µ is effectively solvable against pushdown models 
with no more effort than that required for weaker logics such as CTL. We also investigate the expressive 
power of the logic VP-µ: we show that it encompasses all properties expressed by a corresponding pushdown 
temporal logic on linear structures (CARET [2]) as well as by the classical µ-calculus. This makes VP-µ 
the most expres­sive known program logic for which algorithmic software model checking is feasible. In 
fact, the decidability of most known pro­gram logics (µ-calculus, temporal logics LTL and CTL, CARET, 
etc.) can be understood by their interpretation in the monadic second-order logic over trees. This is 
not true for the logic VP­µ, making it a new powerful tractable program logic. Categories and Subject 
Descriptors D.2.4 [Software Engineer­ing]: Software/Program Veri.cation Model checking; F.3.1 [The­ory 
of Computation]: Specifying and Verifying and Reasoning * This research was partially supported by ARO 
URI award DAAD19-01­1-0473 and NSF award CCR-0306382. Permission to make digital or hard copies of all 
or part of this work for personal or classroom use is granted without fee provided that copies are not 
made or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation 
on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires 
prior speci.c permission and/or a fee. POPL 06 January 11 13, 2006, Charleston, South Carolina, USA. 
Copyright c . 2006 ACM 1-59593-027-2/06/0001. . . $5.00. madhu@cs.uiuc.edu about Programs; F.4.1 [Theory 
of Computation]: Mathematical Logic Temporal logic General Terms Algorithms, Theory, Veri.cation Keywords 
Logic, speci.cation, veri.cation, µ-calculus, in.nite­state, model-checking, games, pushdown systems 
1. Introduction The µ-calculus [20, 16] is a modal logic with .xpoints interpreted over labeled transition 
systems, or equivalently, over their tree unfoldings. It is an extensively studied speci.cation formalism 
with applications to program analysis, computer-aided veri.cation, and database query languages [13, 
25]. From a theoretical perspective, its status as the canonical temporal logic for regular requirements 
is due to the fact that its expressiveness exceeds that of all commonly used temporal logics such as 
LTL, CTL, and CTL*, and equals that of alternating parity tree automata or the bisimulation-closed fragment 
of monadic second-order theory over trees [14, 18]. From a practical standpoint, iterative computation 
of .xpoints naturally suggests symbolic evaluation, and symbolic model checkers such as SMV check CTL 
properties of .nite-state models by compiling them into µ-calculus formulas [8, 21]. In this paper, we 
focus on the role of µ-calculus to specify properties of labeled transition systems corresponding to 
push­down automata, or equivalently, Boolean programs [5] or recur­sive state machines (RSMs) [3, 7]. 
Such pushdown models can capture the control .ow in typical sequential imperative program­ming languages 
with recursive procedure calls, and are central to interprocedural data.ow analysis [22] and software 
model check­ing [6, 17]. While algorithmic veri.cation of µ-calculus properties of such models is possible 
[26, 10], classical µ-calculus cannot ex­press pushdown speci.cations that require inspection of the 
stack or matching of calls and returns. Even though the general prob­lem of checking pushdown properties 
of pushdown automata is un­decidable, algorithmic solutions have been proposed for checking many different 
kinds of non-regular properties [19, 12, 15, 11, 2, 4]. These include access control requirements such 
as a module A should be invoked only if the module B belongs to the call-stack, bounds on stack size 
such as after any point where p holds, the number of interrupt-handlers in the call-stack should never 
exceed 5 and the classical Hoare-style correctness requirements of pro­gram modules with pre-and post-conditions, 
such as if p holds when a module is invoked, the module must return, and q must hold on return . In the 
program analysis literature, it has been argued that data .ow analysis, such as the computation of live 
variables and very busy expressions, can be viewed as evaluating µ-calculus formulas over abstractions 
of programs [24, 23]. This correspondence does not hold when we need to account for local data .ow paths. 
For instance, for an expression e that involves a variable local to a pro­cedure P , the set of control 
points within P at which e is very busy (that is, e is guaranteed to be used before any of its variables 
get modi.ed), cannot be speci.ed using a µ-calculus formula even though interprocedural data.ow analysis 
can compute this infor­mation. The goal of this paper is to identify a .xpoint calculus that can express 
such pushdown requirements and yet has a decidable model checking problem with respect to pushdown models. 
Our search for such a calculus was guided by the recently pro­posed framework of visibly pushdown languages 
for linear-time properties [4]. In this variation of pushdown automata over words, the input symbol determines 
when the pushdown automaton can push or pop, and thus the stack depth at every position. The re­sulting 
class of languages is closed under union, intersection, and complementation, and problems such as inclusion 
that are unde­cidable for context-free languages are decidable for visibly push­down automata. This implies 
that checking pushdown properties of pushdown models is feasible as long as the calls and returns are 
made visible allowing the stacks of the property and the model to synchronize. This visibility requirement 
seems only natural while writing requirements about pre/post conditions or for interprocedu­ral .ow properties. 
The linear-time temporal logic CARET is based on the same principle: its formulas are interpreted over 
sequences tagged with calls and returns, and its syntax includes for each tem­poral modality, besides 
its classical global version, a local version that jumps from a call-state to the matching return-state, 
and thus, can express non-regular properties, without causing undecidability. In order to develop a visibly 
pushdown branching-time logic,we consider structured trees as models. In a structured tree, nodes are 
labeled with atomic propositions as in Kripke models, and edges are tagged as call, return,or local. 
To associate a structured tree with a program (or its abstraction), we must choose the set of ob­servable 
atomic state properties, tag edges corresponding to calls and returns from program blocks appropriately, 
and then take the tree unfolding of this abstract program model. The abstract model can be an abstraction 
of the program at any level of abstraction: from the skeletal control-.ow graph to boolean predicate 
abstrac­tions of programs. We de.ne the visibly pushdown µ-calculus (VP-µ) over struc­tured trees. The 
variables of the calculus evaluate not over sets of states, but rather over sets of subtrees that capture 
summaries of computations in the current program block. The .xpoint opera­tors in the logic then compute 
.xpoints of summaries. For a given state s of a structured tree, consider the subtree rooted at s such 
that the leaves correspond to exits from the current block: differ­ent paths in the subtree correspond 
to different computations of the program, and the .rst unmatched return edge along a path leads to a 
leaf (some paths may be in.nite corresponding to cycles that never return in the abstracted program). 
In order to be able to relate paths in this subtree to the trees rooted at the leaves, we allow marking 
of the leaves: a 1-ary summary is speci.ed by the root s and a subset U of the leaves of the subtree 
rooted at s. Each formula of the logic is evaluated over such a summary. The central construct of the 
logic corresponds to concatenation of call trees: the formula (call).{.}holds at a summary (s, U)if the 
state s has a call-edge to a state t, and there exists a summary (t, V )satisfying . and for each leaf 
v that belongs to V , the subtree (v, U)satis.es .. Our logic is best explained using the speci.cation 
of local reach­ability: let us identify the set of all summaries (s, U)such that there is a local path 
from s to some node in U (i.e. all calls from the initial procedure must have returned before reaching 
U). In our logic, this is written as the formula . =µX.(ret)R1 .(loc)X . (call)X{X}. The above means 
that X is the smallest set of sum­maries of the form (s, U)such that (1) there is a ret-labeled edge 
from s to some node in U, (2) there is a loc-labeled edge from s to t and there is a summary (t, U)in 
X, or (3) there is a call-labeled edge from s to t and a summary (t, V )in X such that from each v .V 
, (v, U)is a summary in X. Notice that the above formula identi.es the summaries in the natural way it 
will be computed on a pushdown system: compute the local summaries of each proce­dure, and update the 
reachability relation using the call-to-return summaries found in the procedures called. Using the above 
formula, we can state local reachability of a state satisfying p as: µY.(p .(loc)Y .(call).{Y }) which 
intuitively states that Y is the set of summaries (s, U)where there is a local path from s to U that 
goes through a state satisfying p. The initial summary (involving the initial state of the program) satis.es 
the formula only if a p-labeled state is reachable in the top-most context, which cannot be stated in 
the standard µ-calculus. This example also illustrates how local .ows in the context of data.ow analysis 
can be captured using our logic. In general, we allow markings of the leaves with k colors: a k-colored 
summary rooted at a node consists of k subsets of the leaves of the subtree rooted at this node. The 
k-ary concatenation formula (call).{.1,....k}says that the called procedure should satisfy ., and the 
subtrees at the return nodes labeled with color i should satisfy the requirement .i. While the concatenation 
op­eration is a powerful recursive construct that allows the logic to express pushdown properties, multiple 
colors allows expression of branching-time properties that can propagate between the called and the calling 
contexts. The main result of this paper is that the logic VP-µ can be model-checked effectively. Given 
a model of a program as a re­cursive state machine [3, 7], or equivalently a pushdown system, and a VP-µ 
formula ., we show that we can model-check whether the tree unfolding of the model satis.es . in exponential 
time (the procedure is exponential in both the formula and the model). For a .xed formula ., however, 
the model-checking problem is only polynomial in the number of states in the model and exponential in 
the number of control locations where a procedure in the model may return. The model-checking algorithm 
works by computing .x-points of the summary sets inductively, and illustrates how the semantics of the 
logic naturally suggests a model-checking algo­rithm. The complexity of model-checking VP-µ is EXPTIME­complete, 
which matches the complexity of model-checking the standard µ-calculus on pushdown systems (in fact, 
model-checking alternating reachability properties is already EXPTIME hard [26]). Finally, we study some 
expressiveness issues for the logic VP­µ. We .rst show that VP-µ captures the temporal logic CARET, which 
is a linear-time temporal logic over visibly pushdown words that can capture several interesting pushdown 
speci.cation proper­ties. This shows that our branching-time logic captures the relevant counterpart 
logic over linear models, much the same way as the standard µ-calculus captures the temporal logic LTL. 
This makes VP-µ the most expressive known speci.cation logic of programs with a decidable model checking 
problem with respect to Boolean programs. We also show that the notion of k-colors in the logic is important 
by proving a hierarchy theorem: formulas of VP-µ that use k colors are strictly weaker than formulas 
that use (k +1)colors. Finally, we show that the satis.ability problem for VP-µ is undecidable. Note 
that this is not an issue as we are really only interested in the model-checking problem; in fact the 
result serves to illustrate how powerful the logic VP-µ is. The paper is organized as follows. Section 
2 introduces struc­tured trees and summaries and Section 3 de.nes the logic VP-µ. In Section 4 we present 
various properties that can be expressed using VP-µ, including reachability, local reachability, expressions 
for various temporal modalities like eventually and until, security properties that involve inspection 
of stack, stack over.ow proper­ties, properties describing pre and post-conditions for procedures, properties 
of access control and some data-.ow analysis properties such as very busy expressions. Section 5 shows 
how recursive state machine models of programs can be model-checked against VP-µ formulas, Section 6 
contains results on expressiveness and unde­cidability of satis.ability, and we conclude with some discussion 
in Section 7. 2. Structured trees Let AP be a .nite set of atomic propositions, and I ={call ,ret,loc}a 
.xed set of tags. We are interested in trees whose nodes and edges are respectively labeled by propositions 
and tags, and model abstract states and statements in sequential, structured, possibly recursive programs. 
Formally, an (AP,I)-labeled tree is a tuple S =(S,s0,E,.,.), where (S,s0,E) is a tree with node set S, 
root node s0 and edge relation E, the node-labeling function . :S . 2AP labels nodes with sets of propositions 
they satisfy, and the transition-labeling function . :E . I tags transitions as procedure calls (labeled 
by call), procedure returns (ret), or local a' statements within procedures (loc). For a . I, we write 
s -. s as shorthand for (s,s '). E and .((s,s '))=a. A .nite path in an (AP,I)-labeled tree is a sequence 
p = s1s2 ...sn over S such that (si,si+1) . E for all 1 = i<n. We will extend . to paths in S as follows. 
Let ei represent the transition (si,si+1)in the above path p. Then .(p)is the word .(e1).(e2)....(en-1)over 
the alphabet I. Such a labeling lets us mark certain paths in S as matched.A path pin S is called matched 
if and only if w =.(p)is of the form w :=loc | call wret | ww. Given nodes s and s . in S, we call s 
. a matching return of s if and only if there is a matched path p = ss1s2 ...sn such that ret sn -. s 
'. Intuitively, s . models the .rst state that the underlying program reaches on popping the context 
of s off its stack frame. The set of matching returns of sis written as MR(s). Then: DEFINITION 1. A 
structured tree over AP is an (AP,I)-labeled tree with root s0 that satis.es MR(s0)=Ø. s2 pp s5 s8 s11 
Figure 1. (a) A structured tree (b) A 2-colored summary Intuitively, paths from the root in structured 
trees do not have excess returns that do not match any call a structured tree models the branching behavior 
of a program from a state s to, at most, the end of the procedural context where slies. Also observe 
that the maximal subtree rooted at an arbitrary node in a structured tree is not, in general, structured. 
Fig. 1-a shows a structured tree, with nodes s1,...,s15 and transitions labeled call, ret and loc. Some 
of the nodes are labeled by propositions p and q. Note particularly the matching return relation; for 
instance, the nodes s10, s11, s12, and s15 are matching returns for the node s2. Also, MR(s1)=Ø. 2.1 
Summaries We are interested in subtrees of structured trees wholly contained within procedural contexts; 
such a subtree models the branching behavior of a program from a state s to each return point of its 
context. Each such subtree rooted at s has a summary comprising (1) the node s, and (2) the set of all 
nodes that are reached on return from its context, i.e., MR(s). Also, in order to demand different temporal 
requirements at different returns for a context, we introduce a coloring of nodes in MR(s) intuitively, 
a return gets color i if it is to satisfy the i-th requirement. Note that such colored summaries are 
de.ned for all s and that, in particular, we do not require sto be an entry node of a procedure. Sets 
of such summaries de.ne the semantics of formulas in VP-µ. Formally, for a non-negative integer k,a k-colored 
summary s is a tuple (s,U1,U2,...,Uk), where s. Sand U1,U2,...,Uk . MR(s). For example, in Fig. 1-a, 
(s1) is a valid 0-colored sum­mary, and (s2,{s11,s12},{s10,s12}) and (s3,{s6},Ø) are valid 2-colored 
summaries. The set of all summaries in S, each k-colored for some k, is denoted by S. Observe how each 
summary describes a subtree along with a coloring of some of its leaves. For instance, the summary s 
= (s2,{s11,s12},{s10,s12}) marks the subtree in Fig. 1-b. Such a tree may be constructed by taking the 
subtree of S rooted at node s2, and chopping off the subtrees rooted at MR(s2). Note that because of 
unmatched in.nite paths from the root, such a tree may in general be in.nite. Now, nodes s11 and s12 
are assigned the color 1, and nodes s10 and s12 are colored 2. The node s15 is not colored. Also, note 
that in the linear-time setting, a pair (s,s '), where s . . MR(s), would suf.ce as a summary, and that 
this is the way in which traditional summarization-based decision procedures have de.ned summaries. On 
the other hand, for branching-time reasoning, such a simple de.nition is not enough.  3. A .xpoint 
calculus of calls and returns 3.1 Syntax In addition to being interpreted over summaries, the logic 
VP-µ differs from classical calculi like the modal µ-calculus [20] in a crucial way: its syntax and semantics 
explicitly recognize the pro­cedural structure of programs via modalities call, ret and loc.A distinction 
is made between call-edges, along which a program pushes frames on its stack, ret-edges, which require 
a pop from the stack, and loc-edges, which change the program counter and local and global store without 
modifying the stack. Also, in order to en­force different return conditions at differently colored returns 
in a summary, it can pass formulas as parameters to call modalities. Formally, let AP be a .nite set 
of atomic propositions, Var be a .nite set of variables, and {R1,R2,...} be a set of markers. Then, for 
p. AP and X . Var , formulas .of VP-µare de.ned by: . := p|¬p| X | .. .| .. . | µX.f | .X.f (call) .{.1,.2,...,.k}| 
[call ].{.1,.2,...,.k}|(loc) . | [loc]. |(ret) Ri | [ret ]Ri, where k = 0and i = 1. Let us de.ne the 
syntactic shorthands tt =p.¬pand . =p.¬pfor some p . AP. Also, let the arity of aVP-µformula .be the 
maximum ksuch that .has a subformula of the form (call).'{.1,...,.k} or [call].'{.1,...,.k}. Intuitively, 
the markers Ri in a formula are bound by (call)and [call]modalities, and variables X are bound by .xpoint 
quan­ti.ers µX and .X. We require our call-formulas to bind all the markers in their scope. Formally, 
let the maximum marker index ind(.)of a formula .be de.ned inductively as: ind(.1 . .2)= ind(.1 . .2)=max{ind(.1),ind(.2)}; 
ind((loc).)= ind([loc].)= ind(µX..)= ind(.X..)= ind(.); and Figure 2. (a) Local modalities (b) Call modalities 
(c) Matching contexts.  ind((ret )Ri)= ind([ret ]Ri)= i. For each p . AP and X . Var , let us de.ne 
ind(p)= ind(X)=0. Finally, let us have ind((call ).{.1,...,.k})= ind([call ].{.1,...,.k})= max{ind(.1),...,ind(.k)}. 
We will only be interested in for­mulas where for every subformula .of the form (call).'{.1,...,.k}or 
[call ].'{.1,...,.k},wehave ind(.') = k. Such a formula . is said to be marker-closed if ind(.)=0. The 
set Free(.) of free variables in a VP-µ formula . is de­.ned as: Free(.1 ..2)= Free(.1 ..2)= Free(.1).Free(.2); 
Free((loc).)= Free([loc].)= Free(.); and Free((ret )Ri)= Free([ret ]Ri)= Ø. We have Free((call).{.1,...,.k})= 
Free([call ].{.1,...,.k})= Free(.) . Free(.1) . ... . Free(.k); for each p . AP and X . Var , Free(p)= 
Ø and Free(X)= {X}. Finally, we have Free(µX..)= Free(.X..)= Free(.) \{X}. A formula .is said to be variable-closed 
if it has Free(.)= Ø. We call .closed if it is marker-closed and variable­closed.  3.2 Semantics Like 
in the modal µ-calculus, formulas in VP-µencode sets, in this case sets of summaries. Also like in the 
µ-calculus, modalities and boolean and .xed-point operators allow us to encode computations on these 
sets. To understand the semantics of local ((loc) and [loc]) modalities in VP-µ, consider the 2-colored 
summary s = (s3,{s6},{s8}) in the tree S in Fig. 1-a. We observe that when control moves from node s3 
to s5 along a local edge, the current context stays the same, but the set of returns that can end it 
and are reachable from the current control point gets restricted (MR(s5) . MR(s3)). The temporal requirements 
that we demand on return from the current context stay the same modulo this restriction. Consequently, 
the 2­colored summary s . = (s5,Ø,{s8}) describes program .ow from this point to the end of the current 
context and the requirements to be satis.ed at the latter. We use modalities (loc) and [loc] to reason 
about such local succession. For instance, in this case, summary s will be said to satisfy the formula 
(loc)q. An interesting visual insight about the structure of the tree Ss for s comes from Fig. 2-a. Note 
that the tree Ss. for s . hangs from the former by a local edge; additionally, (1) every leaf of Ss. 
is aleaf of Ss, and (2) such a leaf gets the same color in s and s . . Succession along call edges is 
more complex, because along such an edge, a frame is pushed on a program s stack and a new calling context 
gets de.ned. In Fig. 1-a, take the summary s = (s2,{s11},{s12}), and suppose we want to assert a 3­parameter 
call formula (call ).'{q,p,tt} at s2. This requires us to consider a 3-colored summary of the context 
starting at s3, where matching returns of s3 satisfying q, p and tt are respec­tively marked by colors 
1, 2 and 3. Clearly, this summary is s . = (s3,{s6},{s8},{s6,s8}). Our formula requires that s . sat­is.es 
.'. In general, we could have formulas of the form . = (call ).'{.1,.2,...,.k}, where .i are arbitrary 
VP-µformulas. To see what this means, look at the summaries r1 = (s6,Ø,{s12})and r2 = (s8,{s11},Ø), which 
capture .ow (under the assumed coloring of MR(s2)) from s6 and s8 to the end of the context they are 
in. To see if .is satis.ed, we will need to consider a summary s '. rooted at s3 where the color i is 
assigned to nodes s6 and s8 precisely when r1 and r2 respectively satisfy .i. Now, we require s '. to 
satisfy .. . So far as the structures of these trees go, we .nd that the above requires a split of the 
tree Ss for summary s in the way shown in Fig. 2-b. The root of this tree must have a call -edge to the 
root of the tree for s ', which must satisfy .. At each leaf of Ss. colored i, we must be able to concatenate 
a summary tree Ss.. satisfying .i such that (1) every leaf in Ss.. is a leaf of Ss, and (2) each such 
leaf gets the same set of colors in Ss and Ss.. . As for the return modalities, we use them to assert 
that we return at a point colored i. Because the binding of these colors to temporal requirements was 
.xed at a context that called the current context, the ret -modalities let us relate a path in the latter 
with the continuation of a path in the former. For instance, in Fig. 2­c, where the rectangle abstracts 
the part of a program unfolding within the body of a procedure foo, the marking of return points s1 and 
s2 by colors 1 and 2 is visible inside foo as well as at the call site of foo. This lets us match paths 
P1 and P2 inside foo respectively with paths P1 . and P2 . in the calling procedure. This lets VP-µ capture 
the pushdown structure of branching-time runs of a procedural program. Let us now describe the semantics 
of VP-µformally. A VP-µ formula .is interpreted in an environment that interprets variables in Free(.) 
as sets of summaries in a structured tree S. Formally, an environment is a map E : Free(.) . 2S . Let 
us write [[.]]SE to denote the set of summaries in S satisfying .in environment E (usually S will be 
understood from the context, and we will simply write [[.]]E ). For a summary s = (s,U1,U2,...,Uk), where 
s . S and Ui . MR(s) for all i, s satis.es ., i.e., s . [[.]]E , if and only if one of the following 
holds: .= p. AP and p. .(s)  .= ¬pfor some p . AP, and p/. .(s)  .= X, and s .E(X)  .= .1 . .2 such 
that s . [[.1]]E or s . [[.2]]E  .= .1 . .2 such that s . [[.1]]E and s . [[.2]]E  . = (call ).'{.1,.2,...,.m}, 
and there is a t . S such that  call (1) s -. t, and (2) the summary t = (t,V1,V2,...,Vm), where for 
all 1 = i = m, Vi = MR(t) n{s . : (s ',U1 n MR(s '),...,Uk nMR(s ')). [[.i]]E }, is such that t . [[.']]E 
. =[call ] .'{.1,.2,...,.m}, and for all t . S such that call s -. t, the summary t = (t,V1,V2,...,Vm), 
where for all 1 = i = m, Vi = MR(t) n{s . : (s ',U1 n MR(s '),...,Uk n MR(s ')). [[.i]]E }, is such that 
t . [[.']]E loc . = (loc) .', and there is a t . S such that s -. t and the summary t = (t,V1,V2,...,Vk), 
where Vi = MR(t) n Ui,is such that t . [[.']]E loc . =[loc] .', and for all t. S such that s-. t, the 
summary t = (t,V1,V2,...,Vk), where Vi = MR(t) n Ui, is such that t . [[.']]E ret .= (ret ) Ri, and there 
is a t. Ssuch that s-. tand t. Ui ret . =[ret] Ri, and for all t . S such that s -. t,wehave t. Ui 
 .= µX..', and s . S for all S . S satisfying [[.']]E[X:=S] .  S . = .X..', and there is some S . S 
such that (1) S . [[.']]E[X:=S] and (2) s . S. Here E[X := S] is the environment E' such that (1) E'(X)= 
S, and (2) E'(Y)= E(Y) for all variables Y X. We say a node = ssatis.es a formula .if the 0-colored summary 
(s) satis.es ..A structured tree S rooted at s0 is said satisfy .if s0 satis.es .(we denote this by S|= 
.). A few observations are in order. First, while VP-µ does not allow formulas of form ¬., it is closed 
under negation so long as we stick to closed formulas. Given a closed VP-µ formula ., consider the formula 
Neg(.), de.ned inductively in the following way:  Neg(p)= ¬p, Neg(¬p)= p, Neg(X)= X  Neg(.1 . .2)= 
Neg(.1) . Neg(.2), and Neg(.1 . .2)= Neg(.1) . Neg(.2)  If . = (call) .'{.1,.2,...,.k}, then Neg(.)=[call] 
Neg(.'){Neg(.1),Neg(.2),...,Neg(.k)}  If . =[call ] .'{.1,.2,...,.k}, then Neg(.)= (call) Neg(.'){Neg(.1),Neg(.2),...,Neg(.k)} 
  Neg((loc).')=[loc]Neg(.'), and Neg([loc].')= (loc)Neg(.')  Neg((ret)Ri)=[ret]Ri, and Neg([ret ]Ri)= 
(ret)Ri  Neg(µX..)= .X.Neg(.), and Neg(.X..)= µX.Neg(.) Performing induction on the structure of ., 
we obtain: THEOREM 1. For all closed VP-µ formulas ., [[.]]. = S \ [[Neg(.)]].. Second, note that the 
semantics of closed VP-µ formulas is independent of the environment; customarily, we will evaluate such 
formulas in the unique empty environment .: Ø. S. More importantly, the semantics of such a formula . 
does not depend on current color assignments; in other words, for all s = (s,U1,U2,...,Uk), s . [[.]]. 
iff (s). [[.]].. Conse­quently, when . is closed, we can infer that node s satis.es . from summary s 
satis.es .. Third, every VP-µ formula .(X) with a free variable X can be viewed as a map .(X):2S . 2S 
de.ned as fol­lows: for all environments E and all summary sets S . S, .(X)(S)= [ .(X)]]E[X:=S].It is 
not hard to verify that this map is monotonic, and that therefore, by the Tarski-Knaster theorem, its 
least and greatest .xed points exist. The formulas µX..(X) and .X..(X) respectively evaluate to these 
two sets. From Tarski-Knaster, we also know that for a VP-µ formula . with one free variable X, the set 
[[µX..]]. lies in the sequence of summary sets Ø,.(Ø),.(.(Ø)),..., and that [[.X..]]. is a member of 
the sequence S,.(S),.(.(S)),.... Fourth, a VP-µ formula . may also be viewed as a map . : (U1,U2,...,Uk) 
. S', where S' is the set of all nodes ssuch that U1,U2,...,Uk . MR(s) and the summary (s,U1,U2,...,Uk)satis.es 
.. Naturally, S' = Ø if no such sexists. Now, while a VP­µ formula can demand that the color of a return 
from the current context is i, it cannot assert that the color of a return must not be i (i.e., there 
is no formula of the form, say, (ret)¬Ri). It follows that the output of the above map will stay the 
same if we grow any of the sets Ui of matching returns provided as input. Formally, let s = (s,U1,...,Uk) 
and s' = (s,U1',...Uk') be two summaries such that Ui . Ui'for all i. Then for every environment E and 
every VP-µformula ., s' . [[.]]E if s . [[.]]E . Such monotonicity over markings has an interesting rami.ca­tion. 
Let us suppose that in the semantics clauses for formulas of the form (call).'{.1,.2,...,.k} and [call 
].'{.1,.2,...,.k}, we allow t = (t,V1,...,Vk) to be any k-colored summary such that (1) t . [[.']]E , 
and (2) for all i and all s' . Vi, (s',U1 n MR(s'),U2 n MR(s'),...,Uk n MR(s')). [[.i]]E . Intuitively, 
from such a summary, one can grow the sets Ui to get the maxi­mal t that we used in these two clauses. 
From the above discus­sion, VP-µand this modi.ed logic have equivalent semantics. Finally, let us see 
what would happen if we did allow formulas of form (ret)¬Ri (at a summary (s,U1,...,Uk), the above holds 
ret iff there is an edge s -. t such that t/. Ui). It turns out that formulas involving the above need 
not be monotonic, and hence their .xpoints may not exist. To see why, consider the formula . = (call 
)((ret)R1 .(ret)(¬R1)){X}) and a structured tree where the root sleads to two ret-children s1 and s2, 
both of which are leaves. Let S1 = {(s1,Ø)}, and S2 = {(s1,Ø),(s2,Ø)}. Viewing . as a map . :2S . 2S 
, we see that .(S1) is not a subset of .(S2).  3.3 Bisimulation closure Bisimulation is a fundamental 
relation in the analysis of la­beled transition systems. The equivalence induced by a variety of branching-time 
logics, including the µ-calculus, coincides with bisimulation. In this section, we study the equivalence 
induced by VP-µ, that is, we want to understand when two nodes satisfy the same set of VP-µformulas. 
Consider two structured trees S1 =(S1,in1,E1,.1,.1) and S2 =(S2,in2,E2,.2,.2). Let S be S1 . S2 (we can 
assume that the sets S1 and S2 are disjoint), S be the set of all summaries in S1 and S2, and . denote 
the labeling of S as given by .1 and .2. The bisimulation relation ~. S × S is the greatest relation 
such that whenever s~ tholds, (1) .(s)= .(t), (2) for every edge aa s -. s', there is an edge t -. t' 
such that s' ~ t', and (3) for aa ' every edge t -. t', there is an edge s -. s' such that s' ~ t. We 
write S1 ~S2 if in1 ~ in2. VP-µ is interpreted over summaries, so we need to lift the bisimulation relation 
to summaries. A summary (s,U1,...Uk).S is said to be bisimulation-closed if for every pair u,v . MR(s) 
of matching returns of s,if u~ v, then for each 1 = i = k, u. Ui precisely when v . Ui. Thus, in a bisimulation-closed 
summary, the marking does not distinguish among bisimilar nodes, and thus, return formulas (formulas 
of the form (ret)Ri and [ret ]Ri) do not disntinguish among bisimilar nodes. Two bisimulation-closed 
sum­maries s = (s,U1,...,Uk) and t = (t,V1,...,Vk) in S and having the same number of colors are said 
to be bisimilar, written s ~ t,iff s ~ t, and for each 1 = i = k, for all u . MR(s) and v . MR(t),if 
u ~ v, then u . Ui precisely when v . Vi. Thus, roots of bisimilar summaries are bisimilar and the corresponding 
markings are unions of the same equivalence classes of the parti­tioning of the matching returns induced 
by bisimilarity. Note that every 0-ary summary is bisimulation-closed, and bisimilarity of 0­ary summaries 
coincides with bisimilarity of their roots. Consider trees S and T in Fig. 3. We have named the nodes 
s1,s2,t1,t2 etc. and labeled some of them with proposition p. Note that s2 ~ s4, hence the summary (s1,{s2},{s4}) 
in S is not bisimulation-closed. Now consider the bisimulation-closed sum­maries (s1,{s2,s4},{s3}) and 
(t1,{t2},{t3}). By our de.nition they are bisimilar. However, the (bisimulation-closed) summaries (s1,{s2,s4},{s3}) 
and (t1,{t3},{t2}) are not. We now want to prove that bisimilar summaries satisfy the same VP-µ formulas. 
For an inductive proof, we need to consider the environment also. We assume that the environment E maps 
VP-µ S t4 t3 p ¬p ¬p ¬ pp ¬p ¬pp p Legend: ret loc Figure 3. Bisimilarity. variables to subsets of 
S (the union of the sets of summaries of the disjoint structures). Such an environment is said to be 
bisimulation­closed if for every variable X, and for every pair of bisimilar summaries s ~t, s .E( X) 
precisely when t .E( X) . LEMMA 1. If E is a bisimulation-closed environment and . is a VP-µformula, 
[[ .]] E is bisimulation-closed. Proof: The proof is by induction on the structure of the formula .. 
Consider two bisimulation-closed bisimilar summaries s = (s,U1,...Uk)and t = (t,V1,...Vk), and a bisimulation-closed 
environment E. We want to show that s . [[ .]] E precisely when t . [[ .]] E . If . is a proposition 
or negated proposition, the claim follows from bisimilarity of nodes s and t. When . is a variable, the 
claim follows from bisimulation closure of E. We consider a few interesting cases. Suppose . = (ret )Ri. 
s satis.es . precisely when s has a return-edge to some node s ' in Ui. Since sand tare bisimilar, this 
can happen precisely when thas a return edge to a node t ' bisimilar to s ' , and from de.nition of bisimilar 
summaries, t ' must be in Vi, and thus t must satisfy .. Suppose . = (call). ' {.1,....m}. Suppose s 
satis.es .. ' ''' Then there is a call-successor s of s such that (s,U1,...U m)satis.es . ' , where U 
' = {u .MR( s ' ) |(u,U1 nMR( u) ,...Uk n i MR( u) ). [[ .i]] E }. Since sand tare bisimilar, there exists 
a call­successor t ' of t such that s ' ~ t ' . For each 1 = i = m, let V ' = {v .MR( t ' ) |.u .Ui ' 
.u ~v}. Verify that the summaries i ''' ''' (s ,U1,...Um) and (t,V1 ,...Vm) are bisimilar. By induction 
'' ' hypothesis, (t,V1 ,...Vm) satis.es . ' . Also, for each v . Vi ' , for 1 =i=m, the summary (v,V1 
nMR( v) ,...Vk nMR( v) )is bisimilar to (u,U1 nMR( u) ,...Uk nMR( u) ), for some u .Ui, and hence, by 
induction hypothesis, satis.es .i. This establishes that t satis.es .. Case . = µX.. ' . Let X0 = Ø.For 
i = 0 , let Xi+1 = [[ . ' ]] E[X:=Xi]. Then [[ .]] E = .i=0Xi. Since E is bisimulation closed, and X0 
is bisimulation-closed, by induction, for i = 0 , each Xi is bisimulation-closed, and so is [[ .]] E 
. As a corollary, we get that if S1 ~S2, then for every closed VP-µformula ., S1 |= .precisely when 
S2 |= .. The proof also shows that to decide whether a structured tree satis.es a closed VP­µformula, 
during the .xpoint evaluation, one can restrict attention only to bisimulation-closed summaries. In other 
words, we can rede.ne the semantics of VP-µ so that the set S of summaries contains only bisimulation-closed 
summaries. It also suggests that to evaluate a closed VP-µ formula over a structured tree, one can reduce 
the structured tree by collapsing bisimilar nodes as in the case of classical model checking. If the 
two structured trees S1 and S2 are not bisimilar, then there exists a µ-calculus formula (in fact, of 
the much simpler Hennessy-Milner modal logic, which does not involve any .xpoints) that is satis.ed at 
the roots of only one of the two trees. This does not immediately yield a VP-µ formula that distinguishes 
the two trees because VP-µ formulas cannot assert requirements across return-edges in a direct way. However, 
a more complex encoding is possible. We defer the details to the full paper. Thus, two structured trees 
satisfy the same set of closed VP-µformulas precisely when they are bisimilar. Let us consider two arbitrary 
nodes s and t (in the same struc­tured tree, or in two different structured trees). When do these two 
nodes satisfy the same set of closed VP-µformulas? From the ar­guments so far, bisimilarity is suf.cient. 
However, the satisfaction of a closed VP-µformula at a node sdepends solely on the subtree rooted at 
s and truncated at the matching returns of s. In fact, the full subtree rooted at smay not be structured 
as it can contain ex­cess returns. For a structured tree S, and a node s, let Ss denote the structured 
tree rooted at sobtained by deleting all the return-edges leading to the nodes in MR( s) . For instance, 
in Fig. 3, Ss1 com­prises nodes s1 and s5 and the loc-edge connecting them. It is easy to check that 
if . is a closed VP-µformula then (s)satis.es .in the original structured tree precisely when Ss satsi.es 
..If sand t are not bismilar, and the non-bisimilarity can be established within the structured subtrees 
Ss and St rooted at these nodes, then some closed VP-µformula can distinguish them. THEOREM 2. Two nodes 
sand tsatisfy the same set of closed VP­µformulas precisely when Ss ~St.  4. Specifying requirements 
In this section, we explore how to use VP-µas a speci.cation lan­guage. On one hand, we will see how 
VP-µand classical temporal logics differ fundamentally in style of expression; on the other, we will 
express properties not expressible in logics like the µ-calculus. The C program in Fig. 4 will be used 
to illustrate some of our speci.cations. Also, because .xpoint formulas are typically hard to read, we 
will de.ne some syntactic sugar for VP-µusing CTL­like temporal operators. Reachability Let us express 
in VP-µ the reachability property Reach that says: a node tsatisfying proposition pcan be reached from 
the current node sbefore the current context ends. As a pro­gram starts with an empty stack frame, we 
may omit the restriction about the current context if smodels the initial program state. Now consider 
a nontrivial witness p for Reach that starts with call an edge s-.s ' . There are two possibilities: 
(1) a node satisfying pis reached in the new context or a context called transitively from ''' '' it, 
and (2) a matching return s of s is reached, and at s , Reach is once again satis.ed. To deal with case 
(2), we mark a matching return that leads to p by color 1. Let X store the set of summaries of form (s 
'' ), where s '' satis.es Reach. Then we want the summary (s,MR( s) )to satisfy (call ). ' {X}, where 
. ' states that s ' can reach one of its matching returns of color 1. In case (1), there is no return 
requirement (we do not need the original call to return), and we simply assert (call )X{}. Before we 
get to . ' , note that the formula (loc)X captures the case when pstarts with a local transition. Combining 
the two cases and using CTL-style notation, the formula we want is EF p= µX.( p.(loc)X .(call )X{}.(call 
). ' {X}) . Now observe that . ' also expresses reachability, except (1) its target needs to satisfy 
(ret)R1, and (2) this target needs to lie in the same procedural context as s ' . In other words, we 
want to express what we call local reachability of (ret )R1. It is easy to verify that . ' = µY.( (ret 
)R1 .(loc)Y .(call )Y{Y}) . We cannot merely substitute pfor (ret )R1 in . ' to express local reachability 
of p. However, a formula EFl p for this property is easily obtained by restricting the formula EF p: 
EF l p = µX.(p .(loc)X .(call). '{X}). For example, consider the structured tree in Fig. 4 that models 
the unfolding of the C program in the same .gure. The transitions in the tree are labeled by line numbers, 
and some of the nodes are labeled by propositions. Suppose we have a proposition free(x) that is true 
immediately after a line where x is freed, EFl free(x) holds at the entry point of procedure foo (node 
s1). Generalizing, we will allow p to be any VP-µ formula that keeps EF p and EFl p closed. It is easy 
to verify that the formula AF p, which states that along all paths from the current node, a node satisfying 
p is reached before the current context terminates, is given by AF p = µX.(p .([loc]X .[call ]. ''{X})), 
where . ''demands that a matching return colored 1 be reached along all local paths: . ''= µY.(p .([ret]R1 
.[loc]Y .[call]Y {Y })). As in the previous case, we can de.ne a corresponding operator AF l that asserts 
local reachability along all paths. For instance, in Fig. 4, AF l free(x) does not hold at node s1. Note 
that the highlight of this approach to speci.cation is the way we split a program unfolding along procedure 
boundaries, specify these pieces modularly, and plug the summary speci.ca­tions so obtained into their 
call sites. This interprocedural reason­ing distinguishes it from logics such as the µ-calculus that 
would reason only about global runs of the program. Also, there is a signi.cant difference in the way 
.xpoints are computed in VP-µ and the µ-calculus. Consider the .xpoint com­putation for the µ-calculus 
formula µX.(p .()X) that expresses reachability of a node satisfying p. The semantics of this formula 
is given by a set SX of nodes which is computed iteratively. At the end of the i-th step, SX comprises 
nodes that have a path with at most (i -1) transitions to a node satisfying p. Contrast this with the 
evaluation of the outer .xpoint in the VP-µ formula EF p. Assume that . '(intuitively, the set of jumps 
from calls to re­turns ) has already been evaluated, and consider the set SX of summaries for EF p. At 
the end of the i-th phase, this set contains all s = (s)such that s has a path consisting of (i -1) call 
and loc-transitions to a node satisfying p. However, because of the sub­formula (call). '{X}, it also 
includes all s where s reaches p via a path of at most (i -1) local and jump transitions. Note how return 
edges are considered only as part of summaries plugged into the computation. Invariance and until Now 
consider the invariance property on some path from the current node, property p holds everywhere till 
the end of the current context. A VP-µ formula EG p for this is obtained from the identity EG p = Neg(AF 
Neg(p)). The formula AG p, which asserts that p holds on each point on each run from the current node, 
can be written similarly. Other classic branching-time temporal properties like the exis­tential weak 
until (written as E(p1 Wp2)) and the existential until (E(p1 Up2)) are also expressible. The former holds 
if there is a path p from the current node such that p1 holds at every point on p till it reaches the 
end of the current context or a node satisfying p2 (if p doesn t reach either, p1 must hold all along 
on it). The latter, in addition, requires p2 to hold at some point on p. The for-all-paths analogs of 
these properties (A(p1 Up2) and A(p1 Wp2)) aren t hard to write either. Neither is it dif.cult to express 
local or same-context versions of these properties. Consider the maximal subsequence p 'of a program 
path p from s such that each node of p 'belongs to the 1 int a, *g; s1 2 void foo () 4 3{ modl(e) 4 int 
*x, b=1; 5 5 x = ALLOC(int); 6 g=x; 6 7 bar (); 8 free (x); cbar 9 b=a*a+b*b; 7 10 return; 11 } 15 cfoo 
modg (e) 12 void bar () 17 free(g) 13 { 19 4 14 int y; 20 15 a++; 16 if (y==0) 58 17 free(g); free(x) 
18 else 9 6 19 foo (); 20 return; usee 21 } modl(e) . . . Figure 4. A C example same procedural context 
as s.A VP-µ formula EGl p for exis­tential local invariance demands that p holds on some such p ', while 
AGl p asserts the same for all p '. Similarly, we can de.ne existential and universal local until properties, 
and correspond­ing VP-µ formulas E(p1 Ul p2) and A(p1 Ul p2). For instance, in Fig. 4, E(¬free(g) Ul 
free(x)) holds at node s1 (whereas E(¬free(g) U free(x)) does not). Weak versions of these for­mulas 
are also written with ease. For instance, it is easy to verify that we can write generic existential, 
local, weak until properties as E(p1 Wl p2)= .X.((p1 .p2) .(p2 .(loc)X .(call). '{X})), where . 'asserts 
local reachability of (ret)R1 as before. Interprocedural data.ow analysis It is well-known that many 
classic data.ow analysis problems can be reduced to temporal logic model-checking over program abstractions 
[24, 23]. For example, consider the problem of .nding very busy expressions in a program that arises 
in compiler optimization. An expression e is said to be very busy at a program point s if every path 
from s must evaluate e before any variable in e is rede.ned. Let us .rst assume that all variables are 
in scope all the time along every path from s.Now label every node in the program s unfolding right after 
a statement evaluating e by a proposition use(e), and every node reached via rede.nition of a variable 
in e by mod(e) (see Fig. 4). Because of loops in the .ow graph, we would not expect every path from s 
to eventually satisfy use(e); however, we can demand that each point in such a loop will have a path 
to a loop exit from where a use of e would be reachable. Then a VP-µ formula that demands that e is very 
busy at s is A((EF use(e) .¬mod(e)) W use(e)). Note that this property uses the power of VP-µ to reason 
about branching time. However, complications arise if we are considering interproce­dural paths and e 
has local as well as global variables. Suppose in Fig 4, the global variable a and the local variable 
b are two observ­ables, and we want to check if the expression e =(a 2 + b2), used in line 9, is very 
busy at line 6. We would, as before, track changes to a and b between lines 6 and 9. But we must note 
that as soon as an interprocedural path p between these two points leaves the current context, the observable 
b falls out of scope. This path may subsequently come back to procedure foo because of recursion, and 
a new instance of b may be created. However, modi.cation of this new instance of b should not cause e 
not to be very busy in the current context. In other words, we should only be concerned with the local 
uses of b. For the same reason, use of e in a different con­text should not be of interest of us. On 
the other hand, the global variable a needs to be tracked through every context along a path before a 
local use of e on it. Local temporal properties come of use in covering such cases. Let us de.ne two 
propositions modg(e) and modl(e) that are true at points where, respectively, a global or a local variable 
in e is modi.ed. The VP-µ property we assert at s is .X.(((EFl use(e)) .¬modg (e) .¬modl (e)) .use(e)) 
.(use(e) .([loc]X .[call ].{X, tt})), where the formula . tracks global variables like a in new contexts: 
. = µY.(¬modg(e) .(([ret]R1 .(ret)R2) .([call ]Y {Y, tt}.[loc]Y ))). Note the use of the formula (ret)R2 
to ensure that [ret ]R1 is not vacuously true. Pushdown speci.cations The domain where VP-µ stands out 
most clearly from previously studied .xpoint calculi is that of pushdown speci.cations, i.e., speci.cations 
involving the program stack. We have already introduced a class of such speci.cations expressible in 
VP-µ: that of local temporal properties. For in­stance, the formula EFl p needs to track the program 
stack to know whether a reachable node satisfying p is indeed in the initial calling context. Some such 
speci.cations have previously been discussed in context of the temporal logic CARET. On the other hand, 
it is well-known that the modal µ-calculus is a regular speci.cation language (i.e., it is equivalent 
in expressiveness to a class of .nite­state tree automata), and cannot reason about the stack in this 
way. We have already seen an application of these richer speci.cations in program analysis. In the rest 
of this section, we will see more of them. Nested formulas and stack inspection Interestingly, we can 
ex­press certain properties of the stack just by nesting VP-µ formulas for (non-local) reachability and 
invariance. To understand why, re­call that VP-µ formulas for reachability and invariance only reason 
about nodes appearing before the end of the context where they were asserted. Now let us try to express 
a stack inspection property such as if procedure foo is called, procedure bar must not be on the call 
stack. Speci.cations like this have previously been used in research on software security [19, 15], and 
are not expressible by regular speci.cations like the µ-calculus. While the temporal logic CARET can 
express such properties, it requires a past-time operator called caller to do so. To express this property 
in VP-µ, we de.ne propositions cfoo and cbar that respectively hold at every call site for foo and bar. 
Now, assuming control starts in foo, consider the formula . = EF (cbar .(call )(EF cfoo ){}). This formula 
demands a program path where, .rst, bar is called (there is no return requirement), and then, before 
that context is popped off the stack, a call site for foo is reached. It follows that the property we 
are seeking is Neg(.). Other stack inspection properties expressible in VP-µ include when procedure foo 
is called, all procedures on the stack must have the necessary privilege. Combining reasoning about the 
pro­gram stack with reasoning about the global evolution of the pro­gram, VP-µ can even specify dynamic 
security constraints where privileges of procedures change dynamically depending on the privileges used 
so far. Stack over.ow One of the hazards of using recursive calls in a C-like language is that stack 
over.ow, caused by unbounded recur­sion, is a serious security vulnerability. VP-µ can specify require­ments 
that safeguard against such errors. Once again, nested modal­ities come handy. Suppose we assert AG((call). 
{}) throughout every context reached through k calls in succession without inter­vening returns (this 
can be kept track of using a k-length chain of (call) modalities). This will disallow further calls, 
bounding the stack to height k. Other speci.cations for stack boundedness include: every call in every 
program execution eventually returns. This property re­quires the program stack to be empty in.nitely 
often. Though this requirement does not say how large the stack may get even if a call returns, it may 
still over.ow the stack at some point. Further, in certain cases, a call may not return because of cycles 
introduced by abstraction. However, it does rule out in.nite recursive loops in many cases; for instance, 
the program in Fig. 4 will fail this prop­erty because of a real recursive cycle. We capture it by asserting 
AG Termin at the initial program point, where Termin =[call](AF l((ret)R1)){tt}. Preconditions and postconditions 
For a program state s, let us consider the set Jmp(s) of nodes to which a call from s may return. Then 
the requirement: property p holds at some node in Jmp(s) is captured by the VP-µ formula (jump)p = (call)(EF 
l (ret)R1){p}. The dual formula [jump]p, which re­quires p to hold at all such jump targets, is also 
easily constructed. An immediate application of this is to encode the partial and to­tal correctness 
requirements popular in formalisms like Hoare logic and JML [9]. A partial correctness requirement for 
a procedure A asserts that if precondition Pre is satis.ed when A is called, then if A terminates, postcondition 
Post holds upon return. Total correct­ness, additionally, requires A to terminate. These requirements 
can­not be expressed using regular speci.cations. In VP-µ, let us say that at every call site to procedure 
A, proposition cA holds. Then a formula for partial correctness, asserted at the initial program state, 
is AG((Pre .cA) .[jump]Post). Total correctness is expressed as AG((Pre .cA) .(Termin .[jump]Post)). 
Access control The ability of VP-µ to handle local and global vari­ables simultaneously is useful in 
other domains, e.g., access con­trol. Consider a procedure A that can be called with a high or low privilege, 
and suppose we have a rule that A can access a database (proposition access is true when it does) only 
if it is called with a high privilege (priv holds when it is). It is tempting to write a prop­erty . 
= ¬priv . AG (¬access) to express this requirement. However, a context where A has low privilege may 
lead to another where A has high privilege via a recursive invocation, and . will not let A access the 
database even in this new context. The formula we are looking for is really . '= ¬priv . AGl (¬access), 
as­serted at every call site for A. Multiple return conditions As we shall see in Section 6.2, the theoretical 
expressiveness of VP-µ depends on the fact that we can pass multiple return conditions as parameters 
to VP-µ call formulas. We can also use these parameters to remember events that happen within the scope 
of a call and take actions accordingly on return. To see how, we go back to Figure 4; now we interested 
in the properties of the pointer variables x and g. Suppose control starts at foo and moves on to bar; 
also, let us ignore the recursion in line 19 and assume the call to bar in line 7 returns. Before this 
call, x and g point to the same memory location. Now consider two scenarios once this call returns: (1) 
the global g was freed in the new context before the return, so that x now points to a freed location, 
(2) g was not freed, so that x still points to allocated memory. Suppose our requirements for the next 
program point in the two cases are: (1) x must not be freed in foo, (2) x should be freed to avoid memory 
leak. We express these requirements by asserting the VP-µformula .at the program point calling bar: .=(call). 
'{[loc]¬free(x),[loc]free(x)}, where . 'is a .xed-point property that states that: each path in the new 
context must (1) see free(g)at some point and then reach (ret)R1, or (2) satisfy ¬free(g)until (ret)R2 
holds. We omit the details for want of space. 5. Model-checking In this section, we introduce the problem 
of model-checking VP­µ over unfoldings of recursive state machines. Our primary result is an iterative, 
symbolic decision procedure to solve this problem. Appealingly, this algorithm follows directly from 
the operational semantics of VP-µand has the same complexity as the best algo­rithms for model-checking 
µ-calculus over similar abstractions. We also show a matching lower bound. 5.1 Recursive state machines 
Recursive state machines (RSMs) are program abstractions that model interprocedural control .ow in recursive 
programs [3]. While expressively equivalent to pushdown systems, RSMs are more visual and tightly coupled 
to program control .ow. For this reason, we will use them as our system model. Syntax. A recursive state 
machine (RSM) M over a set of proposi­tions AP is a tuple ((M1,M2,...,Mm),start), where each Mi is a 
procedure of the form (Li,Bi,Yi,Eni,Exi,di,.i). The mean­ing of the components of Mi is summarized in 
the following: Li is a .nite set of control locations, and Bi is a .nite set of boxes.  Yi :Bi .{1,2,...,m}is 
a map that assigns a procedure to every box.  Eni .Li is a non-empty set of entry locations, and Exi 
.Li is a non-empty set of exit locations.  Let Callsi = {(b,en): b . Bi,en . EnYi(b)} denote the set 
of calls in Mi, and let Retnsi = {(b,ex): b . Bi,ex . ExYi(b)} denote the set of returns in Mi. Then 
di .(Li .Retnsi)×(Li .Callsi)de.nes the set of RSM edges.  .i is a labeling function .i :(Li .Callsi 
.Retnsi).2AP that associates a set of propositions to each control location, call and return.  A control 
location start . in one of the components is Si Li chosen as the initial location. We assume that for 
every distinct i and j, Li, Callsi, Retnsi, Nj , Callsj, and Retnsj are pairwise disjoint. We refer to 
arbitrary calls, returns and control locations S in M as vertices. The set all vertices is given by V 
=i(Li . Callsi .Retnsi), and the set of vertices in procedure j is denoted S by Vj. We also write B =i 
Bi to denote the collection of all boxes in M. Finally, the extensions of all functions di, .i and Yi 
foo bar Figure 5. A recursive state machine. are denoted respectively by d : V . V, . : V . 2AP , and 
Y :B .{1,2,...,m}. Fig. 5 depicts an RSM extracted from the C program in Fig. 4. Here we are interested 
in the behavior of the pointer variable g, and variables and statements not relevant to this behavior 
are abstracted out. We use two propositions g0 and g1 that are true respectively when g points to free 
and allocated memory. The procedures and vertices in this RSM correspond to procedures and control states 
in Fig. 4; transitions correspond to lines of C code and are labeled by line numbers. Each procedure 
has two entry and exit points corresponding to the two possible abstract values of g. Pointer assignments 
and calls to free and ALLOC changes the values of these propositions in the natural way. Note in particular 
that we cannot tell without a global side-effect analysis whether x and g point to the same location 
be­fore line 8. We model this uncertainty using nondeterminism. Semantics. The semantics of an RSM M 
are de.ned by an in.­nite graph C(M)=(C,c0,EC ,.C ,.C ), known as its con.gu­ration graph. Here, C is 
a set of con.gurations, c0 is the initial con.guration, EC .C ×C is a transition relation, and functions 
.C :C .2AP and .C :EC .{call ,ret ,loc}respectively la­bel con.gurations and transitions. Stealing notation 
for structured s ''' trees, we write c -.c if (c,c ).EC and .C ((c,c ))=a. The set C of con.gurations 
in C(M)comprise all elements (.,u).B *×V such that either . =and u .V,or  . =b1 ...bn (with n =1) and 
(1) u .VY (bn), and (2) for all i.{1,...,n-1}, bi+1 .BY (bi).  The initial con.guration is c0 =(,start). 
The con.guration­labeling function .G is de.ned as: .G((.,u)) = .(u), for all (.,u) . B *×V. Now we can 
de.ne the transition relation EG and the transition-labeling function .G in G.For c =(.,u), ''' c =(. 
,u )and a .{call,ret,loc}, we have a transition a c-.c 'if and only if one of the following holds: Local 
move: u .(Li .Retnsi)\Exi, (u,u ').di, . '=., and a=loc;  Procedure call: u =(b,en).Callsi, u '=en, 
. '=..b, and a=call;  Return from a call: u . Exi, . = . '.b, u '=(b,u), and a=ret.  5.1.1 Con.guration 
trees We will evaluate VP-µformulas on con.guration trees of RSMs, which are unfoldings of con.guration 
graphs of RSMs. Consider an RSM M with con.guration graph C(M)=(C,c0,EC ,.C ,.C ). The con.guration tree 
of M is a structured tree Conf (M)= (S,s0,E,.,.), whose set of nodes S .C+ and set of transitions E .S×S 
are the least sets constructed by the following rules: 1. c0 .S. 2. Let s.c .S for some s .C *and some 
con.guration c .C, a and suppose c -.c 'for some a .{call , loc, ret }and some a ''' c .C. Then s.c.c 
.S and s.c -.s.c.c . The above also de.nes the transition-labeling map . in Conf (M). The node-labeling 
function . is given by: for each node s =s '.c, .(s)= .C(c). The initial node is s0 = c0. Finally, we 
de.ne a map Curr :S .C that gives us the current con.guration for any node in Conf (M)as follows: for 
all s . C *and all c . C,if s.c .S then Curr(s.c)=c. Summaries in Conf (M) are now de.ned as in Section 
2.1. We identify the summary s0 = (s0)as the initial summary in Conf (M). We say that the RSM M satis.es 
a closed VP-µ for­mula . if and only if s0 . [[.]].. Note that each node in Conf (M) captures, along 
with the current con.guration, the history of an execution till this point. However, it is easy to see 
that if Curr(s)= Curr(s ')for two nodes s and s 'in Conf (M), then s and s 'are bisimilar. Then by Theorem 
2, the difference between the histories of s and s 'is irrelevant so far as VP-µ formulas are concerned. 
 5.2 Model-checking VP-µ over RSMs For a closed VP-µ formula . and an RSM M, the model-checking problem 
of . over M is to determine if M satis.es .. Recall that con.gurations of M are of the form (., u), where 
. is a stack of boxes and u is a vertex in M. Clearly, the set MR(s) for the current node s and the set 
.ret of ret-subformulas that hold at the current summary depend on the current stack .. However, we observe 
that both these sets refer only to the box to which control returns from the current context, and not 
to boxes further down the box stack. In other words, so far as satisfaction of VP-µ formulas go, we are 
only interested in the top of .. To formalize this intuition, let us de.ne a map Erase :(.,u). u that 
erases the stack of a given con.guration of M. We can extend this map to sets of nodes in the usual way. 
Now con­sider two k-colored summaries s =(s,U1,U2,...,Uk)and s '= (s ',U1',U2',...,U k'), where Curr(s)=(.b,u)and 
Curr(s ')= (. 'b, u). We call s and s 'top-equivalent if and only if for all i, Erase(Ui)=Erase(Ui'). 
Then we have: LEMMA 2. Let s1 and s2 be two top-equivalent k-colored sum­maries in the con.guration tree 
of an RSM M. Then for any closed VP-µ formula ., s1 satis.es . iff s2 satis.es .. It turns out that we 
can restrict our attention to bounded-size sum­maries that only keep track of the top of the box stack 
while doing VP-µ model-checking. We call these summaries stackless.In or­der to de.ne stackless summaries 
formally, we will need to de.ne reachability between nodes in an RSM. Consider any vertex u in an RSM 
M. A vertex v is said to be empty-stack reachable from u if there is a path in Conf (M)from (,u)to (, 
v). It is well-known that for any u, the set Reach(u)of vertices empty-stack reachable from u can be 
computed in time polynomial in the size of M [3]. We also need to de.ne the set of possible returns from 
an RSM vertex u. Suppose u .Vl is in procedure Ml. The set Retb(u)of possible returns from u to a box 
b with Y (b)= l consists of all (b,ex)such that ex .Reach(u)nEx l. Clearly, for any u and b, the set 
Retb(u)can be computed in time polynomial in M. Also, we will use the notation Ret(u)=.bRetb(u). Now, 
let n be the arity of the formula ..A stackless summary is a tuple (u,Ret1, Ret2,..., Retk), where 0 
= k = n, and for some b, Retj . Retb(u) for all j. The set of all stackless summaries in M is denoted 
by SLS . Let ESL : Free(.) . 2SLS be an environment mapping free variables in . to sets of stackless 
summaries, and let .denote FIXPOINT (X, ., ESL) 1 X '=Eval(., ESL) 2 if X '=ESL(X) 3 then return X ' 
4 else return FIXPOINT (X, . ', ESL[X :=X ']) Figure 6. Fixpoint computation for VP-µ. the empty environment. 
We de.ne a function Eval(., ESL)that assigns a set of stackless summaries to a VP-µ formula .: If . 
= p, for p . AP, then Eval(., ESL) consists of all (v, Ret1,Ret2,.. .,Retk)such that p ..(v)and k =n. 
 If . = ¬p, for p . AP, then Eval(., ESL)consists of all (v, Ret1,Ret2,.. .,Retk)such that p/..(v)and 
k =n.  If . =X, for X .Var , then Eval(., ESL)=ESL(X).  If . =.1 ..2 then  Eval(., ESL)=Eval(.1, ESL).Eval(.2, 
ESL). If . =.1 ..2 then Eval(., ESL)=Eval(.1, ESL)nEval(.2, ESL). If . = (call) . '{.1,.2, ..., .m}, 
then Eval(., ESL) con­sists of all ((b, en), Ret1, Ret2,..., Retk)such that for some ''' (en,Ret 1, Ret 
2, ..., Ret ). Eval(. ', ESL), and for all '' (b ',ex ).Ret i, where i m=1,...,m, we have: 1. b '=b '''''' 
 2. ((b ',ex '), Ret 1 , Ret 2 ,..., Ret k).Eval(.i, ESL), where '' Ret j =Retj nRet((b ',ex '))for all 
j =k. If . =[call ]. '{.1,...,.m}, then we have Eval(., ESL)= Eval(.,ESL).Noncall, where . =(call). 
'{.1,.2, ..., .m}, and Noncall comprises all summaries (u, Ret1,..., Retk), for k =n, such that u is 
not a call. This works because the [call ] modality may hold vacuously, and because a node in an RSM 
can have at most one outgoing call-transition.  If . = (loc). ', then Eval(., ESL)consists of all stackless 
summaries (u, Ret1,..., Retk)such that for some v satisfying (u, v).d, we have (v,Ret1 nRet(v),... ,Retk 
nRet(v)).Eval(. ', ESL).  If . =[loc]. ', then Eval(., ESL)consists of all stackless summaries (u, Ret1,... 
,Retk)such that for all v satisfying (u, v).d, we have (v,Ret1 nRet(v),..., Retk nRet(v)).Eval(. ', ESL). 
 If . =(ret)Ri, then Eval(., ESL)consists of all summaries (ex,Ret1,..., Retk)such that (1) Reti = {(b,ex)}, 
where (b,ex).Ret(ex), and (2) for all j =i, Retj =Ø.  If . =[ret]Ri, then Eval(., ESL)=Eval((ret)Ri, 
ESL). Nonret, where Nonret has all summaries (u, Ret1,..., Retk)such that u is not an exit.  If . =µX.. 
', then Eval(., ESL)=FixPoint (X, . ', ESL[X :=Ø]).  If . =.X.. ', then Eval(., ESL)=FixPoint (X, . 
', ESL [X :=SLS]).  Here FixPoint (X, ., ESL)is a .xpoint computation function that uses the formula 
. as a monotone map between subsets of SLS , and iterates over variable X. This computation in described 
in Fig. 6. The following theorem is easily proved: THEOREM 3. ForanRSM M and a closed VP-µ formula ., 
Conf (M)satis.es . if and only if (s0). Eval(., .). Further­more, Eval(., .)is computable. Note that 
our decision procedure is symbolic in nature, and that one could represent sets of summaries using BDD-like 
data structures. Also, it directly implements the operational semantics of VP-µ for­mulas over stackless 
summaries. In this regard VP-µ resembles the modal µ-calculus, whose formulas encode .xpoint computations 
over sets; to model-check µ-calculus formulas, we merely need to perform these computations. Unsurprisingly, 
our procedure is very similar to classical symbolic model-checking for the µ-calculus. 5.3 Complexity 
In an RSM M, let . be an upper bound on the number of possible returns for a vertex, and let NV be the 
total number of vertices. Let n be the arity of the formula in question. Then the total number of stackless 
summaries in M that we need to consider is bounded by N = nNV 2.n. Let us now assume that union or intersection 
of two sets of summaries, as well as membership queries on such sets, take linear time. It is easy to 
see that the time needed to evaluate a non-.xpoint formula . of arity k is bounded by O(N2.|.|)(the most 
expensive modality is (call ). '{.1,...,.n}, where we have to match an inner summary satisfying . 'as 
well as n outer summaries satisfying the .i-s). For a .xpoint formula . with one .xpoint variable, we 
may need N such evaluations, so that the total time required to evaluate Eval (., .)is O(N3.|.|). For 
a formula N3d . of alternation depth d, this evaluation takes time O(.d |.|). It is known that model-checking 
alternating reachability speci­.cations on an RSM M is EXPTIME-hard [26]. Following con­structions similar 
to those in Section 4, we can generate a VP-µ formula . from a µ-calculus formula f expressing such a 
property such that (1) the size of . is linear in the size of f, and (2) M sat­is.es . if and only if 
M satis.es f. It follows that model-checking a closed VP-µ formula . on an RSM M is EXPTIME-hard. Combining 
all of the above, we have: THEOREM 4. Model-checking a VP-µ formula . on an RSM M is EXPTIME-complete. 
 6. Expressiveness Now we present a few results concerning the expressiveness of VP­µ. 6.1 VP-µ and 
the temporal logic CARET We will now establish that the temporal logic CARET is contained in VP-µ. A 
visibly pushdown automaton A is a pushdown automaton with an added restriction: its input alphabet Sis 
partitioned into a call alphabet Sc,a local alphabet Sl, and a return alphabet Sr.On reading a call or 
return symbol, Amust respectively push and pop precisely one symbol on/from the stack; on a local input 
symbol, Amust change state without modifying the stack. A run of such an automaton on an input word w 
is simply a sequence of moves it makes while reading w. From the results implicit in [2, 4], it follows 
that for any CARET formula . over the set of propositions P, there exists A. over in.nite words with 
a B¨uchi acceptance condition, over the alphabet Si = {(loc,v) | v . 2P }, Sc = {(call ,v) | v . 2P } 
and Sr ={(ret ,v)| v . 2P }that accepts precisely the models that satisfy .. We can show that: THEOREM 
5. For any nondeterministic B¨uchi visibly pushdown automaton Aover the alphabets described above, there 
is a VP­µ formula .Athat holds in a structured tree if and only if there is some path in the tree that 
is accepted by A. It follows as a corollary that CARET model checking is reducible to VP-µ model-checking:wecantakethenegationofany 
CARETfor­mula ., .nd the corresponding VP-µ formula, and check whether it holds in a program model. The 
model satis.es this VP-µ formula if and only if it is not the case that all runs of the model satisfy 
the CARET formula. We will now sketch the idea behind the proof of Theorem 5. For brevity, however, we 
will consider acceptance by .nal state rather than B¨uchi acceptance. More precisely, we will have a 
special .nal state qf , and a run will be considered accepting if and only if it reaches qf somewhere 
along the run. This simpli.cation will take out many of the details of our translation while retaining 
its basic .avor. Now, .Awill be a 1-ary formula, and will have variables Xq and Sq,q.,b, where q, q 'in 
A and b . B (the stack alphabet). Intuitively, a 1-ary summary (s, U)will be in Xq if there is a run 
starting from s and state q along some path that reaches qf before it meets any matching return of s. 
The summary (s, U)will be in Sq,q.,b if s is not at the top-level, there is a path that ends with an 
unmatched return edge, and the automaton has a run from q to q 'along this path such that at the unmatched 
return b is popped from the stack to reach q '. We will write the VP-µ formula .Ausing a set of equations 
rather than in the standard form. Translation from this equational form to the standard form proceeds 
as in the modal µ-calculus [16]; we leave out the details. Let us denote internal transitions as (q, 
v, q '), push transitions as (q, v, q ',b)(if in state q and read­ing (call,v), push b onto stack and 
go to q '), and pop transitions as (q, v, b, q ')(if in state q with b on top-of stack and reading (ret 
,v), pop b and go to q '). Let the set of transitions of Abe .. Also, for VV each valuation v .2P , let 
.v =p . .v ¬p. p.vp Then, the formula .Awill be the formula corresponding to Xqin when taking the least 
.xpoint of the following equations: _ Xq =(.v .(loc)Xq. ) (q,v,q.).. _ . (.v .(call)Xq. {. }) (q,v,q.,b).. 
. (.v .(call)Sq1,q.,b{Xq. }) (q,v,q1,b).. q. _ Sq,q.,b =(.v .(ret)R1) (q,v,b,q.).. _ . (.v .(loc)Sq..,q.,b) 
..).. (q,v,q . (.v .(call)Sq1,q2,b. {Sq2,q.,b}). (q,v,q1,b.).. q2 6.2 An arity hierarchy Now we show 
that the expressiveness of VP-µ formulas increases with their arity. For two structured trees S1 and 
S2 with initial nodes s1 and s2,wesay S1 and S2 are distinguished by a closed, k-ary VP-µ formula . if 
and only if s1 satis.es . and s2 does not. Then we have: THEOREM 6. For every k = 1, there is a a closed 
(k +1)-ary formula .k+1, and two structured trees S1 and S2, such that .k+1 can distinguish between S1 
and S2, but no closed k-ary VP-µ formula can. We will sketch the proof for the case k =1. Before we do 
so, we need some extra machinery. More precisely, we will de.ne a preorder called quasi-bisimilarity 
over summaries that takes into account their coloring. It turns out that VP-µ respects this preorder. 
a) ST t4 t7s9 s7 p ¬pp p ¬p ¬p pp ¬p ¬p a1 a2 an $ b1 b2 b3 bm b) Legend: * call ret loc **    
      Figure 7. (a) An arity hierarchy (b) Tree encoding for undecid­ability. Consider a pair of 
k-colored summaries s = (s,U1,...,Uk)and t = (t,V1,...,Vk) such that each path in the trees rooted at 
s and t comprises a chain of loc-edges followed by one ret -edge leading to a leaf. Let S and T respectively 
be the sets of non-leaf nodes in these trees. We say that s and t are quasi-bisimilar if there is a relation 
.. S× T such that s. tand ''' 1. For all s . t ', we have .(s)= .(t) loc '''''''' 2. If s . t ', then 
for every s such that s -. s , there is a t loc ''''''' such that t -. t and s . t ''. Also, for every 
t such that locloc '''''''''''' t -. t , there is an s such that s -. s and s . t . ret '''''''' 3. If 
s . t ', then for every s such that s -. s , there is a t retret '''''' such that t -. t , and for every 
t such that t -. t '', there ret ''''''' is an s such that s -. s ''. Further, if s . Ui then t . Vi, 
for all i(note that this is not an iff condition). Now, we can show inductively that if s and t are quasi-bisimilar, 
then for every variable-free VP-µformula .,if s satis.es ., then t satis.es .as well (note that the converse 
is not true; for instance, t may satisfy [ret ]Ri even when s does not). We skip the proof. Let us now 
come back to Theorem 6. Consider the two non­bisimilar structured trees S and T in Fig. 7-a with initial 
nodes s0 and t0. It is easy to see that the 2-ary VP-µ formula . = (call )((loc)((ret )R1 .(ret )R2)){p,¬p} 
distinguishes s0 and t0. Let us now see if there is a closed, 1-ary formula .that can distin­guish between 
S and T . First, if .is a disjunction or conjunction, we can get a smaller witness for this distinction. 
Further, because trees S and T are of .xed depth, we need only consider .xpoint­free formulas. The interesting 
case is that of formulas of the form .= (call). '{.}. Assume this formula is satis.ed by (s0); then there 
is a bisimulation-closed summary of the form s = (s1,U) that satis.es . '. For each such s, we .nd a 
t = (t1,V). Note that s can assume only four values; these are (s1,{s9,s4,s5}), (s1,{s10,s6,s7}), (s1,{s9,s4,s5,s10,s6,s7}), 
and (s1,Ø). The corresponding val­ues of t are (t1,{t6,t7}), (t1,{t4,t5}), (t1,{t4,t5,t6,t7}), and (t1,Ø) 
respectively. Note that for any value s takes, the corre­sponding t is quasi-bisimilar to it, which means 
that t satis.es . '. Further, for each v . V there is a bisimilar node u . U. It follows that if all 
u. U satisfy ., then so do all v . V. Then (t0) satis.es .. Similarly one can show that (t0) satis.es 
.only if (s0) satis.es .. To extend the proof to arbitrary k, we consider a structure S 'where, like 
in S, the root has one call-child s1 except s1 now has a large number N of loc-children s '. From each 
s ', we have (k+1) ret -edges leading to leaves s '', each of which is labeled with exactly one proposition 
from the set AP = {p1,p2,...,pk+1}. For (N - 1) values of s ', the leaves of the trees rooted at s 'are 
labeled such that only k of them have distinct labels. But there is a particular s '(call it sd') for 
which these leaves get distinct labels p1,...,pk+1. Now take a structure T 'that is obtained by removing 
the subtree rooted at node sd 'from S '. Following the methods for the case k =1, we can show that S 
'and T 'may be distinguished by a (k+1)-ary formula, but by no k-ary formula. We skip the details. 6.3 
Satis.ability The logic VP-µ can express several surprisingly complex proper­ties by exploiting the branching 
nature of the models. Consider the tree fragment depicted in Figure 7-b. We have a set of propositions 
P from which the ai s and bi s are drawn from; we also have extra propositions $ and *. It turns out 
that we can write a VP-µformula .whose models consist only of trees that are bisimilar to the tree given 
in the .gure, with the restriction that the word a1 ...an = bm ...b1. This is surprising as even a visibly 
pushdown word automaton cannot accept precisely the words encoded along the branch a1 ...an$b1 ...bm 
(it could if the second portion encoding the b s are returns, but not when they are calls). The VP-µformula 
can accept this by expressing mainly the following requirements: (a) there are only two ret edges after 
b1, (b) consider any position ai and let bj be a position such that the last return in the string of 
returns after bj matches the call at ai; then we require that the string of returns following bj+1 ends 
up matching the call at ai followed by exactly two more returns. These requirements ensure that the string 
of returns below the bj symbols grow according to the sequence 2,4,6,....Now,the VP-µformula also demands 
that for any position ai, if the returns below bj end by matching the call at ai, then bj = ai. This 
ensures that m = n and a1 ...an = bm ...b1. The formula has to be written carefully and is complex, and 
we omit its exact description. The above structure turns out to be very powerful. Notice that no .nite 
recursive state machine will have its unfolding as the above tree (which is why model-checking is decidable!). 
However, we can show, using the above construction, that trees of the kind above concatenated to each 
other can encode the computations of a Turing machine, and hence the satis.ability problem for VP-µis 
undecidable (we omit details of the proof): THEOREM 7. Given a VP-µ formula, the problem of checking 
whether there is some structured tree that satis.es it is undecidable.  7. Conclusions We have de.ned 
a powerful .xpoint logic over execution trees of structured programs that captures pushdown speci.cations 
taking into account both local and global program .ows. It can express several useful and interesting 
properties, both in program veri.ca­tion as well as data.ow analysis, and yet admits tractable model­checking. 
The logic uni.es and generalizes many existing logics, leading to a new class of decidable properties 
of programs that, we believe, will be a basis for future software model checking tools. In fact, the 
decidability of most known program logics (µ-calculus, temporal logics LTL and CTL, CARET, etc.) can 
be understood by interpreting them in the monadic second-order logic over trees, which is decidable (this 
can also be used to show that the satis.a­bility problem for these logics is decidable). However, there 
is no such embedding of the logic VP-µ into the MSO theory of trees (the fact that its satis.ability 
problem is undecidable argues that there cannot be such an effective embedding). This paper can lead 
to work in several interesting directions. One natural question that arises is how robust the logic VP-µ 
is. The modal µ-calculus has been shown to be the canonical bisim­ulation closed modal logic, as it captures 
all bisimulation-closed properties de.nable using monadic second order logic [18], and is exactly equivalent 
to trees accepted by a restriction of alternating parity tree automata that by design can accept only 
bisimulation­closed sets of trees [14]. While we have not discussed this aspect in this paper, the logic 
VP-µ was carefully designed to have such a canonical expressive power. We have established in a subsequent 
paper [1] that VP-µ is expressively equivalent to alternating visibly pushdown parity tree automata, 
a natural variant of tree automata on structured trees. As a corollary, it follows that for any closed 
modal µ-calculus formula f, we can construct a closed VP-µ for­mula .f such that a node in a structured 
tree satis.es f if and only if it satis.es .f . Finally, the logic VP-µ expresses properties using forward 
modalities. As argued in [23], several data.ow analysis problems also require backward modalities; extending 
VP-µ to backward modalities will result in expressing several other data.ow prob­lems.  References 
<RefA>[1] R. Alur, S. Chaudhuri, and P. Madhusudan. Visibly pushdown tree languages. http://www.cis.upenn.edu/~swarat/pubs/vptl.ps. 
[2] R. Alur, K. Etessami, and P. Madhusudan. A temporal logic of nested calls and returns. In 10th Int. 
Conf. on Tools and Algorithms for the Const. and Analysis of Software, LNCS 2988, pages 467 481, 2004. 
[3] R. Alur, K. Etessami, and M. Yannakakis. Analysis of recursive state machines. In Proc. of the 13th 
International Conference on Computer Aided Veri.cation, LNCS 2102, pages 207 220. Springer, 2001. [4] 
R. Alur and P. Madhusudan. Visibly pushdown languages. In Proc. of the 36th STOC, pages 202 211, 2004. 
[5] T. Ball and S. Rajamani. Bebop: A symbolic model checker for boolean programs. In SPIN 2000 Workshop 
on Model Checking of Software, LNCS 1885, pages 113 130. Springer, 2000. [6] T. Ball and S. Rajamani. 
The SLAM project: debugging system software via static analysis. In Proc. of the 29th ACM Symposium on 
Principles of Programming Languages, pages 1 3, 2002. [7] M. Benedikt, P. Godefroid, and T. Reps. Model 
checking of unrestricted hierarchical state machines. In 28th ICALP, volume LNCS 2076, pages 652 666. 
Springer, 2001. [8] J.R. Burch, E.M. Clarke, D.L. Dill, L.J. Hwang, and K.L. McMillan. Symbolic model 
checking: 1020 states and beyond. Information and Computation, 98(2):142 170, 1992. [9] L. Burdy, Y. 
Cheon, D. Cok, M. Ernst, J. Kiniry, G.T. Leavens, R. Leino, and E. Poll. An overview of JML tools and 
applications. In Proceedings of the 8th International Workshop on Formal Methods for Industrial Critical 
Systems, pages 75 89, 2003. [10] O. Burkart and B. Steffen. Model checking the full modal mu­calculus 
for in.nite sequential processes. Theoretical Computer Science, 221:251 270, 1999. [11] K. Chatterjee, 
D. Ma, R. Majumdar, T. Zhao, T.A. Henzinger, and J. Palsberg. Stack size analysis for interrupt driven 
programs. In Proceedings of the 10th International Symposium on Static Analysis, volume LNCS 2694, pages 
109 126, 2003. [12] H. Chen and D. Wagner. Mops: an infrastructure for examining security properties 
of software. In Proceedings of ACM Conference on Computer and Communications Security, pages 235 244, 
2002. [13] E.A. Emerson. Temporal and modal logic. In J. van Leeuwen, editor, Handbook of Theoretical 
Computer Science, volume B, pages 995 1072. Elsevier Science Publishers, 1990. [14] E.A. Emerson and 
C.S. Jutla. Tree automata, mu-calculus, and determinacy. In Proceedings of the 32nd IEEE Symposium on 
Foundations of Computer Science, pages 368 377, 1991. [15] J. Esparza, A. Kucera, and S. Schwoon. Model-checking 
LTL with regular valuations for pushdown systems. Information and Computation, 186(2):355 376, 2003. 
[16] E. Gr¨adel, W. Thomas, and T. Wilke, editors. Automata, Logics, and In.nite Games: A Guide to Current 
Research [outcome of a Dagstuhl seminar, February 2001], volume 2500 of Lecture Notes in Computer Science. 
Springer, 2002. [17] T.A. Henzinger, R. Jhala, R. Majumdar, G.C. Necula, G. Sutre, and W. Weimer. Temporal-safety 
proofs for systems code. In Proc. of 14th CAV Conference, LNCS 2404, pp. 526 538, 2002. [18] D. Janin 
and I. Walukiewicz. On the expressive completeness of the propositional mu-calculus with respect to monadic 
second order logic. In CONCUR 96: Seventh International Conference on Concurrency Theory, LNCS 1119, 
pages 263 277. Springer-Verlag, 1996. [19] T. Jensen, D. Le Metayer, and T. Thorn. Veri.cation of control 
.ow based security properties. In Proceedings of the IEEE Symposium on Security and Privacy, pages 89 
103, 1999. [20] D. Kozen. Results on the propositional mu-calculus. Theoretical Computer Science, 27:333 
354, 1983. [21] K.L. McMillan. Symbolic model checking: an approach to the state explosion problem. Kluwer 
Academic Publishers, 1993. [22] T. Reps, S. Horwitz, and S. Sagiv. Precise interprocedural data.ow analysis 
via graph reachability. In Proc. of the ACM Symposium on Principles of Programming Languages, pages 49 
61, 1995. [23] D.A. Schmidt. Data .ow analysis is model checking of abstract interpretations. In Proceedings 
of the 25th Annual ACM Symposium on Principles of Programming Languages, pages 68 78, 1998. [24] B. Steffen. 
Data .ow analysis as model checking. In Theoretical Aspects of Computer Software, LNCS 526, pages 346 
365, 1991. [25] C.S. Stirling. Modal and temporal logic. In Handbook of Logic in Computer Science, pages 
477 563. Oxford University Press, 1991. [26] I. Walukiewicz. Pushdown processes: Games and model-checking. 
Information and Computation, 164(2):234 263, 2001. </RefA>
			

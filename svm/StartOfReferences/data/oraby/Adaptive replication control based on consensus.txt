
 Adaptive Replication Control based on Consensus* Udo Fritzke Jr. Ponti.cal Catholic University of Minas 
Gerais Computer Science Department Rua Pe. Francis Cletus Cox, 1661, Poços de Caldas-MG, Brazil udo@pucpcaldas.br 
 Rodrigo Pereira Valentim Ponti.cal Catholic University of Minas Gerais Computer Science Department 
Rua Pe. Francis Cletus Cox, 1661, Poços de Caldas-MG, Brazil valentim@ comp.pucpcaldas.br Luiz Alberto 
Ferreira Gomes Ponti.cal Catholic University of Minas Gerais Computer Science Department Rua Pe. Francis 
Cletus Cox, 1661, Poços de Caldas-MG, Brazil luizgomes@pucpcaldas.br ABSTRACT This paper presents a 
meta protocol that allows the dy­namic replacement of replication control protocols in repli­cated databases. 
The meta protocol is motivated by the diversity of concurrency control and replication control pro­tocols 
that implement di.erent transaction isolation levels. The replacement of protocols allows applications 
to dynam­ically adapt themselves to consistency and data access la­tency requirements. Such kind of adaptivity 
is important in mobile systems, where weaker consistency levels are ac­ceptable when nodes are disconnected 
from a network, but stronger levels may be required when nodes are connected to each other. The paper 
de.nes three properties that meta protocol executions have to enforce and speci.es a proto­col that satis.es 
these properties. The protocol is based on a transaction execution model, uniform reliable broad­cast 
and uniform consensus. Finally, we outline a dynamic adaptable architecture that is being implemented 
that in­cludes the meta protocol and that makes use of an aspect oriented framework. Categories and 
Subject Descriptors C.2.4 [Distributed Systems]: Distributed databases; H.2.4 [Systems]: Distributed 
databases; H.3.5 [Online In­formation Services]: Data sharing.  General Terms Algorithms, Reliability. 
* This work has been developed with the support of FAPEMIG (Funda¸c ` ao de Amparo a Pesquisa do Estado 
de Minas Gerais), CEX-818/05, and FIP/PUC-MG (Fundo de Incentivo `a Pesquisa). Permission to make digital 
or hard copies of all or part of this work for personal or classroom use is granted without fee provided 
that copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice 
and the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute 
to lists, requires prior speci.c permission and/or a fee. WDDDM 08, March 31, 2008, Glasgow, UK Copyright 
2008 ACM 978-1-60558-121-7/08/03 ...$5.00.  Keywords Adaptive Replication Control, Uniform Reliable 
Multicast, Uniform Consensus, Dynamic Protocol Update. 1. INTRODUCTION Data replication has been widely 
used in order to provide database systems with high availability and better perfor­mance in a distributed 
environment. During the execution of a replicated system, the access of a replicated object is controlled 
by a particular replication control protocol. Such a protocol collaborates with concurrency control protocols 
so that data accesses are synchronized o.ering a one-copy view of the system [3]. There exists a large 
variety of repli­cation control protocols [27] that have been conceived upon di.erent assumptions on 
data consistency (or transaction isolation) needs, communication primitives, node disconnec­tion modes 
(failures or planned disconnection), replication models and data synchronization methods. The adaptation 
of replication techniques to particular ap­plication needs has also been subject of study (e.g. [7]) 
and is motivated both by the miscellanea of replication protocols and also by environment changes to 
which an application can be subjected. These include modi.cations of requirements as con.dentiality of 
data, data placement, data adminis­tration policies, storage capacity, and data access latency, among 
others. As mentioned in [7], we understand that there is no practical replication control protocol that 
ful.lls all adaptation needs, even if it was conceived to be param­eterized. Moreover, we believe that 
runtime replacement of replication control is important to some applications and accordingly, it should 
be part of database replication frame­works. Following the de.nition of adaptive programs found in [21], 
we consider that replication control is adaptive if the system is able to dynamically replace a given 
replication control protocol with another one. In mobile database systems in particular, data replication 
allows a mobile node to access local data while it is discon­nected from a network. So, as part of our 
motivation, we borrow the application scenarios presented in [19]. Holliday et al. show three practical 
replication schemes for mobile replicated databases. In the .rst one, basic sign-o. mode, a mobile node 
disconnects from the network keeping local copies of read-only data. When it reconnects it synchro­nizes 
the state with the remaining nodes that have possi­bly updated the database. In a second scheme, check-out 
mode, a mobile node can travel with updatable data, usu­ally a portion of the database, while other nodes 
are not al­lowed to access the data that was checked-out by the mobile node. When the node reconnects 
it updates the remaining database copies with the new state of the data. These two modes provide strong 
consistency (one copy-serializability). A third method, relaxed check-out mode, relaxes the previ­ous 
one by allowing connected nodes to browse the data that was checked-out by the mobile node. This ensures 
a lower consistency level as long as nodes can browse old data. As a practical scenario, one could imagine 
that during an usual activity period, nomadic users access portions of data in relaxed check-out mode. 
When all of nodes reconnect to an enterprise network, the administrator of the database claims to himself 
the data access starting a basic sign-o. mode, so that he or she is allowed to execute data man­agement 
activities, as for example, users inclusion and data schemata alteration. Therefore, replication control 
protocol replacement would be an important requirement for such a system. We treat in this paper the 
dynamic replacement, or up­date, of replication control protocols, so that such an adap­tive scenario 
could be implemented. We consider that a pro­tocol replacement can be requested by any node of the sys­tem, 
and these requests can occur concurrently with trans­action executions. In this paper, while the term 
protocol denotes distributed replication control algorithms, the term meta protocol has been adopted 
to denote protocols that maintain the consistency of the replication control protocols despite both concurrent 
replacement requests and transac­tion executions. In order to implement such an adaptive replicated system, 
all nodes have to agree both on when a protocol replacement can occur, and on which new protocol has 
to be attached to the nodes when a replacement occurs. In order to achieve such agreements, the meta 
protocol proposed in this pa­per is based on Consensus [10]. More precisely, the meta protocol uses any 
protocol that solves the Uniform Consen­sus problem. The Uniform Consensus problem is de.ned in terms 
of safety and liveness properties [5]. A consensus protocol allows nodes of a distributed system to agree 
on some value that is related to values proposed by the nodes, abstracting failures and asynchrony of 
the distributed sys­tem. Consensus protocols have been used to solve a set of agreement problems, as 
atomic broadcast [18] and dis­tributed non-blocking atomic commitment [16]. This paper shows how consensus 
can be used in dynamic replacement of replication control protocols. The rest of the paper is structured 
as follows. Section 2 presents de.nitions and models of mobile databases, con­currency and replication 
control, transactions, reliable mul­ticast and consensus. Section 3 presents three safety proper­ties 
of the meta protocol. Section 4 details the meta protocol and section 5 discusses some related work. 
Section 6 brie.y describes ongoing and future work regarding the meta pro­tocol implementation, and section 
7 concludes the paper.  2. MODELS AND DEFINITIONS 2.1 Transactions, Databases and Failures We consider 
that the system is composed of nodes that may replicate objects (or data items). A node, noted as Ni, 
can disconnect from a network and possibly access lo­cal data during disconnection. Objects are accessed 
by read and write operations executed on behalf of a transaction, noted as T (or Ti to avoid ambiguity), 
following the exe­cution model presented in [3]. A transaction terminates by being either committed or 
aborted. Two transactions are concurrent if one of them begun its execution before the termination (by 
commit or abort) of the other. Two opera­tions con.ict if they belong to di.erent transactions, access 
the same object and one of them is a write operation. Two concurrent transactions are said to be con.icting 
if both ac­cess some object (or some copy of an object in a replicated system) with con.icting operations. 
A transaction is active if it started its execution but did not yet terminate. During a disconnection 
period of a node, data accesses are performed on local copies, and no synchronization be­tween nodes 
is possible. After reconnection a node can re-synchronize the state of local copies with respect to other 
nodes copies. Disconnections and re-connections are planned by the user or due to a failure. Objects 
residing in a node are accessed through a Database Management System (DBMS). We assume that nodes only 
fail by prematurely stopping their execution (crash failure model) [18]. A node (or pro­cess) is said 
correct if it never crashes. We use node instead of process for the sake of notation simplicity. We also 
assume that a majority of nodes of the system are cor­rect (this assumption will allow the underlying 
consensus primitive to be non-blocking in spite of failures).  2.2 Concurrency and Replication Control 
Protocols Data access isolation is guaranteed by concurrency control protocols. These protocols handle 
operations that access shared data (writes and reads) so that execution histories respect the required 
isolation level, and therefore, ensure some data consistency criterion. The literature presents se­veral 
concurrency control protocols, some of them for strong consistency levels (as two-phase locking [3]) 
and other for more relaxed consistency. In the latter case, the protocols are designed to avoid deadlocks 
(e.g. [15]) and to minimize data access latency in mobile systems (e.g. [19], [25] and [11]). The choice 
of the algorithm is strongly related to the integrity constraints of application s data. The coherency 
of object copies is ensured by replication control protocols. These protocols aim to make an execu­tion 
composed by operations that access replicated data, appear as an execution on a non replicated system. 
Tradi­tional replication control protocols use to synchronize data accesses during transaction executions 
(e. g. [8]). How­ever, in mobile settings transactions cannot be synchronized when a node is disconnected 
from the network. Therefore, di.erent protocols that allow local execution of data accesses and further 
dissemination of the updates after reconnections have been proposed (e.g. [15], [19] and [11]). These 
two syn­chronization methods are de.ned in [15] as eager and lazy replication, respectively. Concurrency 
and replication control protocols normally cooperate in order to achieve the desired isolation and co­herency 
levels (e.g., one-copy serializability). For the sake of notation simplicity, we will refer to these 
protocols simply as replication control protocols, or just protocols , in the rest of the paper. We consider 
that any transaction operation submitted to a DBMS is handled .rst by a replication control protocol. 
The replication control protocol will then be allowed to schedule transaction executions as well as disseminate 
transaction up­dates according to its concurrency and replication control policies. This protocol is 
also responsible for the distributed atomic commit of transactions.  2.3 Distributed Transaction Execution 
An application at node Ni can possibly connect to a local DBMS and execute local reads and writes while 
it is isolated from a network or from some other node of the distributed system. When Ni reconnects to 
a network it has to syn­chronize its database with respect to the database state of other nodes. Therefore, 
we consider that a transaction on a replicated environment passes by two distinct and sequential execution 
phases: Local phase. Access operations are executed on the local DBMS. Most replication control protocols 
allow only read operations, but there are other protocols that also allow data modi.cations. In mobile 
database applications, frequently, transaction commit is con­strained to local accesses and so they are 
instead exe­cuted in the local phase (lazy replication). The local phase of a transaction is initiated 
by the .rst operation submitted to the DBMS.  Global phase. The goal of this execution phase is twofold: 
(i) to disseminate the e.ects of writes on local data to remote copies and/or from remote copies to the 
local ones, and (ii) to perform an atomic distributed commit in order to provide a transactional semantics 
of data accesses (eager replication). So, a node can possibly participate in the global phase of a remotely 
initiated transaction in order to update local and re­mote copies of objects and to execute a distributed 
atomic commit to terminate the remote transaction.  The number of nodes involved in the global phase 
may vary from one DBMS server up to all nodes of the dis­tributed system. The former is normally the 
case of com­mon client-server applications, while the latter corresponds to fully replicated databases. 
Our meta protocol assumes that all database objects are fully replicated. We consider that the global 
phase can occur progressively, so that all nodes that replicate an object modi.ed by Ni eventually get 
updated with Ni s modi.cations. Therefore, we de.ne here a global phase termination event that repre­sents 
the dissemination of writes followed by the distributed atomic commit of a transaction at all nodes. 
This execu­tion model is not completely general as is does not include synchronization that could occur 
during earlier accesses to distributed data by a transaction, what happens for exam­ple in writes on 
a ROWA (Read-One Write-All) or quorum basis. In most cases, however, one could postpone writes to the 
global phase, after all reads are executed on local data. Moreover, synchronization at the transaction 
termination phase is particularly interesting for mobile databases, where nodes are frequently isolated 
from communication networks. In some mobile applications, the set of transactions executed in a mobile 
node while it is disconnected, can in fact be perceived by other nodes as only one transaction execution 
whose global phase happens when the node reconnects to the system. This abstract global phase termination 
event allows the decoupling of the actual implementation of replication con­trol protocols from the meta 
protocol we will propose in section 4. This is important as there are numerous proto­cols that could 
be handled by the meta protocol. We will discuss in section 4.2 how replication control protocols could 
launch such an event. 2.4 Underlying Services The meta protocol de.ned in section 4 relies on two dis­tributed 
services, namely, Uniform Reliable Multicast and Uniform Consensus. 2.4.1 Uniform Reliable Multicast 
A service that provides an Uniform Reliable Broadcast is de.ned by two primitives [18]: R-Broadcast(m) 
and R­deliver(m). The semantics of these primitives is de.ned by the properties that follow: Validity 
: If a correct node N broadcasts a message m, then it eventually delivers m. Uniform Integrity : For 
any message m, every node R­delivers m at most once, and only if m was previously reliably broadcast. 
(There is no message duplication nor spurious messages). Uniform Agreement : If a node R-delivers m, 
then all correct nodes eventually R-deliver m. (Either a mes­sage is not delivered to any node, or it 
is delivered to all correct nodes.) 2.4.2 Uniform Consensus In the Consensus problem each node proposes 
a value and all correct nodes have to decide on some value v that is re­lated to the set of proposed 
values [10]. Formally, the Uni­form Consensus problem is de.ned in terms of two primi­tives: Propose(v) 
and Decide(v '), where v and v . are, re­spectively, the value proposed by some node and the agreed decided 
value. The semantics of Propose and Decide is de.ned by the following properties: Uniform Validity : 
If a node decides v, then v was pro­posed by some node. Uniform Integrity : A node decides at most once. 
(This property states that from the point of view of each node, there is a single decision.) Termination 
: All correct nodes eventually decide. (At least all correct node decide.) Uniform Agreement : No two 
nodes (correct or not) de­cide di.erently. (This property gives a global meaning to the consensus.) 
  3. PROPERTIES FOR THE META PROTO-COL In this section we present properties that our meta pro­tocol 
has to enforce. In [29] is stated that during its execu­tion, a replicated system can pass through three 
sequential execution phases: protocol attachment, protocol execution and protocol detachment. The .rst 
phase consists of recon­.guration steps that are performed by the meta protocol to install a replication 
control protocol in all nodes of the distributed system. The second phase corresponds to the application 
execution on top of an installed replication con­trol protocol, during which accesses to replicated objects 
are synchronized according to the rules determined by the repli­cation control. The third phase consists 
of the steps that are performed by the meta protocol to remove a previously installed replication control 
protocol from all nodes of the distributed system. Once a replication control protocol is .rst attached, 
a subsequent attachment of a new protocol is only allowed after the previous protocol is detached. Replication 
control protocol replacement is constrained by the execution state of transactions. A new protocol cannot 
be negligently attached to a node while transactions are ac­tive and under control of another protocol. 
If we consider a distributed execution in which several replication proto­cols are attached to nodes 
and run, we need to understand when these protocols can be attached, run and detached. In order to clarify 
this dynamic replacement, we present three safety properties that relate replication control proto­cols 
with transaction executions: Object copy access consistency. At any time in sys­tem s execution, any 
copy of an object is accessed by a transaction under control of only one replication con­trol protocol. 
In other words, each node with an object copy executes only one protocol at a given time. Transaction 
control consistency. The execution of a committed transaction, including the local and the global phases, 
is controlled by the same replication control protocol, attached to all nodes that replicate objects 
accessed by the transaction. When a transac­tion execution satis.es this property, we say that the transaction 
is protocol consistent. Object access consistency. Consider any two concurrent and con.icting transactions 
T1 and T2 that are proto­col consistent and that are committed, and let O be the set of objects on which 
T1 and T2 execute con­.icting operations. During T1 and T2 executions (i.e. operations of the local phase 
plus the operations of the global phase), both are subject to the same replication control protocol. 
In other words, all nodes that hold copies of the objects in O have attached to themselves the same replication 
control protocol during the exe­cution of T1 and T2. The .rst property ensures that no two replication 
con­trol protocols can mediate the execution of a transaction accessing an object copy during application 
execution. The treatment of transaction operations at some node is done deterministically by exactly 
one protocol. This property is important in the sense that it avoids the attachment and execution of 
a protocol in a node, without the detachment of the previous one. In a practical implementation, for 
ex­ample using a dynamic weaving mechanism o.ered by as­pect oriented frameworks [2] (section 6) in which 
protocols are implemented as advices intercepting the execution of the system, no two advices responding 
to distinct protocols should be deployed. Figure 1(a) illustrates this reasoning by showing three nodes 
replicating some object and that changed replication control from protocol 1 to protocol 2 . Node N1 
appears as it had installed simultaneously the two protocols, creating a protocol con.ict situation and 
thus violating the object copy access consistency property. The second property ensures that a transaction 
execution that is started under some replication control protocol is con­strained exclusively by that 
protocol until it is completely executed and committed. In order to sketch the e.ects of this property, 
Figure 1(b) illustrates a violation scenario. It depicts a transaction execution in which the local phase 
is executed under some (replication control) protocol 1 . The global phase is also initiated under the 
same replication con­trol protocol, but it terminates in node N3 under control of protocol 2 . Supposing 
that protocol 1 and 2 di.er in the isolation level they implement, it is clear that the overall execution 
of the transaction could not be consistent by none of the isolation levels. This cannot happen to a protocol 
consistent transaction. Figure 1: (a) Violation of the object copy access con­sistency property, and 
(b) violation of the transaction control consistency property. The third property extends the transaction 
control prop­erty to concurrent and con.icting transactions. Figure 2 illustrates two execution scenarios 
that exemplify the im­portance of this property. It shows two transactions, T1 that reads and writes 
into replicated objects x and y, and T2 that writes into y. All operations of T1 are controlled at nodes 
N1, N2 and N3 by protocol 1 , thus ensuring that the transaction is protocol consistent. Moreover, all 
opera­tions of transaction T2 are controlled by a protocol 2 , also ensuring transaction control consistency 
with respect to T2. That scenario could clearly lead to data integrity problems when for example the 
concurrency is controlled by distinct protocols, say using an optimistic approach for T2, and a pes­simistic 
one for T1. When updates of T2 reach node N1 they can be considered correct by a certi.cation phase, 
as the op­timistic protocol does not care about locks hold on behalf of T1, an then they are committed 
into the local DBMS. On the other hand, the updates of T1 will also ignore the certi.ca­tion of T2, and 
proceed with T1 s execution that overwrites the copy of y at all nodes. Such a phenomenon is avoided 
if object access consistency is implemented by the system and this because both transactions would be 
submitted to the same replication control protocol. We remark that if both transactions did not con.ict, 
they could be executed under di.erent replication control protocols. For example, if T1 and T2 were both 
read-only transactions, they could be executed no matter what protocol was controlling each of them. 
This is due to the fact that in this case, their ex­ecutions are naturally isolated one from the other 
and so they are ino.ensive to data consistency and coherency. In the framework presented by Yang and 
Li [29], protocols  Figure 2: Object access consistency violation scenario due both to a con.ict of 
transactions T1 and T2 on the access of objects x and y, and to a di.erent repli­cation control protocol 
for T1 and T2. are attached to objects, and not to nodes, as we propose in our work. The fact that transactions 
that access di.erent sets of objects could be executed under distinct replication control, shows that 
Yang and Li s approach could be more interesting. Attaching protocols to nodes (instead of ob­jects) 
could hidden some .exibility and concurrency gains when two protocols are allowed to coexist in a node, 
each responding to some disjoint collection of objects. However, from a practical point-of-view this 
leads to some problems. In such a scheme, a protocol consistent transaction would have to pre-declare 
the set of objects it intended to access so that the system could associate the same protocol to all 
accessed objects. This would constraint the execution of transactions that are dynamically de.ned by 
the user. Al­ternatively, the system could change the protocols attached to the objects as the transaction 
executes, what certainly would restrict the throughput of the transactional system. We note that Yang 
and Li s framework was designed for groupware applications that do not use to access shared ob­jects 
by the means of transactions (instead each operation is treated as an atomic execution unit). So, the 
attachment of protocols to objects does not present the above mentioned drawbacks in such systems.  
4. META PROTOCOL DEFINITION In order to reach a system wide agreement on when a protocol update can occur, 
and also with respect to which protocol should be attached to a node, protocol update and transaction 
initiation requests are proposed as values to con­sensus executions. Protocol update requests are only 
exe­cuted after consensus decisions that express a global knowl­edge about the request, i.e., after a 
consensus decision in which the decided value includes some update request. We note however that the 
e.ective transaction submission to the DBMS is not constrained by the execution of a consen­sus, instead, 
transactions can execute their local and global phase concurrently with the consensus protocol. This 
is im­portant since the global phase of transactions usually include costly communication steps (for 
example, three phase com­mit [3], consensus-based non blocking atomic commit [16], and atomic multicast 
[22, 13]), as it is also the case of con­sensus protocols. In the proposed meta protocol, consensus executions 
are sequential. Moreover, as in other consensus applications (e. g. the atomic broadcast protocol in 
[18, 17]), each consen­sus execution is numbered with a k integer. This number is incremented at each 
new consensus decision. Thus, the meta protocol ensures that the k-th consensus decision al­ways immediately 
follows a decision numbered with (k - 1) at any node. Protocol updates and transactions requests can 
be submit­ted concurrently in any node. Both event types can be asso­ciated to an integer number kV . 
The subscript V .{U, T }indicates that the number is associated, respectively, either to a protocol update 
U or to a transaction T . This number corresponds to the number of the next consensus execution that 
will be launched at a node. The underlaying idea is to identify each request with the consensus execution 
that will propose the request. If that number is not relevant to the meta protocol, it will be replaced 
by the . symbol. We note that as long as di.erent nodes can concurrently propose distinct updates or 
transactions for the same k-th consensus execution, we must remark two situations: (i) a request with 
number kV can be decided in an execution k' = kV and also, (ii) two di.erent requests can have the same 
number kV . The protocol uses consensus executions to de.ne an agreed order on transaction terminations 
and protocol updates. This order allows to de.ne the same update and transac­tion sequence in the execution. 
The syntax of the protocol presentation follows the notation adopted in [17]1 . With re­spect to mobility 
of nodes, we consider that all non faulty nodes (at least the correct nodes) are connected to a net­work 
and allowed to communicate among themselves when a transaction is initiated and during its global phase. 
The same assumption is done also when a dynamic replacement takes place. (Section 4.2 discusses these 
constraints). We discuss here how the protocol, depicted in Figure 3, treats relevant events. Transaction 
initiation or update requests (lines 7-8 and 11). In either case a corresponding <kV ,V > tuple is reliably 
broadcast to the nodes, where kV corresponds to the number of the next consensus execution at the node 
that has initiated the request for a protocol update (U) or transaction initiation (T ). The protocol 
charges the initiating node with the job of assigning the number to the request, and this, before the 
broadcast. This ensures that the request will have the same global number assigned to it. If the request 
corresponds to a transaction initiation, the operation on behalf of it is .rst submitted to the meta 
pro­tocol and then to the local DBMS. Further operations are directly submitted to the DBMS. When the 
transaction ter­minates, we assume that an event is generated by the DBMS. This event is handled by the 
meta protocol as de.ned by the transaction termination event. This behavior allows some concurrency between 
the transaction and meta protocol ex­ecutions. Only the .rst operation and the termination of a transaction 
are synchronized with the meta protocol. We note however that the .rst operation waits only for the ex­ecution 
of a reliable broadcast. When a protocol update is requested, the request is only treated after both 
the delivery of the request to the nodes and after a consensus decision that included that request as 
a decided value. Message delivery (lines 12-13). When a <kV ,V > tuple 1The system handles events that 
are triggered in a mutually exclusive way by executing the corresponding code de.ned by the upon event 
( Event | parameters) do clause. is delivered to a node it is stored into a set of delivered messages, 
namely the delivered set, if it was not decided by consensus. This avoids a request to be proposed twice. 
Consensus launch (lines 14-15). When the delivered set becomes not empty and if there is no consensus 
under exe­cution, a new consensus execution is launched. This consen­sus execution is numbered with k 
and proposes all requests stored into the delivered set. Consensus decision (lines 16-29). When a consensus 
deci­sion is reached in a node, the decided value, V Set, is stored into a decided set. This set possibly 
contains transaction initiation and/or protocol update requests. A total order on the requests could 
be taken by simply executing them according to some deterministic order, as it is done by the total order 
(or atomic) broadcast de.ned in [18, 17]. How­ever, this could led to a non consistent behavior with 
respect to protocol updates. We try to explain this by assuming two non empty sets, Act and Dec, the 
former set repre­senting all active transactions in the system, and the latter one including the transactions 
and/or protocol updates de­cided by some consensus execution. The content of these sets de.ne one of 
the following situations: (i) Act . Dec, (ii) Act . Dec and (iii) Act n Dec = Ø. According to (i), the 
decided set includes all active transactions, and so, we could synchronize protocol updates and transaction 
execu­tions by using some deterministic order for postponing up­dates until the active transactions terminate, 
or reversely, by aborting active transactions and promptly executing the updates. Notwithstanding, situations 
(ii) and (iii) do not allow to safely decide neither on the faith of active transac­tions nor to postpone 
protocol updates as long as some of these transactions are unknown at the decision time. Such situations 
occur when active transactions are on their local phase and until some nodes do not become aware of their 
request. Additionally, any synchronization of the the execution of transactions and protocol updates 
should be performed only after the concerned requests appear in a consensus decision, that is, into V 
Set. This ensures that all nodes agree on the synchronizations decisions. Thus, a node cannot decide 
on the faith of a transaction T until a local consensus execution returns a <kT ,T > tuple into V Set. 
Accordingly, after a consensus execution a next step veri­.es if there is a protocol update request to 
be treated into the decided set. If there is no update request, all transactions in the decided set are 
marked to be committed. Otherwise, the protocol behaves as follows. In order to safely take into account 
possibly unknown ac­tive transactions the meta protocol could consider that when a k ' -th consensus 
decision is taken, these transactions where initiated with kT number such that kT = k ' . This is because 
nodes that start transactions with kT >k ' have necessar­ily decided the k ' -th consensus, and the protocol 
updates of the k ' consensus decisions could not have interfered with those transactions. Moreover, any 
active transaction T that is unknown at the k ' -th decision time (kT = k ' ) will be able only to appear 
in a decision k '' such that k '' >k ' . In such a k '' -th execution then we have kT <k '' . Therefore, 
in order to keep the protocol update safe, every time a V Set of a k ' -th decision includes a transaction 
T with kT <k ' , T is marked to be aborted. This approach gives higher priority to protocol updates with 
detriment to some unknown ac­tive transactions, but also avoids the starvation of update requests. After 
the transactions are marked to be aborted or com­mitted, the meta protocol veri.es if all transactions 
that were marked to be committed were e.ectively committed by the DBMS. If this condition holds, this 
means that the protocol updates can be executed. This is also done ev­ery time a transaction is committed 
by the DBMS. In both cases, the executed updates are excluded from the decided set also to avoid their 
re-execution. Transaction termination (lines 30-39). We assume that, after the global phase, the transactions 
always are intended to be committed. So, when a transaction is terminated the system veri.es if it was 
already included in a consensus de­cision, and subsequently either marked to be committed or to be aborted. 
When this occurs, the meta protocol just executes the corresponding transaction termination. 4.1 Discussion 
on the Meta Protocol Correct­ness Based on the code outlined in Figure 3, we informally dis­cuss here 
the protocol safety in relation to the three proper­ties de.ned in section 3. We assume that initially 
the same replication control protocol is installed at all nodes and no transaction has been started so 
far. Object copy access consistency. This property obligates a node to have attached to it only one protocol 
at a given time. We consider that protocol updates abstract two basic operations: the detachment of an 
installed protocol and a subsequent attachment of the requested new protocol. By executing these two 
steps sequentially and in a mutually exclusive way (as de.ned in lines 25 or 34), the meta protocol ensures 
this property. Transaction control consistency. This property ensures that each committed transaction 
is entirely run (local and global phases) under the control of exactly one replication control protocol. 
In order to show that the protocol of Fig­ure 3 respects this behavior in spite of concurrent protocol 
update requests, we consider the following scenario. Sup­pose that a transaction T is submitted (transaction 
initi­ation event) by an user and that meanwhile an update U is also requested (protocol updated event). 
Lets also sup­pose that U is executed (line 25) and only then T is globally terminated and committed 
(line 31). We argue by contra­diction that such a scenario cannot occur in any node of the system. We 
consider .rst the execution at some node, say Ni. If U has been executed (line 25 or 34) then it was 
be­fore decided (line 16) by consensus and T , that we suppose was committed, has also been decided. 
This is because the transaction is only e.ectively committed (line 31) if it be­longs to the commit set 
(line 30), and this can only happen if its request is decided (lines, 16, 18-21 or 22-23). So, we can 
have either T . commit (was marked to be committed, by line 21 or 23) or T ./commit (it was e.ec­tively 
been committed, by line 31). In the .rst case, line 24 or line 33 precludes any update and so, U could 
not have been executed: a contradiction with our supposition. In the second case, the update should have 
been executed after T ' s upon event ( Init ) do // tuples that were R-delivered 1 set of <kV , V > 
delivered .Ø; // tuples that were decided by consensus 2 set of <kV , V > decided .Ø; // id s of transactions 
marked to be committed 3 set of T commit .Ø; // id s of transactions marked to be aborted 4 set of T 
abort .Ø; // .ag to avoid concurrent consensus executions 5 bool wait . false; // number of the consensus 
execution 6 integer k . 1; upon event ( Transaction initiation | T, op ) do 7 kT . k; 8 R-Broadcast(<kT 
,T >); 9 Submit the transaction operation to the DBMS; upon event ( Transaction operation | T, op ) do 
10 Submit the transaction operation to the DBMS; upon event ( Protocol update | U ) do 11 R-Broadcast(< 
.,U >); upon event ( R-Deliver | <kv,V > ) do 12 if <kv,V >/. decided then 13 delivered .<kv,V >; upon 
event delivered = Ø. wait = false 14 wait . true; 15 Propose(k, delivered); upon event ( Decide | k ' 
, V Set ) do 16 decided . decided . V Set; 17 delivered . delivered - V Set; 18 if . < .,U >. decided 
do 19 for all T | <kT ,T >. decided do 20 if kT <k ' then abort . abort . T ; 21 else commit . commit 
. T ; 22 else for all T | <kT ,T >. decided do 23 commit . commit . T ; 24 if commit = Ø then 25 Execute 
sequentially in some deterministic order all U| < .,U >. decided; 26 for all < .,U >. decided do 27 decided 
. decided- < .,U > 28 k . k + 1; 29 wait . false; upon event ( T is globally terminated . (T . commit 
. T . abort) ) do 30 if T . commit then 31 Submit Commit T to the DBMS; 32 commit . commit - T ; 33 if 
commit = Ø then 34 Execute sequentially in some deterministic order all U| < .,U >. decided; 35 for all 
< .,U >. decided do 36 decided . decided- < .,U > 37 else 38 Submit Abort T to the DBMS; 39 abort . abort 
- T ; Figure 3: Speci.cation of the meta protocol for node Ni. commit, as events are treated in a mutually 
exclusive way. This is also a contradiction to our scenario. The Validity and Uniform Agreement properties 
of reliable broadcast ensure that all correct nodes deliver T ' s initiation request (lines 12-13), as 
it was done for Ni. With this, and based on failures hypothesis from section 2.1, the request for T (<kT 
,T > tuple) will be eventually proposed and decided by consensus. By Termination and Uniform Agreement 
of consensus, and by induction on the set of delivered requests and consensus launches, one can show 
that the discussion above for node Ni also holds for other correct nodes. Object access consistency. 
Consider two con.icting transactions, say T1 and T2, that are executed concurrently. By this assumption, 
both T1 and T2 access some object copy, say at node N. Lets also consider that T1 executes under some 
replication control protocol, say protocol P1. Now we have to consider two other possible scenarios: 
(i) T2 exe­cutes under the same protocol P1, or (ii) T2 executes under another replication control protocol, 
say protocol P2. In case (i), by the transaction control consistency property ensured by the meta protocol, 
both transactions terminate under the same protocol P1, thus, respecting object access consistency. In 
case (ii), as the transactions are concurrent, there was either a replication control protocol replacement 
at node N either before T1 terminates (P1 was replaced by P2), or be­fore T2 terminates (P2 was replaced 
by P1). Also here, as the meta protocol ensures transaction control consistency, these replacements could 
not have occurred, a contradiction to the second scenario. Accordingly, the meta protocol re­spects object 
access consistency. Liveness properties, related for example with the termi­nation of transactions, could 
be demonstrated based on live­ness properties of the underlaying services, as de.ned in sec­tions 2.4.1 
and 2.4.2. It could for example be proved that a transaction eventually terminates either in the commit 
or in the abort set, so that in will not be blocked by the meta protocol when it comes to handling the 
termination event. We could also prove that the meta protocol does not de­cide di.erently on the faith 
of a transaction. This is done on the basis of the transaction initiation request number kV that is the 
same system wide, and due both to the Validity and Uniform Agreement properties of reliable broadcast, 
and also to the Termination and Uniform Agreement of consen­sus. However, this paper only focus in the 
discussion about the properties de.ned in section 3  4.2 Transaction Initiation and Global Phase Termination 
Events We assumed that when the meta protocol treats the trans­action initiation requests and the global 
phase termination events, all non faulty nodes are able to communicate among themselves. For nodes that 
want to disconnect in a planned manner, an initiation request could be issued on behalf of all transactions 
that will execute their local phases while they are disconnected, and this by the means of a pseudo trans­action 
. In the same way, a global phase would be executed when the nodes reconnect. All updates of committed 
trans­action executed during disconnection would be represented by that pseudo transaction global termination 
phase. We note that these pseudo transactions would only be prone to aborts if an protocol update was 
requested and treated. The global phase termination event determines that a transaction was globally 
terminated at the nodes that took part in its execution. This event has to be launched by the replication 
protocol that is controlling the transaction execution, and the launch process depends on the imple­mentation 
of the replication protocols. As examples, we consider here three implementation solutions, each based 
on a distinct termination scheme: distributed atomic commit, group communication, and reconnection of 
mobile nodes. Informally, a distributed atomic commitment [3] ensures that either all correct nodes that 
participated in the execu­tion of the transaction commit its execution, or all of them will abort it. 
A protocol that implements a distributed com­mit involves all non faulty nodes, and should eventually 
ter­minate its execution with a common decision. A protocol based on consensus could also be used to 
reach such a deci­sion [16]. In this case, the protocol launches the termination event just after the 
termination of the distributed atomic commitment, and then e.ectively commits (or aborts) the transaction. 
When group communication primitives are used (e.g. [22] and [13]), the termination event is simply obtained 
by the delivery of a .nal message of the replication control protocol to all correct nodes. Depending 
on the delivery properties (reliability and/or order), this message can determine the global phase termination 
of the transaction. Protocols use to commit (or abort) the transaction after the delivery of that message. 
Just before terminating the transaction, they can also launch the event so that the meta protocol can 
handle it. When we deal with reconnection of mobile nodes, as it is the case of replication control protocols 
presented in [19], the termination event corresponds to the end of the synchro­nization that occurs during 
reconnection. This synchroniza­tion usually involves the exchange of updates issued at the mobile node, 
say node N, or at the node to which the mo­bile node reconnects. If the database is fully replicated, 
this synchronization can occur progressively between the nodes that become connected to N. For any node 
that perceives N reconnection, the global phase terminates after the syn­chronization with N. After this 
synchronization, and before the actual commit (or abort) of the updates, the global ter­mination event 
can be launched and treated by the meta protocol.  5. RELATED WORK The literature brings some important 
research work on dynamic protocol update, notably [28, 24, 6]. These pa­pers refer to the dynamic replacement 
of modules in general communication protocol stacks. In [28], the authors formal­ize in great detail 
weak and strong properties that dynamic protocol update (or DPU for short) has to preserve. It also sketches 
a DPU protocol based on totally ordered broadcast, which preserves the order of the messages sent by 
adaptive protocol stacks (by respecting strong DPU properties) , as well as a lazy algorithm that may 
not preserve delivery order (that respects weak DPU properties). In [24] are presented structural and 
algorithmic solutions for DPU. The structural solutions are based on replacement modules that connect 
distinct modules in a protocol stack and are responsible for the replacement of old modules by new ones. 
In the algo­rithmic aspect, it is shown how atomic broadcasts protocols can be dynamically updated by 
the means of an algorithm that, itself, uses atomic broadcasts in order to preserve DPU properties. Chen 
et al. [6] propose an adaptive architecture in which adaptive components (AC) are composed by inter­nal 
adaptive aware algorithm modules (AAMs). They also delineate how two particular total ordering protocols 
can be dynamically exchanged with the proposed adaptation pro­cess. As they were designed for general 
protocol stacks, all these previously mentioned proposals present a fundamental dis­tinction from the 
protocol presented in this paper. They rely on strong synchronization on the execution of the up­date 
mechanisms and the protocols that are updated, aiming at achieving no interference from the updates on 
the proto­col executions. They de.ne synchronization barriers [6], or assume several steps of totally 
ordered broadcasts [28, 24], so that the system could be able to detect quiescent states (in terms of 
messages sent and not yet received) before an update occurs. Accordingly, they succeed to have updates 
that are isolated from the protocol stacks execution, so that, the protocols that are updated are not 
a.ected by the update process during their execution. In contrast, as we assume a transaction based distributed 
system, we intended to reduce the synchronization costs, at the price of allowing transaction aborts. 
In [28], for ex­ample, three atomic broadcasts are sequentially executed in order to update a distributed 
protocol, respecting strong properties. The atomic broadcast protocol update designed in [24] also requires 
two additional atomic broadcast execu­tions. This meta protocol executes one reliable broadcast followed 
by a consensus execution for each transaction ini­tiation or protocol update request. We note, however, 
that in high transaction throughput situations the meta proto­col could batch a large number of such 
requests, that are proposed and possibly decided in a smaller number of con­sensus executions. Moreover, 
each transaction execution is allowed to start concurrently with consensus. The concur­rence of the global 
phase of transactions with consensus also contributes to minimize the in.uence of the communication steps 
involved. In what concerns transaction aborts, we note that this only happens if there are replication 
control up­date requests, not a frequent event in practical applications of database systems. Adaptivity 
support to replicated systems is also imple­mented by the Ensemble group communication system [26]. Ensemble 
implements ordered and reliable multicasts with virtual synchrony guarantees, and also o.ers the ability 
to dynamically change its protocol stack due to application re­quirements modi.cations. The Ensemble 
system is a power­ful tool that could be used as the building blocks we need in our meta protocol. Consensus 
can be trivially implemented by a reliable totally ordered multicast, and virtual synchrony [4] would 
ensure the multicast properties we need. The meta protocol presented in [12] also implements prop­erties 
that are similar to the ones presented in this paper, for transactional replicated databases. However 
it uses a costly synchronization based on atomic broadcast, every time a transaction is initiated and 
when a protocol update is re­quested. The protocol proposed in this paper requires a re­liable multicast 
and a consensus execution per transaction, and it possibly aborts transactions when concurrent proto­col 
updates are requested. However, as protocol updates are not frequent events in a replicated system, we 
believe that the cost of aborts will be less prejudicial than frequent atomic broadcasts. Moreover, consensus 
cost can be attenu­ated when a batch of transactions is treated in one consensus execution. Yang and 
Li [29] propose a meta protocol that allows to change concurrency control in collaborative applications, 
but that is not well suited to transactional systems. Also, they work relies on a central server that 
coordinates pro­tocol replacement, while we assume a symmetrical protocol based on reliable broadcast 
and consensus, and so, without a single point of failure. The protocols presented in [9, 1] provide a 
replicated sys­tem with the ability to dynamically change the transaction isolation level, from a range 
between snapshot isolation and serializability. The snapshot isolation level itself is de.ned after the 
 outdatedness from the snapshot, i. e. whether the snapshot can be taken on the latest data versions 
on the replicated system, or on some older version of the data available at some node. The problem is 
accordingly gener­alized by the General Snapshot Isolation (GSI) [9]. These protocols show how a system 
could dynamically adapt the isolation level between the di.erent forms of GSI and serial­izability. In 
our work we intended to separate at the largest extent protocol replacements concerns from the actual 
repli­cation control algorithm, and so, allow some isolation of re­placement procedures from the replicated 
system execution. This agrees with the common issue of separating adaptivity components from protocols 
by making the former dependent only on a minimal set of protocol interfaces [28, 24, 6].  6. ONGOING 
WORK The proposed meta protocol is being implemented, as part of an ongoing research on adaptive middleware 
for repli­cated databases. The meta protocol and the replicated ap­plications interact with building 
blocks for group communi­cation, database access and aspect oriented programming. The group communication 
system o.ers atomic multicast and state transfer services, as well as a virtually synchronous execution 
environment. These functionalities are used by the meta protocol and can also be used by the replication 
control protocols. State transfer is particularly useful to the synchronization of database states on 
mobile node recon­nections. The JGroups toolkit [23] has been used for that purpose. The database management 
system provides the system with a transactional environment. We are using the MySQL DBMS. An aspect oriented 
framework plays a central role in our architecture. Aspect orientation [20] has been proposed as a solution 
for the treatment of non functional and transver­sal issues in adaptable middleware [14]. Aspect oriented 
software enhances the modularity by separating orthogonal concerns in well de.ned constructions called 
aspects. As­pects can crosscut the static structure of software, adding for example a new method to a 
class, as well as the dynamic structure, for example by modifying the execution .ow of a program. The 
points of interest in the execution of some program (also called join points) are de.ned by declaring 
pointcuts. To the pointcuts are associated pieces of code called advices that can add new behavior to 
a program. Syn­tactically, aspects allow the de.nition of pointcuts and ad­vices. According to the aspect 
oriented language or frame­work used, aspects can be weaved into the program code, either before the 
program starts or at run-time (dynamic weaving). We have adopted, in the present implementation, the 
As­pectWerkz framework [2]. AspectWerkz o.ers two impor­tant features: a dynamic weaver and a way to 
transform plain Java classes into aspects through a XML de.nition .le. The .rst feature has a particular 
interest because it allows attaching the aspects code to some pre-programmed Java bytecode during the 
execution of the program. The sec­ond feature o.ers a way to decouple the de.nition of point­cuts (XML) 
from the actual implementation of aspects (Java classes). This brings .exibility to the de.nition of 
pointcuts and to the reuse of classes as aspects. In our work, we consider that replication control proto­cols 
are concerns that should be separated from application programming, thus enforcing modularity and adaptability 
of the software development process. Also, aspects are used to accommodate meta protocol functionalities. 
The aspect oriented framework enables the association of the meta pro­tocol to the application and to 
the replication control algo­rithms. With respect to the application, we intercept trans­action operations 
as they are submitted to a DBMS. In prac­tice, these join points correspond to popular mechanisms for 
DBMS connection initialization, data access, and connec­tion interruption, like the methods o.ered by 
well known database programming interfaces (e.g. Java Database Con­nectivity API). The treatment of replication 
control protocol events, as the start of a transaction and its global termina­tion, can be declared in 
the scope of pointcuts that identify some application and replication control join points. With the aspect 
oriented framework, we are able to decouple ap­plication, replication control and meta protocol code. 
 7. CONCLUDING REMARKS This paper presented a meta protocol for the dynamic up­date of replication control 
protocols in replicated databases. It allows adaptive scenarios in which consistency and co­herency requirements 
can be changed according to applica­tions needs. Not much work on replication control adap­tivity has 
been found in the literature, and we showed how basic services for distributed systems, as reliable multicast 
and consensus can help to obtain this kind of functionality. We also claimed that such a meta protocol 
could be inte­grated into commercial database programming interfaces by the means of aspect orientation, 
and thus, a prototype of this meta protocol is currently being implemented. We believe that it is important, 
as a future work, to in­vestigate deeper the relations between the consensus and the protocol update 
problems, as it was done for consensus and other agreement problems (e.g. [18], [16]). The properties 
presented in this paper are an initial step in the de.nition of the update problem for transactional 
replicated systems, but further research that clari.es the isolation between replication control protocols 
and meta protocol executions could be undertaken. We believe that stronger and weaker properties could 
be de.ned on the basis of dynamic pro­tocol update isolation levels , as it is done, respectively, for 
DPU algorithms [28, 24] (strong isolation) and in our meta protocol (weak isolation).  8. REFERENCES 
<RefA>[1] Armendariz-I´nigo, J. E., Ju ´´ arez-Rodriguez, J. R., de Mend´ivil, J. R. G., Decker, H., and Mu 
´i, F. D. k-bound gsi: a .exible database noz-Esco replication protocol. In SAC (2007), Y. Cho, R. L. 
Wainwright, H. Haddad, S. Y. Shin, and Y. W. Koo, Eds., ACM, pp. 556 560. [2] Aspectwerkz -Plain Java 
AOP. Tech. rep., 2007. [3] Bernstein, P., Hadzilacos, V., and Goodman., N. Concurrency Control and Recovery 
in Database Systems. Addison Wesley, Massachusetts, 1987. [4] Birman, K. P., Schiper, A., and Stephenson, 
P. Lightweigt causal and atomic group multicast. ACM Trans. Comput. Syst. 9, 3 (1991), 272 314. [5] Chandra, 
T., and Toueg, S. Unreliable failure detectors for reliable distributed systems. Journal of the ACM 43, 
1 (March 1996), 225 267. (a preliminary version appeared in Proc. of the 10th ACM Symposium on Principles 
of Distributed Computing, pp. 325-340, 1991). [6] Chen, W.-K., Hiltunen, M. A., and Schlichting, R. D. 
Constructing adaptive software in distributed systems. In ICDCS (2001), pp. 635 643. [7] Drapeau, S., 
Roncancio, C., and Dechamboux, P. Rs2.7: an adaptable replication framework. In BDA (2002), P. Pucheral, 
Ed. [8] El Abbadi, A., and Toueg, S. Availability in partitioned replicated databases. In Proceedings 
of the 5th. ACM-SIGACT-SIGMOD Symposium on Principles of Database Systems (Cambridge, MA, Mar. 1986), 
pp. 240 251. [9] Elnikety, S., Zwaenepoel, W., and Pedone, F. Database replication using generalized 
snapshot isolation. In SRDS (2005), IEEE Computer Society, pp. 73 84. [10] Fischer, M. J., Lynch, N. 
A., and Paterson, M. S. Impossibility of distributed consensus with one faulty process. Journal of the 
ACM 32, 2 (Apr. 1985), 374 382. [11] Fritzke Jr., U., de M. Morselli Jr., J. C., Abr ao, I. C., Faria, 
C., and Vicentini, W. B. A protocol for mobile replicated databases based on causallity. In Proc. of 
the Workshop de Comunica¸c ao sem Fio e Computa¸c ao M´ovel (WCSF 2004) (2004). [12] Fritzke Jr., U., 
Gomes, L. A. F., Lima, D., and Morais, D. M. A meta protocol for adaptable mobile replicated databases. 
In Anais do VIII Workshop de Teste e Toler ancia a Falhas (WTF 2007) (Belem-PA, Brasil, May 2007). [13] 
Fritzke Jr., U., and Ingels, P. Transactions on partially replicated data based on reliable and atomic 
multicasts. In ICDCS (2001), pp. 284 291. [14] Gilani, W., Naqvi, N. H., and Spinczyk, O. On adaptable 
middleware product lines. In Adaptive and Re.ective Middleware (2004), F. Kon, F. M. Costa, N. Wang, 
and R. Cerqueira, Eds., ACM, pp. 207 213. [15] Gray, J., Helland, P., O Neil, P., and Shasha, D. The 
dangers of replication and a solution. In Proceedings of the 1996 ACM SIGMOD International Conference 
on Management of Data (SIGMOD 96) (Montreal, Canada, June 1996), ACM, pp. 1 10. [16] Guerraoui, R. Revisiting 
the relationship between non-blocking atomic commitment and consensus. In Proceedings of the 8th International 
Workshop on Distributed Algorithms, WDAG 95 (Sept. 1995), vol. Lecture Notes in Computer Science 972, 
Springer Verlag. [17] Guerraoui, R., and Rodrigues, L. Introduction to Reliable Distributed Programming. 
Springer, 2006. [18] Hadzilacos, V., and Toueg, S. Distributed Systems, Second Edition. ACM Press New 
York and Addison-Wesley, 1993, ch. 5: Fault-Tolerant Broadcasts and Related Problems, pp. 97 145. [19] 
Holliday, J., Agrawal, D., and El Abbadi, A. Planned disconnections for mobile databases. In Proc. of 
the 11th IEEE International Workshop on Database and Expert Systems Applications (2000). [20] Kiczales, 
G., Lamping, J., Mendhekar, A., Maeda, C., Lopes, C. V., Loingtier, J.-M., and Irwin, J. Aspect-oriented 
programming. In ECOOP (1997), pp. 220 242. [21] Lieberherr, K., Lamping, J., Lopes, C., B¨ orstler, J., 
Bacvanski, V., and Xiao, C. Workshop on adaptable and adaptive software ­addendum to the proceedings. 
In Proc. of OOPSLA 95 (Austin, Texas, USA, October 1995). [22] Pedone, F., Guerraoui, R., and Schiper, 
A. Exploiting atomic broadcast in replicated databases. In Proceedings of the 4th International Euro-Par 
98 (Parallel Processing) Conference (Southhampton, Sept. 1998), vol. Lecture Notes in Computer Science 
1470, Springer, pp. 514 520. [23] Reliable multicasting with the jgroups toolkit ­revision 1.6. Tech. 
rep., Red Hat Inc., 2007. [24] R¨ utti, O., Wojciechowski, P. T., and Schiper, A. Structural and algorithmic 
issues of dynamic protocol update. In IPDPS (2006), IEEE. [25] Shapiro, M., Rowstron, A., and Kermarrec, 
A.-M. Application-independent reconciliation for nomadic applications. In Proceedings of the SIGOPS European 
Workshop: Beyond the PC: New Challenges for the Operating System (Kolding, Denmark, Sept. 2000). [26] 
van Renesse, R., Birman, K. P., Hayden, M., Vaysburd, A., and Karr, D. A. Building adaptive systems using 
ensemble. Softw., Pract. Exper. 28,9 (1998), 963 979. [27] Wiesmann, M., Schiper, A., Pedone, F., Kemme, 
B., and Alonso, G. Database replication techniques: A three parameter classi.cation. In SRDS (2000), 
pp. 206 215. [28] Wojciechowski, P. T., and R¨ utti, O. On correctness of dynamic protocol update. In 
FMOODS (2005), M. Ste.en and G. Zavattaro, Eds., vol. 3535 of Lecture Notes in Computer Science, Springer, 
pp. 275 289. [29] Yang, Y., and Li, D. Separating data and control: support for adaptable consistency 
protocols in collaborative systems. In CSCW (2004), J. D. Herbsleb and G. M. Olson, Eds., ACM, pp. 11 
20.</RefA>  
			
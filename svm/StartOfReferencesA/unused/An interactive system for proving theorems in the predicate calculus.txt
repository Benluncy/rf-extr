
 AN INTERACTIVE SYSTEM FOR PROVING THEOREMS IN THE PREDICATE CALCULUS Jacques Cohen - Physics Department 
Brandeis University, Waltham, Mass. 02154 Ann Rubin -Junior Student, Mathematics Department Brandeis 
University, Waltham, Mass. 02154 Contents Abstract Acknowledgments 1. Introduction 2. Objectives 3. 
The Tree Method 4. Computer Implementation 4.1 Storage Allocator 4.2 Basic Procedures 4.3 The Main 
Procedure "develop" 5. Interactive System 5.1 Commands Available 5.2 Garbage Collector 5.3 Example 
 6. Strategies  7. Conclusion References Appendix: Algol 60 Programs Abstract This paper describes an 
interactive system for proving theorems in the first order predicate calculus. The system utilizes Jeffrey' 
s tree method, a variant of Beth's method of semantic tableaux, which lends itself well to a man-machine 
interactive type of imple- mentation. The method also permits one to separate clearly the basic problems 
involved in automatic theo- rem proving from those of devising suitable heuristics to obtain a proof. 
The latter can be superimposed on the basic system at a later stage by means of a strat- egy language. 
This paper places special emphasis on a detailed description of programs involved. The sys- tem is operational 
on a small computer. Acknowledgments We would like to thank Professor R. C. Jeffrey, Princeton University, 
for allowing us to quote from his book. We also wish to thank Professor J. van Heijen- oort, Brandeis 
University, for the interest he has shown in this project. 1. Introduction In the past few years automatic 
theorem-prov- ing has become an increas~gly important field of study for computer scientists, z, o Problems 
as varied as question-answering systems and the checking of cor- rectness of programs have been shown 
to be closely related to automatic theorem-proving. Yet, there is a lack of publications directed to 
the computer special- ist describing in an algorithmically precise language how theorem-proving programs 
can be implemented. There are at least two reasons for this lack: a. Most logic texts emphasize the theoretical 
aspects of theorem-proving and pay second- ary attention to the actual description of algorithms involved. 
 b. Until recently there were no suitable pro- gramming languages in which to describe these algorithms. 
Lisp was about the only language available in the 60's to be used as a publication language to communicate 
theo- rem-proving algorithms. Due to the re- striction it requires as to the type of data that can be 
manipulated, programs written in Lisp may be less than easily comprehen- sible, especially for the non-specialist 
in that language. The fact that sophisticated Lisp programmers tend to use a host of local functions, 
varying from one Lisp ver- sion to another, added to the difficulty.  Since then, however, the situation 
has improved. In a recently published book, R. C. Jeffrey sets forth a simple method -the tree method 
-for proving theo- rems in the predicate calculus. The book is directed to undergraduate students and 
places considerable em- phasis on the presentation of algorithms; it also con- tains numerous examples 
and exercises. The interest- ing aspect of the method insofar as the computer scien- tist is concerned 
is that it lends itself very naturally to an interactive man-machine type of implementation, the man 
supplying the strategy for a machine-implemented proof. In additkLn'sthe~'l, recently proposed languages 
such as Algol 68 , in which the user is given his choice of data structure are ideally suited to describe 
the al- gorithms of the tree method. They are more readable and flexible and closer to logical language 
than their predecessors. It was the availability of Jeffrey' s book combined with the advent of the new 
generation of pro- gramming languages which prompted us to work on the project described in this paper. 
2. Objectives Let us first emphasize that we will not discuss here the relative merits of the tree method 
as com-pared with other theorem-proving methods. We will however mention several assets of the tree method: 
(1) It is simple. (2) It is of academic interest and has already been used in teaching hundreds of students. 
 (3) It can be implemented in an interactive mode in short time using a small computer. (4) It permits 
one to separate clearly the basic problems of machine implementation from those of devising suitable 
strategies. Dif-ferent strategies may always be superim- posed on the basic system at a later stage. 
 Having made this claim, we now state the objectives of this paper. (1) To present in a detailed form 
the algor- ithms involved in the tree method. (2) To utilize for this description a standard and widely 
known language (Algol 60 ) so that the description is available to computer scientists. (3) To present 
the Algol 60 programs in such a form that they contain the "flavor" of par- allel Algol 68 programs. 
 (4) To discuss important problems of imple- mentation related to memory allocation, garbage collection 
and a conversational mode.  3. The Tree Method Jeffrey 1 explains the tree method as a variant of "Beth' 
s method of semantic tableaux (or Jaakko Hintikka's method of model sets)..., although its roots go back 
to Jacques Herbrand. " Jeffrey's presentation of the method is briefly reviewed in what follows. We assume 
that the reader has some familiarity with the problems of proving theorems in the first order predi-cate 
calculus. A theorem to be proved is presented by a se- quence of sentences specifying premises, followed 
by a sentence which specifies the denial of the conclusion. To say that premises imply a conclusion is 
to deny that there exists one case m which all premises are true but me conclusion is lalse. ~uch a case 
is called a counter-example or contradiction. The tree method consists of successively adding to the 
sequence of sen- tences a new sentence derivable from a previous one by the axioms of logic. In most 
cases that previous sentence can be eliminated from the current sequence of sentences. Some of the axioms 
may specify that two alternative new sentences be added to the sequence. Therefore sequences may contain 
branching points and can be represented by a tree. In order to establish the validity of a theorem one 
would have to explore all branches of the tree and check whether or not those branches contain contra- 
dictions. Note that if a branch contains a contradiction, we conclude that the interpretation which the 
branch represents is a counterexample to the theorem. In general 3 cases might occur: (1) All branches 
contain contradictions. They are said to be closed. The theorem is valid. (2) All possible new sentences 
have been gen- erated and some branches do not contain contradictions. They are said to be open. Each 
open branch represents a counter- example to the theorem. The theorem is invalid. (3) Although some 
branches are closed and others open, there remain new sentences to be generated and eventually make the 
theorem fall into cases (1) and (2) above. However, one cannot guarantee that the process will ever stop. 
 A more detailed description of the tree method is given in Figures 1 and 2, taken from Jeffrey's book. 
Figure 1 explains the rules of inference for the predicate cal- culus. The flow graph for applying the 
rules of Figure 1 is given in Figure 2. We quote from Jeffrey: "The order of procedure, shown in Figure 
2 is not the only one, but it is fairly efficient (usually) and does insure that if the tree can close 
it eventually will. The infer- ence is invalid if we ever get to stage 7 or if the pro- cedure never 
terminates. " We point out that Figure 2 is not a flowchart for the programs we have written. It is rather 
a flow- chart for the user of the system, a strategy which may eventually be fenced by a more specific 
machine strategy. The programs described in the following sections perform some of the steps of Figure 
2, but it is up to the user to select the strategy (loops in that figure) in order to prove a given theorem. 
The exam-ple in Figure 3 illustrates the application of the method. In that example all branches are 
closed and the theorem is valid. 4. Computer Implementation In this section we describe a set of Algol 
60 procedures that are automatically called by the system when a user makes a request specifying one 
of the (pos- sible) steps of Figure 2. The repertoire of requests available will be described in Section 
5. Throughout this section we will adopt the follow- ing mode of presentation: procedures proper appear 
in the appendix and contain detailed comments about their operation. Explanations about the main actions 
of these procedures appear informally in the text. The procedures were initially tested using an Algol 
compiler; they were then translated into Fortran and incorporated into the interactive system which is 
currently operational on an IBM 1130 computer with a 16K memory. 4.1 Storage Allocator The storage allocator 
is the backbone of the system. It provides the other procedures with the memory space required to construct 
new sentences from the previous ones. By required space we mean a record [structure in Algol 68), i.e. 
a group of con- secutive memory locations. The storage allocator adopted here is not as general as an 
allocator for an Algol 68-like language would have to be. It, however, fulfills our specific needs optimally. 
Its design is centered around the fact that all records utilized in the program are of fixed but arbitrary 
length, known before the first call of the allocator. This is precisely the situation which occurs in 
our case: once a theorem is entered one knows the sizes of all records that will be involved in a proof. 
Reference [ 4] describes an al- locator based on which we designed ours. Before describing it let us 
point out that point- ers (or references in Algol 68) are represented through-out this paper by integer 
indices to the integer array "memory [l:size]." This arrangement forces us to represent almost all of 
the entities involved by an in- teger code. The allocator uses a special array "homogene-ous [ length]" 
to store free-lists of records of constant sizes used in the program. Records of other sizes are kept 
in an "assorted sizes" list. No records of length one are used in our programs. Basically only two pro- 
cedures are required: one to produce a record of a given length, another to return a record of a specific 
size. The following bookkeeping policy is used: if a record is available in the homogeneous list it is 
taken from there; if not, the assorted sizes list is searched for the first record with length greater 
than the one re- quested. The latter is split and the remainder returned to storage. Similar policy holds 
for returning records to storage. If a record is of homogeneous type it is in- corporated into the corresponding 
homogeneous list. Otherwise it is returned to the assorted sizes list. In-itial conditions are: all homogeneous 
lists are empty and the assorted sizes list contains just one element -the entire storage area. 269 We 
will postpone until next section the descrip- tion of the "drastic" measures that will have to be taken 
when the available space is exhausted. 4.2 Basic Procedures A sentence in our system is represented in- 
ternally by a group of records of the types type structure 1 { operator code, left operand pointer, right 
operand pointerj ~ 2 {negative code, pointer~ 3 {quantifier code, variable, pointer~ 4 {function code, 
n,~me, number of variables, list of variables~ Records of type 1 are used to represent the binary op- 
erations /~( , ~--~ , ~ , v), type 2 to represent negation, type 3 quantifiers and type 4 functions. 
The function designator "triplet" is used to obtain records of types 1 and 3 . The function designators 
"nega-tion" and "function 1, " "function 2, " "function 3," .., etc. are used to obtain records of types 
2 and 4 respectively. These function designators are ex-tremely simple: they just call the storage allocator 
to obtain the needed space. Notice that records of type 4 must be obtained through calls of the corresponding 
procedures "function n," since no procedures with variable number of parameters are allowed in Algol 
60. In order to represent sequences of sentences two additional types of records are needed: type structure 
5 {sequence number, pointer to sentence prop- er, pointer to next sequence, number of sequence from which 
it was derived, mark-er for check, marker for closed~ 6 {branch code, pointer to left branch, pointer 
to right branch} The function designator "line" uses records of type 5 to represent one sentence. Similarly 
branches are represented by records of type 6 , obtainable through the function designator "branch." 
Input-output procedures will not be described in this paper. For the purposes of presentation the reader 
can assume that a sentence such as (V y) (H(y)~A(y)) can be constructed internally by the call (in prefixed 
notation): triplet (for ally y, triplet (implication, functionl (H, y), functionl (A, y) ) ) Similarly 
an entire theorem can be input by using the procedure "line." In Figure 4 we describe pictori- ally the 
memory lay-out of a theorem. For the pur- pose of applying the tree method a 7th type of record was introduced. 
type structure 7 {head pointer, tail pointer} This is a Lisp-like type of record which can be invoked 
by the function designator "list." The function "copy" is used to copy any of the records of types 1 
through 7. 4. 3 The Main Procedure "develop" We start by pointing out that the apparent sim- plicity 
of the procedure "develop" is misleading: its execution may eventually trigger a call of every single 
procedure described in this paper! Before proceeding to the description of the pro- cedure proper, we 
warn the reader that for the sake of clarity we eliminated in the Algol programs the tests for checking 
the correctness of the actual parameters. These tests are of course essential and were imple-mented in 
the operational system. The main action of the procedure is to examine a sentence specified by the user 
and append a new sen- tence to the current sequence of sentences using the rules of inference. This action 
may be followed by a removal of the old sentence from the sequence of sen- tences. A final action of 
"develop" is to check if the theorem is valid and issue a message accordingly. More specifically, a call 
of "develop" com-mands the computer to perform the following actions: (1) Search for the sentence specified 
as the first actual parameter by calling the pro- cedure "search. " (2) Examine the main operator governing 
the sentence and transfer control to the part of the program which processes the sentence. These parts 
correspond basically to the 4 cases depicted in Figure 1, including the 8 subcases of the part involving 
logical con- nectives. A substantial saving in program- ming lines can be achieved by introducing the 
procedures whose actions are described pictorially in Figure 5. These procedures build the structure 
which represents the application of one of the rules of inference and then call the procedure "attach" 
to ap- pend the structure to each of the leaves (i. e. ends of branches) below a given node. In the 
case of quantifiers the function desig- nator "replace" is used to replace a vari- able by the supplied 
constant. Notice that the algorithm requires that new structures be built from the previous ones by succes- 
sive copies or replacements. (3) Transfer control to the part of the program which marks the sentence 
as checked This is not done in the cases involving double denials or universals. (4) Check if all paths 
are closed by a call of the procedure "closed." This procedure builds two lists of the functions and 
---1 functions in a given branch. When it reaches a leaf it calls the boolean procedure "intersection" 
to test if the two lists intersect. If so, the branch is marked to be closed. A check is made at the 
very end of "develop" to test if all branches of the tree are closed and to issue a corresponding message. 
 5. Interactive System 5.1 Commands Available The procedures described so far perform the basic tasks 
of building and maintaining the tree struc- ture. They are, however, imbedded in an interactive system 
which involves the user in the strategy of prov- ing the theorem. In a conversational mode, the user 
can decide which formula to develop next, and which constant to use in developing a universal formula. 
He can also request the machine to print all the formulas in the tree, print all the branches in the 
tree, create or erase theorems, etc. The current list of interact- ive requests is summarized in Figure 
6. Some of the procedures referred to are described in the next sec- tion. Note that while the Algol 
procedures assume that the user makes no errors in calling "develop," the implemented interactive system 
is completely equip- ped with error messages for incorrect calls of sub- routines. One feature which 
will be added soon is a pic- torial print of the branches of the tree. Since only binary trees are involved, 
we will be able to represent the branches of a tree on a printer. It would also be desirable to have 
a procedure which would reduce a tree which is completely closed. It would signal those steps which were 
vital to the clo- sure of the tree and eliminate those which were un- necessary. The interactive features 
of the system make it a potential educational aid for students in logic courses. 5.2 Garbage Collector 
The garbage collector is an integral part of the interactive system. It consists of two phases; one phase 
stores only the relevant data from the fast mem- ory in secondary storage, while the other brings it 
back into fast memory. ~rhe net result is that all cur- rently unused words are returned to the free 
lists; thus this double operation regains space in the memory. Notice that the two phases of the "garbage 
collector" actually perform two functions. The user can issue the command "save" at any time if he wishes 
to store the present configuration in secondary storage. The first phase of garbage collection is performed 
at this time, but the configuration can remain in secondary storage for any length of time while other 
theorems are developed. Only when the user issues the com- mand "bring" is the garbage collection process 
com-pleted. The first phase of the garbage collector con- sists of the procedures "savelines," "save," 
and "store." "Savelines" saves records of type 5 and, using "store, " which does the actual output, stores 
the following data into secondary storage: address, line code, al, a2, a3, a4, a 5 where a. is the contents 
of memory [address + i] If 1 the sentence to which this record refers has not been developed, it is saved, 
using "save. " Each record of types 1 - 4 is saved by storing in the secondary storage: address, al, 
a2, ... a i where a. means the same as above and a. will de- termine ~he length of the record to be stored. 
For ex-ample, if a 1 - minus, the length is 2. Branches are stored similhrly. Note that developed sentences 
are not saved. This is the primary source of memory locations gained in the garbage collection process. 
The other main source is records used in constructing binary lists at various places in the program. 
"Bring" completes the garbage collection pro- cess by moving the configuration from secondary stor- age 
to fast memory. First it flags the entire memory. After retrieving the information stored in secondary 
storage, it returns all flagged words to free lists. Note that we do not check to see if a record has 
al- ready been retrieved before placing it back in fast memory. Since in our implementation of the tree 
al- gorithm each record which has been saved is refer- enced by only one pointer, this checking is unneces- 
sary. where the memory is extremely crowded and even gar- bage collection does not produce the requested 
record, compacting may be necessary; we do not have this provision presently. 5.3 Example The example 
in Figure 7a is the computer-im- plemented proof of the theorem from Jeffrey's book shown in Figure 3. 
The output shown is the final tree; each sentence is shown with its sentence number and the number of 
the sentence from which it was derived. A check in the last column indicates that the sentence has been 
developed. The numbers of undeveloped sen- tences in each path are listed; a minus denotes a closed branch 
of the tree, and the message "all paths closed" indicates that the theorem has been proved valid. The 
next section of output is the machine's re- sponse to the request NAMES. At this point, only THEOREM 
1/1 exists. The last part of Figure 7a shows how THEOREM 1/1 looks after garbage collection. All the 
developed formulas have been eliminated. Figure 7b is a reproduction of the requests the user made in 
proving the theorem. The number of words mentioned after the request BRING does not represent a net gain 
of memory space, but the number of memory locations now available. The total memory in this system is 
6400 words. 6. Strategies The interest of the interactive system de- scribed in the previous section 
can be greatly enhanced by the introduction of a language to describe strategies. In the work currently 
in progress we allow the user to define a special type of file - the executive or strategy file - in 
which he can specify by a program his adopted strategy. The interactive command apply <strategy file 
name>to <~heorem name> would automatically trigger the development of the sen- tences of the given theorem 
according to the strategy specified in the executive file. The basic statements of the strategy language 
are those already described in Section 5 to which we added a simple go to<label>statement. It is, however, 
the introduction of the conditional statement that pro- vides the language with the power to express 
varied heuristics. A conditional statement has the classical form: <label~,. if <boolean expression>then 
<basic statement~, We feel that the desirable features of the strategy lan- guage are intrinsically related 
to the "ingredients" of the <boolean expression> above. The conditional ex- pression can be of several 
types such as: _if< pattern app.lies> then ~develop certair~ formula~, or, if < configuration looks promising> 
then <save>; or, _~ < configuration looks hopeless> then <backtrack to most promising Configuration> 
;~ The heart of the matter is, of course, to have in the language the means to express and evaluate the 
expressions between < >. One could intuitively say that the criteria such as memory space available, 
number of branches closed, number of functions in a branch, constants used in developing a universal, 
etc. would be critical, and means of evaluating them should Procedure "garbage collect" which calls both 
exist in the strategy language. phases of the process is automatically called by "record" when it cannot 
get a record of requested size. In cases We feel that only actual experience with an op- erational system 
having some of the above character- istics can give us more insight into what other fea- 5. tures are 
desirable to express heuristics in a strategy language. Our current efforts are aimed in that direc- 
tion. 7. Conclusion 6. In this paper we have described an interactive system for proving theorems in 
the predicate calculus by the tree method. The system is operational on a . small computer and it will 
be made available to the students in an introductory logic course at Brandeis University. The novel feature 
of the system is that it al- lows the user to try several different directions in 8. proving a theorem 
and store the most promising inter- mediate results in secondary storage. If a given at- tempt fails 
(or looks hopelessly complicated) he can always return to one of the previous configurations and try 
again. The computer is thus used as a sophisti- cated scratch pad in which to record trials, a tool which 
also provides useful information about the cur- rent status of a proof. Our current effort is to provide 
the system with a language in which the user can tailor his strat- egy and command the computer to perform 
automati- cally a series of actions which will, hopefully, lead toward a proof. Special emphasis has 
been given to the descrip- tion of the algorithms in the currently used language Algol 60. Our experience 
in writing these programs is that: (1) They fully utilize the characteristics of Algol 60 as far as recursiveness 
and data structure are concerned. A special stor- age allocator had to be programmed to provide a suitable 
data base. (2) Their structure is very much the same as an equivalent Algol 68 program. As a mat- ter 
of fact th~ reader can consult a com- panion paper,, in which we describe the same basic algorithms using 
Algol 68. (3) In spite of all the efforts to render the pro- grams readable (and we hope they are) it 
is impossible to avoid the use of statements which have little to do with the problem proper and must 
be made simply because Algol 60 does not have the flexible data structure which would make manipulations 
more understandable.  The above prompts us to affirm that the avail- ability of a language like Algol 
68 is essential to the description of the basically simple but potentially in- tricate algorithms involved 
in automatic theorem prov- ing. We also hope that this paper will help knowledge- able Algol 60 programmers 
to appreciate the needed features of a new language such as Algol 68. References 1. Jeffrey, R. C., Formal 
Logic: Its Scope and Limits, McGraw-Hill Book Co., 1967. 2. Meltzer, B. and Michie, D. (editors), Machine 
Intelligence 4, American Elsevier Publishing Co., 1969. 3. Naur, P. (editor), Revised Report on the 
Algorith- mic Language Algol 60. 4. Parente, R. J., A Simulation-Oriented Memory Allocation Algorithm, 
in Simulation Program- miag Languages. North Holland, 1967.  Robinson, J. A., A Review of Automatic 
Theorem- Proving, in Proceedings of Symposia in Applied Mathematics, Vol. XIX, American Mathemati- cal 
Society, 1967. Trilling, L. and Cohen, J., An Algol 68 Program to Prove Theorems by the Tree Method (to 
ap- pear). van Wijngaarden, A. (editor}, Mailloux, B. J., Peck, J. E. L., and Koster, C. I-I. A., Re~ 
on the Algorithmic Language Algol 68, Springer Verlag, 1970. Wirth, N. and Hoare, C.A.R., A Contribution 
to the Development of Algol, Comm. ACM 9, 6, 1966. l Erase "---'" wherever it appears in unchecked sentences 
in List the premises and the denial of the conclusion. open paths. Check sentences of fonns "-(x).. :x...'" 
and "-(3x)... x... in open paths and rewrite them as "(3x) - ... x..." and "(x) -... x.. "' at the bottoms 
of those paths. Apply the roles for denial to all relevant sentences. Close each path that contains 
both a sentence and its O&#38;A x/0~A denial. Are all paths closed? o j_ o No/ IYes ~ Stop. The inference 
-0 ~_~ 0 A A - is valid. A -A 1 s Is there a scntence (unchecked, in an open path) to which one of the 
rules for conncctives applies? No / [ Yes , Apply it. --A -A -0 A -A Is there a sentence to which the 
rule for existential quantifiers can be applied? Given an open path in which a sentence of form (x).'.. 
x... ~ occurs: for each name n that appears anywhere in the path, write ~ the sentence.., n... at the 
bottom of the path unless that sen- "~. ~ tence already occurs in the path. (If no name appears in the 
path, Is there a sentence to which the rule for universal ~ choose some name n and write.., n... at the 
bottom of the quantifiers can be applied? path.) When yon are done, do not check the sentence (x) ... 
x .... No / [ Yes ~ Apply it. Given an unchecked sentence of form (3x) ... x... that occurs Have you 
made any changes in the ,'.fete since last in an open path: inspect the path to see whether it contains 
a entering stage No2 aiove? [Yes sentence of form.., n... where n is some name or other. If not, choose 
a name n that is not used anywhere in the path, and write the sentence.., n... at tile bottom of the 
path. When this has Stop. The hfferenee been done for every open path on which the given sentence of 
is invaJid. form (3x)... x... occurs, check that sentence. -~.denotes implication,.~-~': identity, g 
: intersection, Figure 2. User's Flowchart -The Tree MethodV : union, -: negation, ~ : existential quantifier, 
'( )or~: universal quantifier Figure 1, Rules of Inference [premise] 1 (y)(Hy ~ ay) 2 ~/ --(x)[(3y)(Hy 
&#38; xTy) ~ (3y)(Ay &#38; xTy)] [-- conclusion] 3 x/(3x) -[Oy)(Hy &#38; xTy) -, (3y)(Ay &#38; xTy)] 
[2 by -] 4 ~/ --[(3y)(ny aaTy) ~ (3y)(Ay &#38; aTy)] [3 by (3x)] [4 by 5 X~ (3y)(ny aaTy) 6 ~/ -(3y!(Ay 
&#38; aTy) -(o -~ A)] [5 by (3y)] 7 :V Hb&#38;aTb [7by 8 Hb 0&#38;A] [6by -] 9 aTb 10 (y) --(Ay &#38; 
aTy) 11 V -(Abe aTb) [10 by (y)] [11 by -(0 &#38; A)] /\orb 12 -, - × [1 by (y)] 13 ~/ Hb ~ Ab [13 by 
0 ,~, A] 14 ~Hb/XAb .× × Figure 3. An Example D. EO N ,-ON *0 O~ - Iu 0 0 OO ** 0 * ~.= ~ '~ io ~ ,'O 
O ~% ~ ~ O ~ O o.~o O: ,,C~O t G ~.~ U r0 u o ~ N O o ~ o ~ ~ o ~ ~ ,~ 'r. "; o > o ~ ~ d ": @ 12 
o O O "2, 2 u "r. O N ~J N u r. O °~ ~. °~ o. u m o ~ ~ o ~ l Ii il [ I ~77~ RI~QIII!STS request 
format action error messages develop DEVELOP, sentence Develops requested formula, Sentence number doesn't 
exist. number, constant to be substituted adds resulting leaves of tree. sentences Closed to is Sentence 
already developed. (if a universal) called after each call of Sentence is a closed leaf. develop -finds 
closed branches. and marks iSentence is a function. tree TREE or PATHS Prints all sentence numbers in 
each branch of the tree, with 'open' or *closed' after each. print PRINT Prints all formulas in the tree, 
their sentence numbers) from which sentence each is derived, and whether or not it is developed. save 
SAVE Puts theorem currently in fast No theorem in fast memory. memory into secondary storage. A pointer 
to its position in secondary storage is retained. This is the first half of the garbage collection scheme 
(see section on garbage collection). bring BRING TH theorem Brings requested theorem from There is already 
a theorem number/variant secondary storage to fast in fast memory which must number memory. After transferring 
data be erased or saved. to fast memoryj it returns all unused memory locations to the free list and 
reports This theorem/variant exist. doesn't how many free locations exist. erase ERASE TII theorem Deletes 
theorem named from This theorem/variant doesn't number/variant list of theorems. exist, number Figure 
6. Interactive Requests REQUESTS (2) request format action error messages quit QUIT Quits, after saying 
a fond farewell. names NAMES Prints names of all theorems and variant numbers now in secondary or fast 
storage. max MAX Prints max, the variable used to keep track of constants which have been used in developing 
existen~ and universal formulas Max is set to the highest number constant used so far. create CREATE 
TÁ! theorem Enters this theorem and variant There iS already a theorem in number/variant into list of 
current theorems, fast memory which must be number reads sentences of theorem and erased or saved. sets 
up proper data structure. Syntactic errors in input string are flagged. instances INSTANCES sen-Lists 
constants which have tence number of a already been substituted for universal sentence the universal 
quantifier in this sentence, clean AJAX or After checking to make sure file MR. CLEAN the user hasn't 
made a fatal mistake, deletes all theorems presently stored.---Useful for those with suicidal tendencies. 
change CH&#38;NGE TH theorem Changes number of theorem in No theorem now in fast memory. number/variant 
fast memory to that indicated in request. This is useful when one wants to SaVe a given con-figuration 
but continue deve-loping under a different variant nu~er. Figure 6. Interactive Pequests (cont.) 275 
 C w ¢..) w ~ ~ X v X ~ ~ 0 ~ 0 0 ~° ~ ..a lu x ~ ,,4 o Vl tn ~-4 .=.4 X N [N uJ~. I ~x ~ o i.u ~ ~ 
o. o.. m f~l m~..) I I I ~ E c. t~ o 0 i > ~zJ o >- 0 C £J c~ ff ~ x o ioo ~ 2 u ~--Lu 276 ALGOL/60 
PROGRAM List of Global Variables All variables are of the type integer unless specified. Variable Comment 
memory [ l:size] Primary memory available for storage of theorems. homogeneous [ l:h] This array contains 
pointers to the free lists of records of constant length. It is utilized by the input routines. "Homo- 
geneous" may also contain two types of marks; one to denote the end of a list ("end mark") and the other 
to indicate the non-existence of the corresponding size of constant length record ("empty"). assorted 
sizes Contains pointer to the assorted sizes list. end mark Constant to denote the ends of lists. Initialized 
to - 1. empty Constant to denote the non-existence of a record of constant length. Initialized to -2. 
 ~lsg Constant used by the garbage collector. Initialized to - 3. minus Constant used to denote ° . 
Initialized to I. implication Constant used to denote 4 Initialized to 2, union Constant used to denote 
V. Initialized to 3. intersection Constant used to denote g . Initialized to 4. identity Constant used 
to denote ~ . Initialized to 5, universal Constant used to denote ~ . (or for all) Initialized to 6. 
existential Ce~stant used to denote ~ . (or exists) Initialized to 7. branch code Constant used to denote 
a record ot type 6. Initialized to 0. redicate Constant used to denote a record of r function) type 
4. Initialized to 8. number Variable that indicates a sequence number. Initialized by input routines. 
Increased by "develop. " from Variable which indicates a sentence from which a given sentence has been 
developed. Updated by "develop. " theorem Pointer to the first record of type 5. Initialized by input 
routines. max Largest value of the constant currently being used. checked Constant used to indicate that 
a sentence has been developed. Initialized to 1. close Constant used to indicate that a branch (path) 
of the tree is closed. Initialized to 1. all paths closed Boolean variable used to check if all paths 
of the tree are closed. not checked Constant used to indicate that a sentence has not been developed. 
Initialized to 0. not closed Constant used to indicate that a branch of the tree is not closed. Initialized 
to 0. 277 A. 1 Storage Allocator integer procedure record (length); value length; integer length; begin 
integer temp, previous; beginnil~: homogeneous [ length] ~ end mark A homogeneous [ leng-th] = empty 
then begin comment take record from homogeneous list; record: = homogeneous [ length] ; homogeneous [ 
length] :=memory [ homogeneous [ length] ] end else begin comment tests are made with length+l to avoid 
having residual records of size one; previous :=temp:=assorted sizes; _~.memory [temp+l] > length+l then 
 begin assorted sizes:=memory [ temp] ; goto continue end else temp:=memory [ tempi ; loop: _~_ temp 
~ end mark then begin ..~ memory i~temp+1] > length+l then begin memory [previous] :=memory [temp] 
; continue: record:=temp; return ( temp+length, memory [ temp+l]-length) end else begin previous :=temp; 
temp:=memory [ tempi ; goto loop end end else begin garbage collect; goto beginning end end end of 
record; procedure return (pointer, length); value pointer, length; .integer pointer, length; .~.homogeneous 
[ lengthl ,e empty then l~:~,~.n comment return to homogeneous list; memory { pointer] :=homogeneous 
[ length] ; homogeneous [ length] :=pointer end else .~gil~ comment return to assorted sizes list; memory 
~pointer] :=assorted sizes; memory [ pointer+1 ] :=length; assorted sizes:=pointer end end of return; 
A.2 Basic Procedures integer procedure triplet (operator, left operand, right operand); value operator, 
left operand, right operand ; integer operator, left operand, right operand ; begin integer t ; t :=record 
(3); memory [ t ] :=operator; memory [t + 1] :=left operand; memory It + 2] :=right operand; triplet 
:=t end of triplet; integer procedure negation (operand); value operand; integer operand; begin integer 
t; t:=record (2); memory It] :=minus; memory [ t + 1] :=operand; negation: =t end of negation; integer 
procedure functionl (name, variable); value name, variable; integer, name, variable; begin integer t 
; t:=record (4); memory [t ] :=predicate; memory [t + 1] :=name; memory [t + 2] :=1; memory it + 3] 
:=variable; functionl :=t end of functionl ; Comment integer procedures function2, function3, etc. are 
not listed here. They are similar to functionl. ; i!lt_cge_r.12roce__~re line (sentence, next, from, 
checked, closed); value sentence, next, from, checked, closed ; integer sentence, next, from, checked, 
closed; begin integer t ; t :=record (5) ; number:=number+l ; memory I t ] ::number ; memory It + 1] 
:=sentence; memory [t + 2] ::next; memory [ t + 3] :=from; memory it + 4] :=checked; memory [ t + 5] 
:=closed; line: =t end of line; inte~r prgce_~re new line (forml, form2); yalue forml, form2; i__n_te_ger 
forml, form2 ; new line:=line (forml, form2, from, not checked, not closed); intege_r procedure branch 
(left, right); value left, right; integer left, right; branch:-triplet (branch code, left, right); lnt_e_ger_l?rog.edure 
list (head, tail); value head, tail; i_ntct~9..~_ head, tail; .beg.in iz)tege.___r t; t: record (2); 
memory [ t} :=head; memory [ t 4 1] :=tail; list:=t end of list; i!,tegc__r procedure copy (element, 
length); value element, length; integer element, length; _~gin !n_3.cfler t, i; t:-rccord (length); Ior 
i: =0 step 1 until length- 1 d__.o memory [ t + i] :=memory [ element + i] ; copy:=t en___d ol copy; 
 A. 3 The Main Procedure 'develop' procedure develop(number, constant); value number, constant; integer 
number, constant; begin integer position, sentence, iteml, item2; switch operation:=denial, implies, 
or, and, identical, universal, existential; from:=number; search(number, position); comment position 
contains now a pointer to a record of type 5; sentence:=memory [ position+I] ; iteml:=memory [ sentence+I] 
; comment store information in item2 if not a denial; memory [ sentence] > I then item2:=memory [ sentence+2 
] ; goto operation [ memory[ sentence] ] ; denial: begin switch not operation:=not denial, not implies, 
not or, not and, not identical, not universal, not existential; sentence:=memory [ sentence+l] ; iteml:=memory 
[ sentence+l] ; if memory [ sentence] > 1 then item2:=memory [sentence+2]; goto not operation [ memory 
[ sentence] ] ; not denial: comment erase--; memory [ position+l] :=iteml; goto out; not implies:add2 
(position, iteml, negation(item2) ); goto mark; not or:add2 (position, negation(iteml), negation(item2) 
); goto mark; not and:orl (position, negation(iteml), negation(item2) ); goto mark; not identical:or2(position, 
negation(iteml), item2, iteml, negation (item2)); goto mark; not universal:comment replace -V by ~ -; 
addl(position, triplet(exists, iteml, negation(item2) ) ); goto mark; not existential~comment replace 
- ~ by V -; addl(position, triplet(for all, iteml, negation(item2) ) ); goto mark end of denial; implies 
:or l(position, negation(iteml), item2)-, goto mark~ or:orl (position, iteml, itenl2); goto mark; and:add2(position, 
itcml, item2); goto mark; identical:or 2(position, item1, item2, negation(iteml), negation(item2) ); 
goto nmrk; universal:add1 (position, replace (item2, item1, constant) ); goto out; existential:comment 
increase counter for the pool of constants; nmx := max+ 1; addl(position, replace(item2, iteml, max) 
); mark:memory [ pos ition+4 ] :=checked; out:all paths closed:=true; closed(theorem, end mark, end mark); 
~all paths closed then success else keep trying .end of develop; 278 procedure search (number, position); 
value number; integer number, position; comment this procedure places in position the pointer to the 
record of type 5 containing the sentence denoted by number; begin procedure search prime (node, number); 
value node, number; integer node, number; begin memory[ node] =branch code then be~t~ search prime (memory[ 
node+l], number); search prime (memory[ node+2], number) end else ..ff memory[ node] =number then begin 
pos it ion :=node; goto out; end else _~ memory [ node+2] ~ end mark then search prime(memory[ node+2 
], number) end o1 search prime; search prime (theorem, number); out: en__d of search; procedure or 
l(position, Iorml, form2); value posRion, Iorml, form2; i IRoner pnsition, forml, form2; attach(posRion, 
branch(new line(form1, end mark), new line(form2, end mark) ) ); p r2c?dur_e addl(position, form); value 
position, form; it__~teger position, term; attach(position, new line(form, end mark) ); p ro_cedure 
or 2(position, forml, 1orm2, form3, form4); value position, fermi, 1orm2, form3, form4 i!13c~.t~_r position, 
forml, *.orm2, form3, form4; attach(position, branch(new line(fermi, new line(form2, end mark) ), new 
line(form3, new line(term4, end mark)))); lWoc_c&#38;lr.e add2(position, forml, form2); value posifion, 
forml, form2; .igte~er position, term1, term2; attach(position, new line(fermi, new line(form2, end mark) 
) ); l~ro_ces!t~rre attach (node, structure); value node; integer node, structure; comtnent this procedure 
attaches to each leaf below the node given as first parameter the structure given as the second parameter. 
 be ,in if memory[node] branch code then attach (memory{ node+ 1 ], structure); attach (memory[ node+21, 
structure) end else il memory[ node+2lb end mark then at inch(memory[ node+2], structure) else comment 
if branch is closed do not attach structure; .~_ memory[ node+5] b close then memory[ node+2] :=structure 
end ol attach; .---- .integer.PrOcedure replace (item, variable, constant); value item, variable, constant; 
integer item, variable, constant; begin integer t; switch operator type:= negation, binary, binary, binary, 
binary, quantifier, quantifier, function; goto operator type [memory[ item] ] ; negation:t:=replace:=copy 
(item, 2); memory [ t+l] :=replace(t+l, variable, constant); goto out; binary:t:=replaee:=copy (item, 
3); memory[t+l] :=replace(t+l, variable, constant); continue:memory[t+2] :=replace(t+2, variable, constant); 
goto out; quantifier :t:=r opine e :=copy(item, 3); got____9 continue; Iunction:t:=replaee:=substitute(item, 
variable, constant); out: en___d of replace; inteFer..proc.edure substitute (item, variable, constant); 
value item, variable, constant; ..integer item, variable, constant; begin integer i, t; t :=suhstitute:=record(memory[ 
item+2] +3); fo__r i: = O, I, 2 d....o memory [ i + t] := memory [ i + item] ; fo_.r_ i: = 3 step 1 until 
memory [ item+2]+2 d._o memory [ i + t] := ff~ memory [ i + item] = variable then constant els...._e 
memory [ i + item] en__.d of substitute; procedure closed (branch, I, el); value branch, f, at; _i~)teg_er 
branch, f, nt; .~_lz_lIZ integer item; e o.n.2n_2e__nt cheek for a branch code; if memory i branchl =branch 
code then ~s~h_2 closed (memory[ branch+ I], f, nt); closed (memory[ branch+21, I, nt) exad else be 
,in comment look now for functions and not functions ; item:=memory [ branch+l] ; menmry [ item] : predicate 
then I::list (item, I) else ff~ memory [ item] : minus A memory [ memory [ ifem+ll } = predicate then 
af:=list (memory [ item+l], nt); comment now check if leaf; ~_ memory [ branch+2] = end mark then if 
intersection (f, nf) then comment close the branch; memory [ branch+5] := close else all paths closed:= 
false end else closed (memory [ branch+2], f, nf) end of closed; 279 boolean procedure intersection 
(i, nf); value f, nf; integer f, nf; begin integer tl, t2, i; if f=end mark~/nf=end mark then goto no; 
fo_Z tl: =f, memory It1 + 1] while tl ~ end mark do fo_z t2:=nf, memory It2 + 1] while t2 ~ end mark 
do begin comment check if same function. If so, check entire record; memory [ memoryi tl] +1] =memory[ 
memory[ t2] +1] then ~gin. for t:=3 step 1 until memory [ memory[t l] +2] d_.o memory [ memory[ tl] +i]k 
memory[ memory[ t2 ] +i] then goto try next functions; intersection:= true; goto out en__d; try next 
functions: end; no: interseetion:=faise; out: en___do~intersection; procedure bring (theorem); .inte~e_r 
theorem; begb~ integer i, address, code, number of free records; con)n~cnt first flag the entire memory; 
for. i : : l stcp 1 u_!l.til size d___o_ memory [ i I : = flag; ininteger (secondary, theorem); address:=theorem; 
o~ L; restore main memory: ininteger (secondary, address); if address / flag then ~_~i n_ L : ininteger 
(secondary, code); if code = line code then fur i : = 0 step 1 until 4 do ininteger (secondary, memory 
[ address+;l) else if code = predicate then pcgi___~ memory [ addressl : = code; {or I : :I, 2 d_o ininteger 
(secondary, memory[address+i] ); fo__r_ i : = 1 step 1 until memory [address+2] d_p. ininteger (secondary, 
memory [address+2+il) end else begin menmry [ address] : = code; ininteger (secondary, memory [ address+l} 
); if code ~ minus then ininteger (secondary, memory [ address+2]) en__d; ~t!to-restore main memory 
 end comment return flagged words to homogeneous or assorted lists, first reinitialize; fo____r i : 
= 1 step 1 until h d__o homogeneous I i ] : = end mark; assorted sizes:= end mark; address:= 1; loop: 
i := address-l; number of free records:= O; for i:= i+ 1 while i<- size do if memory I i ] = flag the_____n 
number of free records:= number of free records + 1 else goto back; Ixtck: if number of free records 
~ 0 then return (address, number of free records); address:= address + number of free records + 1; .~ 
address < size the..__.n goto loop end of bring; A, 4 Garbage Collector procedure garbage collect; save 
lines (theorem); bring (theorem) end ol garbage collect; procedure save lines (line); value line; integer 
line; L~u} integer i ; nutinlcger (secondary, line); comment check for a branch; .il memory L line] 
= branch code then outinteger (secondary, branch code); fo X i : =l, 2 d__oo outinteger (secondary, 
memoryl line+i] ); for i : =I, 2 do save lines (memory[ line+;l) end else outinteger (secondary, line 
code); for i : =0 step 1 until 4 do outinteger (sccondary, memory[ line+;l); comment save sentence if 
not checked; iI memory I line+4{ = checked then save (memory [ line+t1 ); comment continue saving lines 
until a leaf is reached; if_ memory I line+21 .= end mark then save lines (memory{ line+2]) end end 
of save lines; procedure save (item); value item; intege__r_ item; _~gin comment this procedure saves 
a record by writing it in secondary storage using the procedure "store." It cheeks the size and type 
of all item before calling "store" and then itself; _~_ memory [ item] = predicate then Store (item, 
memory [ item+2] +3) else _~_ memory [ item] = minus then begin store (item, 2); save (memory[ item+I] 
) end else begin store (item, 3); memory [ item] ~ existential A memory [ item] / universal then save 
(memory[ item+ll); save (memory[ item+2] ) end en___d of save; procedure store (address, size); value 
address, size; ..integer address, size; begin integer i; outinteger (secondary, address); fo__~ i: =0 
step I until size-I do outinteger (secondary, memory{address+i]) en._.d of store; 280
			


 Analyzing Security Protocols with Secrecy Types and Logic Programs * Mart´in Abadi Bruno Blanchet Computer 
Science Department D´epartement d Informatique University of California, Santa Cruz Ecole Normale Sup´ 
erieure, Paris abadi@cs.ucsc.edu Bruno.Blanchet@ens.fr ABSTRACT We study and further develop two language-based 
tech­niques for analyzing security protocols. One is based on a typed process calculus; the other, on 
untyped logic pro­grams. Both focus on secrecy properties. We contribute to these two techniques, in 
particular by extending the former with a .exible, generic treatment of many cryptographic op­erations. 
We also establish an equivalence between the two techniques. 1. INTRODUCTION Concepts and methods from 
programming languages have long been useful in security (e.g., [30]). In recent years, they have played 
a signi.cant role in understanding security pro­tocols. They have given rise to programming calculi for 
these protocols (e.g., [5, 6, 7, 12, 13, 16, 17, 19, 26, 28, 34]). They have also suggested several approaches 
for reasoning about protocols, leading to theories as well as tools for formal pro­tocol analysis. We 
describe some of these approaches below. Although several of them are incomplete, they are appli­cable 
to many protocols, including in.nite-state protocols, often with little e.ort. Thus, they provide an 
attractive al­ternative to .nite-state model checking (e.g., [27]) and to human-guided theorem proving 
(e.g., [33]). In this work we pursue these language-based approaches to protocol analysis and aim to 
clarify their interconnections. We examine and further develop two techniques that repre­sent two substantial 
but largely disjoint lines of research. One technique relies on a typed process calculus, the other * 
This work was partly done while the author was at Bell Labs Research, Lucent Technologies, and at InterTrust 
s Strategic Technologies and Architectural Research Labora­tory. This work was partly done while the 
author was at INRIA Rocquencourt. Permission to make digital or hard copies of all or part of this work 
for personal or classroom use is granted without fee provided that copies are not made or distributed 
for pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst 
page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior 
speci.c permission and/or a fee. POPL 02, Jan. 16-18, 2002 Portland, OR USA . 2002 ACM ISBN 1-58113-450-9/02/01 
...$5.00. on untyped logic programs. We contribute to these two tech­niques, in particular by extending 
the former with a .exible, generic treatment of many cryptographic operations. We also establish an equivalence 
between the two techniques. We believe that this equivalence is surprising and illuminat­ing. The typed 
process calculus belongs in a line of research that exploits standard static-analysis ideas and adapts 
them with security twists. There are by now several type systems for processes in which types not only 
track the expected structure of values and processes but also give security in­formation [1, 4, 11, 20, 
22, 23]. A related approach relies on control-.ow analysis [10]; it has an algorithmic emphasis, but 
it is roughly equivalent to typing at least in important special cases [9]. Such static analyses have 
applications in a broader security context (e.g., [3, 21, 31, 35]); security proto­cols constitute a 
particularly challenging class of examples. To date, however, such static analyses have dealt case by 
case with operations on data, and in particular with cryp­tographic operations. In this paper, we develop 
a general treatment of these operations. In another line of research, security protocols are repre­sented 
as logic programs, in classical or linear logic, and they are analyzed symbolically with general provers 
[15, 36] or with special-purpose algorithms and tools [8, 12, 14] (see also [24] for some of the roots 
of this approach). Super.­cially, these algorithms and tools are quite di.erent from typing and control-.ow 
analysis. However, in this paper we show that one of these tools can be viewed as an implemen­tation 
of a type system. More speci.cally, we develop a generic type system for a process calculus that extends 
the pi calculus [29] with constructor operations and corresponding destructor oper­ations. These operations 
may be, for instance, tupling and projection, symmetric (shared-key) encryption and decryp­tion, asymmetric 
(public-key) encryption and decryption, digital signatures and signature checking, and one-way hash­ing 
(with no corresponding destructor). As in the applied pi calculus [5], these operations are not hardwired. 
The ap­plied pi calculus is even more general in that it does not require the classi.cation of operations 
into constructors and destructors; we suspect that it might be treated along sim­ilar lines but with 
more di.culty (see section 2). Our type system for the process calculus gives secrecy information. The 
basic soundness theorem for the type system, which we prove only once (rather than once per choice of 
operations), states that well-typed processes do not reveal their secrets. We compare this generic type 
system with an automatic protocol checker. The checker takes as input a process and translates it into 
an abstract representation by logic­programming rules. This representation and its manipula­tion, but 
not the translation of processes, come from previ­ous work [8], which develops an e.cient tool for establishing 
secrecy properties of protocols. We show that establishing a secrecy property of a protocol with this 
checker corresponds to typing the protocol in a particular instance of the generic type system. This 
result implies a soundness property for the checker. Conversely, as a completeness property, we es­tablish 
that the checker corresponds to the best instance of our generic type system: if a secrecy property can 
be es­tablished using any instance of the type system, then it can also be established by the checker. 
The next section presents our process calculus, without types. Section 3 gives a (fairly standard) de.nition 
of se­crecy. Section 4 presents our type system, and section 5 gives the main soundness theorems for 
the type system and related results. As an example, section 6 explains how the type system applies to 
shared-key and public-key encryp­tion operations. Section 7 formalizes and studies the logic­programming 
protocol checker. Section 8 concludes.  2. THE PROCESS CALCULUS (UNTYPED) This section introduces our 
process calculus, by giving its syntax and its operational semantics. 2.1 Syntax and Informal Semantics 
The syntax of our calculus is summarized in Figure 1. It distinguishes a category of terms (data) and 
one of processes (programs). It assumes an in.nite set of names and an in.­nite set of variables; a, 
b, c, k, s, and similar identi.ers range over names, and x, y, and z range over variables. It also as­sumes 
a set of symbols for constructors and destructors; we often use f for a constructor and g for a destructor. 
Constructors are used to build terms. Therefore, the terms are variables, names, and constructor applications 
of the form f(M1,...,Mn). On the other hand, destructors do not appear in terms, but only manipulate 
terms in pro­cesses. They are partial functions on terms that processes can apply. The process let x 
= g(M1,...,Mn) in P else Q tries to evaluate g(M1,...,Mn); if this succeeds, then x is bound to the result 
and P is executed, else Q is exe­cuted. More precisely, the semantics of a destructor g of arity n is 
given by a partial function from n-tuples of terms to terms, such that g(sM1,...,sMn)= sg(M1,...,Mn) 
if g(M1,...,Mn) is de.ned and s is a substitution that maps names and variables to terms. We may isolate 
a min­imal set def(g) of equations g(M1',...,M')= M' that de­ n .ne g, where M1',...,M',M' are terms 
without free names. n Then g(M1,...,Mn) is de.ned if and only if there exists a substitution s and an 
equation g(M1',...,M')= M' in n def(g) such that Mi = sM'for all i .{1,...,n}, and i g(M1,...,Mn)= sM'. 
This set of equations may be in.­nite, but it is usually .nite and small in concrete examples. Using 
these constructors and destructors, we can repre­sent data structures, such as tuples, and cryptographic 
op­erations, for instance as follows: ntuple(M1,...,Mn) is the tuple of the terms M1,..., Mn, where ntuple 
is a constructor. (We sometimes ab­breviate ntuple(M1,...,Mn)to(M1,...,Mn).) The n projections are destructors 
ithn for i.{1,...,n}, de­.ned by ithn(ntuple(M1,...,Mn)) = Mi sencrypt(M,N) is the symmetric (shared-key) 
encryp­tion of the message M under the key N, where sencrypt is a constructor. The corresponding destruc­tor 
sdecrypt is de.ned by sdecrypt(sencrypt(M,N),N)= M Thus, sdecrypt(M',N) returns the decryption of M' 
if M' is a message encrypted under N. In order to represent asymmetric (public-key) encryp­tion, we may 
use two constructors pk and pencrypt: pk(M) builds a public key from a secret M and pencrypt(M,N) encrypts 
M under N. The corre­sponding destructor pdecrypt is de.ned by pdecrypt(pencrypt(M,pk(N)),N)= M As for 
digital signatures, we may use a constructor sign, and write sign(M,N) for M signed with the sig­nature 
key N, and the two destructors checksignature and getmessage with the equations: checksignature(sign(M,N),pk(N)) 
= M getmessage(sign(M,N)) = M We may represent a one-way hash function by the con­structor H. There is 
no corresponding destructor; so we model that the term M cannot be retrieved from its hash H(M). Thus, 
the process calculus supports many of the operations common in security protocols. It has limitations, 
though: for example, XOR is neither a constructor nor a destructor. The other constructs in the syntax 
of Figure 1 are stan­dard; most of them come from the pi calculus. The input process M(x).P inputs a 
message on channel M, and exe­cutes P with x bound to the input message. The output process M(N).P outputs 
the message N on the channel M and then executes P. Here, we use an arbitrary term M to represent a channel: 
M can be a name, a variable, or a constructed term, but the process blocks if M does not re­duce to a 
name at runtime. Our calculus is monadic (in that the messages are terms rather than tuples of terms), 
but a polyadic calculus can be simulated since tuples are terms. It is also synchronous (in that a process 
P is executed after the output of a message). The nil process 0 does nothing. The process P |Q is the 
parallel composition of P and Q. The replication !P represents an unbounded number of copies of P in 
parallel. The restriction (.a)P creates a new name a, and then executes P. The local de.nition let x 
= M in P executes P with x bound to the term M. The conditional if M = N then P else Q executes P if 
M and N reduce to the same term at runtime; otherwise, it executes Q.As usual, we may omit an else clause 
when it consists of 0. The name a is bound in the process (.a)P. The vari­able x is bound in P in the 
processes M(x).P, let x = g(M1,...,Mn) in P else Q, and let x = M in P.We write fn(P) and fv(P) for the 
sets of names and variables free in P, respectively. A process is closed if it has no free M, N ::= x, 
y, z a, b, c, k, s f(M1,...,Mn) P, Q ::= M(N).P M(x).P 0 P | Q !P (.a)P let x = g(M1,...,Mn) in P else 
Q let x = M in P if M = N then P else Q terms variable name constructor application processes output 
input nil parallel composition replication restriction destructor application local de.nition conditional 
 Figure 1: Syntax of the process calculus variables; it may have free names. We identify processes up 
to renaming of bound names and variables. We write {M1/x1,...,Mn/xn} for the substitution that replaces 
x1, ..., xn with M1,..., Mn, respectively. As an example, we may express the following protocol: Message 
1. A . B : pencrypt((k, pKA),pKB) Message 2. B . A : pencrypt((k, KAB ),pKA) Message 3. A . B : sencrypt(s, 
KAB ) This protocol establishes a session key KAB between two parties A and B, then uses the key to transmit 
a secret s from A to B. It relies on public keys pKA for A and pKB for B. First, A creates a challenge 
k (a nonce), sends it to B paired with A s public key, encrypted under B s public key. Then B replies 
with the same nonce and the session key KAB, encrypted under A s public key. When A receives this message, 
it recognizes k; it is then con.dent that the key KAB has been created by B. Finally, A sends the secret 
s under KAB . The following processes represent the protocol: . P =(.sKA)(.sKB)let pKA = pk(sKA) in let 
pKB = pk(sKB) in e(pKA).e(pKB).(A | B) . A =(.k)e(pencrypt((k, pKA),pKB)). e(z).let (x, y)= pdecrypt(z, 
sKA) in if x = k then e(sencrypt(s, y)) . B = e(z).let (x, y)= pdecrypt(z, sKB ) in (.KAB )e(pencrypt((x, 
KAB ),y)). '' ' e(z ).let s = sdecrypt(z ,KAB ) in 0 (This code corresponds to a simple, one-shot version 
of the protocol; it is easy to extend it to represent more elaborate versions.) Here we write let (x, 
y)= M in Q instead of let z = M in let x =1th2(z) in let y =2th2(z) in Q, using pattern-matching on tuples. 
The keys sKA and sKB are the decryption keys that match pKA and pKB, respectively, and e is a public 
channel. The messages e(pKA) and e(pKB ), which publish pKA and pKB on e, model the fact that these keys 
are public. We return to this example in section 6.  2.2 Formal Semantics The rules of Figure 2 axiomatize 
the reduction relation . for processes, thus de.ning the operational semantics of our calculus. Auxiliary 
rules axiomatize the structural con­gruence relation =; this relation is useful for transforming processes 
so that the reduction rules can be applied. Both = and . are de.ned only on closed processes. We write 
. * the re.exive and transitive closure of ..As in [4], we say that the process P outputs M immediately 
on c if and only if P = c(M).Q | R for some processes Q and R. We say that the process P outputs M on 
c if and only . * if PQ and Q outputs M immediately on c for some process Q. 2.3 Discussion As mentioned 
in the introduction, our calculus resembles the applied pi calculus [5]. Both calculi are extensions 
of the pi calculus with (fairly arbitrary) functions on terms. However, there are also important di.erences 
between these calculi. The .rst one is that we use destructors instead of the equational theories of 
the applied pi calculus. The second di.erence is that our calculus has a built-in error-handling construct 
(the else clause of the destructor application), whereas in the applied pi calculus the error-handling 
must be done by hand . This error-handling construct makes typing easier.  3. A DEFINITION OF SECRECY 
Throughout this paper, we use the following informal def­inition of secrecy: a protocol P preserves the 
secrecy of data M if P never publishes M, or anything that would permit the computation of M, even in 
interaction with an adver­sary Q. Equivalently, a protocol P preserves the secrecy of data M if P in 
parallel with an adversary Q will never output M on a public channel. De.nitions along these lines are 
quite common in protocol analysis. (There are how­ever alternatives, in particular some based on the 
concept of noninterference; see [2] for discussion.) Next we give a formal counterpart for this informal 
de.­nition, in the context of our process calculus and relying on the operational semantics of section 
2. We represent the ad­versary Q as a process of the calculus, with some hypotheses that characterize 
Q s initial capabilities. We formulate these hypotheses simply by using a set of names S. Intuitively, 
Q knows the names in S initially; and Q may acquire some additional capabilities not represented in S 
in the course of P |0 =P P |Q=Q|P (P |Q) |R =P |(Q|R) !P =P |!P (.a1)(.a2)P =(.a2)(.a1)P if a1= a2 (.a)(P 
|Q) =P |(.a)Q if a/.fn(P) a(M).Q|a(x).P .Q|P{M/x} let x= g(M1,...,Mn) in P else Q.if g(M1,...,Mn)= M 
' let x= g(M1,...,Mn) in P else Q.Q if g(M1,...,Mn) is not de.ned let x= M in P .P{M/x} if M = M then 
P else Q .P if M = N then P else Q .Q if M = N P .Q .P |R .Q|R P .Q .(.a)P .(.a)Q P ' '' =P, P .Q, Q=Q 
.P ' .Q P =Q .P |R=Q|R P =Q .!P =!Q P =Q .(.a)P =(.a)Q P =P Q=P .P =Q P =Q, Q=R .P =R (Red I/O) P{M ' 
/x} (Red Destr 1) (Red Destr 2) (Red Let) (Red Cond 1) (Red Cond 2) (Red Par) (Red Res) (Red =) Figure 
2: Structural congruence and reduction computation, by creating fresh names and receiving terms in messages. 
In order to represent that Qmay initially know complex terms rather than just names, we may let P begin 
with the output of these terms on a public channel c .S, so the restriction that S is a set of names 
entails no loss of generality. De.nition 1. Let S be a .nite set of names. The closed process Q is a 
S-adversary if and only if fn(Q) .S. The closed process P preserves the secrecy of M from S if and only 
if P |Q does not output M on c for any S-adversary Q and any c.S. If P preserves the secrecy of M from 
S, then it clearly can­not output M on some c .S, that is, on one of the channels known to the adversary. 
This guarantee corresponds to the informal requirement that P never publishes M on its own. Moreover, 
P cannot publish data that would enable an ad­versary to compute M, because the adversary could go on 
to output M on some c.S.  4. THE TYPE SYSTEM This section presents a general type system for our pro­cess 
calculus; the following sections include instances of this general type system. Figure 3 gives the rules 
of the type system. In the rules, the metavariable u ranges over names and variables, and T over types. 
The rules concern three judgments: E f0means that E is a well-formed typing environ­ment.  E fM : T 
means that M is a term of type T in the environment E.  E fP says that the process P is well-typed in 
the environment E.  The type system is parameterized by a set of types Types and a non-empty subset 
TPublic .Types. These parameters will be .xed in each instance of the type system. Always, TPublic is 
the set of types of data that can be known by the attacker. The type system relies on a function conveys 
: Types . P(Types) such that: (P0) If T .TPublic, then conveys(T)= TPublic. Intuitively, conveys(T) is 
the set of types of data that are conveyed by a channel of type T. (It is empty when ele­ments of T cannot 
be used as channels.) Data conveyed by a public channel is public, since the adversary can obtain it 
by listening on the channel. Conversely, public data can appear on a public channel, since the adversary 
can send it. The type system also relies on a partial function from types to types Of : Typesn .Types 
for each constructor f of arity n, and a function from types to sets of types Og : Typesn .P(Types) for 
each destructor g of arity n. These operators Of and Og give the types of constructor and destructor 
applications. These applications need not have unique or most general types (but terms do have unique 
types in a given environment). Constructors and destructors can accept arguments of di.erent types, and 
return results whose types depend on the types of the arguments. In this sense, we may say that they 
are overloaded functions; this overloading subsumes some forms of subtyping and para­metric polymorphism. 
We require the following properties: (P1) If for all i .{1,...,n}, Ti .TPublic, then Of (T1, ...,Tn) 
is de.ned and Of (T1,...,Tn) .TPublic. (P2) If for all i .{1,...,n}, Ti . TPublic and T . Og(T1,...,Tn), 
then T .TPublic. (P3) For each equation g(M1,...,Mn)= M in def(g), if for all i .{1,...,n},E fMi : Ti, 
then there exists T .Og(T1,...,Tn) such that E fM : T. Well-formed environments: (Env Ø) Øf0 E f0 u/.dom(E) 
 (Env atom) E,u: T f0 Terms: E f0 (u: T) .E (Atom) E fu: T E f0 .i.{1,...,n},E fMi : Ti Of (T1,...,Tn) 
is de.ned (Constructor application) E ff(M1,...,Mn): Of (T1,...,Tn) Processes: E fM : TE fN : T ' T 
' .conveys(T) E fP (Output) E fM(N).P E fM : T .T ' .conveys(T),E,x: T ' fP (Input) E fM(x).P E f0 
 (Nil) E f0 E fPE fQ (Parallel) E fP |Q E fP (Replication) E f!P E,a: T fP (Restriction) E f(.a)P 
.i.{1,...,n},E fMi : Ti .T .Og(T1,...,Tn),E,x: T fPE fQ (Destructor application) E flet x= g(M1,...,Mn) 
in P else Q E fM : T E,x: T fP (Local de.nition) E flet x= M in P E fM : TE fN : T ' if T = T ' then 
E fPE fQ (Cond) E fif M = N then P else Q Figure 3: Type rules The .rst two properties re.ect that 
the result of applying a function to public terms should also be public, since the adversary can compute 
it. The third property essentially says that the de.nition of Og on types is compatible with the de.nition 
of g on terms. The type rules for nil, parallel composition, replication, re­striction, and local de.nition 
are standard. We use a Curry­style typing for restriction, so we do not mention a type of a explicitly 
in the construct (.a). (That is, we do not write (.a : T) for some T.) This style of typing gives rise 
to a form of polymorphism: the type of a can change according to the environment. By the rule (Output), 
the process M(N).P is well-typed only if data of the type T ' of N can be conveyed on a channel of the 
type T of M, that is, T ' . conveys(T). Conversely, for typechecking the process M(x).P via the rule 
(Input), the variable x is considered with all types T ' . conveys(T) where T is the type of M. The universal 
quanti.cation on the type of x is unusual; it arises because a channel may convey data of several types. 
In security protocols, this .ex­ibility is important because a channel may convey data from the adversary 
and from honest participants, and types can help distinguish these two cases. The rule (Constructor application) 
types f(M1,...,Mn) according to the corresponding operator Of . The rule (Destructor application) is 
similar to (Input); in let x = g(M1,...,Mn) in P else Q, the variable xis considered with all the possible 
types of g(M1,...,Mn), that is, all elements of Og(T1,...,Tn). Rule (Cond) exploits the property that 
if two terms M and N have di.erent types then they are certainly di.erent. In this case, if M = N then 
P else Q may be well-typed without P being well-typed. The constructs if M = N then P else Q and let 
x = M in P can be de.ned as special cases from let x = g(M1,...,Mn) in P else Q, and their typing follows: 
 Let equals be a binary destructor with equals(M,M)= M (and with equals(M,N) unde.ned otherwise), Oequals 
(T,T)= {T}, and Oequals (T,T ' )= Ø if T =. T ' Then if M = N then P else Q can be de.ned and typed 
as let x = equals(M,N) in P else Q, where x/. fv(P).  Let id be a unary destructor with id(M)= M and 
Oid (T)= {T}. Then let x = M in P can be de.ned and typed as let x= id(M) in P else 0.  Because of these 
encodings, we may omit the cases of if M = N then P else Q and let x= M in P in various arguments and 
proofs. The encodings also suggest that the typing rule (Cond) for if M = N then P else Q is more natural 
than might seem at .rst sight.  5. PROPERTIES OF THE TYPE SYSTEM The subject-reduction lemma says that 
typing is preserved by computation. Lemma 1 (Subject reduction) If E f P and P . Q then E f Q. The secrecy 
theorem says that if a closed process P is well­typed in an environment E, and a name s is not of a type 
in TPublic according to E, then P preserves the secrecy of sfrom S, where S is the set of names that 
are of a type in TPublic according to E. In other words, P preserves the secrecy of names whose type 
is not in TPublic against adversaries that can output, input, and compute on names of types in TPublic. 
Theorem 1 (Secrecy) Let P be a closed process. Suppose that E f P, E f s: T ' , and T ' ./TPublic. Let 
S = {a | E f a: T and T . TPublic}. Then P preserves the secrecy of s from S. This secrecy theorem is 
a consequence of the subject­reduction lemma and the typability of the adversary (i.e., that any S-adversary 
Q can be typed with all names and variables of a type in TPublic).  6. A SIMPLE INSTANCE OF THE TYPE 
SYSTEM As an example, we show how the type system applies to symmetric and asymmetric encryption. The 
resulting in­stance of the type system is similar in scope and power to a previous special-purpose type 
system [4], but treats ad­ditional constructs and could easily treat even more. For this instance, the 
grammar of types is given in Figure 4. Informally, types have the following meanings: Public is the 
type of public data.  Secret is the type of secret data.  T1 × ...× Tn is the type of tuples, whose 
components are of types T1,...,Tn.  C[T] is the type of a channel that can convey data of type T and 
that cannot be known by the adversary. (Channels that can be known by the adversary are of type Public.) 
 KSecret[T] is the type of symmetric keys that can be used to encrypt data of type T and that cannot 
be known by the adversary. (Symmetric keys that can be known by the adversary are of type Public.)  
EKSecret [T] is the type of secret asymmetric encryption keys that can be used to encrypt cleartexts 
of type T. DKSecret[T] is the type of asymmetric decryption keys for cleartexts of type T and such that 
the correspond­ing encryption keys are secret. These decryption keys are also secret.  EKPublic[T] is 
the type of public asymmetric encryp­tion keys that can be used to encrypt cleartexts of type T. The 
adversary can use these keys to encrypt its messages, so public messages can also be encrypted under 
these keys.  DKPublic [T] is the type of asymmetric decryption keys for cleartexts of type T and such 
that the correspond­ing encryption keys are public. These decryption keys are however secret. When decrypting 
a message with such a key, the result can be of type T (in normal use of the key) or of type Public (when 
the adversary has used the corresponding encryption key to encrypt one of its messages). T ::= types 
Public public data Secret secret data T1 ×...×Tn tuple C[T] secret channel KSecret[T] secret shared 
key DKSecret[T] decryption key whose corresponding encryption key is secret EKSecret[T] secret encryption 
key DKPublic [T] decryption key whose corresponding encryption key is public EKPublic [T] public encryption 
key Figure 4: Grammar of types in an instance of the type system TPublic = {T |T =Public}Public = {Public,EK[T]}.{T1 
×...×Tn |.i.{1,...,n},Ti .TPublic} If T =Public, then conveys(T)= TPublic; conveys(C[T]) = {T ' |T ' 
=T}. Ontuple (T1,...,Tn)= T1 ×...×Tn. If T1 =Public and T2 =Public, then Osencrypt (T1,T2) = Public; 
 '' Secret if T =T, then Osencrypt (T,K[T]) = Public. If T1 =Public and T2 =Public, then Opencrypt (T1,T2) 
= Public; '' L if T =T, then Opencrypt (T,EK[T]) = Public. If T1 =Public, then Opk (T1) = Public; Opk 
(DKL[T]) = EKL[T]. Oithn (T1 ×...×Tn)= {Ti}. If T =Public, then Osdecrypt (Public,T)= TPublic; Secret'' 
 Osdecrypt (Public,K[T]) = {T |T =T}. If T =Public, then Opdecrypt (Public,T)= TPublic; Secret'' Opdecrypt 
(Public,DK[T]) = {T |T =T}; Public'' Opdecrypt (Public,DK[T]) = {T |T =T}.TPublic. Other cases: conveys(T)= 
Ø, Of (T1,...,Tn) is not de.ned, and Og(T1,...,Tn)= Ø. Figure 5: De.nition of TPublic and type operators 
in an instance of the type system We de.ne TPublic and the type operators of the system in Figure 5. 
For this purpose, we let the subtyping relation = be re.exive and transitive, with SecretSecret C[T] 
=Secret,K[T] =Secret,DK[T] =Secret, SecretPublic EK[T] =Secret,DK[T] =Secret, Public EK[T] =Public,Public 
×...×Public =Public, if .i .{1,...,n},Ti = Secret then T1 ×...×Tn =Secret, '' '' if T1 =T1,...,Tn =Tn 
then T1 ×...×Tn =T1 ×...×Tn. (We do not adopt a subsumption rule.) Importantly, these de.nitions allow 
encryption under a public key of type EKPublic [T] to accept data both of type Public and of type T. 
For the corresponding decryption, we handle both cases: Opdecrypt (Public,DKPublic[T]) includes both 
subtypes of T and subtypes of Public. (A similar idea appears in the special-purpose type system mentioned 
above [4].) Proposition 1 These de.nitions satisfy the constraints of the general type system (P0, P1, 
P2, P3). For example, the type system can be used to prove that s remains secret in the example protocol 
of section 2. For this . proof, we de.ne E = s: Secret,e: Public, and derive E fP. In the (Restriction) 
rule, we choose the types . PublicSecret TsKB =DK[Secret ×EK[Secret ×K[Secret]]] TsKA =DK [Secret ×K 
[Secret]] for sKA and . Public Public Secret for sKB. Then pk(sKA) has the type . )=EKPublic TpKA = 
Opk (TsKA [Secret ×KSecret[Secret]] and pk(sKB ) has the type . TpKB = Opk (TsKB ) PublicPublicSecret 
=EK[Secret ×EK[Secret ×K[Secret]]] The remainder of the process is typed in the environment: ' . PublicSecret 
E = E,sKA :DK[Secret ×K[Secret]], PublicPublicSecret sKB :DK[Secret ×EK[Secret ×K[Secret]]], PublicSecret 
pKA :EK[Secret ×K[Secret]], PublicPublicSecret pKB :EK[Secret ×EK[Secret ×K[Secret]]] We check that TpKA 
. conveys(Public) and TpKB . conveys(Public) (since these types are subtypes of Public). Then we only 
have to show that E ' fA and E ' fB. In the typing of A, we choose k of type Secret. Then E ' ,k: Secret 
fpencrypt((k,pKA),pKB ) : Public follows by (Constructor application), hence the output e(pencrypt((k,pKA),pKB)) 
is well-typed by (Output). In the input e(z), by (Input), z can be of any subtype of Public, then by 
(Destructor application), we have to prove E ' ,k: Secret,x: Tx,y: Ty fif x = k then e(sencrypt(s,y)), 
= KSecret where either Tx = Secret and Ty [Secret] or Tx =Public and Ty =Public. In the .rst case, the 
conditional is well-typed, since the output is well-typed. In the second case, the conditional is well-typed, 
since x and k cannot have the same type. We leave to the reader the veri.cation that B is well-typed. 
Finally, by Theorem 1, P preserves the secrecy of s from {e}.  7. PROTOCOL CHECKER In this section we 
give a precise de.nition of a proto­col checker based on untyped logic programs, then study its properties, 
in particular proving its equivalence to the type system. This equivalence is considerably less routine 
and predictable than properties such as subject reduction (Lemma 1). 7.1 De.nition of the Protocol Checker 
Given a closed process P0 and a set of names S, the proto­col checker builds a set of rules, in the form 
of Horn clauses. We assume that each restriction (.a)P in P0 has a di.erent name a, and that this name 
is di.erent from any free name of P0. The rules use two predicates: attacker and message. The fact attacker(p) 
means that the attacker may have p, and the fact message(p,p ' ) means that the message p ' may appear 
on channel p. F ::= facts attacker(p) attacker knowledge message(p,p ' ) channel messages Here pand p 
' range over patterns (or terms , but we prefer the word patterns in order to avoid confusion), which 
are generated by the following grammar: p::= patterns x,y,z variable a[p1,...,pn] name f(p1,...,pn) constructor 
application For each name ain P0 we have a corresponding pattern con­struct a[p1,...,pn]. We treat a 
as a function symbol, and write a[p1,...,pn] rather than a(p1,...,pn) only for clarity. If a is a free 
name, then the arity of this function is 0. If a is bound by a restriction (.a)P in P0, then this arity 
is the number of input statements above the restriction (.a)P in the abstract syntax tree of P0. Thus, 
in the checker, a new name behaves as a function of the inputs that take place (lexically) before its 
creation. Therefore, we distinguish names only when they are created after receiving di.erent inputs. 
In contrast, a restriction in a process always gener­ates fresh names; hence the rules will not exactly 
re.ect the operational semantics of processes, but this approximation is useful for automation and harmless 
in most examples. As we show below, this approximation is also compatible with soundness and completeness 
theorems that prove the equiv­alence between the type system and the logic-programming system. The rules 
comprise rules for the attacker and rules for the protocol. Next we de.ne these two kinds. 7.1.1 Rules 
for the attacker Initially, the attacker has all the names in a set S, hence the rules attacker(a[]) 
for each a.S. Moreover, the abilities of the attacker are represented by the following rules: For each 
constructor f of arity n, attacker(x1) .....attacker(xn) (Rf) .attacker(f(x1,...,xn)) For each destructor 
g, for each equation g(M1,...,Mn)= M in def(g), (Rg) attacker(M1) .....attacker(Mn) .attacker(M) message(x,y) 
.attacker(x) .attacker(y) (Rl) attacker(x) .attacker(y) .message(x,y) (Rs) The rules (Rf) and (Rg) mean 
that the attacker can apply all operations to all terms it has, (Rf) for constructors, (Rg) for destructors. 
The set of these rules is .nite if the set of constructors and each of the sets def(g) is .nite; handling 
this set is easiest in this .nite case. For (Rg), notice that equations in def(g) do not have free names 
and that terms without free names are also patterns, so the rules have the required format. Rule (Rl) 
means that the attacker can listen on all the channels it has, and (Rs) that it can send all the messages 
it has on all the channels it has. 7.1.2 Rules for the protocol When a function . associates a pattern 
with each name and variable, and f is a constructor, we extend . as a sub­stitution by .(f(M1,...,Mn)) 
= f(.(M1),...,.(Mn)). The translation [ P]].h of a process P is a set of rules, where . is a function 
which associates a pattern with each name and variable, and h is a sequence of facts of the form message(p,p 
' ). The empty sequence is denoted by Ø; the concatenation of a fact F to the sequence h is denoted by 
h.F. [[0]].h = Ø,  [[P |Q]].h=[[P]].h.[[Q]].h,  [[!P]].h=[[P]].h,  [[(.a)P]].h =[[P]](.[a .. a[p 
' 1,...,p ' ]])h if h =  n message(p1,p1' ) .....message(pn,p ' ), n [[M(x).P]].h =[[P]](.[x. .x])(h.message(.(M),x)), 
 [[M(N).P]].h =[[P]].h.{h.message(.(M),.(N))},  [[let x= g(M1,...,Mn) in P else Q]].h =  ' ' ''' .{[[P]]((s.)[x 
.p 1,...,pnp . s ])(sh) | g(p )= is in def(g) and (s,s ' ) is a most general pair of sub­stitutions such 
that s.(M1)= s ' p ' 1,...,s.(Mn)= s ' p ' }.[[Q]].h. n Thus, the translation of a process is, very roughly, 
a set of rules that enable us to prove that it sends certain mes­sages. The sequence h keeps track of 
messages received by the process, since these may trigger other messages. The translation of 0 is the 
empty set, because this process does nothing. The translation of a parallel composition P | Q is the 
union of the translations of P and Q, because P |Q sends the messages of P and Q plus any messages that 
re­sult from the interaction of P and Q. Replication is ignored, because the target logic is classical, 
so all logical rules are applicable arbitrarily many times. For restriction, we re­place the restricted 
name a in question with a pattern a[...] that depends on the messages received, as recorded in the sequence 
h. This sequence is extended in the translation of an input, with the input in question. On the other 
hand, the translation of an output adds a clause; this clause rep­resents that reception of the messages 
in h can trigger the output in question. Finally, the translation of a destructor application takes the 
union of the clauses for the case where the destructor succeeds (with an appropriate substitution) and 
those for the case where the destructor fails; thus we avoid having to determine whether it will succeed 
or fail. 7.1.3 Summary and secrecy results Let . = {a ..a[] | a .fn(P0)}. We de.ne the rule base corresponding 
to process P0 as: BP0,S =[[P0]].Ø.{attacker(a[]) |a .S} .{(Rf),(Rg),(Rl),(Rs)} We have the following 
secrecy result. Let s . fn(P0). If attacker(s[]) cannot be derived from BP0,S , then P0 pre­serves the 
secrecy of s from S. This result is the basis for a method for proving secrecy properties. Of course, 
whether a fact can be derived from BP0,S may be undecidable, but in practice there exist algorithms that 
terminate on numerous examples of protocols. In particular, we can use variants of resolution algorithms, 
such as the algorithm described in [8]. This result can be proved directly. Instead, we establish it 
by showing that we can build a typing of P0 in a suitable instance of our general type system; the result 
then follows from Theorem 1. We also establish a completeness theorem, as a converse: the checker yields 
the best instance of our general type system.  7.2 Correctness We use the rule base BP0,S to de.ne an 
instance of our general type system, as follows. The grammar of types is T ::= types a[T1,...,Tn] name 
f(T1,...,Tn) constructor application The types are exactly closed patterns. TPublic = {T | attacker(T) 
is derivable from BP0,S }(that is, the protocol checker says that the attacker may have T).  conveys(T)= 
{T ' | message(T,T ' ) is derivable from BP0,S } (that is, the protocol checker says that the channel 
T may convey T ' ).  Of (T1,...,Tn)= f(T1,...,Tn).  Og(T1,...,Tn)= {sM | there exists an equation g(M1,...,Mn)= 
M in def(g), s maps variables to types, and .i.{1,...,n},sMi = Ti}.  We can show that the type system 
as de.ned above satis.es the constraints (P0, P1, P2, P3) of the general type system, and that E fP0, 
where E = {a: a[] |a .fn(P0)}. The se­crecy theorem for the protocol checker then follows from the secrecy 
theorem for the general type system (Theorem 1): Theorem 2 (Secrecy) Let P0 be a closed process and s 
. fn(P0).If attacker(s[]) cannot be derived from BP0,S , then P0 preserves the secrecy of s from S. 
7.3 Completeness The protocol checker is incomplete in the sense that it fails to prove some true properties. 
However, as the next theorem states, the protocol checker is relatively complete: it is as complete as 
the type system of section 4. Theorem 3 (Completeness) Let P0 be a closed process, s a name, and S a 
set of names. Suppose that an instance of the general type system proves (by Theorem 1) that P0 preserves 
the secrecy of s from S. Then attacker(s[]) cannot be derived from BP0,S , so the protocol checker also 
proves that P0 preserves the secrecy of s from S. This theorem is proved by establishing a correspondence 
be­tween types T of an instance of the general type system and types Tc of the checker (of section 7.2): 
we de.ne a par­tial function f that maps Tc to T. (The appendix gives the de.nition of f.) Then we prove 
that all rules of BP0,S are satis.ed, in the following sense: The closed fact attacker(Tc) is satis.ed 
if f(Tc) . TPublic.  The closed fact message(Tc,T ' c) is satis.ed if f(T ' c) . conveys(f(Tc)).  The 
rule F1 . .... Fn . F is satis.ed if sF is sat­is.ed for every closed substitution s such that .i . {1,...,n},sFi 
is satis.ed.  Therefore, all facts derived from BP0,S are satis.ed. More­over, if s is proved secret 
by the instance of the general type system, then attacker(s[]) is not satis.ed. (If attacker(s[]) were 
satis.ed, we would also have that f(s[]) . TPublic,so the instance of the general type system would not 
be able to prove the secrecy of s.) Hence, attacker(s[]) cannot be derived from BP0,S . The result follows. 
This completeness result shows the power of the proto­col checker. This power is not only theoretical: 
it has been demonstrated in practice on several examples [8], from sim­ple protocols like variants of 
the Needham-Schroeder proto­cols [32] to Skeme [25]. The completeness result does not however mean that 
the protocol checker constitutes the only useful instance of the general type system. In particular, 
simpler instances are eas­ier to use in manual reasoning. Presenting those instances by type rules (rather 
than logic programs) is often quite con­venient. Moreover, the checker does not always terminate, in 
particular when it tries to establish properties of an in.­nite family of types; in other instances of 
the type system, we may merge those types (obtaining some .nite proofs at the cost of completeness). 
Similarly, the (rare) case where a set def(g) is large or in.nite is more problematic for the checker 
than for the general type system. Finally, the gen­eral type system may be combined with other type-based 
analyses for proving protocol properties other than secrecy (e.g., as in [20]).  8. CONCLUSION This 
paper makes two main contributions: (1) a type system for expressing and proving secrecy prop­erties 
of security protocols with a generic treatment of many cryptographic operations; (2) a tight relation 
between two useful but super.cially quite di.erent approaches to protocol analysis, respec­tively embodied 
in the type system and in a logic­programming tool. The .rst contribution can be seen as the continuation 
of a line of work on static analyses for security, discussed in the introduction. So far, those static 
analyses have been devel­oped successfully but often in ad hoc ways. We believe that type systems such 
as ours not only are useful in examples but also shed light on the constraints and the design space for 
static analyses. In the last few years, there has been a vigorous prolif­eration of frameworks and techniques 
for reasoning about security protocols. Their relations are seldom explicit or obvious. Moreover, little 
is known about how to combine techniques. The second contribution is part of a broader e.ort to understand 
those relations. Previous work (in par­ticular [18]) suggests connections between (untyped) process calculi 
and logic-programming notations for protocols; we go further by relating proof methods in those two worlds. 
Such connections are perhaps the start of a healthy consolidation. 9. REFERENCES <RefA>[1] M. Abadi. Secrecy 
by typing in security protocols. Journal of the ACM, 46(5):749 786, Sept. 1999. [2] M. Abadi. Security 
protocols and their properties. In F. Bauer and R. Steinbrueggen, editors, Foundations of Secure Computation, 
NATO Science Series, pages 39 60. IOS Press, 2000. Volume for the 20th International Summer School on 
Foundations of Secure Computation, held in Marktoberdorf, Germany (1999).  [3] M. Abadi, A. Banerjee, 
N. Heintze, and J. G. Riecke. A core calculus of dependency. In Proceedings of the 26th ACM Symposium 
on Principles of Programming Languages, pages 147 160, Jan. 1999. [4] M. Abadi and B. Blanchet. Secrecy 
types for asymmetric communication. In F. Honsell and M. Miculan, editors, Foundations of Software Science 
and Computation Structures (FoSSaCS 2001), volume 2030 of Lecture Notes in Computer Science, pages 25 
41. Springer-Verlag, Apr. 2001. [5] M. Abadi and C. Fournet. Mobile values, new names, and secure communication. 
In Proceedings of the 28th Annual ACM Symposium on Principles of Programming Languages (POPL 01), pages 
104 115, Jan. 2001. [6] M. Abadi and A. D. Gordon. A calculus for cryptographic protocols: The spi calculus. 
Information and Computation, 148(1):1 70, Jan. 1999. An extended version appeared as Digital Equipment 
Corporation Systems Research Center report No. 149, January 1998. [7] R. M. Amadio and D. Lugiez. On 
the reachability problem in cryptographic protocols. In C. Palamidessi, editor, CONCUR 2000: Concurrency 
Theory (11th International Conference), volume 1877 of Lecture Notes in Computer Science, pages 380 394. 
Springer-Verlag, Aug. 2000. [8] B. Blanchet. An e.cient cryptographic protocol veri.er based on Prolog 
rules. In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 82 96, June 2001. [9] C. 
Bodei. Security Issues in Process Calculi. PhD thesis, Universit`a di Pisa, Jan. 2000. [10] C. Bodei, 
P. Degano, F. Nielson, and H. Nielson. Control .ow analysis for the p-calculus. In CONCUR 98: Concurrency 
Theory, volume 1466 of Lecture Notes in Computer Science, pages 84 98. Springer Verlag, Sept. 1998. [11] 
L. Cardelli, G. Ghelli, and A. D. Gordon. Secrecy and group creation. In C. Palamidessi, editor, CONCUR 
2000: Concurrency Theory, volume 1877 of Lecture Notes in Computer Science, pages 365 379. Springer-Verlag, 
Aug. 2000. [12] I. Cervesato, N. A. Durgin, P. D. Lincoln, J. C. Mitchell, and A. Scedrov. A meta-notation 
for protocol analysis. In Proceedings of the 12th IEEE Computer Security Foundations Workshop (CSFW 99), 
pages 55 69, June 1999. [13] M. Dam. Proving trust in systems of second-order processes. In Proceedings 
of the 31th Hawaii International Conference on System Sciences, volume VII, pages 255 264, 1998. [14] 
M. Debbabi, M. Mejri, N. Tawbi, and I. Yahmadi. A new algorithm for the automatic veri.cation of authentication 
protocols: From speci.cations to .aws and attack scenarios. In Proceedings of the DIMACS Workshop on 
Design and Formal Veri.cation of Security Protocols, Rutgers University, New Jersey, Sept. 1997. [15] 
G. Denker, J. Meseguer, and C. Talcott. Protocol speci.cation and analysis in Maude. In N. Heintze and 
J. Wing, editors, Proc. of Workshop on Formal Methods and Security Protocols, Indianapolis, Indiana, 
25 June 1998. [16] A. Durante, R. Focardi, and R. Gorrieri. CVS: A compiler for the analysis of cryptographic 
protocols. In Proceedings of the 12th IEEE Computer Security Foundations Workshop (CSFW 99), pages 203 
212, June 1999. [17] N. Durgin, J. Mitchell, and D. Pavlovic. A compositional logic for protocol correctness. 
In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 241 255, June 2001. [18] N. A. Durgin 
and J. C. Mitchell. Analysis of security protocols. In M. Broy and R. Steinbruggen, editors, Calculational 
System Design, pages 369 395. IOS Press, 1999. [19] R. Focardi and R. Gorrieri. The compositional security 
checker: A tool for the veri.cation of information .ow security properties. IEEE Transactions on Software 
Engineering, 23(9), Sept. 1997. [20] A. Gordon and A. Je.rey. Authenticity by typing for security protocols. 
In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 145 159, June 2001. [21] N. Heintze 
and J. G. Riecke. The SLam calculus: programming with secrecy and integrity. In Proceedings of the 25th 
ACM Symposium on Principles of Programming Languages, pages 365 377, 1998. [22] M. Hennessy and J. Riely. 
Information .ow vs. resource access in the asynchronous pi-calculus. In Proceedings of the 27th International 
Colloquium on Automata, Languages and Programming, Lecture Notes in Computer Science, pages 415 427. 
Springer-Verlag, 2000. [23] K. Honda, V. Vasconcelos, and N. Yoshida. Secure information .ow as typed 
process behaviour. In G. Smolka, editor, Programming Languages and Systems: Proceedings of the 9th European 
Symposium on Programming (ESOP 2000), volume 1782 of Lecture Notes in Computer Science, pages 180 199. 
Springer-Verlag, 2000. [24] R. Kemmerer, C. Meadows, and J. Millen. Three systems for cryptographic protocol 
analysis. Journal of Cryptology, 7(2):79 130, Spring 1994. [25] H. Krawczyk. SKEME: A versatile secure 
key exchange mechanism for internet. In Proceedings of the Internet Society Symposium on Network and 
Distributed Systems Security, Feb. 1996. Available at http://bilbo.isu.edu/sndss/sndss96.html. [26] P. 
Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. A probabilistic poly-time framework for protocol analysis. 
In Proceedings of the Fifth ACM Conference on Computer and Communications Security, pages 112 121, 1998. 
[27] G. Lowe. Breaking and .xing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms 
for the Construction and Analysis of Systems, volume 1055 of Lecture Notes in Computer Science, pages 
147 166. Springer Verlag, 1996. [28] C. Meadows. Panel on languages for formal speci.cation of security 
protocols. In Proceedings of the 10th IEEE Computer Security Foundations Workshop, page 96, 1997. [29] 
R. Milner. Communicating and Mobile Systems: the Pi-Calculus. Cambridge University Press, June 1999. 
[30] J. H. Morris, Jr. Protection in programming languages. Communications of the ACM, 16(1):15 21, Jan. 
1973. [31] A. C. Myers. JFlow: Practical mostly-static information .ow control. In Proceedings of the 
26th ACM Symposium on Principles of Programming Languages, pages 228 241, Jan. 1999. [32] R. M. Needham 
and M. D. Schroeder. Using encryption for authentication in large networks of computers. Commun. ACM, 
21(12):993 999, Dec. 1978. [33] L. C. Paulson. The inductive approach to verifying cryptographic protocols. 
Journal of Computer Security, 6(1 2):85 128, 1998. [34] E. Sumii and B. C. Pierce. Logical relations 
and encryption (Extended abstract). In 14th IEEE Computer Security Foundations Workshop (CSFW-14), pages 
256 269, June 2001. [35] D. Volpano, C. Irvine, and G. Smith. A sound type system for secure .ow analysis. 
Journal of Computer Security, 4:167 187, 1996. [36] C. Weidenbach. Towards an automatic analysis of security 
protocols in .rst-order logic. In H. Ganzinger, editor, 16th International Conference on Automated Deduction 
(CADE-16), volume 1632 of Lecture Notes in Arti.cial Intelligence, pages 314 328. Springer-Verlag, July 
1999.</RefA> APPENDIX  Function f for the completeness proof This appendix describes the construction of a 
function f on types that plays a role in the completeness proof, as ex­plained in the main body of the 
paper. In order to prove completeness, we consider a closed pro­cess P0, a name s, and a set of names 
S. We consider an instance of the general type system, and assume that this instance proves (by Theorem 
1) that P0 preserves the se­crecy of s from S. That is, we assume that, in this instance, there exists 
an environment E0 such that E0 f P0, E0 f s:T with T/. TPublic, and S = {a | E0 f a: T and T . TPublic}. 
Without loss of generality, we may assume that E0 contains only names. We .x a proof of E0 f P0 for the 
rest of this argument. Intuitively, a well-chosen environment for a subprocess P of P0 is an environment 
that can be used to type P in a standard proof that P0 is well-typed, using the type sys­tem associated 
with the protocol checker in section 7.2. A standard proof is one in which types introduced by the rule 
(Restriction) for (.a)Q are of the form a[Tc1,...,Tcn], where Tc1,...,Tcn are the types of the variables 
bound by inputs above (.a)Q in P0 s syntax tree. A(Tc1,...,Tcn)-well-chosen environment for P is simi­lar, 
except that the parameters (Tc1,...,Tcn) indicate which types should be chosen for the variables bound 
by inputs. Note that a (Tc1,...,Tcn)-well-chosen environment for P does not always exist, for example 
when the number of pa­rameters (Tc1,...,Tcn) does not correspond to the number of variables bound by 
inputs above P in P0. De.nition 2. Let Tc1,...,Tcn be closed patterns. A (Tc1,...,Tcn)-well-chosen environment 
for an occurrence of a subprocess of P0 is de.ned as follows: A ()-well-chosen environment for P0 is 
.0 .= {a . a[] | (a: T) . E0}. If Ec is a (Tc1,...,Tcn)-well-chosen environment for M(N).P, then Ec 
isa(Tc1,...,Tcn)-well-chosen envi­ronment for P.  If Ec is a (Tc1,...,Tcn)-well-chosen environment for 
M(x).P, then Ec[x..Tcn+1]isa(Tc1,...,Tcn,Tcn+1)­well-chosen environment for P.  If Ec isa(Tc1,...,Tcn)-well-chosen 
environment for P |Q, then Ec isa(Tc1,...,Tcn)-well-chosen environment for P and Q.  If Ec is a (Tc1,...,Tcn)-well-chosen 
environment for !P, then Ec isa(Tc1,...,Tcn)-well-chosen environment for P.  If Ec is a (Tc1,...,Tcn)-well-chosen 
environment for (.a)P, then Ec[a.c1,...,Tcnc1,...,Tcn)­  . a[T]] is a (T well-chosen environment for 
P. If Ec is a (Tc1,...,Tcn)-well-chosen environment for let x = g(M1,...,Mn) in P else Q, then Ec is 
a (Tc1,...,Tcn)-well-chosen environment for Q, and if in addition there exists an equation g(M1' ,...,Mn' 
)= M ' in def(g) and a substitution s such that for all i . {1,...,n}, sMi ' = Ec(Mi), then Ec[x .. sM 
' ]isa (Tc1,...,Tcn)-well-chosen environment for P. Finally, the function f is de.ned so that if a type 
Tc ap­pears in a standard proof that P0 is well-typed using the type system associated with the protocol 
checker in section 7.2, then f(Tc) appears in the corresponding place in the proof of E0 f P0 in the 
instance of the general type system under consideration. De.nition 3. The partial function f: Tc . T 
from types of the protocol checker to types of the instance of the general type system is de.ned by induction 
on the term Tc: f(f(Tc1,...,Tcn)) = Of (f(Tc1),...,f(Tcn)). (There­fore, f(f(Tc1,...,Tcn)) is unde.ned 
if Of (f(Tc1),..., f(Tcn)) is unde.ned.)  If E0 f a: T, then f(a[]) = T.  When a is bound by a restriction 
in P0, we de.ne f(a[Tc1,...,Tcn]) as follows. Without loss of gener­ality, we may assume that a is bound 
exactly once. Let P be the process such that (.a)P is a subprocess of P0. Let Ec bea(Tc1,...,Tcn)-well-chosen 
environment for (.a)P. Let E = f. Ec. Then f(a[Tc1,...,Tcn]) =  T ' where T ' is such that E,a: T ' 
f P is a judgment used to prove E0 f P0. There is at most one such judgment, so T ' is unique. Ifa (Tc1,...,Tcn)-well-chosen 
environment for (.a)P does not exist, or if no suitable judgment E,a: T ' f P appears in the proof of 
E0 f P0, then f(a[Tc1,...,Tcn]) is unde.ned. This de.nition is recursive, and we can check that it is 
well-founded using the following ordering. Names are or­dered by a<b if a is bound above b in P0,or a 
is free and b is bound in P0. The ordering on terms is then the lex­icographic ordering of pairs containing 
as .rst component the multiset of names that appear in the term and as sec­ond component the size of 
the term. In the .rst case of the de.nition of f, the .rst component is constant and the sec­ond one 
decreases. In the third case, the .rst component decreases: when de.ning f(a[Tc1,...,Tcn]), in the recur­sive 
calls used to compute f . Ec, the name a at the top of the term has disappeared, and the only names that 
have appeared due to the computation of the well-chosen envi­ronment are free names or names bound above 
a (therefore names smaller than a). 
			

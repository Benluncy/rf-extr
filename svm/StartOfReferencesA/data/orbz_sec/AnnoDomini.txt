
 AnnoDomini: From Type Theory to Year 2000 Conversion Tool Peter Harry Eidorff Fritz Henglein Christian 
Mossin Henning Niss Morten Heine Sprrensen Mads Tofte Dept of Computer Science, Univ. of Copenhagen (DIKU) 
and Hafnium ApS Email: {phei,henglein.mossin,hniss,rambo,totte}Odiku.dk WWW:http://www.diku.dk, http://www.hafnium.com 
Abstract AnnoDomini is a source-to-source conversion tool for mak-ing COBOL programs Year 2000 compliant. 
It is techni-cally and conceptually built upon type-theoretic techniques and methods: type-based specification, 
program analysis by type inference and type-directed transformation. These are combined into an integrated 
software reengineering tool and method for finding and fixing Year 2000 problems. Ann-oDomini s primary 
goals have been flexibility (support for multiple year representations), completeness (identifying all 
potential Year 2000 problems), correctness (correct fixes for Year 2000 problems) and a high degree of 
safe automation in all phases (declarative specification of conversions, no second-guessing or dangerous 
heuristics). In this paper we present the type-theoretic foundations of AnnoDomini: type system, type 
inference, unification the-ory, semantic soundness, and correctness of conversion. We also describe how 
these foundations have been applied and extended to a common COBOL mainframe dialect, and how AnnoDomini 
is packaged with graphical user interface and syntax-sensitive editor into a commercially available soft-ware 
tool. 1 Introduction 1.1 The Year 2000 Problem The Year 2000 (MK) Problem refers to the inability of 
soft- ware and hardware systems to process dates in the 21st cen-tury correctly. The problem arises from 
representing calen-dars years by their last two digits and thus restricting range of representable years 
to 1900-1999 A.D.. Starting some 40 years ago, this convention was established as one of numer-ous techniques 
for conserving precious memory space and has evolved into a de facto standard for representing and exchanging 
dates containing years. The most widespread Year-&#38;OOO-unsafe date representa-tion consists of six 
characters. It has two characters each for the day of the month, the month of the year, and the calen-dar 
year, often in the order year-month-day (YYMMDD). The string 981106 , for example, represents November 
6th, 1998, The problem, of course, is that no provision is made for representing years in the 21st century: 
00 represents 1900 A.D., not 2000 A.D.. We adopt the popular convention of viewing the year 2000 A.D. 
aa belonging to the 21st century. The Y2K Problem affects countless systems at all lev-els: embedded 
systems, operating systems, applications and data bases that process or contain dates. Both its size 
and consequences are staggering. Cost estimates vary widely, but most of them predict global direct and 
indirect costs on the order of US$lOO, 000, 000, 000. Capers Jones writes that the costs of fixing the 
year 2000 problem appear to consti-tute the most expensive single problem in human history [Jon98]p. 
xxiii. 1.2 Remediation Depending on consequential and repair costs, systems can be put into one of three 
categories: Remediate. Systems that can be and need to be fixed, or systems that are too expensive or 
difficult to replace by the Year 2000. Replace. Systems that either cannot be fixed or where fix-ing 
would be too expensive. Ignore. Systems that need not be fixed, either because they are Y2K-safe or because 
they are not used, useless, dispensible or have little impact. Y2K repairs ( remediation ) usually involve 
a combina-tion of (date field) expansion and masking. Expansion refers to expanding unsafe a-digit years 
to I-digit years in appli-cations, data bases, files, etc., ideally as part of adopting a standardized 
date representation (e.g. IS0 8601). Expan-sion can be expensive, however: it requires that not only 
ap-plication programs be changed, but also data bases, files and all other programs communicating dates. 
Masking denotes a variety of methods for extending a-byte year representa-tions into the 21st Century; 
e.g. windowing, compression and encapsulation. These techniques aim at extending the lifetime of existing 
data in data bases and files as well as screen and print maps into the 21st Century. In windowing, for 
example, a pivot year determines whether a two-digit year belongs to the 20th or the 21st century. For 
example, with pivot 50, 59 represents 1959 A.D. and 41 represents 2041 A.D..  1.3 The AnnoDomini Approach 
AnnoDomini2 is a method and tool for making COBOL pro-grams Year 2000 compliant by source-to-source transforma-tion. 
It processes one program at a time and allows for in-cremental conversion and testing of large applications. 
The AnnoDomini is a registered trademark of Hafnium ApS. converted programs do not require special compiler 
support, but compile and execute in their existing operating environ- ment . In COBOL programs, dates 
are represented using the data types and operations of the source language: numbers, strings of characters 
and flat records. Their intensional in-terpretation as representations of dates is not explicit. The 
AnnoDomini approach is based on reverse engineering the programmer-intended year interpretations as abstract 
types. This is done in three conceptual phases: seeding, type check- ing, and conversion. 1.3.1 Seeding 
In the first phase the user seeds the program with year (and possibly nonyear) information about some 
of its variables, inputs and outputs; that is, they are annotated with Qpe System 2000 (TS2K) types that 
specify where years occur in them, if at all. TSZK types are concatenations of WW (two-digit, win-dowed 
year), YYYY (four-digit year), N (single nonyear char- acter) and crcn) (type variable denoting an unknown 
TSBK type with n characters). Annotations are special COBOL comment lines starting with +TSPK in column 
7. For exam- ple, *TSZK WWNNNN 01 DATA-l PIC XXXXXX.  is an annotation that says that the six-character 
variable DATA-l contains a windowed year in its first two bytes. Seed-ing can be done automatically or 
manually. Automatic seeding works by scanning variable names in a program, including all the libraries 
it imports, and looking for matches according to both lexical and data description criteria. Informally, 
for each program variable the user asks: Could this variable contain a calendar year, based on its name 
and its data description? For example, a variable named DEP-DAT and occupying 6 bytes, might represent 
a B-digit date ( departure date ). Then again, it might not ( deposition data ). Automatic seeding is 
specified by a combination of lexical inclusion and exclusion criteria and a list of target date types. 
These specifications can be config- ured interactively, and they can be stored in separate files for 
future use. Automatic seeding is known to be quick, but also error-prone since it depends exclusively 
on nomen- clature for variable names. AnnoDomini presents a list of all matches along with annotation 
suggestions, but does not automatically accept the results as bona-fide year annota- tions. Instead, 
it expects the user to explicitly accept or reject them, possibly after inspecting the variable declara-tions 
through a point-and-click interface. Manual seeding works by systematically checking the in- terfaces 
of a program; e.g., data base, file, terminal and print map descriptions, In COBOL, these are typically 
lo-calized in shared libraries that are copied into programs by COPY statements, COBOL s macro expansion 
and source li-brary access mechanism. Manual seeding is less error-prone since it reduces guesswork. 
Since data base, file, and map descriptions need to be annotated only once, but are typi- cally used 
by multiple programs, manual seeding need not be done for each program and is thus often a quite efficient 
and safe seeding method. 1.3.2 Type checking In the second phase AnnoDomini propagates the seeding in- 
formation to other data by type inference. For example, if the program contains the MOVE statement *TS2K 
WWNNNN 01 DATE-l PIC XXXXXX. 01 DATE-2 PIC XXXXXX. MOVE DATE-2 TO DATE-i the type of DATE-l is propagated 
to DATE-2, and AnnoDo- mini suggests that DATE-2 be given the same type. During propagation AnnoDomini 
also checks that the seeded and propagated types are consistentwith each other. For example, in *TSZK 
WWNNNN 01 DATE-l PIC XXXXXX. *TS2K YYYYNNNN 01 DATE-2 PIC XXXXXXXX. MOVE DATE-2 TO DATE-l DATE-l and 
DATE-2 have different TSZK types (DATE-2 has a four-digit year in its first four bytes), and AnnoDomini 
signals an error. In general, type errors may signal: Seeding error. Seeding might be wrong; e.g., for 
DATE-l, DATE-2 above or even another variable whose type has been propagated to DATE-l or DATE-2. Not 
a Year 2000 problem. The type system does not allow both years and and nonyears to occupy the same storage 
at different times, such as when printing both years and nonyears through the same print buffer. Year 
2000 Problem. The error might signal a Year 2000 Problem or other questionable computations on dates. 
AnnoDomini does not attempt to guess what the real cause of a type error is and how to eliminate it. 
It suggests a num- ber of plausible corrective actions, however. In the example above, for the first 
case it suggests changing either the type annotation for the declaration of DATE-i or DATE-2. For the 
second case it suggests annotating the MOVE statement with an ASSUME annotation; e.g., *TSSK ASSUME DATE-2 
IS WWNNNNNN MOVE DATE-2 TO DATE-l The ASSUME annotation tells the type checker that X should be treated 
as having type WWNNNNNN in this statement only. (This is dangerous, of course, and therefore requires 
an ez-plicit annotation in the source code.) Finally, for the third case it suggests specifying a coercion; 
e.g., . BY D4T02N4 TS2K COERCE DATE-2 TO WWNNNN MOVE DATE-2 TO DATE-l. The coercion D4T02N4 converts 
an eight-digit value start-ing with an four-digit year to a value with the same year in windowed representation, 
followed by the four nonyear bytes. The coercion is specified as an annotation -the actual conversion 
code is inserted fully automatically in the conversion phase. AnnoDomini also provides point-and-click 
access to the MOVE statement causing the type error and to the declarations of the variables DATE-i 
and DATE-2 oc- curring in it for manual browsing and editing of the source code. AnnoDomini issues warnings 
for all relational and arith-metic operations for which there is insufficient type infor-mation to determine 
whether their operands contain years or not. This is a case where seeding is incomplete, with potentially 
dangerous consequences. The user is expected to check the warnings to determine whether they cover over 
any potential Year 2000 problems. They can also be elim- inated by strengthening the seeding to resolve 
the operand types. Phases 1 and 2 are repeated, possibly interchangeably, until all type errors are eliminated 
and the program is type correct. 1.3.3 Conversion The third and final phase consists of virtual conversion 
and actual conversion. During virtual conversion the user spec-ifies Year-2000-safe types for each variable. 
For example . -> TS2K WWNNNN YYYYNNNN 01 DATE-l PIC XXXXXX. specifies that the variable DATE-l should 
be expanded from a six-digit to an eight-digit date representation. Each variable can have its own year 
representation. AnnoDomini has built-in support for four-digit years, de-noted by YYYY, and fixed windowed 
two-digit years, WW.3 Apart from YYYY and WW, it allows abstract, user-defined two-digit years. These 
are denoted AA(t), where t is the name of a user-defined library, which must contain the re-quired arithmetic 
and relational operations. These can be type-checked on a par with the built-in year types. Finally, 
actual conversion is fully automatic: at the push of a button, data declarations are expanded as desired, 
calls to the specified coercions are inserted, and arithmetic and relational operations involving two-digit 
years are replaced by calls to Year-2000-safe library routines. 1.4 Related Work There is a vast literature 
on type theory and type-based program analysis. There are also numerous Year 2000 tools. Very few of 
those are semantics-based, however, and of those only AnnoDomini appears to be type-based with integrated 
automatic analysis and conversion. The value of working with type notions in software un-derstanding 
and reengineering has been observed previously by O Callahan and Jackson [OJ97]. Van Deursen and Moo-nen 
[vDM98] describe type inference rules for COBOL for classifying data into sets of data representations. 
Subtyping is interpreted as subsumption of value sets. Their system specifies type equivalences, and 
it allows subtyping steps at assignments. Intuitively, this specifies a flow-insensitive data flow analysis, 
refined by data flow sensitivity at assign- ments. The unification theory described in Section 3.2 is 
a spe- cial and feasible case of associative unification (word unifica- tion, solving of word equations) 
[AP89] that, however, does not seem to have been treated in the literature before. Inde-pendently of 
us, Ramalingam, Field and Tip have developed Year 2000 unsafe years in the range 1900-1999 are considered 
a special case of windowed years with pivot 00. prog ::= dec stmt dec ::= e 1 dec dn: elem r 1 dec dn: 
group(dec) stmt ::= E 1 stmt stmt PERFORMstmt UNTIL condexp I I MOVEsender TO receiver IF condexp stmt 
ELSE stmt ENDIF I exp ::= lit 1 pqdn 1 assume exp is T coerce exp by c I exp binop exp I sender ::= 
exp I padl~,,,)(evcp) I padr(,,,)(ev:p) I takel(,,,)(exp) I taker(,,,)(ewcp) receiver ::= pqdn I assume 
receiver is r pqdn ::= dn I dn IN pqdn binop ::= +WN I +NW I +YN 1 +NY 1 +NN ..- 7 ..-v I 7-7 I e ..- 
 71 ..-WWl YYYY ] N ( cr+) condexp ::= exp relop exp relop ::= WW I YY 1 NN Figure 1: Grammar for COBOLsooo. 
basically the same unification algorithm [RFT99] as ours in Section 3.2. They also demonstrate how their 
analysis is applicable to Year 2000 program analysis. 1.5 Outline In the remainder of the paper we first 
present the core theory of AnnoDomini: a skeletal language (Section 2), type sys-tem and type inference 
(Section 3), dynamic semantics and soundness (Section 4), and safety of expansion (Section 5). Then we 
describe how salient features of a full COBOL di-alect are treated (Section S), and we briefly describe 
the system architecture of AnnoDomini (Section 7). Finally we discuss the potential of applying the general 
principles em-bedded in AnnoDomini as a general software reengineering methodology (Section 8). 2 A Skeletal 
Language Our skeletal language is called COBOLseoe. While much simplifed, compared to full COBOL, it 
contains some of the key ingredients of COBOL, including moves involving padding and truncation of data. 
We assume a set Lit of (decimal) numeric literals, ranged over by lit; a set Dn of data names, ranged 
over dq4 for each natural number n 2 1, a set TyVar( ) of type variables of size n, ranged over by czln); 
and a set C of coercion names, ranged over by c. TyVar = Ur,r TyVar( ). The grammar for COBOLxooc appears 
in Figure 1; an example program appears in Figure 2. A program (prog) consists of a declaration (dec) 
followed by a statement (stmt). A declaration can be empty (c), or a declaration followed by a declaration 
of an elementary item 4The COBOL term data name corresponds to variable in other programming languages. 
 YRl : elem WW annotate the arithmetic operators (and we only have one)YR2: elem WW by type information. 
Similarly for relational operators. MYDATE : elem WWNNNN The assume and coerce constructs represent AnnoDo-LONGDATE: 
groupf mini s *TS2K annotations ASSUME and COERCE, respectively.YEAR: elem YYYY We impose the monoid 
laws on types: er = re and MONTH: elem NN (Tl72) 73 = ~1 (~3 73). Thus every type can be written in DAY: 
elem NN) the form ~1 . . . qke, k 2 0. we write r(n) to mean r-.-r, (nBUF: elem NC801 times). The size 
of a type is defined inductively as follows: MOVE assume 94 is WWTO YR1 COMPUTE YR2 = YRI +WN 10 size(q) 
= size(r) = PERFORM case q of case 7 of COMPUTEYRl = YRl +UN i ww* 2 e*O UNTIL YR2 <ww YRl 1 YYYY* 4 
I 117 * MOVE assue 940203 is WWN(4) TO MYDATE size(v) + size(+) MOVE coerce MYDATE by D2T04N4 TO LONGDATE 
IF YEAR IN LONGDATE <YY assume 2000 is YYYY MOVE padr(,,,z)(assume LONCDATEis N(8)) TO BUF ELSE MOVE 
padl(,,,) (5) TO DAY IN LONGDATE 3 Type System 2000 ENDIF COBOLzeee has two kinds of data items: numetic 
elemen-tary items and group items: Figure 2: A COBOLZOOO program k E Kind = {e, g} or a group item. 
In COBOLzeac, all elementary items are numeric. A statement can be empty (e) or the sequen-tial composition 
of two statements. Next, PERFORMstmt UNTIL wndexp corresponds roughly to repeat stmt until condexp in 
other languages. MOVE TO receiver sender moves the value of sender to receiver. A sender may be an ex-pression 
or a padded or truncated expression. The sender padl(,,,)(exp) can only be used when ezp is an elemen- 
tary item; it pads the value of exp with n leading zeros. The sender padr(,,,) (ezp) can only be used 
when exp is a group item; it pads the value of exp with m trailing zeros.7 The sender takel(,,,) (exp) 
can only be used when exp is a group item; it extracts the leftmost n digits of the value of exp. The 
sender taker(,,,)(exp) can only be used when exp is an elementary item; it extracts the rightmost m digits 
of the value of exp. Padding and truncation are implicit in COBOL, but it simplifies the formal treatment 
to make them explicit. The front end of a COBOL compiler can insert padding and trun-cation operations. 
Inspired by COBOL syntax, we write COMPUTEreceiver = sender for MOVE sender TO receiver, when sender 
is an arithmetic expressions A perhaps qualified data name (pqdn) is either an unqual- ified data name 
dn or a qualified data name (dn INpqdn). In the latter case, pqdn must denote a group item and dn a data 
name declared in that group item. In AnnoDomini, addition and subtraction are overloaded. Overloading 
is resolved using an overloading scheme simi-lar to the one used in some Standard ML compilers. For the 
purpose of the present paper, however, we assume that overloading has already been resolved, so in COBOLzeee 
we The COBOL term group item corresponds to the term record in other programming languages. COBOL allows 
several other kinds of elementary items. In COBOL group items are regarded as alphanumeric data and 
padding is with spaces, but since COBOLzooo has only numeric ele-mentary items, we pad with zeroa. In 
COBOL, the two statements are not generally equivalent, not even when both are syntactically correct. 
We assume a function, TypeOf, from coercion names to function types, which must all be monotypes. (A 
function type is a type of form r + r , and a monotype is a type that contains no type variables.) We 
define environment types (a) and type environments (TE) as follows: u ::= r 1 TE TE ::= e ) TE,dn:a 
Intuitively, a type environment is a finite map from (un-qualified) data names to environment types. 
It maps data names that denote elementary items to types and it maps data names that denote group items 
to type environments. Whenever A is a type or an object constructed out of types (e.g., a type environment), 
we write tyvars(A) for the set of type variables that occur in A. We define a function flat from type 
environments to types as follows: flat(TE) = case TE of e=%e 1TE, dn : T =S flat(TE) r I TE, dn : TE 
=S flat(TE) flat(TE ) The type inference rules appear below. The turnstile (I-) is overloaded on different 
syntactic categories. There is a small number of inference rules (usually one) for each pro-duction in 
the grammar of COBOLzeec. Rules in which the premise appears to be identical to the conclusion stem from 
productions where the right-hand side consists of a single non-terminal. Perhaps Qualified Data Names 
ITEI-pqdn:ol TE I- dn : u dn # dn (1) TE, dn : u l- dn : u (2) TE, dn : u I- dn : u TE I- pqdn : TE 
TE I- dn : CT (3)TE I- dn IN pqdn : u Expressions [TE[ r = N(size( lit)) (4)TE I- lit : r :: e (5) TE1 
I- pqdn : TE2 ( 5) TEI I- pqdn : flat(TE2) :: g TE I- exp : T :: k size(T) = size(#) (7)TE I- assume 
exp is r : r :: k TE k exp : T :: k TypeOf = 7 --t f (8) TE I- coerce exp by c : r :: e TE I- expl : 
71 :: e TE I- exp2 : 72 :: e ~1~72 I-binop : ~3 TE I- expl binop exp2 : 73 :: e (9) Sending item TE 
I- sender : r TEI-exp:::::k (10) TE I- exp : r TEI-expcp::::e size(#) = n size(T) = m (11) TE t- padl(,,,) 
(exp) : T T TEI-exp::::g size(T) = n size(+) = m 02) TE I- padr(,,,)(exp) : TT TEI-exp:r::g 7 = TITr 
size(n) = n size(r7) = m TE I- takelt,,,)(exp) : TI (13) TEI-exp::::e T = ~7~ size(n) = n size(r,) = 
m TE I- taker(,,,)(exp) : T? (14) Receivers TE I- receiver : r TE I- pqdn : r (15) TE I- pqdn : r 5 
TE I- pqdn : TE (16) TE I- pqdn : flat(TE) TE I- receiver : 7 size(T) = size(#) (17) TE I- asauna receiver 
is r : r -1Statements TE I- sender : r TE I- receiver : r (18) TE I- MOVE sender TO receiver TE I- wndexp 
TE I- stmtl TE I- stmtz (19) TE I- IF condexp stmtl ELSE stmtz ENDIF TE I- stmt TE I- condexp (20) 
TE I- PERFORMstmt UNTIL condexp (21) TE I- e TE I- stmtl TE I- stmta (22) TE I- stmtl stmtz Declarations 
[dee] (23) I--e:e I-dec : TE (24) I- dec dn: elem r : TE, dn : r t-decl : TE1 I- decz : TE2 (25) I- 
decl dn: group(dec2) : TE1, dn : TE2 Programs FJ I-dec : TE TE I- stmt (26) I- dec stmt Binary Operators 
-binOp (27) W,N(i) I- +w : WW (28) YYYY, N(i) I- +YN : YYYY (29) N(i),N(j) I- +NN : N(l + max(i,j)) (30) 
N(i), w b +NW : ifw (31) N(i), YYYY i- +Ny : YYYY Conditional Expressions 1TE I- condexp 1 TEI- expI 
: 71 :: e TE I- exp2 : ~2 :: e 71,~ F relop TE I- expcp, relop exp2 (32) Relational Operators 1~1~~2 
I- relop 1 (33) ww,uw I- <w (34) YYYY, YYYY I- <yy (35) N(i),N(j) f- NN Rules l-3 describe how perhaps 
qualified data names are looked up in the type environment. In rule 3, the first premise expresses that 
p&#38;z must be bound to a type en-vironment (TE ), i.e., it must denote a group item, and the second 
premise expresses that dn must be declared in this group item. The rules for expressions (4-9) allow 
one to infer state-ments of the form TE I- exp : r :: k, read: in TE, exp has type 7 of kind k. The kind 
determines how the value of exp may be padded, as explained later. In rule 4, we use the notation size(lit), 
by which we mean the number of (decimal) digits in it, including any leading zeros. Rule 5 gives kind 
e to elementary items, while rule 6 gives kind g to group items. Rule 7 shows that applying assume to 
an expression makes it possible to change the type of the expression to any other type with the same 
size; the kind is preserved. Rule 8 shows that coerce can be applied to an expression of either kind 
(elementary or group). Somewhat arbitrarily, we say that the result is always an elementary item. Rule 
9 concerns binary operators; the relation ~1, ~2 I- binop : 7 holds if 71 and 72 are legal types of the 
left and right arguments of binop, respectively, and r is the type of the result of applying binop, see 
rules 27-31. The rules for senders (10-14) allow one to infer state-ments of the form TE I- sender : 
T, read: in TE, sender has type 7. Note that the sender does not have a kind; expres-sions have a kind, 
however, and this kind is used for deter-mining how the expression can be padded in order to con-struct 
a sender. Rule 10 is the case where the expression is neither padded nor truncated; the kind is simply 
discarded. Rule 11 concerns the case where a value is padded with n zeros on the left; note that the 
expression must have kind e, but the zeros may be given any type of size n (including types involving 
years). Padding on the right (rule 12) requires group kind; trun-cation which discards rightmost digits 
requires group kind (rule 13); and truncation which discards leftmost digits re-quires kind e (rule 14). 
The identifier which is assigned a value in the MOVE state-ment is called a receiver. Receivers are typed 
much like perhaps qualified data names in expressions, except that no kind is needed (rules 15-17). In 
rule 18, notice that the sender and the receiver must have exactly the same type. The sender must be 
padded or truncated, if necessary, to achieve this. The rules for binary operators (27-31) impose a certain 
discipline on the use of arithmetic. Assume, for example, that MYYEAR MYDATE have types WW and respec- 
and WWNNNN, tively. Then COMPUTEMYYEAR= MYYEAR + 1 is well-typed, but COMPUTE = (a COBOL MYDATE MYDATE+iOOOO 
common idiom!) is not. Similarly, LONCDATE: group( YEAR: YYYY MONTH: NN DAY : NN) SHORTDATE: WWNNNN MOVE 
LONGDATE TO SHORTDATE is not well-typed, although COBOL permits it: the types YYYYNNNNand WWNNNNare not 
equal, not even after any padding or truncation (compare rule 18). Instead, Type System 2000 provides 
coercions for conversions between dif-ferent date formats. In Figure 2, D2T04N4 is a coercion of type 
WWNNNN YYYYNNNN. + Rules 33-35 show a rather limited set of comparisons. AnnoDomini supports a wider 
range, including, for example comparison on types WWNNNN. An expression is well-typed in TE, if there 
exists a type r and a kind k such that TE I- exp : r :: k. Well-typedness of other phrase forms in a 
type environment is defined sim-ilarly. 3.1 Type Checking By type checking we mean using an algorithm, 
called the type checker, which checks, given a type environment and a phrase, whether there exists a 
substitution instance of the type environment in which the phrase is well-typed. As is the case with 
Standard ML, type checking is based on unification [Mi178, DM82]. However, because our types obey the 
monoid laws and because type variables have sizes associated with them, ordinary term unification is 
not a suf- ficient base for type checking in COBOLzoos. We there-fore develop a different unification 
algorithm and prove that there exists a form of most general unifier in this setting. The fact that types 
have known sizes are essential for this result, which appears to be new.g 3.2 Unification A substitution 
is a map S from type variables to types sat-isfying VnVd ) E TyVar( ). size(S(a )) = n The support of 
S, written Supp(S), is the set Supp(S) = U,tr{cP 1 S(P) # ce} The yield of S, written Yield(S), is defined 
by Yield(S) = U{tyvars(S(cr( ))) 1 acn) E Supp(S)} It turns out that Ramalingam, Field, and Tip independently 
have developed essentially the same algorithm, see elsewhere in these pro- ceedings. Further, the set 
of type variables involved in S, written Inv(S) is defined by Inv(S) = Supp(S) U Yield(S) By natural 
extension, substitutions may be applied to types and to objects constructed out of types (for example 
pro- grams). Substitution preserves equality: if two types ri and rz are equal under the monoid laws, 
then S(ri) and S(rz) are also equal under the monoid laws. Substitution pre- verves size: Lemma 3.1 Fz;w;{l 
q~and 7, size(S(7)) = size(q) and size(S(r)) = Substitutions compose: (S~oSi)(c&#38; )) = Sz(Si(c~(~))). 
Note that, by Lemma 3.1, the composition is a substitution. The identity substitution is denoted I. 
 A unifier for types ri and 72 is a substitution S satisfying S(ri) = S(Q). A substitution S is a most 
general unifier for 71 and ~2 if S*(ri) = S (Q) and for every unifier S for ri and 72 there exists an 
5 with S = S o S . Interestingly, not all pairs (71,~~) have a most general unifier. For example, let 
71 = or)@) and rz = @or). In order to unify these two types, without committing the two middle digits 
of the six digits to a monotype, we intro-duce a fresh type variable, say c$). Consider the natural candidate 
for a most general unifier, namely S = ( 14) I+ f$)@, ($ I+ @ok } We have S*(ri) = cr~)c$)@ = S(Q), 
so S unifies ri and ~2. However, 5 is not a most general unifier. To see this, consider S = (~~14) c) 
@NN, cry c) NN@, c@ c) WW} Note that S is a unifier for 71 and 72; but there exists no S such that S 
= S o S (consider what crp should be mapped to); the best we can achieve is S J- U = (S o S*) 1 U, where 
U is a set of type variables satisfying of) $ U. (We write S .J U for the restriction of S to U.) To 
make this precise, we introduce a notion called U-unification. We use U to range over finite subsets 
of TyVar. (U stands for used .) A substitution S is a most gen-eral U-unifier for ~1 and 72, if tyvars(ri) 
U tyvars(rz) c U; s (~1) = S (72); and for all substitutions S, if S(ri) = S(Q) then there is a substitution 
S with S J- U = (S o S ) .J. U. We now present a unification algorithm and a theorem to the effect that 
the algorithm finds most general U-unifiers. The algorithm either raises an exception, FAIL, or re-turns 
a substitution. It uses two auxiliary functions: fun unify,(qi,qz) = (* size(qi) = size(gz) *) case (711,~2) 
of (cp, _) =k-{al ) H 72) I (-,cp) * {&#38; c-) 171) 1 (_, _) =S if ~1 = 712 then I else raise FAIL. 
 fun splitl(v, i, U) = (* 0 < i < size(n) *) case n of ocn) =+ let of), &#38; - ) be distinct type variables 
not in U in ({aCn) +j Gus- )}, {a,), apmi)}) end 1 _ + raise FAIL  The unification algorithm relies 
on the fact that every type can be written in the form 71 . . . nkc, (Ic 2 0). The algorithm is: fun 
unify(ri, ~2,U) = case (71, ~22)of (c, e) * (I, 0) I (~1~11,772~22) =9 if size(qi) = size(vz) then let 
Sl = unify, (171,92) (572, UZ) = unify(Sl(nl), S1(722), U) in (Sz o Si , Uz) end else if size(vi) > 
size(q2) then let (Si, Ul) = splitl(vi, size(vz), U) (572, UZ) = unify(Sil(T&#38; Sl(T2), U U Ul) in 
(Ss o Si, Ul U Uz) end else unify(r2, ~11) 1 _ + raise FAIL  Lemma 3.2 Assume size(ni) = size(nz). If 
there exists a unifier for 71 and 5~2then S = unify,(~i,~z) succeeds and S is a most general unifier 
for qi and 1,72.If there exists no unifier for q1 and 172, then unify,,(,) 72) raises FAIL. Theorem 3.1 
Assume tyvars(ri) U tyvars(T2) C U. If there exists a unifier for 71 and 72 then (9, U ) = unify(ri, 
72, U) (36) succeeds and S*(T~) = S*(72), for any unifier So of ~1 and 72 there is an S with So J- U 
= (S o S ) J. U, Inv(S*) tyvars(Tl) U tyvars(rz) U U , and U rl U = 8. If there is no unifier for 71 
and rz, then (36) raises FAIL. 3.3 A Type Checker We now present a type checker which is sound and complete 
for the type inference rules in Section 3. The soundness relies on the following result: Lemma 3.3 A 
k phrase : B implies S(A) I- S(phrase) : S(B). For brevity, we show only the part of the type checker 
that is necessary for type checking expressions and phrases that are part of expressions. (The remaining 
rules are treated analogously.) Concerning rules 1-3, let TE be a type envi-ronment and let y be a perhaps 
qualified data name. Note that there exists at most one u such that TE I- y : CT. Define lookup(TE, y) 
to be this u, if it exists, and let lookup(TE, y) terminate with FAIL otherwise. Next, rules 27-32 are 
checked by the following function: BinOp(ri, 72, binop, U) = case binop of +WN + let (Sl, ul) = unify(rl,WW, 
U) (SZ, UZ) = unify(S1(7i),N(size(Tz)), U U Vi) in(SzoSi,~~,UiUUz)end 1 +yN =$ let (&#38;, &#38;) = unify(ri, 
YYYY, U) (S2,U2) = unify(Sl(Tz),N(size(Tz)),UUUl) in (Sz o Si,YYYY, Ul U U2) end I +NN * let (S1,Ul) 
= unify(Tl,N(size(Tl)), U) (SZ, UZ) = unify(Sl(Tz),N(size(Tz)), U U VI) in (SZ o SI, N(l + max(size(Tl), 
size(T2)), VI U UZ) end I +NW =+ let (Si, VI) = unify(T1, N(size(Tl)), U) (SZ, UZ) = unify(Sl(Tz),WW, 
U U Ul) in(SzoSi,~~,UiUUz)end 1 +~y * let (&#38;, &#38;) = unify(Tl,N(size(Tl)), u) (SZ, UZ) = unify(&#38;(Tz),YYYY, 
U U VI) in (SZ 0 S1, YYYY, lJ1 U U2) end This algorithm satisfies the following soundness and com-pleteness 
properties. Lemma 3.4 Assume that tyvars(rl, 72) C U and (S, 7, U ) = BinOp(rl, 72,binop, U) succeeds. 
Then S(71), S(72) I- binop : 7, Inv(S) C tywars(~l,~2) U U and unu =0. Lemma 3.5 Assume tyvars(Tl,Tz) 
C U. If there exist So and and ~0 such that So~l, So-r2 I- binop : TO (37) then (S, 7, U ) = BinOp(Tl, 
~2, binop, U) (38) succeeds and for every SO and TO satisfying (37) there exists an S such that So J- 
U = (SOS) 1 U and 70 = r. Moreover, if there is no So and ro satisfying (37), then (38) terminates with 
FAIL. The proof is by cases on binop using Theorem 3.1. The following functions check rules 4-9. (In 
the last case, we assume that the function raises FAIL, if the pattern matching on e fails.) Exp(TE, 
exp, U) = caSe exp of lit =$ (I,N(size(lit)),e, 0) 1 pqdn + (case lookup(TE,pqdn) of 7 * VT.,e,0) I TE 
+ (I,flat(TE ),g,O)) 1 assume expl is r * let (SI, ~1, kl, Ul) = Exp(TE, expl, U) in if size(Tl) = size(r) 
then (Sl, sl(~),IEl, S) else raise FAIL end I coerce expl by c + let (SI,TI,~I,UI) = Exp(TE, expl,U) 
in let TypeOf = 72 + 7; in let (S2,U2) = unify(Tl,Tz,UU Ul) in (572 oSl,S2(4),e,Ul UU2) end end end 
I expl binop exp2 + let (Sl, 71, e, Ul) = Exp(TE, expl, U) (S2,72,e,U2) = Exp(S1(TE),Sl(exp2),U U Ul) 
(&#38;,~a, Us) = BinOp(&#38;(71),72, binop, U U Ul U U2) in(S3o&#38;oS1,r3,e,UlUU2UU3) end The algorithm 
Exp satisfies the following soundness and completeness properties: Theorem 3.2 Assume tyvars(TE) U tyvars(exp) 
C U. If (S, 7, k, U ) = Exp(TE, exp, U) succeeds then S(TE) I- S(exp) : T :: k, Inv(S) U tywars(r) c 
tywars(TE) U tywars(exp) U U , and U n U = 8. Theorem 3.3 Assume tyvars(TE) U tyvars(exp) E U. If there 
exist So, ro and ko satisfying So(TE) t- So(exp) : ~0 :: ko (39) then (S , T , k , U ) = Exp(TE, exp, 
U) (40) succeeds and for all So, ro and ko satisfying (39) there exists an S such that So 1 U = (S o 
S ) 1 U, S (r ) = 70 and ko = k . Moreover, if there is no So, TO and ko satisfying (39), then (40) terminates 
with FAIL. The proofs are by induction on the structure of exp, using Lemmas 3.4, 3.5. 4 Dynamic Semantics 
and Soundness In this section we give a dynamic semantics for COBOL2000 and prove that the static semantics 
is sound with respect to the dynamic semantics. We use d to range over decimal digits. We distinguish 
between numerals (a) and numbers (a). A value, v, is a numeral, i.e., a sequence of digits. The size 
of a value a, written size(a), is the number of digits in a. O(n) denotes the sequence of n zeros. For 
every value v and n 2 0 satisfying size(v) 5 n, we define fill(n, v) to be O(n -size(v))v. Evaluation 
can fail. The semantics distinguishes between the following failures: Y2K (Year 2000 failure), Arith 
(arith-metic failure), and Wrong (other failure). A store (of size n) is a map from (0, . . . , n - 1) 
to digits. We use s to range over stores. We define extract(s,Z,u) to be the value s(~)...s(u -l), if 
0 5 I 5 2~ 5 size(s), and the failure Wrong otherwise. Further, we define update(s, I, LL, v) to be the 
store s defined by s (i) = s(i) if 0 5 i < 1 or u 5 i < size(s) di-1 if 1 5 i < u provided 0 5 I 5 21 
5 size(s) and v = do+.-d,-I-l; otherwise, we define update(s, 1, u, v) to be the failure Wrong. We define 
(dynamic) environments (E) and denotable values (dval) as follows: E ::= e I E, dn = dval dval ::= (E,l, 
u) where 1 and u range over non-negative integers. Intuitively, given store s, E(dn) = (E , 1, u) means 
that dn represents the value s(l)...s(u -1). Further, E is empty, iff dn is an elementary item. The evaluation 
relation takes the form A I- phrase =+ B, where A is an environment or a pair of an environment and a 
store and B is a result, whose kind depends on the kind of phrase. An environment result (e) is either 
a denotable value of Wrong. An expression result (r) is either a value, Y2K, Wrong, or Arith. A statement 
result (t) is either a store, Y2K, Wrong, or Arith. In the evaluation of relational expressions, we use 
booleans (true, false); a condition result (b) is either true, false, Wrong, Arith or Y2K. We assume 
a function Apply with the following property: for all c, letting 7 -_) 7 = TypeOf( for all v, if size(r) 
= size(v) then Apply(c, v) either results in Y2K or in a value v of size 7 . Finally, initstore(z) denotes 
a store of size z consisting of zeros only. The dynamic semantics is defined as a big step seman-tics, 
with a small number of rules for each production in the grammar. The rules appear below. Many of the 
rules have associated with them one, two or three failure propagation rules, which describe that once 
the evaluation of a phrase fails, the evaluation of the entire program fails. For example, rule 48 has 
the following two associated failure rules: E I- pqdn =+ f (41) s,Ekpqdn+ f E I- pqdn =S (_, I, u) Wrong 
= extract(s, 1, U) (42) s, E k pqdn =S Wrong where f ranges over {Wrong, Y2K, Arith}. For brevity, we 
omit the failure propagation rules (although they are used in the proof of Theorem 4.1.) Perhaps Qualified 
Data Names IEI-pqdn+eI (43) e I- pqdn + Wrong E I- dn =+ dval dn # dn (44) E, dn = dval l- dn + dval 
(45) E, dn = dval l- dn j dval E k pqdn =S (E , _, _) E I- dn =+ dval (46) E k dn IN pqdn =S dval Expressions 
Is,El-exp:prl (47) s, E t lit =F. lit E I- pqdn + (_, I, u) v = extra&#38;(+ 1, U) (48) s,El-pqdn=+v 
s,El-expcpv (49) s,Ekassume expiisr:v s, E I- exp =S v Apply(c, v) = v (50) s, E I- coerce exp by c : 
v s, E I- expl =S VI s, E I- exp2 =+ v2 211,212t-binop + v s, E k expcp, binop exp2 + v (51) Sending 
item s, E t- sender + r s,E I- exp *v (52) s,El-expcpv s, E I- exp + v (53) s, E I- pac+,,)(exp) * O(n)v 
s, E I- exp =+ v (54) s, E I- padr(,,,)(exp) * v O(m) s,El-exp=+d~...d,d~...d~ (55) s, E i- takelc,,,)(exp) 
: dl . . . d, 3, E I- exp * dl . , . d,d; . . . dh (56) s t- taker(,,,)(exp) : di . . . dL, Receivers 
1E k receiver =+ (1, u)/Wrong 1 E I- pqdn =S (E , 1, u) (57) E I- pqdn + (1,~) E I- receiver =S (1, 
u) (58) E I- assume receiver is r =+ (1,~) Statements s.El-stmt+t s, E I- sender =s- v s, E I- receiver 
=+- (1,~) (59)8, E i- MOVEsender TO receiver + update(s, 1, u, v) s, E I- condexp * true s, E k stmtl 
+ s (SO)s, E t- IF condexp stmtl ELSEstmtz ENDIF =k 3 s, E I- condexp j false s, E I- stmt2 =+ s (61)s, 
E I- IF condexp stmtl ELSEstmtz ENDIF + s/ s, E I- condexp + true s, E k stmt =S s s , E I- PERFORMstmt 
UNTIL condexp =+ a (62)s, E k PERFORMstmt UNTILcondexp =k- s s, E I- condexp * false (63) s, E I- PERFORMstmt 
UNTILcondexp =S s (64) 3,El-C=+S s,Ekstmtl+-sl sl,El-stmt2*s2 (65) s, E I- stmtl stmtz, =+ 32 Declarations 
IIk dec+ E,zl (66) ll-e*e,O 4.1 Soundness 1 I- decl =+ El, ~1 I t- decl dn: elem r * El, dn = (E,1 + 
x1,1 + z1 + s&#38;(-r)), 21 + size(T) (67) 1 I-decl =+ El, z1 I+ 11 I- decz + Ez, .z2 1 I- decl dn: 
group(dec2) j El, dn = (Ez, I+ zl,l+ z1 + zz), a + z2 633) Programs 0 I- dec + E, z initstore(z), E 
k atmt * s (69)I- dec atmt =+ a Binary Operators Iv,1 a+b<99 a+b>99 (70) g,b t +WN + fill(2,a a,bk+WNjY2K 
a + b 5 9999 a + b > 9999 (71) ~3,b k +yN + fill(4,&#38;) $,&#38;h t- +YN =S Arith i = 1 + max(size(a, 
b)) (72) a, b t- +NN + fill(i, a + b) a+b<99 a+b>99 (73) a, b b +NW =+ fill(2, a) a, b k +NW =+ Y2K a 
+ b 5 9999 a + b > 9999 (74) Conditional Expressions a, E I- condexp + b a, E I- expcp, =+ VI a, E I- 
exp2 + v2 v1,v2 I-relop * b a, E I- expcpl relop exp2 * b Relational Operators a<99bs99a<b a,b I- <WW 
=S true a 5 9999 b 5 9999 a < b a,hl-<fl *true a>99Vb>99 a,&#38;t- ww=$Y2K a<b ~3, b t <NN * true (75) 
Ii, v I-relop + b 1 a<99b<99a>b (76) a, a I- <ww * false a 5 9999 b 5 9999 a 1 b (77) g, b t <yy * false 
a > 9999 V b > 9999 (78) a,!! k <YY * Wrong a>b (7% a, b I- <NN 3 false A store typing, ST, is a sequence 
of triples satisfying 1. size(T;) = U; -li, for all i = 0.. .n; and 2. li=Ui-1,fOralli=1...n.  The 
addreaa apace of 5T, written addr(SZ ), is the interval {i 1 11 5 i < u,}. Given 1 and U, we define the 
restriction of ST to (1, u) to be the subsequence which satisfies li = 1 and Ui+j = u, if one exists; 
further we define the store type of (ST,l,u), written sttyp(SZ ,l,u), to be ri...ri+j. We say that an 
environment E matches type environ-ment TE in ST, if ST + E : TE, where ST k E : TE is defined thus: 
Store Typing VI ST + E : TE sttyp(fl, 1, u) = T STj=e:c ST+E,dn=(e,l,u):TE,dn:r ST + ~~ : TEl ST k E2 
: TE2 sttyp(fZ,l,u) = flat(TEz) ST+E1,dn=(E2,l,u):TE1,dn:TEz The following soundness theorem states that 
if an expres- sion is well-typed and is evaluated in an environment and a store that match the type environment, 
then the result of the evaluation is not Wrong, although it may be a Year 2000 failure. Furthermore, 
if the result is not a failure, it is a value of the size predicted by the type system. Theorem 4.1 Zf 
TE I- exp : r :: k and 5T k E : TE and Dam(s) = addr(SZ ) and a, E !- exp * r then r is not Wrong (although 
it may be Y2K) and if r is a value v then size(v) = size(T). 5 Expansion In this section we formalize 
transformations that fix Year 2000 problems using expansion and show that, informally speaking, all computations 
that succeed using the original program will still succeed (with a related result) after expan- sion. 
A similar result is difficult to obtain for windowing, for as one moves a window, some Year 2000 problems 
are fixed while others may be introduced (because the new window does not represent all the years that 
could be represented with the old window). To prove our result, we shall interpret WWas representing 
the years 1900-1999 by their last two digits. Further, we consider only coercions which expand two-digit 
years to four digit years (by adding 1900). Formally, we introduce type environments, written respectively, 
as the smallest satisfying: 1. ww 5 YYYY, a subtyping relation on types and 9 5 q , r 5 r, and TE 5 TE 
, reflexive and transitive relation 2. 71 5 ri and 72 5 r; implies rirz 5 7174; 3. TE < TE and r 5 r 
implies TE, dn : T 5 TE , dn : T ; 4. TE1 5 TE: and TE2 5 TE , implies TE1, dn : TE2 5 TE;, dn : TE 
,;  A store expander is a finite map from store indices to store indices. (A store index is a non-negative 
integer.) Let 5T and ST be store typings and let cp be a store expander. We say that ST expands ST via 
cp, if cp I- ST 5 ST , where _I-___isdefinedby For example, one has cp I- (0,5,N(5))(5,7,WW)(7,9,WW) 
5 (0,5,N(5))(5,9,YYYY)(9,11,WW), where cp = (0 I+ 0,5 c) 5,7 I+ 9,9 I+ 11). Note that expansion allows 
some of the two-digit years to be expanded to four digits while leaving other years in two-digit form. 
The application of a store expander cp to an environment E, written cp. E, is defined inductively: cp. 
E = E; and cp. (E, dn = (E , 1, u)) = (P . E), dn = ( P. E , ~(0, V(U)). Given two types r and r with 
r 5 r and a value v with the same size as r we define expand(r, T , v) to be the following value: fun 
expand(r, r , v) = case (7, r , v) of (c, e, e) * e 1 [;?kYTYy, d;d$)~~gdl&#38; expad(n,, T[,, v ) 71, 
T2, l... n . ..d.expand(r1,r2,v) where n = size(n)  Note that 7 5 7 and size(v) = size(r) implies that 
v = expand(r, r , v) succeeds and size(v ) = size(#). Assume cp I- ST 5 ST and Dam(s) = addr(S2 ); we 
say that store s expands s, written cp I- s : ST < s : ST , if Dom(s ) = addr(SZ ) and for every (I, 
U, r)-in ?I? and corresponding (v(l), V(U), 7 ) in ST we have extract(s , q(l), V(U)) = expand(r, r , 
extract(s, 1, u)). We say that a coercion c is expansive if, letting r + 7 = TypeOf( we have T 5 7 and, 
for all values v of size size(r), Apply(c, v) = expand(r, r , v). Henceforth, we require that all coercions 
be expansive. We now define how programs may be transformed in or-der to fix Year 2000 problems using 
expansion. The trans-formation is not a function but a binary relation (-) on judgements of the form 
A F phrase : B. For example, TE F exp : r :: k u TE t- exp : r :: k is read: the judgement TE F exp 
: r :: k is transformed into TE I- exp : 7 :: k . We first state the expansion theorem and then define 
and explain the transformation. For brevity, we show only the theorem for expressions. Theorem 5.1 If 
TE I- exp : r :: k -TE t- exp : 7 :: k and cp + s : ST 5 s : ST and ST k E : TE and ST + ycl a E : TE 
and s, E I- exp * v then s , cp s E I- exp =S expand(r, r , v). Informally, the theorem states that a 
translated expression returns the year expanded value of the original expression, if the translated expression 
is evaluated in a year expanded version of the store and environment that the original ex-pression is 
evaluated in. Data Names TEl-pqdn:u-+TE l-pqdn:a dn # dn TE I- dn : u - TE I- dn : a u1 <u; (82) TE,dn 
:alt-dn:uuTE ,dn :a;i-dn:u TE 5 TE u 5 u (83)TE, dn : u l- dn : u u TE , dn : u l- dn : CT TE I- pqdn 
: TE1 u TE l- pqdn : TE: TEll-dn:u-TE;l-dn:u (84) TE I- dn INpqdn : u u TE I- dn IN pqdn : u Expressions 
TEl-exp:r::kuTE l-exp :r ::k r = N(size(lit)) TE 5 TE 035) TE~lit:r::euTE ~llit:r:e TE I- pqdn : r u 
TE I- pqdn : r (86) TEl-pqdn:r::e-uTE l-pqdn:r :e TE1 I- pqdn : TE2 -TE; I- pqdn : TE; TE1 F pqdn : flat(TEz) 
:: g u TE: t- pqdn : flat(TE ,) :: g (87) size(rr) = size(r) TE l- expl : ~1 :: k +L+ TE I- exp; : 
TI :: k TE I- assume exp, is r : 7 :: k u TE I- assume e&#38;&#38; is T : r :: k (88) TypeOf = 7 + 7 
TE l- exp : r :: k - TE F exp : r :: k (89) TE t- coerce exp by c : r' :: e u TE l- coerce exp by c : 
r' :: e TypeOf = r + r TEl-exp:::k~cTE Fexp :~ ::e (90) TE k coerce exp by c : T' :: e cu TE l- exp : 
T' :: e TypeOf = T' + T" TEI-expcp:::: e u TE I- exp : T' : k (91) TEkexp::::e-TE k coerce exp by c 
: T" : e TE l- expl : TI :: e - TE I- expi : ri :: e TE I- exp2 : 72 :: e u TE l- expcp z : 7: :: e rl,72 
I- binop : r r;, ri I-binop : r (92) TE l- expl binopexp2 : r :: e - TE I- expi binop expcp ,: r : e 
 The only interesting rules are the ones involving assume and coerce. In rule 88, note that the type 
of expl must be the same before and after transformation and that the type of the whole assume expression 
must remain unchanged too. This is used in an essential way in the proof of Theorem 5.1. In rule 89, 
note that we can only keep the coercion, if the type of exp equals the type of exp. Rule 90 says that 
a coercion in the original program may be cancelled by an expansion in the resulting program. Such an 
expansion can come about for example because exp is a data name dn with TE(dn) = WW but TE (dn) = YYYY. 
Rule 91 says that one can add a coercion in the resulting program. One can prove Theorem 5.1 using the 
following lemmas. Lemma 5.1 If TE I- exp : r :: k -TE I- exp : T : k then TE k exp : r :: k and TE I- 
exp : r :: k Lemma 5.2 If TE t- exp : T : k u TE I- exp : T : k then TE 5 TE , r 5 r , and k = k . Lemma 
5.3 If ~1 5 72 5 ~3 and size(Ti) = size(v) then expand(Tz, ~3, expand(Tl, ~2, v)) = expcpand(Tl, r3, 
v). 6 Extension to Full COBOL The conceptual and technical core of AnnoDomini s type system has been 
described in Sections 3, 4 and 5. In this section we describe how AnnoDomini addresses a number of COBOL 
features not found in COBOLXJ~~, but of relevance to Year 2000 remediation. 6.1 Storage model Data representation, 
alignment, synchronization, truncation, padding, and editing rules for COBOL are very complex. Here we 
shall give only a glimpse of how they are modeled in AnnoDomini. For a more thorough description we refer 
to the OS/VS COBOL Application Programmer s Reference [IBM86], AnnoDomini User s Guide [Haf98b] and AnnoDo-mini 
Reference Manual [H&#38;gal. 6.1.1 Internal representation In the standard representation of data in 
COBOL each char- acter position in an elementary data item requires one byte of storage. In this representation, 
even numeric data are stored in the form of contiguous decimal digits; e.g., the numeral 98 is stored 
in two contiguous bytes, the first of which contains the EBCDIC representation for the character 9 , 
and the second contains the corresponding representa-tion for 8 .l Numeric data, however, can also be 
stored in binary or packed form. In COBOL, there is a difference between moving a binary or packed item 
by directly referring to it or by moving it For simplicity, we assume that EBCDIC is the underlying char- 
acter set here. Other possibilities, not covered here, are short and long internal floating point representations. 
AnnoDomini does not allow year data in those, though. as part of a group item that contains it. In the 
first case the item is first transformed into its standard representation before its value is moved. 
In the latter case the item is moved in its binary or packed form as part of the group item, without 
prior transformation. AnnoDomini models binary and packed representations by adding ~::=B<T> 1 P<T> to 
the language of TS2K type expressions and reflecting their implicit transformations in the type inference 
rules. 6.1.2 Editing COBOL specifies the format of elementary data items by a number of clauses. The 
picture-string clause determines the class of allowable characters for each character position of a data 
item in standard representation. In particular, it determines the information-carrying character positions 
and the editing character positions in the data item. Data from another data item is written only into 
the information- carrying character positions. The editing positions are filled independently. For example, 
consider *TS2K WWNNNN 01 DATE-i PIC XXXXXX VALUE IS 981106 . 01 DATE-2 PIC XX/XX/XX. MOVE DATE-l TO 
DATE-2 The two occurrences of 1 in the declaration for DATE-2 are editing characters. They are, in a 
sense, hardwired into 2 of the 8 bytes at the positions indicated. During the MOVE the six digits 981106 
are moved into the remaining character positions. As a result, DATE-2contains the string 98/11/06 . AnnoDomini 
keeps track of storage at the byte-level and captures faithfully the effect of editing. In particular, 
it infers the type WWNNNNNNfor DATE-2,where the 1st and the 4th N are derived from the editing for DATE-2. 
The other N s stem from the type for DATE-l. 6.1.3 Data alignment Numeric data are aligned on an assumed 
decimal point be-fore they axe moved. We have generalized the notion of as- sumed decimal point to a 
reference point, which also applies to nonnumeric data. The reference point indicates where the data 
should be logically aligned and, if necessary, where padding and truncation is necessary during a MOVE. 
AnnoDomini models each data item by (k, T, q, T,.), where k, r correspond to r :: k in Section 3, and 
q and 7, describe the type information of the information-carrying character positions to the left and 
to the right of the data item s ref-erence point, respectively. The Ctuple contains sufficient information 
to determine how the bytes of a data item are processed both as a sender and as receiver in a MOVE state-ment. 
6.2 Aliasing COBOL provides a number of facilities for accessing the same storage using multiple data 
item definitions. Explicit redefinition. A REDEFINES clause in the work- ing storage section of a COBOL 
program expresses that the storage area associated with a data item defi-nition can be accessed using 
another data item defini-tion. Implicit redefinition. Multiple 01-level record definitions for a single 
file are implicit redefinitions for the file buffer area shared by all records from the file. Renamings. 
Consecutive storage inside a single 01-level storage can be can be (re)named by a RENAMES clause and 
accessed through it. These forms of aliasing are usually used for two distinct purposes: 1. to provide 
different views of the same data; 2. to reuse storage area for efficiency purposes or to pro- cess different 
records contained in the same file.  In the first case the program interleaves reads from and writes 
to the shared storage area using different views. For example, in 01 DATE-l PIC X(6). 01 DATE-2 REDEFINES 
DATE-l. 02 YY PIG 99. 02 MM PIC 99. 02 DD PIC 99 VALUE IS 31 . MOVE 981106 TO DATE-l. DISPLAY DD OF DATE-2. 
the program writes 981106 into the shared storage area using the view of DATE-l, and consequently reads 
it from the same storage area using the view of DATE-2. (Thus the program displays 06 , not 31 .) In 
the second case the program uses the shared data stor-age primarily to conserve storage space: the shared 
storage area is always read using the same view as when last written to. In this case the storage areas 
can be treated as concep-tually separate (unshared). By default, all views of shared storage must have 
the same TSSK type in AnnoDomini. If, in the above example, YY is annotated with WW and both MM and DDwith 
NN, then DATE-l is inferred to have TS2K type since DATE-2 WWNNNN, has type WWNNNN,and DATE-l and DATE-2 
are aliased. Requiring that all views of shared storage have the same TSPK type leads to propagation 
of type information from one view to the others also in cases where the different views are used conceptually 
separately. AnnoDomini allows anno- tating each both implicit and explicit redefinitions with *TSPK ASSUME 
SEPARATE which expresses that the redefinition should be treated as a separate, unshared definition. 
Thus type information from one view is not propagated to the other. AnnoDomini takes ASSUMESEPARATEannotations 
at face value. Since it is control- flow insensitive it does not check whether read-accesses to shared 
storage are always performed using the same view as the (dynamically) most recent, write access. 6.3 
Key fields AnnoDomini identifies and warns of two-digit windowed and user-defined years in key fields 
of index-sequential files. This is because, for windowed years, dates in the 21st Century appear before. 
dates in the 20th Century in the standard (EBCDIC or ASCII) sorting orders. 6.4 Program Constants Since 
moving literals into dates is a potential Year 2000 problem, literals both in the data division and procedure 
division sections are typed to be nonyears in AnnoDomini. Thus the MOVEstatement in *TSPK WWNNNN 01 DATE-l 
PIC XXXXXX. MOVE 990909 TO DATE-l causes a type error as it is an apparent Year 2000 Problem (990909 
is often used as a special value, not a regular date). If, however, the literal is a correct date literal 
it can be given the desired type by an explicit ASSUME annotation, which eliminates the type error: +TSZK 
ASSUME 990909 IS WWNNNN MOVE 990909 TO DATE-l 6.5 Arrays Arrays, called tables in COBOL, have program-static 
length in COBOL. AnnoDomini treats them a8 group items with re-peated element types. For example an array 
of length 4 with element type has type WWNNNN WWNNNNWWNNNNWWNNNNWWNNNN. 6.6 Call statements COBOL programs 
can call other COBOL programs in one of two ways: by static calls or by dynamic calls. Static calls are 
linked at compile time, whereas dynamic calls are resolved at run-time. In the latter case it is statically 
evident which program is called. AnnoDomini issues warnings if arguments of calls have year types, but 
does not itself propagate the types across call boundaries. 6.7 Nonuniform language features There are 
a number of language features in COBOL that make correct conversion complex: e.g., impossibility of call- 
ing programs in PERFORM statements; nondistributivity of size error handling in ADD/SUBTRACT state- CORRESPONDING 
ments; COPY statements with a REPLACING phrase; variable-sized arrays. To a large degree these can be 
attributed to a nonuniform language design. AnnoDomini is designed to preserve the semantics of the underlying 
program as much as possible. Where this is impractical or impossible Ann-oDomini warns of and describes 
potential problems. 7 AnnoDomini System Components AnnoDomini 1.0 for OS/VS COBOL runs on Windows NT 
4.0 and Windows 9X. It is commercially available from Com- puter Generated Solutions, Inc.; see http: 
//www. cgsinc . corn or http: //ww . haf nium. corn. AnnoDomini consists of 3 com- ponents: 1. the analysis 
and conversion engine (ACE), 2. the graphical user interface (GUI), and 3. IBM s Live Parsing Editor 
(LPEX).  ACE is the heart of AnnoDomini. It is written in Stan- dard ML and consists of about 60,000 
lines of code, of which about 25,000 are generated from lexing and parsing speci- fications using ML-Lex 
and ML-Yacc. LPEX is a syntax- sensitive program editor developed by IBM and delivered with its VisualAge 
series of software development tools. The GUI is written in Visual Basic and consists of about 10,000 
lines of code. It interacts with the user and provides ac-cess to both ACE and LPEX. Communication with 
ACE is through files that pass parameters from the GUI to ACE and return results to the GUI for presentation 
to the user. Com-munication with LPEX is through REXX macros, which po- sition the cursor in LPEX at 
a particular source code line. They are also used to insert TS2K annotations and to gen- erate the code 
during actual conversion. Every time the GUI invokes ACE, ACE processes the whole program under consideration 
from scratch. This batch architecture makes AnnoDomini fault-tolerant and allows for a simplified software 
architecture. It also means that the state of a conversion project is completely represented -and documented 
-by the annotated programs themselves. The cost is that a complete pass with lexing, parsing and type 
checking is required each time a type check is initiated. This appears to be acceptable in practice since 
AnnoDomini operates on one program at a time and Year 2000 problems discovered are eliminated in groups. 
An untuned version of AnnoDomini takes about 30 seconds to process a 10,000 line program on a 133MHz 
PC with 64 MBytes of RAM. Conclusion We have presented the type-theoretic foundations and asso- ciated 
practical aspects of AnnoDomini, an integrated find- and-fix tool for making COBOL programs Year 2000 
com-pliant. The underlying software reengineering method consists of identifying and isolating potentially 
problematic data and their associated operations according to their intended use (here as calendar years), 
encapsulating them as abstract types, and finally replacing their implementation by safe, improved code 
with the same interface. This method ap-pears to be eminently applicable to other problems than Year 
2000 remediation, such as reengineering financial sys-tems for the introduction of the Euro or for the 
Dow Jones Index passing the 10,000 mark. References <RefA>[AP89] Habib Abdulrab and Jean-Pierre Pecuchet. Solv-ing 
word equations. Journal of Symbolic Compu-tation, 8(5):499-521, November 1989. [DM82] L. Damas and R. 
Milner. Principal type schemes for functional programs. In Proc. 9th Annual ACM Symp. on Principles of 
Programming Languages, pages 207-212, January 1982. [Haf98a] Hafnium ApS. AnnoDomini Version 1.0 for 
IBM OS/VS COBOL -Reference Manual, 1st edition, 1998. See http://www.hafnium.com. [Haf98b] Hafnium ApS. 
AnnoDomini Version 1.0 for IBM OS/VS COBOL -User s Guide, 1st edition, 1998. See http://www.hafnium.com. 
[IBM861 IBM. IBM VS COBOL for OS/W, Release 2.4, 5th edition, September 1986. Dot. no. GC26-3857- 4. 
[Jon981 Capers Jones. The Year 2000 Software Problem -Quantifying the Costs and Assessing the Conse- 
quences. Addison-Wesley, ACM Press, 1998. ISBN o-201-30964-5. [Mi178] R. Milner. A theory of type polymorphism 
in programming. J. Computer and System Sciences, 17:348-375, 1978. [OJ97] R. 0 Callaha.n and D. Jackson. 
Lackwit: A program understanding tool based on type infer-ence. In Proc. 1997 International Conference 
on Software Engineering (ZCSE 97), Boston, Mas-sachusetts, pages 338-348, May 1997. [RFT99] G. Ramalingam, 
John Field, and Frank Tip. Ag-gregate structure identification and its application to program analysis. 
In These proceedings, Jan-uary 1999. [vDM98] Arie van Deursen and Leon Moonen. Type infer-ence for COBOL 
systems. To appear in Proc. 5th IEEE Working Conference on Reverse Engineer-ing, Honolulu, Hawaii, October 
1998. Permission to make digital or hard copies ofall or par! of this work for pcrwnal or classroo~~~ 
use is granted withc~t fee procided that copies are not made or tlistrihutcd Or prolit or commercial 
advantage and that topics bear this notice and the full citation on the first page. fo copy otherwise. 
to republish. to post on sewers or to redistribute to lists, require5 prior specific prrrnisswn anJ:or 
a Tee. POPL 99 San Antonio Texas USA Copyright ACM 1999 l-581 13-095-3199/01...$5.00 </RefA>  
			

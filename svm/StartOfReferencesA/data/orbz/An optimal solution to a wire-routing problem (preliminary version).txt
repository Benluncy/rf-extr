
 AN OPTIMAL SOLUTION TO A WIRE-ROUTING PROBLEM (preliminary version) Martin Tompa Department of Computer 
Science, FR-35 University of Washington Seattle, Washington 98195 U.S.A. ABSTRACT A wire-routing problem 
which arises commonly in the layout of circuits for very large scale integration (VLSI) is discussed. 
Given the coordinates of terminals Ul, u2, ..., u n of one component and Vl, v2, ..., v n of another, 
the U.U U. U U  problem is to lay out n wires so that the ith wire connects u i to vi, and adjacent 
wires are separated at least by some fixed distance The solution with minimum wire length is characterized, 
and an optimal algorithm which constructs it is presented. i. DESCRIPTION AND MOTIVATION OF THE PROBLEM 
 Wire-routing problems arise in the layout of circuits for very large scale integration (VLSI) and similar 
technologies. The extreme density of VLSI circuitry (currently tens of thousands of transistors per chip, 
and potentially millions [4]) motivates the study of automatic layout procedures for commonly arising 
situations. This paper analyzes the situation depicted in figure 1 and presents a solution which is optimal 
in several senses. Permission to copy without fee all or part of this material is granted provided that 
the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and 
the title of the publication and its date appear, and notice is given that copying is by permission of 
the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific 
permission. &#38;#169; 1980 ACM 0-89791-017-6/80/0400/0161 $00.75 \ A v I v 2 v 3 v 4 v 5 + Figure 
I: Two component circuits to be connected  Two components of the final circuit have been designed and 
their locations have been specified. Given the coordinates of n colinear terminals Ul, u2, ..., u n of 
one and n colinear terminals Vl, v2, .., v n of the other, n wires are to be laid out so that the it_h_ 
wire connects u i to vi, and adjacent wires are separated at least by some minimal distance d. It is 
easy to see from figure I that straight lines from u i to vineed not satisfy these constraints, even 
if adjacent terminals are known to be separated by distance d. A solution to this problem has been suggested, 
each of whose wires is composed of up to 2n horizontal and vertical straight line segments [3]. This 
solution has the drawback that it minimizes neither individual wire lengths nor total wire length. .......................... 
This material is based upon work supported by the National Science Foundation under Grant MCS77-02474. 
 161  (The former affects the time required by the circuit and the latter affects the chip area; both 
are fundamental VLSl resources.) For instance, such a solution will not construct straight diagonal wires 
connecting the terminals, even if such wires are sufficiently separated. This objection may seem trifling; 
after all, it would appear that the simple rectilinear solution yields wire length at most a factor of 
~ from optimal. Such is not the case, however, as this suboptimality may manifest itself in a more serious 
way. Suppose, for example, that n=5, u i = ((i-l)d,0), and v i = (id,3d), for 1 < i < 5. The rectilinear 
algorithm would begin by constructing the first four wires as illustrated in figure 2. I 3d )  Figure 
2: An unsuccessful interconnection attempt As is evident, the fifth wire cannot be accomodated, and 
the algorithm would terminate unsuccessfully, despite the fact that figure 3 demonstrates the existence 
of a layout which satisfies the constraints. Section 2 characterizes the minimum wire length layout 
for any set of terminals. This optimal layout has several surprising aspects: I. Each wire is composed 
of straight llne segments and arcs of circles of varying radii. 2. The simple and necessary constraint 
that each wire remain sufficiently distant only from other terminals (lemma I) is shown to 13 Figure 
3: A successful interconnection be sufficient to guarantee that all wires are properly separated. 3. 
Because of 2, each individual wire is as short as possible given the constraints imposed only by the 
locations of the 2n terminals. Hence individual wire lengths (time) and total wire length (area) are 
simultaneously optimized.  Section 3 presents a (time-) optimal algorithm which constructs the optimal 
layout. Unlike the rectilinear algorithm, this one is guaranteed to produce a layout if one exists. As 
a by-product, linear time algorithms are developed in sections 3.1 and 3.3 for constructing the minimum 
length single wire which avoids n obstacles of a certain restricted type. These algorithms have obvious 
applications to a problem in robotics as well. Sections 2 and 3 deal with the simplest version of a 
very general layout problem. Section 4 mentions some extensions: I. Only straight llne wire segments 
are permitted, but near optimal layouts suffice. 2. Only relative distances within each of the two sets 
of terminals are fixed, and the components themselves are free to move.  3. Minimum separation requirements 
between pairs of wires are not all equal.   2. DESCRIPTION OF THE OPTIMAL LAYOUT One necessary constraint 
is evident from the statement of the wire-routing problem: wire i must 162  remain outside the four 
circles of radius d with arcs. Figure 5 illustrates the optimal layout for centers at Ui_l, Ui+l, Vi_l, 
and vi+ 1 . The the components of figure i. following lemma shows that other terminals are responsible 
for additional constraints on wire i: Lena I: In any solution to the wlre-routing problem, wire i must 
remain outside the circles of radius lj-ild with centers at uj and vj, for all 1 < j < n. Proof: Suppose 
a point p on wire i is less than Jj-ild distant from a terminal, say vj, of  Figure 5: An example of 
the optimal wire layout wire j, as illustrated in figure 4. The remainder of this section is devoted 
to a i proof of the sufficiency of lemma I. ~l- Definition: Let P be a segment of a continuous curve. 
Let q be a point not on P, let p be a point on P which is not an endpoint of P, and suppose p partitions 
P into segments P1 and P 2. Then P is said to be convex toward R at ~ iff for all neighborhoods N of 
p there exist points Pl ~ N~PI and P2 ~ NOP2 such that the straight llne Figure 4: Wire i passing too 
close to terminal vj. segments pq and plP2 do not intersect. The lj-iI+l wires with labels between 
i and j must  (Notice that this classifies points of pass between p and vj, but the distance between 
 inflection, i.e. points where the curvature changes these two points is insufficient to permit these 
 from convex to concave, as convex toward any wires to be adequately separated. external point.) It 
is perhaps surprising that if the shortest  Lemma 2: Let P and Q be continuous, interconnecting wires 
are laid out subject to the non-intersecting curve segments. Suppose D is the terminal constraints of 
lemma I, they will be least distance separating any point on P from any adequately separated at non-terminal 
points as point on Q, and let p E P and q ~ Q be arbitrary well. Before proving this fact, a description 
of points separated by distance D. Then at least one the minimum length layout is in order. Imagine 
 of the following holds: that wire i is an elastic whose ends are fixed at I. p is an endpoint of P, 
or u i and v i and which must circumvent circular 2. q is an endpoint of Q, or barriers with radii and 
centers as prescribed by 3. P is convex toward q at p, or lemma I. When pulled taut, the elastic describes 
 4. Q is convex toward p at q, or the path of the minimum length wire. In  particular, that wire is 
composed of circular arcs 5. there are neighborhoods of p and q within which P and Q are parallel straight 
llne and segments of straight llne tangents to those segment s. 163 Proof: Let pEP and q( Q be of distance 
D and not satisfy any of 1 - 4. Suppose the straight line segment pq partitions P and Q into PI' P2 
and QI' Q2' respectively. Let Np and Nq be neighborhoods of p and q, respectively, such that for all 
Pl E NAP I, P2 G Np~P2, ql ~ Nq~QI' and q2 ~ NqNQ2, the straight line segments plP2 and qlq2 each intersect 
pq. (Such neighborhoods exist by the definition of "convex toward".) For i {1,2}, let L i be any straight 
line parallel to pq which intersects both Np~P i (say at pi ) and Nq~Qi (say at qi ) (see figure 6). 
 \ P L 1 ql P q D 12 I 2 /Q Figure 6: An untenable example Since plP2 and qlq2 each intersect pq, 
and since p and q are of minimal distance D apart, Pl and ql must be of distance D, and likewise P2 and 
q2" Thus, within small neighborhoods of p and q, P and Q must be parallel straight llne segments. G 
Corollary 3: Let P and Q be continuous, non-intersecting curve segments. Suppose D is the least distance 
separating any point on P from any point on Q. Then there exist points P0 ~ P and q0 ~ Q separated by 
distance D such that at least one of the following holds: I. P0 is an endpolnt of P, or 2. q0 is an 
endpoint of Q, or  3. P is convex toward q0 at P0' or  4. Q is convex toward P0 at q0"  Proof: Let 
pEP and qGQ be of distance D and not satisfy any of I - 4. By lemma 2, there are neighborhoods of p and 
q within which P and Q are parallel straight llne segments. By moving p and q along these parallel 
segments (in either direction, but maintaining distance D between them) to the first pair of points 
P0' q0 at which arbitrarily small neighborhoods of either P0 or q0 are no longer straight line segments, 
lemma 2 guarantees that one of 1 - 4 must hold for P0' q0" Theorem 4: If the minimum length wires are 
lald out subject to the constraints of lemma I, each pair of adjacent wires will be separated by distance 
at least d. Proof: Suppose adjacent wires i and i+l have minimum separation D. By corollary 3, we may 
assume that there are points P0 and q0 on wires i and i+I, respectively, of distance D such that one 
 of the following holds: Case I: q0 is one of the terminals ui+ 1 or vi+ I. Then lemma 1 guarantees 
that D ~ d, since no point on wire i lies within a circle of radius d and center q0" Case 2: Wire i+l 
is convex toward P0 at q0" This can occur only if q0 lies on a segment of wire i+l which is a circular 
arc of radius (j-i-l)d with center at either uj or vj, for some j > i+l. Once again lemma 1 guarantees 
that D ~ d, since no point on wire i lies within a circle of radius (j-i)d with the same center. Case 
3: P0 is one of the terminals u i or v i- Analogous to case I. Case 4: Wire i is convex toward q0 at 
P0" Analogous to case 2. D 3. AN OPTIMAL ALGORITHM FOR CONSTRUCTING THE OPTIMAL LAYOUT Any algorithm 
which constructs the layout described in section 2 must use~n) time per wire, since each wire may contain 
that many segments.  164 (The same is true of the rectilinear layout mentioned in section i.) This 
section presents an algorithm which uses O(n) time per wire, and so is optimal to within a constant factor. 
 In determining the layout of the it__h wire, it is conceptually convenient to consider the problem as 
finding the shortest path for a point traveling from u i to v i which avoids the semicircular obstacles 
described in lemma i. (This is a special case of a problem in robotics; seer for example, [2, 5].) Adopting 
the approach of Lozano-P~rez and Wesley [2], we might construct tangents between every pair of obstacles, 
remove those tangents which are obstructed by obstacles, and use a shortest path algorithm on the resulting 
graph, with tangents and arcs of circles weighted by their Euclidean lengths. This algorithm certainly 
will not run in time which is linear in the number n of obstacles, as the resulting graph may have 8(n 
2) vertices. In fact, because of considerations of computations involving radicals [I] (further complicated 
here by a transcendentall), it is not even clear that the resulting algorithm would run in time polynomial 
in n. A more promising approach is to start with a straight line from uito vi, and incrementally adjust 
this path by circumventing any obstacle which obstructs it. It is not difficult to see that this may 
require ~n) passes over the list of obstacles. The algorithm presented in this section succeeds in attaining 
efficiency by exploiting certain particulars of the obstacles which arise from lemma I. In order to highlight 
the relevant particulars and suppress others, section 3.1 describes an O(n) algorithm for the simpler 
case in which the n obstacles are line segments of varying lengths which protude from the two lines of 
terminals. Sections 3.2-3.5 return to the case of semicircular obstacles. For ease of description throughout 
section 3, it is assumed that the terminals are on horizontal lines. This admits the use of such descriptive 
 "ri hi" "up", "down", terms as "left", g , "upper", and "lower". Any obstacle which protrudes down 
from the upper line of terminals will be called a stalactite, and any obstacle which protrudes up from 
the lower line of terminals a stalagmite. If P and Q are two points, then PQ denotes the ray with endpoint 
P which passes through Q, and FQ the llne segment with endpoints F and Q. 3.1. The Shortest Path Avoiding 
Straight Line Obstacles This section describes an 0(n) algorithm for constructing the minimum length 
path between two points that avoids n vertical straight llne obstacles. It is convenient to dispose of 
the two horizontal lines from which the obstacles protrude and instead imagine that the straight line 
obstacles continue to +co or -,,o, depending upon whether they are stalactitic or stalagmitic, respectively. 
Before presenting the algorithm, it may help to see how it works on an example. Figure 7 shows the algorithm 
in progress on an example with 6 obstacles. / / / I ) m 3  A Im 2 Figure 7: Finding the shortest 
path from A to ~ which avoids vertical obstacles  165 The obstacles are processed left to right, and 
the algorithm is prepared to process obstacle M 2. The diagonal lines constructed by the algorithm represent 
extremes of visibility as restricted by obstacles processed so far; for example, A can "see" only points 
between the rays AI and AE. The algorithm's next task is to determine in which of the four regions of 
visibility to the right of the dashed line the endpoint F of obstacle M 2 lles. Since M 2 is stalagmitic 
the regions are searched bottom to top, and the algorithm discovers that F lies above AE, above AI, but 
below IJ. Therefore IF is added as a lower extreme of visibility for I, the rays AE and AI are deleted, 
and I is added to the minimum length path from A to Z (since A cannot "see" the top of M2). The complete 
algorithm is given below, followed by proofs of correctness and analysis. Each obstacle is identified 
by its protruding endpoint, plus a flag which identifies it as stalactitic or stalagmitic. Since the 
rays of visibility are at some times searched from the top and at other times from the bottom, they are 
stored on a deque (double-ended queue). Each entry on the deque is a quadruple <Ci,P1,C2,P2> which represents 
one ray of visibility, where PiP2 is the ray and, for iE{l,2}, C i is a flag with values from {'T', 
"M', "A'} depending upon whether Pi is the endpoint of a stalactite, the endpoint of a stalagmite, or 
 A, respectively. Al~orithm Line-0bstacles: Input s : A = (xA, yA), Z = (xZ,y Z) (endpoints to be connected), 
and xT[l::p], yT[l::p], xM[l::q], yM[l::q]  (obstacle descriptors). Constraint s:  < < < < % < xz 
and Stalactitic obstacle T i is  (xy) and YZ Stalagmitic obstacle M i is {(x,y)Ix=x~ and y~ y~}. 
 Outputs: minimum length path P0' Pi' "''' Pr from P0=A to Pr=Z which avoids all obstacles: the Pi are 
points, and PiPi+l are the straight line segments which form the path. Local data structures: l-dimensional 
array V and a deque, each initially empty. procedure: I. Merge (according to abscissa) Ti, T2, ..., 
Tp and Mi, M2, ..., Mq into a single list. Add a stalagmite and a stalactite to the end each with endpoints 
Z. Let Vi, V2, ..., Vn+ 2 be the resulting sorted list of obstacles. 2. Output P0 = (xA'~)" Add the 
quadruple <'A',(xA,~),'T',(xA,+~)> to the top of the deque, and <'A',(xA,yA),'M',(xA,-~)> to the  bottom. 
(By convention, any point lies below the ray (x,y)(x,+~) and above the ray (x,y)(x,-~), for any x and 
y.)  3. For i from 1 to n+2 do  a. If V i is a stalactite Tk:  i. Remove each entry <C,P,D,Q> from 
the top  of the deque for which T k intersects the ray ~. If in addition D='M', output Q. li. Suppose 
the top of the deque is <C,P,D,Q>. If D='T" add <D,Q,'T' T T ,(xk,Yk)> to the top of the deque, otherwise 
add , T T <C,P, T ,(xk,Yk)> to the top of the deque. iii. Add < T ,(Xk,Y k) , T T ,'T',(x~,+~)> 
to the top of the deque.  b. Else V i is a stalagmite Mk:  i. Remove each entry <C,P,D,Q> from the 
  bottom of the deque for which M k intersects  the ray PQ. If in addition D='T', output Q. ii. Suppose 
the bottom of the deque is <C,P,D,Q>. If D='M" add <D,Q,'M', M M (xk,Yk)> to the bottom of the deque, 
otherwise add <C,P,'M" M M ,(xk,Yk)> to the bottom of the deque. M M " " (x~,-~)> the iii. Add <'M',(xk,Yk) 
, M , to bottom of the deque.  Theorem 5: Algorithm Line-Obstacles correctly determines the minimum 
length path from A to Z which avoids all obstacles. Proof: By induction on the value of the  iteration 
counter i in step 3, it is straightforward to establish that the deque always has the form (from top 
to bottom) <'T',(Xt_l,Yt_l),'T',(xt,Yt)>, <'T',(xt_2,Yt_2),'T',(Xt_l,Yt_l)>, 'T',(xl,Yl),~T',(x2,Y2)>, 
- ,(x;y)7"T',(Xl,91)> , < -,(x,y),'M',(w],z])>, <'M',(Wl,Zl),'M',[w27z2)>,  <'M',(Wm-l,Zm-l),'M',(Wm,Zm)>, 
where i. x < x I < x 2 < ... < x t and  x Z wl Z w2 Z Z Wm  2. (x,y) was the last point output, and 
 3. if <C,P,D,Q> is on the deque during the ith iteration of step 3, there is no obstacle which obstructs 
the segment of the ray P~ between the abscissa of P and the abscissa of Vi, with the possible exception 
of V i. (An obstacle V is said to obstruct a line segment L if L intersects V at a point other than the 
endpoint of V.)  Assuming that (x,y) is on the shortest path from A to Z that avoids all obstacles, 
it will be shown that the straight line segment between (x,y) and the next point output is on that shortest 
path as well. Assume (by symmetry) that when the next output is produced the obstacle being processed 
is a stalactite T k. In order for the algorithm to output, the top of the deque must be of the form 
<-,(x,y),'M',(Wl,Zl)>, where (x,y) is on the shortest path from A to Z and T k intersects the ray (x,y)(wl,z;) 
(see figure 8). Figure 8: Algorithm Line-Obstacles about to output  Since no obstacle obstructs the 
segment of (x,y)(wl,z ~) between x and XkT, the shortest path from (x,y) past T k contains the line 
segment (x,y)(wl,Zl). (This is most easily seen by again appealing to an argument about elastics similar 
to the one in section 2.) a Notice that, although as many comparisons may  be performed for a given 
obstacle as there are entries on the deque at the time it is processed, each comparison deletes an 
entry for future obstacles. The following theorem formalizes this into a proof that the algorithm runs 
in linear time. Theorem 6: Let n p+q be the number of  obstacles input to algorithm Line-Obstacles. 
Then the total number of comparisons which check whether an obstacle intersects a ray is 3n+5. Proof: 
Let t i be the number of comparisons made during the it h iteration of step 3, and r i be the number 
of entries on the deque preceding the ith iteration. Then r I =2, rn+ 3 = 3, and  ri+ 1 = r i -t i 
+ 3, so the total number of comparisons is n+2 n+2 ~t i = i=~l(ri-ri+l+3) = rl-rn+3+3(n+2) i=l = 3n+5. 
Q  The total number of comparisons needed is in fact only 2n+3, since the first comparison for each 
obstacle is unnecessary. Since the total running time is proportional to the number of such comparisons, 
the algorithm runs in linear time. It is a curious property of algorithm Line-Obstacles that, although 
the rays are ordered on the deque so as to make binary search possible, this would result in a less efficient 
algorithm than the sequential search used. 3.2. An Overview of the Entire Wire-Routlng Algorithm A 
moment's reflection shows that algorithm Line-Obstacles of section 3,1 does not make much use of the 
fact that the obstacles have width 0. In fact, it would seem to work for the semicircular obstacles of 
interest, if the rays of visibility are chosen to be tangents to those obstacles. There is a rather severe 
impediment, however, and that is that it is not clear in which order the obstacles should be processed. 
Not only may obstacles protruding from the same line of terminals overlap, but it is also not easy to 
determine the order in which to process a stalactite and a stalagmite which are near each other. These 
impediments are overcome by adapting a general strategy of Shamos and Hoey [6] for imposing an order 
on geometric objects. First a "hidden llne elimination" is performed on the set of stalactitic semicircles, 
and independently on the set of stalagmitic semicircles, finding intersection points of overlapping semicircles 
in the process. This results in a new but equivalent set of obstacles, called the silhouette, which is 
 comprised of non-overlapping segments of semicircles (see figure 9). The stalagmitic segments are further 
subdivided by vertical lines at the abscissas of all the stalactitic obstacles' endpoints, and vice versa. 
The result is a set of semicircular segments which are vertically "aligned". Figure 9 shows an example 
of this process on 5 semicircular obstacles which are ultimately decomposed into 18 obstacles.  II 
I  Figure 9: Semicircular obstacles, their silhouettes and their aligned segments The only re~inlng 
problem of order is for the stalactite-stalagmite pair within each aligned segment; the solution to 
this is deferred to the next section. The sections which follow give more details of the algorit~. Section 
3.3 extends t~ O(n) algorlt~ Line-Obstacles of section 3.1 to aligned semicircular segments. Section 
3.4 discusses an O(n) algorithm for silhouetting. Finally, the entire wire layout algorithm is given 
in section 3.5. 168 3.3. The Shortest Path Avoiding Obstacles which are Aligned Semicircular Segments 
 As in section 3.1, it is convenient to dispose of the two horizontal lines of terminals and instead 
imagine that the segments continue vertically to +o o or -~o, depending upon whether they are stalactitic 
or stalagmitic, respectively. Once again a deque is employed, each of whose entries is a quadruple 
<Ci,Pi,C2,P2> representing one ray PiP2 of visibility: for i 6{1,2}, C i is either the initial point 
A, a stalactite T k, or a stalagmite M k, and PiP2 is tangent to C i at Pi" A few words of explanation 
are in order. Each obstacle should really be represented as a pair (e.g. <'M',k>) but M k is used here 
for brevity. Notice also that the term "tangent", as used in this section, means a tangent to the semicircular 
segment, which is not necessarily a tangent to the associated circle. Given C 1 and C2, the points PI 
and P2 of common tangency can still be computed in constant time, even under thls notion of tangency. 
 Algorithm Circle-Obstacles: Inputs: A = (xA,yA), Z = (xZ,y Z) (endpoints to be connected), n (number 
of obstacle pairs), and x[0::n], xT[l::n], yT[l::n], rT[l::n], xM[l::n], yM[l::n], rM[l::n]  (obstacle 
descriptors). Constraints: xA <__ Xo ~_ Xl ! "'" <__ Xn <-- xZ" Stalactltlc obstacle T i is {(x,y) 
Jxi_ 1 < x < xl, and either y > or (x4) 2 + (, y )2 < Stalagmitlc obstacle M i is {(x,y) Jxi_ 1 < 
x < x i, and either  y -< yr or รท (y-,r) < T 0, or T i must be convex: either r i =  r; and 'xi-4' 
r;. M i must be convex: either r~ = 0, or  IXl_l-Xi M] < r~ and Ixi-xiMl < r~. Outputs: minimum length 
path CO, P0' Q0' Cl' PI' QI' "''' Cr, Pr' Qr from C0=Po=A to Qr=Z which avoids all obstacles. Pi and 
Qi are points and each C i is a triple (x,y,r) which describes the center and radius of a circle. The 
shortest path is composed of the straight line segments PiQ i and the arcs of circles Ci+ 1 from Qi 
to Pi+l Local data structure: a deque, initially empty. Procedure: I. (Initialize) Output C O = (xA,~,O). 
Add <A,(xA,~),Tee,(xA,+~)> to the top of the deque, and <A,(xA, yA),Mee,(xA,-e~)> to the bottom. (By 
 convention, any point lies below the ray (x,y)(x,+eo) and above the ray ix,y)(x,-~), for any x,y.) 
2. For i from I to n do a. If T i intersects M i in more than I point, then no wire-routing is possible. 
 b. Searching sequentially from the top of the deque (but without altering the deque), let <C,P,D,Q> 
be the entry nearest the top such that T i lies completely above the ray PQ. If D is stalactitic, let 
RS be the straight line  segment which is tangent to D at R and to T i at S; otherwise let RS be the 
straight line  169 segment which is tangent to C at R and to T i at S. If Miintersects RS in more 
than 1 point, then reverse the order of steps c and d below. c. (Process T i)  i. Remove each entry 
<C,P,D,Q> from the top of the deque for which Tiintersects the ray P~. If in addition D is a stalagmite 
Mk,  . M M M. output P, Q, Lxk,Yk,rk). ii. Suppose the top of the deque is <C,P,D,Q>. If D is stalactitic, 
add <D,R,Ti,S> to the top of the deque, where the straight line RS is tangent to D at R and to T i at 
S. Otherwise add <C,R,Ti,S> to the top of the deque, where the straight line RS is tangent to C at R 
and to T i at S. iii. Add <Ti,(xi,yiT),T~,(xi,+~)> to the top of the deque.  d. (Process Mi)  i. Remove 
each entry <C,P,D,Q> from the bottom of the deque for which Miintersects the ray P~. If in addition D 
is a stalactite  , T T r T. Tk, output P, Q, tXk,Yk, k ). ii. Suppose the bottom of the deque is 
<C,P,D,Q>. If D is stalagmitic, add <D,R,Mi,S> to the bottom of the deque, where the straight line RS 
is tangent to D at R and to M i at S. Otherwise add <C,R,Mi,S> to the bottom of the deque, where the 
straight line RS is tangent to C at R and to M i at S. iii. Add <Mi, (xi, y~) ,M~, (xi,- ~)> to the 
bottom of the deque.  3. (Process Z) i. Remove each entry <C,P,D,Q> from the top of the deque for which 
Z lies on or below the ray PQ. If in addition D is a stalagmite Mk, M M M output P, Q, (xk,Yk,rk). 
 ii. Suppose the top of the deque is <C,P,D,Q>. If D is stalagmitic output R, where the straight line 
RZ is tangent to C at R. T Otherwise add <D,(xn,Yn),T~,(Xn,+~)> to the top of the deque. iii. Remove 
each entry <C,P,D,Q> from the bottom of the deque for which Z lies on or above the ray ~. If in addition 
D is a T T T stalactite Tk, output P, Q, (xk,Yk,rk). iv. If the deque is not empty, its one entry 
will be <D,P,T~,Q>. Output R, where the straight line RZ is tangent to D at R.  v. Output Z.   Theorem 
7: Algorithm Circle-Obstacles correctly determines the minimum length path from A to Z which avoids all 
obstacles. Proof: By induction on the value of the iteration counter i in step 2, it is straightforward 
to establish that the deque always has the form (from top to bottom) <Tjt-l' PJt-l' Tjt' QJt-i >' <Tjt-2' 
Pit-2' Tjt-l' QJt-2 >' <TjI' PJI' TJ2' QJl >' <S, PJo' Tji' QJo >' <S, Pi0, Mil, Qi0 >, <Mi I, Pi 
I, Mi 2, Qil>,  <Mim_ I' Pim_ I' Mi m, Qim_l >, where i. Jl < J2 < "'" < Jt and i I < i 2 < ... < im, 
and 2. S is either A, or Tjo with J0 < Jl' or Mi0with 170 i 0 < il, and the last output was the circle 
 associated with S.  Unlike theorem 5, in this case it is not as straightforward to establish the important 
property that 3. If <C,P,D,Q> is on the deque when obstacle V is processed and V intersects PQ at some 
point H, then H is not on the line segment PQ, and no obstacle (with the possible exception of V) obstructs 
the llne segment PH. (An obstacle V is said to obstruct a line segment L if L intersects V at a point 
not on the perimeter of V.) Assuming this property is true through the  beginning of the it h iteration 
of step 2, it will be shown true throughout that iteration as well. Suppose <C,P,D,Q> is on the deque 
at the beginning of the it h iteration. By hypothesis P~ is unobstructed between P and xi_ I. The proof 
that steps 2.c.i and 2.d.i remove every ray which T i and M i (respectively) obstruct has a direct analogue 
in the proof of theorem 5, and is as straightforward. In addition, if <C,P,D,Q> is added to the deque 
during the it h iteration of step 2 (i.e., D=T i or D=M i), the proof that no obstacle obstructs the 
 segment of PQ between P and Xi_lalSo has a direct analoque in the proof of theorem 5, and is as st raight 
forward. What remains is to demonstrate that T i and M i do not interfere with each other; this is the 
reason for the test in step 2b which decides the order of steps 2c and 2d. Suppose U is the first of 
the obstacles T i and M i to be processed, and V is the second. It must still be demonstrated that i. 
Property 3 holds when U is being processed; that is, if <C,P,D,Q> is on the deque when U is being processed 
and P~intersects U at H, then V does not obstruct the line segment PH. 2. Property 3 holds when V is 
being processed; that is, if <C,P,U,Q> is added to the deque, then V does not obstruct the line segment 
PQ.  3. Property 3 holds when future obstacles are being processed; that is, if <C,P,V,Q> is added to 
the deque, then U does not obstruct the ray PQ.  Let RS be the tangent to T i as constructed in step 
2b, and R'S" be the analogous tangent to M i. (That is, the deque entry for Tiwould be of the form <-,R, 
Ti,S> if M i did not intersect RS, and the entry for M i would be <-,R',Mi,S'> if T i did not intersect 
R'S'.) A corollary of the form of the deque and the induction hypothesis is that no pair of rays present 
on the deque at the beginning of the it h iteration of step 2 intersect to the right of Xi_l; consequently 
neither do RS and R'~. The proof that M i and T i do not interfere with each other breaks into 2 cases, 
depending on the outcome of step 2b: Case I: Step 2d precedes step 2c. This means that M i obstructs 
R'~ (let E-~ be Mi~) and an entry of the form <-,R',Mi,S'> is made on the deque in step 2.d.il. Let PH 
be any ray with HUM i which doesn't intersect R~ to the right of xi_ I (see figure I0); notice that this 
also includes the case where P=R' and H=S'. l{t ~ I xi-1 I in I i~ ',xi M i T i  Figure I0: Suppose 
T i intersected the line segment PH at G. Since M i is convex and EF and H are contained in Mi, the entire 
triangle EFH is contained in M i. Similarly, since Tils convex the llne segment GS is contained in T 
i. This can only occur if M i and T i intersect in more than one point, and such cases have already been 
eliminated in step 2a. It is true, however, that T i must obstruct the ray R'~' to the right of S', 
since M i obstructs the llne segment RS, and RS and R'~" do not themselves intersect to the right of 
xi_ I. When T i is subsequently processed in step 2.c.i, all entries except <Mi,(xl,Y~),M~9,(xi,-~)> 
are removed from the deque, and the tangent to T i in step 2.c.li is from Mi, that is, it has the form 
<Mi,P,Ti,Q>. Certainly M i does not obstruct PQ in this ease, since PQ is tangent to M i. Case 2: Step 
2c precedes step 2d. Then M i does not obstruct R'~ and an entry of the form <-,R,Ti,S> is made on the 
deque in step 2.c.li. There are two subcases: Case 2.1: M i obstructs RS to the right of S. Let EF be 
MileRS. Let P~ be any ray with HET i which does not intersect R~ to the right of xi_ I (see figure II). 
T i ~i  Figure 11: Arguments analogous to those given in case 1 show that M i cannot intersect the llne 
segment PH, and that the tangent to Miadded in step 2.d.ii is from Ti, and hence unobstructed by T i. 
Case 2.2: M i does not obstruct RS (see figure 12). i~ ~ @ ~ .~--. f ~i Ix i Xi-I ~ " I Figure 12: 
 Then R'S" is below RS to the right of Xi_l, and consequently M i does not obstruct the segment PH of 
any existing ray that has H ~T i. Also, an entry of the form <-,R',Mi,S'> is added to the deque in step 
2.d.il, and Ticannot obstruct R'S'. The remainder of the proof is analogous to that of theorem 5. Assuming 
that some arc of the circle associated with S is on the shortest path from A to Z that avoids all obstacles, 
it will be shown that some arc of the next circle D output together with the tangent from S to D is 
on that shortest path as well. Assume (by symmetry) that when the next output is produced the obstacle 
being processed is a stalactite T k. The top of the deque must be <S,Pi0,Mil,Qio> , where T k intersects 
the 3.4. Silhouetting Circles with Colinear Centers ray PioQi0 , say at point H. Since no obstacle 
(with the possible exception of Tk) obstructs the line segment Pi'oH , and H is to the right of Qio, 
the shortest path from S past T k contains the arc of the circle associated with S up to Pi0 and the 
 line segment Pi0Qi 0 (see figure 13). O Pi O i O Figure 13: Algorithm Circle-Obstacles about to output 
 Theorem 8: The total number of comparisons in which algorithm Circle-Obstacles checks whether an obstacle 
intersects a straight line is no greater than 12n + 6. Proof: Let t i be the number of such comparisons 
made during the ith iteration of step 2, and r i be the number of entries on the deque preceding the 
ith iteration. There are two cases, depending upon the outcome of the final test in step 2b: Case I: 
M i does not intersect RS (the tangent to T i) in more than 1 point. Then ri+ 1J r i -ti/2 + 6 (the 
factor of 1/2 due to the fact that the comparisons in step 2b are repeated in step 2c), or t i ~ 2(ri-ri+l+6) 
 Case 2: M i intersects RS (the tangent to T i) in more than i point. Then ri+l=3 (see the proof of theorem 
7) and t i ~ 2ri+4 , so again t i 2(ri-ri+l+6). With the end conditions rl=2 and rn+ 1 > 0, n n ~ t 
i ~ 2~ (ri-ri+l +6) = 2(rl-rn+l+6n).  i=l i=l Since step 3 makes at most rn+ 1 + 2 comparisons, the 
total number is at most 2r I - rn+ 1 + 2 + 12n ~ 12n + 6.  This section presents the details of an 
O(n) algorithm for the silhouetting of n circles with colinear centers, as described in section 3.2. 
Silhouetting is the only part of the entire procedure which makes essential use of the fact that the 
terminals are on straight lines, and that the constraints are circular. Algorithm Silhouette Inputs: 
 x[l::n] (abscissas of circle centers), r[l::n] (radii of circles), and S (a stack).  Constraints: x 
I ~ x 2 ~ ... ~ Xn, and S is empty. Outputs: Upon completion, S contains a description of the silhouette 
of circles Ci, C2, ..., Cn, where C k has center at (Xk,0) and radius rk, for 1 < k < n. In particular, 
S will have the form (from top to bottom) <0,P0> , <kl,Pl> , <k2,P2> , .., <km,Pm>, <0,(+~,0)>, where 
the silhouette contains the arc of Ckj from point Pj-i to point Pj, if kj#O. An entry with kj=O indicates 
that the interval from Pj-i to Pj is contained in none of the circles.  Procedure: 1. Push <0,(+~,0)> 
onto S.  2. For j from n to 1 by -I do  a. Pop each entry <k,P> from the top of S for which P is on 
or within the circle Cj.  b. Suppose the top of S is <k,P>. If k=O then push <j,(xj+rj,0)> onto S; 
 else if x~+rj < xk-r k then push <0,(xk-rk,0)> onto S, and push<j,(xj+rj,O)> onto S; else if xj-rj 
< xk-r k then push <j,Q> onto S, where Q is the point of intersection of Cjand  173 C k which has non-negative 
ordinate. 3. Push <0,(Xm-rm,0)> onto S, where m minimizes x -r . m m  Theorem 9: Algorithm Silhouette 
correctly determines the silhouettes of circles Ci, C2, ..., C . n Proof: The proof follows from a 
simple trigonometric fact: if r ~ 0 and x ~ 0 are fixed, the distance between the two points with polar 
coordinates (r,8) and (x,t) decreases as e increases from 0 toy (see figure 14). (r,@)~ Figure 14: 
Distance from a point to a circle  The proof of this fact is that the distance mentioned is ~(rsinS)2 
+ (x+reosS)2 = ~2 + x 2 + 2rxeosS, and cos8 decreases from 1 to -I as 8 increases from  0 to'~". 0 Theorem 
I0: The number of comparisons in which algorithm Silhouette checks whether a point is inside or outside 
a circle is no greater than 3n. Proof : Let t i be the number of such comparisons made during the ith 
iteration of step 2, and r i be the number of entries on the stack preceding the ith iteration. Then 
 rl = I, rn+ 1 > I, and  ri+ 1 < r i - t i + 3, so the total number of comparisons is n n t i < i~=l(ri-ri+l+3) 
= rl-rn+l+3n < 3n. i=l =  3.5. The Wire-Routlng Algorithm This section employs the algorithms Circle-Obstacles 
of section 3,3 and Silhouette of section 3.4 to construct the optimal wire layout discussed in section 
2. Algorithm Wire-Route: Inputs: L yU y , (the ordinates of the terminals), xL[l::n], xU[l::n] (the 
abscissa lists of the terminals), and  d (the separation requirement). Constraints: d>0, yL<_y U, 
x~ ~ x~-d < x~-2d ~ ... < x~-(n-l)d, and   Xl ! "'" LL  Outputs: minimum length curves connecting 
(xi,Y) to (x~,yU), for l!i<n, such that adjacent curves are separated at least by distance d. Local 
data structures: 2 stacks S and S', 4 simple variables xA,yA,xZ,y Z, and 8 1-dimensional array% . r,x,xT,yT,rT,x~,y~,r 
m. Procedure: For i from I to n do: I. Empty S L and S U. 2. For j from 1 to n do rj <- lj-ild.  3. 
Call Silhouette(x L, r, sL). Call Silhouette(x U, r, sU).   4 if then < and (xZ,y Z) <- (x~,yU). Otherwise 
(xA,y A) <- (x~,y U) and (xZ,y Z) <- (x~,yL). 5. Pop each entry <k,(a,b)> from S L and from S U for 
which a ~ x A. Set x 0 <- x A and j <- 0.  174 6. Until the top entry <k,(a,b)> of S L satisfies a 
> x Z and the top entry <m,(c,d)> of S U satisfies c > x Z do a. j <- j+l.  b. xj <-mln(a,c).  C. 
If k#0 then (x~,~j,r~) <- (x~,yL,r k) else (xj,yj,rj)M <- (xj,yL,0),  M M T T r~) <- (xmU,yU,rm) 
If m#0 then (xj,yj, T T T else (xj,yj,rj) <- (xj,yU, O). d. Pop each entry <k,(a,b)> from S L and from 
S U for which a=xj. 7. Call Circle-Obstacles((xA,~), (xZ,yZ), j, x, x T, yT, r T, x M, yM, rM). The 
correctness of algorithm Wire-Route follows from theorems 4, 7, and 9. That Wire-Route runs in time O(n 
2) follows from Theorem II: Wire-Route generates each of the n curves in O(n) time. Proof: After step 
3 each stack has at most 2n+l entries. Since step 6d pops at least one entry from one of the stacks, 
the number of obstacles passed to algorithm Circle-ObStacles in step 7 is O(n). 4. EXTENSIONS TO MORE 
COMPLEX WIRE-ROUTING PROBLEMS 4.1. Only straight line wire segments are permitted. Section 2 shows 
that only near-optlmal layouts can be achieved if wires are restricted to be composed of straight llne 
segments. A graceful way of honoring this restriction within the current framework is to use as constraints 
concentric, similar polygons which circumscribe the circles specified in lemma I, noting that corollary 
3 still shows them to be sufficient. As an example, figure 3 results from the use of octagonal constraints. 
 For these particular types of constraints, a simple modification of algorithm Line-Obstacles (section 
3.1) can be used, with a straight llne obstacle substituted for each vertex of the circumscribing polygon. 
(Notice that this succeeds only because the resulting straight line segments are contained entirely within 
the polygons.)  4.2. The components to be connected are free to move The characterization of theorem 
4 can be applied to aid in deciding the placement of the two components to be connected. For example, 
if the components are free to move vertically, there is a polynomial time algorithm based on theorem 
4 to decide how close they can be placed while still allowing sufficient area for the connecting wires. 
Once this is done, the algorithm of section 3 can be used to lay out those wires. 4.3. Separation requirements 
between pairs of wires are not all equal. This situation would arise if the wires are to be lald out 
on various layers (see [4]). The characterization of section 2 can be adapted to this case.  5. FURTHER 
RESEARCH There are many directions for further research in this area. The algorithm of section 3 and, 
to a lesser extent, the characterization of section 2 depend upon the assumption that the terminals are 
 on two straight lines. It is desirable to develop similar results for more general component contours. 
Aside from the obvious applications, such a result also has applications to the problem of routing wires 
to input and output pads [3]. Sections 3.1 and 3 3 develop optimal algorithms for constructing the 
shortest single  wire which avoids n obstacles of a certain  REFERENCES restricted type. Generalizing 
the types of obstacles considered is another potentially fruitful area of research. Section 4.2 mentions 
an efficient algorithm for placing components which are free to move perpendicular to the lines of terminals. 
It is surprising that there is not an obvious efficient algorithm when parallel motion is also permitted. 
 Finally, this paper has considered only the simplest connection pattern possible, namely one with no 
crossovers. A study of other patterns adds to wire length such considerations as crossover circuits, 
the number of layer changes, and the relative speeds of the layers.  ACKNOWLEDGEMENTS I thank Mike 
Fischer, Richard Ladner, and especially Larry Ruzzo for helpful discussions which improved this material. 
<RefA> I. Garey, M.R., Graham, R.L., and Johnson, D.S. Some NP-Complete Geometric Problems. Proceedln~s of 
the Eighth Annual ACM Symposium o nTheory o_~ Computing , Hershey, Pennsylvania (May 1976), 10-22. 2. 
Lozano-P~rez, T. and Wesley, M.A. An Algorithm for Planning Collision-Free Paths Among Polyhedral Obstacles. 
Communications of the ACM 22, 10 (October 1979), 560-570T-  3. Mead, C.A. VLSI Design Course, Offered 
at University of Washington, August 20 - September 14, 1979.  4.  Mead, C.A. and Conway, L.C. Introduction 
to VLSI Systems. Addlson-Wesley Publishing Co., Reading, Massachusetts, 1980.  5. Relf, J.H. Complexity 
of the Mover's Problem and Generalizations. 20th Annual Symposium on Foundations of Computer Science 
, San Juan, Puerto Rico (October 1979~, 421-427.  6. Shamos, M.I. and Hoey, D. Geometric Intersection 
Problems. 17th Annual S~posium on Foundations of Computer Science , Houston, Texas (October 1976), 208-215.</RefA> 
 176   
			

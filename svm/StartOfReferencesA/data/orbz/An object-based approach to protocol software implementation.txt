
 An Object-Based Approach to Protocol Software Implementation Chung-Shyan Liu Department of Information 
and Computer Engineering Chung Yuan C. University Chung Li, 32023 Taiwan e-mail: liucs~mailbox.ice. cycu.edu. 
tw Abstract In this paper, an object-based approach to protocol soft­ ware implementation is presented. 
A protocol is specified by an FSM, then the FSM is implemented by a group of related objects. In our 
method, each state is implemented by an object. The member functions of an object are the interface events 
that trigger state transitions, and actions associated with state transitions constitute the body of 
the member functions. An object becomes another object if a state transition is enabled. A real example 
is given for illus­ tration. We also present a software tool that lets a designer edit a state machine 
graphically, and generates C++ class definitions automatically. We also discuss some implemen­ tation 
related issues and present an organization model for protocol layers. 1 Introduction Due to increasing 
uses of distributed systems, communica­tion protocol software design and implementation are be­coming 
more important to ensure proper operations of a system. Communication software is difficult to design 
and implement, for its concurrency nature, complexity, and per­formance requirements [1]. Thus, it is 
desirable to have de­sign techniques and tools to assist a designer in designing and implementing a protocol 
software. Permission to co y without fee all or part of this material is granted provided tEat the copies 
are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of 
the publication and its date appear, and notice is given that copying is by permission of the Association 
of Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 
SIGCOMM 94 -8/94 London England UK 0 1994 ACM 0-89791-682-4/94/0008..$3.50 A design method for protocol 
software should satisfy the following requirements. First, an implement a­tion developed using the design 
method should not have serious performance problems. As indicated in [10] [18], an implementation may 
suffer substantial performance penalty if context switch occurs too often. Thus, expensive IPC (inter-process 
communication) and unnecessary data copy­ing should be avoided if possible [12]. Second, the design method 
can be used to develop new protocols as well as to implement protocols conforming to existing standards. 
Third, the design method allows incremental design and implementation. Fourth, the design method could 
support fully or partially automated implementation. Also, tools with visual or graphical interface could 
be designed to assist a designer using the method to develop a protocol software. In this paper, we describe 
an approach to pro­tocol software development using object-oriented concepts, and present a tool that 
generates the object classes needed for a protocol implementation. In our approach, a protocol is modeled 
using an extended finite state machine (FSM) then the FSM is translated into a group of related objects. 
At implementation, an object is defined for each state of the FSM. In a given state, for each interface 
event that triggers a state transition from the state to another state or back to itself, a member function 
(or called method) is defined for the state object. The actions associated with a state transition constitute 
the body of the member func­tion corresponding to the interface event that triggers the transition. When 
an interface event is recognized and to be delivered to a protocol entity, the corresponding member function 
of an object is called. Since each object represents a state, an object becomes another object, which 
represents another state, when a state transition is enabled. A tool that can let a designer edit a state 
ma­chine graphically and generate C++ [20] objects classes and their associated member functions automatically 
was designed. This tool is actually a program generator with graphic editing capabilities. The object 
classes and mem­ber functions generated are in skeleton form, but a user may include a pre-written routine 
into a member function. Currently, the included routines are hand-coded, but they may be generated by 
a specification compiler [4]. Incremental implementation is allowed in our 1. the set of messages it 
wants to receive and to process, method and is supported by our tool. A user can edit an FSM to add new 
states and transitions, and the tool will generate a new set of object classes and member func­tions. 
Deletion of states and transitions can be handled as well. When a state is split into sub-states, in 
order to spec­ ify more detailed operations, its corresponding state object will be refined by a set 
of sub-state objects. The sub-state objects are made sub-class (or specialized) objects of the original 
object. A designer may use the tool to open up a state and refines it into sub-states and local interface 
events. The sub-class definitions can also be generated by the tool automatically. The rest of this paper 
is organized as follows. Section 2 is background information and related work. Sec­tion 3 describes our 
implementation method. Section 4 .. presents the design tool. Section 5 describes incremental implementation 
of a protocol. Section 6 discusses some imp­lementation related issues. Section 7 is conclusion. 2 Background 
2.1 A View Toward States and Objects A state machine, which may be the model of a protocol en­tity or 
the model of a process, can be divided into two levels: state level and detailed level. At state level, 
one concerns mostly with states and their transitions. At detailed level, one is more interested in the 
operations local to a state or the activities associated with state transitions. On the other hand, conventionally, 
an object is viewed as an instance of an abstract data type, or is viewed as a process that has states 
and is characterized by its re­actions to the messages it receives. If an object is viewed as a process, 
it has a state variable to record its current state and has some procedures, which are called methods 
or member functions, to react to the messages received. A state variable is a state level entity, and 
the procedures and their local variables are detailed level entities. If we adopt the process view of 
an object, then a protocol entity can be implemented as an object that contains a state variable and 
other variables. A state transition would then be an assign­ment of the state variable, and whether an 
operation, which may be implemented as a member function, is allowed or not at some states would involve 
a test of the state variable first. Our view is different. In our view, if a state machine is implemented 
by an object, then a state of the state machine is completely characterized by the behaviors that the 
object exhibits when it receives a message. When a state machine changes from a state to another state, 
instead of updating its state variable, it changes and 2. its exhibited behaviors when it receives a 
message. Since a state machine is implemented as an object, when the state machine changes state, the 
object actually becornesl another object. The new object accepts a different set of messages and has 
different behaviors. However, both old object and new object may belong to the same process and reside 
in the same address space. Thus, we may say that no state variable is needed, because an object itscif 
is the state. In other word, a state of a state machine may be implemented as an object. 2.2 Related 
Work Formal description technique (FDT) is a commonly used methodology for protocol development. In this 
methodol­ ogy, a protocol is formally specified using a formal specifi­cation language, such as Estelle 
[8], SDL [3] or LOTOS [7], then the specification is translated into a programming lan­guage with minimal 
human intervention. In [4] and [5], a protocol implementation and verification environment us­ ing Estelle, 
which is based on general transition model, was reported. Our current work is also based on general transi­tion 
model, but is different from the work presented in [4] and [5] in some aspects. First, we provide a graphical 
ed­itor, which has program generation capabilities, for a user to edit a state machine, so we have a 
more user-friendly in­terface. Second, since in our approach, interface events are transformed into member 
functions of objects, the event handling is simplified and thus can be automated. Another benefit by 
transforming interface events into member func­tion calls is that the implementation will have better 
per­formance [18]. In x-kernel [18] [16], to implement a protocol, one composes it from smaller pieces 
of protocols that together provide the required functionalities of the desired protocol. There are two 
features that contributed to the remarkable performance of x-kernel. One is that a process is associ­ated 
with each message to shepherd the message through the protocol layers. Another is that it provided facilities 
for message abstraction, so that unnecessary data copying can be avoided. In [17], x-kernel is used as 
OS platform for a dynamic network architecture, and a language, called Morpheus [I], is defined for composing 
protocols. However, a protocol composed in x-kernel is not entirely compatible with its standard specification, 
even that it has the same functionalities. Thus, x-kernel and Morpheus are more suit­able for developing 
new protocols than for implementing protocols that should be conformed to existing standards. In [10], 
a method was proposed for organizing a collection of modules, in the same protocol layer, into a 1This 
work was influenced by Actors [2], where the keyword become was borrowed.  number of horizontal processes, 
where each process is re­sponsible for performing a single thread of activities verti­cally to move a 
message up or down the layers. Vertically, a process contains modules of different protocol layers. The 
modules interact via procedure calls, which may be upward or downward. Horizontally, the modules of a 
protocol layer are scattered in different processes that share some state information and interact via 
shared memory with locks. Besides the potential problems of using up-calls [10] [16], the implementation 
of up-calls requires special operating system support.  2.3 Granularity In [1], three approaches, FDT-based, 
OS-based, and language-based, to protocol software implementation were characterized. Under this characterization, 
our approach is basically an FDT-based approach. Another dimension for characterizing pro to CO1 implement 
ation approaches, using granularity of building objects, may be used. An implementation approach is called 
coarse­gramed if a protocol layer, which is modeled using FSM or other formal method, is viewed as a 
process and is imple­mented by decomposing it into modules or sub-processes. Most FDT-based approaches 
and current Unix-based imple­mentation of TCP/IP are coarse-grained. An implementa­tion approach is called 
fine-grained if a protocol is imple­mented by composing it from basic protocol functions and supporting 
routines. Morpheus [1] and x-kernel [16] may be characterized as fine-grained. Our approach is based 
on general transition model, but views each state as a sepa­rate object. So, it may be characterized 
as medium-grained. The method suggested in [1 O] is also medium-grained.  3 Object Design and Imple­mentation 
of Protocols In this section, we will show how to implement a protocol software using objects. Also, 
a tool that lets user edit a state machine graphically and then generates C++ object classes automatically 
will be presented. A protocol is speci­fied using an FSM, then the FSM is implemented by a set of related 
objects. We will also demonstrate the concepts with a simplified version of a real protocol, CCITT T.70 
[11]. 3.1 Object Design The operations of a protocol in a given layer can be formally specified based 
on an extended finite state machine. The specification of a protocol consists of2: 1. a set of possible 
states and transitions that together describe a finite state machine, 2. a set of well-defined interface 
events, which corre­spond to the set of service primitives, at layer bound­ary, and 3. the actions, 
which may be specified by program seg­ments, performed during state transitions.  In our approach, 
object design begins after a pro­tocol is specified. Object design is divided into three steps: 1 Identify 
objects. The objects identified are the states of the FSM. Each state of the FSM is implemented by an 
object. Such objects are called state objects. 2 Define member functions (or called methods) of the objects. 
The member functions of each state object are the interface events that trigger state transitions. 3 
Implement the member functions of objects. The body of a member function is constituted by actions associated 
with a state transition triggered by the corresponding interface event. The enabled condi­tion of a transition 
is also part of the body of the member function. Currently, most object-oriented languages, such as 
C++ [20] and Smalltalk [13], require that each object be an instance of an object C1SSS3. Thus, a state 
should then be defined as an object class, of which a state object is an instance. When an FSM is initialized, 
instead of making a local copy of the FSM, an instance of initial state o+ ject is created. When a state 
transition is enabled, instead of modifying the state variable that records current state, the from-state 
object becomes an tostate object. A state transition is triggered by an interface event. The interface 
event may be a service primitive of this layer to be ca21ed by its upper layer entity, a service primitive 
of its lower layer to be zndzcated by its lower layer entity, or a system generated event such as time-out4. 
Thus, those interface events are member functions of the state object. If a state is not supposed to 
process a particular interface event, its state object will either ignore it or flag it as an exception. 
A declaration of a state object class is shown in Figure 1. The design steps and mappings between specifi­cation 
level entities and implement at ion level entities can be summarized as follows: 21u [1.5], a protocol 
is specified by five elements: services, as­sumptions on the environment, vocabulary of messages, encoding 
of messages, and procedwre rules. In this paper, we are not cOn­cerned with messages, which are hand-coded 
now but may be generated using a specification compiler. 3 If a classless language, such as Actors [2], 
is used, then this restriction can be lifted. 4 Some implementation details, such as upward and downward 
control flow, will be dkcussed in later section. class pm_14 { // This is a transport // layer object 
 public: pm.140 { } // Instance creation // Interface events of this layer virtual void t_conn_req(pdu*,pm*){} 
virtual void t.conn_ind(pdu*,pm*){} virtual void t.corm.resp(pdu*,pm*){} virtual void t_conn_conf(pdu*,pm*){} 
virtual void t_data_req(pdu*,pm*){} virtual void t_data_ind(pdu*,pm*){} virtual void t_disc_req(pdu*,pm*){} 
virtual void t-di.sc-i.nd(pdu*,pm*){} // Interface events from // lower layer entity virtual void n_corm_req(pdu*,pm*) 
{} virtual void n.conn_ind(pdu*,pm*) {} virtual void n-corm-resp(pdu*,pm*) {} virtual void n-conn_conf(pdu*,prn*) 
{} virtual void n.data_ind(pdu*,pm*) {} virtual void n_disc_req(pdu*,pm*) {} }; Figure 1: The declaration 
of a state object class. 1. Design object classes for the protocol which is mod­eled by an FSM. For each 
state of the FSM, define an object class for it. 2. Design memberfunctions (orcalledmethods) foreach 
object class. For each interface event that triggers a state transition from a particular state, define 
it as a member function of the object class that implements the state. 3. The actions associated with 
a transition are imple­mented as body of the member function that imple­ments the interface event triggering 
the transition. If the enabled condition of a transition is satisfied, current state object becomes another 
state object to conclude a call to this member function. Otherwise, this member function returns prematurely. 
  3.2 An Example Here, we show how to implement a protocol based on an FSM specification. The ex~mple 
we ~sed is the sender of a TPo transport protocol, T.70, which is part of G4FAX. The FSM we showed in 
Figure 2 is a simplified version. Some of the protocol activities are not shown. This example is shown 
here only for illustration. A full-fledged T.70 will be used when we introduce our tool in next section. 
Also, the FSM only shows states and operations of the protocol at protocol level, with peer-to-peer activities. 
The detailed level states and operations are not shown here. (S-TCR) T.di I N.dak_ind (R-TCA) \ > N.data_ind(R-TDT) 
T.data_req(S-TDT) Figure 2: The FSM that models the operations ofa simplified T.70. The peer-to-peer 
activities are shown in parenthesis. Since the finite state machine haa three states, it will be implemented 
by three state object claases: idle, wait, and connected. The object class definition of the three state 
objects are shown in Figure 3. Under our current implementation, ae shownin Figure 3, however, an object 
class designating the entire FSM is implemented as superclass of its constituent states. One reaaon for 
this is that all state objects of the FSM will have uniform interface for an upper layer entity or a 
lower layer entity. A protocol entity can now address to a single pr7z.14object, instead of a set of 
state objects. Also, prn_Lj can act as a generic dispatcher for other state objects. For example, when 
the member function N.data-indofa wait_l object is called, the procedure in pm-bj will be invoked since 
N-data..ind is defined there, The procedure will decide first what kind of TPDU this incoming message 
is, then it will call the corresponding member function of watt-l. For ex­ample, if the incoming TPDU 
is TCA (Transport Connec­tion Accept), then R-TCA of wait-l will be called5. An­other reason is that 
it allows incremental implementation, and this will be described later. By using this program structure, 
the default processing of an interface event at a 5TC A is de~vered as data by network layer and is indicated 
with N -dataind to transport layer. Therefore, the member func­tion, N -dataind, is responsible for decoding 
TC A and then for calling R.TC A. ............. ., Statehktdim ........... ..: class idle_O : public 
pm.14 { // Declared as sublcass of pm-14 // This will be erplained later public: idle_O() : pm_140 { 
}; // Instance creation / void t_conn_req(pdu*,pm_14*) Rotoml // Will override the function De-r@eJ // 
defined in superclass pm.14 { . . . // Send TCR and becomes // a wait-l object } }; class wait_i : public 
pm_14{ public: wait_lo : pm-140 { } // Instance creation Figure4: Implementation of a protocol using 
the soft­ void R_TCA() ware tool. { . . . // Receives a positive response // T-conr-conf to upper layer 
// Becomes a connected-2 object particular state can be defined in the superclass. The de­ } fault action 
may be re-defined by a state object class. If a void R_TCC() state is not supposed to process an interface 
event, it may { . . . // Becomes an idle-O object ignore it or flag it as an exception. } }; class cormected_2 
: public pm_14{ 4 A Design Tool public: connected.20 : pmJ40 { } // Instance creation In this section, 
we present a software tool for assisting a void t_data_req(pdu*, pm_14*) designer to implement a protocol 
that is specified using an { // Send TDT FSM. The implementation of a protocol with the software ... 
} tool is shown in Figure 4. The state machine editor is a void t_disc_req(pdu*, pm_14*) graphics editor 
that lets a designer add or delete states and ... { // Becomes an idle.-O object interface events of 
a state machine directly on the screen. It } records states and interface events of the state machine 
to void R-TDT(pdu*, pmJ4*) generate C++ object classes and their member functions. { . . . // Data-.ind 
to upper layer entity Thus, the state machine editor is actually a program gen­ ,.. // at the end of 
re-assembly erator with graphic editing capabilities. An FSM table is } generated at the same time. The 
FSM table may be used }; to verify certain properties of a protocol [4], but is not im­plemented at this 
time. In Figure 5, the FSM modeling the sending protocol of T.70 and its C++ class definitions are shown. 
The FSMS were edited using the state machine Figure 3: The class definitions of the state objects of 
editor and the object classes were automatically generated. the FSM for the simplified T.70 The member 
functions generated are declarations only, but a designer may use the tool to include a hand-coded rou­tine 
into amemberfunction. Since ahand-coded routine is actually the program segment associated with a transition 
triggered by an interface event, which is implemented by a member function, it may be generated by a 
specification compiler. 311 T_DISC_REQ N_DISC_IND R_TBR N_RESET_IND R_Invalid_TPDU R_TCO 1/ R_TDT S_TDT 
class Idle-O : public T70 { public : Idle_O() : T70() { } void S_TCR() < } void R_any_TPDU() { } Idle-0() 
{ } }; class Wait-l : public T70 { public : Wait-1o : T70() { } void R_TCC() { } void R_TCR() { } void 
R_TBR() { } void R.Invalid_TPDU() { } void N_RESET_IND() { } void Tl_ltiraeouto { } void N_DISC_IND() 
{ } void T_DISC_REQ() { } void R_TCA() { } Wait_lo { } }; class Connected_2 : public T70 { public : Connected_20 
: T700 { } void T-DISC_REQ() { } void N_DISC_IND() { } void R_TBR() { } void NJESET.IND() { } void R_TDT() 
{ } void S_TDT() { } void R_Invalid_TPDU() { } Connected_20 { } }; Figure5: TheFSM that models the sending 
protocol of T.70 and its C++ object classes generated by the tool. T_OISC_RER(Hait_l .ComectedL2J \ NIESET_IND(Nait_l. 
Connected2j R_Invalid_TPDU{ Hait_l) timeout(Hait.J) N_DISC_IND(Hait_l, Connected) R_TCC(Mait_l) tLDISC-.IND 
R_TBR(Hait_l, Connected) N_RESET-IND T_DISC_REQ timeout R-ang-TPDU(Idle-0)   / ,_anjpDu,ldle_o,J 
 R_Invalid_TPDU(Connected2) S_TCR(Hait_l) Figure6: Arefined state transitions diagramofthe idle state. 
The diagram is edited using the state machine editor. A designer may also use the state machine editor 
to open up a state, to add more details such as sub-states and other interface events. This will be discussed 
in next section. 5 Incremental Implementation and Inheritance In this section, we discuss how to incrementally 
implement a Protocol. BY in-mental implementation of a protocol we mean modifications of an existing 
protocol, by adding or deleting states or interface events of an F SM, or refine­ments of a state by 
splitting it into some sub-states with some interface events that are visible only to the sub-states. 
The former can be handled directly by the state machine editor shown in previous section. Th~ latter 
can also be handled by the state machine editor, to be shown below. This is similar to XOR decomposition 
ofa Statechart [14] or leveling of a Data Flow Diagram [19]. The splitting of a state is different from 
the synthesis of a protocol [9], in the sense that the purpose of the former is to implement a pro­tocol 
whose specification is already given, and the purpose of the latter is to derive its service specification. 
However, it is possible to integrate the state machine editor with a class definition for a protocol 
at functional level is shown in Figure 1 in previous section. Pm.14 idle.O Wafl.1 uaL2 <z>  d T idle.o-l 
@@ Figure 7: The class hierarchy of the protocol machine. protocol synthesis tool. 5.1 Method and Principles 
In 1S0 or CCITT recommendations, a protocol is specified using three different kinds of activities: peer-to-peer, 
inter­layer, and local activities. The specification is divided into two levels: protocol level which 
contains only peer-to-peer activities, and detail level which adds inter-layer and local activities. 
The FS M shown in Figure 2 cent ains only peer­to-peer activities, but no inter-layer and local activities. 
In our method, the implementation of a proto­col software can be decomposed into three levels: functional 
level, abstract state machine level, and detail level. Each level may be viewed as an implementation 
stage. At func­tional level, a protocol machine is viewed as a black box that accepts requests, which 
are interface events, and performs the required functions. This level corresponds to the ser­vice specification 
of a protocol. At abstract state machine level, which corresponds to protocol level in 0S1 frame­work, 
peer-to-peer activities are specified and represented by a simplified FSM as shown in Figure 2. The detail 
level is the same as that of 0S1 framework. To incrementally implement a protocol, one starts from functional 
level, then proceeds to abstract state machine level, and finally to detail level. At functional level, 
a protocol has only one state which is the entire protocol machine. It can be implemented by a single 
object class with all its service primitives as its member functions. The When one goes from functional 
level to abstract state machine level, the only state of the protocol machine is split into, in our case 
as shown in Figure 2, three states. Thus, the abstract state machine will be implemented by three object 
classes, with each object class corresponding to one state. Moreover, each object class is defined as 
a sub­class of the object class implementing the functional level protocol machine. Now we have a principle 
on splitting a state. Principle 1 If a state, X, which is Implemented by an ob­ject class, O, is split 
into sub-states, XI, Xz, . . . . X~, which are implemented by object classes 01, 02, . . . . On, respec­tively, 
then 01, 02, . . . . On should be made as subclasses of o. The implementation of a protocol from abstract 
state machine level to detail level can be handled in a similar way. At detail level, more states are 
introduced and more inter-layer and local activities are added. Thus, the object classes for newly added 
states can be made as subclasses of the object class for the split state. Actually, states may be merged 
too. Below is the principle for state merge. Principle 2 When a set of states, XI, X2, .... X~, whtch 
are implemented by object classes, 01, 02, . . . . 0~, respec+ tively, are merged into a single state. 
X, whtch is imple­mented by object class O, then 01, 02, .... On should be made as subclasses of O. Usually, 
a functional level object defines default processing of the interface events in member functions to constitute 
generic interface of the entire protocol machine. Since a sub-class object may inherit the member functions 
defined in its super-class as its own, an abstract machine level object can re-use the member functions 
defined in the functional level object if the functionalities are not changed. An abstract machine level 
object, however, may re-define a member function to suit its own processing needs. The member function 
re-defined in a sub-class will override the one defined in the super-class. For example, the member function 
t-conrueg defined in the class idle-O, shown in Fig­ure 3, will override the one defined in pm.f4, which 
is the super-class of tdle.o. A detail level object may do the same thing. The advantage of this approach 
is that when one pro­ceeds from functional level to abstract state machine level, and then to detail 
level, all implemented part need not be changed at all. They are either re-used or re-defined by the 
subclasses. class Idle_O_l : public public : Idle_O_lo : Idle-0() void T_CONN_REQ() { } Idle_O-lo { } 
>: class Wait_O_2 : public Idle_O { public : Wait_O_20 : Idle-0() { } void N_DISC_IND() { } void S.TCR() 
{ } void T_DISC_REfJ() { } Wait_O_20 { } }; class Wait_O-3 : public Idle_O { public : Wait_O_30 : Idle_O() 
{ } void N_DISC.IND() { } void TO_3tinreouto { } void N_RESET_IND() { } void R_any_TPDU() { } void T_DISC_REQ() 
{ } Wait_O_30 { } }; Figure 8: The class definitions of the subclasses of idle_O.  5.2 An Example In 
Figure 6, the refinement of the state, idle, is shown. Figure 6 is edited using the state machine editor. 
Now, we have three sub-states, idle-OJ, wait-O-2, and wait_O-3. TO refine a state, a designer opens up 
a state of the FSM from the screen using the state machine editor, and then adds more states and events 
as necessary. The class hierarchy and class definitions of the resulted subclasses are shown in Figure 
7 and Figure 8. The subclasses are generated automatically.  6 Implementation Considerations In this 
section, we will discuss several implementation re­lated issues. 6.1 Entry Points ofa Protocol Machine 
Conventionally, a protocol may be implemented and be ac­cessed in the following ways: (1) as part of 
operating sys­tem and accessed by system calls, (2) as a user process and accessed by inter process communication, 
or (3) as sepa­rate procedures of a user process and accessed by procedure calls. As mentioned before, 
1P Cs incur performance penalty, and thus second approach should be avoided. In first approach, there 
is context switch overhead. But, this overhead is in general unavoidable due to different address space 
between system and user. It is the designer s choice on where to cross the system/user boundary in a 
protocol stack. Since we are concerned now with implementation of protocols as user processes, third 
approach is adopted. In our method, protocol layers are organized as in Figure 9. This organization model 
is similar to that in [10], except that in our model, processes do not share state infor­mation of the 
protocol machine. Each process has its own state information, which are embedded in different objects 
that are created independently. In our model, an objectis consisted of an UpperSAP session and a LowerSAP 
session. Since an object can encapsulate its data and procedures into a single package, there is no distinction 
between session and SAPS. Also, when an object is created, its UpperSAP ses­sion and LowerSAP session 
will be created simultaneously. Downward control flow is straightforward, since an upper layer entity 
can call the procedures exportedby a protocol machine. This is basically the same in our case, ex­cept 
that an object must be created first to open an Upper-SAP session. Upward control flow is usually more 
compli­cated. In our model, a lower layer may invoke the protocol machine directly by creating an object 
to open a LowerSAP session, as long as they are in the same process. Since an object makes no assumptions 
on its clients, creation of Up­perSAP and LowerSAP are symmetrical. An upper laye,r entity needs not 
call its lower layer entity first for thelow<r layer entity to pass up messages. But some ways still 
have to be provided for a lower layer entity to know its upper layer protocol machine. One way to register 
an upper layer entity to a lower layer entity is to hard-wire it into the lower layer entity. At the 
system/user boundary, IPC or system calls are used. Although upcall [10] will improve performance at 
system/user boundary, it is not generally available in most systems.  6.2 Implementation of ~ecorne 
In our approach, at state transition, an object may become another object. However, in most existing 
languages, to implement become, we must create to~tate object first and then delete from-state object. 
The creation and deletion of objects are usually time-consuming operations. To create anobject~ we need 
to allocate memory space from free pool, and then to initialize its variables. To delete an object, we 
need to de-allocate the memory space it occupies and then return the space back to free pool. Although 
in some lan­guages, an object may compute its replacement behaviors to become another object [2], it 
is still expensive. !/\  Uppefloyef .-. 1---,IJ up+x!tw uppA4P *** uppdAP z-&#38; aProtocol Mochine 
object 3 *** I.owew lowefw AA .-.. ..­ vv L Figure 9: The organization model of protocol layers. Currently, 
become isimplemented =follows. At the opening of a session, a set of state-objects, each stands for a 
state of the entire state machine, are created. Thus, at state transition, instead of creating anddeletimg 
objects, the current object pointer is assigned to to=tate object which will handle succeeding incoming 
events and messages. However, an efficient language-level construct is possible. If we look more into 
the class definitions as shown in Figure 3 and Figure 8, we may find out that they are very similar. 
Essentially, although an object class is defined separately for each state, they all together define 
a single state machine. Also, they share the same set of variables. Thus, they may be grouped together 
as a special set of objects, called isomorphic objects. When an object becomes another object in the 
same isomorphic set, there is no need to create and delete objects, are-assignment of class pointer would 
suffice. In other words, only a change of identity would be enough, and the values of local variables 
need not, be modified at all. Then, state transition may be efficiently, yet elegantly, implemented. 
 7 Conclusion In this paper, we presented an approach to implement a protocol software using objects. 
A protocol is specified by an FSM, then the FSM is implemented by a set of related objects. In implementing 
the FSM, a state is implemented by an object, and the interface events that trigger the state transitions 
are implemented as member functions of the state object. When a state is split into sub-states, the sub 
states are implemented as subclass objects of the original state object. This allows incremental implementation 
of a protocol software, and the implemented part need not be changed at all when a more detailed level 
implementation is performed. The implemented part would either be re-used or overridden. We also demonstrate 
ed our approach with a real example, CCITT T.70. We also presented a software tool for assisting a designer 
to implement a protocol. The tool lets a designer graphically edit a state machine, and then generates 
C++ classes automatically. A hand-coded routine may be included into a member function of the gen­erated 
clssses. As we have indicated, the hand-coded rou­tines may be generated by a specification compiler. 
We aLso discussed some implementation related issues and presented an organization model for protocol 
layers, which we hope will be helpful for future protocol implementation. References <RefA>[1] M. B. Abbott 
and L. Peterson, A Language-Based Approach to Protocol Implementation . Proc. ACM SIGCOMM Conference 
on Communication Architec-[16] N. C. Hutchinson and L. L. Peterson, The x-Kernel: ture and Protocols, 
1992, 27-38. An Architecture fir Implementing Network Protocols , IEEE Trans Software Engineering, Vol 
17, No 1, Jan [z] G. Agha, Actors: A Model for Concurrent Computa­1991, 64-76. tion in Distributed Systems 
, MIT Press, 1986. [17] S. O Malley and L. Peterson, Dynamic Network Ar­ [3] F. Belina and D. Hogrefe, 
The CCITT Specification chitecture , ACM Trans Computer Systems, Vol 10, and Description Language SDL 
, Computer Networks No 2, May 1992, 110-143. and ISDN Ss@erns, Vol 16, 311-341, 1989. [18] L. Peterson, 
N. Hutchinson, S. O Malley, and H. Rae, [4] T. P. Blumer and D. P. Sidhu, Mechanical Verifica­ The x-kernal: 
A Platform for Accessing Internet Re­ tion of Automatic Implementation of Communication sources , IEEE 
Computer, Vol 23, No 5, May 1990,Protocols , IEEE Trans Software Engineering, Vol 12, 23-33. No 8, Aug 
1986, 827-843. [19] L. Peters, Advanced Structured Analysis and De­ [5] T. P. Blumer and R. L. Tenney, 
C(A Formal Specifica­sign , Prentice-Hall, 1988. tion Technique and Implementation Method for Pro­tocols 
, Computer Networks, VO1-6, 1982, 201-217. [20] B. Stroustrup, The C++ Programming Lnaguage , 2nd ed., 
Addison Wesley, 1991. [6] G. V. Bochmann, A General Transition Model for Protocols and Communication 
Services , IEEE Trans Commumcatton, Vol 28, No 4, Apr 1980, 643-650. [7] T. Bolognesi and E. Brinksmaa, 
 Introduction to the 1S0 Specification Language LOTOS , Computer Net­works and ISDN Systems, Vol 14, 
1987, 25-59. [8] S. Budkowski and P. Dembinski, An Introduction to Estelle: A Specification Language 
for Distributed Sys­tems , Computer Networks and ISDN Systems, Vol 14, 1987, 3-23. [9] P. M. Chu and 
M. T. Liu, Protocol Synthesis in a State-Transition Model , Proc. IEEE Computer Soft­ware and Appl~catzons 
Conference, COMPSA C-88, Chicago, 1988, 505-512. [10] D. Clark, The Strucutring of Systems Using Up 
calls , ACM Operatzng System Review, Vol 19, No 5, 1986, 171-180. [11] CCITT T.70, Network Independent 
Basic Transport Service for the Telematic Services , 1988. [12] D. D. Clark and D. L. Tennenhouse, Architectural 
Consideration for a New Generation of Protocols , Proc. ACM SIGCOMM Conference on Communica­tion Architecture 
and Protocols, 1990, 200-208. [13] A Goldberg and D. Robson, Smalltalk-80, The Lan­ guage and Its Implementation 
, Addison-Wesley Pub­lishing Company, 1983. [14] D. Harel, On Visual Formalism , Communication ACM, 
Vol 31, No 5, May 1988, 514-530. [15] G. Holzmann, Design and Validation of Computer Protocols , Prentice 
Hall, 1991.  </RefA>
			

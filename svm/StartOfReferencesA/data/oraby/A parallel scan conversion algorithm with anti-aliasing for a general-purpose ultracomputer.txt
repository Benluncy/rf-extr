
 A Parallel Scan Conversion Algorithm with Anti-Aliasing for a General-Purpose Ultracomputer Eugene Fiume 
Alain Fournier Computer Systems Research Group Department of Computer Science University of Toronto 
Toronto, Ontario, M5S 1A4 Larry Rudolph Department of Computer Science Carnegie-Mellon University Pittsburgh, 
PA 15213 ABSTRACT Popular approaches to speeding up scan conversion often employ parallel processing. 
Recently, several special-purpose parallel architectures have been suggested. We propose an alternative 
to these sys- tems: the general-purpose ultracomputer, a parallel processor with many autonomous processing 
ele-ments and a shared memory. The "serial semantics/parallel execution" feature of this archi- tecture 
is exploited in the formulation of a scan conversion algorithm. Hidden surfaces are removed using a single 
scanline, z-buffer algorithm. Since exact anti-aliasing is inherently slow, a novel parallel anti-aliasing 
algorithm is presented in which subpixel coverage by edges is approximated using a look-up table. The 
ultimate intensity of a pixel is the weighted sum of the intensity contribu- tion of the closest edge, 
that of the "losing" edges, and that of the background. The algorithm is fast and accurate, it is attractive 
even in a serial environment, and it avoids several artifacts that commonly occur in animated sequences. 
CR Categories and Subject Descriptors: B.32 [Memory Structurcs]: Design Styles Shared Memory; D.3.3 [Programming 
Languages]: Language Constructs -Concurrent programming structures; F.2.2 [Analysis of Algorithms and 
Problem Complex-ity]: Nonnumeri, cal Algorithms and Problems Geometrical problems and computc~tions; 
1.3.1 [Computer Graphics]: Hardware Architecture -Ras-ter display devices; 1.3.3 [Computer Graphics]: 
Picture/Image Generation -Display algorithms; 1.3.7 [Computer Graphics]: Three-Dimensional Graphics and 
Realism -Y~sible line~surface algo- rithm. Permission to copy without fee all or part of this material 
is granted provided that the copies are not made or distributed for direct commercial advantage, the 
ACM copyright notice and the title of the publication and its date appear, and notice is given that copying 
is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, requires 
a fee and/or specific permission. 1. Introduction The performance of a raster graphics system is strongly 
influenced by the inefficiency of scan conversion. Several recent papers have proposed speeding up scan 
conversion by employing special- purpose hardware. These systems exploit parallel processing in various 
ways, some of which are: (I) "Intelligent" VLSI-based memory. This includes systems such as PIXEL-PLANES, 
by Fuchs et al. [FuPoSl, FPPB82], the smart memory architec- ture by Gupta etal. [GuSSSI], and the Rec- 
tangular Area Filling Display System Architec- ture by Whelan [Whe182].  (2) Hardware enhancements or 
graphics engines. Clark's geometry engine, although not a scan conversion, system, illustrates the latter 
[ClarSZ], and Whitted's enhanced frame buffer is an example of the former [Whir81]. The pro- posed systems 
of Fussell and Rathi [FuRa82], and Weinberg [Wein81], are graphics engines.  (3) Special-purpose, multiple-processor 
systems. These systems incorporate special-purpose hardware to broadcast image descriptions to the processors. 
Image memory is often parti- tioned to enhance parallelism. Examples include Fueh's central broadcast 
controller [Fuch77], Parke's splitter tree, and Parke's splitter tree/broadcast controller hybrid  
[ParkS0]. Obviously, any parallel-processing scheme should demonstrably hasten scan conversion. The 
above proposals are no exception. Several issues remain open, however. First, few proposals address the 
aliasing problem. Indeed, anti-aliasing is difficult to perform on the systems of Fuchs et al., Fussell 
and Rathi, Whelan, Fuchs, and Parke. Second, display systems exploiting parallelism should always exhibit 
subserial behaviour. Third, it is not clear that a special-purpose system is the best approach if similar 
computational power is required for other tasks. It is likely that the feasibility of large-scale display 
processors with special-put'pose hardware will coincide with that of general-purpose parallei processnrs. 
The u!tracomputer, described below, is one such processor. We wish to demon-strate that the ultracomputer 
can be a very effec- tive "graphics engine" in its own right. This is illus- trated by presenting a parallel 
scan conversion &#38;#169; ACM 0-89791-109-1/83/007/0141 $00.75 algorithm including anti-aliasing. The 
worst case behaviour of the algorithm is subserial. Not all problems necessarily have faster parallel 
implementations. However, problems such as scan conversion, which naturally decompose into a large set 
of independent subproblems, are good candi-dates for parallel processing. The objective of a general-purpose 
parallel processor design is to maximise the degree of subproblem independence over a wide class of tasks. 
Otherwise, the major advantage of such a processor over special-purpose systems is lost. In our ultracomputer 
model, sub- problem independence is facilitated by a Small repertoire of powerful concurrent operations 
on shared memory. To each processing element (PE) of the ultracomputer, a concurrent operation appears 
to execute indivisibly. In fact, an intelligent, multi- stage network cleverly connects the PEs to shared 
memory, and combines all operations simultane-ously directed at a variable into one operation. Pro-grams 
thus appear to have a serial semantics, but parallel execution. Moreover, parallel programs are simply 
expressed, unlike the often more compli-cated techniques required to optimise computa-tions on vector 
or pipeline processors. Because of this "serial semantics/parallel exeetion" property, the algorithms 
below can be implemented on any processor capable of simulating the concurrent operations, although the 
resulting programs may run more slowly. Section 2 outlines the basic ultracomputer archi-tecture. A scan 
conversion algorithm that utilises this parallel processing model is presented in Sec- tion 3. A novel 
anti-aliasing algorithm is given as an integral part of scan conversion. Lastly, the gen-erality of the 
ultracomputer is illustrated by noting other problems to which it can be applied. This is discussed in 
Section 4, as are topics for future research. 2. Ultracomputer Architecture An ultracompz~er is a parallel 
processor composed of many processing elements (PEs), which have multiple-cycle access to shared memory. 
Ultra-computers are a good model of parallel computa- tion. Schwartz has made an extensive survey of 
this field, summarising various upper and lower bounds for parallel sorting algorithms, set operations, 
matrix multiplication, etc. [Schw80]. Ultracomput-ers are more than just a theoretical model, how-ever. 
Indeed, our ultracomputer model is based on the work done at New York University, at which a large-scale 
implementation is planned [GGKM81]. The model we propose is a very slight extension of the NYU model, 
incorporating additional concurrent instructions. An NYU Ultracomputer is composed of N = 2 D auto- nomous 
PEs and connected to N shared memory modules. Local memory for each PE is provided by means of a partitioned 
memory cache. PEs access shared memory via a D=log2N-stage connection network composed of an NxD array 
of "intelligent" a-input, a-output switches 1. Switch interconnection i. The entire architecture can 
be easily genera]ised to N =/~ D PEs and a D --Iogk N-stage network using k-input, k- output switches. 
 is based on Lawries's omega-network [Lawr75], illustrated in Figure i. I~tale 1 I IStaee ~ I I~taee 
3 I Figure 1, Ro~N~g through a~ omegg-~.et~mrk.l'o~" 8 PEs. Con- neetions between PEa, switches, and 
MMs are by means of a slt~ffts-ezcItaw, ge: an object numbered d id  " " c/n in binary is connected 
to the object numbered d z'- 01D d *in the next stage of the network. A message transmitted from PE 
~D  "P * to MM rn~ -  rn * uses output port rn~ when leaving the i m switch. Similarly for travelling 
from MM to PE. The route from PE 5 (101e) to MM 2 (010e) is indicated. The novelty of the NYU design 
rests in the intelli-gent switches, which implement concurrent access to variables in shared memory. 
The network easily realises concurrent fetch or store operations. Other more powerful concurrent operations 
can be implemented. Presently, one such instruction is supported: the replace-add, which creates the 
illu- sion of indivisibly adding a value to a shared vari-able, and returning the sum to the requesting 
PE. Specifically, the format of the operation is RepAdd(V,e) 2, where V denotes a shared (integer) variable 
and e is an integer expression. Let V have value v. Suppose P~:~ issues the command S/ =RepAdd(V,e~ ), 
and PEj issues the command Sj =RepAdd(V,ej ) simultaneously. Then, assuming V is not simultaneously updated 
by another PE, either S/ =v+~i S] =v+e i + el, or S~ =v+e/ +e~ Sj ----v+ej, and in either case, the 
new value of V is v+ei +ej . Note that RepAdd(V,0) is a fetch instruction. When operations on the same 
cell in shared memory meet at a switch, they are synthesised into a single instruction. This is sent 
to the next stage in the network in one cycle. Instruction combining can occur at any stage in the network. 
Hence of all the operations simultaneously directed at a single vari- able, V, only one cumulative operation 
actually "reaches" V. Thus memory traffic is reduced and network bandwidth is increased. Indeed, the 
pro-cessor has the following surprising property: it is 2. 'the semantics of this operation has recently 
been modified in the NYU design, and has since been renamed FetehAdd. Since RepAdd can be easily constructed 
from FetchAdd, we will continue to use RepAdd in our ultracomputer model. particularly efficient when 
many operations are concurrently issued on a small set of variables. Simultaneous update of the same 
variable by all N PEs is resolved in O(log N) time, compared to 0(N) time for typical parallel processors 
using semaphore-like mutual exclusion. This is a useful property which is often exploited. For example, 
RepAdd makes an effective synehronisation primi-tive [GoLR83]. Moreover, data structures allowing parallel 
access are conveniently implemented using RepAdd. A polygon display list can be nicely imple- mented 
as a parallel queue. Suppose the index NextPolygon is used as a subscript into a polygon list. Then every 
PE executing RepAdd(NextPolygon,1) is guaranteed to get a unique value for NextPolygon. The standard 
NYU ultracomputer model supports the three concurrent instructions described above: fetch, store, and 
RepAdd. To realise these opera-tions, a switch only needs a small amount of memory, and an adder. Implementation 
details, together with a network performance analysis, are found in [GGKM81]. Although these instructions 
have proved useful for constructing good parallel solutions to scientific and operating system prob-lems, 
we believe a concurrent, flexible comparison instruction is needed. We propose a new concurrent instruction, 
repLace-minimum, or RepMin, which is easily realised by adding a eomparator to each switch. Its semantics 
is defined as follows. Let V denote a cell of shared memory having value v, and let e be an expression 
such that both v and e are pairs (intensity,depth) of values s. Then RepMin(V,e) causes all of V to be 
replaced by e iff e.depth < v.depth. The value returned by RepMin will be dis- cussed presently. The 
utility of RepMin in scan conversion is obvious. Consider the following paral- lel version of the z-buffer 
algorithm found in [NeSp79]. Here, the entire z-buffer is assumed to be addressable as an nxm array of 
shared memory. Each PE executes the following.  while polygons remain do begin get P from polygon list 
(use RepAdd) Ypixels (x,y) E P do begin i :-- Polygonlntensity(P,x,y) z := PolygonDepth(P,x,y) RepM'm((x,y), 
(i,z)) end end Let us now discuss the value returned by a RepMin operation. We only consider the case 
where n PEs (0-<n~N) simultaneously issue a RepMin for cell V. Informally, of all the RepMin's simultaneously 
directed at variable V, the value returned to a PE is one which has "lost" in at least one comparison. 
Moreover, any value sent by a particular PE is returned exactly once. Perhaps surprisingly, this is achievable 
in the switches, and can be shown by induction on n. The NYU ultracomputer also presently lacks con-current 
logical bit operations. The scan conversion 3. To make the replace-minimum instruction qu~te genera], 
the extent of. the intensity and depth subwords could be con- trolled by a modifiable bit-mask stored 
in each switch. Clearly, the names of the subwords, "intensity" and "depth", are illustrative. In practice, 
the subwords cotdd be known by arbitrary names. algorithm below makes use of another concurrent instruction, 
the RepAnd. This operation has the same format as the RepAdd, but performs a logical and of the arguments 
instead of an addition. Note that in principle, only a few Nand gates in each switch would be required 
to realise all 16 boolean operations as concurrent instructions. In general, an instruction supported 
by the connec-tion network must be associative. Thus concurrent floating point operations cannot be properly 
real-ised 4. There exist inherently non-associative opera- tions, such as the group (or Fourier) commutator. 
Defined as [a ,b ] = aba-lb -5, this operation is not associative for non-commutative groups; thus a 
"RepCom" instruction for matrices under multipli-cation is inherently unrealisable. The serialisation 
principle is a necessary property of the connection network: The network ensures that the effect of simultaneous 
operations by the PEs is equivalent to some serialisation of the opera- tions. 3. A Fast Parallel Scan 
Conversion Algorithm 3.1. Preliminaries Our definition of scan conversion is the traditional one (e.g. 
[NeSp79]). Given a scene represented by P simple polygons, determine the set of pixels and their intensities 
that best approximates the scene. The solution, based on the conventional single-scanline z-buffer algorithm, 
performs hidden-surface removal and anti-aliasing. Serial scanline algorithms typically require a YX-sort 
of polygon spans intersecting with a given scanline [SuSS74]. However, RepMin allows us to drop the X 
sort. The shared memory storing ultimate scanline intensi-ties is assumed to be available to a video 
controller, by dual-ported memory, for instance.  3.2. The Algorithm First we briefly outline the 
major steps performed by each PE. As in traditional scanline algorithms, a ¥-scanline bucket is employed 
to determine polygon segments that enter the scene at scanline y. (I) Remove backfacing polygons.  (2) 
Convert remaining polygons into sets of $1#a~-area~, i.e. trapezoidal or triangular regions. Insert each 
span-area into the Y-bucket corresponding to its largest y-value. (3) Scan convert span-areas: for y 
:= ymin to ymax do  (a) The span-areas from bucket y are inserted into the ac~vs span list (ASL). (b) 
Process active spans for scanline y. Each PE takes a span from the ASL. If the span is large, only a 
fraction of it is taken at a time, thus permitting parallel pro- cessing of the span. For each pixel 
in its portion of a span, the PE computes intensity and depth values, and performs a table look-up to 
approximate the portion of the pixel covered by the span. The left and right end- points of the span 
are then updated. If the span-area is exhausted, it is removed from the ASL. (c) Anti-aliasing. For 
each non-empty pixel, an approxi- mate anti-aliasing procedure is performed by  4. Inmost computers, 
((I0~--i0a)+1) ~ (i0a+(--I0~+I)), for large a. determining the intensity contribution of the closest 
span, and adding in the average contribution of the "losers". The coverage information computed in step 
 (b) is used in these calculations.  3.2.1. Data Structures For clarity, we only use static storage 
in shared memory. ASsume there are P input polygons found in the array InputList. In what follows, let 
V~ be the number of vertices in input polygon P~, and let V be the largest such V~. Assume the PEs are 
pro-grammed in a high-level language such as Pascal or Euclid which allows programmer-defined data types. 
Note that arrays in shared memory are pos-sible, since their starting addresses can be stored in the 
local memory for each PE. The names assigned to variables in shared memory begin with an upper case letter. 
Local variables begin with a lower case letter. Polygon display list I [nputList: array I..P of Polygon 
Ngon: array I..P of Polygon -each polygon Pc contains an array 1..l~ of (x,y,z). I Y bucket. Yp gives 
next available position for seanline y ] ¥: matrix ymin..ymax 1..PV of SpanArea Yp: array ymin..ymax 
of 0..P Active Span List. S reflects the number of spans. ASL: array 1..PV of SpanArea S: 1..PV :-- 0 
I Some indices PolyIn, PolyOut, CurrentSpan: Integer I Locks for synchronisation. Assume they are initialised 
to 0 Loekl, Lock2: 0..P := 0 SpanArea: type record of yt ~top y I dy { height of span-area xl ~current 
LHS xr ~current RHS I xm ~multiplicity-see below; initially xm--xl-M~ dxl ~ &#38;z ofLHS I AN dxr 
[ Az of RHS Ay dyl [ ~ofLHS| Az dyr ~ A.~ of RHS Az DepthInfo Intensitylnfo end  3.2.2. Synchronisation, 
Initialisation, and Backfae-ing Polygon Removal Since the code in this section is familiar, it is a good 
place to illustrate some principles of synchronisa- tion and initialisation. Assume each PE has access 
to a unique identifier in the manifest constant PEid, which takes on a value between 1 and N. The follow- 
ing code initialises PolyIn and PolyOut, performs synchronisation, and removes backfacif~g polygons as 
in [NeSp79, Appendix III]. We assume the polygons in the input list have undergone perspec-tive transformation. 
The reader may wish to verify that two locks are necessary to have fully reusable locks for synchrordsation. 
i, j, p: integer InputList, Ngon, Lock I, Lock2, PolyIn, Poly0ut: shared The first PE in initialises 
Polyln, Poly0ut if RepAdd(Lockl,1) = 1 then PolyIn := Poly0ut :-- Lock2 := 0 while Lock1 < N do ~nothing~ 
I The last PE out resets Loekl for future Use if Lock2 = N-1 then Loekl := 0 RepAdd(Lock2,1) while Lock2 
< N de ~nothing{ p := I~phdd(Poly0ut,1) while p ~ P do begin for polygon InputList[p], calculate c 
E e := ~ (V[i].x-V[j].x)(V[i].y+V[j].y) C ~l where ]=i+l if i<V~ ; otherwise j=l if c .c 0 then ~the 
polygon feces us, add it to Ngon] Ngon[RepAdd(Pelyln,1)] := InputList[p] p := RepAdd(Poly0ut, 1) end 
In the average case, each PE processes about P/N polygons. This algorithm assumes that N<P, since otherwise 
those PEs with PEid>P do no work. The amount of memory traffic this algorithm would cause is suboptimal, 
since polygon definitions are moved around, rather than their pointers. 3.2.3. Decomposition of Polygons 
into Span-areas As presented in this paper, the scan conversion algorithm presumes the input polygon 
list has been decomposed into span-areas: trapezoidal or tri-angular regions. This idea is not new (see 
[LeeBl, WeinS1, WhWeSl]). Unlike polygons, span-areas have a bounded, concise specification in terms 
of left and right edges. Thus span-areas are useful in scanline-oriented algorithms. However, desirable 
properties of trapezoids such as planarity are not necessarily preserved after geometric transforma-tions. 
Consequently, the input polygon list is preprocessed for each frame. This additional com-putation can 
be circumvented if polygons are tri-angulated once and for all, since triangles remain (trivially) planar 
after geometric transformations (see [FuRa82, Whir81]). The scan conversion algo-rithm easily adapts 
to triangles, but since span-areas are so simple to work with, the algorithm is presented using span-areas. 
Both triangles and span-areas can lead to fragmentation of very small (pixel-sized) polygons, making 
anti-aliasing critical. A maximum of V-1 span-areas are generated for a polygon of V vertices. An O(V 
logV) serial algorithm to decompose a simple polygon into span-areas was recently published [LeeS1]. 
A straightforward, polygon-per-PE parallelisation of this algorithm would yield an o(PV-~-log V) average-case 
running time. As each span-area is generated, it is inserted into the Y-bucket corresponding to the largest 
y value of the span-area. This can be determined on-the-fly with no change in the order statistic.  
 3.2.4. Scan Conversion Each PE performs the following scan conversion loop. for y:=ymin to ymax do 
begin UpdateASL(y) InitialiseScanLine ScanConvert(y) <synchronise> end for UpdateASL places the 
contents of bucket Y[y] into the active span list. All PEs synchronise at the com-pletion of scan conversion 
for each scanline. This is not necessary. If sufficient memory is available, the algorithm easily generalises 
to k-scanlines, k 1. We now consider the scan conversion process in more detail. procedure InitialiseScanLine 
InitialiseXBucket CurrentSpan := 1 <synchronise>  end InitialiseScanLine procedure SeanConvert(y: ymin..ymax) 
span: SpanArea spansLeft: Boolean X: shared Get Span(span,spansLeft) while spansLeft do begin Vx E span 
calculate pixeILnfe: intensity, depth, and coverage mask UpdatePixel(x, pixelInfe) Get Span(span,spansLeft) 
end while AntiAliasScanline(y) end ScanConvert The X bucket contains all required scanline informa- 
tion. It will be discussed shortly, as will the rou- tines UpdatePixel and AntiAliasScanline. GetSpan 
does the obvious: it returns an unpro- cessed span to the scan converter. However, the routine is complicated 
by the fact that we wish to get a subserial worst case behaviour. In particular, large spans should receive 
parallel treatment, for otherwise all PEs could wait for one PE to complete a long span. One approach 
is for PEs to recursively subdivide large spans so that each PE processes a smaller portion of the span. 
However elegant this solution appears, this approach is likely to increase memory traffic substantially. 
The approach we have taken avoids this problem. Assume there is a constant M which denotes the maximum 
number of pixels in a span that a PE is allowed to process at a time. This value may be empirically or 
theoretically determined, and represents a good balance between the overhead in GetSpan and the increased 
effi-ciency in parallel processing of large spans. Multi-ple copies of a span may be returned; the index 
xm is used to indicate the leftmost point of the unpro- cessed portion of the span s . The following, 
is one possible implementation of GetSpan. It is some-what tricky since it must cope with the unlikely 
event that two PEs simultaneously try to get an exhausted span. procedure GetSpan(var span: SpanArea; 
var spansLeft: Boolean) gotSpan: Boolean S, ASL, CurrentSpan: shared M: Constant newLHS: Integer spansLeft 
:= CurrentSpan .c S gotSpan := false while ~gotSpan and spansLeft do begin span := ASL[CurrentSpan] 
 with ASL[CurrentSpan] do be~ } calculate new LHS of span, and see if LHS>RHS newLHS := RepAdd(xm,M) 
 gotSpan := newLHS ~ xr if ~gotSpan then if span is exhausted, the first PE advances CurrentSpan and 
processes the remaining span segment ifnewLHS-xr < M the,, RepAdd(CurrentSpan,1) spansLeft := CurrentSpan 
~ S end with/while if gotSpan then span.xm := newLHS spansLeft := gotSpan end GetSpan  3.2.5. Anti- 
aliasir~ The aliasing problem is immediately apparent to anyone who has seen synthesised raster images. 
Various aliasing artifacts are possible in both still and moving images. An abundant literature describes 
the problem and some of its solutions. See [Crow77, Crow81] for a start. It is thus of prime importance 
to examine whether anti-aliasing can be incorporated into our algorithm. Since we currently compute the 
picture scanline by scanline without backtracking over scanlines, we cannot use any scheme where the 
value at one pixel depends on the value of some of its neighbours, unless we arbi- trarily privilege 
the x direction 8. The best solution under the circumstances is what we can call the Exact Area Sampling 
solution, where the intensity for the pixel is I = A~I~/l~. A, and/~ are the areas and intensities of 
the visible surfaces within the pixel, and A is the total area of the pixel. If colour is used, this 
formula is used for the three primaries. As pointed out in [Catm78], and imple- mented there and in [FuBar79], 
this requires a hid- den surface algorithm at the pixel level. We can establish a more formal lower 
bound, by showing that any algorithm that computes the EAS can be used to determine the order of a list 
of ~% non-negative integers. The reduction is as follows. Given alist NI,N2,...,N~ of numbers, construct 
a scene with ~% rectangles of depth Ni , with the left, top and bottom edges coincident with the pixel 
left, top and bottom, and the right edge of rectangle ~ at N~. Without loss of generality, assume that 
the pixel right edge is at max(N i ). Let the intensity ~ of each rectangle be D i-I where D is a constant 
greater than max (Ni) - rain (N~). The answer to the gAS problem is then: 6. The idea is not totally 
without merit, since as seen on broad-cast television it produces decent images. Note, moreover, 5. See 
the definition of the SpanArea data type above, that a k-sean/ine version (k > I) of the algorithm would 
per- rnit a mltltJp]e-pixe] anti-aliasing scheme. H x~Di-I(N~-Np ) where H is the height of the pixel, 
and N~ is the predecessor of N¢ in the sorted order. The predecessor of min(Ni) is 0. This transformation 
can be done in 0(n) time. It is clear that the answer, when expressed as a base D number, contains Ni 
-Np in the i th digit (from the least significant), and that therefore in 0(n) time one can find, for 
every number, its predecessor in the sorted order. Computing the answer to the EAS problem allows sorting 
with a 0(n) time transfor-mation, and therefore takes at least 0(nlogn) time. While this does not prove 
that it is necessary to solve the hidden surface problem to solve the EAS problem, this shows that nothing 
easier than sort-ing will do it. For other results about the EAS, see [FoFu83]. In view of this result, 
we will aim for an approxi-mate solution. Our approach will be to limit the amount of computation and 
to utilise parallelism as much as possible. We subdivide the pixel into ~z ×n subpixels. It is convenient 
to have ~ a power of 2, for example n =23=8. For each line which intersects a pixel, the two intersection 
points along the boundaries of the pixel are used as an index into a lookup table, whose entries give 
the subpixels covered by the halfplane defined by this line. We will call this entry the mask for this 
halfplane. In our example, the mask would be a 64 bit number. Each intersection with the boundaries of 
the pixel is computed with k bits of fraction (where there are 2 k intervals, since the fraction n/n= 
1 in the current pixel is 0 on the next pixel). In our example, then, k=3. Thus each inter-section can 
be fully described as a k +2 bit number, 2 bits to identify the boundary crossed, and k bits to give 
the crossing position along the boundary (see Figure 2). The total entry for a line is then a 2(/¢ +2) 
bit number, which in our example is a i0 bit number. This gives a 1K×64 bit table, which is small enough 
to allow a copy for each PE. Alternatively, several PEs could directly share such a read-only table. 
  t lz / Code= Iii0100011 O0 Ol ~'~ i r t 51 3  c/ II II Mask= FSFOE00080000000 X b i0 Figure 2. 
PL~el-/,~,ne ~,~tersecL~o~ e~cod'i,~g. The order of the intersections is relevant, since the line should 
be oriented. We adopt a convention that the inside is to the right when going from the first intersection 
to the second. The size of the table can be reduced by making it into a triangular array, and using an 
extra bit to indicate the direction, which will tell whether to complement the mask or not. The table 
is of course precomputed, and each bit is on if the subpixel corresponding to it is more than half-covered 
by the halfplane described by the index. Of the four edges of a normal span-area, two are horizontal, 
and are relevant only at the start and at the end of its scanning. For these, a small special lookup 
table can be used, with the y fraction used as the index. For the other two edges, updating the intersection 
information from pixel to pixel is fairly simple, and requires only additions and subtrac-tions. The 
coverage mask has interesting boolean proper-ties. Indeed, the mask for the intersection of a span-area 
with a pixel is the and of the masks of the span-area°s edges which cross the pixel. Thus we get an accurate 
representation of the subpixels covered by a given span-area. It is also easily seen that the mask for 
the background (indicating the subpixels where the background is seen) is the com-plement of the or of 
all the span-area masks for this pixel. It is unfortunately impossible to go much farther without making 
some approximations. The problem is that we do not want to compute the Z values at the subpixel resolution, 
since it would be tantamount to going to a higher resolution. Each span-area at a given pixel is then 
associated with only one Z value, namely its Z at the centre of the pixel. Given that, we cannot guarantee 
that the depth comparison allows the visible areas to be exactly determined, unless the planes of support 
of the span-areas do not intersect within the pixel (see Figure 3). We will give two approximation algo-rithms, 
and discuss where they succeed, and where they fail. Let weight (mask) be the fraction of the pixel covered 
by a mask (this can be easily com-puted by counting the number of one bits in the mask). The span-area 
with the smallest Z value is called the zvirLner; the others are called losers. There are two ways to 
compute the final pixel inten- sity. One way necessitates the use of an X-bucket to hold pixel information 
for each span-area intersect-ing with the current scanline; a pass over the con-tent of this bucket would 
be performed at the end of the scanline, since the final intensity cannot be computed until the winner 
is known. The other approximation can be computed on-the-fly, and is almost as accurate as the first. 
The two methods calculate intensities fz and 12, respectively, as fol-lows. It = ff~.'n~e~'Comp + LoserCo~rtp 
1 + B~ckWro~nddb~rtp [m= ~vtvte~.Corctp + Los~rCor~p 8 + Igaclc~rou~tdCo~p W~vtne~Comp = 1. x~veight 
(.~ask~ ) B~.ckgrouTtdCov%p = It x~ue£gh~ (AAtlMa~k~ ) ZoserCornp * = Cot ,x~l~=,, x'we£gh, f (m.ask~ 
Arn, o.s/c.=, ) Lose?'Corrt~ = = CoT" =xtue£glt~ (rrtcslc= )X ~.~ x~ue~gltf (rrtllskl ) =ll l oe~,llh, 
t (ra.ask,~ Arn, asl~ ) , CO~"~ = ~ue~glt¢ (wta.slcb Ar/taSP.~.). The subscripts ~o ,t, and b, stand 
for "winner", "loser", and "background", respectively. The correction factors are ratios of the actual 
coverage by the losers compared to the sum o3 their indivi- dual coverage as computed by each algorithm. 
Therefore the correction factors give a measure of the amount of overlap of the losers, hence of the 
possible error.  3.2.5.1. First approximate anti-aliasing algorithm This solution requires an X bucket. 
For each pixel, several additional pieces of irdormation are kept: the current winner, background data, 
the losers' intensity, and their sum of coverage-mask weights. The following data structures are used. 
 x bucket. Xp contains list of number of span-areas per pixel I X:matrix xmin..xmax I..PV of PixeIInfo 
Xp: array xmin..xmax of 0..PV := 0 Additional pixel information I Pixels: array xmin..'xmax of Winner, 
Back: PixeIInfo Loserlnt, Sum0fWeights: Integer  PixelInfo:type record of Depth Int ~intensity Mask 
~ coverage mask J end Pixel[nfo The ScanConvert routine above executes the follow- ing version of UpdatePixel 
and AntiAliasSeanline. Recall that each PE executes ScanConvert. procedure UpdatePixel(x: xmin..xmax, 
pix: PixelInfo) Add pixel from this span into bucket X[x,RepAdd(Xp[x], I)] := pix pix may be a "winner" 
 RepMin(Pixels [x] .Winner,pix) I Determine how much background is covered by pix  RepAnd(Pixels [x].Back.Mask, 
pix.Mask) end UpdatePixel procedure AntLAliasScanline(y: ymin..ymax) x:Integer winner,pix: PixelInlo 
 Initialise Cx to xmin while Cx ~ xmax do be~ } Many PEa work on each pixel (i.e. X bucket) x := 
RepAdd(Xp[Cx],-1) + i ~ get pixel info for span winner := Pixels[Cx].Winner while x > 0 do begin pix 
:= X[Cx,x] if pix ~ winner then begin pix is a loser, calculate its contribution newMask := pix.Mask 
A winner.Mask newlnt := Weight(newMask) x pix.lnt RepAdd(Pixels [ Cx].Loserlnt, newInt) RepAdd(Pixels 
[Cx]. SumOfWeights, Weight(newMask)) end if x := RepAdd(Xp[Cx],-I) + 1   end while if x = 0 then 
begin PE with x=O adds background and losers' contrib I for Pixels[Cx], compute: c := Weight(Back.Mask/\Winner.Mask)/SumOfWeights 
RepAdd(Winner.Int, cxLoserlnt + Back.lnt) R~pAdd(Cx, i) end then else <synchronise> }all other PEa 
waitl  end while end AntiAliasScanline 3.2.5.2. Second approximate anti-aliasing algo- rithIn No X 
bucket is required in this solution. We only keep four pieces of information for each pixel, Winner, 
Back, Sum0fWeights, and Losers. Winner, Back, and Sum0fWeights are as in the first solution; Losers is 
used to keep track of the losers' coverage and intensity contributions on-the-fly. procedure UpdatePixel(x: 
xmin..xmax, pix: PixelInfo) loser: PixelInfo loser := RepMin(Pixels[x].Winner, pix) intContrib := loser.lnt 
x Weight(loser.Mask) RepAdd(Pixels [x].Loser s.lnt, intContrib) RepAnd(Pixels [x].Back.Mas k, loser.Mask) 
 RepAdd(Pixels [x].S um 0fWeights, Weight(pix.Mask)) end UpdatePixel procedure AntiAliasScanline(y: 
ymin..ymax) each PE handles a pixel, so if N > X, some PEs are idle I x := PEid + xmin -I while x 
< xmax de begin pix := Pixels[x] compute background and losers' intensity contrib I backlnt := pix.Back.Int 
× Weight(pix.Back.Mask)  c := Weight(pix.Back.Mask/Xpix.Winner.Mask)/pix.Sum0fWeights loserInt := pix.Losers.Int 
x Weight(pix.Winner.mask) × c RepAdd(Pixels [x].Winner.lnt, back[nt+loserLnt) x:=x+N end while  end 
AntiAliasScanline 3.2.,5.3. Analysis of the approximations These approximations, and indeed all approxima- 
tions of this kind, should be characterised in three ways: when they are right (here right is to be under- 
stood exact within the subpixel resolution), when they are wrong and how wrong they can be, and when 
they are cortsiste~ztty wrong. The last is important, since aliasing is particularly noticeable  Computer 
Graphics in motion, by crawling, scintillation and other annoying artifacts. If an algorithm computes 
a wrong shade, but is consistent as the polygons move, then these artifacts will be avoided. Both solutions 
will be right when there is only one span-area within the pixel, whether it covers the whole pixel or 
not. As long as a span-area covers at least one subpixel (1/64 of a pixel in our example), it will contribute 
to the total intensity of the pixel. Both solutions are also right when none of the span-areas overlap. 
This is especially important, since we might have cut a polygon into numerous small span-areas. Fortunately 
we will not have to pay a heavy price in aliasing problems. In fact, the problems, if any, will be at 
the silhouette edges of the objects, and not against the background, but against each other. The first 
solution has the addi-tional advantage of being right when the winner overlaps the losers, but the losers 
do not overlap each other. The second algorithm will be right in case of overlap by the winner if the 
loser coverage ratio is sensibly the same under the winner as in the rest of the pixel. Figures 3 and 
4 give examples of wrong cases, and the errors made by each algorithm. Figure 3 shows the worst case 
for both algorithms, where the amount of overlap of the losers and the area they cover is maximal. Figure 
4 shows a case where the first algorithm is right and the second is wrong. ~xture 3. The worst case for 
both algo'M,f, hrr~s. Span 1, the winner, covers a sliver of the pixel. Losing span 2 obscures another 
loser, 3. Z I<Z ~<Z 3 Correct Answer -~ Iz Iz + Is Computed Answer = -- 2 Error = 18 -Is 2 Figure 
4. A bad case for algor'~thrn 2 o~y. Winning span 1, covering half the pixel, obscures losing span 3. 
Losing span 2 covers half the pixel as well. Z,<Zz<Zs Correct Answer = Ii + le Z i  Algorithm 1 - I1 
+ I8 2 It+ Iz+Is  Algorithm2 = 2 2 Error 2 = Iz - [a 4 A gross estimate of the extent of the errors 
for 103 polygons, covering an average of l0 s pixels each, and  Volume 17, Number 3 July 1983 with 
10 2 boundary pixels each, on a screen with 10 e pixels, shows that less than 5E of the pixels would 
have an error, and that for these the average error would be less than 10~ of the shade of the pixel. 
As the polygons move with respect to each other, we avoid the numerous problems of point sampling. Since 
the wrong cases are computed from averages, the errors made will not exhibit large discontinui-ties, 
but will be consistent from frame to frame. In the example of Figure 3, as polygon 3 moves out of the 
pixel, its contribution to the pixel intensity will go smoothly from ~-13 (which is wrong), to 0 (which 
is right). 3.2.6. Discussion An implementation of this algorithm has been made, demonstrating that the 
approach works, and i11us-trating a realisation in a pseudo-concurrent language. The implementation is 
written in Con-current Euclid, a language developed at the Univer-sity of Toronto which supports processes 
and moni- tors. Concurrent operations such as RepAdd are simulated using monitors. The only relevant 
aspect in which our implementation differs from one on an ultracomputer is speed. The lack of "true" 
con-currency, and the 0(N) performance of concurrent operations (compared to O(IogN) on an ultracom-puter), 
make our implementation somewhat slower than would be expected on an ultracomputer. The algorithm above 
has several appealing proper-ties. It is independent of N, the number of PEs in the ultracomputer. Indeed, 
the speed of the algo-rithm is inversely proportional to N, up to a lower >XY bound constant when N --~--. 
A good serial algo- rithm is obtained when N= i. We emphasise the fact that the anti-aliasing techniques 
presented here easily transfer to serial environments, as illus-trated here. Another property of the 
algorithm is that although it scan converts polygons, the general approach adapts to other scene representations 
(e.g. scanline methods for parametric surfaces as in [BCLW80]). Several improvements could be made to 
the algo-rithm. An issue deserving of attention is space complexity and memory traffic. By using dynami-cally 
allocated shared memory and pointers, the amount of storage required would be drastically reduced; memory 
traffic would decrease, since pointers would travel through shared memory. However, indirect shared memory 
references require two passes through the connection network. A solution is to make greater use of the 
cache memory local to each PE. A copy of the static pointers may be placed in the local memory for each 
PE, thus saving the O(log N) connection net-work cycle time. 4. Other Ultracomputer Applications and 
Future Research As the plethora of published parallel algorithms shows [Schw801, the ultracomputer is 
truly a power- ful, general-purpose tool. Fast parallel algorithms exist for matrix multiplication, 
sorting, linear pro- gramming, fluid dynamics, etc. We hope to have demonstrated that the ultracomputer 
has great 148 potential in the computer graphics field. Other applications would also significantly 
benefit from ultracomputer implementation. For instance, a parallel queue could be exploited to parallelise 
ray-tracing algorithms [WhirS0]. Since the processing of one ray (or alternatively, one pixel) is an 
indepen-dent task, we believe significant speed-up in ray-tracing can be achieved on an ultracomputer. 
Simi-larly, we believe many problems in image process-ing, signal processing, and artificial intelligence 
are likely to benefit. 5. Acknowledgements We wish to thank John Amanatides and Peter Schoeler for their 
suggestions, which have improved the clarity of this paper. The first two authors gratefully acknowledge 
the financial sup- port of the Natural Sciences and Engineering Research Council of Canada. References 
<RefA>BCLW80 Blinn, J.F., L.C. Carpenter, J.M. Lane, and T. Whitted, "Scan line methods for displaying parametrically 
defined surfaces", Comm. ACM 23, 1 (Jan. 1980), 23- 34. Catm78 Catmull, E., "A Hidden-Surface Algorithm 
with Anti- Aliasing", Computer Graphics (ACM), 12, 3, (Aug. 78), 6-11. Clar82 Clark, J.H., "The geometry 
engine: a VLSI geometry system for graphics", Computer Graphics (ACM) 16, 3 (July 1982), 127-134. Crow'/? 
Crow, F.C., "The Aliasing Problem in Computer- Generated Shaded Images", Comm. ACM 20, 11 (Nov. 1977), 
799-805. CrowS1 Crow, F.C., "A Comparison of Antialiasing Tech- niques", IEEE Computer Grc*pltics a~.d 
Applieat~o~zs, 1, 1 (Jan. 81), 40-49. FPPB82 Fuchs, H., J. Poulton, A. Paeth, and A. Bell, "Develop- 
ing PIXEL-PLANES, a smart memory-based raster graphics system", 1982 Conference oR Advanced ReseaTch 
in VLSI, MIT, January 1982, 137-146. FoFuB3 Fournier, A. and D. Fussell, "On the Power of the Frame 
Buffer", unpublished manuscript, 1983. FuBar79 Fuchs, H. and J. Barros, "Efficient Generation of Smooth 
Line Drawings on Video Displays", Computer Graphics, 13, 2, (Aug. 79), 260-269. FuPo81 Fuchs, H., and 
J. Poulton, "PtXEL-PLANES: a VLSI-oriented design for 3-D raster graphics", CMCCS Conference Proceedings, 
(June 1981), 343-348. Full82 Fussell, D., and B.D. Ratl~i, "A VLSI-oriented architec- ture for real-time 
raster display of shaded polygons", Graphics/nferfa~e "82,May 1982, 373-380. Fueh77 Fuchs, H., "Distributing 
a visible surface algorithm over multiple processors", Proceedings of ACM 1977, Seattle (Oct. 1977), 
449-481. C~KM8$ Gottlieb, A., R. Grishman, C.P. Kruskal, K.P. ~IcAu- liffe, L. Rudolph, and M. Snir, 
"The NYU Ultracomputer--designing an MIMD shared memory parallel computer", IEEE Transactions on Comput-ers, 
C-32, 2 (Feb. 1983), 175-189. GoM~3 GuSS81 La~-75 Lee81 NeSp?9  ParkS0 Sehw80 SuSS74 Wein81 WhWe51 Whe152 
WhitSO Whit81 Gottlieb, A., B.D.Lubachevsky, and L. Rudolph, "Basic techniques for the efficient coordination 
of very large numbers of cooperating sequential proces-sors", l~ransact~i,o~s oR Progrcsrnrni, ng Languages 
a~l ~ystem.s (ACM) 5, 2 (Apr. 1983), 164-189. Gupta, S., R.F. Sproull, and I.E. Sutherland, "A VSLI architecture 
for updating raster scan displays", ComputeT Graphics (ACM) 15, 3 (Aug. 1981), 71-78. Lawrie, D.H., "Access 
and alignment of data in an array processor", IEEE Transactions oR Computers, (:-.24,12 (Dec. 1975), 
1145-1155. Lee, D.T., "Shading of regions on vector display dev- ices", ComputeT GrapAics (ACM) 15, 
3 (Aug. 1981), 87-44. Newman, W.M., and R.F. Sproull, Principles of 2nteTac~ve ComputeT Graphics, Second 
Edition, McGraw-Hill, New York, 1979. Parke, F.I., "Simulation and expected performance of multiple processor 
z-buffer systems", Computer Ccraph~cs (ACM) 14, 3 (July 19B0),48-56. Schwartz, J.T., "Ultracomputers", 
Tran~ac~$on.v oR Programming I_~nguages and ~lstern~ (ACM) 2, 4 (Oct. 1980), 484-522. Sutherland, I.E., 
R.F. Sproull, and R.A. Schumacker, "A characterization of ten hidden-surface algo-rithms", Compu~ng Surveys 
(ACM) 6, 1 (March 1974), 1-55. Weinberg, R., "Parallel processing image synthesis and anti-aliasing', 
Computer Graphics (ACM) 15, 3 (Aug. 1981), 53-62. Whitted, T., and D.M. Weimer, "A software test-bed 
for the development of 3-D raster graphics systems", Computer Graphics (ACM) 15, 3 (Aug. 1981), 271-277. 
Whelan, D.S., "A rectangular area filling display sys- tem architecture", Computer Graphics (ACM) 16, 
3 (July 1982), 147-153. Whirred, T., "An improved illumination model for shaded display", Comm. ACId 
23, 6 (June 1980), 343- 349. Whitted, T., "Hardware enhanced 3-D raster display systems", CMCCS Conference 
ProceedS, rigs, (June 1981), 349-356</RefA>.   
			


 A Framework for Supporting Data Integration Using the Materialized and Virtual Approaches* . Richard 
Hull Computer Science Department University of Colorado Boulder, CO 80309-0430 hull@ cs.colorado .edu 
Abstract This paper presents a framework for data integration currently under development in the Squirrel 
project. The framework is based on a special class of mediators, called Squtrrei integration medzators. 
These mediators can support the traditional virtual and materialized approaches, and also hybrids of 
them. In the Squirrel mediators, a relation in the integrated view can be supported as (a) fully materialized, 
(b) fully virtual, or (c) partially materialized (i.e., with some attributes materialized and other attributes 
virtual). In general, (partially) materialized relations of the integrated view are maintained by incremental 
updates from the source databases. Squirrel mediators provide two approaches for doing this: (1) materialize 
all needed auxiliary data, so that data sources do not have to be queried when processing the incremental 
updates; or (2) leave some or all of the auxiliary data virtual, and query selected source databases 
when processing incremental updates. The paper presents formal notions of consistency and freshness for 
integrated views defined over multiple au­tonomous source databases. It is shown that Squirrel medi­ators 
satisfy these properties. Introduction The advent of the Information Superhighway has dra­ -. matically 
increased the need for efficient and flexi­ble mechanisms to provide integrated views over mul­tiple 
information sources. The traditional approach to this problem is to represent the view in a virtuai fashion; 
queries against the view are decomposed and sent to the remote sources [SBG+81, DH84, LMR90, *This research 
was supported in part by NSF grant IRI-931832, and ARPA grants BAA-92-1092 and 33825-RT-AAS. t A student 
at the University of Southern California, in residence at the University of Colorado. Permission to make 
digitalmard mpy of part or all of this work for personal or classroom use is granted without fee provided 
that cupies are not made or distributed for profit or commercial advantage, the copyright notice, the 
title of the publication and Its date appear, and notice is given that copying is by permission of ACM, 
Inc. To mpy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior 
specific permission and/or a fee. SIGMOD 96 6/96 Montreal, Canada (CI 1996 ACM 0-89791 -794-4/96/0006 
...$3.50 Gang Zhou 1 Computer Science Department University of Colorado Boulder, CO 80309-0430 gzhou@cs.colorado. 
edu T+90, ADD+91, ACHK93]. A complementary ap­proach has emerged recently, that is based on storing 
the view in materialized form [WHW89, ZHKF95, ZHK95, ZGHW95]. In that approach, queries can be answered 
without accessing the source databases, and the ma­terialized view is typically maintained via propagation 
of incremental updates. Speaking broadly, the virtual approach may be better if the information sources 
are changing frequently, whereas the materialized approach may be better if the information sources change 
infre­quently and very fast query response time is needed. The virtual and materialized approaches represent 
two ends of a vast spectrum of possibilities. This paper de­velops a general and flexible framework for 
supporting integrated views using a hybrid of these two approaches. In the framework developed here, 
a relation in the integrated view can be supported as (a) fully material­ized, (b) fully virtual, or 
(c) partially materialized (i.e., with some attributes materialized and other attributes virtual). In 
general, (partially) materialized relations of the integrated view are maintained by incremental updates 
from the source databases. Two approaches for doing this are provided in our framework: (1) (fully materialized 
support [ZHKF95, ZHK95]: materialize all needed auxiliary data, so that data sources do not have to be 
queried when processing the incremental up­dates; and (2) leave some or all of the auxiliary data virtual, 
and query selected source databases when pro­cessing the incremental update. A view with fully ma­terialized 
support has been termed self-maintainable in [GJM96]. The framework presented in this paper forms one 
aspect of the Squirrel project currently under way at the University of Colorado [ZHKF95, ZHK95]. The 
framework is based on a special class of mediators [Wie92], called Squirrel integration mediators. Squirrel 
is a tool that can be used to generate these mediators from high-level specifications. References [ZHKF95, 
ZHK95] describe a restricted form of Squirrel mediators, that support only fully materialized integrated 
views with full materialized support; they do not address the issue of virtual or hybrid integrated views. 
The present paper substantially generalizes and ex­tends the work of [ZHKF95, ZHK95] by developing a 
framework for supporting hybrid materialized/virtual integrated views. In particular, we describe a gener­alized 
architecture for Squirrel mediators that supports hybrid integrated views, and we present the key algo­rithms 
used by these mediators. The discussion here is presented in terms of the relational model, and the general 
spirit of our techniques can be applied in the context of the object-oriented database model. The Squirrel 
mediators implement a synthesis of sev­eral technologies, including query processing against vir­tual 
integrated views [LMR90], algorithms for updating materialized views [BLT86, GMS93, GL95, ZGHW95], the 
use of the active paradigm to implement those al­gorithms [C W91, Cha94], and the use of active mod­ules 
to provide light-weight, customizable activeness [Da195, BDD+95]. A central construct used by Squirrel 
mediators to sup­port integrated views is the notion of View Decom­position Plan (VDP). A VDP provides 
a systematic framework for synthesizing the above technologies in order to support materialized, virtual, 
and hybrid re­lations. In particular, this includes support for (i) re­trieval from source databases 
of virtual data needed to answer queries, and (ii) incremental update of materi­alized data (including 
querying of source databases as necessary). VDPS provide a framework for optimizing support for integrated 
views in a manner reminiscent of query execution plans. This paper presents formal notions of consistency 
and freshness for integrated views defined over multiple autonomous source databases. Consistency guarantees 
that the state of the view at any time corresponds to a family of states of the source databases (although 
not necessarily states that existed simultaneously). Freshness ensures that updates to source databases 
are reflected in the view within a bounded time. It is shown that if the source databases and network 
satisfy certain natural conditions, then Squirrel mediators satisfy the consistency and freshness properties. 
Section 2 uses a simple example to illustrate differ­ent kinds of hybrid integrated views and how Squirrel 
mediators can support them. Section 3 presents the formal notions of consistency and freshness. Section 
4 presents the architecture of Squirrel mediators. Section 5 describes VDPS. Section 6 describes the 
three central algorithms used by Squirrel mediators to support hybrid integrated views. Section 7 shows 
that Squirrel medi­ators satisfy the consistency and freshness properties. Some future research directions 
are offered in Section 8. Due to space limitations, many details are omitted in this paper; see [HZ96]. 
= %l,rislsz (R ~rz=sl s ) = 7T~*,@S~3 < 50s I I I Mediator A Source DBs [s1> 52>531 s - Figure 1: An 
annotated VDP for an integrated view T = r~l,r,,,l,., (a?.4=looR ~,,=sl 0,,<50s) 2 Motivating Examples 
and Intuitive Remarks This section presents three related examples to give a progressive overview of 
several key aspects of Squirrel mediators. Example 2.1 illustrates how a Squirrel mediator maintains 
a materialized relation T that has fully materialized support, and introduces the central notion of annotated 
VDP. Example 2.2 modifies the first example by allowing some of the auxiliary supporting data to be virtual. 
Providing support for T as a hybrid (partially materialized) relation is described in Example 2.3. Example 
2.1: Let R(cI, 72, T3, rq ) with key rl and S(gl, S2, S3) with key S1 be two relations from distinct 
databases. Suppose that the integrated view supported by a mediator has the single export relation T 
= ~r,,r,,s,,.~(~,,=IooR %=,, a,,<sos). A VDP for T is shown in Figure 1. Each non-leaf node in the VDP 
corresponds to a relation maintained by the mediator, and each leaf node corresponds to a relation in 
a source database. The attributes of the relations are shown to the left of the nodes. The relationship 
between a node and its children nodes indicates that the relation of the parent node is derived directly 
from relations of the children nodes. An attribute of a relation of a non-leaf node is annotated as either 
materialized or virtual. For example, the attribute notation [r~, r~, ST, S2 ] for the node T indicates 
that all four attributes are materialized, i.e., the relation T is fully materialized. In fact, all the 
relations maintained by this mediator are fully materialized. Supporting queries against relation T is 
trivial. The incremental maintenance of T is supported by the auxiliary relations R and S that are fully 
materialized. As will be discussed in Subsection 5.2, the rules responsible for propagating updates from 
R and S to T are: rule #1: on changes to R , AT = AR W S ; rule #2: on changes to S , AT = R N AS ; where 
AQ denotes the net change to a relation Q. In this context, T can be maintained using incremental updates 
from the source databases and data local to the mediator, without querying the source databases. 1 The 
next example modifies the previous example by selectively materializing the auxiliary data for T. Example 
2.2: Assume that updates to relation R are frequent, but updates to relation S are infrequent. To reduce 
the overhead of continually maintaining R and to conserve space in the mediator, we change the annotation 
of R to be [r~, r;, r;], where the superscript v stands for virtual. So R is fully virtual. The annotations 
for S and T are unchanged. Rule #1 introduced in Example 2.1 shows that in response to a change AR1 to 
RI, AT is computed solely from AR1 and S . So letting R be virtual does not delay the propagation of 
updates against R, i.e., the majority of updates. In the rare case when updates to relation S occur, 
the mediator must incur the expense of sending queries to relation R to compute AT. 0 The next example 
will not only have some auxiliary data virtual, but also keep some infrequently accessed attributes of 
the export relation T virtual. lt e describe how queries are answered, and how the values of virtual 
attributes are obtained when needed. Example 2.3: Assume that queries against relation T mainly refer 
to attributes rl and S1, i.e., to r,,,$l T. For this example, we choose the annotation for the VDP to 
be: T[r~, r?j, s~, s20] , R [T~, r;, r;], s [s~,s;]. The response time to the queries that only refer 
to rl and S1 is not affected by the fact that r3 and S2 are virtual. With this annotation, answering 
queries involving attributes T-1 and S1 is straightforward. How does the mediator answer a query involving 
one or more virtual attributes, e.g., the query q = n-.,,., u., < 100T? The mediator constructs a temporary 
relation that is equivalent to the answer of q. For this example, the temporary relation will be Tkp 
= iT,3,.la.3<IOOT. This can in turn be constructed from relations of the children nodes of T, namely 
R and S , as: Tt~~ = m~3,~1(a~3<IOOR W-z=s~ s ) In this manner, the VDP serves as a guide concerning 
what temporary relations need to be materialized in order to answer a query against an export relation. 
Sometimes, there are more efficient ways to construct Tt~p by using integrity constraints inherited from 
the source databases. but that is not the focus of this paper. 0 The preceding examples showed how a 
single VDP can be used to support a variety of different combination of materialized and virtual support 
for an integrated view. VDPS are quite similar to query execution plans, in that both data structures 
represent a decomposition of one or more queries. VDPS are used to support queries against an integrated 
view, to hold materialized portions of the view, and to organize the incremental maintenance of those 
materialized portions. As a result, the VDP of a Squirrel mediator is relatively static, although one 
VDP may be migrated to another VDP as a result of optimization. The annotation of a VDP might also be 
modified. In contrast, query exec ution plans are typically developed on a query by query basis. 3 Formal 
Notions of Correctness The kind of consistency that should be supported for a view depends on the context 
of the view definition. If source data and a (materialized or virtual) view is within a single database 
system, then the view can be designed to reflect the current database state. In the materialized case 
this is accomplished by combining within a single transaction both updates and update propagation to 
the view. Typically, a virtual or materialized view defined over remote databases will reflect some state 
of the sources, but not necessarily their current state. This section develops formal notions of correctness 
for the context where an integrated view over multiple source databases is supported in a separate database 
system. We assume that the source databases are relatively autonomous, and do not assume that they participate 
in global transactions. As a result, there is generally no global state of the multiple autonomous databases. 
The formal definitions given below capture natural intuitions about consistency and freshness in this 
context. The integration mediators described in this paper satisfy these properties (see Section 7). 
-An zntegratzon enwronrnent consists of a sequence DB = (DB1, . . . . DB. ) of source databases, a view 
definition v that defines an integrated view of portions of the source databases, and a database V, which 
is intended to hold that view. The environment is presumed to include software that supports V in some 
manner. (The view may be either materialized or virtual, or a hybrid of these. ) JVe shall use the following 
notation. ~ a time vector in the form of (tl, . . . . tn). We write ~S ~, ifti ~ t( for each i c [I, 
n]. Also, ~< ~, if ~S ~and i# ~. If tis a time and ~ a time vector, then t s ~ means that (t, .... t) 
< ~; t< ~, etc., are defined analogously.  state(d, t): the state of d at time t,where d ranges over 
DBi or V.  e sfate(D4B, ~): the state vector of databases D-B at time ~ i.e., (state(DBl, tl), . . .,state(DBn, 
tn)). v(s): a view defined on a state (vector) s of source database(s). We now define the notions of 
consistency and fresh­ness for integration environments. In these definitions we let t .,eW_%n,t denote 
the time at which the view is initialized. Definition: [Consistency] An integration environment is consistent 
after time t .,eW ~n,t if there exists a reflects function r 7$ : Time + (Tz me)n such that: (a) [Validity] 
For each time t ~~viewinit, state(V, t) = v(state(DB, r;f(t)). (Intuitively, this means that the state 
of the view at time tshould correspond to some state vector of the source databases. We do not insist 
that the view corresponds to the set of source database states at a single time t ,because updates from 
and accesses to the source databases will typically be asynchronous.) (b) [Chronology] For each time 
t > tviewjnitand each iE [l, n], t ~ ri! ~(t),. (Intuitively, this insists that the state of the view 
at time t corresponds to the source databases at a times ~ t, i.e., the view does not forecast the future 
. ) (c) [Order preserving] For each pair tl, t2 of times satisfying tu,ewJn%t~ tl~ t2, r-;f(t~) < rzf(t~). 
 (Intuitively, this insists that successive states of the view correspond to successive (vectors of) 
states of the source databases.) We now give a definition that captures an intuitive property of freshness: 
Definition: [Guaranteed freshness] An inte~rated view is guaranteed fresh within time vector ~ after 
time tviewtinit if for each t ~ toiewinii there is a ~ such that state(V, t) = u(state(DB, ~)) and t 
t:< fi for i E [1, n]. (Intuitively, this states that for each time t > tU$eW~n%t, the contents of the 
view at time t correspond to recent states of the source databases. The definition is based on a time 
vector ~ rather than a single time, to accommodate integration environments where some databases announce 
updates very quickly, while others announce them only periodically, e.g., once every 24 hours). 4 Overview 
of Squirrel Mediators SquirreI mediators support integrated views derived from multiple remote source 
databases (see Figure 2). A mediator consists of five components: a local store, a query processor (QP), 
a virtual attributes processor (VAP), an update-queue, and an incremental update processor (IUP). The 
local store contains the VDP that represents the schema and the derivation relationship between relations 
in the local store (more details in Section 5), the materialized portion of the view, other supporting 
materialized data, and a rulebase that specifies the incremental maintenance of the materialized data 
in a declarative fashion. The QP provides the interface for querying the view. Upon receiving a query 
against the view, the QP determines first whether the query can be answered solely based on the materialized 
portion of the view. In case virtual data is needed to answer the query, the QP requests the VAP to construct 
temporary relations containing the relevant data (see Subsection 6.3). The update-queue holds incremental 
updates from remote information sources, and the IUP is responsible for propagating the updates accumulated 
in the queue into the materialized data according to the rules in the rulebase (see Subsection 6.4). 
There are three kinds of information flow within an integration mediator. One involves incremental updates 
against the source databases, which flow into the update-queue; they are then propagated into the integrated 
view under the control of the IUP. The second kind of information flow is generated by the VAP that sends 
(receives) queries (answers) to (from) the source databases. The third kind of information flow involves 
queries posed against the integrated view, and answers made in response to them. Importantly, humans 
and processes that query the Squirrel mediator need only be aware of the query processor. There are three 
ways a source database can be associated with the mediator. First, a source database is called a materialized-contribut 
or, if all its contribution to the mediator is in the materialized data portion of the mediator. Second, 
a source database is called a hybrid-contributor, if part of its contribution to the mediator is to the 
materialized portion and part to the virtual portion. Finally, a database is called a virtual­contributor, 
if it contributes only to the virtual portion. We now mention several assumptions that are made about 
the source databases and the network. It is assumed that source databases in the first two categories 
above actively send messages to the mediator specifying incremental updates that have occurred to the 
database. In order to guarantee that the integrated view satisfies the correctness conditions defined 
in Section 3, we assume that the messages (including both incremental updates and query answers) transferred 
from each source database to the mediator are in order. Also, each message sent from the source database 
corresponds to a family of one or more consecutive transactions Answers .. ..... . . .. . .. . .- .-! 
.. .. -.. - ---..---.., .-w . . . ... ... .. .. Squirrel Mediator 11 materialized-hybrid-virtual­contributor 
DBs contributor DBs contributor DBs Figure 2: A Squirrel mediator connected with multiple source DBs 
that occurred in the database. Databases in the last not consider the use of attribute-renaming (see 
[HZ96]). two categories must be able to answer queries from Although the view definition language is 
based on set the virtual data processor, so that the relevant virtual semantics, some of the relations 
stored inside an inte­data portion in the mediator can be evaluated when gration mediator may be bags, 
in order to support our necessary, Since a virtual-contributor database only incremental maintenance 
algorithms; this occurs if the needs to be able to answer queries, its role can be played integrated 
view involves projection or union. Another by all kinds of DBMSS, including legacy systems that part 
of the language specifies object matching . See do not have active database capabilities. [ZHKF95, ZHK95]. 
5 Annotated View Decomposition Plan 5.1 Definition We now present the definitions of VDP and annotationsThe 
skeleton of a Squirrel-generated integration media­ for them. Formally, a VDP is a labeled dag V = A 
VDP specifies the relations that the integration me-(V, E, relation, source, clef, Export) where V k 
a set of tor is provided by its View Decomposition Plan (VDP). diator will maintain (either materialized, 
virtual, or hy-nodes, E is a set of edges over V, and such that: brid), and provides the basic structure 
for supporting 1. The function relation maps each node v E V into incremental maintenance of materialized 
data and eval-a specification of a distinct relation, which includes the uation of virtual data. This 
subsection presents the def-name of the relation and its attributes, We often refer inition of VDP and 
gives an example. to a node v by using the name of relation. As will be defined formally below, the VDP 
of an in-2. source is a function that maps the-leaves of V into tegration mediator is a directed acyclic 
graph (dag) that the set of source databases of the mediator. The leaves represents a decomposition of 
the integrated view sup-of V correspond to relations in the source databases, ported by that mediator 
(see Figure 1). The leaf nodes and are depicted using the 0 symbol. Other nodes are correspond to relations 
in the source databases, and the depicted using a circle. other nodes correspond to derived materialized 
or vir-3. An edge (a, b) G E indicates that relation(a) is tual relations which are maintained by the 
mediator. directly derived from relation(b) (and possibly other Analogous to query execution plans, different 
VDPS for relations). If b is a leaf node, a is called leaf-parent. the same integrated view specification 
may be appropri-4. For each non-leaf v E V, defiv) is an expression in ate under different query and 
update characteristics of the view definition language that refers to {relation I the application. (v, 
u) G E}. Intuitively speaking, deflv) defines the The language currently supported by Squirrel for population 
of r-elation(v) in terms of the relations specifying integrated views includes the relational al-corresponding 
to the immediate descendants of v. gebra. We use an attribute-based form of the algebra. Similar to query 
execution plans, some combinations of In the interest of clarity, in the discussion below, we do operators 
are permitted in connection with a single node of the tree and its immediate descendants, while others 
are not, The restrictions are follows: (a) the immediate parents of leaf nodes can involve only projection 
and selection on those leaf nodes. Otherwise for node u, (b) de~(v) can be arbitrary combination of selects, 
projects and joins; or (c) de$(v) canhavetheform ofa union or a difference, with arbitrary selects and 
projects underneath that. Non-leaf nodes involving difference are called set nodes] and all other non-leaf 
nodes are called bag 71odes, The relations associated with set nodes are stored as sets, while the relations 
associated with bag nodes are stored as bags. 5. Export c V denotes the set of export relations. Each 
lmaximal node (i.e., node with no in-edges) is in Ezport; other non-source nodes may also be in Export. 
Elements of Export are depicted using a double circle. If V is a VDP and v is a node and relation(v) 
has name R and attributes al, . . . . an, then an annotation for R is a function from {al, . . . . an} 
into {m, v}, which indicates which attributes are materialized and which are virtual (see Section 2). 
Given a VDP V, an annotation for V is a function ann defined on the set of non-leaf nodes, such that 
arm(u) is an annotation of the relation of v, for each non-leaf node v E V. 5.2 Rules for update propagation 
Every edge (a, b) in a VDP is associated with an update propagation rule which computes an incremental 
update (Aretation(a)) to the relation relation(a) based on an update Arelation(b). The rules follow the 
general spirit of previous works, mainly [G MS93, GL95]. Due to the space limitation, we present only 
one sample rule for relations defined with select/project/join (SP.J). The complete set of rules is presented 
in [ZHK95]. SPJ: Suppose a relation T in a VDP is defined with ,SPJ operators: T = TPa~(TP1 ufl Rl ~gl 
. ~g..l ~P~afnRn). The sub-VDP for T is analogous to the one in Example 2.1, with V = {T, RI, . . . . 
Rn} and E = {(T, Fill), . . . . (T, Rn)}. The rule for the edge (T, Ri) is (using the bag semantics): 
rule for SPJ: edge (T, Ri) ou new ARi, AT = ~pUj(rp, Uj, RI ~g, ~g,., 7p,uf,ARz ~g, wgn_l 7rpmof. Rnli 
 6 Accessing Virtual Data and Maintaining Materialized Data This section describes the two primary algorithms 
used m a Squirrel mediator to support hybrid integrated views. The first algorithm (Subsection 6,3 ) 
is performed by the Virtual Attribute Processor (VAP), and materi­alizes temporary relations that hold 
the current value of (projections of) virtual or hybrid relations. These temporary relations might be 
needed to answer a query, or to incrementally update materialized data. The sec­ond algorithm (Subsection 
6.4) is performed by the In­cremental Update Processor (IUP), and incrementally updates materialized 
data to reflect updates received from the source databases. Before the algorithms are presented, Subsection 
6.1 gives some technical background used in the descrip­tion of the algorithms. Also, Subsection 6.2 
develops formalism for describing the behavior of the algorithms. During the presentation of the algorithms 
this formal­ ism will be used to verify certain properties of the algo­ rithms. Section 7 also uses the 
formalism. 6.1 Tools to manage deltas The update-queue of a Squirrel mediator holds incre­mental updates 
received from the source databases. A Squirrel mediator processes these incremental updates and internal 
ones for a variety of purposes. This sub­section introduces the notation and tools used by the mediator 
to manipulate such incremental updates. We use the Heraclitus paradigm [HJ91, GHJ96], which elevates 
deltas , or the differences between database states, to be first-class citizens in database programming 
languages. Speaking loosely, in the re­ lational case, a delta (value) is simply a set of insertion atoms 
of the form + R(t] and deietion atoms of the form R(O , subject to the consistency condition: two confltctmg 
atoms (i. e., two atoms +a and -a) cannot both occur in the delta. A delta can simultaneously contain 
atoms that refer to more than relation. Deltas have also been generalized to bags [DHR96]. Incremen­tal 
updates in the update-queue and incremental up­dates computed during update propagation are repre­sented 
as deltas. Two important operators are apply and smash. Given delta A and database state db, appiy(db, 
A ) denotes the result of applying the atoms in A to db. If A refers only to relation R, we also write 
app/y(R, A). It turns out, that app~y commutes with select and project, e.g., if A refers only to R, 
then 7rcajapply(R,A) = apply (~cuf R, mcuf A). Smash, denoted ! , is a kind of compose operator. In particular, 
for any state and deltas, apgdy(,db, Al !Aj) = apply (apply(db, Al), A2). For the relational case, the 
smash Al !A2 can be computed by formmg the union of Al and A2, and then deleting any element of Al that 
conflicts with an eiement of AZ [HJ91]. Smash is also relatively easy to compute for bag deltas. An insertion 
atom +R(~ in A is redundant for state db if ~is in R under db; and similarly for deletion atoms. In the 
context of Squirrel mediators, no atom of any delta that is used is redundant. As a result, the natural 
tnverse operator 1, that reverses the sign of all atoms in a delta, has the property (for the states 
and deltas tal update from a source database is a delta expressed in terms of the relations of the source 
database. Because each leaf-parent holds a relation which is a project-select of a source database relation, 
it is easy to filter the deltas in the update queue so that they are applicable to the leaf-parent nodes, 
(A straightforward optimiza­tion that can be applied in some cases is to filter the incremental updates 
at the source databases. ) that arise) appiy(apply(db, A), A-l) = clb. Note also that (A1!Az)-l = A~l!A~l 
In the discussion below, we assume that an incremen­  6.2 Constructing the reflect function This section 
establishes notation for describing how a Squirrel mediator operates through time, and describes how 
a reflect function r Zf as in the definition of consistency can be constructed for Squirrel mediators. 
We assume that the mediator receives queries asyn­chronously from the user/applications and incremental 
updates from the source databases. Internally the medi­ator performs a series of sequential transactions 
of two kinds: Query transaction: Compute the answer to a query Update transaction: Empty the update-queue 
and prop­agate those updates to all affected materialized data in the mediator In general, transactions 
of these two kinds will be interleaved, to form a sequence such as where tuiew-znit is the time when 
the view is initi­ated; tf,t~,t$t~,t~,..are query transaction times, i.e., the commit times of the query 
transactions; and t?,t!,t;,t!, are update transaction times. While the mediator may perform parts of 
these transactions con­currently, we assume that the implicit serial order of the concurrent execution 
matches the order of the transac­tion commit times. The algorithms of Squirrel mediators are carefully 
devised to ensure that the mediator is consistent, in the sense defined in Section 3. We now describe 
how a function r~f satisfying the definition of consistency can be constructed for the mediator, based 
on the timing of the update and query transactions. Let DB1, . . . . DB. be the source databases, and 
let v define the view of the mediator. We focus here on the first property of r;f in the definition of 
consistency, name~y that for each time t we should have state(V, t) = v(DB, r?f(i)). Let DB1, . . . . 
Dl?m be the materialized-contributor and hybrid-contributor databases (see Section 4), and DBm+l, . . 
. . DBn be the virtual-contributor databases. Let V be the relational database schema that includes al~ 
materialized portions of relations in the annotated VDP of the mediator, and let v be the function derived 
from v and the VDP that specifies how V should be populated from the source databases DBI, ,.., DB~. 
To describe r;f, we define first the function r;f : Time + (Time)m, with the property that for each 
update transaction time t$ we have state(V , t;) = V (D+B[l, m], r;j (t~)) (where D+B[l, m] = (DBI,..., 
DB~)). Consider an update transaction time ty.As detailed in Subsection 6.4 below, with each execution 
the IUP processes the full set of deltas currently in the queue. Thus, for the execution of the IUP that 
ends at time t!,there is some earlier time empfy.queue(t~ ) when the IUP flushes the update-queue, and 
combines the individual updates using smash into a delta value A. Time empty .queue(tj ) > t~_l, because 
the mediator is assumed to perform the update transactions serially. Furthermore, A will hold all incremental 
updates received by the mediator from the source databases between empty_queue(t~_l) and empty-queue(t~). 
Continuing with our focus on time t;,for each kE [1, m], let -tkbe the time that DBk sent the last up­date 
to the mediator that was received before time empty .queue(t; ). Set r;f (t~) = (-tl, . . .,t~). The 
IUP will guarantee that for each i, state(V , t?) = v (DB[l, m], r;j (t~ )) This will follow from two 
basic facts: (a) the IUP correctly incorporates the impact of A into V , and (b) if virtual data is needed 
to determine the appropriate incremental update to some relation in V , then an algorithm (Subsection 
6.3) is used to guar­antee that virtual data from database DBk corresponds to state(DBk, tk) = state(DBk, 
r;f (t~).k). As just defined, the domain of function ri7f is {t~,t?j,is to times t.i,wjnit ...}.This 
extended all z in the natural fashion: if t$< t < t:+l,then r.?f (t) = rzf (ty ) , The definition of 
consistency gives conditions about the state of the integrated view that are supposed to hold at all 
times. It is sufficient to ensure that these conditions hold at all query execution times. We now describe 
how the function rZf is defined for each query execution time tj. Suppose first that the query q processed 
at time t; requires access only to the materialized data in the VDP. This query is answered by simply 
accessing data in the local store of the mediator. This data will correspond to U (D-B[l, m], rZf (tj)). 
In this case we define ?-;f (t;). k if k e [l, m] r;f(t;).~q k= ifkc[m+l, n] { 3 (Because DBk is not 
involved for k c [m+ 1, n], the query output does reflect the current state of DBh, i.e., the state at 
time t;. ) Suppose now that the query q associated with query execution time tj involves virtual data. 
Under the algorithm of the VAP, virtual data coming from a hybrid-contributor DBk will come from the 
state of DBk at time r;f (t$).k. Virtual data from virtual­contributors is obtained by the VAP through 
direct querying of the relevant source databases. Suppose that DBk is a relevant virtual-contributor. 
The VAP packages all queries against DBk into a single transaction against DBk, so that the answers received 
from DBk all correspond to a single time, say tk. In this case we define 9-.3f (t~). k if k C [l, m] 
tk if k c [m+ ],n] and DB~ r? f($). k = contributes to g t; if k c [m+ I,n] and DBk does not contribute 
to g{ (As before, if DBk does not contribute to the query, then we use the state of DBk at the current 
time.)  6.3 Accessing virtual data This subsection presents how the virtual attribute pro­ cessor ( 
VAP ) of the mediator supports accesses to the virtual data by the query processor (QP) and the in­ cremental 
update processor (IUP). When QP or IUP needs to evaluate a query q = 7A u~ R, where A or j con­ tains 
at least one virtual attribute, the VAP constructs a temporary relation T = ~A Uj R as indicated in Sec­ 
tion 2. The QP or IUP transmits to the VAP the set 1 of needed queries involving virtual attributes. 
The set 1 is in the form of {( R1, A1, fl), . . ..(R~. A~, $~)}, where (R,, .4;, fi ) corresponds to 
the query T.. = TAt C~LR~. In order to construct the temporary relation Ti, the VAP determines the relations 
from which T, is derived. Let S be one of those relations. If at least part of the data in S used to 
construct T, is virtual, a temporary relation S must be constructed before the construction of Ti. S 
will correspond to the projection and selection of the portion of S that is referred to in the construction 
of T,. We now introduce a function derived.from on a relation T, that returns a set of projections and 
selections from which T can be derived. Definition: Let v be a non-leaf node in a VDP, R = relation(v), 
attr(R) be the whole attribute set of R, .4 ~ attr(R), and f is a selection condi­tion. We define the 
function derived-f rorn(R, A, f ) = {(s,, B,, g,),..., (sn,13n, (Jn)}, where A ~ attr(R) and S, is a 
relation in the VDP, g, is a selection condition, and B;~ attr(S zminimal such that TAOJR can )is be 
derived from ~E, aj, S, (possibly together with other re­lations). More specifically, {(Sl, Bl, gl), 
. . . . (Sn) Bn, gn)} are determined as follows: 1 (1) If clef(v) = mCa~S and D ~ attr(S) is a set of 
attributes involved in the select condition h, derived.from(R, A, f) = {(S, A U D, h)}. 1In the interest 
of clarity, we present these definitions infor­mally. Also, as indicated in Section 5, we ignore the 
possibility that renaming of attributes might be in the de.f(v). (2) ~fz deflv) = ~cuh(mc, ah, Si, Mjl 
. . . C4jm_, ~Cm&#38;hm S~~), where {ii,...,i~} ~ {1, . . ..n} and D, is the set of attributes in atiT(Si) 
that are used in the select and join conditions, derived-f r-om(R, A, f) = {( SI, BI, ~l),..., (S~, 
B~, h~)}, where B~ = (An attr(S, )) uDg .  (3) If deflv) = (TccThlSl) U (7rcc7h, SZ), where D, is the 
set of attributes in h,, derived-from(R, A, f) = {(S1, Bl, hi), (S2, B2, hz)}) where l?i = (Anattr(Si)) 
UDi (4) If deflv) = (~ca~lSl) (7rcC7h, S2), where D, is de­  fined analogously as in (3), derived_from(R, 
A, f) = {(SI, BI, hi), (S2, B,, hz)}, where B, = (AfwMr(S,)) uDi UC. The execution of the VAP has two 
phases. During the first phase, all the temporary relations to be constructed are identified. Then they 
are instantiated in a bottom­up fashion through the VDP during the second phase. The first phase is specified 
by the following algorithm: (1)Initialization: Let Unprocessed hold the input set {(RI,AI, fl), . . 
..(R~. An, fn)}, The nodes in the VDP are topologically sorted such that a parent node is considered 
before its children nodes. The output set Processed is set to 0. (2) Processing the Unprocessed set: 
While Unprocessed is not empty, for the first (R, A, f) c Unprocessed according to the topological order 
do: (2a) Identifying further temporary relations to be con­structed: For each (R , A , f ) E derived-f 
rom(R, A, f ), if A contains one or more virtual attributes, then a temporary relation T = ~A/ aj) R 
needs to be constructed as well. (2b) Merging temporary relations: If a triple (R , B, g) is in Unprocessed, 
replace it with (R , A U B, f V g). Otherwise, add (R , A , f ) to Unprocessed. (2b) Move (R, A, f) from 
Unprocessed to Processed. We now turn to the second phase of the VAP execution. The output set Processed 
of last phase is the input of this phase. For each triple (R, A, f) c Processed, a temporary relation 
T is constructed as r~uf clef(w), where R = relation(v). They can be easily constructed in a bottom-up 
fashion, except for the case where v is a leaf-parent node. The rest of this subsection focuses on the 
leaf-parent node case. Suppose there exists (R, A, f) G Processed such that R is associated with a leaf-parent 
node and the corresponding temporary relation is T. Since R is a virtual or hybrid relation, T can only 
be derived from a 2 Note the same relation may be referred multiple times in a n-way join formula. relation 
S of a hybrid-contributor or virtual-contributor source DBk. In order to construct T, the VAP queries 
relation S. We consider first the case that DBk is a hybrid­contributor. As pointed out in Subsection 
6.2, the data polled from S must be consistent with the materialized data also contributed from the same 
source where S resides. To guarantee this consistency, we have developed the following mechanism: Using 
notation defined in Subsection 6.2, suppose t:is the time of the last update of the materialized data 
in the mediator, The portion of materialized dat~ derived from DBk corresponds to the state(DBk, ref(t~). 
k) of DBk, In this case we desire that the result from querying S also corresponds to this state of DBk. 
Note that the source relation S may have been updated since time r;f(ty).k. T~e correct value for S, 
i.e., the value for S as of time re~(t~ ) .k is obtained by compensating the current value for S by the 
inverse of the smash of the updates for S that are in the update-queue up to the time when the result 
of querying S is received. The mechanism described above overlaps to certain extent with mechanisms developed 
in [ZGHW95] and [CGL+96]. Reference [CGL+96] establishes invariants between a source database, a view 
of that database which may be maintained using deferred updates, and deltas on the source database and 
view. The algorithm described above is compatible with these invariants. Reference [ZGHW95] considers 
warehoused views de­rived from a single source database. The algorithm de­scribed in [ZGHW95] has to 
send compensating queries to the source, while our algorithm performs the compen­sation locally in the 
mediator. Unlike our algorithm, the algorithm in [ZGHW95] may have to repeatedly send out compensating 
queries, if the updates in the source occurs very frequently. In fact, the algorithm may need to execute 
an arbitrary number of compensating queries without producing an answer to the initial query. If DBk 
is a virtual-contributor, the only restriction to the querying of S is: for constructing temporary relations 
for a given view state, each virtual-contributor can only be accessed at most once, so that no more than 
one state of the same source can contribute to the view state. For our specific case, this means: the 
VAP finds all the leaf-parent temporary relations specified in the set Processed and packages all queries 
of DBk into a single transaction (see Subsection 6.2). 6.4 Maintenance of materialized data The I UP 
is based primarily on the use of active database techniques to propagate incrementa~ updates from the 
update-queue into the materialized portions of the VDP. However, because some of the intermediate relations 
might be virtual or hybrid, in the general case the IUP may have to temporarily materialize some of the 
virtual data. To describe the behavior of the IUP, we begin with some preliminary comments. We then describe 
the IUP Kernel Algorithm . This can be used directly in the simplified context where the updates in the 
update-queue affect only fully materialized relations that have fully materialized support. We then describe 
the general IUP algorithm, which generalizes the IUP Kernel Algorithm As indicated in Subsection 6.2, 
the IUP process is executed at a series of times ty,ty,...called update transaction times . In each such 
transaction, the entire contents of the update-queue are combined into a single delta A, which is propagated 
upwards through the VDP. Assume now that a VDP V = (V, E, class, source, de~ Export ) is fixed. As indicated 
in Subsection 5.2, based on the definitions of non-leaf nodes, a rule specifying how updates should be 
propagated is associated with each edge of the VDP. Let edge-rule be the function that maps each edge 
in E to a rule. (This will be independent of annotations for V.) Finally, let A be an annotation for 
V. For the IUP algorithm, two repositories are associated with each non-leaf node v of V. Suppose that 
relation(v) = R. The first repository is denoted simply as R . During execution of the IUP it holds the 
current population of relation R. The second repository is denoted by AR , and holds the smash of zero 
or more incremental changes for R that result from the incremental propagation of updates during a single 
execution of the IUP. Before continuing, it is convenient to extend the function edge.-rule to apply 
to nodes as follows: edge-rule(v) = {edge-rule(v , v) [ (v , v) E E) Intuitively, edge_rule(v) holds 
all rules of in-edges to v, i.e., all rules that propagate updates out of v to its parents. Some care 
must be taken if incremental updates affect two or more children of a node, as illustrated next. Example 
6.1: Recall Example 2.1, where T, R and S are materialized and T = R N S . Suppose that updates AR and 
AS have been computed. The rules of Example 2.1 must be applied. However, it would be incorrect to compute 
 AT= (R M AS ) U (AR M S ) because this will miss the contribution of AR Cd AS . One correct solution 
is to compute AT= (R M AS ) U (AR C4 apply(S , AS )) This captures all of (R N AS ), (AR ~ S ), and (AR 
cd AS ). 0 To avoid the problem of missing contributions of deltas illustrated in the previous example, 
we develop a systematic approach to firing rules and applying deltas to relatlons. Let v be a node with 
relation = R. By the phrase process node v we mean to fire all eligible rules in edge-rule(v) (in any 
order), and then to execute the following steps: R : = apply (R, AR); AR :=0; During IUP processing, 
a node v will not be processed until all of its children have been processed. As a result, all incremental 
changes to a node v are accumulated before any of these changes are propagated to parents of v. The IUP 
Kernel Algorithm: We now describe the IUP Kernel Algorithm, which can be used directly for the simplified 
case that all relations affected by the update A are fully materialized and have fully materialized support. 
In this case, the IUP acts as a specialized active database execution model, that applies rules from 
the rulebase in an order determined by the VDP. We assume that the queue holding incremental up­ dates 
from the source databases is nonempty. Let t= t: be the time that this cycle of processing begins. The 
al­ gorithm proceeds as follows: (1) Initialization: Let A hold the smash of all incre­ment al updates 
held in the queue at time t. A can be broken into a set ARI, .,., ARk of subdeltas that refer to some 
set RI, . . . . Rk of source database rela­tions that are associated with leaf nodes VI, .... v~, (respectively) 
of V. During this phase, two things occur: (la) All eligible rules in U{edge-rule(vi) I i E [i, k]} are 
fired in any order. (lb) All entries in the queue that contributed to A are deleted. (It may be that 
during the execution of step (la) additional deltas were added to the queue. These will remain in the 
queue until the next cycle of rule firing is initiated. ) (2) Upward traversal of (1~, E). During this 
phase each non-leaf node is processed according to some topological sort of (V, E), i.e., m an order 
that satisfies the following restriction: A node w cannot be processed until all of its children have 
been processed. Suppose that the above algorithm is executed at time t:,and that the most recent execution 
of the algorithm that occurred before t: took place at time t~_l. The first step of the algorithm propagates 
the updates in A to the nodes that are directly above the leaf nodes of the VDP (although it does not 
process those nodes). It is straightforward to verify that ,A) If a non-leaf node v with relation = R 
has been processed, then (i) the repository R will hold the population for R that corresponds the state 
of the source databases at time r Z$(t$ ), and (ii) the associated repository AR is empty.  B) If 
a non-leaf node v with relation(v) = R has not been processed, then (i) the repository R will hold the 
population for R that reflects the state of the source databases at time rZ~(t~_l). (ii) the associated 
repository AR may hold informa­tion corresponding to some or all of the incremen­tal updates implied 
for relation R by the incre­mental updates to the source databases reported between times t~_~and t;. 
 (C) A node v with relation = R is not processed until all contributions to AR have been computed. 
 In particular, then, after execution terminates, all of the affected nodes will hold the state reflecting 
all updates that reached the queue up until the time of flushing the queue, i.e., empty -queue(t~) in 
the notation of Subsection 6.2. As a result, we have state(V, t:) = V (D-B[l, m], r;$ (t~)) as promised 
in subsection 6.2. The general IUP algorithm: We now describe the general I UP algorithm,, that supports 
incremental update to arbitrary materialized and hybrid relations. We again assume that this update transaction 
has time t;. The general execution of IUP has three phases, namely (a) determine needed temporary relations; 
(b) populate needed temporary relations (using the VAP); and (c) propagate updates. Example 6.2 To understand 
why temporary rela­tions are needed, recall Example 2.2, where T and S are materialized but R is virtual. 
If during processing AS becomes non-empty, then the value of R must be obtained, in order to apply rule 
#l of Example 2.1. 0 To perform phase (a), i.e., to determine the needed temporary relations, we apply 
a variant of the IUP Ker­ nel Algorithm, called the IUP Preparation Algorithm. In this algorithm, the 
IUP Kernel Algorithm is simu­ lated, to see what rules would be fired based on the delta A obtained from 
the update-queue. This yields a set 1 = {( Rl, Al, fI), . . ..(R~. A~, .f~)} of projections of selections 
of hybrid and virtual relations that will be needed. (If two temporary relations (R, A, j) and (R, A 
, f ) are needed for the same node, then these are merged. ) The second phase (b) is simply a call to 
the VAP to obtain temporary relations for all of 1. Note that all source databases that are accessed 
are hybrid contributors. [Materialized data in the VDP depends on them because they were identified by 
phase (a), and virtual data in the VDP depends on them because they are being accessed to populate relations 
in 1 with virtual attributes.] Because the input queue holds all incremental up­dates received after 
t~_~,the VAP populates 1 to the state corresponding to rZ~ (t~_ ~). This is appropriate, because some 
of the updates in A might imply updates that are to be applied to the materialized portions of hybrid 
relations that participate in 1. Phase (c) of the general IUP algorithm is to apply the IUP Kernel Algorithm, 
except using the temporary relations in place of their associated hybrid or virtual relations. When the 
IUP Kernel Algorithm is finished, update the materialized part of any hybrid relation according to the 
value of the associated temporary relation. By the properties of the IUP Kernel Algorithm discussed above, 
after completion of these steps the materia~zed portion of the VDP will correspond to state(lll?[l, m], 
r?~ (t~)). 7 Correctness of Squirrel Mediators This section briefly sketches the proofs that Squirrel 
mediators are both consistent and (under natural assumptions) guarantee freshness. Theorem 7.1: Squirrel 
mediators are consistent. Proof: (sketch) To prove consistency, we begin with the function r i?f constructed 
in Subsection 6.2. As verified during the presentations of the IUP and VAP algorithms, state(V, t;) = 
v(DB, r;f(t~)) and so Condition 1 of the definition of consistency is satisfied. Also, it is straightforward 
to verify that Conditions 2 and 3 of the definition consistency. 0 To show that mediators guarantee freshness, 
we first identify some natural properties that the overall environment can be assumed to satisfy. The 
following lengths of time are important: announcement delayi (ann_delayi): the period be­tween the time 
when updates are committed in database DB; and the updates are announced to the mediator  communtcatton 
delay, (comm-delay, ): the time it takes for messages from DBi to reach the mediator, and for messages 
from the mediator to reach DBi.  update holding delaymed (u_ho/d.de~aymed): the length of time in the 
worst case between when an update might arrive at the mediator and when the mediator starts the next 
update transaction.  update processing de~aymed (U.proc.deiaymed): the length of time in the worst case 
between when the mediator starts an update transaction and completes it, excluding the time taken to 
query the source databases. query processing de~ayi (q-proc-deiayi ): the length of time it takes in 
the worst case for DBi to answer a query posed against it. (It is O if queries are not made against D13,.) 
query processing delaymed (q-proc_delaymed): the length of time it takes in the worst case for the mediator 
to do processing associated with the QP and VAP, excluding the time taken to query the source databases. 
 Both ann-delayi and U-proc-delaymed are dictated pri­marily by policies, e.g., on how often source databases 
should transmit updates to the mediator, and how fre­quently the mediator should flush its incremental 
up­date queue. We now state: Theorem 7,2: Suppose that in an integration en­vironment involving source 
databases DB1, . . . . DBn and Squirrel mediator, the delays are bounded by ann-delayi, comm_delayi, 
u_hoid.deiaymed, u_proc _ de~aym.d, q-proc-delay,, and q-proc-delay~ed. Define vector f so that for 
materialized-and hybrid-contributors DBi and virtual-contributors DBj we have: f, = ann_delay, + comm-delay, 
+ u-hold-de[ay~.d + u-proc-de[aym,d + ~~=~(q-proc-delayk + 2 * commde!ayk) + q-proc.-delay~ed  f, 
= ~;=l(q-PToc-delaYk + 2 * comm-delaYk) + q-pTOC.detaY~,d Then Jhe integration environment is guaranteed 
fresh . . wlthm f after time tvtew~.ntt. Proof: (sketch) From the proof of Theorem 7.1 we know that 
for each query transaction time t;, state(V, t;) = U(D-B, rL?f (tj)). Also, it is easy to verify that 
for each source database Dl?i we have tj r~f(tj)~ < !i 0 The choice of fin the above theorem reflects 
the worst case, in which a query against the mediator must access all hybrid-and virtual-contributor 
source databases. Importantly, if a query against fully materialized data is asked, then the freshness 
for each materialized­contributor database DB~ is f, = ann.delay, i-comm.delay, + u-hold-de ~ay~ed + 
u-pToc-deiay~.~ Conclusions This paper presents Squirrel mediators, which support views that integrate 
data from multiple data sources, and support the materialized and virtual approaches, and hybrids of 
them. An important topic for future research is to develop guidelines for choosing optimal VDPS and annotations 
for Squirrel mediators. One step in this direction will be to benchmark various alternatives under different 
environmental conditions. Another important topic is to develop algorithms for migrating to new VDPS 
and/or annotations in a Squir­ rel mediator, as the underlying environment changes. These changes might 
include the addition/deletion of data sources and/or export relations, network condi­ tions, and query 
and update frequencies. <RefA>[GMS93] A. Gupta, 1.S. Mumick, and V.S. Subrahmanian. Maintaining views incrementally. 
In Proc. ACM SIGMOD Symp. on the Management of Data, pages 157-166, 1993.  References [ACHK93] Y. Arens, 
C.Y. Chee, C.N. Hsu, and C.A. Iinoblock. Retrieving and integrating data from multiple information sources. 
Intl. Journal of Intelligent and Cooperative Information Systems, 2(2):127-158, 1993. [ADD+ 91] R. Ahmed, 
P. DeSmedt, W. Du, W. Kent, M. Iietabchi, W. Litwin, A. Rafii, and M. C. Shari. Pegasus heterogeneous 
multidatabase system. IEEE Computer, December 1991. [BDD+ 95] O. Boucelma, J. Dalrymple, M. Doherty, 
J. C. Franchitti, R. Hull, R. King, and G. Zhou. Incorporating Active and Multi-database-state Services 
into an OSA-Compliant Interoperability Framework. In The Collected Arcadza Papers, Second Edztton. University 
of California, Irvine, May 1995. [BLT86] J.A. Blakeley, P.-A. Larson, and F.W. Tompa. Efficiently updating 
materialized views. In Proc. ACM SIGMOD Syrnp. on the Management of Data, pages 61­71, 1986. [CGL+96] 
L.S. Colby, T. Griffin, L. Libkin, 1.S. Mumick, and H. Trickery. Algorithms for deferred view mainte­nance. 
In Proc. ACM SIGMOD Symp. on the Manage­ment of Data, pages 469 480, 1996. [Cha94] T.-P. Chang. On Incremental 
Update Propagation Between Object-Based Databases. PhD thesis, University of Southern California, Los 
Angeles, CA, 1994. [CW91] S. Ceri and J. Widom. Deriving production rules for incremental view maintenance. 
In Proc. of Intl. Conf. on Very Large Data Bases, pages 577 589, 1991. [Da195] J. Dalrymple. Extending 
Rule Mechanisms for the Construction of Interoperable Systems. PhD thesis, University of Colorado, Boulder, 
1995. [DH84] U. DayaI and H.Y. Hwang. View definition and generalization for database integration in 
a multidatabase system. IEEE Trans. on Software Engineering, SE­10(6):628 644, 1984. [DHR96] M. Doherty, 
R. Hull, and M. Rupawalla. Struc­tures for manipulating proposed updates in object­oriented databases. 
In Proc. ACM SIGMOD Symp. on the Management of Data, pages 306 317, 1996. [GHJ96] S. Ghandeharizadeh, 
R. Hull, and D. Jacobs. Her­aclitus: Elevating deltas to be first-class citizens in a database programming 
language. ACM Trans. on Database Systems, 1996. To appear. Available via anony­mous ftp at ftp://ftp. 
cs. Colorado. edu//userhulllhersra­tech94-revised.ps. [GJM96] A. Gupta, H.V. Jagadish, and 1.S. Mumick. 
Data integration using self-maintainable views. In Proc. of Intl. Conf. on Extending Data Base Technology, 
1996. [GL95] T. Griffin and L. Libkin. Incremental maintenance of views with duplicates. In Proc. ACM 
SIGMOD Symp. on the Management of Data, pages 328 339, 1995. [HJ91] R. Hull and D. Jacobs. Language constructs 
for programming active databases. In Proc. of lntl. Cont. on Very Large Data Bases, pages 455 468, 1991. 
[HZ96] R. Hull and G. Zhou. A framework for optimiz­ing data integration using the materialized and virtual 
approaches. Technical report, Computer Science Depart­ment, University of Colorado, 1996. in preparation. 
[LMR90] W. Litwin, L. Mark, and N. Roussopolos. Interop­erability of multiple autonomous databases. ACM 
Com­putmg Surveys, 22(3):267-293, September 1990. [SBG+ 81] J. M. Smith, P. A. Bernstein, N. Goodman, 
U. Dayal, T. Landers, K.W.T. Lin, and E. Wong. Multi­base -Integrating heterogeneous distributed database 
sys­tems. In Nattonal Computer Conference, pages 487-499, 1981. [T+90] G. Thomas et al. Heterogeneous 
distributed database systems for production use. ACM Computing Surveys, 22(3):237-266, September 1990. 
[WHW89] S. Widjojo, R. Hull, and D. Wile. Distributed Information Sharing using WorldBase. IEEE Ofice 
Iinowledge Engtneerzng, 3(2):17-26, August 1989. [Wie92] G. Wiederhold. Mediators in the architecture 
of future information systems. IEEE Computer, pages 38­49, March 1992. [ZGHW95] Y. Zhuge, H. Garcia-Molina, 
J. Hammer, and J. Widom. View maintenance in a warehousing environ­ment. In Proc. ACM SIGMOD Symp. on 
the Management of Data, pages 316 327, San Jose, California, May 1995. [ZHK95] G. Zhou, R. Hull, and 
R. King. Generating data integration mediators that use materialization, 1995. To appear, Journal of 
Intelligent Information Systems. [ZHKF95] G. Zhou, R. Hull, R. King, and J-C. Franchitti. Using object 
matching and materialization to integrate heterogeneous databases. In Proc. of Third Intl. Conf. on Cooperatzue 
Information Systems (CoopIS-95), Vienna, Austria, May 1995.</RefA>  
			

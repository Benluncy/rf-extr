
 A Generic Account of Continuation-Passing Styles * John Hat cliff Department of Computing and Information 
Kansas State University t hat cliff(lcis.ksu.edu Abstract We unify previous work on the continuation-passing 
style (CPS) transformations in a generic framework based on Moggi s computational met a-language. This 
framework is used to obtain GPS transformations for a variety of evalua­ tion strategies and to characterize 
the corresponding admini­ strative reductions and inverse transformations. We estab­ lish generic formal 
connections between operational seman­ tics and equational theories. Formal properties of transfor­ mations 
for specific evaluation orders follow as corollaries. Essentially, we factor transformations through 
Moggi s computational meta-language. Mapping A-terms into the met a-language captures computational properties 
(e.g., par­ tiality, strictness) and evaluation order explicitly in both the term and the type structure 
of the meta-language. The CPS transformation is then obtained by applying a generic trans­ formation 
from terms and types in the meta-language to CPS terms and types, based on a typed term representation 
of the continuation monad. We prove an adequacy property for the generic transformation and establish 
an equational correspondence between the meta-language and CPS terms. These generic results generalize 
Plotkin s seminal theo­ rems, subsume more recent results, and enable new uses of CPS transformations 
and their inverses. We discuss how to apply these results to compilation. Introduction There is a variety 
of continuation-passing styles one for each evaluation order (call-by-name, etc. ) and for each se­ 
quencing order (left-to-right, etc.). In each style, contin­ uations get passed from function to function 
 resulting in a strikingly similar structure for all styles. However, in the literature, the formal 
properties of each style are es­ tablished independently. For example, in his seminal paper Catl-by-name, 
call-by-value, and the A-calculus [32], Plotkin first presents call-by-value continuation-passing style 
(CPS) along with a set of correctness proofs and then he presents call-by-name CPS along with another 
set of correctness proofs. Both styles have similar structure but they are not identical. Their correctness 
proofs are also structurally sim­ ilar but they are not identical We propose to exploit these This work 
was partly supported by NSF under grant CCR­ 9102625. Manhattan, Kansas 66506, USA tN ~ Munkegade, 8000 
Aarhus C, Denmark This work was initiated at Kansas State University, continued at Carnegie Mellon University 
in spring 1993, and completed at Aarhus University, Pem ssion to copy without fee all or part of this 
material is granted providad that tha copies era not msde or distributed for direct commercial advantage. 
the ACM copyright notica and tha title of the publication and its data appear, and notica is Oiven that 
copying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, 
requiras a fea endor apecifio permission. POPL 94-1194, Portland Oregon, USA @ 1994 ACM O-89791 -rHWh94fOOl..$3.5O 
 Olivier Danvy Sciences Department of Computer Science Aarhus University $ danvyOdaimi.aau .dk similarities 
to factor the CPS transformations and their cor­rectness proofs. It appears that many CPS transformations 
are built from common building blocks. We represent these building blocks abstractly by constructs of 
Moggi)s computational meta­language (which we refer to as A~L ) [26].1 By formally connecting the language 
of abstract building blocks and the language of CPS terms, we obtain a generic framework for constructing 
CPS transformations and for reasoning about CPS terms as opposed to dealing with each transforma­tion 
individually. To connect the (operational) semantics of the two languages, we show an adequacy property 
for a generic transformation C from A~L to CPS terms. To con­nect equational theories, we show that the 
transformation C (continuation introduction), along with its inverse C-l (continuation elimination), 
establishes an equational corre­spondence between A~L and CPS terms. The diagram of Figure 1 summarizes 
the situation. The result is that, given a correct encoding into AA, the construction and correctness 
of the corresponding CPS transformation follow as corollaries. Establishing a correct encoding into Aml 
is much simpler than working directly with CPS terms. This approach generalizes Plotkin s construction 
and correctness proofs for his call-by-value and call-by-name CPS transformations [32]. It also generalizes 
similar re­sults for Reynolds s cal-by-value CPS transformation [34], and more recently for CPS transformations 
capturing mixed evaluation orders based on strictness and totality informa­tion [3, 8, 9]. Practical 
use of CPS transformations requires one to characterize administrative reductions [7, 32, 36]. Again, 
administrative reductions are usually characterized for each CPS transformation individually. For example, 
Plotkin gives a colon-translation that performs administrative re­ductions for call-by-value CPS and 
then another colon­translation that performs administrative reductions for caU­by-name CPS. In contrast, 
a certain subset of A~z reduc­tions generically characterizes the administrative reductions on CPS terms. 
For each CPS transformation, a corresponding direct­style (DS) transformation exists that maps CPS terms 
and types to direct-style terms and types. DS transformations have stirred interest recently [6, 10, 
13, 36]. However, just like the CPS transformations, they have been studied in­dividually. In cent rast, 
the continuation elimination C l serves as the core of a generic D S transformation. Finally, in situations 
where explicit continuations are not needed (e. g., for compiling programs without jumps), flA stands 
as an alternative language to CPS very close to GPS but without continuations. 1 Note that M~ggi>s computational 
meta-language [26] 1s a different language than Moggi s computational J-calculus Xc [23, 24]. Reynolds 
s C13V CBN CBV -* + { * * c ~ l CBV + strictness i info \ Evaluation Orders CPS Figure 1: Factoring transformations 
through the computational meta-language In Moggi s work, A*1 (without recursive functions) is given 
a categoriczd semantics. The interpretation can be parameterized with categorical structures called monads 
that abstractly capture various notions of computation. In essence, we point out that by giving a term 
representation of the continuation monad, A~~ forms the basis of an el­egant framework capturing the 
construction, correct ness, equational properties, and optimizations of CPS and DS transformations for 
a variety of evaluation orders. Because the meta-language is typed, our development also gives a generic 
account of the typing of CPS transformations. Sec­tion 9 relates the present work to other recent applications 
of Moggi s framework [36, 41, 42]. The rest of the paper is organized as follows. Section 2 addresses 
the representation of computational properties of Lterms with A~t terms. We consider in detail the standard 
call-by-name and call-by-value reduction strategies. Sec­tion 3 describes the mappings between Aml terms 
and CPS terms. Section 4 illustrates the framework with a variety of CPS transformations. Section 5 formalizes 
administrative reductions. Section 6 addresses DS transformations. Sec­tion 7 describes how data structures 
are dealt within the framework. Section 8 applies the framework to compilation, Section 9 addresses related 
work. Section 10 concludes. 2 Representing Computational Properties of A-terms 2.1 The language A of 
typed A-terms 2.1.1 Syntax and notation Figure 2 presents the syntax of the language A simply­typed 
A-terms with recursive functions. 2 Throughout the paper, type annotations are omitted when no ambiguity 
re­sults. In such cases, the terms are assumed to be type cor­rect. The same met a-variables (r for type 
assumptions, r for types, e for terms) are used in different languages. Ambigu­ity is avoided by giving 
a different subscript for the typing judgement symbol 1-in each language. We use the meta­variable $ 
to distinguish identifiers of recursive functions, For other identifiers (and where no distinction is 
necessary) we use the meta-variable x. To simplify substitution, we follow Barendregt s variable convention 
and consider the quotient of A under a-equivalence [2]. We write el ~ e2 for a-equivalent terms el and 
ez. The notation F V(e) denotes 2 We follow Tennent s presentation of abstract syntax bssed cm derivability 
y of sequents of the form 17 h e : r [40]. 3 In terms occurring in definitions and proofs etc., all bound 
vari­ables are chosen to be different from free variables [2, page 26]. the set of free variables in 
e and el [z := ez] denotes the re­sult of the capture-free substitution of all free occurrences of x 
in el by ez. Closed terms of base type are called programs. 2.1.2 Values and computations Certain terms 
of A are designated as values. Intuitively, values correspond to terms that are irreducible according 
to the operational semantics for A given below. The sets Value% [A] and Value% [A] represent the set 
of values from the language A under call-by-name and call-by-value reduc­tion respectively. Vaiue%[A] 
::= c I ~z. e I rec~(z). e I ~ Vaiue%[A] ::= c [ )z. e I r-ecf(z). e [ z Note that all identifiers are 
included in Vaiue% [A] since only values are substituted for identifiers under call-by-value re­duction. 
Only identifiers f for recursive functions are in­cluded in Value% [A] (based on the reductions for rec 
in the following section), since arbitrary terms are substituted for identifiers in general. We use v 
to represent values and, where no ambiguity results, we ignore the distinction be­tween call-by-name 
and call-by-value values. C omputatioras are non-values terms requiring addi­tional computational steps 
before their meaning can be de­termined. Not all computations reduce to values due to the possibility 
of non-termination introduced by recursive func­tions. 2.1.3 Operational semantics and equational reasoning 
The rules of Figure 3 define single-step reduction functions over A programs. The meaning functions evak 
and evak are defined in terms of the reflexive, transitive closure (denoted **) of the single-step reduction 
functions. ermh(e) = v ifl e M: v evaL(e) = v ifl e +; v For reasoning about the meaning of A programs, 
we consider calculi generated by the usual reductions @, &#38;, q, [2] as well as the reductions rec 
and ret, defined below. (ret f(z). eo) el ~rec eo[f := reef(z).eo , z := e]] (r-ec f(z). e) v are. e[f 
:= reef(z). e, z := ~] For a notion of reduction r, ---+ also denotes compatible one-step reduction, 
---+, is the reflexive, transitive closure of +,, and =, is the smallest by -4, [2]. The calculus (i.e., 
the relation =&#38;) is I EC:L r~z:r(~) r,z:~ll-e: 7-2 rl-Ax. e:n+r2 r, r T .. .. r ::=  f:71+~2, z:71Ee:72 
1-~ecf(x). e : T1.+T2 rt-eo:t-1+~2 171­ eoel:rz rl-el:rl L I 7-1-+?-2 . I r,3:T Figure 2: Abstract syntax 
of A, the language of simply-typed X-terms Cdl-by-name: (Ax .eo)el I--+ eo[x := el] (r-cc f(x). eo) e, 
-n eo[f := reef(x).eo , x := el] eo eo el +-+n +-+ e~ , e. el Cdl-by-value: (Ax. e)v +-+. e[x := v] 
 grams under call-by-name ated byR, = Figure 3: Single-step equivalence relation generated generated 
by R. = {~, q., rec}4 sound for reasoning about pro­ evaluation.5 The calculus gener­ {8v, %, recv } 
is sound for reasoning about programs under call-by-value evaluation. When a property P holds for both 
,8 and /3v, indifferently, we say that p holds for ,&#38; (similarly for reci, Rz, and eva4 ). 2.2 The 
computational meta-language A~i 2.2.1 Syntax and notation Figure 4 presents the syntax of the language 
A~t based on Moggi s computational rneta-kmguage [26]. The key feature of the language is that its typing 
system captures the dis­tinction between computations and values (or, in Reynolds s terminology, serious 
terms and trivial terms [33]) which has often been used to justify the structure of CPS programs in­tuitively 
[32, 33]. Types of the form L and ~1 ~ 7-z are called value types. Accordingly, the rules for constants 
and ab­stractions are among the introduction rules for value types. Types of the form ; are called computation 
types. The monadic constructs are used to make the compu­t ational process explicit. Intuitively, [e] 
simply returns the value of e while let x + e] in e2 first evaluates el and binds the result to z, and 
then evaluates 4 The reason for considering only w Section 3. 5 Soundness of calculi is formalized of 
operational equ$valerace [32] which situations throughout the paper. ez. instead of rI IS explained m 
via a standard presentation we omit here and in similar 6 For the explicit connection to the structure 
of a monad see [26, page 61]. (r-cc f(x). e) v +--+V e[f := rec f(x). e, x := v] e~ b--+ ej (r-cc f(x). 
eo) el w, (ret f(x). eo) e{ reductions for A programs 2.2.2 Operational semantics and equational reasoning 
Figure 5 presents the set of reductions Rml for the com­putational meta-language A~~. Note that when 
a A~i­abstraction parameter is of value type, ,Bmr corresponds to /l, A~l typing ensures that only values 
will be substituted for the parameter. When an AA abstraction parameter is of computation type, both 
values (coerced to trivial com­putations by [.]) and computations may be substituted for the parameter. 
recmi can be viewed in a similar manner. qml corresponds to q, reduction of Am~, e in Az ,ez must have 
a The monadic reductions R~o~ are used to structure computation. property of the computational since, 
by the typing rules value type. = {let.,8,1et.q, let.assoc} In fact, an important meta-language is that 
the reductions R~l can describe the evaluation patterns of both direct style and continuation-passing 
style A programs. We exploit this property when constructing correctness proofs for transformations factored 
through the meta-language. To capture the property formally, Figure 6 gives two sets of single-step reduction 
rules which are used to de­fine operational semantics for Aml programs (closed terms of type l). In both 
sets of rules, the Rml reductions ~~i, ret, and let.9 are used to express computation. Adding the let 
.assoc reduction gives an evaluation pattern reminis­cent of continuation-passing style, where the next 
redex is lifted out of a context before it is contracted. Omitting the let .assoc reduction gives the 
characteristic direct-style evaluation pattern where the evaluator descends into a con­text to pick the 
next redex to contract [11]. The following property captures the fact that the direct­style and the continuation-passing 
style evaluation pat­terns give the same results for Aml programs. 7Moggi ~,ves a categorical semant)cs 
for the meta-language. HOW­ever, an operational semantics 1s sufficient here, The rules of Fig­ure 6 
describe two leftmost, outermost reduction strategies over Ant reductmns.  rkmic:~ r I-ml~: r(z) r,x:~ll-mle:fi 
r,~:~l-+%,x:~lkmle:fi rkmt eo :71-+Z r t-m{el :71 r+mt Az. e: 71+72 r EmIreef(z). e : 7-I -+rz r I-mIeo 
e] : r2 I +mle:r I l-miel:fi I , x:rll-mlez:% (monadic constructs) r l-m~ [e] : F rt-mtletz+=elinez:rz 
T ::= L[ ~l+fi I; r ;:= . I r,z:r Figure 4: Abstract syntax of A~l, the computational meta-language 
(A z .eo) el ~pml eo[x := el] Az. ez +Vml e z @ FV(e) (ret f(z). eo) el +recmi eo[f := reef(z). eo , 
z := el] let z + [cl] in ez +Ie,,p ez [x := el] let z -+= e in [z] +Iet.n e let z2 + (let zl + el in 
ez) in es --qet,m~oc let 21 -+= e~ in (let z~ + ez in es) xl $? ~V(e3) Figure 5: The set of reductions 
Rmr for Aml Direct-St yle Evahmtion Pattern: (Jz. eO) el I---+mD.D eO[z := el] (recj(z). eO) e, ++mt.D 
eO[f := reef(z).eO , z := el] e] ++ml,LI ej ~et~ ~ [cl] in ez #mi.D ez[~ := el] let X~ e] in ez #m/,D 
let X@ e; in e2 Continuation-Passing Style Evaluation Patterra: (Ax. eo)el +mI,C eO[x := e,] (reef(z). 
eO) e, +d.c eO[f := reef(z).eO , x := e,] el Wmt.C ej let z ~ [cl] in ez ++ml.c e2[z := el] where el 
~ let y -&#38; ea in eb. letz-+elin ez*ml.c letx+ e;inez let X2+ (let xl + el in ez) in es Hm~.c iet 
ZI + e~in (let X2-@ezin es) Figure 6: Single-step reductions for A~/ programs &#38;n (.] : A ~ A~L En( 
) Vaiuew [A] ~ A~l &#38;n{v] = [s.(0)1 ,,, zuhere v ~ Vaiue%[A]. f.(c) = c ~.{eo el] = (et zo * Z.(co} 
tn(~z.e) = As. &#38;{e} in zo C.{cl} t$n(rec f(x). e) = reef(t).tn{e} I?n(s] = z f%(f) = f t.(r] = f~) 
 tn{r,z:~] = fn{r},~:tn{~] tn(~) = L sn{r,$:r) = tn{r],.f:sn(r) 4%(T1+T2) = 1%{7-1} --? En{rz} Figure 
7: CalI-by-name encoding into A~z 461 Figure 8: Call-by-value encoding in A~z Property 1 For . k~l e 
:7, e +-+%.~ [v] zfl e ~~~ c [VI Proofi One method relies on what can be thought of as a generalized 
version of Plot kin s colon translation [32] which unrolls reductions in the continuation-passing style 
pattern until a reduction corresponding to a direct-style reduction is exposed. 9 A (partial) meaning 
function evck for A~/ programs . l-~1 e : ~ can be defined as follows. evahl(e) = v i# e +-+>Z.D [vI 
iff e X:Z ~ [v] It is straightforward to show that the calculus Rml is sound for reasoning about A~l 
programs. 2.3 Encoding evaluation orders of A in A~/ Figures 7 and 8 present the A~t encodings of the 
st an­dard call-by-name and call-by-value strategies. In these par­ticular transformations, the double 
brackets {.} are used when building computations and computation types. Single brackets (.) are used 
when building values and value types. Elsewhere, where a distinction between computations and values 
is unimportant to the structure of the transforma­tion, we use {.] by default. The encodings G and 2, 
preserve typing, as captured in the following property. Property 2 e ~fr 1-e :7 then .fn[r] l-d G{e]: 
E.(r}. 0 ~jr 1-e : r then &#38;v{r} t-d &#38;v{e] : tv{~}. The two encodings differ in that call-by-name 
func­tions receive computations as arguments (hence the typing t. {rl} ~ .5. {7z} ) while call-by-value 
functions receive val­ues as arguments (hence the typing t. (TI ) --t, (m}). The encodings also capture 
the distinction between identifiers as computations for call-by-name and identifiers as values for call-by-value, 
as pointed out in Section 2.1.2. Correctness is captured as follows. Property 3 For cdl programs ~F e 
: t, eva&#38;(e) = v iff eoahl(~.{e}) = v c evak(e) = v ifl eval~~(tv {e}) = v Proofi The proof takes 
advantage of the fact that XA D reductions describe direct-style evaluation. For example, for call-by-name, 
the proof relies on the fact that e G. e implies &#38; {e} ~~~.D ~. {e }. I 2.4 Conclusion As advocated 
by Moggi and as illustrated here with call-by­name and call-by-value, A~l offers a framework for encoding 
the computational properties of A terms. Section 4 presents other practical evaluation orders. The following 
section for­mally connects A~z terms and CPS terms. 3 Computations as Continuation-Passing Terms 3.1 
Introducing continuations Figure 9 presents the translation C from AA to contin­uation-passing terms 
of A. C relies on a term representa­tion of the monad of continuations [26, page 58]. We use the monad 
of continuations because it naturally accounts for passing continuations. We use a term representation 
because we are aiming for a program transformation. The following property captures the fact that C maps 
weKtyped A~L terms to well-typed CPS terms. Property 4 1~ r I-mi e : T, then e{r} E C{e} : C{r}. The 
translation on computation types ; shows that compu­tations correspond to continuation-passing terms. 
We use the notation -v-to abbreviate r 4 cms where mu is a dis­tinguished type of answers. Thus Cm = 
7~C(r} = (C{r}-+ am) ~ am. The translation on terms shows that the monadic con­st ruct ors [.1 and let 
correspond to the basic components of continuation-passing terms: [e] abstracts the application of a 
continuation to the result C(e), and  let x + el in ez abstracts the composition of com­putations (continuation-passing 
terms) by forming the continuation A x . C{ez} k and passing it to C{el].  In the following sections, 
we consider an optimized trans­ formation C producing terms without redexes of the form (A k . e) k. 
Section 5 discusses administrative reductions in general. A fundamental property of C is that all A-terms 
in its im­ age are evaluation-order independent. Furthermore, C pre­ serves A~~ equational properties 
and operational semantics of A~l. 462 C{eorl-2 el j = A k-c~ z]). (C(feO}C{fa]) ~ Figure 9: Continuation 
introduction To formalize these properties we establish an equational correspondence between the Itml 
calculus of Am[ and CPS terms under the R, calculi. This first requires defining a translation C-1 from 
CPS terms to A~J. - Figure 10 presents the language C{AA} of CPS A-terms closed under R% reduct ion.8 
Note that C{A~J is a sub-Ianguage of A. The judgement Fuat enforces the property that terms in the image 
of C are values (this property is dis­cussed in detail in Section 3.4). The judgments +an~ and E.Ont 
rely on type assumptions that include a distinguished identifier k @ I . Figure 11 presents all possible 
R. reductions on C{A~t} terms. It is easy to show that each reduction is also a R, re­duction. Also, 
reductions on CPS terms preserve synt attic categories, e.g., reducing an expression satisfying the judge­ment 
1-~ai yields an expression that still satisfies the judge­ment l-v=?. 3.2 Eliminating continuations 
Figure 12 presents the translation C-l from the language of CPS terms C{A~l} back to A~[. A key component 
of C l is the transformation of continuations to what we call reduction conteds.g Reduction contexts 
r +m~ p : ; [;] of type ;Z with holes of type ;I are described by the folIowing syntax rules.  r l-ml[] 
: 7~ (tr+kdcontexts) I?, x:rl+mle:fi (let contexts)rEd letz+ [.]in e:~2[r1] The following property captures 
the fact that the transfor­mation preserves well-typed terms. Property 5 8A formal statement of correctness 
is omitted for lack of sPace 9 Felieisen and Friedman first pointed out that continuations m CPS correspond 
to ewahatton contezts in direct-style terms (e. g., terms from the language A) [1 1]. When considering 
Aml terms, corl­tinuations correspond to r-edwctton contests. Reduction contexts rep resent an intermediate 
step between evaluation contexts and contin­uations where, among oth&#38; things, the term in the (hole 
of a non. trivial evaluation context 1s given a name translation from AA into CPS If r l-eZP w : r 
then C l (r] t-m, C;;p {w]: c- (7-].  If(r; k:lr)banSa:ans  . 3.3 Relating operational semantics and 
equational theo­ries We can now state an adequacy property for the transla­tions C and C-l. The following 
theorem recasts Plotkin s Simulation and Indifference theorems for call-by-name and call-by-value CPS 
[32, Section 6] in terms of the generic in­troduction of continuations by C. Theorem 1 (Simulation and 
Indifference) If .l-~t e:~ then etmlml(e) = v ifl ew3it(C(e] (A x . z)) = w Proofi The proof takes advantage 
of the fact that F-+A.C reductions describe continuation-passing style evalua­tion. Specifically, e +-+m~.c 
e implies C {e] Q K WJ,V C {e } K for any arbitrary continuation K, where The corresponding property 
for C-l follows. Theorem 2 If . +va/ w : lTL then ewh(c;,j{w}) = w ifl etd(w (J z . z)) = v. Proof: For 
eua~, . ewL((C o C l)(W) (AZ . z)) e ~~(c;:,(w)) . . . Theorem 1 erm~(w (A z x)) . . . Theorem 3 @ soundness 
of R. Similarly for ew-z~. m Values rF ,qlw:r where w is a value I t-ualw:r Expressions r,x:rl ~val 
w: ~Tr2 r, f: T14T7T2, Z:Tl +.al W: 7TTZ  rF-eqc:L r +~zpr(x) x: r E.ZpAx. w:rl-+1-v2 r I-.zprec f(x). 
w: r] +77T2 r hva~ WO: T] +-qTz r +.~1 wl: 71 (1?; k : -r) i-an, CY: ans r~ ~zp wo WI : ~~r2 rkezp~k. 
ff:77T Continuations (r,x:r, ; k : Tro) l-an. a : ans (r; k: ~r) t-cent k: ~T (r; k:lro)Econt Ax. a:=rl 
 Answers r t-.$pw : =-wO (r; k : 71) I-.ont K : =ro (r; k :T) l-an, WK : am (r; k: ~ro) E.ont K : =rl 
r +v~lw : r, (r; k: -m) kan. ttw : ans Types and Assumptions .._ r .. t Irl+=vz I=-v r ,:= . I r,x:r 
Figure 10: Abstract syntax of C{A~i), the language of CPS terms (Ax . Wo) w, -pezp Wo[x := w,] (ret f(x). 
wo) W1 ---+~e~ezp Wo[f := recj(x). wo , X := Wl] (Ax . a) w --+pan$l a[z := w] (Ak .a) K +Ban, , CY[k:= 
K] .XX.WX ---+qez.,, e x @ FV(W) where w is a value ~ k .w k +QeZP, W k ~ FV(W) where w is a value Ax. 
tGz x @ FV(K) where K w a value -~cont K Figure 11: The set of reductions Rep, for C{A~l} c;;, (w] = 
C;;p {w] C;;p(c] = c c;;?(x] = x c;;. {w K] = C;;nt (t$][c;;p (w]] C;;P(A x .w] = Az .C;:,(W] c;;. {K 
w) = C:;nt {K][[c;;t(pu}]] C&#38;{rec f(z). w} = rec f(~). e~j(w} C;:p(Wo Wl) = C;;l{wo} C;;r{wl] Glt{kl 
= [ 1 CZ&#38; {A k.a} = C~&#38; {a} CJo~t {A z.a} = let z * [.] in C~~, {a] c- {,} = , C-1{rl+r2} = 
c-l{7i}+c-l{T2] c-l{r, z:T} = C-l {r}, z :C-l {r} C ] {mar} = C-~T} Figure 12: Continuation elimination 
 translation from CPS back to A~l Plotkin s Translation theorems show how his call-by­name and call-by-value 
CPS transformations relate equa­tional theories over direct-style terms and theories over CPS terms [32]. 
We relate the equational theories of the meta­language and CPS terms by showing an equational corre­spondence 
between A~l terms under the Rmi calculus and C{Aml} terms under the llcps (i.e., R,) calcuIus. In essence, 
this means that the equivalence classes of each theory are in a one-to-one correspondence. Theorem 3 
(Equational Correspondence) Proofi Follows the outline of [36, Theorem 16]. However, the proof here is 
simpler because our framework is typed and C does not perform administrative reductions on the fly . 
(see also [2, Theorem 7.3.10] and [17, Theorem 4]). ~ 3.4 Assessment Evaluation-order independence for 
all terms in the image of C holds because all C{Aml} function arguments are values. SpecificaUy, if 
a Aml argument e has a value type, then C{e} is a value; and,  if a Amz argument e has a computation 
type, then c(e) takes the form ~ k. ... (i.e., a value).  Obtaining evaluation-order independence requires 
slightly more than simply instantiating the monadic constructs [.1 and let with the continuation monad 
(witness the q-redex in C{eo el} of Figure 9). Such q-redexes are important since they suspend call-by-value 
evaluation when terms cor­responding to computations occur as function arguments, e.g., in CPS terms 
encoding call-by-name. Let C be a translation that only instantiates [.] and let. Following this strategy 
gives C {eo el} = C {eO} C {eI]. Now, if eo z A z. [CO] and el s (r-ec f(y). fy) cl, then C {eO el} (kz.z) 
= ((~z.Ak.k co) ((reef(y).fg) c,)) (kc.z) which diverges under call-by-value but terminates under call-by-name, 
and thus is not evaluation-order independent. The above example also illustrates why ~ is not sound for 
reasoning about C(A~l] terms under call-by-value evalua­tion. For example, C~eO el ] (Az .z) terminates 
under call-by­value but q-reduces to C [eo el] (kz. z which has just been 2 shown to diverge under call-by-value. 
1 In reality, problems are encountered only when one attempts to generalize qcont redexes to q all q 
redexes of the form given by Vezp, I and qexp.z are also v, redexes.11 10~i~ilar ~Xa~Ple~ of ~ &#38;~g 
unsound exist for traditkmal Un­ typed call-by-name CPS terms under call-by-value evaluation. 11 SabrY 
and Felleisen shOw that the ~q calcuhIs is sOund fOr e­ soning about a language of terms in the image 
of a call-by-value CPS transformation. We conjecture that q is sound there because it is call­by-name 
that requires the suspension effect given by the n-redex Furthermore, since continuations are the first 
arguments to functions in them C!PS transformation, terms cent aimng the relevant q-redex Ak. (UJo WI) 
k would appear in their language as Ak. (wo k) WI a non-redex. 3.5 Generalizing the notion of value 
Suppose the types of Aml are extended as follows. This typing generalizes the notion of value to include 
ap­plications of functions that always terminate when applied. Such functions do not need to be passed 
continuations to achieve evaluation-order independence [9]. Theorem 1 and 2 hold for a language with 
this generalized type system. A~I reductions in the generalized system induce a set of reduc­tions R&#38; 
on CPS terms that are sound under call-by-name and call-by-value evaluation. However, the generalized 
cal­ culus R~p~ no longer equationally corresponds to R. or R, due to the generalized notion of value, 
but it is a conserva­tive extension of R. and Rv. Section 4.5 gives an application of this generalized 
no­tion of value. The reader is referred to [16] for a detailed discussion. 4 CPS Transformations from 
Encodings of Computational Properties Previous applications of AA focus exclusively on call-by­value 
or call-by-name [26, 42]. 111 cent rast, the present framework allows the description of many other useful 
CPS transformations. Further, the correctness of the correspond­ing CPS transformation, the characterization 
of adminis­trative reductions (see Section 5), and a correct mapping from CPS back to A~i (see Section 
6) follow as corollar­ies from simply identifying the appropriate computational properties. We give several 
examples below. For each evaluation order, the corresponding CPS trans­formation is constructed by composing 
the encoding &#38; (of the evaluation order into A~~ ) with the continuation intro­duction C (or preferably, 
the slightly optimized introduc­tion C of Section 3 that produces terms without redexes of the form (A 
k . e) k). In general, the correctness of the con­structed CPS transformations follows from the correctness 
of an encoding &#38; and the correctness of C (Theorem 1). 4.1 Call-by-name and call-by-value CPS transformations 
We describe in detail the construction of correct call-by­name and call-by-value CPS transformations. 
As outlined above, CPS transformations are obtained by composing the encodings of specific evaluation 
orders with the generic con­ tinuation introduction C . Definition 1 (Construction) /cn Af c ot. K, 
Af c ot. The fact that the transformations preserve well-typed terms follow as corollaries. Property 
6 (Type correctness) Proofi Follows from the type correctness of the encodings fn, 2, (Property 2) and 
the type correctness of C (Property 4). E The correctness of the transformations follows as a corol­lary. 
Property 7 (Simulation and Indifference) If.l-e:L then eva~(e) = v iff ezdt(Kn(e} (Ax . z)) = v evd(e) 
= v ifl erm L(Kv(e}(Az . z)) = v Proofi Follows from the correctness of the encodings t., &#38;, (Property 
3) and the generic Simulation and Indifference theorem for C (Theorem 1). I The transformations K. and 
K constructed above are actually Plotkin s CPS transformations. Let P. and PV re­ spectively denote the 
typed version of Plotkin s call-by-name and call-by-value CPS transformations [8, 15, 22]. Proofi by 
structural induction over e. B Thus, the construction and correctness (specifically, the Simulation and 
Indifference theorems, and type correctness) of the typed versions of Plotkin s CPS transformation fol­low 
from the correctness of the encodings. Relationships between equational theories for direct-style and 
CPS terms (similar to those established by Plotkin s Translation theo­rems for P. and P.) follow by connecting 
equational theories over A with the theory Rml of Aml.  4.2 Reynolds s call-by-value CPS transformation 
We obtain a typed version of Reynolds s call-by-value CPS transformation [34] by keeping the same encoding 
of vari­ ables and applications in Figure 7 (the call-by-name encod­ing into Aml ) but by replacing the 
encoding of abstractions with the following definition. Instead of arguments being evaluated in the application 
(as in Figure 8, the call-by-value encoding into Aml ), they are passed as computations (essentially 
as thudcs[17, 18]), eval­uated immediately after the function is applied, and the re­sulting values are 
wrapped up again as thunks. Thus, tR captures the computational properties of call-by-value, but in a 
different style than &#38;,. This corresponds to the defini­tion of call-by-value in the Algol 60 report 
[30]. Turning to the CPS transformation, n =fc o&#38; Griffin, for example [15, Footnote 3], pointed 
out that the typing of the function space in RV matches the one of P. i.e., R, (T, +,2) = 7ZV(.I}+7?V(T2} 
This typing coincidence already holds here, before introduc­ing continuations: and thus it is independent 
of continuations as such. In any case, this coincidence illustrates that the transforma­ tion over types 
does not always determine the transforma­ tion over terms. 4.3 Variation on Reynolds s call-by-value 
CPS transfor­mation One may choose to pass arguments unevaluated and to force them after the function 
is applied, but not to wrap them into computations again. This is achieved by replacing the encoding 
of abstractions and applications in Figure 8 (the call-by-value encoding into AA) with the following 
defini­tions. Thus ~~, captures the computational properties of call-by­value, but in a different style 
than &#38; and ER. This corre­sponds to the style of capturing computational properties of call-by-value 
in denot atiorml semantics [38]: (1) either using a strictness check in the applicative structure (correspond­ing 
to E,); (2) or forming strict functions to crest e a strict function space (corresponding to Reynolds 
s transformation and its variant). The typing of the function space in CR, still matches the one of tn 
(see Figure 7) i.e., However, the transformation on type assumptions r is the same as for &#38;, (Figure 
8). 4.4 Mixed evaluation strategies based on strictness infor­mation Compile-time analyses of computation 
properties (such as strictness analysis) indicate where it is safe to mix eval­uation strategies [29], 
Earlier works show how to derive the corresponding CPS transformation encoding the mixed evaluation strategy 
into CPS terms [3, 8, 28, 31]. Such transformations can be correctly constructed by an encod­ing that 
contains both call-by-value-like (capturing strict­ness) and call-by-name-like (capturing non-strictness) 
appli­cations/ functions/identifiers. The types of such an encoding are structured as follows. These 
types illustrate that arguments to non-strict functions are computations while arguments to strict functions 
can be safely reduced to values before application. This encoding is based on combining the styles of 
&#38;v and &#38;n. However, a correct encoding based on strictness information can also be obtained by 
combining the styles of 2R and E. or of f~, and S.. Again, as long as the computational properties are 
correctly identified, the correct CPS transformation and ac­companying tools follow. , 4.5 Mixed evaluation 
strategies based on totality infor­mation Similarly, totality information determines when computa­ tions 
are guaranteed to reduce to values. An encoding of terms with totality information obeys the following 
type structure (capturing the possibility of partiality/totality in the domain and codomain of function 
spaces). Note that this encoding utilizes the generalized type struc­ture of Aml discussed in Section 
3.5. Such an encoding yields a CPS transformation where Reynolds s notion of trivial and serious expressions 
is generalized to functions functions that always produce values do not need to be passed con­tinuations 
to achieve evaluation-order independence [9, 33]. Elsewhere [16], we use Moggi s existence predicate 
[26, Section 2.2] within the met a-language itself to derive such optimizations.  4.6 Other sequencing 
orders Since A~l makes control flow explicit, one can construct CPS transformations with different sequencing 
orders for sub-expression evaluation. For example, replacing the en­coding of application in Figure 8 
with the one below gives a call-by-value CPS transformation where the argument is evaluated before the 
function in an application. 4.7 Conclusion We have shown that a wide variety of evaluation strategies 
can be described by simple encodings in Aml. The corre­sponding (2PS transformations and correctness 
proofs fol­low. The next two sections describe how administrative re­ductions and the corresponding direct-style 
transformations follow as well. 5 A Generic Account of Administrative Reductions Practical use of CPS 
transformations requires one to char­acterize administrative reductions i.e., the reduction of the extraneous 
abstractions introduced by the transforma­tion to obtain continuation-passing [7, 32, 36]. In fact, ad­ministrative 
reductions are characterized generically by the monadic reductions Rmon on Aml. In particular, let.~ 
and let .assoc correspond to the administrative reductions iden­tified by Plotkin. It is straightforward 
to show that the reductions Rmo ~ are Church-Rosser and strongly normaliz­ ing. Let ~ be a function mapping 
every Am; term to its Rmon normal form and let Z denote a version of plotkin~s call-by-value CPS transformation 
that carries out adminis­trative reductions on the fly [I, 7, 43]. A similar property also holds for 
the corresponding one-pass call-by-name CPS transformation, and for the corresponding CPS transformations 
after static analyses [8, 9, 31]. This staging and the account of administrative reductions prior to 
introducing continuations have been recently noted [5, 6, 13, 21, 36]. Typically, CPS transformations 
are factored into three distinct steps: 1. naming intermediate values (captured by ~); 2. flattening 
nested let s (captured by Af); and 3. introducing continuations (captured by C).  The last step is 
provably reversible, and Lawall antomated that proof for another meta-language than Am/ [20]. Recently, 
Sabry and Felleisen have identified an addi­tional optimization made possible by administrative reduc­tions 
on call-by-value CPS terms [36]. The optimization cor­responds to relocating evaluation contexts (reduction 
con­texts, continuations) inside abstractions in ,&#38;redexes. The following Rml equivalence characterizes 
this optimization:12 where p + [.] and z @ FV(p). Let let. ctxt be the reduc­tion induced by reading 
this equivalence from left to right .]3 The Church-Rosser and strong normalization property ex­tends 
to Rmon U {let .ctxt } reductions, characterizing ad­ministrative reductions (including the above optimization) 
generically. We have characterized administrative reductions ab­stractly in terms of normalization of 
AA terms. In practice, one would define an optimized translation that performs ad­ministrative reductions 
on the fly [1, 7, 43]. This can ei­ther be achieved using brute force [27, 36] or with a two-level specification 
[7, 8, 31]. 6 DS Transformations from Encodings of Computational Properties Direct-style transformations 
mapping CPS terms back to direct-style A terms are potentially useful in their own right. Our transformation 
C-l forms the core of a generic DS trans­formation, thus generalizing previous work in the absence of 
comput atiomd effects other than non-termination [6, 35]. Direct-style transformations D are obtained 
by composing inverse encodings &#38;-l (mapping A~l terms to direct-style A terms) with the transformation 
C l. The transformation t l may be defined in several ways. A simple technique is to unfold let constructs 
and remove [.1 constructs thus collapsing values and computations, under some side-conditions ensuring 
that the resulting terms remain evaluated in the same order. This is the technique used by e.g., Lawall 
and Danvy [6, 10, 19, 21]. Alternatively, one may adapt the techniques of Sabry and Felleisen [36] and 
map reduction contexts to evaluation contexts in A. In general, transformations t 1 defined as above 
are meaning-preserving only when defined on the language of A~l terms in the image of a corresponding 
encoding &#38; (or snch a language closed under Rml reductions). Considering a more general domain for 
.5-1 usually requires additional constructs in A which explicitly direct computation (e.g., strict let 
s, thunks) without resorting to full continuation­passing style. Formal properties and details of methods 
to obtain DS transformations for specific evaluation orders are described elsewhere [16]. 7 Products 
and Co-products This section outlines how products and co-products are in­corporated into the generic 
framework. A detailed discus­sion and proofs can be found elsewhere [16]. All of the results of the previous 
sections scale up to the extended language. 12 Even ~i~h ~hl~ ~Ptimization, Sabry and Felleisen s call-by-value 
 CPS transformation will produce slightly more compact terms. Hav­ing continuations as first arguments 
to functions makes it possible for all continuations to be relocated inside the abstractions of all P-redexe.. 
Here, trwial continuatmns (z. e., identifiers k) are notdo­ cated. In any case, this optimization is 
independent of continuations in general, and in particular of psssing them first or last to CPS functions. 
13A ~imilar OptimiZatiOn ak exists fOr ec f(c) T t-ml el rhml : TI r >m~ez (el, e2): T1xr2 : r2 r +m~e 
: r1+r2 r r,zl:rl t-miel t-ml ca9ee oj(zl.el) :Y I , z2:r2t-mle2:; \ (z2.e2) : ; i­ .. ... I r, X72 I 
T,+rz Figure 13: Abstract syntax of products and coproducts for the computational meta-language A~t 
Figure 13 extends the syntax of A~~ to include products are obtained by composing the encodings f with 
C. The 14 The set of ~aiue types is extended 0 and co-products. correctness hinges on the fact that all 
CPS terms will have include types T1 x TZ and rl +~z. The reductions for products only values as constructor 
arguments (i. e., either terms cor­and co-products are as follows. 15 responding to met a-language values, 
or abstractions M.... corresponding to meta-language computations). This gen­i7i(el, e2) +X.pt e, eralizes 
our earlier work [8], where we presented a CPS trans­formation after strictness analysis, handling both 
strict and case (in, e) of (zl.el) I (zz.ez) -+,pz e,[zt := e] non-strict products. Note that the definition 
of C in Figure 14 relies on the As with function spaces, the structure of A~l types and monadic constructs 
to structure continuation-passing proP­terms provides a description of constructors with differing erly. 
However, the definition below gives an alternate struc­ computational properties (e.g., eager or lazy). 
For exam-ture commonly used when transforming conditional expres­ple, eager (i. e ., call-by-value) pairing 
can be expressed via sions. products of values. fv(Tl XT2) = &#38;v (I(el, e2)] = in let zz @ Zv{ez} 
The latter definition allows reduction contexts (in the in [(z1, Z2)] form of continuations) to be relocated 
inside case constructs . which duplicates the contexts. Ie Indeed, this definition ~v(~, e} = let z 
* &#38;v{e} in [7r, z] reauires adding the followimz reduction to the set of Aml re~uct~ns to o~tain 
an equat~onal correspondence with CPSLazy (i. e., call-by-name) injections can be expressed via co­terms: 
rproducts of computations. V[casee of (zl.el) j (z2.e2)] -+.ctxt case e of (xl.p[el]) I (z2. p[e2]) where 
q # [.] and Z1, X2 @ FV(p). This reduction is sound with respect to the operational semantics of Am{ 
extended with products and co-products. Moreover, the framework naturally describes non-standard forms 
of products and co-products (e.g., one lazy compo-8 Compiling with Monadic Normal Forms nent, one eager 
component ) such as might occur in a pro­gram after strictness and/or termination analysis. In situations 
where explicit continuations are not needed Figure 14 extends C to products and co-products. As be-(e.g., 
for compiling programs without jumps), A~l stands fore, correct CPS transformations for the extended 
language 16This duplication can be avoided inserting a @-redex when intro­ 14The ~~esentationof products 
follows Moggi [26, Sect iOn 3 11. ducing continuations [7, 36]. 17 Sabry and FeIIe15en [36] give .s similar 
reduct]on for conditional 15A presentation including the usual x .q and + T rules fOr prOducts expressions, 
 and co-products can be found elsewhere [16]. as an alternative language to CPS very close to CPS but 
without continuations. A language with similar prop­erties ( A-normaJ forms ) has been proposed by Flanagan 
et al. [13] and studied for untyped, call-by-value A-terms. In particular, A-reductions provide the following 
standard compiler optimizations [13, page 243]: 1. code segments are merged across declarations and con­ditions; 
 2. reductions are lifted out of evaluation contexts and intermediate results are named.  These properties 
occur naturally in A~l. The Aml reduc­tions let .assoc and +.ctxt merge code segments across dec­larations 
(i. e., let) and conditionals (more generally, case statements). Encodings t into AA name intermediate 
re­sults and the reduction let. assoc lifts reductions out of re­duction contexts. Thus, Moggi s meta-language 
is not only a flexible for­mal tool, but also an attractive intermediate language for compiling. In particular, 
a sub-language of A~~ that we call the language of monadic nor-mat forms gives the properties discussed 
above for any evaluation order that can be en­coded into A~l. (The word monadic is slightly abused here 
since +.ctxt is not a monadic reduction.) The strong normalization and confluence properties of Rmon 
reductions extend to Rmon U {+.ctxt}. Let N be a function taking a A~t term to its I?mon U {+.ctxt} normal 
form. The function ~ o &#38; maps A terms to monadic normal forms for an arbitrary encoding t, thereby 
performing administrative reductions independently of continuations (see Section 5). Recent trends indicate 
that types are important for in­termediate languages. For example, Burn and Le M6tayer point out that 
types on CPS transformations give a use­ful characterization of boxed and unboxed values [3]. This observation 
applies here as well  computation types cor­ respond to boxed values, and value types correspond to 
un­ boxed values. Related Work The framework presented here relies on a formal connection between Moggi 
s computational meta-language and CPS terms and types. Moggi proposes the meta-language as a means of 
abstractly capturing the basic computational structure of programs. Semantic definitions of programs 
are obtained by a categorical interpretation parameterized with different monads capturing various notions 
of compw tation. Moggi gives a continuation monad in the category Set as particular example of a notion 
of computation es­tablishing a correspondence between the meta-language and set-theoretic continuation-passing 
functions [26, page 58]. Wadler illustrated the usefulness of Moggi s ideas when applied to functional 
programming [42]. In essence, he showed how programs written in the style of the meta-Ianguage (i. e., 
monadic style) could be parameterized with term representations of monads thus abstractly captur­ing 
various computational effects such as side-effects on a global state, etc. In particular, he showed how 
call-by-value and call-by-name CPS interpreters can be obtained by in­stantiating call-bv-value and call-bv-name 
monadic-stvle in­ . terpreters-with a term representation of the CPS monad thereby informally relating 
the encodings t, and t. with call-by-value and call-by-name CPS terms. In contrast, we formalize the 
relationship between the complete meta-language Aml and CPS terms. Based on this formulation, we generically 
capture many different aspects associated with CPS (construction of CPS transformations, correctness 
of transformations with regard to computational adequacy and preservation of equational theories, adminis­trative 
reductions, construction of DS transformations, typ­ing of transformations, etc.) which were previously 
handled individually for each evaluation order. We emphasize that AA is powerful enough to describe not 
only the standard call-by-value and call-by-name strategies but many other useful strategies appearing 
in the literature. One only needs to identify computational properties with Ami and all the aspects mentioned 
above follow as corollaries in the frame­work. To the best of our knowledge, this is the first attempt 
of such a global investigation of CPS. Sabry and Felleisen, in their recent work [36], hint at the relationship 
between Moggi s computational framework and CPS terms. They derive a calculus for untyped call­by-value 
DS terms which equatiomdly corresponds to call­by-value CPS terms under the /?~ calculus. They note that 
the resulting calculus equationally corresponds to an un­typed variant of Moggi s computational J-calculus 
AC [23] a calculus for call-by-value terms capturing equivalences that hold for any notion of computation. 
However, this correspondence seems to stem more from the emphasis on naming intermediate values present 
in both calculi rather than from any deliberate structural connection with e.g., the CPS monad. For example, 
the terms produced by Sabry and Felleisen s CPS transformation (a curried ver­sion of Fischer s transformation 
[12], where continuations occur first in functions) do not have the fundamental com­putational structure 
dictated by Moggi s framework. This is most easily seen by observing the mismatch between the typing 
of function spaces in Fischer s transformation and in the transformations generated by the CPS monad 
(cur­ried and with continuations occurring last ). In contrast, our framework is deliberately based on 
the structural (and equational) correspondence between AA and generic CPS terms. Using techniques analogous 
to those of Sabry and Fellei­sen [36], Sabry and Field have investigated state-passing style (uncurried 
and with state occurring last), deriving calculi for an untyped language with state. In contrast, one 
can take the state monad [26] and translate from the meta-language A~z to various state-passing styles 
(curried and with state occurring last) in the same way as we have used the continuation monad to generate 
a variety of continuation-passing styles: one then obtains a state-passing transformation for any evaluation 
order, generic administra­tive reductions, and the corresponding (direct-style trans­formations. As for 
CPS, these tools are obt ained by showing an equational correspondence between the meta-language and 
a term representation of the state monad. Thus Moggi s framework seems to provide a solid basis for studying 
both the relation between implicit and explicit representations of control and the relation between implicit 
and explicit representations of state, in a typed setting. In particular, we are currently investigating 
how the contin­uation/st ate monad (obtained e, g., by applying the state­monad constructor to the continuation 
monad [25]) offers a generic relation between implicit and explicit representa­tions of both control 
and state. We are also considerirw . to add computational effects on control (first-class continua. tions) 
and on the state (side-effects). 10 Conclusion and Issues We have characterized CPS transformations of 
typed A­terms for any evaluation order, their administrative reduc­tions, and the corresponding DS transformations, 
in one generic framework based on Moggi s computational meta­language and using a term representation 
of the CPS monad. Plotkin s Indifference, Simulation, and Translation theorems are generalized for the 
continuation introduction C. Char­acterizations of administrative reductions (including Sabry and Felleisen 
s optimization) are scaJed up in a typed frame­work for any evaluation order. Moggi s computational met 
a­language appears as a generic typed intermediate language for compiling, alternatively to CPS and with 
an equivsJent expressive power, in the absence of first-class continuations. We are currently considering 
other monads for applying the methodology developed here. Preliminary investigation for the state monad 
suggests that the same benefits hold: state­ passing style for any evaluation order, uniform administra­ 
tive reductions, and the corresponding direct-style trans­formations. Ditto for the continuation/state 
monad. This investigation should make it possible to come back to Griffin s connection between double-negation 
translation and CPS transformation [14] and to Murthy s intrepid dis­play of continuation-passing styles, 
from a logical standpoint [28, Chapters 9 &#38; 10]. Griffin identified Plotkin s caH-by­value CPS transformation 
as a logical embedding. Murthy identified it as a variant of the Kuroda negative transla­tion, and Plotkin 
s caJ1-by-name CPS transformation as the Kolmogorov translation. In fact, looking back at Murthy s PhD 
thesis, it is striking that his slightly modified Kuroda translation providing for mixed call-by-vahe 
and call-by­name evaluation [28, page 159] corresponds to the mixed CPS transformation of Section 4.4, 
and that his pervasive Kolmogorov translation [28, pages 164-167] corresponds to Reynolds s CPS transformation 
in Section 4.2. The equa­ tional correspondence between A~l and CPS strongly sug­ gests that the encoding 
of any evaluation order into A~l could be formalized as a logical embedding. We leave this point for 
a future work. Acknowledgements We are grateful to Andrzej Filinski and Bob Harper for fun­dament aJ 
observations and encouragements at an early stage of this work. Thanks are also due to Mat t hi as Felleisen, 
Sergey Kotov, Julia Lawall, Peter Lee, Karoline Malmkjam, Chet Murthy, Frank Pfenning, Amr Sabry, Dave 
Schmidt, and the referees for comments. References <RefA>[1] Andrew W. Appel. Compiling with Continuations. 
Cambridge University Press, 1992. [2] Henk Barendregt. The Lambda Calculus Its Syntax and Semantics. 
North-Holland, 1984. [3] Geoffrey Burn and Daniel Le M6tayer. Proving the correctness of compiler optimisations 
based on a global program analysis. TechnicaJ report Doc 92/20, Depart­ment of Computing, ImperiaJ College 
of Science, Tech­nology and Medicine, London, England, 1992. [4] William Clinger, editor. Proceedings 
of the 1992 ACM Conference on Lisp and Functional Prograrnmmgj LISP Pointersj Vol. V, No. 1, San Francisco, 
California, June 1992. ACM Press. [5] Olivier Danvy. Three steps for the CPS transforma­tion. TechnicaJ 
Report CIS-92-2, Kansas State Univer­sit y, Manhattan, Kansas, December 1991. [6] Olivier Danvy. Back 
to direct style. Science of C orn­puter Progr-amrnmg, 1993. SpeciaJ issue on ESOP 92, the Fourth European 
Symposium on Programming, Rennes, February 26-28, 1992. To appear. [7] Olivier Danvy and Andrzej Filinski. 
Representing con­trol, a study of the CPS transformation. In Wand [44], pages 361-391. [8] Olivier Danvy 
and John Hatcliff. CPS transformation after strictness amdysis. ACM Letters on Prograrnrninjj Languages 
and Systems, 1(3):195-212, 1993. [9] Olivier Danvy and John Hatcliff. On the transformation between 
direct and continuation semantics. In Stephen Brookes, Michael Main, Austin Melton, Michael Mis­love, 
and David Schmidt, editors, Proceedings of the 9th Conference on Mathematical Foundations of Program­ming 
Semantics, Lecture Notes in Computer Science, New Orleans, Louisiana, April 1993. To appear. [10] Olivier 
Danvy and Julia L. Lawall. Back to direct style H: First-class continuations. In Clinger [4], pages 299­ 
310. [11] Matthias Fe!.leisen and Daniel P. Friedman. Control operators, the SECD machine, and the A-calculus. 
In M. Wirsing, editor, Formal Description of Pro­gramming Concepts III, pages 193-217. North-Holland, 
1986. [12] Michael J. Fischer. Lambda-calculus schemata. In Tal­cott [39]. An earlier version appeared 
in an ACM Con­ference on Proving Assertions about Programs, SIG-PLAN Notices, Vol. 7, No. 1, January 
1972. [13] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Mat thias Felleisen. The essence of compiling 
with con­tinuations. In David W. Wall, editor, Proceedings of the ACM SIGPLAN 93 Conference on Programming 
Lan­guages Design and Imgdementation, SIGPLAN Notices, Vol. 28, No 6, pages 237 247, Albuquerque, New 
Mex­ico, June 1993. ACM Press. [14] Timothy G. Griffin. A formulae-as-types notion of con­trol. In Paul 
Hudak, editor, Proceedings of the Seven­teenth Annual ACM Symposium on Principles of Pro­gramming Languages, 
pages 47 58, San Francisco, Cal­ifornia, January 1990. ACM Press. [15] Bob Harper and Mark Lillibridge. 
Polymorphic type assignment and CPS conversion. In TaJcott [39]. [16] John Hatcliff. PhD thesis, Department 
of Comput­ing and Information Sciences, Kansas State University, Manhattan, Kansas, USA, March 1994. 
Forthcoming. [17] John Hatcliff and Olivier Danvy. Thunks and the ~­calculus. Technical Report CIS-93-15, 
Kansas State University, Manhattan, Kansas, September 1993. 470 [18] Peter Z. Ingerman. Thunks, a way 
of compiling pro­cedure statements with some comments on procedure declarations. Communications of the 
ACM, 4(1):55-58, 1961. [19] Julia L. Lawall. PhD thesis, Computer Science Depart­ment, Indiana University, 
Bloomington, Indiana, USA, 1993. Forthcoming. [20] Julia L. Lawall. Proofs by structural induction us­ing 
partial evacuation. In David A. Schmidt, editor, Proceedings of the Second ACM SIGPLA N Symposium on 
Partial Evaluation and Semantics-Based Program Manipulation, pages 155 166, Copenhagen, Denmark, June 
1993. ACM Press. [21] Julia L. Lawall and Olivier Danvy. Separating stages in the continuation-passing 
style transformation. In Su­san L. Graham, editor, Proceedings of the TuJent ieth Annual ACM Symposium 
on Principles of Progr-am­ming Languages, pages 124 136, Charleston, South Carolina, January 1993. ACM 
Press. [22] Albert R. Meyer and Mitchell Wand. Continuation se­mantics in typed lambda-calculi (summary). 
In Rohit Parikh, editor, Logics of Programs -Proceedings, num­ber 193 in Lecture Notes in Computer Science, 
pages 219 224, Brooklyn, June 1985. [23] Eugenio Moggi. Computational lambda-calculus and monads. Report 
ECS-LFCS-88-66, University of Edin­burgh, Edinburgh, Scotland, October 1988. [24] Eugenio Moggi. Computational 
lambda-calculus and monads. In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, 
pages 14-23, Pacific Grove, California, June 1989. IEEE Computer Society Press. [25] Eugenio Moggi. An 
abstract view of programming languages. Course notes ECS-LFCS-90-113, Labora­tory for Foundations of 
Computer Science, Department of Computer Science, University of Edinburgh, Edin­burgh, Scotland, April 
1990. [26] Eugenio Moggi. Notions of computation and monads. Information and Computation, 93:55-92, 1991. 
[27] Luc Moreau and Daniel Ribbens. Sound rules for par­allel evaluation of a functional language with 
callcc. In Arvind, editor, Proceedings of the Sixth ACM Confer­ence on Functional Programming and Computer 
Archi­tecture, pages 125 135, Copenhagen, Denmark, June 1993. ACM Press. [28] Chetan R. Murthy. Extracting 
Constructive Content from Ckmsical Proofs. PhD thesis, Department of Com­puter Science, Cornell University, 
1990. [29] Alan Mycroft. The theory and practice of transform­ing call-by-need into call-by-value. In 
Bernard Robinet, editor, Proceedings of the Fourth International Sympo­sium on Programming, number 83 
in Lecture Notes in Computer Science, pages 269 281, Parisj France, April 1980. [30] Peter Naur (editor). 
Revised report on the algorith­mic language Algol 60. Communications of the ACM, 6(1):1-17, 1962. [31] 
Chris Okasaki, Peter Lee, and David Tarditi. Call-by­need and continuation-passing style. In Talcott 
[39]. [32] Gordon D. Plotkin. Call-by-name, call-by-value and the A-calculus. Theoretical Computer Science, 
1:125-159, 1975. [33] John C. Reynolds. Definitional interpreters for higher­order programming languages. 
In Proceedings of 25th ACM National Conference, pages 717 740, Boston, 1972. [34] John C. Reynolds. On 
the relation between direct and continuation semantics. In Jacques Loeckx, edi­tor, .2nd Colloquium on 
Automata, Languages and Pro­gramming, number 14 in Lecture Notes in Computer Science, pages 141 156, 
Saarbrucken, West Germany, July 1974. [35] Amr Sabry and Matthias Felleisen. Reasoning about programs 
in continuation-passing style. In Clinger [4], pages 288-298. [36] Amr Sabry and Matthias Felleisen, 
Reasoning about programs in continuation-passing style. In Talcott [39], [37] Amr Sabry and John Field. 
Reasoning about explicit and implicit representation of state. In Paul Hudak, ed­itor, Proceedings of 
the ACM SIGPLA N Workshop on State in Programming Languages, pages 17--3o, Copen­hagen, Denmark, June 
1993. [38] David A. Schmidt. Denotational Semantics: A Method­ology for Language Development. Allyn and 
Bacon, Inc., 1986. [39] Carolyn L. Talcott, editor. Special issue on con­tinuations, LISP and Symbolic 
Computationj Vol. 6, Nos. 3/4. Kluwer Academic Publishers, 1993. [40] Robert D. Tennent. Semantics of 
Programming Lan­guages. Prentice-Hall International, Englewood Cliffs, New Jersey, 1991. [41] Philip 
Wadler. Comprehending monads. In Wand [44], pages 461-493. [42] Philip Wadler. The essence of functional 
programming (tutorial). In Andrew W. Appel, editor, Proceedings of the Nineteenth Annual ACM Symposium 
on Principles of Programming Languages, pages 1 14, Albuquerque, New Mexico, January 1992. ACM Press. 
[43] Mitchell Wand. Correctness of procedure representa­tions in higher-order assembly language. In Stephen 
Brookes, Michael Main, Austin Melton, Michael Mis­love, and David Schmidt, editors, Mathematical Foun­dations 
of Programming Semantics, volume 598 of Lec­ture Notes in Computer Science, pages 294 311, Pitts­burgh, 
Pennsylvania, March 1991. 7th International Conference. [44] Mitchell Wand, editor. Special issue on 
the 1990 ACM Conference on Lisp and Functional Programming, Mathematical Structures in Computer Science, 
Vol. 2, No. 4. Cambridge University Press, December 1992.  </RefA>
			


 A Matroid Approach to Finding Edge Connectivity and Packing Arborescences Harold N. Gabow* Department 
of Computer Science University of Colorado at Boulder Boulder, hal~boulder. Abstract. We present an algorithm 
that finds the edge connect ivity A of a directed graph in time O(Arn log (n2/rn)) and is slightly faster 
on an undi­rected graph (n and m denote the number of vertices a nd edgea, respectively). This improves 
the previous best time bounds, O(min{rnn, Aznz}) on a directed graph and 0(An2) on undirected. We present 
an al­gorithm that finds k edge-disjoint arborescences on a directed graph in time 0((kn)2). This improves 
the previous best time bound, O(kmrt + k3n2). Unlike pre­vious work, our approach is based on two theorems 
of Edmonds that link these two problems and show how they can be solved. 1. Introduction. The starting 
point of this work is two characteriza­tions of Edmonds for packing arborescences. Consider a directed 
graph G = (V, E). An arborescence is a di­rected spanning tree, i.e., an acyclic subgraph where some 
vertex a haa indegree zero and every other vertex has indegree one. We sometimes write a-arborescence 
and call a the root. The arborescence packing problem for vertex a is to construct the greatest possible 
number of edge-disjoint a-arborescences. An a-cut is the set of edges directed from V S to S, where 
S is any vertex set with @# S ~ V a. Edmonds first characterization for packing arborescences is in terms 
of cuts. Cut Characterization. In a directed graph the max­ imum number of edge-disjoint a-arborescences 
equals the minimum cardinality of an a-cut. * Research supported in part by NSF Grant No. CCR­8815636. 
Perrmssion to copy without fee afl or part of this material is granted provided that the copies are not 
made or distributed for direct commercial advantage, the ACM copyright notice and the titfe of the publication 
and its date appear, and notice is given that copying is by permission of the Association for Computing 
Machinery. To copy otfrer­wise, or to republish, requires a fee and/or specific permission. @ 1991 ACM 
089791-397-3/91/0004/01 12 $1.50 CO 80309 colorado. edu Edmonds gave an algorithmic proof using first 
princi­ples of graph theory [Ed72] (the algorithm is involved and seems to use exponential time in the 
worst case). Alternative proofs are in [F, Lo, TL]. The edge connectivity of a directed graph G, de­noted 
A(G), is the smallest number of edges whose dele­tion leaves a graph that is not strongly connected. 
Such a set of J(G) edges is a connectivity cut. G is k-edge­connected if A(G) > k. Clearly A(G) is the 
minimum cardinality of an a-cut in either G or G with all edges reversed. Thus the Cut Characterization 
gives a way to compute edge connect ivity. This observation also holds for undirected graphs G (since 
the edge connectivity of G equals that of the directed graph where each edge is oriented in both directions). 
To state Edmonds second characterization, recall that a spanning tree is subgraph of an undirected per 
we refer to a spanning this, simply ignore edge Matroid Characterization. graph can be partitioned a 
connected acyclic spanning graph. Throughout this pa­tree of a directed graph for directions. The edges 
of a directed into k a-arborescences if and only if they can be partitioned into k spanning trees and 
every vertex except a haa indegree k. We call this the Matroid Characterization since the con­dition 
corresponds to a matroid intersection, as indi­cated below. For k = 1 the Matroid Characterization is 
simply the definition of arborescence. However for k >2 the proof is not easy. Edmonds shows the Matroid 
Characterization follows from the Cut Characterization [Ed69]. This paper gives two algorithms, corresponding 
to the two Characterizations. The algorithm for the Ma­troid Characterization can be used to efficiently 
com­pute edge connectivity, The two algorithms together can be used to efficiently pack arborescences. 
Both al­gorithrnz are based on matroid theory. We now discuss the two algorithms and mention some related 
results. The algorithm for the Matroid Characterization finds k edge-disjoint spanning trees such that 
each ver­tex other than a has indegree k, and k is w large as possible. This can be done using an algorithm 
for maxi­mum cardinality matroid intersection [Ed65] along with techniques for efficiently implementing 
matroid inter­section and matroid sum algorithms on graphic ma­troids [GX89b, G W]. However we achieve 
much better efficiency with a different overall organization, which we call the round robin algorithm. 
Round robin runs in time O(krn log (n2/rn)) and is easy to program. Here and throughout this paper, n 
and m denote the number of vertices and edges of the given graph, respectively. Round robin can be used 
to find the edge connec­tivity, as observed above. The algorithm also produces a connectivity cut. The 
time is O(Jm log (n2/m)). For undirected graphs a preprocessing step reduces the time to O(rn + ~2n log 
(n/A)) (this is at most the previous bound and can be smaller). Alternatively round robin can check if 
a graph is k-edge-connected. The time is given by changing A to k in the above bounds. For instance we 
can check if an undirected graph is k-edge­connected, for any constant k, in time O(m + n log n). Let 
us summarize previous work on edge connectiv­ity. Early algorithms for computing edge connectivity are 
given in [ET, Sch]. The best-known time bound for finding the edge connectivity of an undirected graph 
is O(An2); since J = O(rn/n) for any graph, this bound is also O(nrn). The latter bound was first achieved 
by Podderyugin [P], the former by Karzanov and Timofeev [KT] (improving [Ti]). Matula [M87] rediscovered 
both bounds independently. Mansour and Schieber general­ized Matula s work to directed graphs, achieving 
time O(rnin{mn, A2n2}) [MS]. These bounds apply to check­ing k-edge-connectivity, changing ~ to k. An 
undirected graph can be checked for 2-or 3-edge-connectivity in time O(m) ([GI] reduces checking 3-edge-connectivity 
to checking 3-vertex-connectivity). Recently Nagamochi and Ibaraki have given a linear-time graph searching 
algorithm that is helpful in computing edge connectivity of undirected graphs [N189a]. We use their algorithm 
in our undirected con­nectivity algorithm. An application of Matula [M90] is discussed in Section 4. 
[N189b] uses it to find a mini­mum cut on graphs with large capacities (this does not improve any of 
the above bounds). All the above general edge connectivity algorithms (but not [N189a-b]) are based on 
network flow and Menger s Theorem rather than Edmonds Characteri­zations. Our time bound is asymptotically 
never larger than any of the above general bounds and it is smaller for graphs with m = o(n2) (since 
Jm log (n2/m) is 0( An2), and is O(Araz) when m = O(nz)). Our algorithm for the Cut Characterization 
ar­ranges a set of edges into k edge-disjoint arborescences, if possible. It runs in time 0((kn)2). Thus 
our two al­gorithms together find k edge-disjoint arborescences in total time 0((kn)2), if they exist. 
This improves the previous best-known bound, O(kmn + k3n2), due to Tong and Lawler [TL]. Earlier packing 
algorithms in­clude [T74, Sh]. For the special case k = 2 Tarjan gives an algorithm that runs in time 
O(m) if a linear-time set merging algorithm is used [T76, GT]. The analysis of our algorithms gives a 
new proof of the two Charac­terizations, so our development is self-contained. Our two step approach 
to packing also facilitates finding a minimum cost packing; an efficient algorithm is given in Section 
4. The remainder of this paper is organized as follows. Section 2 givea the round robin algorithm for 
the Ma­troid Characterization, and the edge connectivity algo­rithms. Section 3 gives the efficient arborescence 
pack­ing algorithm, and provea the two Characterizations. Section 4 states related results those mentioned 
above, plus improved spanning tree packing algorithms. The rest of this section gives notation and reviews 
matroids. Note that the paper is presented in terms of elementary graph theory. Material on matroids 
is included to place the results in their proper setting. However our proofs do not logically draw upon 
matroid theory. If S is a set and e an element, S+e denotes SU {e} and S -e denotes S {e}. The function 
log n denotes logarithm base two. For any graph G, V(G) and E(G) denote the vertex set and edge set of 
G, respectively. For vertices v and w, the notation vw denotes an undirected edge joining v and w, or 
a directed edge from v to w; it will be clear from context which is meant. A directed edge vw has tail 
v and head w. If S is a set of vertices, 6(S) denotes the set of all edges directed from S to V S; if 
F is a set of edges then 6F(S) denotes r5(S) n F. The function p is analogous to 6 for edges directed 
to a set; thus P(S) = 6(V -S). In these notations we abbreviate {v} to v, e.g., PF(V). Alao ifL isa setof 
edges then P(L) is an abbreviation for p(V(L)). Introductory treatments of matroids are given in [L76, 
R, W]. A matroid consists of a finite set S and a family of subsets of S called independent sets, that 
satisfy simple axioms. This paper works with several specific matroids, so we concentrate on describing 
them rather than matroids in general. The graphic matrvid of an undirected graph G, denoted G(G) (or 
g when the graph is obvious) has S = E(G) and independent sets the forests of G. A partition matroid 
on a set S is determined by a partition of S into sets S i and nonneg­ative integers di, i = 1, ..., 
p; A G S is independent if 1An Sil < di for each i. For matroids Mi$ i = 1, ..., k on the same set S, 
the mairoid sum Vf=l Mi is a matroid on S, whose inde pendent sets are all subsets of S that can be partitioned 
into k subsets, the ith subset independent in Mi. A spe­cial case is the k-fold sum of a matroid M, V:=l 
M, also denoted Mk. For example an independent set of ~k is a subgraph that can be partitioned into k 
forests. For matroids Mi, i = O, 1 on S, a (matroid) intersection is a subset of S that is independent 
in both Mi; the set of all such intersections is denoted M. n Ml. Polynomial-time algorithm for finding 
a maximum cardinality indepen­dent set of a matroid sum or a maximum cardinality matroid intersection 
are due to Edmonds [Ed65]; more efficient algorithms are in [GW, GX89a b]. Let A be a set of elements 
of S for an arbitrary matroid. If A is independent and spans an element e, then C(e, A, M) denotes the 
fundamental circuit of e in A. We drop the last argument M when it is clear from context. For example 
in a graphic matroid with edge e and spanning tree T, C (e, T) (or C(e, T, ~)) is the fundamental cycle 
of e in T. 2. The round robin algorithm. This section presents the round robin algorithm for the intersection 
problem corresponding to the Matroid Characterization. Then it applies round robin to com­pute edge connectivity. 
We begin by defining our matroid intersection problem and briefly reviewing matroid intersections and 
sums. Fix a directed graph G with a distinguished ver­tex a. Let k be any positive integer. Define ~k 
and Dk to be matroids over the edge set E(G) as follows. ~k is the k-fold sum of the graphic matroid 
of G. Dk is the partition matroid where an independent set contains no edges of p(a) and at most k edges 
of p(v), for each v # a. Let Tk denote the matroid intersection ~k n Dk. (Remark on superscript notation: 
~k is a k-fold sum. Dk is easily seen to be a k-fold sum. Tk, a matroid intersection, is not a k-fold 
sum, but the superscript in­dicates the link to ~k and Dk.) Call an intersection of Tk complete if it 
contains precisely k(n 1) edges. Thus the Matroid Characterization corresponds to finding a complete 
intersection of Tk. We do this by finding a maximum cardinality intersection. Let us review the algorithm 
to find a maximum cardinality matroid intersection, specialized to the in­tersection Tk. (For a complete 
discussion of the gen­eral matroid algorithm see e.g. [L75; L76, Section 8,4; R, Section 13. l].) The 
algorithm maintains an intersec­tion T of Tk, partitioned into forests Ti, i = 1, ..., k. The algorithm 
repeats the following step: Search for an augmenting path P. If P is found then augment T along P , thereby 
enlarging T by one edge; then repeat the step. If no augmenting path exists then halt with the maximum 
cardinality intersection T. Before defining the notion of augmenting path we describe how T is enlarged. 
Let z be a vertex with Ip-r(z)l < k. We wish to enlarge T by an edge, in­creasing the indegree of z by 
one. To do this an edge el 6 p(z) T is added to some forest Ti. If this re suits in a new forest we 
are done. Otherwise adding el creates a cycle, which is broken by removing some edge e2 from 7j. Edge 
e2 is treated in one of two ways. It can be added to another forest Tj; this is done using the above 
procedure for adding el. Alternatively it can be deleted from T; if ez is directed to vertex y, this 
decreases the indegree of y; this is remedied by adding an edge e3 G p(y) T, using the above procedure 
for adding el. This pattern continues until some edge et is added to a forest without creating a cycle. 
In this case the sequence el, . . . , et is an augmenting path P; the procew just described is called 
augmenting T along P. Now we give a precise definition of these terms. Let z be a vertex with IPT(.z)I 
< k. An augmenting path P fmm z is a sequence of edges ei, i = 1,...,1 with the following properties. 
(i) el c p(z) -T. (ii) For each i <1 either  (a) ei+l 6 C(ei, Zj, G), where ~ contains ei+l but not 
ei, or (b) ei+l is directed to the same vertex ss ei, where T contains e~ but not ei+l.  (iii) For 
some forest Th not containing el, Th + et is a forest. (iv) A pair ei, ei+l as in (ii.a) is called a 
swap; to execute the swap is to replace ei+l in Tj by ei. Then executing each swap of P and adding et 
to Th gives a new collection of forests. This operation is called aug­menting T along P. Clearly if (i) 
-(iv) hold then augmenting T along P enlarges T by one edge, increasing the indegree of z by one without 
changing any other indegree. A sequence ei, i= l,..., g satisfying all the above conditions except those 
on et is a partial augmenting path. Condition (iv) is essential and is not implied by the others. It 
can be guaranteed by any of several rules, e.g., path P has no shortcuts (i.e., no subsequence of P satisfies 
the definition) or P is formed using the cyclic scanning rule [RT, GW] or the topological numbering rule 
[GX89a-b]. This paper uses the first two rules. The reader familiar with matroids will observe that in 
our definition, a maximal subsequence of edges ei, i = r,. . . ,s, each consecutive pair related as in 
(ii.a), corresponds to the condition e, E C(er, T, ~ ) in the matroid definition of augmenting path (so 
edges er+l, ..., es-1 do not appear in the matroid defini­tion). Also (ii.b) essentially corresponds 
to the con­dition ei+l E C (ei, T, Dk ) in the matroid definition of augmenting path. A slight difference 
is that if ei and ei~l are directed to x, the condition of the matroid definition requires that l~(x)l 
= k, which we do not require. This relaxation is for convenience and causes no harm: if IPT(z)I < k then 
the augmenting path could actually begin with edge ei+l. Our definition of augmenting path indicates 
how to search for such a path. We give a high-level descrip­tion of the search for P. (A detailed and 
more efficient algorithm is given below.) The data structure consists of a label for each edge: if edge 
~ has the label e then there is a partial augmenting path ending with edges e, ~. The labels allow the 
augmenting path P to be traced out, starting from its last edge. We now sketch an algorithm that specifies 
L, the set of edges that get labelled in this search. It is a simple matter to assign appropriate labels. 
The labelling aigorithm works as follows. Consider an intersection T of Tk, partitioned into forests 
Ti. Let z be a vertex having ]~ (z) I < k. To search for an augmenting path from z, initialize set L 
to p(z) T. Then repeat the following step until it halts: L Step. If some edge e c L joins two trees 
of some forest Tt then halt (e completes an augmenting path). Otherwise add U{C(e, Ti, !3) I e c L ~} 
 L to L. If no edge has been added to L then halt (there is no augmenting path from z). Otherwise add 
U{p(v) T I ~n~(~) # 0} L toL. u The search is successful if it halts finding an augmenting path, and 
unsuccessful if it halts discovering that no augmenting path from z exists. We now observe two important 
properties of the la­ belling algorithm. First consider an unsuccessful search. Recall that in any graph, 
a collection of trees is cospan­ ning for S if each tree has the same vertex set S. If the labelling 
algorithm halts unsuccessfully with set L, then L n T is a set k subtrees of T that are cospanning for 
V(L); furthermore any vertex v with ~n~(~) # 0 has p(v) T ~ L. To prove this first observe that for 
each i, L n Ti is connected, hence a subtree (this follows by a simple induction). Furthermore when the 
algorithm halts unsuccessfully no edge can be added to L, so the k subtrees are cospanning. Next consider 
a successful search. As indicated, the last edge examined completes an augmenting path. This is obvious 
to readers familiar with the matroid in­tersection algorithm (there are no shortcuts if one views the 
matroid ~k as a direct sum of k copies of ~). Other readers can supply a simple inductive proof. Alterna­tively 
note that in the rest of the development we can substitute any labelling algorithm for this one, as long 
aa successful and unsuccessful searches have these two properties. We prove the two properties for the 
de­tailed labelling algorithm given below, thus completing the development. Now we give the basic lemma. 
Part (ii) justifies how our algorithm uses augmenting paths. Part (i) is an obvious consequence of Edmonds 
Characterizations. To make our development self-contained we give a sim­ple proofi among other things 
part (i) is used in Section 3 to prove Edmonds Characterizations. Let G be a directed graph, with intersection 
Tk defined for distinguished vertex a. Let T be an inter­section of Tk. Lemma 2.1. (i) G has a complete 
intersection of Tk if and only if any a-cut contains k or more edgea. (ii) If vertex z # a has l~(z) 
< kl then there is either an augmenting path from z or an a-cut containing less than k edges, Proof. 
We first prove the only if direction of (i). Let T be a complete intersection and let the vertex set 
S de­termine an a-cut p(S); lets = ISI. Then I U{ PT(Z) I z E S}I = ks. At most s 1edges ofeach tree 
ofT have both ends in S. Thus lp(S)l ~ ks k(s 1)= kss desired. Now we prove (ii). This also proves 
the if direc­tion of (i). Suppose we search for an augmenting path by initializing the set L to p(z) 
 T and then executing the labelling algorithm. Assume there is no augmenting path. Thus the labelling 
algorithm halts unsuccessfully with a set of edges L. We show this determines an a-cut of less than k 
edges. If L = 0 then z haa indegree less than k, by the initialization. Thus p(z) is the desired a-cut. 
We now show that if L # @then p(L) is the desired a-cut. Lett= IV(L)Iandp= I{z IzEV(L) z and p~ (z) 
# t?} 1. Since the search is unsuccessful, L tl T forma k subtrees of T that are cospanning for V(L). 
These subtrees contain L@ 1) edgea, each of which is in ~(z) for some x 6 V(L). Since [~(z)l ~ k, with 
strict inequality for z = z, we have kp~k(l 1) (k l)>k(l 2). Thus p >1 1, i.e., every vertex z c V(L) 
 z has PL(Z) # 0. We draw two consequences from this fact. First the fact clearly implies that a @ V(L). 
Thus V(L) is an a-cut. Second the fact implies that every z c V(L), including z, has p(z) T ~ L. Thus 
P(L) = U{PT(Z)I z E V(L)} L. The cardinality of the set on the right-hand side is at most k? 1 k(l 
 1) = k 1. In other words P(L) is an a-cut containing at moat k 1 edges. a We now present the round 
robin algorithm. Its in­put is a complete intersection for Tk-1, partitioned into k 1 spanning trees, 
Its output is a similar partitioned complete intersection for 7k, if such exists. Thus to find a complete 
intersection of Tk from scratch, start with k = 1 and repeatedly execute round robin until the desired 
value of k is reached. Round robin maintains an intersection T of Tk, partitioned into spanning trees 
Ti, i = 1,. ... k 1 and spanning forest Tk. The goal is to enlarge Tk to a span­ning tree. To do so 
two invariants are maintained. (i) Each vertex v # a has l~(v) I equal to k 1 or k. Call a (weakly) 
connected component of Tk a subtree. (ii) Each subtree has precisely one vertex z with ]~(z)l < k (z 
is either a or a vertex of indegree k 1). The notation S= denotes the subtree having z as its unique 
vertex of indegree less than k. An edge is joining if its ends are in different subtrees. Round robin 
is organized as a sequence of passes. At the start of a pass every subtree other than S. is active; a 
subtree created during the pass is not active. We start with a version of round robin that is efficient 
for graphs that are not extremely dense. Round robin initializes T to contain the given in­tersection 
of Tk-1 plus Tk, a forest consisting of all the vertices and no edges. Then it repeats the Paas Step 
until the algorithm halts. Pass Step. If Tk is a spanning tree then halt (T is a complete intersection 
of Tk ). Otherwise make all sub­trees except S= active. Then repeat the Augment Step until no subtree 
is active, or it halts. Augment Step. Choose an active subtree, say S z. Search for an augmenting path 
P from z that has pre­cisely one joining edge (its last edge). If P does not exist then halt (no complete 
intersection of Tk exists). Otherwise augment intersection T along P. B We briefly elaborate on the Augment 
Step. The last edge e of P joins S= to another subtree S y; the augment adds e to Tk, thus forming a 
new subtree. (The edges of S z may change in the augment but its vertices do not, so the new subtree 
has vertices V(S. ) U V(SY). Edge e may be in p(SZ ) or 6(SZ ).) The new subtree is inactive. Finally 
[~(z) I changes only for x = z, for which Iw(z)I becomes k. Thus the new subtree has a unique vertex 
with indegree less than k, preserving invariants (i) (ii). It is easy to see that round robin is correct, 
i.e., it finds a complete intersection of Tk if one exists: Lemma 2.1 shows that an augmenting path is 
always found in the Augment Step. Now we analyze the time for round robin. There are at most log n passes, 
since each pass halves the number of active subtrees. We will now implement a pass in time O(m), thereby 
proving that round robin uses O(rn log n) time. We show how to implement the labelling algorithm so 
it uses O(m) time per pass. It is easy to see that this implies the tot al time for a pass is O(m). The 
imple­ment at ion is based on two ideaa. The first is cyclic scan­ning, a labelling method used in [RI 
, GW] for matroid sum algorithms. The second idea is a simple data struc­ture to find a desired edge 
in a graphic fundamental cy­cle without tracing the entire cycle. Data structures Q and d below implement 
these two ideas, respectively. The algorithm uses the following data structures. Each edge of G has a 
label which, as in the labelling algorithm, indicates how to construct the augmenting path; the label 
also indicates if the edge is labelled or not. The vertices of each subtree S= are marked with the value 
z. Each tree of T is rooted arbitrarily and each vertex has a parent pointer. (Thus each vertex has k 
parent pointers. A tree Ti, i < k, contains one root, while forest Tk cent aim an arbitrary number of 
roots.) For each edge e that is in a tree T:, i < k, when round robin begins, d(e) (the depth ) is the 
length of the path beginning with e and ending at the root of Ti. The value d(e) does not change even 
aa the algorithm modifies T. There is a queue Q that contains labelled edges. In addition Q may contain 
an entry that is a flag (it separates the current group of edges from the next). The algorithm maintains 
an invariant that in each tree of T, theedges label led in a search form a subt ree; ri indicates the 
root of the subtree of Ti. A variable indicates the current tree Ti for computing fundamental cycles. 
At the start of round robin, initialize all parent pointers and d values. At the start of each pass, 
erase all labels and in each subtree S2 of Tk, initirdize parent pointers and set all vertex marks to 
z. To search for an augmenting path from vertex z, initialize index i + 1, rl + z and set Q to the edges 
of p(z) T, followed by a flag. Then repeatedly execute the Cyclic~canning Step until the Fundamental.cycle 
Step or LabeI Step stops, having found the desired path. Cyciic.scanning Step. Remove the first element 
e from Q. If e is an edge, execute the Fundamental-cycle Step. Ife isaflag, addanewflagto Q,aet i t (i 
mod k)+l, and if ri ~S=set ri * Z. Fundamental-cycle Step. Let a be an end of e such that u # ri and 
the tree edge from u to its parent is unla­beled. If u exists then execute the first of the following 
cases that apply. (We indicate below that u is unique if it exists.) Case (i) C(e, Ti) contains a joining 
edge. An aug­menting path P has been found. Choose the last edge ~ of P to be the joining edge in C(e, 
Ti) with largest value d(f) (break ties arbitrarily). Assign label e to ~ and stop. Case (ii) ri is an 
ancestor of u. Let A be the re­versal of the maximal length path of unlabeled edges from u to an ancestor. 
Go to the Label Step. Case (iii) Neither (i) nor (ii) hold. Let A be the tree path from ri to u. Set 
ri to the nearest common ancestor of u and ri. Go to the Label Step, Labe!Siep. Examine theedges of Ain 
order. For each such edge f, assign the label e to f and add f to Q; furthermore if f is directed to 
vertex v and no edge of p(y) l! islabelle dthendoth efollowing: Foreach edge g c P(Y) T, assign the label 
f to g; ifg is a joining edge then let it be the last edge of P and stop; otherwise addgto Q. m The correctness 
of this algorithm follows easily from properties of cyclic scanning proved in [RT, GW]. For completeness 
we outline the argument. An easy induction shows that at all times, the labelled edges in each Ti, i 
~ k, form a subtree rooted at ri. (This depends on the order that edges are processed in the Label Step. 
The inductive argument also shows that as mentioned, u is unique in the IOmdament al.cycle Step.) This 
fact implies that in Cases (ii) -(iii), A contains precisely the unlabeled edges in C(e, Ti). Thus when 
the Fundamental.cycle Step processes an edge e, it either stops (because of a joining edge) or it ensures 
that every edge in C (e, Ti) is labelled. Here i = (~ mod k) + 1, where Tj contains either e, or if e 
@ T, the label of e. The algorithm eventually stops with a joining edge. The only way it could otherwise 
stop would be if Q were empty. In this case let L denote the set of labelled edges. Any edge of L n Tj 
is spanned by L n Ti for i = (j mod k) + 1. This implies that sets L n Tj form k cospanning subtrees. 
Now it is easy to see that L satisfies all the properties for an unsuccessful search. Hence an augmenting 
path does not exist. But this is not the case in round robin. The last detail of correctness is that 
the algorithm stops with a valid augmenting path P. This is so be­cause P has no shortcuts that respect 
the cyclic scan­ning order. A detailed proof of validity is given below for the efficient implementation 
of this algorithm. For efficiency we must implement the Fundamen­tal-cycle Step so it traverses only 
edges of C (e, Ti) that are within S2. We do this as follows. Traverse the tree paths from ri and u to 
their root in parallel (i.e., fol­low parent pointers, alternating between ancestors of ri and u). Stop 
the traversal when either (i) a joining edge has been traversed in both paths, or (ii) in the path of 
u, a labelled edge is traversed or ri is encountered, or (iii) the nearest common ancestor of ri and 
u has been encountered in both paths. In possibilities (ii) (iii) every unlabeled edge in C (e, ~) is 
traversed; if C(e, Ti) contains a joining edge then execute Case (i), else exe­cute the corresponding 
Caae (ii) or (iii). In poasibilit y (i), although C(e, Z) is not traversed in entirety it is clear that 
Case (i) applies. Choose f to be the joining edge with larger d value (break ties arbitrarily). The correctness 
of this implementation depends on the fact that (i) chooses f to be the edge specified in Case (i). In 
particular it may not be clear that the edge is actually in C(e, Ti ). We prove this with the help of 
the following auxiliary property (a). For a joining edge e in Ti, i < k, define its successor e to be 
the joining edge after e in the path from e to the root of Ti, if such exists. Successors change as the 
algorithm progresses. (a) For any joining edge e that has a successor e , d(e) > d(e ). We now prove 
by induction that (i) chooses f as speci­fied in Case (i), and that property (a) holds at any time in 
a pass. In fact the argument also shows that the algo rithm finds a valid augmenting path. Hence this 
proof supplies all the details needed for a development inde­ pendent from matroid theory. Property (a) 
is clearly true when round robin be­ gins. It is easy to see that property (a) implies (i) chooses f 
as specified in Case (i). To complete the proof we need only show that property (a) is preserved each 
time intersection T is augmented along a path P. To show this augment T in the following way: Execute 
the swaps of P in reverse of their order along P. Then add the last edge of P (i.e., the joining edge) 
to Tk. We show that property (a) is preserved by each change to T. Let g,h be a swap of P, with h 6 Ti. 
First ob­serve that executing the swap does not change Sz or the joining edges. Thus successors change 
only because paths in T change. Recall that if A is a path leading to the root of Ti before the swap, 
then executing the swap replaces some subpath of A contained in C(g, Ti ) by another such subpath. (The 
subpaths may be empty.) Here C(g, Ti) denotes the fundamental cycle of g im­mediately before the swap 
is executed. Note that in general this need not equal C(g, Ti) when the Funda­mental-cycle Step assigned 
a label of g to h, since pre­viously executed swaps can change the cycle. We begin by considering a swap 
g, h of 1 where h is the last edge of P. Such a swap is the first to be executed (if it exists) so C(g, 
Ti ) is the same cycle as examined by the Fundamental-cycle Step. Executing the swap changes some successors 
from h to some other joining edge f c C(g, Ti ) or to h . The first alternative occurs only if swap g, 
h was discovered in possibility (i), The rule for choosing h implies d(h) ~ d(f), so property (a) is 
preserved. In the second alternative property (a) is preserved since d(h) > d(h ) by induction. Now consider 
a swap g, h of P where h is not last in P. When the swap is executed, C(g, Ti ) is the same as it was 
in the Fundamental-cycle Step. This follows because P has no shortcuts. One consequence of this fact 
is that the result of our executing swap g, h is a valid forest; this observation shows that P is in 
fact an augmenting path, and so it supplies the missing details for readers not versed in matroid theory. 
The other con­sequence of the fact is that C(g, Ti) has all its vertices 117 in Sz. Thus swap g, h does 
not change any successor e , and property (a) is preserved. To complete the proof it remains only to 
consider the effect of adding the last edge of P to T . This joins S. and another subtree, so some edges 
are no longer joining. Clearly property (a) is preserve d. This com­ pletes the induction. Now we show 
that the time per pass is O(m). An edge is labelled only once per pass, since it has an end in S,. Thus 
the Label Step uses time O(m). In addi­tion the time for the Fundamental-cycle Step is O(m) (more precisely 
O(kn)). This follows since the time is proportional to the number of edges labelled in (ii) (iii), plus 
the number of edges traversed in (i). Any edge is so labelled or traversed only once per pass. It is 
clear that this accounts for all the time. This completes the analysis of the first version of round 
robin. To improve the performance of round robin for dense graphs we make the following change: At the 
start of the ith pass, make only subtrees with less than 2i vertices active. To analyze the modified 
algorithm, observe that in one pass the algorithm examines at most one joining edge per vertex. In the 
ith pass the algorithm labels at most 2i nonjoining edges directed to each vertex z, since each edge 
of p(z) comes from a different vertex. In addition the time to initialize the pass is O(n). We conclude 
that the time for the ith pass is 0(2i n). Hence the first log (m/n) passes use total time O(m). In the 
ith pass an active subtree S. has at least 2i-1 vertices, Thus there are at most log n passes. Hence 
there are log n log (m/n) = log (n2/rn) remaining passes, each using time O(m). This gives total time 
O(rn log (n2/rn)) for round robin. Theorem 2.1. The round robin algorithm can be used to find a complete 
intersection of Tk in time O(krn log (n2/rn)) and space O(m). u Round robin can be extended to find a 
maximum cardinality intersection. Another extension is given at the end of Section 3. Although round 
robin is most efficient on graphs it extends to multigraphs. Represent a Multigraph by associating a 
multiplicity with each edge. The first ver­sion of round robin works correctly. It is implemented by 
representing each tree Ti explicitly and each edge of G T by storing its multiplicity. In each pass 
an edge of G T is examined only once. Thus the time to find a complete intersection of Tk is O(k(rn 
+ k-n) log n). The space is O(rrz + kn). The version of round robin for dense graphs speeds up the processing 
of edges of G T but not T. Thus it improves the time to O(k(m log (n2/rn) + km log n)). If each multiplicity 
is at most d then the log n factor decreases to log (dn/k). We mention a type of Multigraph used extensively 
in [G]. Suppose every edge with multiplicity greater than one is incident to the distinguished vertex 
a. Then the time is O(k(m log (n2/rn) + Ire)). This follows since any edge from a is joining. We turn 
to edge connectivity. To find the edge connectivity y of a directed graph G, choose an arbitrary vertex 
a; let R denote the graph G with the direction of each edge reversed. For k starting at one and assuming 
successively larger values, execute round robin on both G and R. Stop when the algorithm finds the smallest 
value k such that a complete intersection does not exist. Then A = k 1 by Lemma 2.l(i). This algorithm 
also finds a connectivity cut: A search for an augmenting path in Tk fails. The proof of Lemma 2.1 shows 
how the edges labelled in this search determine a cut of A edges. The time to find the edge connectivity 
of a directed graph is O(Am log (n2/rn)). This can be improved for undirected graphs. An obvious practical 
simplification is that the reverse graph R need not be processed. More importantly we use the following 
lemma of [N189a, Th]: Partition edges E(G) into a sequence of spanning forests Fi, i=l ,. ... n; do this 
by letting F l be a maximal spanning forest of G and proceeding recursively on G F1. It is easy to see 
that G has edge connectivity y k or more if and only if @=l Fi does. To compute the edge connectivity, 
first find the spanning forests Fi. Then use the connectivity proce­dure for directed graphs, modified 
as follows. Initialize the graph to vertices V(G) and no edges. At the start of the iteration for k, 
add edges ~(~k ) to the graph. Thus the kth execution of round robin starts with the previously computed 
intersection, and uses Tk for the edges of u~=l Fi. The algorithm of [N189a] finds all sets Fi in to­tal 
time O(m). The kth run of round robin uses time O(kn log (n/k)). A simple calculation shows that A runs 
use time 0(~2n log (n/J)). Theorem 2.2. The edge connectivity and a connectiv­ity cut can be found in 
time O(~rn log (n2/rn)) for a directed graph, O(m + ~zn log (n/~)) for an undirected graph. The space 
is O(m) for both. H 3. Packing arborescences. This sect ion begins with a high-level version of our packing 
algorithm. The correctness proof gives a new proof of Edmonds Characterizations. Then an efficient implementation 
of the packing algorithm is presented. Consider a directed graph G that is a complete intersection of 
Tk for distinguished vertex a. The goal is to partition the edges of G into k a-arborescences. We do 
this by maintaining two subgraphs: A is an a­arborescence for a subset of the vertices V(A). T is a 118 
complete intersection of T -l that is edge-disjoint from A, An enlarging path (for e) consists of an 
edge e E 6(A), plus if e c 2 , an augmenting path P for intersec­tion T e of Tk-l, that contains no 
edge of E(A)+ e. (Note that if vertex z is the head of e then P starts with the unique edge of p(z) 
T.) An enlarging path allows us to extend A by one edge as follows: If e c T then modify T by removing 
e and augmenting along P, obtaining a new complete intersection T. Now in either case, e ~ T. Add e to 
A. Clearly we have enlarged A by an edge and maintained the defining properties of A and T. The following 
lemma allows us to use enlarging paths as the main tool of the algorithm. Let G be a directed graph that 
is a complete intersection of Tk. Let A and T be subgraphs as defined above. Lemma 3.1. If V(A) # V(G) 
then there is an enlarg­ ing path. Proof. Choose any edge e E 6(A) (e exists by Lemma 2.1 (i)). Suppose 
e c T, else e forms the desired enlarg­ing path. Let vertex z be the head of e. Suppose we search for 
an augmenting path for intersection T e by initializing the set L to the edge of p(z) T and then executing 
the labelling algorithm. We begin by showing that if the search halts unsuccessfully, having labelled 
a set of edges L, then 6~(A) # 0. Let 1?= IV(L)]. Let R = V(L) V(A) and r = IR[. The edges of L n T 
form k 1 subtrees of T that are cospanning. Thus IL n TI = (k 1)(? 1). Since each vertex z haa lp~(z) 
[ < k 1, L n T contains at most (k l)(t r) edges directed to vertices of A. Thus it contains at least 
(k 1) (r 1) edges directed to vertices of R. Let p= l{z Iz c R z and p~(x) # 0}1. Then (k-l)p~(k-l)(r-l)-(k 
-2)>(k-l)(r-2). Thus p z r 1, i.e., every vertex x E R z has p~(z) # $. Hence every such vertex z has 
the edge of p(z) -T in L. The edge of p(z) T is added to L in the initialization. Hence the number of 
edges in L directed to a vertex of R is at least (h-l) (r-l) +r>k(r-1). Since G is independent in ~ k, 
the number of edges of G with both ends in R is at most the right-hand side. Thus PL (R) = 6L(A) # 0 
as desired. To complete the proof consider an edge e E 6(A) whose search is unsuccessful and has [L [ 
minimum. As shown above there is an edge e E 6L (A). We show the search for an augmenting path for e 
is successful, by contradiction. Thus suppose the search for e is unsuc­cessful, and it labels a set 
of edges L . Then L C L, since any edge labelled in the search for e could be similarly labelled in the 
search for e. (This depends on the fact that both searches are unsuccessful.) Further­ more e @ L by 
definition. Thus [L 1 < ILI, the desired contradiction. B The lemma can be used to partition G into k 
dis­joint a-arborescences, as follows. Initialize T to a com­plete intersection of T -1. Initialize A 
to a partial ar­borescence containing vertex a and no edges. Then re­peatedly find an enlarging path 
and use it to add an edge to A, until V(A) = V(G). Output the arbores­cence A. If k = 1 then halt, else 
decrease k by one and repeat the entire procedure on graph G A. The correctness of this procedure follows 
from the fact that a complete intersection of T&#38;-l actually ex­ists. This follows from Lemma 2.1 
(i): Since G has a complete intersection of Tk, any a-cut has at lesst k edges, whence G haa a complete 
intersection of Tk-1. This proves the Matroid Characterization. The Cut Characterization also follows, 
using Lemma 2. l(i). We turn to an efficient implementation of this pro­cedure. The main difficulty is 
that the edge e that actu­ally has an enlarging path is unknown. A simple strat­egy like trying all possibilities 
would increase the time by a factor of kn. We avoid this inefficiency using two observations. Suppose 
an edge e gives an unsuccessful search for an augmenting path in T e. Let L be the set of edges labelled 
in the search. The proof of Lemma 3.1 shows that lLl=lLfl Tl+lL-Tl~(k-l)(l l)+r. Now suppose that G is 
partitioned into arborescences Ai, i=l ,..., k, where A ~ Al. (This can be done, as shown above.) For 
each i >1, [A; fl L[ S IV(L)[ ­1 = f 1, and IA1 nLI ~ r. The lower bound on [Ll implies these inequalities 
hold with equality. Thus for each i > 1, A~ contains precisely 1 1 edges of L that form a subarborescence. 
Similarly Al contains precisely r edges of L forming a number of subarborescences, each rooted at a vertex 
of A. (A root is not in R since the r edges are directed to the vertices of R.) The roots of the subarborescences 
in Ai, i >1, are precisely the heads of the edges of p-r(L). To prove this first observe that a @ V(L) 
(otherwise having z 6EV(L) implies lLflTl s (k 1)(1 2)+(k 2) < (k 1)(1 1) = IL n T[). This implies that 
[pT(L)[ = (k -1).t -(k ­ 1)(/ 1) = k 1. Thus the edges of ~(L) are precisely the edges that enter the 
subarborescences spanning L inAi, i> 1. Based on these observations we construct an algo rithm that processes 
L recursively. (One poaaibilit y is to find all k arborescences for L recursively; for notational simplicity 
our algorithm finds only one arborescence re cursively.) It is convenient to now let Go denote the given 
graph, with distinguished vertex ao. We use a re­ cursive procedure P(G, a, A, T). Argument G is a graph 
having a complete intersection of T~ for distinguished vertex a; arguments A and T are as above, i.e., 
A is an a-arborescence for a subset of the vertices, and T is a complete intersection of Tk -1, edge-disjoint 
from A; in addition T is partitioned into k 1 spanning trees. Procedure p modifies A and T but maintains 
these prop­erties. It returns with Aana-arborescence for Gthat is edge-disjoint from some complete intersection 
of T~ l, The initial call to procedure p is p(Go, ao, A, T), where A contains vertex a. and no edges, 
and T is a complete intersection of Tk 1; it constructs an ao-arborescence. Procedure p(G, a, A, T) returns 
if V(A) = V(G). Otherwise choose an edge e c 6(A), where if possible e @ b(a). Execute the case below 
that applies and then return A. Case (i) An enlarging path for e exists. Find such a path. Use it to 
enlarge A. Then call p(G, a, A, T). Case (ii) No enlarging path for e exists. Let L be the set of edges 
labelled in the search for an augmenting path for T e. Denote the k 1 subtrees comprising L i3T as 
Li; denote the k 1 edges of D(L) as e~; here i = 1,..., k 1 but the indexing is arbitrary. (We remark 
that a tree of T need not contain any edge ei.) Modify graph G to G by contracting V(G) V(L) into a 
single vertex a . Let A contain the edges of A directed to vertices in V(L). Let T be the com­plete intersection 
of T~-I for G and distinguished ver­tex a , whose ith tree consists of Li plus ei. Call P(G , a , A , 
T ). Modify graph G to G by contracting V(L) into a single vertex L . Add an arbitrary edge ~ 6 A np(L) 
to A (changing its head to L ). Modify T to an intersection for G by replacing each subtree Li by vertex 
L . Call p(G , a, A, T). Then in A, replace edge f by the edges A A. B We prove that procedure p is correct 
in two steps. First prove by induction that for each invoca­tion p(G, a, A, 2 ), the arguments satisfy 
their defining properties; furthermore if the invocation returns, A is an a-arborescence for G, edge-disjoint 
from a complete intersection of Tk -1. The argument is straightforward and we just mention some details 
concerning the first recursive call in Case (ii). First observe that the ar­guments G{, a , A and T satisfy 
the defining proper­ties, by the discussion preceding procedure p. Second observe that immediately after 
the first recursive call returns, adding the edges of A A to A gives an a­subarborescence. This follows 
because when p returns each edge ei is in a tree of T1 and hence not in A . (Note that adding an edge 
ei to A need not give an a-subarborescence, since the tail of ei may not be in A.) These observations 
imply that Case (ii) does re­turn with A the desired a-arborescence. The second step is to prove that 
all recursive calls terminate. This follows from the fact that in Case (ii) each graph G has fewer vertices 
than G. This is clear for the second graph G so consider the first. Let e = ZZ. Since the search is unsuccessful 
z $? V(L). Thus if z # a the desired conclusion holds. If z = a then the choice of e implies that 6(A) 
~ c$(a). But in this case the search is successful, since an unsuccessful search has a @ V(L) (as just 
noted), implying 6,z(A) = 0, contradicting 6L(A) # 0 (as shown in Lemma 3.1). Now we estimate the time. 
Consider an initial call p(GO, ao, A, T), where A contains vertex a. and no edges, and T is a complete 
intersection of Tk-1. We show the entire time (including all recursive invo­cations) is 0(krz2). Consider 
an invocation of p where V(A) # V(G). The time, excluding recursive calls, is proportional to the number 
of edges. To achieve this we implement the search for an augmenting path using cyclic scanning, as in 
Section 2. Case (i) occurs at most n times in the entire algorithm (observe that any edge added to A 
in Case (i) is in the arborescence returned by the initird call). The time is O(kn) for each occurrence, 
giving total time 0(kn2). For Case (ii), an unsuccessful search, observe an edge ~ @ ~(L) is in only 
one of the two graphs G , and each of these graphs has fewer vertices than G. Thus this possibility y 
occurs for ~ at most n times. Say the time for a search amounts to 1 time unit per edge. If ~ # L U ~(L) 
charge 1 time unit to ~ for this unsuccessful search. If ~ E L charge 2 units to ~. This accounts for 
the time spent on all edges of L UpT(L), since ILI ~ k 1 = l~(L)l. Thus the total time for unsuccessful 
searches is 0(kra2). The space needed by the algorithm is O(kn). We use only one global data structure 
for the graph, A and T, and all recursive invocations of p work on it. Note that in the first recursive 
call of Case (ii) only edges with both ends in V(L) get labelled in a search. For the second recursive 
call we modify the global data struc­ture, by choosing some vertex of L to represent L and changing the 
data structures accordingly. Now we give an algorithm to construct the greatest possible number of edge-disjoint 
a-arborescences in a given directed graph. Use the round robin algorithm to find the largest value k 
such that G has a complete intersection of Tk. Then assign a. t a, let Go be the subgraph with edges 
E(T), and execute the following procedure. Use round robin to find a complete intersection T of Tk-l. 
Initialize A to the vertex a.. Execute P(G 0, ao, A, T). Output the arborescence A. If k = 1 then halt, 
else decrease k by one and repeat the entire procedure on graph Go A. The time for this procedure is 
O((kn)2). To show this observe that the bound for one execution of round robin is O(krn log (nZ/m)) = 
O(kn2). The bound for one execution of p is the same. There are k + 1 execu­tions of round robin and 
k executions of p. Theorem 3.1. In a directed graph, the greatest num­ values 1 ,..., k, and if e # Tk 
then i = k. In summary ber k of edge-disjoint a-arborescences can be found in the results of Theorems 
2.1 and 3.1 apply to the general time O((kn)z) and space O(m). m case . Clearly the same bounds apply 
to the problem where k is given and we wish to find k edge-disjoint a­arborescences, if they exist. These 
results also apply to multigraphs, for which the bounds are O((kn)2) time and O(rn + kn) space. The procedure 
must be modified slightly, since on a Multigraph k executions of round robin may exceed the desired time 
bound by a logarithmic factor. The idea for the modification is that round robin need only be executed 
once, to determine the value of k. To achieve this the procedure finds a complete intersection T of Tk-l 
by making two changes: Procedure p is modified to return, in addition to A, a complete intersection T 
of Tk-1 that is disjoint from A. After the execution of p, the desired complete intersection is found 
by removing appropriate edges from T and then finding O(n) aug­menting paths. Using cyclic scanning the 
time to find these augmenting paths is O(kn2). Since this is done k times, the total time is O((kn)2) 
as desired. Note that in practice it may be desireable to use this modification on graphs as well as 
multigraphs. We close by mentioning the more general version of Edmonds Characterizations. In a directed 
graph G, if A is a nonempty set of vertices then an arborescence rooted at A is a subgraph such that 
for every vertex v there is exactly one directed path from a vertex of A to v. Consider a family of k 
nonempty sets of vertices Ai, i=l ,.. ., k. The Cut Characterization states that G contains k edge-disjoint 
arborescences, the ith one rooted at Ai, if and only if for any nonempty set of vertices S, P(S) z P(S). 
Here P(S) = I{i I AinS = 0}1. The Matroid Characterization states that the edges of G can be partitioned 
into k arborescences, the ith one rooted at Ai, if and only if they can be partitioned into k spanning 
forests, the ith one rooted at Ai, and each vertex v has indegree k a(v). Here a(v) = [{i I v c Ai}l 
and a spanning tree rooted at A is the undirected version of an arborescence rooted at A. The results 
of this paper extend to the general case. To state the basic observation, consider an undirected graph. 
Let H be a subgraph whose edges can be par­titioned into k forests, the ith one containing no path between 
any two vertices of Ai. Then for S = V(H), IE(H)I < klSl P(S) ~{a(v) I v E S}. An unsuc­ cessful search 
for an augmenting path labels a subgraph that satisfies this inequality with equality. Lemmas 2.1 and 
3.1 are proved analogously. The main change in the algorithms is in round robin cyclic scanning does 
not work in this context. We use Tk­scanning : for a labelled edge e, Tk-scanning labels the edges in 
C(e, Ti ), where if e c Tk then i ranges over the 4. Related results. This section summarizes several 
related results. Edge connectivity. Consider an undirected graph with minimum degree IS. Choose any c 
> 0. Matula shows that if A s (~ 6)6 the edge connectivity can be found in time O(rn + n2/6) [M90]. 
Incorporating round robin into his algorithm improves the time to O(m log n) or better (O(m) when 6 = 
f2(@), as in [M90]). A problem in cluster analysis is, find a subgraph of maximum possible edge-connectivity. 
Matula accom­plishes this in time 0(n3) [M87]. Repeated applications of round robin achieves time 0(rn2 
log (n2/m)), an im­ provement for sparse graphs. The algorithm of [KT] for undire cted edge connec­ tivity 
finds all connectivity cuts, not just one. A forth­ coming paper [G] presents extensions of round robin 
solving this and other problems. Packing spanning trees. In an undirected graph, we seek k edge-disjoint 
spanning trees (i.e., a msx­imum independent set of L7k). Curiously the round robin approach does not 
seem to work in the undi­rected case! We improve the algorithms of [GWl to time O(kn/m + kn log n). We 
use a system of guards to prevent edges from being scanned k times, in each graphic matroid of Gk. Next 
suppose each edge has an integral capacity, at most iV; we seek the greatest number of edge-disjoint 
spanning trees, where the number of times an edge can be used is given by its capacity (for the output, 
each tree is specified together with a multiplicity). We give an algorithm that uses time 0(n4m2 log 
21V); it uses scaling and guards. [GLS, p.313] gives a polynomial time algorithm based on the ellipsoid 
method. Packing weighted arborescences. In a directed graph with edge costs, we seek a set of k edge-disjoint 
a­arborescences of minimum total cost. (Equivalently we seek a minimum cost subgraph that has k edge-disjoint 
paths from a to any vertex v, plus the paths for all v.) We give an algorithm that uses time O(kn(m + 
n log n) log n). It uses an initialization scheme to r~ duce the number of augmenting paths from kn to 
n. We also give a cost-scaling algorithm that uses time O(k/=(m + kn log n) log (nIV)), for integral 
costs at most iV. It uses guards. Acknowledgments. Thanks lo Zvi Galil, David Mat­ula, Vijaya Ramachandran, 
Eva Tardos and Ramki Thurimella for sharing their ideas. References. <RefA>[M87] D.W. Matula, Determining edge 
connectivity in [Ed65] J. Edmonds, Minimum partition of a matroid into independent subsets , J. Res. 
National Bureau of Standards 69B, 1965, pp. 67-72. [Ed69] J. Edmonds, Submodular functions, matroids, 
and certain polyhedra , Calgary International Conf. on Combinatorial Structures and their Ap­plications, 
Gordon and Breach, New York, 1969, pp. 69-87. [Ed72] J. Edmonds, Edge-disjoint branchlngs , in Com­binatoria~ 
Algorithms, R. Rustin, Ed., Algorith­mic Press, New York, 1972, pp. 91 96. [ET] S. Even and R.E. Tarjan, 
Network flow and test­ing graph connectivity , SIAM J. Comput., 4, 4, 1975, pp. 507-518. [F] A. Frank, 
Kernel systems of directed graphs , Acts Sci. Math., 41, 1979, pp. 63-76. [G] H.N. Gabow, Efficient implementations 
of algo­rithms to increase edge connectivity y , manuscript in preparation. [GI] Z. Galil and G.F. Italiano, 
Reducing edge con­nectivity y to vertex connectivity y , manuscript. [GLS] M. Griitschel, L. LOWLSZand 
A. Schrijver, Geomet­ric Algorithms and Combinatorial Optimization, Springer-Verlag, New York, 1988. 
[GT] H.N. Gabow and R.E. Tarjan, A linear-time al­gorithm for a special case of disjoint set union , 
J. Comp. and System Sci., 30, 2, 1985, pp. 209-221. [GW] H.N. Gabow and H.H. Westermann, Forests, frames 
and games: Algorithms for matroid sums and applications , Proc. 20th Annual A CM Symp. on Theory of Comp., 
1988, pp. 407-421; also Al­gorithmic, to appear. [GX89a] H.N. Gabow and Y. Xu, Efficient theoretic and 
practical algorithms for linear matroid intersection problems , Technical Rept. CU-CS-424-89, Comp. Sci. 
Dept., Univ. Colorado, Boulder, CO, 1989; submitted for publication. [GX89b] H.N. Gabow and Y. Xu, Efficient 
algorithms for independent assignment on graphic and linear ma­troids , Proc. 30th Annual Symp. on Found. 
of Comp. Sci., 1989, pp. 106 111, [KT] A.V. Karzanov and E.A. Timofeev, Efficient al­gorithm for finding 
all minimal edge cuts of a nonoriented graph , Kibernetika, 2, 1986, pp. 8­12; translated in C@ernetics, 
1986, pp. 156-162. [L75] E.L. Lawler, Matroid intersection algorithms , Math. Progmmming, 9, 1975, pp. 
31-56. [L76] E.L. Lawler, Combinatorial Optimization: Net­works and Matroids, Holt, Rhinehart and Win­ston, 
New York, 1976. [Lo] L. Lov&#38;z, On two minimax theorems in graph theory , J. Comb. Theory, B, 21, 
1976, pp. 96 103. O(nrn) , Proc. 28th Annual Symp. on Found. of Comp. Sci., 1987, pp. 249-251. [M90] 
D.W. Matula, A linear time 2 + e approximation algorithm for edge connectivity y , preprint. [MS] Y. 
Mansour and B. Schieber, Finding the edge connectivity y of directed graphs , J. Algorithms, 10, 1, 1989, 
pp. 76-85. [N189a] H. Nagamochi and T. Ibaraki, Linear time algo­rithm for finding a sparse k-connected 
spanning subgraph of a k-connected graph , Algorithmic, to appear. [N189b] H. Nagamochl and T. Ibaraki, 
Computing edge­connectivity in multiple and capacitated graphs , Teehnical Rept. #89009, Dept. of Applied 
Math. and Physics, Kyoto Univ., 1989. [P] V.D. Podderyngin, An algorithm for finding the edge connectivity 
of graphs, Vopr. Kibern., 2, 1973, p. 136. [R] A. Recski, Matroid Theory and its Applications in Eleetric 
Network Theory and in Statics, Springer-Verlag, New York, 1989. [RT] J. Roskind and R.E. Tarjan, A note 
on find­ing minimum-cost edge-disjoint spanning trees , Math. Op. Res. 10, 4, 1985, pp. 701-708. [Sch] 
C.P. Schnorr, Bottlenecks and edge connectivity in unsymmetrical networks , SIAM J. Cornput., 8, 2, 1979, 
pp. 265-274. [Sh] Y. Shiloach, Edge-disjoint branching in directed multigraphs , Inf. Proc. Letters, 
8, 2, 1979, pp. 24-27. [T74] R.E. Tarjan, A good algorithm for edge-disjoint branching , lnf. Proc. Letters, 
3, 2, 1974, pp. 51­ 53. [T76] R.E. Tarjan, Edge-disjoint spanning trees and depth-first search , Acts 
Informatica 6, 1976, pp. 171 185. [T83] R.E. Tarjan, Data Structures and Network Al­gorithms, SIAM Monograph, 
Philadelphia, PA, 1983. [Th] R. Thurimella, Findhg a sparse k-edge connected spanning subgraph of a k-edge 
connected graph , preprint. [Ti] E.A. Timofeev, An algorithm for constructing minimax k-connected oriented 
graphs~, Kiber­netika, 2, 1982, p. 109. [TL] P. Tong and E.L. Lawler, A faster algorithm for finding 
edge-disjoint branching , Inf. Proc. Let­ters, 17, 2, 1983, pp. 73 76. [w] D. J.A. Welsh, Matroid Theory, 
Academic Press, New York, 1976.</RefA>
			

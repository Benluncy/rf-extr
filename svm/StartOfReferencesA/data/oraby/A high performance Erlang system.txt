
 b e t h a s c o n - h b e in g , b u t e m y e m h a s e c o d e . h of systemshouldprovideaseamlessintegrationofemulated 
andnativecodeexecution,andallowitsusertochoosethe executionmodeindividuallyforeachapplicationcomponent 
basedonthevariousspace/timetrade-ofsthatareinvolved. Informationaboutthesetrade-ofsshouldalsobesomething 
thatthesystemprovidestoitsuser. Thispaperpresentsourapproachtotheefcientexecution ofErlang.Wehavedevelopedasystem,HiPE,whichcom­binestheperformancecharacteristicsofanativecodecom­pilerwiththebeneftsofanemulatedimplementation.HiPE 
currentlyusestheJAMemulator[1]asabasisandallows selectivecompilationofwholemodulesorindividualfunc­tionsintonativecode,whichisthenexecuteddirectlybythe 
underlyinghardware.Besidesfullydescribingthearchitec­tureofHiPEandthechangestotheJAMrun-timesystem neededtosupportnativecodeexecution,wediscussvarious 
technicalissuesthatthisemulated/nativecodeintegration entailsinthecontextofErlangandhowwedealtwiththem. 
Morespecifcally: .wepayspecialattentiontosupportinghot-codeloading (seenextsection)anderrorhandlinginHiPE; 
.wedescribeamethodforperformingtailcalloptimiza­tioninamixedmodeofexecutionwhereaseparate stackisusedforeachmode|thismethodisprobably 
folklorebut,tothebestofourknowledge,ithasnot beenreportedintheliterature; .wecompareandanalysetheperformanceofexisting 
Erlangimplementationson\standard"smallbench­marksandonlargeprogramsfromactualindustrial ErlangapplicationsandshowthatHiPE'sperformance 
issuperior. Tomakethispaperself-contained,webeginbyreviewing thecharacteristicsofErlang(Section2).Sections3and4 
formthemainpartofthispaperanddescribethebasic characteristicsofHiPE,itsarchitecture,andtheintegration 
ofnativeandemulatedexecutionwithinthesamerun-time system.Section5containsaperformancecomparisonof HiPEagainstotherimplementationsofErlang,bothindus­trialandacademic,andagainstotherfunctionallanguages. 
Section6containsadditionalmeasurementsonsomeofthe benchmarkprogramsusedinourperformanceevaluation thatgivemoreinsightonHiPE'sperformance.Weendthis 
paperwithsomeconcludingremarks. 2. A BRIEF INTRODUCTION TO ERLANG Erlangisadynamicallytyped,strict,concurrentfunctional 
programminglanguage.Itispossibletocreateclosuresin Erlang,buttypicalErlangprogramsaremostlyfrst-order. 
Erlang'sbasicdatatypesareatoms,numbers(integerswith arbitraryprecisionandfoats),processidentifers,andref-erences;compounddatatypesarelistsandtuples.Thereis 
nodestructiveassignmentofvariablesandthefrstoccur­renceofavariableisitsbindinginstance.Functionselection 
happensusingpatternmatching.Erlang'sdesigninherits someideasfromconcurrentconstraintlogicprogramming 
languagessuchastheuseoffatguardsinfunctionclauses. ProcessesinErlangareextremelylight-weight,theirnum­berintypicalapplicationsisquitebig,andtheirmem­oryrequirementsvarydynamically.Erlang'sconcurrency 
primitives|spawn,\!"(send),andreceive|allowapro­cesstospawnnewprocessesandcommunicatewithother processesthroughasynchronousmessagepassing.Anydata 
valuecanbesentasamessageandprocessesmaybelocated onanymachine.Eachprocesshasamailbox,essentiallya messagequeue,whereeachmessagesenttotheprocesswill 
arrive.Messageselectionfromthemailboxoccursthough patternmatching.Thereisnosharedmemorybetweenpro­cessesanddistributionisalmostinvisibleinErlang.To 
supportrobustsystems,aprocesscanregistertoreceivea messageifanotheroneterminates. Erlangapplicationstypicallyconsistofanumberofmod-ules:anErlangmoduledefnesanumberoffunctions.Only 
explicitlyexportedfunctionsmaybecalledfromothermod­ules.Callingfunctionsindiferentmodules,calledremote 
calls,isdonethroughsupplyingnameofthemoduleofthe calledfunction.Duringexecutionoffunctions,tailcallop­timizationisperformed.Asinotherfunctionallanguages, 
Erlang'smemorymanagementisautomaticthroughgarbage collection.Thereal-timeconcernsofthelanguagecallfor 
bounded-timegarbagecollectiontechniques;see[24,16].In practice,garbagecollectiontimesareusuallysmallasmost 
processesareshort-livedorsmallinsize. Toperformsystemupgradingwhileallowingcontinuousop­eration,anErlangsystemneedstocaterfortheabilityto 
changethecodeofamodulewhilethesystemisrunning,so calledhot-codeloading.Processesthatexecuteoldcodecan 
continuetorun,butareexpectedtoeventuallyswitchtothe newversionofthemodulebyissuingaremotecall(which willalwaysinvokethemostrecentversionofthatmodule). 
Erlangprovidesmechanismsforallowingaprocesstotime­outwhilewaitingformessagesandacatch/throw-styleex­ceptionmechanismforerrorhandling. 
TheErlanglanguagewaspurposelydesignedtobesmall, butcomeswithlibrariescontainingalargesetofbuilt-in functions(knownasBIFs).WiththeOpenTelecomPlat­form(OTP)middleware[23],Erlangisextendedwithstan­dardsolutionstocommonrequirementsoftelecommunica­tionapplications(servers,statemachines,processmonitors, 
loadbalancing),standardinterfaces(CORBA),andstan­dardcommunicationprotocolssuchasHTTPandFTP. 3. JAM: 
THE BASIS OF HIPE HiPEisbasedonthebytecodeemulatedJAMimplemen­tationofErlang,towhichitaddstheabilitytocompile 
andexecuteErlangasnativemachinecode.HiPEisanew component(currently30,000linesofErlangcodeand3,000 linesofCandassemblycode)addedtoanotherwisemostly 
unchangedJAMsystem;onlytheJAMemulatorandthe garbagecollectorhavebeenextendedtobeawareofnative code.Becauseofthistightintegration,wedescriberelevant 
aspectsofthebasicJAMsystemhere;Section4continues withHiPE-specifcs.1 1HiPEispubliclyavailableasopen-source.Thecurrent 
releaseisbasedonEricsson'sOpenSourceErlang47.4.1. Seehttp://www.csd.uu.se/projects/hipe. 3.1 The JAM 
system TheJAM-basedErlangimplementationusesJAM:avir­tualstackmachinewhoseprimitiveoperationscloselycor­respondtotheErlanglanguage.Forexample,sinceErlang 
isadynamically-typedlanguage,JAMusesaself-describing datarepresentationwithtaggedvalues[10],andtheemu­lator'sinstructionsoperateontaggedvalues,neveronraw 
machinevalues. 3.1.1 The JAM compiler TheJAMcompilerisanon-optimisingcompilerwhichper­formsastraightforwardtranslationtotheJAMvirtualstack 
machine.Theobjectflescontainbytecodesandrelocation entrieswhichdescribeallsymbolicreferencesthatmustbe 
resolvedbytheloader. 3.1.2 The JAM loader TheJAMloadertranslatesJAMbytecodesfromtheex­ternalformattotheinternalformatexpectedbytheJAM 
emulator. Erlangatomsaresymbolicconstants,likeatomsinProlog orsymbolsinLisp.Theinternalrepresentationofanatom 
isitspositionintheatomtable,whichisnotknownuntil runtime.Therefore,thefrsttaskoftheloaderistoreplace 
symbolicreferencestoatomsbytheircurrentinternalrep­resentation. Aremote(non-local)functioncallisrepresentedbyatriple 
(modulename,functionname,functionarity).Firstthe namesaretranslatedtointernalatoms.Thenspecialcases areidentifed,suchascallstotheerlangmodulewhich 
becomecallstoCfunctionsintheruntimesystem.Finally, theJAMinstructionatthiscallsiteispatchedtorefectthe 
result. Afteramodulehasbeenloaded,aglobalsymboltableis updatedwithinformationaboutthemodule,itsexported 
functions,andthecodeaddressesatwhichthosefunctions start. 3.1.3 The JAM emulator TheJAMemulatorisasingleCfunctionwhichexecutes 
JAMinstructionsrepresentedasbytecodes.TheJAMim­plementationisindirectlythreaded[4,17].Theemulatoris invokedonarunnableErlangprocess,andexecutescodefor 
thatprocessuntilitblocks.Aprocessblockseitherwhenit attemptstoreadamessageanditsmessagequeueisempty, 
orwhenits\timeslice"hasexpired.Timeslicesarerep­resentedbyworkbudgets,whichareexplicitlydecremented andcheckedatspecifcpointsintheemulator. 
EachErlangprocessisdescribedbyaprocesscontrolblock (PCB),astack,aheap,andasetofpointerregisters: spnextwordonthestack 
fpstartofcurrentfunction'sactivationrecord apfrstactualparameter pccurrentbytecodeinstruction ccdebuginformationaboutthecurrentfunction 
Thestackdisciplineissimplebutunoptimised.Atacall, theparametersarepushedinleft-to-rightorder,followed 
bya4-wordcontinuationrecordcontainingthecaller'sfp, ap,pc,andcc.Thenfpissettopointtothestartofthis record,sptothefrstwordaftertherecord,andaptothe 
frstparameter(derivedfromfpandthecallee'sarity);see Figure1.(Notethatapnowhasthesamevalueasthe caller'ssphadbeforethecall.)Atreturn,spisresettoap, 
thencc,pc,ap,andfparerestoredfromtheframe,andthe returnvalueispushedontothestack. ap! fp! sp! parameter 
#1 parameter #n caller'sfp caller'sap caller'spc caller'scc  (stackgrowsdown) Figure1:JAMstackonentrytoafunction 
 InJAM,tailcallsarecomplicatedbythefactthatthefour­wordcontinuationframeispushedaftertheparametersin­steadofbefore.Sincethecontinuationframeisadjacentto 
theparameterarea,itmustberelocatedwheneverthereis atailcallandthecallerandcalleehavediferentnumber ofparameters.Atatailcall,theJAMemulatorcopiesthe 
frameintotemporaryvariables,thencopiestheoutgoing parametersfromthebottomofthestacktotheparameter area,andthen(ifnecessary)movesthecopybacktothe 
stack.2 Exceptionhandlingisimplementedbydynamictracking[3]. Onentrytoaprotectedcodeblock,a2-wordcatchframeis 
pushedontothestack,containingapointertotheprevious catchframeandtheaddressofthefrstinstructionafter theprotectedblock.Theaddressofthisframeissavedin 
thePCB.Toraiseanexception,thestackisunwoundone call-frameatatime,untiltheactivationrecordcontaining thecurrentcatchframeisfound.Theunwindingprocess 
simultaneouslyrestoresthesp,fp,ap,andccregisters.  3.2 Processes and memory management AnErlangnodeisaninstanceoftheErlangruntimesystem 
executingonagivenmachine.OnUnix,thisisasingle Unixprocess.Withinanode,Erlangprocessesarecreated dynamicallyandexecuteascoroutines.ACprocedureacts 
asscheduler,continuouslyselectingarunnableprocessand passingittotheemulatorforexecution. EachErlangprocesshasaPCB,astack,andaprivateheap 
forthedatastructuresitcreates.AnErlangprocessstarts withsmallstackandheapareas,whicharegrownwhen needed.ComparedtoatypicalimplementationofPosix 
threadsinUnix,whichwouldallocateintheorderofone megabyteofvirtualmemoryforeachthread'sstack,Erlang 2Performancecouldbeimprovedbyshrinkingtheframeto 
aminimum:apisredundantandcccanbecomputedfrom pcwhenneeded.Ifthecontinuationwaspushedbeforethe parameters,itcouldremaininplaceduringtailcalls[7, 
Section4.6.1]. processesareextremelylightweight.AnErlangnodeisex­pectedtohandlehundredsorthousandsofErlangprocesses 
withrelativeease. Thegarbagecollectorisofastandardtwo-generationalstop­and-copytype[16].Itdoes,however,haveoneinterest­ingdesignfeature:eachprocess'heapisstrictlyprivateto 
thatprocess,andnoreferencesareallowedfromonepro­cesstoanother'sheap.Theadvantageofthisarrangement isthatitsimplifesmemorymanagement.Sincereferences 
fromotherprocessescannotoccur,garbagecollectionisa strictlylocalactivity,andwhenaprocessterminates,its 
memorycanbereclaimedimmediately.Thisisbelievedto reducetotalmemorymanagementcosts,sincethemajor­ityofErlangprocessesareexpectedtobeshort-livedorto 
havesmallamountsoflivedata.Thedisadvantage,how­ever,isthatmessagepassingmustbeimplementedbydata copying,whichreducessharingandincreasesthepressure 
onthememorycaches.3Messagesareexpectedtobesmall, however.  4. HIPE: SYSTEM OVERVIEW TheHiPEcompileriscalledasanordinaryErlangfunction, 
withinarunningErlangsystem.Thesmallestunitofcom­pilationisafunction:giventhenameofanexistingErlang function,thecompilertranslatesthatfunction'sJAMbyte­codestoSPARCV9machinecode,andthenalinkingphase 
updatesthesystemstatesothatfuturecallsinvokethena­tivecode;seeSection4.2.Inthisrespect,HiPEresemblesa 
(user-invoked)JITcompiler.Alternatively,theHiPEcom­pilercancompileawholeErlangmodule,andtheresultof thecompilationcanbesavedinafle,assymbolicSPARC 
code.ThisflecanlaterbeloadedexplicitlyintotheHiPE system. SomeErlangapplicationsaredeliveredonlyinbytecodefor­matandnosourcesareavailable.Forexample,beforeEr­langbecameopen-source,Erlanglibrarieswereonlypresent 
asJAMbytecodefles.Therefore,HiPEwasdesignedtobe abletotakealready-loadedfunctionsinJAMbytecodefor­matinsteadofErlangsourcecodeasinput.Althoughthis 
meansthatHiPEcannotperformsomehigh-leveloptimiza­tions,thiscompilationschemeofersmorefreedomtoits users:usershavethepossibilitytoidentify(usingHiPE's 
proflingtools)thosefunctionsandcallpathsthatwould beneftmostfromcompilationtonativecodeandselectively 
compilethem.Thisway,HiPEcombinestheperformanceof anativecodesystemwiththecodecompactnessofabyte­codesystem.Thisintegrationisverytight:codecompiled 
byHiPEusesthesameruntimesystemandthesamebuilt-in functionsastheJAMemulator. 4.1 The HiPE compiler Thecompilerhasfourintermediaterepresentations:anin­ternalrepresentationofJAMbytecode,ahighlevelinterme­diatelanguage(ICode),ageneralregistertransferlanguage 
(RTL),andamachine-specifcassemblylanguage,currently Weplanningtosubsystemperfor­ only SPARC; see Figure 
2.ICode, RTL, and SPARC a r e represent e d a s c on trol fow graphs of basic blocks. 3 aremeasurememorymancebyimplementingashared-heapruntimesystemand 
comparingitagainstthecurrentruntimesystem.  Memory  Erlang Run-Time System HiPE Compiler Figure2:IntermediaterepresentationsinHiPE. 
TheJAMbytecodesaretranslatedtosymbolicformbya straightforwardprocess.Internalatomnumbersarecon­vertedtorealatoms,andbranchestolocalfunctionsare 
translatedtocallinstructionswithsymbolicfunctionnames. ICodeisbasedonaregister-orientedvirtualmachinefor 
Erlang.Argumentsandtemporariesarelocatedinanin­fnitenumberofregisters,andallvaluesareproperErlang terms.Thecallstackisimplicit,andcallspreserveregis­ters.Bookkeepingoperations,suchasheapoverfowchecks, 
contextswitching,andtime-slicedecrements,areimplicit. ThetranslationfromJAMbytecodetoICodeusesasimu­latedstacktomapJAMstackslotstoICoderegisters.To 
simplifydependencyanalysisinlatercompilationpasses,a renamingpost-passensuresthatindependentliverangesuse 
diferentregisters. TheICodeisthenoptimisedwithstandardcompileropti­mizationssuchascopyandconstantpropagation,andcon­stantfolding.Thisisdoneinonepassoverallextended 
basicblocks.Deadcoderemovalisthenperformedtore­moveassignmentstodeadtemporaries. UnreachablecodeisremovedbythetranslationtoRTL, 
sinceonlyreachablebasicblocksareinsertedintheRTL controlfowgraph.OperationsonErlangvaluesareex­pandedtomakedatatagginganduntaggingexplicit. 
TheoptimisationsthatwereperformedonICodeareapplied againtotheRTLcode.Heapoverfowtests,callstackman­agement,andthesavingandrestoringofregistersaround 
callsaremadeexplicit,andthestandardoptimisationsare appliedagain.Inordertolimitthenumberofheapoverfow 
tests,theyarepropagatedbackwardsasfaraspossible,and adjacenttestsaremerged. TheRTLcodethenistranslatedtoabstractSPARCcode, 
andregistersareassignedusingagraph-colouringregister allocatorsimilartotheoneofBriggsetal.[6].Finally, 
symbolicreferencestoatomsandfunctionsarereplacedby theirvaluesintherunningsystem,memoryisallocatedfor 
thecode,andthecodeislinkedintothesystem. 4.2 The HiPE linker Asdescribedbefore,Erlangrequirestheabilitytoupgrade 
codeatruntime,withoutafectingprocessescurrentlyexe­cutingtheoldversionofthatcode. TheJAMsystemmaintainsaglobaltableofallloadedmod­ules.Eachmoduledescriptorcontainsaname,alistof 
exportedfunctions,andthelocationsofitscurrentandpre­viouscodesegments.Theexportedfunctionsalwaysrefer 
tothecurrentcodesegment.Ataremotefunctioncall, module:function(parameters:::),theJAMemulatorfrst performsalookupbasedonmoduleandfunctionname.If 
thefunctionisfound,theemulatorstartsexecutingitsbyte­codes.Otherwise,anerrorhandlerisinvoked. Innativecode,eachfunctioncallisadirectmachine-level 
calltoanabsoluteaddress.Whenthecaller'scodeisbeing linked,thelinkerinitialisesthecalltodirectlyinvokethe 
callee.Ifthecalleehasnotyetbeenloaded,thelinkerwill insteaddirectthecalltoastubwhichperformstheappropri­ateerrorhandling.Ifthecalleeexists,butonlyasemulated 
bytecode,thelinkerdirectsthecalltoastubwhichinturn willinvoketheJAMemulator. Inordertohandlehot-codeloadinganddynamiccompila­tionatruntime,thelinkeralsomaintainsinformationabout 
allcallsitesinnativecode.Thisinformationisusedfor dynamiccodepatching,asfollows: .Whenamoduleisupdatedwithanewversionofthe 
emulatedcode,allremotefunctioncallsfromnative codetothatmodulearelocated.Thesecallsitesare thenpatchedtocallthenewemulatedcode,vianew 
native-to-emulatedcodestubs. .Whenanemulatedfunctioniscompiledtonativecode, eachnativecodecallsitewhichreferstothisfunction 
ispatchedtocallthenewnativecode.Thefrstin­structioninthebytecodeisalsoreplacedbyanew instructionwhichwillcausethenativecodeversionto 
beinvoked.Finally,thenative-to-emulatedstubused toinvokeitfromnativecodeisdeallocated. .Whenamoduleisunloadedanditsmemoryisfreed, 
allnativecodecallsitesreferringtothismoduleare patchedtoinsteadinvokeanerrorhandlingstub.All nativecodecallsiteswithinthisnownon-existentmod­ulearealsoremovedfromthelinker'sdatastructures, 
topreventfutureattemptstoupdatethem. BoththestandardErlangsystemandHiPEsupportload­on-demandofmodules.Wheninvoked,theerrorhandler 
forundefnedfunctioncallswillattempttoloadtheJAM bytecodesforthatmodulefromtheflesystem.Ifthisis successful,thecallcontinuesasnormal.Asaside-efectof 
loadingtheJAMmodule,theHiPElinkerwillpatchnative codecallsitesasdescribedabove. 4.3 Native code calling 
conventions IntheHiPEruntimesystem,anErlangprocesscanexecute bothemulatedJAMcodeandnativeSPARCcode.Tofacil­itatedatasharing,HiPEusesthesamedatarepresentation 
asJAM.However,theJAMcallingconventionisinappropri­atefornativecode,sinceJAMpassesallparametersonthe stackanduseslargecallframescontainingredundantinfor­mation.Instead,nativecodepassesthereturnaddressand 
thefrstfveparametersinregisters,remainingparameters (ifany)onthenativestack,andshrinksthefxedportion 
ofstackframestoasinglewordforpreservingtheprevious returnaddress.Currently,HiPEdoesnotusetheSPARC's registerwindows;instead,registersaresavedandrestored 
asneededaroundfunctioncalls. HiPEusestwostacksforeachprocess,oneforemulated code(theestack)andonefornativecode(thenstack).An 
earlierversionofHiPEusedonlyonestack,butthatscheme wasquicklyabandonedasitwasfoundtobequitecomplex anddifculttoimplementcorrectly.Ourcurrentdual-stack 
approachhasdisadvantagesandadvantagestoo: ;AsdescribedinSection3.1.3,theJAMemulatorim­plementsexceptionhandlingbycreatingalinkedlistof 
catchframesonthestack.Nativecodeusesthesame strategy,whichmeansthateachstackmaycontain pointerstotheother.Iftheruntimesystemrelocates 
onestack(toincreaseitssize),thentheotherstack mustbetraversedsothatthecatchframelinkscanbe updated. +Byseparatingthestacksthestack-scanningcodeinthe 
garbagecollectoriskeptsimple.Withasingle-stack approach,thescanningcodewouldhavetoknowwhen toswitch\mode",inordertocorrectlydealwiththe 
diferentstackframelayouts.Thisiscertainlydoable, butwouldrequiremoreeforttoimplementcorrectly. Foreign 
Function Interface ErlangprogramscanandoftendocallCfunctions:standard procedures(BIFs)intheruntimesystemarewritteninC,as 
aretheI/Omodules.ForeachBIF,thereisamachine-code stubwhichisdirectlycallablefromnativecode.Thestub takescareofsavingthenative-codestateregistersbefore 
invokingtheCfunctionontheCstack.Thestubalsochecks forexceptionsatreturn,andeitherreturnstoitscalleror 
invokesthecurrentErlangexceptionhandler. However,theErlangruntimesystemisnotdesignedtoper­mitarbitraryrecursivecallsbetweenErlangandCfunc­tions.WhethertheErlangcodeisemulatedornativemakes 
nodiference.Adetailedexplanationisbeyondthescopeof thispaper,butthelimitationstemsmainlyfromthenon­reentrancyoftheErlangprocessscheduler(aCfunction) 
andthewayinwhichtheruntimesystemperiodicallypolls I/Ochannels.(Itwouldnotbeoverlydifculttomodifythe runtimesystemtoeliminatethislimitation,however.) 
 4.4 Mode-switching InHiPE,amode-switchoccurswheneverthereisatrans­ferofcontrolfromnativecodetoemulatedcode,orvice­versa.Wemadethedesigndecisionthatthemerepresence 
ofmultipleexecutionmodesshouldnotimposeanyruntime overheads,aslongasnomode-switchesoccur.Thisdesign requirementcallsforgreatcarewhenimplementingmode­switches,notonlyforperformance,butalsoforcorrectness. 
4.4.1 Where do switches occur? SinceHiPEcompilesindividualfunctionstonativecode,a mode-switchmustoccurwheneverthereisafowofcontrol 
fromonefunctiontoanother,andthetwofunctionsare indiferentmodes.Thus,mode-switchesoccuratcalland returnsites.Erlang'sexceptionmechanismalsointroduces 
mode-switches,viz.whenanexceptionisthrownfromcode executinginonemode,andthemostrecentcatchhandler isinadiferentmode.Wewillrefertothesecasesascall, 
return,andthrowevents,respectively. 4.4.2 When do switches occur? Howdoesthesystemdiscoverthataparticularinstanceof 
acall,return,orthroweventmustperformamode-switch? Call Events OlderLispsystemsoftenuseadynamictestatcallstode­terminethemodeofthecallee(e.g.compiledoremulated), 
andthenperformtheappropriateaction. Anothercommonchoiceistouseafxedmodeforcalls, usuallynativecode.Emulatedfunctionsarerepresentedas 
smallnativecodestubswhichinvoketheemulatorwhen called.Theadvantageofthisapproachisthatnodynamic typetestisneededwhenbothcallerandcalleeareinnative 
code.Thedisadvantageisthatcallsbetweenemulated-mode functionsarepenalisedsincetheyhavetomakeconversions 
toandfromthenative-codecallingconventions. HiPEusesapseudo-staticapproachinwhichcallsalways usethemodeofthecaller.AsdescribedinSection4.2,if 
anative-codecallerreferstoanemulated-modecallee,then thelinkerredirectsthecallinstructiontoinsteadinvokea 
native-codestub,whichinturncausesaswitchtoemulated mode.Ifanemulatedfunctioniscompiledtonativecode, thenthestartoftheoriginalbytecodesisoverwrittenwitha 
specialemulatorinstructionwhichcausesaswitchtonative mode.(Theasymmetrybetweenthesecasesisduetothe factthattheHiPElinkeronlyhasknowledgeaboutcallsites 
innativecode.) Return Events Wheneverarecursivefunctioncallcausesamode-switch, thereturnsequencemustbeaugmentedtoperformthein­versemode-switch.Likecalls,thisisoftenimplementedby 
dynamictests,afxed-modeconvention,orbysame-mode stubs. Ifdynamictestsareused,thenthereturnaddressistagged 
toindicatethatamode-switchisrequiredwhenthecallee returns.Typically,eitherthelowestorthehighestbitis 
used.Thelowestbitisavailableifreturnaddressesare alignedonsome>1boundary.Usingthehighestbit 2iimposesalimittotheusableaddressspace. 
Ifafxed-modeconventionisusedforcalls,thenthesame modeisalsousedforreturns.Ifthatmodeisnativecode, thenacallfromanemulated-modefunctionmustpusha 
\stub"native-modereturnaddresswhichcausescontrolto fowbackintotheemulator. HiPEusesasame-modeconventionforreturns.Whenacall 
causesamodeswitch,anewcontinuation(stackframe)is createdinthemodeofthecallee.Thereturnaddressin thiscontinuationpointstocodewhichcausesaswitchback 
tothecaller'smode.Forreturnsfromnativetoemulated code,thereturnaddresspointstomachinecodeintherun­timesystem.Forreturnsfromemulatedtonativecode,the 
returnaddresspointstoaspecialemulatorinstruction.We madethischoiceinHiPEbecauseitcausesnooverheadex­ceptduringmode-switches,anditminimisedtheamountof 
changeswehadtomadetotheexistingJAMemulator. Throw Events HiPEdealswithexceptionthrowsinthesamewayasitdeals 
withfunctionreturns:asame-modeconventionaugmented withmode-switchingstackframes.Whenacallcausesa mode-switch,anewexceptioncatchframeiscreatedinthe 
modeofthecallee.Thehandleraddressinthiscatchframe pointstocodewhichswitchesbacktothecaller'smode, andthenre-throwstheexception.Thus,whenacallcauses 
amode-switch,twoframesarepushed:frstacatchframe, thenareturnframe.Thecodeatthereturnaddressinthe returnframeknowsthatitalsohastoremovethecatch 
framebeneathitbeforeswitchingmode. 4.4.3 Maintaining tail-recursion Thesame-modecallingconventionwithmode-switchstack 
framesisefcientandeasytoimplement.Formanypro­gramminglanguages,thiswouldbeenough.However,like mostotherfunctionalprogramminglanguages,Erlangrelies 
ontail-recursivefunctioncallsforexpressingiteration.Con­siderthefollowingsequenceoftailcalls,whereeachisan 
fe iemulatedfunction,andeachjisanativecodefunction: fn tailtailtailtail fe fn fe fn 1!2!3!4! AcorrectimplementationofErlangisexpectedtoexecute 
suchasequenceinboundedstackspace,regardlessofits length.Unfortunately,ateachcall,anewmode-switch stackframeispushed,tomakethereturnperformthein­versemode-switch.Thus,stackspaceusagewillgrowlin­earlywiththelengthofthesequenceoftailcalls,andtail­recursionoptimisationislost. 
HiPEsolvesthisproblemasfollows.Thereturnaddressina mode-switchstackframewillalwayshaveaknownvalue:ei­thertheaddressofthereturnmode-switchroutine(innative 
mode),ortheaddressofthereturnmode-switchinstruction (inemulatedmode).Thus,asimpleruntimetestisable todistinguishmode-switchstackframesfromnormalstack 
frames.Now,considerthefollowingcallsequence: ntail fehe !g! fe Whencallsg n ,itpushestwomode-switchframesonthe 
native-codestack:frstacatchframe,thenareturnframe. Wheng ntailcalls,thesystemwouldnormallypushtwo he 
newmode-switchframes,ontheemulated-codestack.In­stead,HiPEimplementsamode-switchcalleventasfollows: 1.ifthecurrentreturnframeisamode-switchframe, 
then (a)removethemode-switchreturnframefromthe caller'sstack (b)removethemode-switchcatchframefromthe 
caller'sstack (c)invokethecallee; otherwise 2.pushamode-switchcatchframeonthecallee'sstack 3.pushamode-switchreturnframeonthecallee'sstack 
4.invokethecallee Bypreventingadjacentmode-switchframesfrombeingcre­ated,thetestrestorespropertail-recursivebehaviour.The 
testitselfisnotexpensive,andisonlyexecutedwhenthere isamode-switchcall.Thisimplementationrefutesastate­mentin[9,Section4.4.3],whereitwasclaimedthatthe 
useofmode-switchstackframeslosestail-recursionopti­misation.Althoughsimilarmethodstomaintainingproper 
tail-recursioninthecontextofmixedmodeexecutionhave beenusedinsomePrologimplementations(e.g.BIMPro­log,SICStusProlog)andperhapselsewhere,thesemethods 
areprobablyfolklore:tothebestofourknowledge,they haveneverbeeninprint. 4.4.4 Mode-switching in suspend/resume 
events Inadditiontothecall,return,andthroweventsdescribed above,HiPEmayalsoneedtoperformmode-switcheswhen 
aprocessissuspendedorresumed. TheschedulerintheErlangruntimesystemhasnoknowl­edgeaboutthecurrentmodeofaprocess.Itassumes,im­plicitly,thateachprocessisexecutedbytheJAMemulator. 
Therefore,whenaprocessiscreatedorresumed,thesched­ulersimplypassestheprocess'PCBtotheJAMemulator forexecution. 
Whenaprocessissuspendedwhileexecutinginnativecode, HiPEsetstheresumeaddressinthePCBtopointtoa specialemulatorinstruction.Whentheschedulerresumes 
theprocess,theJAMemulatorexecutesthisinstruction, whichtransferscontroltothesuspendednativecode.  4.5 
Modi.cations to the JAM emulator AsdescribedinSections4.2{4.4,wehavemodifedtheJAM emulatortosupportmixingnativeandemulatedcode.In 
summary,thesemodifcationsare: .TheJAMloaderregistersthelocationofeachfunc­tion'sbytecodeswiththeHiPElinker. 
.Anative-codestackhasbeenaddedtothePCB,to­getherwithafewnative-codevariables(stackpointer, resumeaddress). 
.Thegarbagecollectorhasbeenextendedtoscanthe native-codestack,andtorepaircatchframelinkswhen eitherstackisrelocated. 
.Asmallnumberofinstructionshavebeenaddedtothe JAMemulator,tosupportmode-switchingbetween emulatedandnativecode. 
ApreviousversionofHiPEuseddynamictestsinthe JAMemulatorinstead.Ateachcall,acheckwasmade ifthetargetalsohadanative-codeversion,andat 
eachreturn,throw,andresume,acheckwasmadeif thereturnaddresswaszero,whichwasinterpretedas asignaltoswitchmode.Thatdesignrequiredchanges 
tomanydiferentlocationsintheemulator,compli­catedthemode-switchstackframemanagement,im­posedruntimeoverheadsonemulatedcode,andwas 
generallyuglyanddifculttomaintain. Incontrast,ourcurrentdesignrequiresonlyasmall localisedextensionoftheemulator,andimposesno 
runtimeoverheadsexceptduringmode-switches.  4.6 Performance instrumentation features Tosupportperformanceanalysisandbenchmarking,andto 
helpusersidentifywhichpartsoftheircodecouldbeneft mostfromcompilationtonativecode,wehaveaddedtwo kindsofperformanceinstrumentationfeaturestoHiPE's 
runtimesystem:softwareeventcountersandhardwareper­formancecounters. Thesoftwareeventcounterskeeptrackofhowoftenvarious 
interestingoperationsareperformed.Theseinclude:the numberoftimeseachErlangfunctioniscalled,thenumber 
oftimeseachbuilt-inlibraryfunctioniscalled,howmany timeseachJAMinstructionisexecuted,andhowmany timescontrolispassedbetweenemulatedandnativecode. 
Thehardwareperformancecountersareeventcountersin­sidetheUltraSPARCprocessor 4 .Theyareusedtomeasure thenumberofclockcyclesspentincoderegions,andtopro­videhardware-specifcinformation,forexampletheamount 
oftimelostduetostallsandcachemisses.Thereasonfor astallcanalsobedetermined:datacachemiss,instruction 
cachemiss,externalcachemiss,orabranchmisprediction. Formoredetailsontheinstrumentationfacilities,thereader 
isreferredto[14]. 5. PERFORMANCE EVALUATION Weconductedourperformancecomparisonona143MHz single-processorSunUltraSPARC1/140with128MBofpri­marymemoryrunningSolaris2.6.Althoughslowbytoday's 
standards,thismachinewasusedbecausewecouldensure itwaslightlyloadedduringthebenchmarkruns,andithad enableduser-levelaccesstotheUltraSPARC'sperformance 
instrumentationfacilities[22].Thelatterwasneededfor theperformanceresultspresentedinthefollowingsection. 
WhenusingHiPE,allfunctionsactuallycalledinthepro­gramswerecompiledtonativecode. 5.1 Erlang systems used 
in the comparison BesidesHiPE(version0.90),threeotherErlangsystems wereusedinthiscomparison:JAM,BEAM,andEtos.The 
JAMandBEAMsystemsusedinourmeasurementsare fromEricsson'sErlang47.4.1(uponwhichHiPE0.90is based).TheversionofEtosusedis2.3.5WedescribeBEAM 
4Manymodernprocessorshavehardwareperformancecoun­ters,althoughtheirfunctionalityandthelevelofOSsupport 
varies. 5VersionsofEtos&#38;HiPEusedin[8]aresignifcantlyolder thanthoseusedhere. andEtosbelow;HiPEandJAMhavebeenfullydescribed 
earlierinthispaper. BEAM TheBEAM[12]isaregister-basedabstractmachine,infu­encedbytheWarrenAbstractMachine(WAM)[26]used 
inmanyPrologimplementations.ComparedtoJAM,the translationofErlangcodetoBEAMabstractmachinein­structionsismoreadvanced.Forexample,thetreatment 
ofpatternmatchingisbetterintheBEAMsystem,even thoughafullpatternmatchcompiler(likethatine.g.[20]) isnotimplemented.Also,BEAMusesadirect-threaded 
emulator[4,17]usinggcc'sfrst-classlabelsextension[21]: instructionsintheabstractmachinecodeareaddressesto 
thepartoftheemulatorthatimplementtheinstruction. Etos Etos,describedin[8],isasystembasedontheGambit-C 
Schemecompiler.IttranslatesErlangfunctionstoScheme functionswhicharethencompiledtoC.Thetranslation fromErlangtoSchemeisfairlydirect.Thus,takingad­vantagesofthesimilaritiesofthetwolanguages,manyop­timizationsinGambit-CareefectivewhencompilingEr­langcode.Amongtheseoptimizationsareinliningoffunc­tioncalls(currentlyonlywithinasinglemodule)andun­boxingoffoating-pointtemporaries.Etosalsoperforms 
someoptimizationsinitsErlangtoSchemetranslation,for example,simplifcationofpattern-matching.Processsus­pensioninEtosisdoneusingcall/ccimplementedusing 
alazycopyingstrategy;see[13].Whenaprocessissus­pended,thestackis\frozen"sothatnoframecurrently onthestackcanbedeallocated.Whencontrolreturns 
toasuspendedprocess,itsstackframesarecopiedtothe topofthestack.Whenthestackoverfows,thegarbage collectormovesallreachableframesfromthestacktothe 
heap.Ingeneral,suspendingandresumingaprocesswill requireitsstacktobecopiedatleastonce.Incontrast, theJAM/BEAM/HiPEruntimesystemshandleprocesses 
explicitly;savingorrestoringthestateofaprocessinvolves storingorloadingonlyasmallnumberofregisters.The 
Etoscompilerisworkunderprogress,anditisnotyetafull Erlangimplementation.Wehavethereforebeenabletorun 
onlyrelativelysmallbenchmarksonEtos.  5.2 Time on benchmark programs Westartourperformancecomparisonusingthefollowingset 
of\standard"smallsequentialbenchmarksalsousedin[8]: fbArecursiveFibonaccifunction.Calculatesfib(30)50 
times. hufHufmanencoder.Compressesanduncompressesa shortstring5000times. lengthAtail-recursivelistlengthfunctionfndingthelength 
ofa2000elementlist100,000times. nrevNaivereverseofa100elementlist20,000times. qsortOrdinaryquicksort.Sortsashortlist50,000times. 
smithTheSmith-WatermanDNAsequencematchingalgo­ rithm.Matchesonesequenceagainst100others;allof length32.Thisisdone30times. 
Benchmark HiPE Etos JAM BEAM fb huf lengthnrev qsortsmithtak 33.811.922.718.512.311.413.5 31.812.117.224.411.011.612.8 
281.4234.7375.6241.3208.1114.6140.1 120.6 69.2 98.9 56.9 97.6 53.9 100.2 decode 22.8 52.4 67.8 49.0 
Table1:Times(insecs)forsmallsequentialbench­marks. takTakeuchifunction,usesrecursionandintegerarithmetic 
intensely.Calculatestak(18,12,6)1000times. andamedium-sizedone(.400lines): decodePartofatelecommunicationsprotocol.Decodesan 
incomingbinarymessage500,000times. Table1containstheresultsofthecomparison.Inallbench­marks,HiPEandEtosarethefastestsystems:insmallpro­gramstheyarebetween7to20timesfasterthanJAMand 
3to8timesfasterthantheBEAMimplementation;seealso Figure3.ExcludinglengthandnrevwhereHiPEandEtos showcomplementarybehaviour,theperformancediference 
betweenthesetwosystemsonsmallprogramsisnotsignif-cant.Indecode,whereitisprobablymoredifcultforEtos tooptimizeoperationsandpatternmatchingonbinaryob­jects(i.e.onimmutablesequencesofbinarydata),HiPEis 
morethan2timesfasterthanEtos.HiPEisfasterthan JAMandBEAM,butnottothesameextentasforthe otherbenchmarks. 
 HiPE 20  Figure3:SpeedupcomparedtoJAMforsmall benchmarks. Next,wecomparetheErlangimplementationsonconcur­rentprograms.Asmentionedintheintroduction,mostEr­langprogramsrelyheavilyontheconcurrencyprimitivesof 
thelanguage.Thus,theseprogramscallforspecialattention ingoodErlangimplementations.Thebenchmarkprograms 
weusedare: ringCreatesaringof10processesandsends100,000mes­sages.Thebenchmarkisexecuted100times. Benchmark 
HiPE Etos JAM BEAM ring stablelife 37.112.85.6 76.027.920.1 101.637.813.4 72.5 19.5 8.7 Program HiPE 
JAM BEAM JAMCompiler 5.4 17.2 5.9 Eddie 18.8 93.6 40.0 AXD/SCCT 68.0 109.9 84.5 Table2:Times(insecs)forsmallconcurrentbench­marks. 
stableSolvesthestablemarriageproblemfor10menand 10women5000times. lifeExecutes1000generationsinConway'sgameoflifeon 
a10by10boardwhereeachsquareisimplementedas aprocess. Table2containstheresultsofthecomparison.Onceagain, 
HiPEisthefastestsystem:itisaround2.5timesfaster thanJAM,55%fasterthanBEAM(95%onring),justover 2timesfasterthanEtosonringandstableandmorethan 
3.5timesonthelifebenchmark;seealsoFigure4.Infact, Etos2.3doesnotseemtobesignifcantlyfasterthanJAM andisslowerthanBEAMwhenprocessesenterthepicture. 
WesuspectthatEtos'implementationofconcurrencyvia call/ccisnotveryefcient. 3 Table3:Executiontimes(inseconds)forlargepro­grams. 
ATMswitchsetsupandtearsdownanumberofcon­nections100times;501functionsareusedinthebench­markwhichamountto15%ofthecode.There­mainingcodeprovidesotherATMservicesorhandles 
errorsthatcanoccurinpractice(butnotduringthe benchmarkrun!).Thesepartswerenotcompiledto nativecode. Table3showstheresultsofthiscomparison.6HiPEisonce 
againthefastestsystem.However,aswemovefrombench­markstoreal-worldapplicationsofErlang,programstend tospendmoreandmoreoftheirexecutiontimeinbuilt-ins 
fromthestandardlibrary.Forexample,theAXD/SCCT programextensivelyusesthebuilt-instoaccesstheshared databaseontopoftheErlangtermstorage;seethedata 
presentedintheSection6andin[14].  islessthanbefore.Still,HiPEis24%fasterthanBEAM onthelargestbenchmark,andconsiderablyfasterthanthe 
1 JAMimplementationonwhichitisbased;seealsoFigure5. 5 Astheimplementationofthesebuilt-insiscurrentlyshared 
byallthreesystems,thepercentageofexecutionspentin Speedup compared to JAM thesebuiltinsbecomesabottleneckandHiPE'sspeedup 
2  0 Ring Life Stable 4 Speedup over JAM 3 2 1 Figure4:Performancespeedupforconcurrent benchmarks. 
 5.3 Time on real programs Tous,itwasveryunclearwhetherperformanceexperiences gatheredfromthestudyofsmallormedium-sizedbench­marksareapplicabletoreal-lifeapplicationsofErlang.We 
thusalsocomparedtheperformanceofHiPEonquitelarge Erlangprograms.Theprogramsusedinthisendeavour were: 
JAMCompilerThis\application"isincestuous,butlarge nevertheless.Theusedportionofthecompilerconsists of30modulestotalling18.000linesofErlangcode. 
Thebenchmarkistocompile11ofthesemodulesusing theJAMcompilercompiledineachofthesystems. EddieAnHTTPparserwhichhandles30complexhttp-get 
requests.ExcludingtheOTPlibrariesused,itconsists of6modulesforatotalof1,882linesofErlangcode. Thebenchmarkisexecuted1,000times. 
AXD/SCCTThisisthetime-criticalsoftwarepartofthe AXD301switchmentionedintheintroduction.Not countingstandardlibraries,itconsistsofabout95,000 
linesofErlangcode.Thisactualbenchmarkofthe 0 Figure5:Performancespeedupforlargeprograms. 5.4 Code size 
Duringbenchmarking,allcalledfunctionsofprogramswere compiledtonativecode.Thismakesperfectsenseinsmall 
programsbutmightnotbethebestapproachinallcases. Asmentioned,usersofHiPEcanselectivelycompiletime­criticalpartsoftheirapplicationstonativecodeanduse 
theemulatorfortheremainingparts.Still,HiPE'sspace overheadisnotprohibitiveandcompilationofwholeappli­cationstonativecodeisavalidoption. 
Table4providessomeevidencetothatefect.ForJAM, BEAM,andHiPEitpresentsthesize(inbytes)oftheloaded codethatisusedbythebenchmarksinthissection.Inall 
casesbutAXD/SCCTallfunctionsofloadedmodulesare 6Etosisnotincludedhere;itcurrentlycannothandlethese largeprograms. 
Program JAM BEAM HiPE Etosy fb 616 1937 4080 17808 huf 2530 7691 38728 90744 length 678 2085 4400 22424 
nrev 750 2145 4932 24444 qsort 850 3049 6308 24784 smith 1416 4709 13616 71760 tak 656 2057 4712 23684 
decode 1933 8641 14012 100132 ring 784 2737 6920 29380 life 1400 5069 15280 63772 stable 1299 4701 14008 
59264 Eddie 21717 81075 170308 N/A AXD/SCCT 83370 | 244936 N/A Table4:Code-size(inbytes)fortheprogramsused. 
usedinthebenchmark;inAXD/SCCTonlyafractionofthe functionsisused.AstheBEAM-basedErlangsystemdoes notprovideanymeansofobtainingthesizeofindividual 
functions(onlyofwholemodules),wecouldnotreportthe correspondingnumberforBEAM.Forsmallprograms,the codesizeincreaseofHiPEcomparedtoJAMisbetween 
7to15times.ComparedtoBEAM,HiPErequires2to3 timesmorecodespace(excludinghuf).Inlargeprograms, thespaceoverheadisonthelowend;seee.gAXD/SCCT. 
Forcomparison,wealsopresentthesizesofstripped.o1 flesproducedbytheEtoscompiler;theyarequitebigpartly 
duetotheaggressiveinliningperformedbyEtos2.3.Itis notcleartoustowhatextentEtosbeneftsfromitsuseof inlining.NotethatthecodesizereportedforEtosmight 
diferslightlyfromthecodesizeoftheseprogramswhen loaded;however,notbymuch.Table4denotesthisbyay. 5.5 
Erlang vs. other functional languages WehavecomparedtheperformanceofHiPEwiththatof severalotherfunctionallanguageimplementations(Bigloo 
2.1c,CMLfromSML/NJ110.0.6,CLEAN1.3.2)onafew smallbenchmarks(versionsoftheqsort,fb,huf,andring benchmarksdescribedpreviously). 
Onthesmallsequentialbenchmarks,CLEANwasconsis­tentlythefastestsystem.Theotherthreesystemsshowed considerablevarianceintheirperformance,withnoclear 
winner.ComparedtoCLEAN,CMLwasfrom1.75to4.4 timesslower,Bigloo1.33to13timesslower,andHiPE1.88 to14.8timesslower.HiPEandBigloohadcomparableper­formance,exceptonqsortwhereHiPEwasmorethantwice 
asfast.Ontheconcurrentringbenchmark,HiPEwas1.3 timesslowerthanCML,whiletheJAMemulatorwas1.7 timesslowerthanCML. 
See[15]forfurtherdetailsaboutthiscomparison.  6. MORE DETAILED MEASUREMENTS ToshedmorelightonHiPE'sperformancecharacteristics 
comparedtotheothertwoErlangsystemsfromEricsson, wepresentsomeadditionalmeasurementsonthreebench­marksofdiferentsizes:length,Eddie,andAXD/SCCT. 
Thesemeasurementswereobtainedbyenablingtheperfor­manceinstrumentationfeaturesofthethreesystems(see Section4.6)duringtheirinstallation;thisexplainsslight 
mismatcheswithperformancenumbersreportedinthepre­vioussection.Amorethoroughanalysisandcomparisonof thesesystemscanbefoundin[14]. 
lengthisasmallsequentialbenchmarkconsistingoftwo nestedloops,onethattraversesalistandonethat iteratesanumberoftimes. 
OnthisbenchmarkHiPEis16timesfasterthanJAM andover3timesfasterthanBEAM;seeTable5.The byte-codeemulationoverheadisevidentinthisbench­markwhereHiPEexecutesonly6millionSPARCin­structionswhileJAMandBEAMexecute49and10 
millioninstructionsrespectively.JAMandBEAMalso haveproblems(10%and14%oftheirruntime,respec­tively)withpipelinestallsfrombranchmispredictions; 
seeTable7.Thesametableshowsthatallthreesys­temshavesomeproblemswithloadstalls(avalueis neededbeforeithasbeencompletelyloadedintoareg­ister)butnoneofthesystemssufersfrominstruction 
cachemisses. Eddieisamildlyconcurrent(only5messagesaresent) benchmarkwhichparsesHTTPrequests.Theparser 
consistsoffourmodules,anothertwoareaddedfor thebenchmarkingpurposes,4.7%ofthecallsareto built-inCfunctions,andsomeErlang/OTPstandard 
librariesareheavilyused.Thebenchmarkconsists of159diferentErlangfunctionsthatarecalledatotal of30.000times. 
Onthisbenchmark,HiPEis6.3timesfasterthanJAM andover2timesfasterthanBEAM.Heretheimproved BEAMcompileralmostmakesupfortheemulation 
overhead:BEAMexecutes4millionSPARCinstruc­tionswhichisnotmuchmorethanHiPE's3million andalotlessthanJAM's13million.Allthreesystems 
haveaboutthesamepercentageofpipelinestalls:36% forJAMandHiPE,and37%forBEAM. AXD/SCCTisatimecriticalpartofEricsson'sAXD301 
ATMswitch.SCCTisresponsibleforsettingupand tearingdownconnectionsintheswitch.Thecodewe haveusedisfromversion6ofAXD301,anearlier 
versionthanwhatisusedintheproducttoday.This benchmarkismoreconcurrentthanEddie,withsev­eralprocessesandover3000messagessent.Italso 
usesthebuilt-infunctionsheavily:about32%ofthe executiontimeforJAMisspentinbuilt-ins.Inabso­luteterms,thistimeisthesameinHiPE;inrelative 
terms,itcorrespondsto50%ofHiPE'sexecutiontime andbuilt-insstartbecomingabottleneck.SCCTisa largebenchmark:thetotalsizeofthe501calledfunc­tionsisinnativecode244,936bytes(seealsoTable4). 
JAM BEAM HiPE length 1 4.5 16.1 Eddie 1 2.6 6.3 AXD/SCCT 1 1.4 1.6 Table5:SpeedupsforBEAMandHiPEcompared 
toJAMcalculatedfromthetotalexecutiontimesin clockcycles. Mc Mi CPI length JAMBEAMHiPE 63144 49106 1.30 
1.45 0.70 Eddie JAMBEAMHiPE 1873 1343 1.39 1.54 1.07 AXD/SCCT JAMBEAMHiPE 15311197 1016262 1.52 1.79 
1.56 %L %M %IC %Total length JAMBEAMHiPE 12916 10140 012 22 23 18 Eddie JAMBEAMHiPE 232318 10114 2314 
36 37 36 AXD/SCCT JAMBEAMHiPE 232516 1285 6722 41 40 43 Table6:Measurementsforthebenchmarks.The Mccolumnisroundedaverageexecutiontimesin 
millionofcycles.TheMicolumnistheaverage numberofmillionsexecutedinstructions.TheCPI columnisthenumberofcyclesperinstruction(the 
lowerthebetter). OnthisbenchmarkHiPEisonlyabout1.6timesfaster thanJAMand1.15timesfasterthanBEAM.Here 
theimprovedBEAMcompilercompletelymakesupfor theemulationoverhead.Thisisindicatedbythefact thatBEAMandHiPEbothexecuteabout62million 
SPARCinstructionsonthisbenchmark;seeTable6. Theexecutiontimesinmillionsofclockcycles(Mc)and millionsofexecutedinstructions(Mi)foreachsystemand 
benchmarkareshowninTable6. ThehighspeeduponlengthforHiPEcomparedtoJAMhas tworeasons: 1.Becauseofcompilationtonativecodeandvariousopti­mizations,HiPEexecuteslessthan12%ofthenumber 
ofSPARCinstructionsthatJAMexecutes. 2.Byutilizingthepipelinebetter,HiPEexecutes1.86 timesasmanyinstructionspercycleasJAM. 
Withfewerinstructionsexecutedandbetterpipelineutiliza­tion,HiPEgetsaspeedupof16(8.6*1.86)timesoverJAM; 
thisisshowninTable5. OnEddie,asonlength,HiPEandBEAMexecuteconsid­erablylessinstructionsthanJAM,andHiPEhasalower 
CPIthanJAMandBEAM.Thisbenchmarkusesbuilt­infunctionsandconcurrency.Thistogetherwiththeuse ofdiferenttypesofcallsprobablyisthereasonthatthe 
speedupforHiPEisnotasgreatasitwasonlength.On Eddie,allthreesystemsspendmorethan35%ofthetime stalling,mainlyonloads.HiPEhassignifcantlyhigherin­structioncachestallsthantheothertwosystem,whileJAM 
andBEAMsufermorefrombranchmispredictionstalls;see Table7. Becauseofthelargesizeofthegeneratednativecode,on 
AXD/SCCTtheabsolutenumberofinstructioncachestalls isabouttwiceasmanyforHiPE(22%of97million)asfor JAM(6%of153million).Buttakentogether,thenumberof 
stallsfrommispredictionsandstallsfrominstructioncache missesisaboutthesameforJAMandHiPE.Allthreesys­temsspendabout40%oftheirtotalexecutiontimestalling 
Table7:Percentageoftheexecutiontimespent onthemostcommontypesofpipelinestalls.The column%Lshowsthepercentageofloadstalls, 
%Mshowsthepercentageofbranchmispredic­tionstalls,%ICshowsthepercentageofinstruction cachestalls,and.nallythe%Totalcolumnshowsthe 
totalpercentageofstalls.Allnumbersarebasedon thenumberofexecutedmachinecycles. onthisbenchmark.ThisindicatesthateventhoughHiPE 
runsintoproblemswiththeinstructioncache,HiPEdoes notsufermorefromthisthanJAMorBEAMsuferfrom othertypesofstalls.OnereasonwhyHiPEdoesnotachieve 
thesamespeedupasonsmallerbenchmarksisthatmuchof thetimeisspentincodecurrentlyoutsideHiPE'scontrol, suchasbuilt-infunctionsandgarbagecollection.Ignoring 
thetimespentinbuilt-infunctions,thegarbagecollector, andtheoperatingsystem,HiPEis2timesfasterthanJAM 
onthisbenchmark. 7. CONCLUSIONS AND FUTURE PLANS Thispaperhasdescribedthearchitectureandimplementa­tionofHiPE,anativecodecompilerforErlang.HiPEofers 
fexible,user-controlledintegrationbetweeninterpretedand nativecode,isacompleteimplementationofErlang,and 
supportsfeaturescrucialfortelecommunicationapplications suchasconcurrency,errorhandling,andhot-codeloading. 
Asourperformanceevaluationshows,HiPEisthefastestof currentErlangimplementations. HiPEispubliclyavailableasopen-sourcesinceMarch2000. 
ThecurrentreleaseisbasedonErlang47.4.1.SincetheEr­icssonreleasesofopen-sourceErlangwillexclusivelyusethe 
BEAMimplementationfromnowon,weplantoportHiPE totheBEAMrun-timesystem.AtpresentHiPEonlyruns ononeplatform,theUltraSPARC.Toimprovetheuseful­nessoftheHiPEsystem,wearecurrentlydevelopingacode 
generatorforthex86processorfamily.Wearealsodevelop­inganewfront-endforHiPEsothatcompilationdoesnot necessarilyrelyontheoutcomeofapreviouscompilationto 
JAM(ortoBEAM).Instead,thenewfront-endwillbebased onCoreErlang,7 anintermediaterepresentationforErlang 
developedrecently.SinceCoreErlangisafairlyhigh-level functionallanguage,weexpectthatitshouldbeeasierto 
includeoptimizations,forexampleefcientpattern-match compilation,atthatlevel. Ourbenchmarkresultsindicatethatreal-worldapplications 
spendalargefractionoftheirtimeinbuilt-instandardpro­ 7Seehttp://www.csd.uu.se/projects/hipe/corerl. cedures.Wewillthereforeinvestigatethisissuefurther,and 
extendthescopeofHiPEaccordingly.Thismayrequireim­provingthecompiler,tuningtheruntimesystem,orboth. Acknowledgements 
HiPEhasgreatlybeneftedfromthepriorinvolvementof ChristerJonssonandfromvariousdesigndiscussionswith ThomasLindgren,Sven-OlofNystroom,andRichardCarls­son.Wealsothanksomeanonymousreviewersforcomments 
whichhelpedimprovethepresentationofthispaper.This researchhasbeensupportedinpartbyASTEC(Advanced SoftwareTechnology)competencecenter. 
 8. REFERENCES <RefA>[1]J.Armstrong.ThedevelopmentofErlang.In ProceedingsoftheACMSIGPLANInternational ConferenceonFunctionalProgramming,pages 
196{203,June1997. [2]J.Armstrong,R.Virding,C.Wikstroom,and M.Williams.ConcurrentProgramminginErlang. 
Prentice-Hall,secondedition,1996. [3]T.P.BakerandG.A.Riccardi.ImplementingAda exceptions.IEEESoftware,3(5):42{51,Sept.1986. 
 [4]J.R.Bell.Threadedcode.Communicationsofthe ACM,16(8):370{373,June1973. [5]S.BlauandJ.Rooth.AXD301|Anewgeneration 
ATMswitchingsystem.EricssonReview,75(1):10{17, 1998. [6]P.Briggs,K.D.Cooper,andL.Torczon. Improvementstographcoloringregisterallocation. 
ACMTrans.Prog.Lang.Syst.,16(3):428{455,May 1994. [7]R.K.Dybvig.ThreeImplementationModelsfor Scheme.PhDthesis,DepartmentofComputer 
Science,UniversityofNorthCarolinaatChapelHill, 1987.TechnicalReportTR87-011.Availablefrom: http://www.cs.indiana.edu/scheme-repository/. 
[8]M.FeeleyandM.Larose.CompilingErlangto Scheme.InC.Palamidessi,H.Glaser,andK.Meinke, editors,PrinciplesofDeclarativeProgramming, 
number1490inLNCS,pages300{317. Springer-Verlag,Sept.1998. [9]A.D.Gordon.Howtobreedhybrid compilers/interpreters.TechnicalReport 
ECS-LFCS-88-50,DepartmentofComputerScience, UniversityofEdinburgh,1988. [10]D.Gudeman.Representingtypeinformationin 
dynamicallytypedlanguages.TechnicalReportTR 93-27,UniversityofArizona,Departmentof ComputerScience,Oct.1993. 
[11]P.H.Harteletal.Benchmarkingimplementationsof functionallanguageswith\pseudoknot",afoat intensiveprogram.JournalofFunctional 
Programming,6(4):621{655,July1996. [12]B.Hausman.TurboErlang:Approachingthespeedof C.InE.TickandG.Succi,editors,Implementations 
ofLogicProgrammingSystems,pages119{135.Kluwer AcademicPublishers,1994. [13]R.Hieb,R.K.Dybvig,andC.Bruggeman. 
Representingcontrolinthepresenceoffrst-class continuations.InProceedingsoftheACMSIGPLAN ConferenceonProgrammingLanguageDesignand 
Implementation,pages66{77,June1990. [14]E.Johansson,S.-O.Nystroom,T.Lindgren,and C.Jonsson.EvaluationofHiPE,anErlangnative 
codecompiler.TechnicalReport99/03,ASTEC, UppsalaUniversity,1999. [15]E.Johansson,M.Pettersson,K.Sagonas,and 
T.Lindgren.ThedevelopmentoftheHiPEsystem: Designandexperiencereport.Technicalreport, ASTEC,UppsalaUniversity,2000.Inpreparation. 
[16]R.E.JonesandR.Lins.GarbageCollection: Algorithmsforautomaticmemorymanagement.John Wiley&#38;Sons,1996. 
[17]P.Klint.Interpretationtechniques.Software{ PracticeandExperience,11(9):963{973,Sept.1981. [18]G.Lal.MLRISC:Customizableandreusablecode 
generators.Unpublishedtechnicalreportavailable from:http://www.cs.bell-labs.com/~george,1996. [19]S.PeytonJones,N.Ramsey,andF.Reig.C--:A 
portableassemblylanguagethatsupportsgarbage collection.InG.Nadathur,editor,Principlesand PracticeofDeclarativeProgramming:Proceedingsof 
InternationalConferencePPDP'99,number1702in LNCS,pages1{28.Springer-Verlag,Sept.1999. [20]S.L.PeytonJones.TheImplementationofFunctional 
ProgrammingLanguages.ComputerScience. Prentice-Hall,1987. [21]R.M.Stallman.Usingandportinggcc.Technical 
report,TheFreeSoftwareFoundation,1993. [22]SunMicrosystems.UltraSPARCTMUser'sManual. Technicalreport,SunMicroelectronics,PaloAlto, 
CA,1997. [23]S.Torstendahl.Opentelecomplatform.Ericsson Review,75(1):14{17,1997.Seealso: http://www.erlang.se. 
[24]R.Virding.Agarbagecollectorfortheconcurrent real-timelanguageErlang.InH.G.Baker,editor, ProceedingsofIWMM'95:InternationalWorkshopon 
MemoryManagement,number986inLNCS,pages 343{354.Springer-Verlag,Sept.1995. [25]P.Wadler.Anangryhalf-dozen.SIGPLANNotices, 
33(2):25{30,Feb.1998. [26]D.H.D.Warren.AnabstractProloginstructionset. TechnicalReport309,SRIInternational,MenloPark, 
U.S.A.,Oct.1983.</RefA>  
			

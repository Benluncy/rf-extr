
 A Performance Analysis of View Ma terialization Strategies Eric N. Hanson Department of BectmaL lShgznee?wxg 
and Co mmter Sxences Unwers-zty of CaLt..ornaa, Brkeley, CA 94720 Abstract The conventional way to process 
comman ds for relational mews 1s to use query modlficatlon to translate the commands mto ones on the 
base relations An alternative approach has been pro-posed recently, whereby materlahzed copies of mews 
are kept, and incrementally updated lmmedlately after each modlficatlon of the data-base A related scheme 
exists, m which update of materialized views is deferred until Just before data 1s retneved from the 
view A performance analysis 1s presented comparing the cost of query modlficatlon, nnmedlate view maintenance, 
and deferred view maintenance Three &#38;fferent models of the structure of wews are given a sun- ple 
selection and proJectlon of one relation, the natural Join of two relations, and an aggregate (e g the 
sum of values m a column) over a selection-proJection view The results show that the choice of the most 
efficient view maintenance method depends heavily on the structure of the database, the view definition, 
and the type of query and update actlvlty present Introduction A materlahzed view 1s a stored copy of 
the result of retnevmg the view from the database In this paper, the types of materialized mews con-sidered 
are those that could be defined using SELECT, PROJECT and JOIN, and also simple aggre-gates such as sum 
or count over the result of such expressions TIM research was sponsored by the National Science Foun-datlon 
under Grant DMC-8504633 and by the Navy Electron-KZS Systems Command under contract N00039-84-C-0039 
Permlsslon to copy without fee all or part of this material IS grantea provided that the copies are not 
made or dlstrlbuted for direct commercial advantage, the ACM copyrlght notlce and the title of the pubhcatlon 
and Its date appear, and notlce IS given that copymg 1s by permlsslon of the Assoclatlon for Computmg 
Machmery To copy otherwlse, or to republish, requires a fee and/or specfic permission 0 1987 ACM 0-89791-236-5/87/0005/0440 
754 Conventional systems do not materlahze views m ad vance, ratherbut use query mo&#38; ficatlon to 
turn a query referring to a view mto one on the base relations [Ston75] An alternate method for materlahzmg 
mews whch updates the copy of the view after each transaction [Blak88] w111 be called ammedzate vaezu 
maantenance or simply zmmedz-ate m this paper A related dfferentlal wew update algorithm 1s described 
m [H0rw86] Another more restricted view maintenance algo-rithm generates and penodlcally refreshes data-base 
snapshots, which are copies of mews consist-mg of selections and proJections of a single base table [Adlb80,Lmd86] 
In the context of evaluat- mg complex trigger and alerter condltlons, Bune-man and Clemons presented 
a method for analyz-mg each update command przor to executzon to see whether it could cause a view to 
change [Bune79] If the system could not rule out the posslblhty that the command rmght alter the state 
of the view, the view would be completely recom-puted Hence, this represents another view refresh algorithm 
Lastly, this paper presents a final alternative, called de.ferred uzezu maante-nunce, or o!eferred, that 
incrementally updates a materialized view Just before data 1s retrieved from it This algorithm was also 
proposed by Roussopoulos as a method for materlahzmg copies of mews on workstations attached to a mainframe 
[ROUSES] In that scheme, the mamframe mam-tams a shared global database, and workstations update local 
copies of mews when they process queries An important way to improve the performance of view materlahzatlon 
algorithms 1s to use a screenang algorithm to test each tuple inserted mto or deleted from the base relations 
If a tuple passes the screening test, then its insertion or deletion may cause the state of the view 
to change, so the tuple must be used to try to update the view If the tuple falls the screening test 
then it cannot cause the view to change, so it does not need to be used to refresh the view In the scheme 
described m [Blak86] screening 1s done by substltutmg a tuple mto a view predl-cate, which 1s then tested 
to see d it 1s still satasjlable If so, the tuple passes the screenmg test, othemse it falls This test 
IS performed for every tuple inserted mto a relation, incurring a significant CPU cost The screening 
test proposed m [Bune79] has a compile-time phase and a run-time phase In the first phase, when the command 
for a transactlon 1s compiled, the system checks to see whether anyfields the command proposes to update 
are read by the view definition If no such fields are updated, then the command 1s called a read%@ agnoruble 
update (RIU) mth respect to the view If a command 1s an RIU, it cannot cause the view to change In the 
second phase, if the command 1s not an RIU, the mdlvldual tuples updated are screened further at run 
time If a command 1s an RIU, there 1s only a per-transaction cost assocl-ated mth this screening test 
If it 1s not an RIU, then there 1s a per-tuple cost, slrmlar the screen-ing test of [Blak86] An alternative 
test that ~11 usually be more efficient than the two just described 1s to apply the rule wake-up scheme 
m [Ston86] to the screening problem Using this mechanism, called rule zndezzng, the index intervals covered 
by one or more clauses of the mew predicate are locked using special markers called tmgger-locks or t-locks 
When a tuple 1s inserted mto the relation, if an index record contammg a t-lock 1s dls- turbed, then 
the tuple passes the screening test Othemse, the tuple falls the test nnphcltly Since this screening 
test can produce false drops (1 e tuples which pass the screening test but do not satisfy the view predicate), 
a second stage screening test, substltutmg the tuple mto the view predicate, 1s required This strategy 
1s assumed for both immediate and deferred view maintenance m the performance analysis of this paper 
To provide the background necessary for the performance analysis, Section 2 reviews the nnmedlate mew 
maintenance algorithm and describes the proposed deferred view mamte- nance scheme m detail In Section 
3, cost formu-las for each of the algorithms are derived for three different view models 1 selection-projection 
mews 2 two-way natural join mews 3 aggregates over selection-proJection mews The performance of the algorithms 
1s compared for each model Finally, Section 4 presents con-clusions, and suggests directions for future 
research 2 View Materiahzation Strategies In this section, the algorithm for mcremen-tally updating 
materlahzed mews after each update transaction IS described briefly (see [Blak86] for a complete dlscusslon) 
The proposed variant of this algorithm to allow deferred view maintenance 1s then presented Also, a brief 
dls-cusslon of query modlficatlon 1s given 2.1 Immediate View Mamtenance The differential view update 
algorithm (1 e zmmeduzte view mamtenance) operates on the fol-lomng sets of tuples RI, Rz, RN the N base 
relations A,, Aa AN the N sets of tuples m-serted into the base rela- tions by the current transaction 
DI, D2. DN the N sets of tuples deleted from the base re-lations by the current transaction The sets 
Al AN and D, DN must contam the net changes to the database made by one transac- tion Hence for ls~Q/2 
zz 9 s 4 The definition of a view V can be represented by a select-proJect-cross-product expresslon as 
follows, where Q represents selection based on a predicate X, ITY represents proJection of the set of 
attributes Y, and x represents cross-product V = ny(ox(R,xR2x -NJ) Consider an example vvlth two relations, 
Rl(a,b) and R2(b,c), and a view V defined as fol-lows, where Y=la,c j and X=(RI a=5 and RI b=R2 b) V 
= ~Y(ux(RI%)) The followmg expression shows the subsequent value of V, VI, after an append-only transaction 
updating both RI and R2 VI = ny(ux((R, u A&#38;OR2 u -42))) Selection and projection both distribute 
over union, so the above expresslon slmphfies as fol-lows V, = my(ux(RlxR2 u AlxR2 u RlxA2 u A,xA2)) 
= ~Y(ux(RIX&#38;)) u ~Y(ux(AIX&#38;)) u ~r(ux(R,'W) u ~~(ox(A~xAz)) = Vo u n~(ux(AlxRd) u ~~(ux(R~xAz)) 
u ~~bx(-WAd) This algebraic slmplificatlon shows that V can be refreshed by computing the value of the 
last three expressions shown above, and then umomng the results to the stored copy of V (Vo) In practice, 
the query optlrmzer can be used to find the most efficient method available for computing these subexpresslons 
[ Sehi 9] Since all the subexpres-slons are computed at the same time, perfor-mance advantages can be 
gamed by optlrmzmg them together The techniques described m [Se11861 can be applied to this problem If 
deletions as well as msertlons occur m transactions, the differential update algorithm becomes slightly 
more complicated One problem 1s that tuples m V may have been contributed by more than one source, since 
the prolectlon opera-tlon can map multiple input tuples to the same value If It appears that a tuple 
should be deleted from V, but V 1s stored vnth duplicates removed, It impossible to decide what action 
to take vnthout totally recomputing V from the base relations To overcome this difficulty mthout wasting 
disk space by physically stormg duphcates, each tuple m V must contam a duplzcate count, indicating how 
many potential sources could have contn-buted the tuple With the duplicate count, when a tuple 1s inserted 
mto V, if an identical value 1s already stored, then its duplicate count 1s mcre- mented Othermse, the 
tuple IS inserted vnth a duplicate count of 1 Slrmlarly, the duplicate count of the stored value 1s decremented 
on tuple deletion If the count becomes 0, the tuple 1s phy- slcally removed from V Extending the previous 
example, consider a transaction that inserts and deletes tuples from both RI and Rz The new version of 
the view, VI, IS thus represented as follows VI = ~Y(ux((# ,-4) u A,M(R2-D2) u -42))) Using R, = (RI-D,) 
Rz = (R2-D2) the above can be rewritten as simply VI = nr(ux((R~ u AI)X(RZ u A2))) Multlplymg out this 
expression yields VI = ny(ux(R, xR2 u R, xA2 u AlxR2 u A,xA2)) Expanding the Rl xRi term of the above 
gives the follomng (the remaining terms are indicated by ellipses) VI = TTY(ux((R~-DI)x(Rz-D~)u 1) = 
~r(ux(R~x(Rz-Dz) - DIX(&#38;-D~) u 1) = ny(ox(R,XRs -R,xD~ -Dlx(Rz-02) U Re-writing the second occurrence 
of RI as (RI u DJ gives VI = my(ox(R,xRs -(RI U Dl)xD, -D, 4%-Dd u )I Multlplymg the second term through, 
and substl-tutmg R2 for (R2-D2) leaves V, = TT~(u~(R~xR~ -Rl xD2 -D,xD2 -DlxR2 u )) If the operator 
-1s implemented as deletion and U as insertion using duplicate counts as described previously, then the 
prelection opera-tlon TI ~11 have the dlstrlbutlve property for both -and u [Blak86] Applymg these distributive 
properties to the expression above yields VI = nr(&#38;R,xRz ))-~y(ux(R~ xDz)) = Vo-my(ux(R, x&#38;))-my(ux(DlXRz 
)) -dux(&#38;XDz)) U dux(R, x&#38;)) u ~~(~x(A,x&#38;')) u ~rbx(A,xAzN As expected, the first term of 
this expression 1s Vo, the previous stored value of V To update the stored copy of V so that its value 
becomes VI, the remaining expressions must be evaluated, and either Inserted mto or deleted from V as 
required, mamtammg the correct duphcate counts (The differential view update algorithm presented here 
is slightly dfferent than that given m [Blake61 A discussion of the differences appears m Appendix A) 
2 2 Deferred View Mamtenance The immediate view maintenance algorithm 1s performed after every database 
update However, m certain situations, It vnll be advantageous to save the sets of tuples inserted and 
deleted for a period of time, and then apply the differential update algorithm to the whole group Given 
a method to compute the net changes (q-net and q-net) for each relation, &#38;, for l<z<N, over a period 
encompassing more than one transaction, incremental view maintenance can be done when-ever desired (hence 
the name deferred view maintenance) To refresh the materlallzed view on a deferred basis, A,-net and 
q-net must be calcu-lated and then input to the standard differential view update algorithm A previously 
developed technique called hypothetzcal relataons [Wood83] can be adapted to the purpose of computmg 
q-net and D,-net The basic algorithm for lmplementmg hypothetical relations 1s brlefly described below 
Efficient lmplementatlon of hypothetical relations to sup-port deferred view maintenance vvlll be dlscussed 
after the basic algorithm 1s presented )) 2 2 1 Hypothetical Relations Fortunately, the net changes to 
&#38; to use m deferred refresh can be found using a modified hypothetical relation (HR) algorithm proposed 
in [Agra83] The HR scheme uses three tables for each relation rather than one Each relation has associated 
mth It tables R, D and A, for base tuples, deletions and insertions, respectively The data value of a 
tuple ml1 simply be called value Each tuple ~11 also have a unique identifier field ld This yields 
the followmg schema for each relation R(id, value) D(ld, value) A(id, value) The true value of the relation 
(RT) is (R u A) -D The set difference operation - above has the normal meaning, based on all fields of 
the tuple, including id To append a tuple to RT, a transaction inserts that tuple in A, placing the value 
of the system clock or other monotonlcly increasing source m the id field If duplicate-free semantics 
are desired, the system must ensure that the tuple 1s not already in (R u A)-D before appending it. to 
A To delete the tuple from the relation, a copy of its value, mcludmg the id it had m R or A, is placed 
m D To modify an exlstmg tuple, its old value ~11 be put in D, and its new value m A When retrlev- mg 
data from RT, queries are processed against both R and A, and any tuples found are checked to make sure 
they are not already m Dz (If they are, they are ignored) Given this structure of the HR, the expres-slons 
for computing A-net and D-net from R, A and D as described above are the followmg A-net = A -D D-net 
= D -A After a view refresh that uses A-net and D-net, the files used to store the hypothetical relation 
~11 be reset as follows R = (R u AI-D A =q5 D =$ 222 Efficient Implementation of Hypothetical Relations 
 The problem mth the most straightforwardlmplementatlon of hypothetical relations 1s that retrlevmg a 
tuple from R requires three disk accesses rather than lust one, as m a standard relational database To 
retrieve a tuple t from R using the HR scheme this way, an attempt must be made to read t from both R 
and A, and then D must be read to make sure that t has not been deleted Fortunately, a method developed 
m [Seve76] can be used to screen out most accesses to the differential file(s) In this method, a Bloom 
filter [Bloo70] 1s used for each differential file, conslst-mg of an array of bits B[ 1 m], vvlth each 
entry ml-tlally zero It 1s assumed that some subset of the fields of each record called the lcey uniquely 
identifies the record For each record m the differential file, a hash function h mapping the key of a 
record to an mteger in the range 1 to m 1s computed, and the correspondmg entry m B 1s set to 1 Then, 
to test whether a record t 1s m the differential file, if B[h(t key)]=O, t 1s not present, othemse, if 
B[h(t Ley)]=l, it rmght be present, so the differential file must be searched to see if it. 1s there 
Using the method proposed in [Seve76] one can design a Bloom filter vnth any desired ability to screen 
out accesses to records not present m the differential file by increasing the value of m As another measure 
to help speed up accesses to the differential file, A and D for each relation R ~11 be combined into 
a single file, AD An extra attribute role ~11 be added to tuples in AD to indicate whether they are appended 
or deleted tuples This storage structure ~11 speed up the malorlty of updates, which modify exlstmg records 
mthout changing the key For example, If AD 1s maintained using a clustered hashing access method on the 
key, then when a tuple t 1s updated to t wthout havmg its key changed, t ~11 hash to the same page as 
t Thus, a maximum of only three disk I/OS ~11 be required to update a smgle tuple t in R given the key 
for t This update pro-cedure 1s as follows I/O Read the tuple (Check the Bloom filter to see if t could 
be m AD If not, read t from R Othemse, read AD to see if it is there If t is not m AD, read R This rmeht 
reaure 2 I/O s. but the Drobabll-ltyYcan be made arbitrarily s&#38;l by m-creasing m Hence, only one 
I/O 1s counted here for sunphclty ) I/O Read the page where the new value of t (t ) ~11 he in AD (Place 
both t and t prime on the page The role values of t and t are deleted and appended respectively ) I/O 
Write this page back to disk This 1s only one more I/O than necessary to per-form this type of update 
using a standard rela-tional data structure If separate files for A and D were used, at least flzve I/O 
s would be required rather than three since R must be read, and A and D must both be read and written 
In the remainder of the paper, the sets of inserted and deleted tuples ~11 still be referred to as A 
and D, even though they are stored m the AD table It 1s assumed that AD w-111 be partltloned to form 
A and D when necessary 2 3 Query Modficatlon The queries sta1s ndard query method for modlficatlon, processmg 
whereby view view queries are translated into base relation queries This can result m efficient view 
access, since a good query execution plan for the resulting base relation query ~11 be found by the query 
optlm-lzer [Sell791 For example, consider the followmg view ED on the standard EMP and DEPT schema EMP(name, 
age, salary, dept) DEPT(dname, floor) define view ED ( EMP all , DEPT all ) where EMP dept = DEPT dname 
Suppose that EMP has a hash index on dept and DEPT has hash indexes on dname and floor Query modlficatlon 
would translate the view query retmeve (ED name) where ED floor = 1 mto the followmg base relation query 
retrieve (EMP name) where EMP dept = DEPT dname and DEPT floor = 1 The optlrmzer rmght then select the 
followmg access plan for the query Fmd all DEPT tuples mth floor = 1 using the hash index on DEPT floor 
Do a nested loop join, vnth the tuples found above as the OUTER relation, and EMP as INNER, making use 
of the EMP dept index Performance Comparison Each of the view materiahzatlon methods presented ml1 have 
different performance charac-teristics This section discusses the factors affecting performance and derives 
cost functions for each method for three different view models 3 1 Models to be Analyzed Views can be 
matenahzed using query modlficatlon, or munedlate or deferred view maintenance Here, the situations m 
which each method performs best are determmed Three different models of the structure of mews are con-sidered 
relation R Model 2 natural loin of two relations, RI Only two types of operations ml1 be considered 
m the models updates to the base relations, and queries to the view It 1s assumed that exactly k update 
operations, and q queries to the view ml1 be run For each model, a formula for the azleT-age cost per 
query, over all k updates and q queries, ml1 be derived The relations involved have the followmg access 
methods d R, RI clustered B+-tree on field used m view predicate R2. clustered hashing on Join field 
matermhzed view (V) clustered B+-tree on field used m view pre&#38;cate differential file (AD) clustered 
hashing on a key &#38;dd Generous assumptions ml1 be made for all view materlalizatlon schemes regardmg 
how queries and other operations are performed using these clustered indexes Smce these performance benefits 
vvlll be given to all algorithms, the results should not be biased toward any one scheme The parameters 
important to the analysis are shown m Figure 1 The default values of these parameters, which w111be used 
unless stated oth-erwlse, are as follows r N 100,000 S 100 l-f, 1 B 4,000 f&#38; 1 k 100 Cl 1 1 25 cz 
30 Ca 1 ter dejh&#38;on N number of tuples m relation S bytes per tuple B bytes per block b total blocks 
(6 = NS/B) T number of tuples per page f T=B/ Sl n iumber of bytes m a B+-tree index record k number 
of update transactions on base relation 1 number of tuples modified by each update transaction 9 number 
of times view queried U number of tuples updated between view queries (u =kl/ q) P probablhty that a 
given operation1s an update (P=k/ (k +q)) f view predicate selectlvlty for Model 1 fv fraction of view 
retrieved per query f&#38; size of Rz as a fraction of R, Cl CPU cost to screen a record against a pre&#38;cate 
m rmlhseconds (4 CZ Cost m ms of a disk read or write Ca Cost in ms per tuple per transac-tion to manipulate 
A and D data structures in immediate mew Figure 1 3.2 Model 1 Cost Analysis In Model 1, the view 1s 
formed by prolectmg exactly one half of the attributes of tuples from R, and applymg a predicate mth 
selectlvlty f Thus, the result ~11 contain f times N tuples The value that ~11 be measured for each view 
maintenance scheme 1s the average cost of a query that retrieves a fraction f, of the tuples m the view 
3 2 1 Cost of Deferred View Mamtenance Assummg Model 1 In deferred view maintenance, it 1s assumed that 
the view 1s refreshed every time it 1s queried After the refresh 1s finished, the result of the query 
1s computed The average cost of a query to the view, which will be called TOTQeferredl, has several components 
The first is the cost to read the result of the query from the copy of the view stored on disk The second 
1s the cost to refresh the view The third 1s the cost to screen mcommg and deleted tuples to see if they 
rmght affect the state of the view Finally, the fourth 1s the cost to maintain the hypothetical relation(s) 
The aver-age value of each of these costs are added together to get the average cost per query, TOTALdeierredl 
In =-I-Y,  TOTALdeiemedl= (cost to retrieve result of query from stored copy of view) + (cost to refresh 
the view) + (average cost per query to screen tuples to see if they affect view) + (average cost per 
quer to maintam hypothetical relation rs))  It 1s assumed that no duplicates are formed by prolectmg 
half the attributes, so the view has f N tuples and f b/ 2 pages A fraction f, of the view 1s read during 
each access, requiring f f ,, b / 2 page reads, at a cost of C2 each One search of the B+-tree vnll also 
be necessary to locate the position m the view to begm scanning Since there are n bytes per index record, 
the height of the B+-tree, not including the data pages, 1s determmed as follows The number of index 
records per page, and thus the mdex fanout, 1s B/n There 1s one index record for each of the fN tuples 
in the view Assummg as a slmphficatlon that all pages are packed full, the height of the view index (H,) 
1s thus H, = 1 loq~,,FfNl Additionally, each tuple read from the view must be screened against the query 
predicate, at a cost of C1, for a total cost per view access of C,f,fN Thus, the total cost Cpuergl to 
query a materlahzed mew is Czffvb Cquery1 = -+ C,H, + c,ff,N 2 The next cost to consider 1s that for 
the hypothetical relation overhead It 1s only neces-sary to measure the cost m excess of that required 
to perform normal base relation updates As a slmphficatlon, the assumption 1s made that only tuples m 
R are updated, and never tuples in AD The cost to mamtam the HR for a single insertion mto R m this sltuatlon 
1s the followmg 1 read the orlgmal tuple from R 2 read the page m AD where the modified tuple ~11 be 
placed 3 write this page m AD Step (2) 1s the only extra I/O required over using Just a single table 
(R) The normal cost to update R would be one read and one write, or 2C2, per tuple updated If the cost 
of step (2) 1s averaged over all quenes and updates, the cost per query to mamtam the HR 1s at most the 
cost of one I/O (C,) times the number of tuples update per view query ( LL) The total cost 1s likely 
to be somewhat less than this, however, since AD often has a small number of pages, and there are 1 tuples 
modified per transaction The cost can be modeled more accurately using a function for estunatmg the number 
of pages touched when accessmg k out of n records m a file occupymg m disk pages Ths function, whch ~11 
be called y(rr,m,k), has been previously derived [Yaoi? ] (See Appendix B for a descrlptlon of J/) The 
number of tuples m AD ~11 be tmce the number of tuples updated per view query (2 1~) The number of pages 
m AD ~11 thus be NIL dlvlded by the number of tuples per page (T) The number of pages m AD touched per 
tran-saction 1s thus y(2~,2W T,L) Averaged over q queries and k updates, the total cost of the extra 
accesses to AD is thus the followmg cm=c2 $2/(2+) Consider now the cost to refresh the view V once This 
first mvolves the cost to read all of AD Since 21 tuples are updated per view query, AD has approxunately 
2u elements There are T records per page, so AD has 2u/ T pages Thus, the cost Cea,j of reading M is 
CADread = c222LT Another cost 1s incurred to screen updates to see whether they have a chance of affecting 
the view Recall that to screen mcommg tuples to see whether they can affect a view, rule indexing 1s 
used m combmatlon vnth a more stringent satlsfiablhty test For the view maintenance methods analyzed, 
it. 1s assumed that the screen-mg 1s performed as follows If (1) a tuple breaks a t-lock for the predicate 
of view V, and (2) , , ,e,~;e~$;;;;~;;~-~~;$ t substituted  then a marker mlcatmg this 1s placed on 
t In both the deferred and immediate view update algorithms, a tuple ~11 be used to update a stored 
view V only if the tuple has a marker for V A fraction f of the u tuples inserted into R per query ~11 
conflict mth a t-lock set for V m step (1) above, and thus must be passed on to step (2) Step (1) has 
essentially no overhead, and step (2) costs Cl Thus, the average overhead per query to screen tuples 
to see if they affect V 1s Cscreen= ClfU Also, approximately fu tuples per query vnll be inserted into 
and deleted from the view, respectively, for a total of 2u tuple updates Each insertion or deletion from 
the view requires read-mg the B -tree view index, and reading and rmt-mg a data block However, somewhat 
less than 2fu pages of the view may actually have to be updated during a refresh, since there may be 
more than one record per block m the view Using the Yao function, since there are fN tuples and f b/ 
2 blocks m the view, the number of view blocks accessed (X,) 1s approxunately X, = v(fN,+f4 Each access 
requires reading the index, readmg and mtmg a data block, and writing a leaf-level index block (splits 
of internal index pages are infrequent, so then-cost ~11 be ignored as a simplification) This requires 
3 I/OS, plus a number of I/OS equal to the height of the index on V (H,) Thus the cost to refresh the 
view, Cd&#38; remshl, is as foilows The following is the final expression for the cost per query to .the 
view V using deferred refresh: ;.2.2. Cost of Imme&#38;+ Assuming Model The cost per view access immediate 
view maintenance, TOT-~, follows: of performing is. as TOTktitil = (cost to query view) + (total cost 
to modify s>ored view) / (# of view accesses) + (total cost to screen tuples inserted into R to see 
ir thev should enter view1 / (# of vi&#38; accesseg) + (overhead per query to maintain R and D sets 
in a data structure during 1 transaction processing)  The cost Cm1 to query the view is the same as 
for deferred view maintenance. The cost to update the stored view when a transaction modifies R, which 
will be-called &#38;-Al, is corn puted much like Cdd_*i: The difference is that approximately 2jl tuples 
in the view must be modified once per &#38;ansacBcn, rather than modi- fying 2ju view tuples once per 
query. Since some of these 23i, tuples may lie on the sax+&#38; page, the number of view page&#38; touched 
(Xe) can be estimated using the Yao function as follows: x, =YvN.~,zfl)  Similar to the case for deferred 
view maintenance, updating a tuple in V requires a P-tree search, the read and write of a data block, 
and the write of an index block. This requires (3+H,.J I/OS for each view page touched, as. before. Since 
there are k updates for every q queries. the average cost per query to update the view is: C~,_,.,,M,, 
= >z (3+H,) X, The cost C,, to screen the kt tuples inserted into R is unchanged. Finally, since immediate 
view maintenance must update the view after every transaction, the data structures used to maintain the 
A and D sets must be reset once per transaction. The overhead per query to do this, which will be called 
C-bd, will be estimated as Cs for each of the jl tuples in A and D, multiplied by the number of updates 
per query (k/q), i.e. COVerhsad(CZi2JV$= This gives the following expression for the total cost of immediate 
view maintenance: TOTb&#38;, = ~queryl*~~rhl+c~~+~~head 446   X2.3. Cost Using Query Modiflc&#38;ion 
Assuming Model 1 I The cost of using query modification rather than materializing the view in advance 
is con-sidered here (this option will perform best in some circumstances, e.g. if the ratio of updates 
to queries is high). Three different methods for retrieving the view from R Tlill be considered: (1) 
a clustered (primary) index scan for which no extra tuples must be read (clusstexyd) (2) ~1 zc&#38;&#38;e&#38; 
un (3) a sequential (8eqlle?nt.ial) (secondary) index scan scan of the entire relation 1 Using a clustered 
index, scan, the number of pages that must Bre read from R is equal to the size of the view. which is 
.fb. times the fraction of the vien_ ret&#38;&#38;d. I,, . hid number of tuplesretrieved is ffVN, a&#38;each 
of these tuples must be tested against the view predicate at a cost of C,. Thus, for the clustered, scan 
(1) the total cost to retrieve the view per access is Using an u&#38;lustered scan (2), ,a larger number 
of pages must be read from R. Searching for jf,N tuples out of a total of 6 pages will require approximately 
v (N,b ,Nfj,) reads. The system must stiI1 test Nff ,, tuples against the view predicate. Thus, the total 
cost for case (2) is TOT&#38;-a = 4-u (N.b AV1u )+C,Nff, Using a sequential scan of the entire relation 
(3), all b pages must be read, and all N tuples must be screened against the view predicate, resulting, 
in the following total cost: TOThI+-ti = Gb +C,N 3.3. Perfqrmance FW@ts for Model 1 To indicate the 
differences in cost with respect to the probability P that an operation is an update, F igure 2 plots 
the total cost of deferred, immediate, clustered and unclustered vs: P for the standard parameter setti 
s (sequential is not shown since it is off the scale 9, . This setting of the parame ters models a situation 
where the ,view : contains ~10,000 tuples, and each query retrieves 1,000 tuples. In this situation, 
query modificatidn using a clustered access path has performance equal or superior to deferred and immediate. 
One would expect that clustered would rform well -here since the number of pages tff at must be read 
is small when using a clustered index. The only advantage that deferred and immediate have over clustered 
is that there are twice as many tuples per page in the view comuared with the base relation. How-ever, 
the e&#38;a overhead paid by deferred and immediate to maintain the materialized copies of the view offsets 
this. It is surprising that deferred and immediate view maintenance have almost identical cost clustered 
view index as an alternate access path 50000 00 dmfemed 40000 00 view maintazlance : pImy nmiification 
ue brlmediate 30000 00 uncblamed index SCM vimr -tenmCO P 0 00 0 20 0 40 0 60 0 a0 100 update probabihty 
(P) Model 1 (1 table, snnple selectlon/projectlon view) Total cost of a view query vs update probablhty 
P Figure 2 under these circumstances Once reason for this 1s that for low values of P, materlahzatlon 
methods have nearly equal cost for vn-tually any parameter setting This occurs since for low update probability, 
a large fraction of the cost of both algorithms 1s for processing queries against the materlallzed view, 
and both algorithms do this the same way Another cause of the close match 1s that the hypothetical relation 
overhead m deferred view mamtenance counteracts the other advantages it. holds over m-mediate view mamte-nance 
If more than one disk 1s available, and I/O operations can be issued concurrently by a pro- gram, then 
it would be possible to significantly decrease the cost of mamtammg hypothetical relations (e g by putting 
R, A and D on separate disks and readmg from them simultaneously) This would give deferred mamtenance 
an advan-tage over the immediate scheme for a mder range of parameter settings However, these assump-tions 
are not made m this paper smce they would require extra hardware, and operating system functlonallty 
not readily available m all computer systems Assummg the view 1s maintained mth a clustered index on 
a commonly used access path, the view materlahzatlon methods are slgmficantly superior to query modlficatlon 
when only an unclustered access path 1s available on the base relation This has lmphcatlons for database 
design, since a materlahzed view could be clustered on one attribute, and the base relation on another 
In this situation, a query optlrmzer could chose to process a view query in one of two ways, depending 
on the query pre&#38;cate If the predicate could be processed most efficientlyusing the clustered index 
on the base relation, query modlficatlon would be chosen to execute the query Othemse, the query could 
be pro-cessed against the materlallzed view, using the An interesting tradeoff among the algorithms centers 
around the parameters f , P, and f, To illustrate the relationship between these parame-ters, Figure 
3 plots the region where each algo-rithm has lowest cost for different values of P and f , mth f, fixed 
at 1 Although deferred 1s never the most efficient algorithm under these parame-ter settings, larger 
values for f improve the per-formance of deferred relative to lmmedlate view maintenance This occurs 
due to the nature of the Yao function, combined w?th the fact that increasing f increases the size of 
A and LJ propor- tionately Larger values of P tend to favor the algorithm wAh the least overhead per 
update transaction (1 e query mo&#38;ficatlon) Reducing the total fraction f, of the view retrieved also 
tends to favor using query mo&#38;ficatlon, since the over-head of the view maintenance schemes 1s mdepen- 
dent of f,, but the cost per query decreases vvlth f, When the value of f v is lowered to 01, as shown 
in Figure 4, clustered performs best over an even larger area In Figure 5, CS, the overhead per tuple 
for mamtammg the A and D sets was increased from 1 to 2 ms, while setting f ,, = 1 The affect of this 
change can be seen by comparing Figure 5 and Figure 3 The fact that deferred mew maintenance now performs 
best m part of Figure 3 shows that the cost of the view matemallzatlon methods 1s very sensitive to the 
overhead for mamtammg the A and D sets 3 4 Model 2 2-Way Jam View In this section, the performance of 
the different view maintenance algorithms 1s com-pared, assummg a more complex view model The view V 
in Model 2 1s a join of two relations, RI and R2, where RI contains N tuples, and R2 has fAEN Model 1 
(1 table, snnple selection/pro]ectlon view) Regions where each algorkhm performs best for f vs P (fraction 
of view retmeved v,,) = 1) Figure 3 1 00 0 80 I 020 ilmmdlat.4 slew main~mcenfnr / 8- ooo-T -0 00 020 
040 080 0 80 100 view predicate mlectlvlty rf ) Model 1 (1 table, simple selectlon/proJectlon mew) Regions 
where each algorithm performs best for f vs P (fraction of mew retneved (j,) = 01) Figure 4 Model where 
Ale ocf,) ve= 1 (1 table, each algorithm rhead per 01) simple petuple selectlon/proJectlon rforms best 
for f (Cs) = 2, fraction vs of view) P (differential view Regions retrieved Figure 5 tuples The definition 
of V is define mew V (R, fields, Rz fields) where RI x = Rz y ad Cr (RI)  The clause C,(R,) m the view 
predicate restmcts relation R, wkh selectlvlty f It 1s assumed that every tuple of RI that matches C 
loins to exactly one tuple in Rz, so V has f N tuples total Also, both RI and Rz contam tuples of size 
S bytes, and only half the attributes of each relation are pro-Jetted in the target list of the view 
defimtlon Thus, the tuples m V also contain S bytes each The query and update actlvlty assumed 1s the 
same as for Model 1, except that all updates are to R, rather than R (Rz 1s never updated) 3 4 1 Cost 
of Deferred Ass ummg Model 2 For Model 2, the cost per query of doing deferred view mamtenance 1s determmed 
as fol-lows TOTGeierrede = (cost to read AD) + cost to refresh view) + cost to query view) + i cost 
per query to screen new tuples against view predicate)  The costs Cm and Caead of updating and read- 
mg the HR, respectively, from Model 1 are unchanged for Model 2 The cost to refresh the view before it 
is queried (using deferred view maintenance), which Cdefhreiresh8, ~11 be called ~11 be determmed as 
follows To refresh V, the value of the followmg expression must be computed (the notation V(X,Y) means 
the expression for V evaluated mth X and Y m place of RI and Rz, respectively VU?,&#38;) u V(A,&#38;) 
-WI,&#38;) The V(RI,Rz) term 1s already computed and stored as the previous version of the view ( Vo) 
No terms containing AZ and Dz are shown since Rz 1s never updated Thus, only V(A1,Rz) and V(Dl.R2) must 
be computed Recall that there 1s a clustered hash-ing index on Rz that can be used as an access path 
to loin tuples m Al and D1 to Rz The cost to Join the Al and D1 sets to Rz is determmed as fol- lows 
Rz has f&#38;V tuples and f R,b pages, and there are u tuples m each of Al and D, at refresh time Thus, 
the total number of pages that must be read from Rz to perform these two Joins is xs = Y (f RBNnf &#38;J 
r2f U) It 1s assumed that pages read for the first Join stay m the buffer pool for the second There 
is also a CPU cost of C1 for matchmg each of the 2u tuples m A, and D1 vvlth the lolmng tuple m Rz Furthermore, 
for each Joining tuple, a page must be read and written from the stored view Using the Yao function, 
since the view has fN tuples of size S bytes, and a fraction f of the tuples m Al and D1 Join to exactly 
one tuple in Rz, the actual number of view pages that ml1 be updated 1s approxnnately X4 = y (fN,f b 
,2f u) Each page update requires reading the B+-tree index on the view, as well as reading and writing 
the data page, and writing the index leaf page (1 e 3+H, I/OS) Thus, the total cost C&#38;f-,.&#38;&#38;Z 
to update the view every time it 1s queried 1s Cd&#38;refresh2 = ~&#38;i+~,~~+C2(3+&#38;-1) x4 When 
the view 1s queried, both deferred and munedlate view maintenance pay the same cost, Cpuerg2 tis consists 
of searching the view index to find the startmg pomt, and then performmg a clustered index scan to retrieve 
a fraction f, of the view This costs Cz per page, and Cl per tuple scanned Summmg the cost of the index 
search and scan yields the follomng expression for Cw=ry2 Cquery2= c,H,+W,f b +C,f ,,f N Both deferred 
and nnmedlate view mamte-nance pay an average screening cost of C,,, per query to the view Given Cdefmreirea, 
Cquerg2, and CecPe.zIL~the expression for the total cost using deferred view maintenance assummg Model 
2 1s TOTALdeferred = CADread+Cdef-refTe~2+cq~=~2+c~~=~~ 3 4 2 Cost of Immediate View Mamte-nance Assumng 
Model 2 The cost TOTQnnncdateB of doing unmedlate view maintenance combined vnth rule indexing m Model 
2 IS TO Nme~atez = (cost per query to update view) + (cost to query view once) + (total overhead per 
query to mamtam A and D sets) + (cost to screen new tuples  against view predicate) To find the cost 
per query qrmrrreireh2 of mamtam- mg the materialized view, the cost to refresh the view after each transaction 
must first be found The components of this refresh cost are the I/O cost of reading the pages of R2 to 
which tuples in A, and D, loin and readmcr and rmtme modified pages of VI plus the CPU cost of han&#38;ng 
each tuole in A, and D, Since A, and D, both contain 1 t&#38;es at {he end of each tiansact;on, and a 
frac- tion f of these match the view predicate and must be Joined to R2, the number of pages that must 
be read from R2 1s x, = Y dfR,Nvf R,b n2f 1) Each tuple in A, and D, Joins to some tuple in R2, so each 
causes one tuple to enter or leave V The number of modified pages of V 1s X, = 2/(fN,fb,2fl) Again, for 
each of these pages, the index on V must be read, the page must be read and written, and an index leaf 
page 1s wrltten, requiring 3+H, page I/OS There 1s also a CPU cost of Cl for han-dling each of the 21 
tuples m Al and D1 Averaging the per-transaction cost of updating V over k transactions and q queues, 
the estimated cost per query is as follows Cunmrehush2 = @&#38;+Cd3+Wd Given Clmmrefreh2 and Cquerp2, 
the followmg expres-sion shows the total cost of lmme&#38;ate view mamtenance using rule indexing, assummg 
Model 343 Cost Using Query Modticatlon Assuming Model 2 Another important cost to measure 1s that to 
matermhze a view directly from the base rela-tions A frequently used Join strategy called nested-loops 
(or 1oopJozn) mvolves scanning one (outer) relation, and for each of Its elements, searchmg the other 
(inner) relation to find all lommg tuples If an index 1s present on the Join field of the inner relation, 
it can be used for the search It 1s assumed that the nested-loops Join algo-rlthm 1s used to Join RI 
and R2 m Model 2 RI ml1 be the outer relation, and R2 ml1 be the inner one Since there is a hash index 
on the Join field of R2, it vnll be used for the inner search The assump- tion is made that pages of 
R2 stay m the buffer pool throughout the computation of the Join after they are read the first time With 
the advent of very large main memories, this 1s reasonable since R2 contains only fRaNS bytes, which 
1s approxl- mately 1 Mbyte using the standard parameter set-tings Under these assumptions, nested loop 
Join has the followmg cost components, vvlth the actual costs shown below cost component actual cost 
read 3+-tree on RI CJ 104 B/nlNl read part of RI using Czff ,, b clustered scan CPU cost to screen Rl 
Clff,N tuples scanned read pages from Re us- C2%4(f~$ ftt,$ ff,N) mg hash Index CPU cost to match RI 
C,Nff, Summmg the above cost components gives the fol-lowmg formula TOTI,,,, for the total cost to com-pute 
the Join using nested loops + c,yV~,N,fR~b,ffvN)+ZC,Nff. 3 5 Performance Results for Model 2 The actual 
cost per query for deferred view mamtenance, immediate view maintenance, and query modficatlon using 
a nested loop loin mth an index on the inner relation are plotted m Fig-ure 6 using the standard parameter 
settmgs Ths figure mdlcates that the results for Model 2 are slgmficantly &#38;fferent than to those 
for Model 1 When the view Joins data from more than one rela-tion, mcremental view maintenance algonthms 
(deferred and unmediate) perform better relative to query modlficatlon By mamtammg a matenal- lzed copy 
of the view, the query cost 1s greatly reduced, since each result tuple 1s stored on exactly one page 
In effect, mamtammg the view serves as an effective way of clusterzng related data on the same page However, 
as the update probablhty P increases, the overhead for mam-taming the materialized view overwhelms the 
advantage gamed by clustering, so query BOO00 00 defelTed. xllnmdlate 60000 00 vm lMintalmce mII 1 
I   i_$ _ -w- -- wdlnce.twn 0000 20 040 0 60 0 so 100 update probabibty (P) Model 2 Actual cost per 
query usmg deferred view mamte-nance. immediate view mamtenance, and query modlficatlon (fraction of 
view retrieved cf,) = 1) Figure 6 modlficatlon becomes more attractive Also, su-n~-lar to Model 1, as 
the fraction of the view retrieved (f,) IS decreased, the advantage of query modlficatlon grows This 
follows since mak-ing f, smaller reduces the query cost, while the amount of overhead paid by deferred 
and unme&#38;- ate algorithms for updating the view stays the same An important special case to consider 
1s when the view IS large, and the queries read a small amount of data This occurs, for example, using 
the standard EMP and DEPT relations, and view ED Joining the two The malorlty of queries m this situation 
rmght retrieve only a smgle tuple from ED Also, updates usually change only one EMP tuple This example 
was modeled by setting f = 1, f V = I/ N and 1= 1, and the results showed that query modification 1s 
superior to deferred and immediate under these cn-cumstances for all values of e 08 Thus, query modlficatlon 
1s almost always the preferred method for answering small queries agamst large mews Other effects of 
varymg f, are shown usmg two figures Figure 7 plots the areas where deferred view maintenance, unmedlate 
mew maintenance and query modlficatlon usmg nested loops each have best performance for different values 
of P and f , vnth f, set to 1 (recall that the nested loop Jam uses an index on the inner relation) Figure 
8 shows the same information mth f, set to 01 3 6 Model 3 Aggregates Over Model 1 Views Aggregates such 
as sum, count and average are an often-used feature of database systems Many aggregates (mcludmg all 
the ones listed above) can be incrementally updated as changes occur to the data from which they are 
computedThis 1s done by defining a state for the aggregate, functions for updating it m case of deletion 
or insertion of values m the set being aggregated, Model 2 (2-way join view) kglons where each algorithm 
performs best for f vs P (fraction of view retfleved VII)= 1) Figure 7 100 1 o OOO. 100 dew predicate 
nehuvity rf ) Model performs u, I= 2 (e-way best 01) join for view) Regions where f vs P (fraction of 
each view algorithm retrieved Figure 8 and a function for computmg the current value of the aggregate 
from the state The notion of mcre- mentally mamtammg aggregates is extremely attractive since the aggregate 
state can be read quickly because It normally requires less than one disk block of storage, while it 
often takes a large amount of I/O to recompute the aggregate from scratch Thus, it would appear that 
an aggregate need not be used often to Justify the expense of mamtammg a materlahzed version of it To 
compare the value of mamtalmng aggre-gates vs computing them from scratch, a modified view model (Model 
3) 1s used, m which the mews are simply aggregates over mews of the same type as Model 1 In Model 3, 
the tuples for which the aggregate 1s computed do not need to be kept m a separate matenahzed view Only 
the aggregate state must be stored For this model, a query to the view consists of sunply reading the 
state of the aggregate Usingthe deferred view maintenance scheme m Model 3, the cost TOTALdeferredper 
query to the view IS TOTALdeferreds= (cost to read hypothetical database) + (cost to read the aggregate 
state) + (cost per query to update the aggregate state if necessary) + (cost per query of screening 
tuples  to see d aggregate 1s affected) The cost to read the hypothetical database 1s Cfiea&#38; unchanged 
from Model 1 The cost to query the aggregate 1s the cost to read a single page, 1 e Cquery3 - cz The 
cost to update the aggregate 1s the cost of one wnte times the probability that at least one tuple modified 
since the last query to the view lies m the set being aggregated (no read 1s necessary since the aggregate 
must be read to answer the w-39 There are 2u modified tuples m the hvDothetlca1 database Der auerv to 
the view. and each has probability f-of l$ng*m the aggregated set The Drobabihtv that at least one of 
these tuples mli he m thd aggregated set 1s equal to 1 mmus the probablhty that none of the tuples lie 
m the set Thus, the probablhty that at least one of the tuples lies m the set 1s (l-(l-f)ti) This yields 
the followmg expression for the cost per query to update the view Cdef-refresh3 = c2( 1-c 1 -f )2 ) The 
final value of TOTALdeferred1s the followmg TOTALdefemds = CADread+Cquery3+Cdef-refresh3+Csc~een Using 
the unmedlate view update algonthm, the cost per query to maintain the aggregate IS TOTA.Lmsimtes= (cost 
to read the aggregate state) + (cost per query to update the aggregate state if necessary) + (cost per 
query of screening tuples  to see d aggregate 1s affected) The cost to read the aggregate state 1s C,-The 
cost per transahon to update the aggregate state 1s C2 times the probablhty that at least one tuple modified 
by the transaction lies in the aggregate, which IS (l-( l-f) ) The cost per query to update the aggregate 
state 1s thus as fol-lows Cmmrefresh3 = F(l-(l-f)=) The cost of screening tuples is again C,,,,,, yield- 
mg the followmg expression for TOT&#38;-hates TOTh,mwes = Cquerys+ClrmnrefreshS+Cscreen The actual cost 
of recomputmg the aggregate for each query using a clustered index scan 1s the same as the cost of query 
modlficatlon m Model 1, which 1s TOTi&#38;lustered This cost ml1 be compared to TOT&#38;hate3 and TOTALd,f,,,ds 
3 7 Performance Results for Model 3 To compare the total cost of using deferred view mamtenance, nnmedlate 
Mew maintenance, and a clustered index scan to compute an aggre-gate, the total cost of all three IS 
pIotted vs 1 m Figure 9 Note that the most significant part of the curve is for small values of 1, e 
g 1cl00 In this region, mamtalmng the aggregate costs only a small percentage as much as computing it 
from scratch To show the trade-off between a matenahza-tlon algorithm and standard aggregate process-ing, 
Figure 10 plots curves for P vs 1 showmg where a clustered scan and Immediate view mamtenance have equal 
cost for different values of f (the fraction of the relation that 1s being aggregated) Query modlficatlon 
using the clustered scan performs best above each curve, and n-nmedate maintenance performs best below 
It 1s interesting to note that mamtammg matenal-lzed aggregates 1s most attractive when the frac-tion 
of the relation being aggregate 0) 1s largest Also, since reahstlcly 1 ~11 probably be small, it 1s likely 
to be worthwhile to maintain materialized aggregates even for small values of f Cost sav-ings can be 
obtamed by matenahzmg aggregates m slgmficantly more cases than for other mews 4 Conclusion The performance 
analysis presented has shown that the choice of the most efficient view matenahzatlon algonthm 1s highly 
apphcatlon-dependent The results are most sensitive to the 2600 00 1 2000 -query modolcation 00 dew mdntanallm 
llshg cludmnd index ICM 1500 00 1000 00 * 600 00 - Model 3 (smgle-relation aggregate) Average cost of 
an ag-gregate query vs 1 for deferred and mmediate mew mamte-nance, and standard processing using a clustered 
mdex scan Figure 9 deferred and nnmedlate view maintenance nearly canceled each other The mam advantage 
of  \:I-- 0 30 L 1=01 0 100 00 300 00 300 00 400 00 600 00 Model 3 (sm f le-relation ygregate) Eqwvalent 
cost cur for umne&#38;a e mew mam enance, and standard aggre ate processmg usmg a clustered mdex scan 
Above curves s an- dard processmg 1s best. unme&#38;ate mamtenance wms below Fuure 10 follomng parameters 
1 the total fraction of operations that are updates (P) 2 the selectnnty factor of the view pre&#38;cate 
V ) 3 the fraction of the view retneved by each query (f,) 4 the number of tuples mtten by each update 
(1) 5 the cost of mamtammg the sets of inserted and deleted tuples (either m or m disk-based hy-~l?etZ%Xi~ons) 
 Sltuatlons where P 1s high, f is high, or I,, 1s small, tend to favor not matenahzmg the view at all 
Rather, it 1s best to perform query modlficatlon, and retrieve the result from the base relations usmg 
a good access plan selected by the query optlrmzer An important example of this 1s for large views (e 
g the ED view on EMP and DEPT) and quenes that always retrieve a sm- gle record When this example was 
modeled usmgf =I, 1=1, and f,= l/(number of tuples m the mew), it was found that query modification nearly 
always outperforms materlahzmg the view m advance If f, is large, and P is not extremely hgh, then it 
becomes desirable to maintain views m matenahzed form. Higher values of P, fv, and 1 favor deferred view 
mamtenance over the unme&#38;-ate scheme Conversely, d P 1s low, nnmetiate view maintenance has a shght 
advantage over deferred maintenance An mterestmg phenomenon observed was that nnmedlate and deferred 
view maintenance have very nearly equal cost for Models 1 and 2, espe- cially for low values of P The 
reason for this 1s that the advantages and disadvantages of deferred view maintenance 1s that fewer disk 
mtes to the stored copy of a view must be per- formed than m immediate view maintenance The reason for 
this 1s that tiangle amquahty holds for the Yao function, whch 1s a mam determmant of the number of writes 
to the view More pre-cisely, ybm,a+b) 5s y(n,m,a)+y(n,m,b) for all a, b >0 On the other hand, the advantage 
of nnmedlate view maintenance 1s that less over-head is usually required to mamtam the A and D sets, 
smce they usually ml1 not have to be wrrtten to &#38;sk (they should fit m the buffer pool except for 
transactions that update a large fraction of the database) In deferred view mamtenance, the A and D sets 
must be wrrtten to disk, since they may live for more than one transaction Reducing or increasing the 
overhead of mamttumng A and D m either algorithm could give that algorithm an overall performance advantage 
Also, a valuable strategy 1s available to deferred view mamtenance that cannot be used m the immediate 
scheme If there 1s idle CPU and disk tnne available, it 1s likely to be useful to put it to work refreshmg 
mews asynchronously This would nnprove the response time of view queries m some sltuatlons smce the mews 
would not have to be refreshed first It would also allow update transactions to be completed more quickly 
than using unmedlate view mamtenance, smce the view would not have to be updated wlthm the transac-tion 
The evaluation of the usefulness of optlm- zatlon 1s an interesting topic for future study This paper 
has shown that the performance benefits of dlfferentlal view update algorithms relative to query mohfication 
are greater for two-way Join views (Model 2) than for simple res-trlctlons (Model 1) This 1s due to the 
natural clustering of Mew tuples on a single disk page that occurs when the view 1s materialized m advance 
The performance benefits of view mamtenance algonthms are likely to be even greater for mews Joining 
three or more relations Also, one could speculate that the most significant applications of incremental 
view update may not be related to processing queries against views, since ths study has shown that query 
modification 1s still quite effective Rather, view matermhzatlon Ilnght have a greater impact m apphcatlons 
where a complete copy of the answer to a query 1s always needed For example, materlahzatlon could support 
condltlons for com- lex tnggers and alerters, as described m PBune79] As another example, it could be 
used as a basis for a mndow on a database facility, where the result of a query would be displayed and 
updated m real tune Finally, the performance of different view materlahzatlon schemes depends slgmficantly 
on the database and view structure, and the dlstnbu-tlon of queries and updates Thus, an interestingtopic 
for future research would be to devise an adaptive method to choose the appropriate view materlallzatlon 
algorithm Future lmplementatlon and emplrlcal testing of immediate and deferred view maintenance are 
also needed to help gam a fuller understanding of the tradeoffs involved References <RefA>[AdlbBO] Adlba, M 
E and B G Lmdsay, Database Snapshots , Proceedwags of the Internatzonal Conference on Veqj Large Data 
&#38;es, October 1980, 86-91 [k-a831 Agrawal, R and D J Dewitt, UpdatmgHypothetical Data Bases , hformatzon 
Processang Letters 16 (April 1983), 145 146, North Holland [ Blak86] Blakeley, J A, P Larson and F W 
Tompa, Efficiently Updatmg Materialized Views , Proceedzngs of the 1986 ACiWSIGMOD Con$erence on Management 
at Data, Washmgton DC, May 1986, 61-71 [Bloo70] Bloom, B H , Space/Time Trade-offs m Hash Codmg Hnth 
Allowable Errors , Comm of the ACM 13, 7 (July 1970) [Bune79] Buneman, 0 P and E K Clemons, Efficiently 
Momtormg Relational Databases , ACM l+ansactaons on Database $ystems 4, 3 (September 1979), 368-382 [Card751 
Cardenas, A F , Analysis and Performance of Inverted Data Base Structures , &#38;mm of the ACM 18, 5 
(May 1975), 253-263 [Horw86] Homtz, S and T Teltelbaum, Generating Editing Environments Based on Relations 
and Attributes , ACM Iptansactaons &#38;ogrammzng Languages and &#38;tyems 8 , 4 (October 1986), 577-608 
[ Lmd86] Lmdsay, B G , L Haas, C Mohan, H Pn-ahesh and P Wllms, A Snapshot Dlfferentlal Refresh Algorithm 
, fioceedzngs of the 1986 ACM-SIGMOD InterruztaonaL Conference on Management of Beta, June 1986, 53-60 
[Rous86] Roussopoulos, N and H Kang, Principles and Techniques in the Design of ADMS+ I- , Corn*ter, 
December 1986 [Sell791 Selinger, P , et al, Access Path Selectlon in a Relational Database Management 
System , Froceeclzngs 0.f the 1979 ACMSIGMOD Internatzonal Conference on Management of Data, Boston, 
MA, June 1979 [Se11861 Sellis, T , Global Query Optlrmzatlon , Proceedwzgs of the 1986 ACM-SIGMOD hzternutzonal 
Conference $gyo;ment of Data 15, 2 (June 198ir [ Seve76] Severance, D and G Lohman, Differential Files 
Their ApplFcatlon to the Maintenance of Large Databases , ACM ikansactaons on Database Systems 1, 3 (September 
1976), 256-267 [ Ston75] Stonebraker, M , Implementation of Integrity Constraints and Views by Query 
Modlficatlon , Proceedwags of the 1975 ACM-SIGMOD Internataonal ConJ erence on Management of Data, San 
Jose, CA, June 1975 [ Ston86] Stonebraker, M , T Selhs and E Hanson, An Analysis of Rule Indexing Implementations 
m Data Base Systems , Proceedangs of the first Annual Conference on E&#38;pert LWabase Systems, Charleston 
SC, April 1986 [Wood831 Woodfill, J and M Stonebraker, An Implementation of Hypothetlcal Relations , 
Proceedwzgs of the h%nth Very Large Data &#38;se Conference, Florence, Italy, December 1983 [Yao77] Yao, 
S B, Approxnnatmg Block Accesses m Database Orgamzatlons , Cbmm of the ACM 20, 4 (April 1977)</RefA> Append 
A The method presented m [Blak86] for deter-mmmg how to refresh the view when both dele-tions and msertlons 
occur 1s slightly different than the one shown here, and 1s m fact not always correct Using the scheme 
of [Blak86], the ex-pression below would be used to refresh the view V, = ~r~(u~(R~xR~ u A,xA2 u A,xR, 
u R,xA2 -D,xD2-D,xR2-RlxDz)) Using this expression can cause improper update of the duplicate counts 
For example, suppose tu-ples t , m R, and t 2 in Rz Jomed together to pro-duce a result tuple m V, If 
a transaction deleted both t, and t,, then the result of Jommg t, to t2 would be deleted from Vo three 
times, not Just one as it should This happens since t 1 1s m both R1 and D,, and t, 1s in both R2 and 
D2 The formula- tion given m this paper (using R, =R1-D, and Rz =Rz-Dz> does not have this problem Append 
B Given that there are n total records on m blocks, a formula givmg the expected number of blocks that 
ml1 be accessed to modify k records 1s as follows [Yao77] Let c be the number of ways that b items can 
be selected from a items (a;rb) If the number of records per block 1s p =n/m, then the formula glvmg 
the expected number of block accesses 1s c-P/ I$ An approxnnation to the above that is very close if 
the blocking factor is large (e g n/m>lO) 1s m(l-(i-l/m)k) [ Card751 The notation y (n,m,k) 1s used to 
represent the Yao function 
			

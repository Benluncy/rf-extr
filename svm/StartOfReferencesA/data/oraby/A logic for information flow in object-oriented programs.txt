
 A Logic for Information Flow in Object-Oriented Programs Torben Amtoft Sruthi Bandhakavi Anindya Banerjee 
Department of Computing and Information Sciences Kansas State University, Manhattan KS 66506, USA {tamtoft,sruthi,ab}@cis.ksu.edu 
Abstract This paper speci.es, via a Hoare-like logic, an interprocedural and .ow sensitive (but termination 
insensitive) information .ow anal­ysis for object-oriented programs. Pointer aliasing is ubiquitous in 
such programs, and can potentially leak con.dential information. Thus the logic employs independence 
assertions to describe the noninterference property that formalizes con.dentiality, and em­ploys region 
assertions to describe possible aliasing. Programmer assertions, in the style of JML, are also allowed, 
thereby permitting a more .ne-grained speci.cation of information .ow policy. The logic supports local 
reasoning about state in the style of separation logic. Small speci.cations are used; they mention only 
the variables and addresses relevant to a command. Speci.cations are combined using a frame rule. An 
algorithm for the computation of postconditions is described: under certain assumptions, there exists 
a strongest postcondition which the algorithm computes. Categories and Subject Descriptors F.3.1 [Theory 
of Computa­tion]: Logics and Meanings of Programs Specifying and Verify­ing and Reasoning about Programs 
General Terms Security, Languages, Theory, Veri.cation. Keywords aliasing, information .ow, con.dentiality. 
1. Introduction An information .ow policy, concerned with protecting con.den­tiality of data, must ensure 
that during program execution, data does not .ow to a channel unauthorized to receive the data [10]. 
The typical setting for checking con.dentiality of data involves chan­nels with different clearance levels1, 
e.g., High for sensitive/private channels and Low for public channels, and a program that manipu­lates 
data arriving at input channels (with different clearance levels) and produces results that may .ow into 
output channels (with dif­ferent clearance levels). In this setting, con.dentiality of data can be assured 
provided that, during program execution, data meant for High output channels do not .ow into Low output 
channels. Co­hen [14] advanced an equivalent, deductive formulation for assur­ing con.dentiality: from 
the text of the program, and by observing only the data in Low output channels (hereafter called Low 
outputs) 1 In general, these levels form a security lattice, with Low = High. Permission to make digital 
or hard copies of all or part of this work for personal or classroom use is granted without fee provided 
that copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice 
and the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute 
to lists, requires prior speci.c permission and/or a fee. POPL 06 January 11 13, 2006, Charleston, South 
Carolina, USA. Copyright c . 2006 ACM 1-59593-027-2/06/0001. . . $5.00. an attacker cannot deduce any 
information about the data in High input channels (hereafter called High inputs). In other words, for 
con.dentiality to hold, Low outputs must not depend on High in­puts in any way. It is this notion of 
independence that is explored in this paper in the context of object-oriented programs. Here are some 
simple examples that illustrate whether or not a program satis.es con.dentiality. In each example, the 
variable l is a Low output and the variable h is a High input. First, the assignment l := h violates 
con.dentiality directly due to the data .ow from h to l. Second, the conditional if h > 0 then l := 1 
else l := 0 violates con.dentiality indirectly due to control .ow: while nei­ther assignment by itself 
violates con.dentiality, information as to whether or not h > 0 is revealed by whether or not l is 1 
after the execution. In contrast, the command l := h ; l := 0 satis.es con.­dentiality although it has 
a subpart that does not: no deductions can be made about the input value of h from the output value of 
l, since the latter is always 0. Information .ow analysis has been used to statically certify[15] that 
con.dentiality holds in all possible execution paths of a pro­gram. Typical information .ow analyses, 
surveyed by Sabelfeld and Myers [24], are often speci.ed using security type systems [26, 19, 22, 6, 
18]. The security guarantee provided by a well-typed pro­gram is this: no High inputs will .ow to Low 
outputs either directly, via data .ow, or indirectly, via control .ow, during program execu­tion. The 
type systems mentioned above, except for the recent [18], are .ow insensitive, and this is a source of 
imprecision. Indeed, such type systems reject all the example programs above, including the benign one, 
for they require every subprogram be well-typed whether or not it contributes to the .nal answer. The 
subprogram, l := h, in the benign example, fails to type. Extant security type systems for object-oriented 
programs [6, 19] have yet another source of imprecision that arises due to the way aliasing is handled. 
In object-oriented programs, .elds of a class in addition to program variables are annotated with se­curity 
levels. However, if an object is assigned to a High variable, then the Low .elds of the object cannot 
be updated [6, 19]. Thus the .eld update, z.info := 42, is rejected by the security type sys­tem in case 
info has level Low and z has level High. The reasoning is as follows: consider two Low variables, p and 
q, which are as­signed objects o1 and o2 respectively. Now consider the command if h > 7 then z := p 
else z := q which appears secure since a High variable is updated under a High guard. However, depending 
on h, either z and p are aliases of o1,or z and q are aliases of o2.A subsequent update of z s info .eld 
will reveal information about h: if q.info is not 42 after the .eld update, we know that h > 7 holds. 
A similar reasoning requires a method call like x.m(y) to update only High .elds in the body of method 
m, in case the receiver x is High. Such reasoning, while sound, is imprecise: aliasing may not be present 
at all, in which case, both the .eld update and the method call is benign. Our challenges are twofold. 
First, we prefer a .ow sensitive speci.cation of information .ow analysis. We also want to han­dle pointer 
aliasing in a manner that is more precise than extant approaches which do not perform any alias analysis. 
The second challenge is to obtain a modular speci.cation for an interprocedural information .ow analysis. 
(Ideally, this would allow us to obtain a static checker for information .ow). To be speci.c, we want 
our analysis to be compositional in the state.2 We want local reasoning about the heap where aliasing 
happens; this means that when we analyze a command, we are only allowed to consider the footprint of 
the command on the state, i.e., we can only consider the variables and parts of the heap that are used 
by the command [21, 23] nothing else. Contributions. The primary contribution of this paper is to meet 
both of the above challenges by specifying an interprocedural in­formation .ow analysis using a Hoare-like 
logic. Assertions in the logic are stateful and describe aliasing properties region asser­tions as 
well as information .ow properties independence as­sertions. To reason about outgoing method calls in 
method bodies, we require method summaries to provide a contract about asser­tions that must be met before 
a call and assertions that must hold after a call. Importantly, the logic uses fundamental ideas from 
separation logic [21, 23] to provide local reasoning about state. As we clar­ify in the sequel, speci.cations 
in the logic are small or local: the intuition is that these speci.cations convey the bare essence of 
reasoning about a command. The reasoning can be elaborated in different contexts, and larger speci.cations 
may be obtained by way of a frame rule. Indeed, with region and independence assertions, our speci.cation 
yields an interprocedural static checker for infor­mation .ow. Our second contribution is to extend the 
logic with program­mer assertions so that a more .ne-grained speci.cation of informa­tion .ow policy 
can be obtained. Programmer assertions can take the form x is a constant , or variables x and y are equal 
, or x = k(y) , where k is a mathematical function: such assertions are also allowed, e.g., in JML [12]. 
In contrast to region and inde­pendence assertions, however, programmer assertions may require runtime 
checking or veri.cation by a theorem prover. We show ex­amples of the use of programmer assertions in 
concert with region and independence assertions for verifying observational purity [7] and for demonstrating 
selective dependency [14]. Nevertheless, we do not have an automatic checker in the presence of programmer 
assertions. At some points in the checking process, logical impli­cations need to be decided. We do not 
know whether there exists a useful proof system to decide the logical implications. But we provide a 
few simple heuristics to ease the burden of checking. A minor contribution of the paper is concerned 
with complete­ness issues for the logic with assertions restricted to region and independence assertions 
only. For this sub-logic, we give an algo­rithm that computes postconditions from preconditions and show 
that, under certain extra assumptions, the sub-logic is complete: there exists a strongest postcondition 
that the algorithm computes3. Alas, the algorithm is non-modular. The main dif.culty lies with interprocedural 
analysis, for which the procedure summaries must be discovered and updated on the .y. We leave this issue 
for a fu­ture paper. 2 It is not compositional reasoning per se we are interested in, since it is perfectly 
possible to be compositional and global (in the state) at the same time, as was the case in early denotational 
models of imperative languages [21]. 3 By strongest postcondition we mean the strongest among the assertions 
accepted by our logic, rather than the strongest among the assertions which are semantically correct 
(a larger set). 2. Examples Local Reasoning about Aliasing. Recall that local reasoning about a command 
entails reasoning only about the footprint of the command. In the command, z.info := 42, for example, 
reason­ing is permitted only with variable z, the location in the heap that z denotes, and the contents 
of the info .eld nothing else. Since we are interested in static checking, we need to abstract the concrete 
heap location denoted by z. Abstract locations (as in, e.g., [20]) are used to abstract sets of concrete 
heap locations. A region assertion x . L, read x at L , asserts that L abstracts the concrete location 
denoted by x. Suppose two abstract locations L1 and L2 are disjoint, i.e., they abstract two disjoint 
sets of concrete locations. Then, if x . L1 and y . L2 hold, we infer that x, y must not alias a concrete 
location. (In contrast, if L1, L2 are not disjoint, then x, y may alias). Region assertions may also 
take the form L1.f . L2,so as to deal with aliasing caused by heap-allocated values, e.g, x.f . The intuition 
is that for any concrete location £1 that is abstracted by L1, if .eld f of £1 contains concrete location 
£2, then £2 is abstracted by L2. We now show two examples in which region assertions are used to reason 
locally about aliasing. Consider a method getNode which, given the head of a linked list and an integer 
i, returns the node at position i in the list. Each node has two .elds: data denoting the value in the 
node, and next denoting the next node in the list. We consider two implementations of getNode: in the 
.rst, a pointer to the ith node is returned, creating an alias; in the second, a copy of the ith node 
is returned this does not create an alias. The bodies of getNode for the two implementations are shown 
below; the distinguished variable, result, holds the return result of a method. n := head; j := 0; while 
(n = null)&#38;&#38; (j < i) do {n := n.next; j := j +1; }result := n Example 1: Node i is aliased n 
:= head; j := 0; while (n = null)&#38;&#38; (j < i) do {n := n.next; j := j +1; } if n = null then 
{newNode := new Node; newNode.data := n.data; newNode.next := null; result := newNode; } else {result 
:= null} Example 2: Node i is not aliased Consider the .rst two commands of Example 1, where we assume 
that L is the abstract location in which the list is allocated. Because head points to the .rst node 
in the list, head . L is part of the precondition of the program, which also contains the assertion L.next 
. L. For the command n := head, we get the small speci.cation: {head . L} n := head {n . L} The speci.cation 
says that from precondition head . L, the post­condition n . L can be asserted. Note how the region assertions 
in the speci.cation mention facts about head and n, nothing else. Next, for the command j := 0, we get 
the small speci.cation4 {true} j := 0 {j . int} . To combine the speci.cations for the two commands above, 
we use, in a manner similar to separation logic, a frame rule (also see [11]): because n is not modi.ed 
by 4 The assertion j " int, expressing that j has an integer value, is strictly speaking redundant, since 
we shall assume that we are dealing with well­typed programs where a variable/.eld may contain an integer 
iff it has been assigned the type int. Therefore such assertions may be omitted. j := 0, the frame rule 
allows us to add nL as conjunct to both its pre-and postconditions. To wit: {nL} j := 0 {j int,nL} Now 
the two speci.cations can be combined to obtain the following speci.cation for the sequential composition, 
n := head; j := 0. {head L} n := head; j := 0 {j int, nL} The invariant for the while loop is {nL,L.next 
L}, which we may write in abbreviated form as {(n,L.next) L}. To show that the preamble establishes this 
invariant from the program s precondition, we may apply the frame rule once more on the above speci.cation, 
adding L.next L to both pre-and postcondition; this is valid since no next .eld is modi.ed by the preamble. 
Thus: {(head,L.next) L} n := head; j := 0 {(n,L.next) L} To show that the invariant is maintained by 
the while loop, we show the stronger property that each assignment in the loop body maintains the invariant. 
For n := n.next the small speci.cation is {(n,L.next) L} n := n.next {nL} . Now the frame rule (applicable 
since no next .eld is modi.ed) gives us {(n,L.next) L} n := n.next {(n,L.next) L} In a similar (but simpler) 
way, we can show {(n,L.next) L} j := j +1 {(n,L.next) L} . Finally, for result := n, the small speci.cation 
is {nL} result := n {result L} By a few more applications of the frame rule, we obtain the follow­ing 
speci.cation for the body, B1,of getNode. {(head,L.next) L} B1 {(n,L.next,result) L} As expected, n and 
result may alias the same location in the heap. In Example 2, the precondition for the entire method 
body, B2, of getNode is the same as that of B1, namely, (head,L.next) L. The crucial difference is the 
occurrence of the command newNode := new Node where we may choose an arbitrary abstract location to abstract 
the concrete location being created. Choosing L1, we get the small speci.cation {true} newNode := new 
Node {newNode L1} . Applying the frame rule repeatedly, we can derive postcondition5 {(n,L.next) L,(result,newNode) 
L1,L1.next .} for B2. The key observation is that provided L and L1 are disjoint, n and result must not 
alias the same location in the heap. Information Flow Analysis and Independences. A baseline cor­rectness 
property for information .ow analysis is noninterfer­ence [17] (the negation of Cohen s notion of dependency 
[14]) which is formalized via an indistinguishability relation on states. Two states are indistinguishable 
if they agree on values of their Low variables (but may differ on values of High variables). Noninter­ference 
holds if any two runs of a program starting in two initially indistinguishable states, yield two .nal 
states that are also indistin­guishable. In other words, a program is noninterfering, if for any pair 
of runs, changes to its High input variables are unobservable via its Low output variables; hence, reverting 
to a point made in the introduction, Low outputs are independent of High inputs. The small speci.cations 
of our analysis are designed to answer the following question, encompassing noninterference as a special 
case6: given two runs which initially agree on variables x1 ...xn , will they at the end agree on variables 
y1 ...ym ? Accordingly, 5 The abstract location . abstracts null pointers only. 6 As can be seen by letting 
x1 ...xn , and y1 ...ym , be the Low variables. we introduce independence assertions of the form xK, 
such that a positive answer to the above question amounts to the speci.cation {x1K,...,xn K} {y1K,...,ym 
K} . In general, we shall con­sider assertions of the form aK, where a is an abstract address: either 
a variable, or a .eld access of the form L.f . Leveraging the above reading of noninterference, Amtoft 
and Banerjee speci.ed, as a Hoare-like logic, a termination insensitive information .ow analysis for 
simple imperative programs [2] (later extended to a termination sensitive analysis [3]). This paper ex­tends 
that logic to handle programs written in a core, Java-like, object-oriented language. Also, unlike [2, 
3], this paper employs a standard style semantics. Aliasing, Independences and Local Reasoning. We consider 
the following example adapted from Askarov s master s thesis [4]. class X { int q; int getQ(){result 
:= self.q}; unit setQ(int n){self .q := n}} What can we say about the body of getQ? First, we consider 
region assertions. Suppose assertions self .1 and .1.q int hold for the precondition of getQ. Then we 
can assert that result int holds in the postcondition of getQ. Think about .1 as a metavariable which 
will be instantiated by abstract locations at the point of call. For instance, if the receiver in the 
call to getQ is at abstract location L, then .1 will be substituted by L. Next, we consider independence 
assertions. Given that self .1 holds for the precondition of getQ, we want to check whether the postcondition 
contains resultK. That is, under which condi­tions will two runs agree on the .nal value of result? For 
that to be the case, the runs must agree on the initial value of self .q, a suf.­cient condition for 
which is that .1.q. holds in the precondition; also (since self .q depends on self ), the runs must agree 
on self .A convenient method summary for getQ is thus the following {self .1,self K,.1.qK} getQ {result 
K} . On the other hand, if the independence assertions in the precon­dition do not hold at the point 
of call, we are unable to conclude result. in the postcondition. In a similar manner, we can compute 
the following method summary for setQ: {self .1,self K,nK,.1.qK} setQ {.1.qK} This says that in order 
for two runs to agree on the .nal value of the q .elds of corresponding (as formalized in Sec. 4) objects 
abstracted by .1, they must agree on the initial value of n, and on the initial value of self (as otherwise, 
the two runs would update non-corresponding objects). Also, because there may be other objects abstracted 
by .1 than the one which self points to (and these objects did not have their q .eld updated), the runs 
must agree on the initial value of all q .elds; this requirement can be omitted in the case where .1 
abstracts one concrete location only, i.e., in the case of strong update . Now consider the program Xx1; 
Xx2 := new X ; x1 := x2; //alias created x1.setQ(secret); z := x2.getQ() where, because x1 and x2 are 
aliases, the value of secret is leaked to z. Let us see how checking independences might help detect 
the leak. We recall what noninterference means: two runs that initially agree on all variables except 
for secret, must agree on the .nal value of z. A proof of noninterference, in our framework, would thus 
amount to establishing a speci.cation where z. is in the postcondition, without having to assume that 
secretK is in the precondition. Below, we argue that this is impossible. First assume that the location 
allocated by new is abstracted by L2; then we have x2 L2 and x1 L2. With the aim of proving that zK holds 
after the call to getQ, we consult the method summary for getQ where we substitute self by x2, and result 
by z, and .1 by L2. Looking at the resulting precondition, we see that we must show that x2K and L2.qK 
holds before the call to getQ, that is, after the call to setQ. We therefore consult the summary for 
setQ where we substitute self by x1, n by secret, and .1 by L2. Looking at the resulting precondition, 
we see that we must at least show that secret K holds. But this yields the desired contradiction. Suppose 
the aliasing were removed in a slight modi.cation of the above program, where z is once again the output 
variable: Xx1 := new X ; Xx2 := new X ; //no alias x1.setQ(secret); z := x2.getQ() Now x1 and x2 do not 
alias the same heap location. The postcon­dition for the .rst assignment asserts {x1 L1, x1K}, and that 
for the second asserts {x2 L2, x2K}, where L1 and L2 are assumed disjoint to re.ect the absence of aliasing. 
As before, to establish that zK holds after the call to getQ, we must show that x2K and L2.qK holds after 
the call to setQ. But since locations abstracted by L2 are not modi.ed by the call to setQ, this follows 
from the frame rule (since we may assume that L2.qK holds before the call). In summary, because of the 
absence of aliasing, the assertion zK does hold .nally, even if secretK does not hold initially. This 
is in contrast to the previous example. It is instructive to see how an existing type-based information 
.ow analysis system, like Jif [19], handles the above programs. Assume that the variables secret and 
x1 are typed High, and x2 and .eld q are typed Low. Since q is Low, the method setQ has a begin label 
of Low, which says that the method can only be called if the program counter of the caller is no more 
restrictive than Low. But the level of the receiver (x1)is High. This is one reason why Jif rejects this 
program. In general, the above check ensures that if there are any low aliases of x1 in the future e.g., 
x2 in the .rst program they should not be able to read the value of q assigned by setQ. In the second 
example there is no aliasing. Yet, Jif rejects this example also, because the call to setQ is untypable. 
Programmer assertions. As noted earlier, apart from region as­sertions and independence assertions, we 
also allow programmer assertions in code. For example, for the trivial program if x > 0then w := 7else 
w := 7, clearly wK holds (two runs will always agree on the .nal value of w), although a na¨ive analy­sis 
cannot prove the assertion. However, armed with the program­mer assertion that w is a speci.c constant 
after the conditional, the following reasoning is sound in our framework: w being constant logically 
implies (de.ned in Sec. 4) that wK holds. We show two more examples of programmer assertions. The .rst 
concerns observational purity [7]. Assume we repeatedly need to apply a function expensive(z), the computation 
of which is very expensive. To save time, we decide to memoize the most recent call7. For that purpose, 
we introduce a class M , with .elds marg and res obeying the invariant (marg ) . (res =0=expensive(marg)) 
and with a method int cexp(int z){ if z = self.marg then result := self.res else //compute expensive(z) 
and store the value in result result := expensive(z); self.marg := z; self.res := result assert (result 
= expensive(z))} 7 The generalization to full memoization appears in Sec. 6. Obviously, the last assertion 
should not be checked at runtime (this would defy the purpose of memoization), but might instead be veri.ed 
by a theorem prover, using the above-mentioned invariant. Suppose we know that for cexp: (a) its result 
depends only on z, not on memo data (marg or res) and (b) its computation affects only an abstract location 
L1.If L1 is not used elsewhere, we can consider calls to cexp observationally pure [7]; this notion of 
purity is under consideration for extending JML [12] which currently disallows effectful method calls 
in assertions. It remains to show (a) and (b). Indeed, in Sec. 4.1, we will see that from zK and the 
programmer assertion, result = expensive(z), we can derive resultK. Hence it is easy to see that if self 
L1 and zK are preconditions for cexp, then resultK is a valid postcondition for cexp. We also observe 
that L1.marg and L1.res are the only abstract addresses that may be modi.ed by cexp. This information 
appears in the following method summary for cexp: {self L1, zK} {result K} [L1.marg, L1.res]. Our second 
example with programmer assertions deals with se­lective dependency and we consider an example due to 
Cohen [14]: the command b := x +a mod 4where, clearly, b is not indepen­dent of a. However, only the 
lower order two bits of a are revealed to b; nothing else is revealed. Suppose we .x the lower order 
two bits of a to 3, i.e., a mod 4=3. Then we can prove that the rest of a is protected from b , by means 
of the derivation8 {xv} assert a mod 4= 3; {a mod 4=3, xv}{(a mod 4)v, xv} (by logical implication) b 
:= x + a mod 4; {bv} That is, bK is in the postcondition, under the assumption that xK is in the precondition, 
but without assuming that aK is too. The Rest of the Paper Sec. 3 formalizes the language. Sec. 4 gives 
the syntax and seman­tics of assertions. Sec. 5 speci.es the logic. The full memoization example, illustrating 
reasoning in the logic, appears in Sec. 6. Sec. 7 is about the computing of assertions and strongest 
postcondition. Sec. 8 concludes. All proofs appear in the companion technical re­port [1].  3. Language: 
syntax and semantics Syntax. Our core language (Figure 1) is a class-based object­oriented language with 
recursive classes, methods and .eld update. To avoid clutter, unlike the technical report [1] we do not 
consider subclassing (and thus neither dynamic dispatch, nor cast, nor type test). The grammar is based 
on given sets of class names (with typ­ical element C ), expressions (E), constants ranging over integers 
(c), .eld names (f ), and method names (m). The names x, y, z, w are used for program variables, and 
k is used for mathematical functions (e.g., mod). The BNF is self-explanatory. One difference from usual 
security­typed languages is that programmer assertions are allowed via the command assert .. Conjunctions 
and disjunctions of programmer assertions are also allowed. A type is either a base type int,ora class 
type , i.e., a class name C ; like Java, we have nominal (by name) typing. We assume a function, type, 
that assigns a type to all program variables and to all .elds. We also assume the existence of a class 
table, CT , that maps a class name to the corresponding class declaration. A class declaration consists 
of a class name, e.g., 8 The technical development in this paper does not allow assertions Ev with E 
an expression, but it is straightforward to add them. T ::= int | C data type CL::= class C { Tf ; M 
} class declaration M ::= Tm(Uu) { S} method declaration S ::= x := E | x.f := y assign to variable, 
to .eld | x := new C | x := y.f object construction, .eld access | x := y.m(z) | S ; S method call, 
sequence | if x then S else S | while x do S conditional, while | assert . programmer assertion E ::= 
x | c | null | E op E | k(E) variable, constants, arith. operations, arith. functions . ::= x = c | x 
= y | x = k(E) | ... primitive assertions | . . . | . . . Figure 1. BNF of language C , together with 
a list of public .eld declarations, e.g., Tf , and a list of method declarations, e.g., M . Consider 
a method m declared as Tm(Uu) {S} in class C ; such a method has return type T , and formal parameter 
type U , and body S where S is a command. We employ a distinguished variable result such that the effect 
of an explicit return expression, return E, can be achieved by letting the last assignment of S be result 
:= E. We will assume that only well-typed programs are checked. Semantics. We specify the semantics in 
relational style; such a semantics .ts well with a Hoare-style partial correctness speci.ca­tion and 
eases the proofs, especially since our analysis is termina­tion insensitive. After a brief description 
of the semantic domains involved, we de.ne the semantics of commands and .nally the se­mantics of well 
formed class tables. The state of a method in execution comprises a store, s, and a heap, h. A store 
s (in semantic domain Store) assigns values to local variables and parameters, where values are integer 
constants or locations or the distinguished entity nil (which is not a location). We use v to range over 
values, and assume that Val, the set of all values, is partitioned into two disjoint parts, True and 
False.For locations, we assume given a countable set Loc ranged over by £. We assume each location £ 
has a class C associated with it, and write type £ = C . For all constants c we write type c = int.For 
each type, we de.ne a default value of that type: default(int)=0 and default(C )= nil. A heap h (in semantic 
domain Heap) is a .nite partial function from locations to object states, where an object state is a 
total mapping from .eld names to values. With abuse of notation, we say that location £ is in the range 
of heap h if there exists location £0 in dom(h) and a .eld f such that £ = h £0 f . We will work with 
self-contained states: say that state (s, h) is self-contained iff (a) for all £ in the range of s, £ 
is in the domain of h; and (b) for all £ in the range of h (c.f. above), £ is in the domain of h. The 
meaning, [[E]], of an expression, E, is a function from Store to Val; its de.nition is standard and thus 
elided. Pointer arithmetic is disallowed: in an expression E1 op E2, each [[Ei ]]s has to evaluate to 
an integer. The meaning of an assertion . is a predicate on states: [[.]] . Store × Heap . Bool. The 
semantics of a class table is a method environment µ which provides a relational meaning, µ(C , m), for 
each method m de­clared in class C . The method environment µ is computed using a .xpoint construction. 
For each class C and method name m, µ(C , m) . (Store × Heap) × (Val × Heap). Because a command S may 
contain method calls as con­stituents, the meaning of S is with respect to a method environ­ment µ. More 
precisely, [[S]]µ is a relation on input and output states: [[S]]µ . (Store × Heap) × (Store × Heap). 
The relational semantics of commands appears in Table 1. We explain the cases [FieldUpd], [New] and [MethodCall] 
below. In .eld update, x.f := y, the heap h0 is updated with the value of y at .eld f of location £, 
where £ is the meaning of x. (We use the notation [h0 | £.f ..v] to denote the update of the object state 
h0 £ at .eld f by v). In object allocation, x := new C , a fresh location £ of type C is allocated in 
the heap; the resulting store maps x to £. The resulting heap, h, is the old heap, h0, with its domain 
extended with £. Each .eld f of C in the object state h £ is initialized to the default value of type(f 
); this is captured by the notation [h0 | £ . . defaults]. For a method call, x := y.m(z), suppose that 
y denotes a location £ with type £ = C , where class C contains a method m with formal parameter u (written 
pars(m, C )= u). Let the initial state be (s0, h0), and suppose that the meaning of the method m is looked 
up in method environment µ, using a state whose heap component is h0 but whose store component is a local 
store , s0. , that binds self to £ and u to s0(z). Let the method meaning relate (s0. , h0) to (v, h), 
where v is the return result of the method, and h the updated heap. Upon return, local store s0 . is 
discarded, and the resulting state is heap h together with the initial store, s0, with x updated to v. 
Observe that for some (s0, h0) there may be no (s, h) with (s0, h0)[[ S]]µ](s, h). This will be the case 
in the event of an in.nite computation, a run-time error (like dereferencing a null pointer), or a failed 
programmer assertion. We are now ready for the semantics of a class table, CT . The semantics makes explicit 
the .xpoint computation alluded to earlier. DEFINITION 3.1 (Semantics of class table, CT ). [[CT ]] is 
the least upper bound (wrt. subset inclusion) of the ascending chain µn (n . Nats) of method environments, 
de.ned as follows (where class C contains method m with body S): µ0(C , m)= Ø (s0, h0)(µn+1(C , m)) (v, 
h) .. . s · (s0, h0)[[ S]]µn ](s, h) . (v = s(result)) Letting µ =[[CT ]], a key lemma is that for all 
self-contained states (s0, h0),if (s0, h0)[[ S]]µ](s, h) holds then (s, h) is self-contained with dom(s0 
) . dom(s) and dom(h0 ) . dom(h). In the sequel, we will tacitly assume that all states (s, h) are self-contained. 
Modi.cation of state. Sec. 2 presented several examples of lo­cal reasoning that were justi.ed by the 
frame rule. Such reasoning is sound because a side condition holds for the frame rule: when the small 
speci.cation of a command is extended with other asser­tions, the abstract addresses mentioned in the 
assertions are disjoint from the corresponding abstract addresses modi.ed by the com­mand. Both notions 
are made precise in Sec. 4. But .rst De.ni­tion 3.2 states precisely what it means to modify concrete 
locations occurring in heaps and stores. DEFINITION 3.2. For a location £ of type C , and for a .eld 
f of C , say that £.f is modi.ed from heap h to heap h. if £ . dom(h') and either of the following conditions 
hold: (a) £ . dom(h), and h'£f = h£f ; (b) £ . dom(h), and h'£f = default(type f ). Variable x is modi.ed 
from store s to store s . if x . dom(s ') and either of the following conditions hold: (a) x . dom(s), 
and s(x)= s '(x); (b) x . dom(s).  4. Assertions This section formalizes abstract locations, and provides 
the syntax and semantics of assertions. It also makes precise the two main [Assert] [FieldAcc] [New] 
(s0, h0)[[ assert .]]µ](s, h) .. [Assign] [[.]](s0, h0). s = s0 . h = h0 (s0, h0)[[ x :=y.f ]]µ](s, 
h) .. .£ . Loc · (s0(y)= £ [FieldUpd] . s =[s0 | x . h0 £ f ]) . h =h0 (s0, h0)[[ x :=new C ]]µ](s, 
h) .. . £ · (type £ =C . £ . rng(s0). £ . dom(h0 ) . £ . rng(h0). [MethodCall] s =[s0 | x . £]. h =[h0 
| £ . defaults]) (s0,h0)[[ x :=E]]µ](s, h) .. (. v · v =[[E]]s0 . s =[s0 | x . v]). h =h0 (s0,h0)[[ 
x.f :=y]]µ](s, h) .. s = s0 .. £ . Loc · (s0(x)= £ . h =[h0 | £.f . s0(y)]) (s0,h0)[[ x :=y.m(z)]]µ](s, 
h) .. (s0, h0)µ(C , m)(v,h). 's =[s0 | x. v] where £ =s0(y)and C =type £ ' and s=[pars(m, C ) . s0(z), 
self . £] 0 Table 1. Semantics of commands: excerpts. ingredients of the frame rule alluded to in Sec. 
2, namely, the modi.cation of abstract addresses, and disjointness. The frame rule can only be applied 
when an assertion is disjoint from the set of abstract addresses that may be modi.ed by a command. Abstract 
Locations. We let L range over the set of abstract lo­cations, AbsLoc. Think of L as a token that stands 
for a set of concrete heap locations. We will consider the following relations on AbsLoc: a partial ordering 
relation, L1 . L2, conveys that L2 contains at least those concrete heap locations that L1 contains. 
We also need a symmetric relation, L1 0 L2, pronounced L1 is dis­joint from L2 , to convey that L1 and 
L2 have no concrete heap locations in common. We add a special element . to AbsLoc so that for all L 
. AbsLoc we have .. L and .0 L. One can think of . as the counterpart of the concrete value nil. We assume 
that if L1 . L2 and L 0 L2 then also L 0 L1.We let LI range over AbsLoc .{int}. And, we let X range over 
sets of abstract addresses. Syntax of assertions As noted in Sec. 2, we have three kinds of primitive 
assertions, namely, region assertion, independence asser­tions, and programmer assertion. The BNF of 
assertions is this: f ::= . | x LI | L.f LI | xK | L.f K | true | f. f An assertion is thus a (possibly 
empty) conjunction of primitive assertions. Recall from Sec. 2 that we shall often use the set no­tation 
to denote conjunctions of assertions. For simplicity, this pa­per allows disjunction only in programmer 
assertions, although the technical report allows arbitrary disjunctions of assertions. Roughly, the meaning 
of xL in a state (s,h) is that the concrete heap location denoted by x is abstracted by L. The meaning 
of aK is that the two current states in question, say (s,h) and (s1,h1), agree on the value of a; agreement 
implies that there is no leak of information via a. This intuition leads to the one-state and two-state 
semantics for assertions in the sequel. One-state Semantics of Assertions. To give a precise meaning 
to assertions, we need to assume the existence of an extraction relation, ., (similar to the extraction 
functions described in [20, p.235]) that relates locations to abstract locations. We require that . satisfy 
the following properties: (a) If L1 . L2 and £.L1 then £.L2; (b) If L1 0 L2 then for no £we have £.L1 
and £.L2; (c) £.. holds for no £. For convenience, we extend . to Val , so that c .int and nil .. thus 
nil .L holds for all L. But c .L holds for no L, and £.int holds for no £, and nil .int does not hold. 
We say that .is over h if £.L implies £ . dom(h).For .over h, we are now in a position to de.ne the semantics 
of an assertion fin state (s,h), written, (s,h) |=. f. (s,h) |=. . .. [[.]](s,h) (s,h) |=. x LI .. s(x).LI 
(s,h) |=. L.f LI .. . £. dom(h) · £.L .  (h£f ).(LI ) (s,h) |=. xK .. true (s,h) |=. L.f K .. true (s,h) 
|=. true .. true (s,h) |=. f1 . f2 .. (s,h) |=. f1 and (s,h) |=. f2 Two-state Semantics of Assertions. 
Consider, e.g., the assertion ' xK and consider two states (s,h) and (s,h') for which we want the values 
of x to agree. If x denotes a location then, because of different allocation behavior in h and h', we 
cannot expect s(x) and s'(x)to be equal. Rather we expect the former to yield location £ and the latter 
to yield location £', so that the agreement can be enforced by a bijection ß that relates £ and £'. On 
the other hand, not all locations need to be related to some other location, similar to what is the case 
for type-based information .ow analysis [6]. ' There, the indistinguishability relation on states (s,h)and 
(s,h') is formalized using a bijection between those locations in dom(h) and dom(h')that are visible 
to a low observer . We formalize the above intuition. Let ß range over bijections from a subset of Loc 
to a subset of Loc. That is, if £ß£1 and £ß£2 then £1 = £2, but for some £0 there might not be any £' 
such that £0 ß£'; and if £1 ß£and £2 ß£then £1 = £2, but for some £0 there might not be any £' such that 
£' ß£0. In addition, with abuse of notation, for all integer constants c we shall assume that c ßc, and 
also assume that nil ßnil. We say that ß is over h&#38;h1 if £ß£1 implies £. dom(h)and £1 . dom(h1 ). 
We can now de.ne the two-state semantics of assertion f, writ­ten (s,h)&#38;(s1,h1) |= ß,.,.1 f. Here 
ßis over h&#38;h1, and .is over h, and .1 is over h1; further, if £ß£1 then £.L iff £1 .1 L. The last 
condition simply says that concrete locations £and £1 related by ß are abstracted to the same abstract 
location L by both .and .1. (s,h)&#38;(s1,h1) |= ß,.,.1 xK .. (sx)ß(s1 x) (s,h)&#38;(s1,h1) |= ß,.,.1 
L.f K .. . £. dom(h),£1 . dom(h1 ) · £ß£1 . £.L . (h £f )ß(h1 £1 f ) (s,h)&#38;(s1,h1) |= ß,.,.1 f .. 
 (s,h) |=. fand (s1,h1) |=.1 f,(f is .,xL,L.f LI ) (s,h)&#38;(s1,h1) |= ß,.,.1 true .. true (s,h)&#38;(s1,h1) 
|= ß,.,.1 f1 . f2 .. (s,h)&#38;(s1,h1) |= ß,.,.1 f1 and (s,h)&#38;(s1,h1) |= ß,.,.1 f2 Modi.cation of 
Abstract Addresses. We now specify the condi­tions under which an abstract address X is modi.ed from 
state ' (s,h)to state (s,h')under extraction relation .over heap h'. This is written, (s,h) . (s',h') 
|=. X . The abstract address X over­approximates the set of concrete locations that may be modi.ed from 
(s,h)to (s ' ,h ' ). DEFINITION 4.1 (Modifying an abstract address). Say that (s,h).(s ' ,h ' ) |=. X 
iff (a) for all y modi.ed from s to s ' , y .X . (b) for all £.f modi.ed from h to h ' , there exists 
L with £.L such that L.f .X .  Disjointness. Recall that L1 0L2 denotes that L1 and L2 are disjoint. 
We de.ne disjointness in two stages. In the .rst stage, we lift 0to a relation between an abstract address 
and a set of abstract addresses as follows: (a) x 0X iff x .X ; (b) L.f 0X iff for all L1.f .X , we have 
L 0L1. Second, we de.ne what it means for an assertion fto be disjoint from a set of abstract addresses, 
X . This relation, written f 0X , holds provided a 0X for all abstract addresses a occurring on the left 
hand side of assertions in f, i.e.: (a) For all x LI occurring in f, x 0X ; (b) For all L.f LI occurring 
in f, L.f 0X ; (c) For all xK occurring in f, x 0X ; (d) For all L.f K occurring in f, L.f 0X ; and (e) 
For all . occurring in f:if x occurs in . then x .X . As we shall see later (Sec. 5), f 0X is exactly 
the form of the side condition of the frame rule. An Invariance. The main result of this section is an 
invariance result, intuitively stating that an assertion which is valid before ex­ecuting a command, 
also remains valid after, provided it is disjoint from any abstract address modi.ed by the command. To 
precisely state this result, we need the following notion of extension of . and ß: Say that . ' over 
h ' extends . over h,if dom(h) .dom(h ' ) and for all £ .dom(h), for all L: £.L iff £. ' L. Let dom(h) 
.dom(h ' ) and dom(h1 ) .dom(h1 ' ). Say that ''' ' ß over h &#38;h1 extends ß over h&#38;h1 if ß = {(£,£1) 
.ß |(£ .dom(h)) .(£1 .dom(h1 ))}. (Therefore, if £ß ' £1 and £ .dom(h)then £1 .dom(h1 ), and vice versa). 
LEMMA 4.2 (Invariance). Suppose f 0X . Further, suppose '' '' (s,h) .(s ,h ) |= .; X , and (s1,h1) .(s1,h1) 
|= .;X , 1 '' '' where . over h extends . over h, and .1 over h1 extends .1 ' '' over h1. Also, let ß 
over h &#38;h1 extend ß over h&#38;h1. Suppose (s,h)&#38;(s1,h1) |= ß,.,.1 f. Then ' '' (s ,h ' )&#38;(s1,h1) 
|= ß;,.;,.;f. 1 4.1 Logical implication The purpose of this section is to de.ne a notion of implication 
of assertions; this permits the deduction of more independences than can be obtained by tracking data 
and control .ow only. DEFINITION 4.3 (Logically implies). Say that f0 logically im­plies f, written f0 
. f,iff (s,h)&#38;(s1,h1) |= ß,.,.1 f0 implies (s,h)&#38;(s1,h1) |= ß,.,.1 f. The above de.nition allows 
us to show that the following logical implications are valid. Let . be the programmer assertion x =c. 
Then . . xK.  Let . be the assertion (x =y). Then (..yK) . xK.  Let . be the assertion x =k(y), with 
k an arithmetic function. Then (..yK) . xK.  Several other such logical implications are possible. For 
applica­tions, recall Sec. 2, and see Sec. 6. We can de.ne . on abstract addresses in a manner similar 
to ' '' Def. 4.3. Say that X . X iff (s,h) .(s ,h ) |=. X implies '' '' (s,h) .(s ,h ) |=. X ' . Clearly, 
if X .X then X . X .   5. Statically Checking Assertions via a Logic To statically check assertions 
we de.ne, in Table 2, a Hoare-like logic whose judgements take the form .f{f0}S {f}[X ]. In the judgement, 
X is a set of abstract addresses that over­approximates the abstract addresses modi.ed by S, f0 are the 
assertions that hold before execution of S, and fare the assertions that hold after execution of S. . 
is a summary environment for methods, such that .(C ,m) is a (set of) summaries of the form {.0} {.}[X 
' ], where the only program variables mentioned in .0 are self and the formal parameter of m, where the 
only program variable mentioned in . is result, and where X ' does not contain program variables. The 
reason for having a set of summaries is polyvariance: at different call sites of the same method, different 
pre-and postconditions may hold. We will often omit . in rules other than the rule for method call. Each 
judgement in Table 2 is a small speci.cation. Before discussing the small speci.cations in more detail, 
we shall de.ne, for a judgement {f0}S {f}[X ], its intended mean­ing, of which our logic will be a sound 
(but necessarily not com­plete) approximation. 5.1 Semantics of Judgements DEFINITION 5.1. We say that 
µ |= {f0}S {f}[X ] iff the '' '' following holds for all s,h,s ,h ,s1,h1,s1,h1,ß,.,.1. Assume '' '' (s,h)[[ 
S]]µ](s ,h )and (s1,h1)[[ S]]µ](s1,h1)and (s,h)&#38;(s1,h1) |= ß,.,.1 f0. '' '' Then there exists . over 
h extending ., there exists .1 over h1 ' '' extending .1, and there exists ß over h &#38;h1 extending 
ß over h&#38;h1, such that (1a) (s,h).(s ' ,h ' ) |= .; X (1b) (s1,h1).(s1' ,h1' ) |= .;X 1 '' '' (2) 
(s ,h )&#38;(s1,h1) |= f ß;,.;,.; 1 Conditions (1a) and (1b) say that X is a sound overapproximation 
of the abstract addresses modi.ed in S when its execution changes ' '' the state from (s,h)to (s ,h ' 
), or from (s1,h1)to (s1,h1). Condi­tion (2) says, under the assumption that precondition f0 holds for 
the initial pair of states (s,h)and (s1,h1), that the postcondition f ' '' holds for the modi.ed states 
(s ,h ' ) and (s1,h1). Note that these conditions hold vacuously in case of non-termination, or run-time 
'' '' error (since then, states (s ,h )and (s1,h1)would not exist). Conjunction Rule not Sound in Semantic 
Model. It may be the case that µ |= {f0}S {f1}[X ]and µ |= {f0}S {f2}[X ]hold separately, but µ |= {f0}S 
{f1 .f2}[X ] does not hold. For a concrete example, consider the following program S: if z then x := 
new C ; y := x else x := new C ; y := new C Using Def. 5.1, we can semantically establish xK and yK sepa­rately, 
but not xK .yK. To see this, consider the initial states (s,h) '' '' and (s1,h1), evolving into states 
(s ,h )and (s1,h1). Our goal is ' '' '' to .nd ß extending ß such that (sx)ß(s1 x) and (sy)ß(s1 y); this 
is trivial if s(z)and s1(z)assume the same truth value, so as­sume that s(z) .True but s1(z) .False. 
Then there exists fresh location £such that s ' (x)=s ' (y)=£, and there exists fresh loca­tions £x = 
£y such that s1' (x)= £x and s1' (y)= £y. To establish xK, we de.ne ß ' such that £ß ' £x ; similarly, 
to establish yK,we de.ne ß ' such that £ß ' £y. But to establish both xK and yK,we '' ' would need £ß 
£x and £ß £y , which con.icts with ß being a bijection. 5.2 Syntax-directed Rules Table 2 gives the 
details of some small speci.cations. First note that ordinary assignment, x := E, is split into three 
cases pure as­signment, where E is an arithmetic expression; pointer assignment, where E is a variable 
z denoting a location; and null assignment, where E is null. Next note that for a given small speci.cation, 
its region asser­tions are always relevant, in that those occurring in the precon­dition must be established 
by the context, whereas the indepen­dence assertions may or may not be relevant, depending on whether 
those occurring in the precondition are established by the con­text. Therefore certain speci.cations 
should be read as two spec­i.cations (for space reasons, we do not show both), with the op­tional independence 
assertions being listed right of a semicolon. For example, [PointerAssign] should be read as the two 
rules: {z .}x := z {x .}[{x}] and {z ., zK}x := z {x ., xK}[{x}]. Many of the rules in Table 2 have already 
been motivated by means of examples in Sec. 2, so below we shall discuss only a few, and also give the 
rule for method calls. The postcondition of [New] asserts that x will be at some abstract address L with 
L = .; furthermore, xK always holds and x is modi.ed. The rule mirrors the concrete semantics of new, 
where a fresh location is allocated in the heap, except that we do not require freshness of L. Next we 
discuss [If], which is similar to the rule for conditionals in Hoare logic, except that in the presence 
of independences, some side conditions may be needed. Two cases: (a) If f0 logically implies xK, then 
we know that in states (s, h) and (s1, h1), both s(x) and s1(x) will have the same (integer) value, so 
the same branch of the conditional will be taken during evaluation. Hence, there is no indirect control 
.ow, and thus no need for any side conditions. (In the context of security, this case amounts to the 
guard of the conditional being low ). (b) Alternatively, in states (s, h) and (s1, h1), s(x) and s1(x) 
may differ, causing different branches of the conditional to be taken. In this case, in order to assert 
wK at the end of the conditional, it does not suf.ce to assert wK at the end of each branch, since this 
merely says that two runs choosing the same branch will agree on the value of w. What we need is that: 
 1. w is not modi.ed in any branch. (In the context of security, this amounts to no write down under 
a high guard [8]). 2. the two runs agree on the value of w before the conditional.   The .rst demand 
can be encoded as I(f) 0 X ; the second, as f0 I(f). Here, the notation I(f) denotes f s projection to 
its independence assertions. Concerning the speci.cation of a method call, x := y.m(z), as­sume that 
type y = C and that .(C , m) contains the summary {.0}{.} [X ]. Then, with f0 = .0[y/self , z/pars(m, 
C )] and f = .[x/result],9 we have [MethodCall]. f{f0}x := y.m(z) {f}[X .{x}] 5.3 Structural Rules There 
are two structural rules: [Conseq], which extends the rule of consequence in Hoare logic, and the frame 
rule, [Frame]. {f1}S {f2}[X ] if f ' f1 [Conseq] 1 {f ' }S {f ' }[X ' ] and f2 f2 ' 12and XX ' 9 The 
notation, e.g., .[x /result] denotes substitution of x for result in .. {f1}S {f2}[X ] [Frame] if f 0 
X . {f1 .f}S {f2 .f}[X ] The frame rule is used to reason with small speci.cations in a larger context. 
For example, for a command S1 ; S2, rule [Seq] requires the postcondition of S1 to be the same as the 
precondition of S2. As the examples in Sec. 2 depict, such a match may not always be achievable by small 
speci.cations themselves: extra assertions must be added by invoking [Frame]. This is sound provided 
the added assertions are disjoint from the modi.ed abstract addresses. As suggested by the semantic considerations 
in Sec. 5.1, we do not have a rule of conjunction like the one in Hoare logic (without heaps), i.e., 
we cannot derive {f0 .f ' 0} S {f .f ' } [X .X ' ] from {f0} S {f} [X ] and {f ' 0} S {f ' } [X ' ]. 
To see why this would be unsound (at least in our semantic model), let S be the command x := new C . 
Then, for all L1 and L2, we would have {true}S {xL1}[{x}] and {true}S {xL2}[{x}] and by the proposed 
conjunction rule therefore {true}S {xL1 .x L2}[{x}]. But this is clearly a semantic impossibility if 
L1 0 L2. Remarks. (a) One may think that the small speci.cations lose in­formation and may not be precise. 
For example, in [PointerAssign], why did zK disappear in the postcondition? But that independence can 
be recovered by [Frame], since z is not modi.ed. (b) Simi­larly, the rule for .eld update does not lose 
precision: if yL1 holds before then it also holds after, despite the use of [Conseq]to unify L1 with 
the region of f (details are in [1]). (c) The techni­cal report also shows one way to handle strong update 
in the rule [FieldUpd]. An example of strong update appeared in Sec. 2 but we do not discuss this issue 
any further due to lack of space. (d) In [If] and [Conseq], has a semantic de.nition. However, when all 
as­sertions are restricted to region and independence assertions, has a syntactic characterization given 
by De.nition 7.4 and asserted by Theorem 7.6. 5.4 Soundness DEFINITION 5.2 (Consistent summary environment). 
Say that summary environment . is consistent wrt. class table CT if when­ever .(C , m) contains the summary 
{.0}{.} [X ], and S is the body of a declaration of m in C , then . f{.0}S {.}[X ' ] where X = {L.f |L.f 
.X ' }. The idea is that even if a local variable is modi.ed by S and hence occurs in X ' , it should 
not occur in X since it is not visible outside m. On the other hand, all .eld updates10 are globally 
visible. THEOREM 5.3 (Soundness). Let . be a summary environment consistent wrt. class table CT . For 
a method m with body S, suppose . f{f0}S {f}[X ]. Then [[CT ]] |= {f0}S {f}[X ].  6. A Larger Example 
We consider the following example due to Barnett et al. [7]. class C { 1. private Hashtable ht := new 
Hashtable; //cache 2. public Um(Tx){ 3. Hashtable t := self.ht; 4. bool present := t.contains(x); 
 5. if (!present){ 6. Uy := costly(x); 7. t.put(x, y); } 8. Ures := (U )t.get(x); 9. assert (res 
= costly(x)); 10. result := res; }}  10 Since we are handling only public .elds. In future work, we 
hope to explore issues involving information hiding through private .elds. {z1,..., zn } =free(E) [Assert] 
{true} assert . {.} [Ø] [PureAssign] {true; z1v,..., zn v} x := E {x int;xv} [{x}] [NullAssign] {true} 
x := null {x ., xv} [{x}] [PointerAssign] {z .;zv} x := z {x .;xv} [{x}] {y ., ..f e;yv,..f v}{x ., y 
e, ..f e;xv, yv,..f v}x := y.fx.f := y [FieldAcc][FieldUpd] {x e;xv}{..f e;..f v} [{x}][{..f }] [New] 
{true} x := new C {x ., xv} [{x}] where . =. {f0} S1 {f1} [X1] {f1} S2 {f} [X2] {f0} S1 {f} [X ] {f0} 
S2 {f} [X ] where f0 . xv [Seq][If] {f0} S1 ;S2 {f} [X1 . X2] {f0} if x then S1 else S2 {f} [X ] or 
I(f)< X and f0 . I(f) Table 2. Small speci.cations: excerpts. A .(a e) is a metavariable to be instantiated 
by an L (an LI ). The method m is an ef.cient implementation of the method costly, employing memoization: 
argument-result pairs are cached in a hash table t, with the argument as key. A call to m with some argument, 
x, .rst checks if a value exists for key x in t (lines 4, 5); if not, it is computed (line 6) and stored 
in t (line 7). At that point, we know that the result can be retrieved from the hash table (line 8) and 
returned (line 10). We shall now argue that m is observationally pure (and hence can be used in speci.cations). 
As in Sec. 2 (for cexp), this involves showing (i) that result depends on x only; (ii) that m modi.es 
only locations not visible to the caller. For (i), we must show that two runs which agree on the initial 
value of x also agree on the .nal value of result. So let xK be in the precondition, then due to the 
frame rule, as x is not modi.ed along the way xK holds after line (9), where by [Assert] we also have 
res = costly(x).By[Conseq], this entails that resK holds before line (10). By [PointerAssign], this entails 
that result K is in the postcondition, as desired. For (ii), assume that Hashtable has two .elds, key 
and val, and that it is in abstract location L0. The only abstract addresses modi.ed by m are L0.key 
and L0.val (as well as certain local variables which are not visible to the caller, c.f. De.nition 5.2). 
The desired invisibility can then be obtained by assuming that L0 is disjoint from all abstract locations 
used outside of m. For the above to work out formally, we need method summaries such as the ones below: 
{self .0.key .0, .1,x {self .1,.0.key .0, .1,x .1, .0.val .2,y put .2} .0.val get .2} {} {result .2} 
 [.0.key,.0.val][Ø] Note that we do not need the summaries to contain indepen­dence assertions. It is 
interesting, however, to consider how such assertions could be added in the summary for, e.g., the method 
get.Na¨ively, we would expect (c.f. the method getQ described in Sec. 2) that if the precondition .0 
contains the assertions xK, self K, .0.keyK, and .0.val K, then the postcondition .1 will con­tain the 
assertion result K. But in general, get cannot be imple­mented so as to satisfy this summary. To see 
this we assume, in order to arrive at a contradiction, that Sg is the body of such an implementation. 
By Theorem 5.3 (and De.nition 5.2), we have µ |= {.0} Sg {.1} . Now consider two states, (s,h) and (s1,h1), 
where the key s(x)(which due to xK equals s1(x))is mapped by the hash table to different integer values. 
With ß cho­sen such that ß relates s(self ) to s1(self ) but relates no other locations, we have (s,h)&#38;(s1,h1) 
|= ß,.,.1 .0 (since, e.g., .0.keyK vacuously holds). But with Sg transforming (s,h)into '' '' (s ,h )and 
(s1,h1)into (s1,h1),it is not possible (since the in­ '' ' tegers s (result) and s1(result) are different) 
to de.ne ß such '' '' that (s ,h )&#38;(s1,h1) |= result K. This yields the desired ß;,.;,.1; contradiction. 
To .x the above situation, we need to be more concrete about how the (hash) table is implemented. Suppose 
that it is a linked list, with each record containing not only a key and a val .eld (both integers), 
but also a next .eld. Then, we can implement get such that resultK is in the postcondition, provided 
we include .0.nextK in the precondition .0. To see this, consider as above two states, (s,h)and (s1,h1), 
with (s,h)&#38;(s1,h1) |= ß,.,.1 .0. Since .0 contains xK, there exists an integer k such that s(x)=s1(x)=k. 
Wlog., we can assume that in the .rst state, k occurs as the third key in the list. That is, there exists 
locations £, £1, and £2 such that s(self )= £, h £next = £1, h £1 next = £2, and h £2 key = k. Since 
.0 contains self K, with s1(self )=£ ' we have £ß£ ' . This entails, since .0 contains .0.nextK and we 
can assume £..0, '' ' that with h1 £ next =£1 we have £1 ß£1; similarly we then infer '' ' that £2 ß£2 
with h1 £1 next =£2. Since .0 contains .0.keyK and .0.valK, we now infer that h1 £2 ' key = h £2 key 
= k, and that ' '' there exists v such that h1 £2 val =h £2 val =v. With (s ,h )and '' ' (s1,h1)the .nal 
states, this shows the desired s1(result)= v = s ' (result).  7. Computing Postconditions It is time 
to address how to decide, and implement, our logic. For that purpose, we shall along the way introduce 
several simplifying assumptions, two of which we state already now. ASSUMPTION 7.1. Abstract locations 
form a .nite complete lat­tice, with . the least element and T the greatest element, where U corresponds 
to set union and n corresponds to set intersec­tion. That is, we require that if L =L1 U L2 then £.L 
iff £.L1 or £.L2  if L =L1 n L2 then £.L iff £.L1 and £.L2.  Accordingly, we also require that if L 
=L1 U L2 then for all L ' : L ' 0 L iff L ' 0 L1 and L ' 0 L2. Recall from Sec. 4 that . approximates 
nil but no concrete heap locations; on the other hand, T approximates all concrete locations. The next 
assumption is motivated by the fact that if L =L1 U L2, then any information about L.f can be deduced 
from informa­tion about L1.f and L2.f . ASSUMPTION 7.2. Among the abstract locations are some irre­ducible 
elements (we write irr(L)for irreducible L) such that if L1 =L2 are irreducible then L1 0L2;  for each 
abstract location L, there are unique irreducible ele­ments L1,...,Ln (n =0) such that L =L1 U...ULn 
.  Recall from Sec. 4 that all disjunctions in assertions occur only within programmer assertions .. 
Thus, we can view an assertion f as a set (implicitly a conjunction) of primitive assertions a.Itis convenient 
to work with assertions where all abstract locations (on the left hand side ) are irreducible and occur 
at most once: DEFINITION 7.3. Say that fis normalized iff (a) if L.fL ' .f then L is irreducible; (b) 
if L.f K . f then L is irreducible; (c) if L.fL1 . f and L.fL2 . f then L1 = L2; (d) if xL1 . f and xL2 
. f then L1 = L2; (e) f does not contain any assertions of the form Tor int; (f) f contains exactly 
one programmer assertion. For a normalized assertion f, the region part gives rise to a function as follows: 
(a) f(x)= int,if type x = int; (b) f(x)= L,if xL . f; (c) f(x)= T, otherwise. And, given irr(L0),we de.ne: 
(d) f(L0.f )=int,if type f =int; (e) f(L0.f )=L,if L0.fL .f; (f) f(L0.f )=T, otherwise. It is possible 
to write a function norm that converts an assertion finto a normalized assertion norm(f)which is logically 
equiva­lent. (That is, f norm(f)and norm(f) f; also we have f 0 X iff norm(f) 0 X ). For example, if 
L can be written as L1 U...ULn where irr(L1)...irr(Ln ), then norm will transform an assertion L.f LI 
into {L1.f LI ,...,Ln .f LI }. 7.1 Checking Logical Implication In Sec. 4.1, we gave a semantic de.nition 
(4.3) of logical implica­tion. We shall show that without programmer assertions, that de.­nition is equivalent 
to a syntactic characterization which is readily implementable. DEFINITION 7.4. For normalized . and 
. ' , we write .. ' iff the following holds: (a) if xL ' . . ' there exists L with LL ' such that xL 
.. L '' L ' (b) it L1.f . . there exists L with L such that L1.fL .. (c) xK .. ' implies xK .. (d) 
L.f K .. ' implies L.f K ..;  '' ' (e) . .. implies that there exists . .. such that .. . For arbitrary 
f and f ' , we shall with abuse of notation write ff ' iff norm(f) norm(f ' ). Now consider the case 
with no programmer assertions. Then clause (e) above is trivial (as . ' =. =true), so it is easy to decide 
.As shown by the results below, this amounts to deciding . FACT 7.5. If ff ' then ff ' . THEOREM 7.6. 
If f and f ' contains no programmer assertions, then ff ' is equivalent to ff ' . To see why we need 
to assume the absence of programmer asser­tions, observe that x =c logically implies xK whereas (x =c) 
xK does not hold. For that assumption to be removed, we would need a much stronger version of norm that 
.nds all instances of logical implication hidden in programmer assertions. Concerning how to decide XX 
' , we proceed in a similar (but much simpler) way: we say that a set X of abstract addresses is normalized 
if L is irreducible for all L.f .X ; we write a function norm that converts a set of abstract addresses 
into an equivalent normalized set; .nally, we establish FACT 7.7. XX ' iff norm(X ).norm(X ' ). 7.2 
A Sound Algorithm We shall de.ne, inductively on S, a function sp(S,f0)that given a command S and a precondition 
f0 (which could be global ) computes a pair (f,X ); here we want f to be a postcondition of S, and X 
to be the abstract addresses that may be modi.ed by S. With ASSUMPTION 7.8. We assume that a consistent 
summary environ­ment .is given in advance we can show soundness of sp wrt. to the logic: THEOREM 7.9. 
If sp(S,f0)=(f,X )then .f{f0}S {f}[X ]. The full de.nition of sp is11 in [1]; below we shall list the 
most interesting cases which are for conditional, assignment, and method call. (For programmer assertions, 
sp(assert .,f0)=(..f0,Ø)). Conditionals. We call sp recursively on the two branches and then combine, 
via a least upper bound operator, the resulting as­sertions. DEFINITION 7.10. For normalized .1 and .2, 
we de.ne . = .1 U.2 (which is itself normalized) as follows: xL .. iff there exists L1 and L2 with L 
=L1 UL2 =T such that xL1 ..1 and xL2 ..2  L0.fL ..iff there exists L1 and L2 with L =L1 UL2 = Tsuch 
that L0.fL1 ..1 and L0.fL2 ..2  xK ..iff xK ..1 and xK ..2  L.f K .. iff L.f K ..1 and L.f K ..2  
. ..iff there exists .1 ..1, .2 ..2 such that . =.1 ..2.  For arbitrary f1 and f2, we shall with abuse 
of notation write f1 Uf2 for norm(f1)Unorm(f2). Let f12 be the least upper bound of the analyses of 
the branches. Looking at the side conditions for [If] in the logic, we see that if f0 logically implies 
xK (with x the test), we can just return f12. Otherwise, in order to satisfy the second side condition, 
we must remove from f12 all independences which either are not in the precondition, or whose abstract 
addresses have been modi.ed in S1 or in S2. The resulting code is sp(if x then S1 else S2,f0)= let (f1,X1)=sp(S1,f0)in 
let (f2,X2)=sp(S2,f0)in let X =norm(X1 .X2)in let f12 =f1 Uf2 in let f =if f0 xK then f12 else f12 \(C1 
.C2) where C1 ={yK |(y .X ).(yK .norm(f0))}and C2 ={L.f K |(L.f .X ).(L.f .norm(f0))} in (f,X ) Assignments. 
Assume that S is an assignment A which is not a method call, i.e., A is either a pure assignment, a pointer 
as­signment, a null assignment, a .eld access, a .eld update, or an 11 Except that we do not yet handle 
while loops; such would require some kind of .xed point iteration. object creation. Assume that we have 
a nondeterministic func­tion Choose(A,f0) which returns a triple (.0,.,X ) such that {.0}A {.} [X ]is 
an instance of a rule for A in the logic where f0 .0. Then de.ne sp(S,f0)= let (.0,.,X )=Choose(A,f0)in 
let f=..disj (f0,X )in (f,X ) Here, the function disj extracts the parts of an assertion not modi­.ed 
by the assignment, thus incorporating the frame rule. It is de­.ned by disj (f,X )={a .norm(f)|a 0 X 
}. So far, the above de.nition is very non-deterministic; it will be concretized in the next section 
when we consider strongest postconditions. Method calls. Assume that S is a method call x := y.m(w), 
with type y = C where C contains a method m with formal parameter z. Assume that we have a non-deterministic 
function12 Choose(m,C ,f0) which returns a triple (.0,.,X ) such that {.0} {.} [X ] . .(C ,m)where f0 
.0[y/self ,w/z]. Then: sp(S,f0)= let (.0,.,X )=Choose(m,C ,f0)in let fX =disj (f0,X .{x})in let f=.[x/result].fX 
in (f,X .{x}) Construction of method summaries. In an actual implementa­tion, the summary environment 
.may be built incrementally, by using sp to analyze a new method in the context of the current . (see, 
e.g., [25]). For recursive methods, however, the user might be required to provide the summaries, as 
in ESC/Java [16]. 7.3 Strongest Postcondition We shall now look at conditions for when sp, as de.ned 
in the previous section, is indeed the strongest postcondition. We want to prove the following completeness 
theorem THEOREM 7.11 (Completeness). If sp(S,f0)=(f,X )and ' '' {f0}S {f ' }[X ], then ff and XX . For 
that purpose, we need to control the nondeterminism in the selection of abstract locations in rule [New]. 
ASSUMPTION 7.12. Each occurrence of new is associated with a speci.c irreducible abstract location L0 
such that the only rule applicable for that occurrence is {true}x := new C {xL0;xK}[{x}]. Then we can 
concretize, as done in Table 3, the function Choose for assignments. Thanks to Assumption 7.12, we can 
show that Choose computes the strongest applicable version . DEFINITION 7.13 (Strongest Applicable Version). 
Given rule schema (j . J ), {.j } S {.j ' } [Xj ]. For given f0, we say that j0 is the strongest applicable 
version if f0 .j0 For all j such that f0 Xj0 Xj . .j , it holds that . ' j0 . ' j and Under the further 
assumption that the method summaries have been constructed such that there exists a strongest applicable 
version for method calls, we can prove the completeness (Theorem 7.11) of sp, provided that is equivalent 
to (as is the case without programmer assertions, c.f. Theorem 7.6). 12 Required because we have a set 
of summaries for different calling con­texts, so we need to select the appropriate one.  8. Discussion 
We have speci.ed, via a Hoare-style logic, an interprocedural and .ow-sensitive information .ow analysis 
for object-oriented pro­grams. (The analysis is insensitive to termination, but we expect that adding 
assertions of the form .K, c.f. [3], would make it sen­sitive to termination). Because aliasing can compromise 
con.den­tiality, the logic uses region assertions to describe aliasing that may arise between variables 
and between heap values. Independence as­sertions describe the absence of leaks due to data and control 
.ow in a program. Together with the knowledge that particular abstract addresses are disjoint, i.e., 
they must not alias, the logic can be employed to specify a more precise information .ow analysis than 
extant type-based approaches. We also permit JML style program­mer assertions in code. Such assertions 
allow more programs to be deemed secure than would be permitted by region and inde­pendence assertions 
alone, albeit at the cost of a fully automatic checker. The technical report considers dynamic dispatch 
(which we avoid in this paper); the proof rule for method call needs to be augmented with side conditions 
as in [If]. Local reasoning about state is supported in our logic and we show a number of examples. While 
ordinary Hoare logic without aliasing is compositional by nature, aliasing makes it challenging to reason 
locally about the heap. By drawing upon fundamental ideas from separation logic, we achieve local reasoning: 
we use small speci.cations for each command and combine speci.cations via a frame rule. The small speci.cations 
only mention abstract addresses relevant to a command and semantically correspond to the footprint of 
the command in the global state [21]. The frame rule permits a move from local to non-local speci.cations. 
As we mentioned in Sec. 5, Table 2 speci.es two sets of rules. The reader might have noted that the rules 
that mention region as­sertions only specify a points-to analysis similar to well-known ones, e.g., [13, 
9]. Data .ow facts used in typical points-to anal­yses can be viewed as assertions. Nevertheless, we 
have not found in the literature an explicit Hoare-style speci.cation of interproce­dural points-to analysis 
that is based on local reasoning via small speci.cations and the frame rule. On top of such a points-to 
analy­sis, a host of other analyses (rather than just information .ow anal­ysis) could be speci.ed. There 
is much work that remains. We wish to experimentally validate whether local reasoning with the frame 
rule indeed pro­vides scalability. Towards this goal, we plan to extend ESC/Java213 and its assertion 
language, JML [12], to handle region and inde­pendence assertions. This would provide a veri.cation framework 
for information .ow properties. For checking benchmarks (e.g.,[5]) that use declassi.cation, we conjecture 
that independence asser­tions might help in statically predicting program points where de­classi.cation 
may be used. A signi.cantly harder problem is obtaining a modular interpro­cedural analysis. This requires 
devising a modular algorithm for computing strongest postconditions, one that discovers and updates procedure 
summaries on the .y. We plan to explore how local rea­soning might be employed in this process. Although 
our logic does not have separation logic s spatial con­junction (.) operator, we conjecture that the 
semantics of assertions could be alternatively given as follows: the meaning of e.g., x in state (s,h)under 
., could consider a partition of h into disjoint subheaps h1,h2 such that dom(h1 )={s(x)}with (s(x)).L. 
Our hope is that local reasoning will be used in the speci.cation of program analyses and in the security 
context used as a foundation for checking security policies for practical systems composed of components. 
13 http://secure.ucd.ie/products/opensource/ESCJava2 Choose(x := new C ,f0)= let L0 be the designated 
abstract location for this occurrence of new in ({},{xL0,xv},{x}) Choose(x := z,f0)= let L =f0(z)in if 
f0 . zv then ({zL,zv},{xL,xv},{x}) else ({zL},{xL},{x}) Choose(x := y.f ,f0)= let L =f0(y)=L1 ... Lk 
in let LI =j.1...k f0(Lj .f )in if f0 . yv,L.f v then ({yL,L.f LI ,yv,L.f v},{x else ({yL,L.f LI },{x 
LI },{x}) LI ,xv},{x}) Choose(x := E,f0)= let z1,...,zn =free(E)in if f0 . z1v,...,zn v then ({z1v,...,zn 
v},{xv},{x}) else ({},{},{x}) Choose(x := null,f0)=({},{x .,xv},{x}) Choose(x.f := y,f0)= let L =f0(x)=L1 
... Lk in ' let LI =f0(y)in ' let LI =j.{1...k}f0(Lj .f ) LI in if f0 . xv,yv,L.f v then ({xL,y LI ,L.f 
LI ,xv,yv,L.f v}, {L.f LI ,L.f v},{L.f }) else ({xL,y LI ,L.f LI },{L.f LI },{L.f }) Table 3. The function 
Choose, given normalized f0.  Acknowledgments To Alex Aiken, Dave Naumann, Peter O Hearn, John Reynolds, 
Tamara Rezk, Andrei Sabelfeld, Dave Sands, Dave Schmidt, Lyn Turbak and the POPL reviewers for discussions, 
comments and encouragement. We were supported in part by NSF grants CCR­0209205, ITR-0326577, and CCR-0296182. 
 References <RefA>[1] T. Amtoft, S. Bandhakavi, and A. Banerjee. A logic for information .ow analysis of pointer 
programs. Technical Report CIS TR 2005-1, Kansas State University, July 2005. [2] T. Amtoft and A. Banerjee. 
Information .ow analysis in logical form. In SAS, LNCS 3148, pages 100 115. Springer-Verlag, 2004. [3] 
T. Amtoft and A. Banerjee. A logic for information .ow analysis with an application to forward slicing 
of simple imperative programs. Science of Computer Programming, special issue of SAS 2004. To appear. 
[4] A. Askarov. Secure Implementation of cryptographic protocols: A case study of mutual distrust. Master 
s dissertation, Chalmers University of Technology, April 2005. [5] A. Askarov and A. Sabelfeld. Security-typed 
languages for implementation of cryptographic protocols: A case study. In ESORICS, LNCS 3679, pages 197 
221. Springer-Verlag, 2005. [6] A. Banerjee and D. A. Naumann. Stack-based access control and secure 
information .ow. JFP 15(2):131 177, Mar. 2005. [7] M. Barnett, D. A. Naumann, W. Schulte, and Q. Sun. 
99.44% pure: Useful abstractions in speci.cations. In ECOOP workshop on Formal Techniques for Java-like 
Programs (FTfJP), 2004. [8] D. Bell and L. LaPadula. Secure computer systems: Mathematical foundations. 
Technical Report MTR-2547, MITRE Corp., 1973. [9] M. Berndl, O. Lhot´ak, F. Qian, L. J. Hendren, and 
N. Umanee. Points-to analysis using BDDs. In PLDI, pages 103 114, 2003. [10] M. Bishop. Computer Security: 
Art and Science. Addison-Wesley, 2003. [11] A. Borgida, J. Mylopoulos, and R. Reiter. On the frame problem 
in procedure speci.cations. IEEE Transactions on Software Engineering 21(10):785 798, 1995. [12] L. Burdy, 
Y. Cheon, D. R. Cok, M. D. Ernst, J. Kiniry, G. T. Leavens, K. R. M. Leino, and E. Poll. An overview 
of JML tools and applications. Electr. Notes Theor. Comput. Sci., 80, 2003. [13] D. R. Chase, M. N. Wegman, 
and F. K. Zadeck. Analysis of pointers and structures (with retrospective). In Best of PLDI, pages 343 
359, 1990. [14] E. S. Cohen. Information transmission in sequential programs. In Foundations of Secure 
Computation, pages 297 335. Academic Press, 1978. [15] D. Denning and P. Denning. Certi.cation of programs 
for secure information .ow. CACM 20(7):504 513, 1977. [16] C. Flanagan, K. R. M. Leino, M. Lillibridge, 
G. Nelson, J. B. Saxe, and R. Stata. Extended static checking for Java. In PLDI, pages 234 245, 2002. 
[17] J. Goguen and J. Meseguer. Security policies and security models. In Proc. IEEE Symp. on Security 
and Privacy, pages 11 20, 1982. [18] S. Hunt and D. Sands. On .ow-sensitive security types. In POPL 2006. 
To appear. [19] A. C. Myers. JFlow: Practical mostly-static information .ow control. In POPL, pages 228 
241, 1999. [20] F. Nielson, H. R. Nielson, and C. Hankin. Principles of Program Analysis. Springer-Verlag, 
1999. [21] P. O Hearn, J. Reynolds, and H. Yang. Local reasoning about programs that alter data structures. 
In CSL, LNCS 2142, pages 1 19. Springer-Verlag, 2001. [22] F. Pottier and V. Simonet. Information .ow 
inference for ML. TOPLAS 25(1):117 158, Jan. 2003. [23] J. C. Reynolds. Separation logic: a logic for 
shared mutable data structures. In LICS, pages 55 74. 2002. [24] A. Sabelfeld and A. C. Myers. Language-based 
information-.ow security. IEEE J. Selected Areas in Communications, 21(1):5 19, Jan. 2003. [25] Q. Sun, 
A. Banerjee, and D. A. Naumann. Modular and constraint­based information .ow inference for an object-oriented 
language. In SAS, LNCS 3148, pages 84 99. Springer-Verlag, 2004. [26] D. Volpano, G. Smith, and C. Irvine. 
A sound type system for secure .ow analysis. Journal of Computer Security, 4(2/3):167 188, 1996.  </RefA>
			

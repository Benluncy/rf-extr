
 A Framework for Expressing and Combining Preferences Rakesh Agrawal Edward L. Wimmers IBM Almaden Research 
Center San Jose, CA 95120 Abstract explode. The advent of the World Wide Web has created an explosion 
in the available on-line information. As the range of potential choices expand, the time and effort required 
to sort through them also expands. We propose a formal framework for expressing and combining user preferences 
to address this problem. Preferences can be used to focus search queries and to order the search results. 
A preference is expressed by the user for an entity which is described by a set of named fields; each 
field can take on values from a certain type. The * symbol may be used to match any element of that type. 
A set of preferences can be combined using a generic combine operator which is instantiated with a value 
function, thus providing a great deal of flexibility. Same preferences can be combined in more than one 
way and a combination of preferences yields another preference thus providing the closure property. We 
demonstrate the power of our framework by illustrating how a currently popular personalization system 
and a real-life application can be realized as special cases of our framework. We also discuss implementation 
of the framework in a relational setting. 1 Introduction The World Wide Web is suffering from abundance. 
The publicly indexsble web contains an estimated 800 million pages [LG99]. The number of pages is anticipated 
to expand 1000% over the next few years [BP96]. The current on-line catalog of Amazon.com contains more 
than 3 million books, 225,000 CDs, 60,000 Videos, and other merchandise. The auctioning site eBay has 
on-line information on more than 3 million items on sale at any time. The emergence of industry-specific 
exchanges such as Sciquest, Chemdex, Chipcenter, etc. will cause the amount of on-line information about 
product and services to further Permission to make digital or hard copies of all or part of this work 
for personal or classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advant -age and that copies bear this notice and the full citation on the first 
page. To copy otherwise, to repubtish, to post on servers or to redistribute to lists, requires prior 
specific permission and/or a fee. ACM SIGMOD 2000 5/00 Dallas, TX, USA &#38;#169; 2000 ACM 1-58113-218-210010005-.$5.00 
As the range of potential choices expand, the time and effort required to sor t through them also expands. 
These problems are difficult enough when a person is actively searching for a product to meet a specific 
need. The problem becomes even more severe when people are browsing. The effort required to browse through 
thousands, if not millions, of product variants within specific categories becomes like searching for 
the proverbial needle in a haystack [HS991. The importance and potential commercial impact of managing 
this data so that users can quickly and flexibly state their preferences represents an important new 
potential direction for database technology. We propose a framework for expressing and combin- ing user 
preferences to address the above problem. Pref- erences can be used to focus search queries and to order 
the search results. While the Web applications moti- vated our work, the framework is more generally 
appli- cable. The salient features of our framework are: A user expresses preference for an entity 
by provid- ing a numeric score between 0 and 11, or vetoing it, or explicitly stating indifference. By 
default, indif- ference is assumed. Thus, a user states preference for only those entities that the user 
cares about. An entity is described by a set of named fields; each field can take on values from a certain 
type. The * symbol may be used to match any element of that type. For example, (painting, cubist, *) 
refers to any cubist painting, (painting, *, Picasso) refers to paintings of Picasso, and (*, *, Picasso) 
refers to any artwork of Picasso. Preferences can be combined. There is one generic combine operation 
for this purpose. This operator is instantiated by value functions to yield specific instances of the 
combine operation. Having a single iExtension to the case where the scores are discretized and assigned 
symbolic labels is straightforward.  generic combine operation makes for a lean and easy to understand 
and implement system. Allowing value functions provides a great deal of flexibility. Specification of 
preferences is decoupled from how they are combined. The same preferences may be combined in different 
ways depending upon the application.  Autonomy of various preferences is preserved. Pref- erence for 
an entity can be changed without affecting any score of an unrelated entity.  The combining operation 
has the closure property so that the result of combining two preferences may be further combined with 
another preference.  To illustrate the flexibility of our framework, we take a current popular personalization 
system and a real-life application and show how they can be modeled within our framework. We also sketch 
how to implement our framework in a relational setting. Related Work The problem of expressing and com- 
bining preferences arises in several applications. Cus-tomization by selecting from a menu of choices 
(e.g. ticker symbols for tracking stocks, city names for weather forecast) can be thought of as a simple 
expres- sion of preferences. Terns expressions used for filtering documents (e.g. myexcite) can also 
be viewed as sim- ple form of preferences. The recommendation systems based on collaborative filtering 
[RV97] ask users to rank items and combine preferences of similar users to make recommendations. The 
need for combining rankings of different models has arisen in meta-search problems [EHJ+96] [FISS98], 
multi-media systems [Fag98], and information retrieval [SM83]. Perhaps the most famous theorem related 
to combining preferences is the Arrow Impossibility Theorem in Economics [ArrS0]. The the- orem says 
that it is impossible to construct a "social preference function" (ranking the desirability of various 
social arrangements) out of individual preferences while retaining a particular set of features. While 
related, the main thrust of our work is quite orthogonal to the above literature. Our main concern is 
to develop a flexible framework for expressing and combining preferences that has certain desirable properties. 
The specific function used in combining some preferences is a parameter in our framework; we only require 
that this function obey certain constraints. (Arrow's social preference function does not obey these 
constraints.) Paper Organization The rest of the paper is struc- tured as follows. In Section 2, we present 
our preference framework. We formally define preference functions and how they are combined. We introduce 
modular com-bining forms that have the desirable properties of ef- ficiency and conservation of the autonomy 
of various preferences. Modular combining forms are closed under composition. We show that all the preference 
combing forms defined using our framework are indeed modular. In Section 3, we model the Personalogic 
system (http://www.personalogic.com) using our framework. In this case study, we combine several preference 
functions from the same person that cover different aspects of a total picture. We also model a real-life 
design application in which a company's preferences are combined with an engineer's preferences into 
a single preference function. We then present a completeness result that explains the power of our framework. 
In Section 4, we sketch how our preference system can be implemented on a relational database system. 
We conclude with a summary in Section 5. In this paper, we assume that the user explicitly provides preferences. 
It is easy to extrapolate how such a system can be used in conjunction with a data mining system that 
observes a user's past interactions and offers suggestions for preferences. 2 The Framework 2.1 Preference 
Functions In this section, we formalize the notion of a preference function. We start with a set of (base) 
types which typically include ints, strings, floats, booleans, etc. We introduce a data type called score 
that represents a user preference. Formally, this is [0,1] U { ~, _1_). A score of 1 indicates the highest 
level of user preference. A score of 0 indicates the lowest level of user preference. The "~" score, 
represents a veto. The "±" score represents that no user preference has been indicated. We also make 
use of record types. Since it is an important building block of preference functions, it is worth briefly 
reviewing. A record type is a set of pairs { name_l:type_l, ..., name_n:type_n } in which all n names 
(a name is simply a non-empty string) are different (although the types are allowed to be the same). 
In this case, name5 is the name of a field in the record and type_i is the type of that field. A record 
is where each field takes on a value in the type of that field. More formally, a record is a function 
r whose domain is { name_l, ..., name_n ) such that r(name._i) is an element of type_i. Usually, r(name_i) 
is written as r.name_i. A type is called wild iff it contains "*". The "*" symbol is used to indicate 
a wild card that "matches" any value. Definition 2.1 A preference function is a function that maps records 
of a 9ires record type to a score. If p is a preference function, we use dora(p) to refer to the given 
record type that is the domain of p. Since we sometimes wish to apply a preference function to a record 
with more fields than are present in the domain of the preference function, we introduce a projection 
operator to eliminate the extra fields. This is formalized in Definition 2.2. Definition 2.2 Let rt be 
the record type {at : tl, ..., nk : tk). Let r be a record of type {nl : Q,...,nh : t~,nk+l : tk+l,...at 
: tl} where k < l. Then rrrt(r) is the record of type rt where Irrt(r).ni = r.ni for i < k. While a preference 
function does not require that the types of fields in the record type that is the domain of a preference 
function be wild, most of the time these fields will be wild so as to allow the user a convenient method 
for specifying a whole class of preferences. Definition 2.3 Given two records rl, r~ of type rt = {nl 
: tl,...,n~ : t~}, we say r2 generalizes rl (which is written as r 2 ~ rl) iff for all i _< k, either 
rz.ni = rl.ni Or r2.n i = *. It is clear that the t> relation is reflexive and transitive. Note that 
for any record r there are 2J records that generalize r where j is the number of fields that have a wild 
type and for which the value of the field in r is not "*" 2.2 Combining Preference Functions It is frequently 
desirable to combine preference func- tions to form a new preference function. We define a preference 
function meta-combining form called com-bine which takes a "value function" that says how to compute 
a new score based on the original scores and produces a preference function combining form (which takes 
a finite list of preference functions and produces the new preference function). Imagine two roommates, 
Alice (who never cooks but likes to decorate) and Betty (who does all the cooking) are purchasing a refrigera- 
tor. Alice has a preference function (called A0) whose domain is {model : in,, color : string U {*}}; 
Betty has a preference function (called Bo) whose domain is {model : in,, quality : in,). The model field 
indicates the model number, the color field is a string describing the color, and quality is an integer 
between 1 and 4 indi- cating the quality of the refrigerator. Notice that color is the only field with 
a wild type. The two roommates agree that the combined preference function should be what Betty wants 
(since she does all the cooking) but that Alice should have veto power over any refrigera- tor they buy. 
In this subsection, we define a preference function combining form and show how this roommate example 
can be expressed using this preference function combining form. We assume the existence of a special 
character "~" that is reserved for system use and is not allowed to appear in the name of any (user) 
record field. Definition 2.4 Given a record type, rt = {nl : tl,...,nk :tk}, define ScoreBoard(r,) = 
: scorel(t, is wild ^ = "star!") v = rid. Notice that we are using the special character "!" both as 
a separator character as well as at the end of the "star!" string to avoid conflict with the name of 
a user field (which is not allowed to contain the "!" charac-ter). Thus, ScoreBoard(r,) has 2 j fields 
where j is the number of ti types that are wild. The careful reader will note that the record type is 
a set which is un-ordered whereas the new field names have an order (namely n~ occurs before n~, etc.). 
This gap is easy to remedy by simply taking the names in the new record field to be listed in alphabetical 
order. In the room-mate example, ScoreBoard( dom(Ao )) = {color!model: score, star!!model : score} and 
ScoreBoard( dom( Bo )) = {model!quality : score}. Definition 2.5 Given a record type rt = {nl : ti ..... 
nk : tk} and the name of a field n~!...!n~ in record type ScoreBoard(r,), and a record r of type rt, 
define RecordOf r,(r, n~ ! . . .!n~) to be a record o/type rt such that, for each field name nj in rt, 
 { r.nj ifn~:nj RecordOf r,(r, n~ !...!n~).nj = if n~ = star/ Notice that RecordOfr t completely specifies 
the record since a value is supplied for every field in the record of type ft. Also note that n~ can 
be "star!" only if tj is wild so that the nj field in the record RecordOf~t is always a valid member 
of type tj. For example, in the roommate example, RecordOf do,n( A o) ( r, star!! model ) = {color = 
*, model = r.model}. (Note that we use the sign (rather than :) when giving a specific instance of a 
record.) It is clear that, when applied to a record of type rt, RecordOfrt produces a generalization 
of that record. Definition 2.6 Given a preference function p whose domain is the record type rt = {nl 
: tl,...,n/¢ : t/c}, and a record r of type rt, define Scores(p, r) to be a record of type ScoreBoard(rt) 
such that Scores(p, r).n~!...!n~ = p( RecordO/ ,t ( r, n~ ! . . .! n~ ) ) . The basic idea is that Scores(p, 
r) provides the value of p(r') for all the generalizations r' oft when the type oft is dora(p). Clearly, 
Scores(p, r) : ScoreBoard(dora(p)) provided r is of type dora(p). In the roommate exam- ple, Scores(Ao, 
r) = ( star!!model = Ao( (color = *, model = r.model} ), color!model = Ao( (color = r.color , model = 
r.model} ) }. In the case that n~ = ni for each i (i.e., none of the n~ are "star!"), note that Scores(Ao, 
r).nl! ...!nk = A0(r). Definition 2.7 A finite set of record types {rtl, . . . , rtn) is compatible iff 
whenever rti and rtj share a field with the same name, then those two fields have the same type. If (rti, 
. . . , rt,~} is compatible, define merge(rti .... ,rt,~) to be the record type that has a field n : 
t iff at least one of the record types has the field n : t. Note that, by compatibility, each field in 
the merged record type will have a uniquely determined type. In other words, merge(rti,...,rt,~) is the 
"smallest" record type that "contains" all of the record types rti,...,rtn. Also note that the order 
of the argu-ments to merge is irrelevant. In the roommate ex-ample, dom(Ao) and dom(Bo) are compatible 
types and merge( dom( Ao ), dom( Bo ) ) = (model: int, color: string U (*}, quality : int}. Definition 
2.8 For every set (rti,..., r~n]-of compat- ible record types, C is called a preference combining form 
based on (rti,...,rtn) iff C maps n preference functions pi , . . . , pn with dom(pi ) = rtl into a new 
pref- erence function with domain merge(rtl, . . . , rtn). This new preference function is denoted by 
C(pl,... ,Pn). Definition 2.9 Let (rti,...,rtn} be a set of compati- ble record types. A function f is 
called a value function based on (rti,...,rtn) iff f : ScoreBoard(rtl) × ... × ScoreBoard(rtn) × merge(rtl,. 
. ., rtn) ~ score. We are now ready to define the meta-combining form combine which is at the heart of 
the combining preference functions. Definltlon 2.10 Let (rtl,...,rtn} be a set of com-patible types. 
Let f be a value function based on (rti,...,rt,~). Then combine(f) is preference combin-ing form based 
on (rtl,..., rtn) defined by = f(Scores(pl, (r)),..., Scores(p , r) for all records r of type merge(rQ 
, . . . , rtn) and all preference functions with dom(pi) = rti for all i<n. The idea behind this notion 
of combining preference functions is that only the "relevant" scores are exam- ined. The relevant scores 
are the scores associated with a record as well as any generalizations of that record. All the other 
values are irrelevant. Notice that a value function is based on a list (rather than a set) of record 
types since the order of the arguments to a value function might make a difference. In the roommate example, 
the computation that gives Alice veto power would be the function FirstVeto defined as follows: FirstVeto(a 
: ScoreBoard(dom(A0)), b: ScoreBoard(domB0), c : merge(dom(Ao),dom(Bo))) returns score ( if a.color!model 
= ~ then return ~; else if a.star!!model = ~ then return ~; else return b.model!quality; ) The preference 
function combine(FirstVeto)(Ao, Bo) would be the desired combined preference function. If Alice can't 
stand a particular refrigerator, then she would veto it and the result would be a veto. If Alice chooses 
not to veto a particular refrigerator, then Betty's preference would be the one that is returned. For 
example, assume Alice hated all the model 123 refrigerators and the green refrigerator in model 234; 
if she had no preference among the other refrigerators, then her preference function A0 would be: Ao((color 
= *, model = 123}) = Ao((color = green, model = 234)) = A0(r) = ± for all other records r. Let's look 
at a particular example in which Alice's veto prevails. Let ri = (color = purple,model = 123, quality 
= 2}. combine( firstVeto)( Ao, Bo )(rl ) = FirstVeto(Scores(Ao, rl), Scores(Bo, rl), rl) = FirstVeto((color!model 
= l, star!!model = ~),  (model!quality = Bo(rl ) ), rl ) = Let's look at a particular example in which 
Betty's preference prevails. Let r2 = (color = purple, model = 234, quality = 2}. combine( first Veto)( 
Ao, Bo )( r~ ) = firstVeto(Scores(Ao, Scores(Bo, = FirstVeto((color!model = .L, star!!model = .L}, (model!quality 
= B0(r~)}, r~) = B0(r2) In the roommate example, note that the final argu- ment to FirstVeto is ignored. 
A variation on the exam- ple would be that Alice can not veto a refrigerator with a quality rating of 
at least 3. In this case, the definition of FirstVeto would change to: FirstVetoSometimes(a : ScoreBoard(dora(A0)) 
, b : ScoreBoard(domB0), c: merge(dom(Ao),dom(Bo))) returns score .[ if c.quality _> 3 then return b.model!quality; 
else if a.color!model = ~ then return ~; else if a.star!!model = ~ then return h; else return b.model!quality; 
} 2.3 Modular Combining Forms In this section, we formalize and study the notion of the modular combining 
forms (see Definition 2.12). Having modular combining forms has two desirable results. The first desirable 
result is that autonomy of various preferences is conserved. If a preference function is created using 
only modular combining forms, then a user may change a preference for a particular record (in one of 
the original preference functions) without affecting any preference (in the final preference function) 
for any unrelated records. For example, if Alice changes her perference towards yellow refrigerators 
in model 123, this will have no affect on the final preference for green refrigerators in model 123. 
The second desirable result is that an implementation need only provide first order value functions. 
The value functions do not need to take entire preference functions as arguments. Instead, they only 
require the finite amount of information that is contained in a scoreboard. Next we say when two preference 
functions are equivalent with respect to a record in their domain. The idea is that they agree on all 
the information that is relevant to a record. Definition 2.11 Let p and p' be preference functions with 
the same domain. Let r be a record of type dora(p). We say p and p' are equivalent with respect to r 
iff = p' for all r We are now ready to define the modular combining forms. Definltlon 2.12 A combining 
form C based on (rtl,..., rtn) is modular iff = provided that for all i < n, Pi and p~ are equivalent 
with respect to rrt,(r). It is clear this definition captures the desired notion of relevance. If a user 
changes their preference on a given record r (thereby changin their preference function from p to p'), 
it is clear that p and p~ are equivalent with respect to any record which is not generalized by r. The 
result of the new combined preference function will agree with the old combined preference function on 
all the records that are not generalized by r. Modular combining forms enjoy the property of being closed 
under composition. This is formalized in Proposition 2.13 which, to enhance readability, is stated only 
for binary combining forms. Proposition 2.13 Let {rtl, rt2, rt3, rt4} be a compatible set of record types. 
Let C1, C2, and Cs be modular preference combining forms based on (rtl, rt~), (rts, rt4), and (merge(rQ 
, r~2), merge(re3, r~4)) respectively. Then the combining form Co based on (rtt, rt2, rts,rt4) de-y ned 
by Co(p , P2, p3, = P2), C2(p3, P4) ) is a modular combining form. Proofi This is proven as Proposition 
6.1 in Ap- pendix A (Section 6). [] Now that we have seen that modular combining forms are desirable 
to have around, Theorem 2.14 is important because it guarentees that all the preference combining forms 
defined using combine are modular. Theorem 2.14 If f is a value function based on (rQ,...,rtn), then 
combine(f) is a modular combining form based on (rtl, .... ft,). Proof: This is proven as Theorem 6.2 
in Appendix A (Section 6). [] 2.4 Preference System Definition 2.15 A basic preference system is a collec- 
tion of record types, and for each record type, a collec- tion of preference functions with that domain 
(called the available preference functions}, and a collection of value functions (called the available 
value functions} each of which is based on a finite collection of those record types. A basic preference 
system is closed iff combine(/)(p1,..., p,~) is an available preference func- tion provided Pl,...,Pn 
are available preference func- tions and f is an available value function that is based on {dora(p1),..., 
dom(p~)}. It is important to note that a basic preference system need not make available all possible 
preference functions. We expect that it will be the case that most basic preference systems will be closed 
but to increase flexibility, we do not require this. For example, a system designer might put a sematic 
condition that a score for any record be within ten percent of the score of any of its generalizations. 
Since this might be a difficult condition to enforce within the value functions, all the possible value 
functions might be available even though the combined preference function might not be available. This 
system would, therefore, not be closed. 3 Flexibility In this section, we discuss how flexible basic 
preference systems are. We first model a single person system in which several preference functions from 
the same person that cover different aspects of a total picture are combined. We use the popular Personalogic 
system for this purpose. We then consider a multiple person system in which preferences of two (or more) 
individuals are combined into a single preference function. We have already seen an instance of this 
in the roommate example; we now model a real-life design application. Finally, we present a completeness 
results that explains the power of our framework. 3.1 Modeling Personalogic part databases become cognizant 
of individual prefer- The Personalogic system 2 is a popular system for making selections and ordering 
results based on user provided preferences. We sketch below how the functionality provided by Personalogic 
can be realized as a special case of our framework. We will use Personalogic's decision guide for selecting 
a dog for illustration. The dog decision guide allows users to express pref- erences for various attributes 
of different breeds of dogs through a series of questions. These attributes include size, indoor energy, 
exercise time, trainability, barking, history of inflicting injuries, dog group, and coat char- acteristics 
such as length, shedding, and hypoallerginic- ity. The user can also specify the importance of indoor 
energy, exercise time, trainability, and barking. The values not selected for some of the attributes 
(size, dog group, coat length) act as vetoes. For other attributes, the user may indicate preference 
or no opinion. For the history of inflicting injuries and hypoallerginicity attributes, the user may 
also specify must not have val- ues. The system computes a combined score for each dog in the database 
based on the weightings of all the individual preferences, provided that all the predicates are satisfied, 
and returns results ordered by score. The reader can immediately note that this system is easy to model 
in our basic preference system. The choices on individual attributes would be a preference function on 
that attribute. A predicate could be treated as a veto if the predicate is not satisfied. The user controlled 
weighting could be modeled as a value function. The reader can also note that a system built on the basic 
preference system would provide more flexibility in allowing users to express preferences. For instance, 
the user does not have the option of specifying prefer- ence values for a combination of attributes in 
the Per- sonalogic system. This can be important for a user who wants to veto a combination of some specific 
val- ues for different attributes while admitting those values in other combinations. 3.2 Design Application 
 Design houses typically have component engineering de- partments that are responsible for approving 
and rating parts that are allowed to be used by design engineers in the company products. Within the 
guidelines provided by the component engineering, design engineers have considerable flexibility in exercising 
their preferences. We illustrate below how to model this common situa- tion in our basic preference system 
so that searches over 2h'ttp://llnnz. persona.logic, com. Personalogic is now owned by America Online 
(AOL) ~nd their customers include National Geographic, American Express, and ~2"IYade. ences. A design 
house deals with three major product cat- egories: inductors, capacitors, and resistors; these are represented 
by a field called "Product". For each of these categories, there are further subcategories; these are 
represented by a field called "Subcatory". Manu-facturers X, Y, and g supply all the three categories; 
these are represented by a field call "Manufacturer". The component engineering has forbidden the use 
of all parts from Z. It has rated inductors from X as superior (score = 0.8) and capacitors as good (score 
= 0.6). On the other hand, the ratings for inductors and capacitors from Y are good and superior respec- 
tively. Component engineering has not yet rated re- sistors. To save writing, we present the records 
as a (Manufacturer,Product,Subcategory) list. The compo- nent engineering expresses these preferences 
as follows: Co(Z, ,, ,) = Go(X, inductors, ,) = 0.8 Co(X, capacitors, *) = 0.6 Co(Y, inductors, .) = 
0.6 Co(Y, capacitors, ,) = 0.8 Engineer Elizabeth generally likes products from Y better than products 
from X, except that she really likes ceramic resistors built by X. She also thinks highly of resistors 
made by g. She expresses her preferences as follows: s0(Y, ,, ,) = 0.8 So(X, *, *) = 0.7 E0(X, capacitors, 
ceramic) = 1.0 Eo(Z, resistors, ,) = 0.9 By providing different combining forms, it is possible to implement 
different policies that affect search results in different ways. Note that neither component engineering 
nor Elizabeth has to restate any of their preferences. Example of policies include: Component engineering 
has priority. Elizabeth's searches for inductors will resolve in favor of X, searches for capacitors 
will resolve in favor of Y, and searches for resistors will resolve in favor of Y. The interesting case 
is the resistor case. Elizabeth's preference for Z for resistor is vetoed because of blanket ban on Z. 
However, since component engineering has no preference between X and Y for resistors, Elizabeth's general 
preference for Y over X prevails.  Engineer's preferences have priority unless vetoed by component engineering. 
All of Elizabeth's searches now resolve in favor of Y since she prefers Y over X, except for ceramic 
capacitors for which she has explicit higher preference for X. Her preference for g for resistors has 
been vetoed by the component engineering's veto on g.  As the time goes by, Elizabeth was able to convince 
component engineering to loosen its ban on g for resistors. However, component engineering still rates 
resistors from Z, below than those from X. It can simply add the following preferences: C0(X, resistors, 
*) = 0.8 Co(Z, resistors, ,) = 0.6 No change is required in the combining forms. The reader can easily 
verify that these .additions do not affect the results of searches for inductors or capacitors. Elizabeth's 
search for resistors now resolve in favor of X under the first policy and in favor of Z under the second. 
3.3 Completeness off Combine Operator We have seen the tremendous flexibility of a basic preference system. 
In fact, there is good reason for this. The combine meta-combining form (Definition 2.10) is complete 
in that all modular combining forms are definable using combine!!! This is formalized in Theorem 3.1. 
Theorem 3.1 Let C be a modular combing form based on ( rt l , . . . , rt,~ ) . Then there is a value 
function f based on (rtl .... , rtn) such that C = combine(f) Proof: This is proven as Theorem 6.3 in 
Appendix A (Section 6). [] PuttSng this result together with the fact that combine(f) is always modular 
gives us the following complete characterization of the modular combining forms. Theorem 3.2 C is a modular 
combining form based on (rtl,..., rtn) iff there exists a value function f based on (rt~,..., rt~) such 
that C = combine(f). Proofi Follows from Theorems 2.14 and 3.1. [] 4 Implementation on a Relational Database 
System Let us consider the roommate example and see how it might be represented using a relational database 
system. The purpose of this example is to show how a relationM database system could be used to implement 
a basic preference system. There are many other possible ways to implement a basic preference system 
and we think there is a good bit of interesting research to be done to take full advantage of a database 
system. In one such implementation, Alice and Betty's prefer- ence functions can be stored in separate 
tables. Records with score of .L are not represented. Alice's preference function:  I Color I Model 
II Score I Red 123 0.4 Green 234 White 456 0.8 White 234 0.6 Betty's preference function: Model Quality 
II Score I 123 3 0.7 123 4 0.9 234 4' 0.5 345 3 0.3 345 4 0.5 Here is how a system Would compute the 
combined preference function defined by combine (First Veto)( A o, Bo ). Given a record r, the system 
would perform the follow- ing steps: 1. Form the ScoreBoard called sba for A0 as follows: (a) Issue the 
query: SELECT Score FROM Alice WHERE Color = r.color AND Model = r.model Store the unique answer in sb_a.color!model 
(and let this value be ..1_ if the query returns an empty answer). (b) Issue the query: SELECT Score 
FROM Alice WHERE Color = * AND Model = r.model Store the unique answer in sb~.star!!model (and let this 
value be _l_ if the query returns an empty answer). 2. Form the ScoreBoard called sbb for B0 as follows: 
(a) Issue the query: SELECT Score FROM Betty WHERE Model = r.model AND Quality = r.quality Store the 
unique answer in sb_b.model!quality (and let this value be .L if the query returns an empty answer). 
3. Return the value obtained from the user-defined function First Veto( sb~ , sbb, r) The implementor 
might choose to materialize this new preference function for retrieval efficiency. In this example, we 
assume that there are four colors: Red, Green, White, and Purple; we assume four models: 123, 234, 345, 
and 456; and we assume that there are four quality levels: 1, 2, 3, and 4. Under these assumptions, the 
combined preference function would look like the following: Color Model Quality I[ Score Red 123 1 I 
~ Green 123 1 I ~ Purple 123 1 White 123 1 * 123 1 Red ~123 2 Green 1123 2 Purple i 123 2 White 123 
2 * 123 2 Red I23 3 Green i23 3 Purple 123 3 ]~ White 123 3 * 123 3 Red 123 4 ~. Green 123 4 Purple 
123 '4 ~....... White 123 4 ~.. * 1i23 4 [~ Color I M0del I Q,uality II Score Red ii234 4 0.5 Green 
1234 1 Green i234 2 Green ! 234' ' 3" Green '234 4 Purple 234 4 0.5 White 234 4 0.5 * 234 4 0.5 Red 
345 3 0.3 Green 345 3 i0.3 Purple 345 3 0.3 White 345 3 0.3  * 345 3 t0.3 Red 3~i5 4 I 0.5 Green 345 
4 0.5 Purple 345 4 0.5 White 345 4 0.5  * 345 4 10.5  Of course, there is a lot of redundancy in the 
above table. There are many interesting research questions that merit further investigation such as: 
when to materialize; how to have more compact representations of the preference functions; what restrictions 
to put on the available preference functions and available value functions to permit an efficient implementation; 
etc. Summary We have presented a framework for expressing and combining user preferences. The system 
is very lean in that it only has two basic notions: 1. A preference function (Definition 2.1) that specifies 
user preferences. 2. A single meta combining form combine (Defini-tion 2.10) that is based on value 
functions (Defi- nition 2.9).  Yet, in spite of its very lean nature, the framework is very powerful. 
The single combine meta-function is able (in conjunction with the value functions) to express all modular 
preference combining forms (Theorem 3.1). In addition to being quite powerful, the basic pref- erence 
system is quite flexible since it does not require the system to provide every possible preference func- 
tion or every possible value function. Limits might be placed to facilitate user interaction, impose 
semantic conditions, or enable an efficient implementation. Fur- thermore, there is flexibility in that 
the system does not arbitrarily limit the possible value functions. Future Work Since this paper presents 
a framework, there is a lot of work that can be done realizing this framework. There is considerable 
room for system im- plementors to address efficiency issues and experiment with user interfaces. In fact, 
a generic user interface could be built for a basic preference system that would work with any preference 
system. Different represen- tations of preference functions are possible. Another important issue concerns 
value functions. We expect the system to have a library of canned value functions that should meet the 
needs of a large number of users. But should value functions be definable by end users and what would 
be a good interface? References <RefA>[Arr50] K.J. Arrow. A difficulty in the concept of social welfare. J. 
of Political Economy, 58:328-346, 1950. [BP96] John M. Berrie and David E. Presti. The word wide web 
as an instructional tool. Science, 274:371-372, 1996. [EHJ+96] O. Etzioni, S. Hanks, T. Jiang, R.M. Karp, 
O. Madani, and O. Waarts. Efficient infor- mation gathering on the internet. In 37th Annual Syrup. Foundations 
of Computer Sci- ence, 1996. [Fag98] Ronald Fagin. Fuzzy queries in multimedia database systems. In 
17th A CM Syrup. Principles of Database Systems, June 1998. [FISS98] Yoav Freund, Raj Iyer, Robert E. 
Schapire, and Yoram Singer. An efficient boosting algorithm for combining preferences. In Machine Learning: 
15th Int. Conf, 1998. [HS99] John Hagel and Marc Singer. Net Worth. combine(f) is a modular combining 
form based on Harvard Business School Press, 1999. [LG99] Steve Lawrence and C. Lee sibility of information 
on th400:107-109, 1999. Giles. e web. Acces-Nature, [RV97] P. Resnick and H. Varian. systems. Communications 
40(3), 1997. Recommender of the A CM, [SM831 G. Salton and M. McGill. Modern Information Retrieval. Introduction 
to McGraw- Hill, New York, 1983. 6</RefA> Appendix A: Modular Combining Form Proofs Proposition 6.1 (Restatement 
of Proposition 2.13) Let {rtl, rt2, rt3, rtd} be a compatible set of record types. Let Ct, C2, and Ca 
be modular preference combining forms based on (rQ, rtz), (rta, rta), and (merge(rt,, rtz), merge(rt3, 
rtd)) respectively. Then the combining form Co based on (rt~, rt~, rts, eta) de-fined by C0(p~, p~, Ps, 
Pa) = Cz( Ct (p~, pz), Cz(pa, Pa) ) is a modular combining form. Proof.. First note that it is clear 
that Co is based on (rtt,rt2,rts, rtd). .Let r be a record of type merge(rtl,rt2,rts,rtd). Assume that 
pi and p~ are equivalent with respect to Ir~t,(r) for i = 1,2,3,4 with the goal of showing that Co(p~,p2,pz,pd)(r) 
= / I I c0(p~, p~, p~, p~)(r). First we show that C~(p,,p~) and C,(pt,p~) are equivalent with respect 
to Irmerg~(rtxxt~)(r). Let rtDTrrnerge(rtt,vt~)(r ). Let r" Dr'. Then ~r,t,(r") t> 7r, t,(C) I:> 7rrt,(vme,ge(rt,,rt,)(r)) 
= ..,,(r). Thus, p~(..,,(r")) = p;(~.t,(r")) since p, and p~ are equivalent with respect to Irrt,(r). 
Thus, Pt and p~ are equivalent with respect to C. Similarly, P2 and p~ are equivalent with respect to 
C. Since, C1 is modular, it follows that C1 (pl, p2)(r') = C1 (p~ , p~)(r'). ! I This proves that C~(p~,p2) 
and CI(Pt,P2) are equiv-alent with respect to ~rmerge(rtx,rt2)(r). Similarly, C2(ps, p4) and C2(p~,p~) 
are equivalent with respect to ~'m~ge(~t~,¢t,) (r). Since Ca is a modular combining form based on (merge(rQ, 
rt2), merge(rta, eta)), it follows that Ca(C1 (pt, pz), C~(ps, pa))(r) = Cs( C~ (p~, p~), C2(p~, p~) 
)(r). This proves that l I I I co(p~, p~, p~, p4)(r) = Co(p~, p~, p~, p~)(r) as desired. [] Next we 
show that every combining form defined using the combine operator is modular. This is formalized in Theorem 
2.14. Theorem 6.2 (Restatement of Theorem 2.14) If f is a value function based on (rtl,...,rtn), then 
 (rt~,...,rt,). Proof: Let pl ..... p,~ and p~,...,p~ be preference functions such that dora(p,) = rt, 
= dom(p~) for all i < n. Let r be a record of type RT = merge(rQ,..., rtn~. Let f be a value function 
based on (rtl,...,rtn). Assume that p, and p~ are equivalent with respect to rt, for all i <_ n. The 
goal is to show that combine(f)(p~ , . . . , p~ )(r) = combine(f)(p~ , . . . , p~)(r ). Let no be an 
arbitrary name of a field in ScoreBoard( rt/ ). Scores(p,, 7r,ti(r)).no = p~(RecordOf,.t,('rr,t,(r), 
no)) = p~(necordOf,,,(~,,,(r), no)) since RecordOf ,t, ( ~r,t,( r), no)) ~> r,,,(r) = Sco~s(p~,..dr)).no 
 Since the choice of no was an arbitrary name in ScoreBoard(rt,), it follows that Scores(p,, r,,,(r)) 
= Scores(p~, ~r,,,(r)) for all, _< n. We can compute as follows: co~bine(f)(p~,...,p~)(r) = f(Scores(p,,..,,(r)),..., 
Scores(p~,..tAr)), r) = f(Scores(p~,rrt,(r)),..., Scores(p~,Trrt,(r)), r) = combine(f)(p~,...,p~)(r) 
 as desired. [] Now that we know that every combining form combine(f) is modular, the next question to 
address is are there any other modular combining forms other than the ones definable by combine. It turns 
out the answer is no. This means that every modular combining form can be expressed using the combine 
operator. This is formalized in Theorem 3.1. Theorem 6.3 (Restatement of Theorem 3.1) Let C be a modular 
combing form based on (rtl, . . . , rtn). Then there is a value function f based on (rtl, . .., rtn) 
such that C = combine(f). Proof: It is helpful to have a function NameOf that takes a record of type 
rt for any type rt with field names nl,...,nk and produces a name of a field in ScoreBoard(rt) as follows: 
NameOf(ro) = n~!...!n~ where n~ = ni if r0.n, ~ * and n~ = star! if r0.n, = *. It is clear that if r0 
t> r, then Reco,dOf ~t,(r, NameOf(ro)) = to. First defined a set valued function S: ScoreBoard(rti ) 
x ... x ScoreBoard(rtn) x merae(rtl,..., rtn) --+ 9(score). Recall that :P represents the power set operation 
so that ?~(score) is the set of all subsets of score. The definition of S is as follows: Define so E 
S(sbl,...,sbn,r) iff there exist preference functions Pl,...,P,~ such that C(pl,...,pn)(r) = So and Vi 
< n(dom(p,) = rt,&#38;Scores(p,, rrrt,(r)) = sb,). It is clear that C(p~,...,p,)(r) e S( Scores(p , 
, ¢r,t, (r)),..., Scores(p,, ¢r,t.(r)), r). Assume that So and s~ are elements ofS(sbl,..., sbn, r). 
Hence, it follows that so = C(pl,...,p,~)(r), s~ = C(pl , . . . , p~ )(r), and Vi < n( Scores(p,, rr~t,( 
r) ) = sbi = Scores(pi, ~rrt,(r)). Let ri t> ~'rt.(r). p,(r~) = p,(RecordO/,,,(~dr), N~eOf(r~)) = Scores(pi,rrt,(r)).NameOf(r,) 
= Scores(p~,~,,,(r)).NameO/(r,) since Scores(p,, ~,,,(r)) =   Sco,es(p;, ~,,,(~)) = p;(RecordOf,,,(~r,,,(r), 
NameO.f(r,)) = p;(r,) Hence, it follows that pi and p~ are equivalent with respect to 7r~t,(r) for all 
i < n. Since C is a modular combining form, it follows ~at s0 = C(pl,... ,p,)(,) = C(pl, ...,p',)(,) 
= s~. This proves that S(sbl,...,sb~,r) has at most one element. If S(sbl,..., sbn, r) is empty, then 
define /( sbl, . . . , sb,~, r) = .L; otherwise, define f(sbl,...,sbn,r) to be the unique member of 
S( sbl , . . . , sb, , r ). Since C(pl,...,p,~)(r) e S(Scores(p,,rrt,(r)),..., Scores(p,,~rrt,(r)), r), 
it follows that C(p~,...,pn)(r) = .f(Sco~s(p,, ~,d~)),..., S¢ore~(p~, ~,~,(r)), ~). By Definition 2.8, 
it follows that c(p~, . . . ,p~)(r) = comb,,e(/)(p, , . . . , p~)(~) as desired. []  
			

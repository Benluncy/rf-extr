
 A Development Methodology for Distributed Ada Applications * C. Mugur Stefanescu H. Dieter Rombach 
t Compass, Inc. 550 Edgewater Drive Wakefield, MA 01880 Abstract The DAPSE (Distributed Ada Programming 
Sup- port Environment) research project aims at (i) produc- ing a technology base for developing future 
Ada pro- gramming support environments and (ii) demonstrating the suitability of this technology base 
by using it to build a prototype environment for the development of distributed Ada software. In this 
paper we emphasize those parts of the DAPSE project that specifically address the methodology and software 
tool support for building distributed applic~ tions in Ada. Our paper is structured into three major 
parts: (1) a brief overview of the entire DAPSE project and a gen- eral framework for distributed programming, 
(2) the spe- cific distribution strategy chosen for the DAPSE project and the initial DAPSE distribution 
tool kit intended to support the chosen distribution strategy (including first lessons learned), and 
(3) future plans.  Introduction Ada has been designed to support the development of sequen- tial~ parallel~ 
and distributed software applications. As of to- day, however, none of the existing compilers, run-time 
environ- ments, or Ada Programming Support Environments provide adequate support for developing distributed 
Ada programs. The state-of-the-practice in developing distributed Ada appli- cations is to manually distribute 
distinct Ada programs and implement the required communication between them (e.g., substituting the regular 
Ada communication mechanisms by system calls to an underlying communication layer). *This work was performed 
under contract DAAB07-85-C-K572 for the U.S. Army, Ft. Monmouth, N. J. tWith University of Maryland 
COPYRIGHT 1988 BY THE ASSOCIATION FOR COMPUTING MACHINERY, INC. Permission to copy without fee all or 
part of this material is granted provided that the copies are not made or distributed for direct commercial 
advantage, the ACM copyright notice and the title of the publication and its date appear, and notice 
is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, 
orto republish, requires a fee and/or specific permission. The DAPSE (Distributed Ada Programming Support 
En- vironment) project is (i) a comprehensive research project that aims at producing a technology base 
for developing future Ada programming support environments and (ii) a software pro- totype activity aimed 
at demonstrating the suitability of this technology base for supporting the development of distributed 
Ada applications ([10], [11]). The DAPSE project addresses issues related to supporting the cost-effective 
development and maintenance of quality Ada software ([4]). In this paper we restrict our discussion to 
the DAPSE project issues that specif- ically address the methodology and software tool support for building 
distributed applications in Ada. In the first part of this paper we provide background infor- mation 
about the objectives and scope of the entire DAPSE project (section 2) and introduce a framework of general 
is- sues related to distributed programming (section 3). In the second part of this paper we discuss 
the specific strategy for developing distributed Ada programs chosen for the DAPSE project (section 4) 
and its initial prototype support (section 5). The discussion of the DAPSE distribution strategy includes 
a characterization of our intended application domain, the ratio- nale for choosing a specific strategy, 
a description of the chosen strategy, and its relationship to the framework. We also de- scribe our research 
and development plans. The initial proto- type is described in terms of its current status, the first 
lessons we learned, and our next steps. In the final part of the paper we discuss future directions for 
research and development in distributed programming (section 6).  2 DAPSE Project Overview The Distributed 
Ada Programming Support Environment (DAPSE) project is a multi-yea~r research effort at Compass, Inc. 
The DAPSE project aims at developing a technology base for the construction of future Ada programming 
support envi- ronments (APSEs). The primary goals of the DAPSE project are the develop- ment of an architectural 
framework for future APSEs and the development of a coherent environment construction method allowing 
for customized generation of environments from for- real specifications (generator technology). Within 
this framework, we specifically address user interface techniques and approaches to distributed programming 
[15]. Research results are being implemented and evaluated through a series of experimental prototypes. 
2.1 DAPSE Construction Method: Generators The DAPSE technology base allows for the customized gen- eration 
of automated tools from specifications within the con- text of an environment framework. This generator 
approach provides for tallorability and flexibility at the tool level. An instantiation of this approach 
for the process of compilation is presented in Figure 1. source code  ~toob ~ too=(au:TtÂ°doomp,,er 
generator I ] proc( grammar comp(ler-comp(ler object code Fig.1 Generator technology paradigm for compilers 
 Tools (e.g., compilers) automate software processes (e.g., translating source code into object code). 
Before generators (e.g., compiler-compilers) can generate tools from specifications (e.g., grammars), 
a thorough understanding of the principles underlying the processes and the structure of the correspond- 
ing tools is required. Such thorough understanding is usually the result of building and evaluating a 
series of prototype tools. The actual generator approach is reflected in the horizontal di- mension of 
Figure 1, whereas the preceding phase of under- standing and learning is reflected in the building of 
a number of prototypes in the vertical dimension of Figure 1. Generator technology increases the potential 
for reuse by allowing the reuse of generation of processes in addition to in- dividual tools (the results 
of such generation processes). This approach decreases the "reuse with modification" problem to modifying 
just the tool specification instead of the tool itself. 2.2 Objectives of the DAPSE Project with regard 
to distribution Creating a technology base for developing distributed Ada ap- plications is one of the 
main objectives of the DAPSE project. The idea is to support the development of distributed Ada ap- plications 
throughout the lifecycle, especially during specifica- tion, design, coding, distribution, and testing. 
Automated sup- port will be provided through a set of tools, hereafter refered to as the Distribution 
Tool Kit. The prototyping of these tools will help us understand how the generator-based construction 
methodology can be applied to building Distribution Tool Kits.  3 A Distributed Programming Framework 
No programming language (such as Ada) can solve all the prob- lems related to distributed programming. 
A language generally allows the representation of the result of some problem solving process. The problem 
solving process itself is concerned with mapping some application into a software solution running on 
a distributed computing system. This mapping will exploit the inherent parallelism of the application 
and the resource char- acteristies of a given computing system to fulfill non-functional requirements 
(e.g., performance, fault-tolerance). We provide a software process model for developing distributed 
software, which consists of four stages (Figure 2): APPLICATION DEVELOPMENTstage IMPLEMENTATION stage 
CONFIGURATION  {.ar were spoo stage EXEC~ stage Fig.2 Four-stage model for building distributed applications 
($1) Application development stage specifies and designs an application solution. During these activities, 
the in- herent application-oriented parallelism is exposed (im- plicitly or explicitly). ($2) Implementation 
stage represents the exposed poten- tim parallelism using the features provided by an imple- mentation 
lmaguage (e.g. Ada). We distinguish between the actual language features (which are supposed to pro- 
vide a certain level of abstraction) and their particular implementation using compilers and run-time 
systems. ($3) Configuration stage decides on the actual physical dis- tribution and tries to find a good 
mapping of the paral- lelism contained in the implemented software product and the physical parallelism 
provided by a distributed hard- ware architecture. (S4) Execution stage deals with all issues related 
to the ac- tual testing and usage of distributed software in its target environment. Solutions at these 
four stages are not independent of each other. For example, if we decide on some language (e.g., Ada) 
to be used during the implementation stage, we need to support the application development stage in a 
compatible way. The distribution model used for designing a solution must allow for the utilization of 
the features provided by the implementation language. We can often compensate for insufficient solutions 
at one stage with the richer solutions at other stages. For example, lack of appropriate explicit distribution 
units in the implemen- tation language can be compensated for by guidelines for dis- tribution (compatible 
with the unit structure available at the implementation stake) at the application development stage. 
A similar compensation is made when we design software in a modular way without having the corresponding 
features in the implementation language. The solution is to incorporate the idea of modularization (e.g., 
abstract data types) into the design model and implement them implicitly with whatever fea- tures the 
implementation language offers. For example, we can use the concept of abstract data types independently, 
whether our implementation language is Ada or Fortran. The advantage of Ada is that we have a corresponding 
language feature (pack- ages) to reflect abstract data types explicitly. In the same way, although it 
would be desirable to see some distribution model explicitly incorporated into a language that claims 
to support distributed programming, we can compensate by using good distribution models at the application 
development stage. In the following subsection we provide a general framework for distributed programming. 
In section 3.1 we present some of the choices for supporting distributed programro which allows us to 
put our specific DAPSE approach into I ,ective. In section 3.2 we summarize the major support areas that 
are needed in the context of distributed programming (both from a constructive and an analytic perspective). 
3.1 Characterization of the Approaches An analysis of past and present distributed systems projects, 
such as ARGUS, CIRCUS, CLOUDS, EDEN, INCAS, ISIS, LOCUS and ISIS [14], shows a wide spectrum of potential 
alter- natives for distributed programming. Important related issues are summarized below. (Q1) What 
is the appropriate distribution model? (a) Granularity/type of distribution units (e.g., en- tire programs, 
subsystems = clusters of passive and/or active modules, modules, statements): A discussion of various 
approaches and related con- sequences in the case of Ada is contained in [Corn- hill 84]. Cornhill distinguishes 
between distributing entire Ada programs, Ada tasks (active units), pack- ages and subprograms (passive 
units), and all kinds of named program units in the most general case. For example, the distribution 
of entire programs as- sumes an early structuring of an application into sep- arate programs. The benefits 
are that each of those programs can be developed without further consid- erations of distribution, except 
for external commu- nication. The disadvantages are that the entire ap- plication cannot be compiled 
as one program (e.g., no static checking of interface consistency at com-pile time). On the other hand, 
any other model of distribution units (except library subprograms and library packages with clearly defined 
interfaces) cre- ates problems in Ada without guidelines for using it properly (e.g., no sharing of reference 
variables between distribution units, etc.). There are two so- lutions to this problem: (i) to restrict 
the imple- mentation language, or (ii) to provide application development support that guides the structuring 
of the application towards proper use of concepts that can be represented by explicit language features. 
 (b) Type of communication among distribution units Synchronous mechanisms are preferred from a soft- 
ware engineering perspective, because they allow proofs of the program correctness. Logically, they extend 
the traditional local communication mecha- nisms to remote communication. However, we are not convinced 
that all kinds of real-time require- ments can be fulfilled with this kind of mechanism. The open question 
is whether both types need to be provided at the language level, or whether we can live with synchronous 
communication at the lan- guage level and can delegate the actual implementa- tion to an intelligent 
compiler or run-time system. (Q2) How should communication between distributed Ada units be provided, 
transparently or non-transparently? Non-transparent communication assumes that the devel- oper must be 
aware whether a inter-unit communication is local or remote before the loading phase; transparent communication 
does not. Non-transparent communica- tion might mean that the developers have to choose be- tween local 
and remote communication features or must implement remote communication themselves. Both of these approaches 
have the disadvantage that they result in static configurations of a distributed program. When- ever 
the parts of the distributed program will be re-hosted, some re-programming might be involved. Ada claims 
to allow for distribution. Currently, the overwhelming ma- jority of validated Ada compilers do not support 
trans- parent remote communication. Transparent communication assumes that the developer creates a net 
of communicating software distribution units independent of physical distribution. This can be achieved 
either by having a compiler that (based on distribution information) creates different code for local 
or remote communication, a run-time system interpreting commu- nication calls (based on distribution 
information) during execution, or by a post-processor transforming compiled centralized programs into 
distributed programs (based on distribution information). All three approaches are pos- sible in Ada. 
 (Q3) When should the developer deal with the distri- bution aspects? This is the most crucial part of 
the distributed program- ming framework. There are applications that require a certain distribution, 
because of the configuration of the physical process (e.g., embedded control systems). There are other 
cases (especially if parallelism and distribution are to be exploited at the statement level or lower) 
where the user does not have to deal with distribution at all, because an intelligent compiler can derive 
a good distri- bution simply based on data-flow analysis. In general, we believe that distribution should 
be dealt with in three steps: (i) identify the potential parallelism of some appli- cation, (ii) formulate 
this parallelism as part of the prod- uct implementation, and (iii) map the product onto some distributed 
hardware architecture, trying to exploit the parallelism reflected in the implementation to the degree 
possible or to desired. Steps (i), (ii) and (iii) are usu-ally dealt with during the application development, 
im- plementation, and configuration stages respectively (see Figure 2). In summary, we can distinguish 
between three different ap- proaches to distribution. 1. Only during the application development stage. 
Identify units of distribution based on application con- straints (e.g., embedded systems) early on, 
and develop each of these distribution units without regard to distri- bution. 2. Only during the configuration 
stage. Disregard distribution during the application development and implementation stages and deal 
with distribution based on an analysis of the implemented product (e.g., in the case of distributing 
a program at the statement level onto a vector machine).  3. Throughout the application, implementation, 
and config- uration stages.  Guide the user during the application development stage towards defining 
distributable units that are compatible with the structural concept of the implementation lan- guage. 
Guide the user during the implementation stage towards using the implementation language features ef- 
fectively and suggest mappings of distributable software units onto physical hardware nodes during the 
configura- tion stage. 3.2 Necessary Support Areas To effectively implement non-functional requirements, 
such as performance or fault-tolerance (which are often the drivers for distribution), we need to support 
the application development, implementation, configuration and execution stages properly. Proper support 
can address the constructive steps for achiev- ing distribution or the analysis of constructed products 
with respect to distribution. For example, if we only want to allow the distribution of non-nested packages, 
we can either provide constructive support in the sense that a design model is followed which does not 
permit nesting of package-like units, or we can apply some kind of analysis of a program (developed without 
knowing the non-nesting requirement) and identify candidate packages for distribution which are not nested. 
Ultimately, we would like to support as many constructive aspects of dis- tributed programming as possible. 
There are limitations to this approach due to our poor understanding (as a community) of the process 
of developing distributed software. Analysis (case studies of actual developments, experiments) can help 
us un- derstand what needs to be supported during the development of distributed programming. Only when 
we understand the pos- itive and negative impacts of a chosen distribution approach can we effectively 
support it during development. 3.2.1 Constructive Support Constructive support is required for all four 
stages of our pro- cess model (see Figure 2). During the application development stage, we need to support 
the specification of non-functional requirements that axe the drivers for distribution (e.g., fault tolerance, 
performance, availability, security), and the trace- ability of these non-functional requirements through 
all design steps. Without traceability of non-functional requirements, what would unit and integration 
testing mean as far as such re- quirements were concerned? During the implementation stage, we need an 
appropriate language compiler and an editor (struc- tured or syntax-directed). In addition, we need guidelines 
for using the existing features of an implementation language in the context of a distribution model. 
During the configuration stage, we need guidelines as to what mappings (software onto hardware) are promising 
to fulfill the non-functional require- ments. This includes the specification of hardware character- 
istics. During the execution stage, we need support for dis- tributed loading, testing, and monitoring. 
 3.2.2 Analytic Support We should also provide analytical support for feedback and control wherever we 
cannot completely automate construction, or for the purpose of learning wherever we do not clearly un- 
derstand the construction process. Examples from the appli- ca~tion development stage are the evaluation 
of designs with respect to possible degree of parallelism, or the checking of the validity of traces 
of non-functional requirements through- out the design process. Examples from the implementation stage 
are the analysis of source code to determine whether lan- guage features were used properly or whether 
the implemented program restricts the degree of parallelism more than necessary (compared to the potential 
parallelism expressed as a result of the application development phase). Examples from the con-figuration 
stage are determining a good mapping of a given source code program onto a distributed system, determining 
a good distributed system architecture for fulfilling specific non- functional requirements with a given 
source code program, or identifying the implicit potential for parallelism of a given pro- gram that 
does not address parallelism explicitly at all. Ex-amples from the execution stage are determining the 
actual performance or fault-tolerance of a distributed system (testing or monitoring software in its 
target environment), determin- ing the impact of software structure, language features and the implementation 
of those features.    4 Distribution Strategy of the DAPSE Project In this section we describe the 
approaches taken towards a DAPSE Distribution Tool Kit in the context of the framework presented in section 
3. This will not only avoid misunderstand- ings as far as our objectives are concerned, but also allow 
us to compare our approaches with those chosen by other research and development groups. DAPSE is a project 
that aims in part at creating a tech- nology base for developing distributed Ado applications. As in 
every research project of this kind, the prototype implemen- tations are not intended as marketable products, 
but as exis- tence proofs for the kinds of technologies suggested, as well as vehicles for the further 
evaluation and improvement of those technologies. The distribution strategy chosen for the DAPSE project 
is first motivated by the application domain of interest, the par- ticular constraints imposed by an 
Ado environment on choos- ing a particular strategy, and the expectations we have for this project. The 
specific strategy is presented in the context of the framework presented in section 3, and our ideas 
for each of the support areas are outlined. The research character of DAPSE creates expectations at various 
levels: (i) building knowledge as to how distributed programming in Ado should be supported, (ii) lessons 
learned about the impact (pros and cons) of certain language features, as well as their particular implementation 
(it is important to distinguish here between Ado language issues and Ado imple- mentation issues!), and 
(iii) contributing to the better under- standing of the issues of distributed programming in general. 
4.1 Application Domain The application domain at this time is "interactive systems" that do not impose 
any hard real-time requirements. The per- formance requirements imposed are that response times should 
not exceed the limit that can actually be recognized by human beings, on the order of 1/10 second. Again, 
this application domain will be used to prototype and evaluate alternative ap- proaches. It is possible 
that at some later time (armed with a better understanding and validated approaches), we will look into 
application domains with harder non-functional require- ments. 4.2 Rationale The rationale underlying 
our chosen strategy is:  To be able to compile a distributed Ado application with existing validated 
Ado compilers.  To utilize Ado language features in a way that allows to maximize desirable characteristics 
(e.g., performance) through distribution.  To build upon the existing body of knowledge regarding distribution 
[16].  To develop a prototype distribution tool kit based on the generator technology.  The last issue 
points out our commitment to further expla- nation of the generator technology. Figure 3 presents the 
the generator technology paradigm instantiated for building dis- tributed applications. ~ non-distributed 
application tOOI [=-[tool (autÂ°matedl distribution ~ generator ~ process) [ tool specs ofibe distribution 
tool distribution generator model distributed application ................................. p.  Fig.3 
Generator technology paradigm for distribution tools Currently, our work is done along the vertical 
line, trying various approaches for the distribution tool kit. As our un- derstanding grows (this means 
that when we can structure the tools in a systematic way and understand the impact of differ- ent distribution 
strategies), we will start trying to generate at least parts of those tools from some specification of 
the distri- bution strategy (horizontal line). 4.3 DAPSE Strategy Due to the research character of this 
project, we will start with one particular approach, which will be described in this and the following 
subsections, but we plan to compare alternate approaches in many areas. Our interests in the DAPSE Distribution 
Tool Kit include:  To use all kinds of functional units (subsystems, passive and active modules) as 
distribution units that are com- patible with the structural units provided by Ado (see framework: (Q1) 
part (a)).  To use preferably synchronous communication (for the usual software engineering reasons), 
without ruling out the need for using asynchronous communication (see frame- work: (Q1) part (b)).  
To provide transparent communication by generating the required code for communication between remote 
units of distribution using a post-processor which translates cor- rectly compiled centralized Ado (together 
with a descrip- tion of its physical mapping onto a distributed computing system) into a distributed 
Ado program. Eventually, we might provide transparent communication layers allowing for dynamic reconfiguration 
of distributed Ado programs (see framework: (Q2)).  To support the development of distributed Ado programs 
at all four stages of our model (see framework:   (q3)). 4.4 Research/Development Plan The DAPSE 
project's plan for achieving its objectives includes the following tasks: 5 1. To develop a tool for 
automatically generating the neces- sary communication code based upon an Ada program, a description 
of the distributed architecture, and a descrip- tion of the intended mapping of the Ada program onto 
this hardware. 2. To explore technology (and eventually to develop a tool) for analyzing the expected 
performance and/or fault-tolerance of an Ada program based upon its map- ping onto a given distributed 
architecture. 3. To explore technology (and eventually to develop a tool) for helping the developer 
in identifying a "good" mapping of a given Ada program onto a given distributed archi- tecture, or identifying 
a good distributed architecture for executing a given Ada program ("good" is characterized in this context 
as satisfying given performance or fault- tolerance requirements). 4. To document the lessons learned, 
describing the impact of certain characteristics of an Ada program on its dis- tribution potential (these 
lessons learned should result in constructive guidelines for the developers), in relation to non-functional 
requirements. 5. To develop a comprehensive development methodology for distributed software that covers 
all phases, from spec- ification to implementation and testing (the important aspects are to allow for 
the traceability of characteristics that have been identified as impacting the distribution potential 
through all software representation levels). 6. To provide the appropriate infra-structure (measuring 
those characteristics) throughout the development process and guiding the developer through appropriate 
feedback based on past experience.  4.5 Distribution Support Specific to the Life Cycle Our initial 
ideas as to how the application development, im- plementation, and configuration stages could be supported 
are listed below. During the application development stage we will provide support regarding the specification 
and design towards distributed Ada programs. We plan to develop a specification language that allows 
the specification of non-functlonal requirements in addition to functional re- quirements. Possibly we 
will just augment and modify ex- isting specification methods (e.g., TSL [9]). In addition, we plan to 
develop a (preferably graphically oriented) de- sign method that is (a) compatible with the specification 
method as well as with Ada, and (b) allows for the trace- ability of refined non-functional requirements. 
The idea is to support a step-wise refinement process, including functional and non-functional requirements. 
 During the implementation stage we will apply anal- ysis and constructive guidelines for properly using 
Ada language features.  During the configuration phase we will provide sup- port for specifying the 
characteristics of a physically dis- tributed hardware architecture, and mapping a given Ada program 
(hopefully structured in terms of distributable units) onto such an architecture relative to specific 
non- functional requirements. Although this problem cannot be solved in general, we hope that practical 
constraints will limit the domain of possible reductions and thereby make the problem solvable. During 
the execution stage we eventually will support distributed loading, testing, and monitoring. We plan 
to use as many results as possible from other ongoing research projects  5 The Prototype DAPSE Distribution 
Tool Kit As a first step, we are currently implementing a prototype Dis- tribution Tool Kit, which implements 
one specific (limited) dis- tribution approach within the scope of the DAPSE distribution strategy defined 
in section 4.3. 5.1 The initial approach Our initial approach for the Distribution Tool Kit restricts 
DAPSE strategy as follows: (See Figure 4): Issue Framework DAPSE DAPSE Distribution Tool Kit Granularity 
process/subsystem/ module subsystems, modules library units Communication -synchronous -synchronous 
synchronous(RPC) -asynchronous (-asynchronous] Communication -transparent transparent transparent transparency 
-non-transparent (source expansion) -application -application development development -configuration 
stags -implementation -imptementation I-execution] -configuration -configuration *execution -execution 
 Fig.4 Comparative table of proposed framework and current work in DAPSE To use "library packages and 
library subprograms" as the candidate units of distribution. Later, we will look into the possibility 
and problems of allowing non-library units or even all named Ada units that require no dereferencing 
to be distributed (see framework: (Q1), part (a)).  To use synchronous communication (see framework: 
(Q1), part (b)).  To generate communication code by a post-processor as required, based on the physical 
distribution of an Ada program. (see framework: (Q2)).  To handle distribution only during the configuration 
stage. (see framework: (Q3)).  Our initial efforts are based on Schuman's approach [16]. This approach 
is based on Hoare's work on Communicating Se- quential Processes (CSP) [7] and assumes that the application 
is composed of a fixed number of distribution units (mutually disjoint in address space) and communication 
is done through synchronous typed message passing. In this approach, application development according 
to the distribution paradigm consists of an appropriate packaging of the code and specifying the mapping 
on a real architecture. Distribution will be provided by transforming certain constructs (procedure calls, 
entry calls, constant references) into Remote Procedure Calls [12]. The RPCs are implemented by dedicated 
channels, which provide typed bidirectional message passing. This first (limited) approach allows us 
to deal partly with the problems of the configuration and execution stages early on. The pros of such 
an approach is that it will enable us to de- velop a prototype that allows the distributed execution 
of Ada programs quickly (this is required as a basis anyway). The cons are that we are avoiding the hard 
questions at this time (at the application development and implementation stage) and might have to deal 
with Ada programs that are not suited for distri- bution due to their use of Ada features. Later approaches 
will gradually introduce support for the application development stage and the implementation and execution 
stages. 5.2 Current Status As a first step, we built a sample application following the recipe described 
in [16]. For this sample, the transformation was done manually; the Distribution Tool Kit will automate 
this process. The application (a database server, which can be accessed simultaneously by two clients) 
was developed as a rather or-dinary Ada program, according to the distribution paradigm. Then, the original 
source was transformed into a functionally equivalent source, including code for the communication be- 
tween the distributed units. This code included a small fixed part of C code for low level operating 
system interface. All development is done on a network of Sun workstations, using the VERDIX Ada Compiler. 
We concentrated on library program units as units of dis- tribution. However, we expect that the recipe 
will also allow distribution of non-library units. We explored and implemented only the communication 
protocols ([16]) that provide reason- able reliability. The recipe itself had to be refined (in a way 
compatible with Ada) to address the following issues: Startup and shutdown in a distributed environment. 
 A'larger subset of Ada features (e.g., exceptions).  Particularities in the Sun/Unix/Verdix environment. 
  We also wrote a draft for extending the recipe to handle a more dynamic model of distribution. In 
this paper, startup and shutdown refer to the operations applied to the communication paths between the 
distribution units. Both require appropriate protocols (reliable and general to cover a large range of 
needs). Startup was treated minimally and implicitly, by adopting a solution with empirical delays. Shutdown 
was provided as a explicit operation in three different semantics: 1. Termination of the availability 
of the service at caller's site. This is the raw version of shutdown. It includes the termination of 
the virtual connection between the caller and the callee. It is aimed to handle explicitly turning off 
application clients. 2. Termination of the availability of the service at callee's site. This is similar 
to the one above, but aimed at the other side of the communication (to handle explic- itly turning off 
application servers). 3. Termination of the availability of the whole virtual con- nection. This has 
the semantics of terminate in Ada, and provides shutdown of a remote site by a graceful degra- dation. 
 There is an initial design for explicitly handled exceptions. 5.3 Lessons Learned A number of lessons 
have already been learned from our exper- iments; they can be classified into the following topics: Issues 
related to our initial approach to distribution The evaluation of the initial approach is done with respect 
to the appropriateness of the automated source transforma- tion concept and the transformation recipe. 
(L1) So far, our experience has proven the validity of our concept of distributing Ada applications based 
on source transformation. As expected, the process of development is rather flexible for a number of 
rea- sons, including delaying the specification of mapping on the actual architecture and small overhead 
for fine-tuning of the mapping. (L2) Schuman's recipe is implementable with the current technology (but 
see L7 below). It was claimed that at the time the paper was published (1981) the Ada compiler technology 
was not mature enough for the implementation of the recipe. (Z3) The approach is suitable for a class 
of applications with static architecture (inherited from CSP). For instance, an example of an unsuited 
application would be a server with a variable number of clients (e.g., a common database accessed by 
many users running the same application). (L~) The recipe had (and still has) to be refined to handle 
distribution specific issues (startup, shutdown, etc). (Z5) The recipe handles only a minimal set of 
Ada fea- tures. Although this set is probably enough for de- veloping all the applications within its 
scope (i.e., the set is probably canonical), additional refinements are needed to take full advantage 
of Ada power (ex- ceptions are an obvious candidate). Ada and Unix issues This topic combines the language 
is- sues with the issues related to the interaction between a particular Ada implementation and the operating 
system. The lessons are summerized below. (L6) The only language related issue appeared with ex- ceptions 
in the remote mode (i.e., between distribu- tion units). While it is straightforward to support predefined 
exceptions, in general, it is very costly to support user defined exceptions. It is about ex- ceptions 
that cannot be caught explicitly by excep- tion handlers since they are not visible at that point. Generally, 
these exceptions are trapped via when others construct and are eventually reraised blindly to the caller. 
If the call was a remote one, the caller is somewhere on the other side of the vir- tual connection. 
Normally, information qualifying the exception is encoded and returned through the virtual connection 
for decoding at the caller site. For anonymous exceptions this is not possible, since they are not Ada 
visible and special access to the run-time system is needed. (L7) The interaction between Sun-RPC library 
and Ada runtime system was rather fragile. The combina- tion of the Sun-RPC routines and obscurely nested 
Ada constructs (packages with tasks and with nested generic instantiations containing tasks) failed and 
other less natural programming solutions had to be adopted. {L8) The version based on sockets proved 
to be compact and reliable. From the socket types provided by Sun, the datagram connectionless sockets 
fitted our scheme the best. They are the only sockets that al- low a flexible protocol of starting up 
the channels, since there is no need for synchronization of the two ends prior to message sending. The 
datagram sock- ets (unlike stream sockets) do not ensure reliabil- ity of data transmission, and thus 
extra checks are needed at either at or above the virtual channel level. One possible reliable protocol 
was described in [16]. Performance issues We are looking into performance per se, and overhead introduced 
by distribution. The conclusions are listed below. (I.,9) The hand-built examples showed that the approach 
is well suited for soft real-time applications (where the response time is instantaneous in human terms: 
hundreds of milliseconds, rather than milli- or mi- croseconds). Further performance improvements might 
strictly depend on better implementations or special access to the run-time system. (LIO) The code overhead 
is given by the Ada code (which will be automatically generated), and operating sys- tem dependent code 
(C in Unix) which is generally of fixed size. The Ada code overhead tends to be rather large and increases 
with the degree of distri- bution (number of distributed units) and the num- ber of Ada features supported. 
However, unless the memory constraints are severe, we do not think that this would be a problem. (Lll) 
The number of additional tasks is not important per se; the additional tasks put more burden on the task 
scheduler. The simplest version in Schu- man's approach adds only two tasks per process (~ la Unix), 
but the more sophisticated ones add N+2 tasks, where N is the maximum number of concur- rent remote calls. 
We do not expect this to be a problem for the class of applications we are dealing with. 5.4 Next Steps 
Future directions are summarized in the list below. To explore different communication layer interfaces, 
par- ticularly seeking more reliable protocols (as discussed in  [16]). To explore enhancements of the 
distribution model. This can go in two different directions: - By extending the scope of Ada features 
considered until now. In particular, the objects of interest are non-library program units (including 
tasks) and full semantics for exceptions. - By extending the distribution model beyond the cur- rent 
approach. Currently, a distributed application is confined to having a completely static architec- ture. 
It is particularly interesting to investigate mod- els with more dynamic behavior, for instance, a com- 
mon database accessed by many users running the same application. In this case, one user is just an instantiated 
database client, and the number of in- stantiations is variable (but probably bounded). To complete 
the minimal Distribution Tool Kit. This initial set is composed of small tools capable of perform- ing 
specialized tasks and exchanging data. This allows flexibility and extensibility. Development guidance 
and tutoring are just two of the extensions which might be added. For now, the components of the toolkit 
include: - An analyzer. This tool Expects as input Ada code and checks it against the constraints imposed 
by the distribution recipe. The input can be either a DI- ANA tree produced by the DAPSE Structured Edi- 
tor [15] or ASCII text processed on an Ada Compiler front-end. - A transformer. This tool expects as 
input the inter- mediate representation of the units to be distrubuted and a specification of the distribution. 
It will exe- cute the source expansion according to the rules of transformation given by the recipe. 
 - A distribution editor. This is a combined Ada struc- tured editor and distribution specifier. It allows 
specification of the distribution (the mapping of dis- tributable units onto distributed units) and the 
con- figuration (the mapping onto the real architecture).   To assess the potential limitations of 
the generator-based technology used in this initial approach.  6 Conclusions We have described the research 
and development activities within the DAPSE project aiming at appropriately supporting the de- velopment 
of distributed Ada programs. We have provided a rationale for the specific DAPSE distribution approach 
in the context of a general framework for distributed programming. We have described our initial research 
and development efforts and summarized our current knowledge in the form of a num- ber of lessons learned. 
The initial distribution tool kit supports a specific approach in the context of the configuration stage 
of the software process model for developing distributed software. Our future plans within the DAPSE 
project and beyond are to incrementally enlarge the scope of our technology develop- ment activities 
in three different directions: (1) alternative ap- proaches for communication between units within the 
context of our current distribution model (library units), (2) alternative distribution models, (3) support 
for application development, implementation, and execution stages for the most promising distribution 
models. The DAPSE project addresses the need for a customized generation of tools within a context of 
environment frame-works. The project has the potential of incorporating further customization at the 
overall process level, such as that pursued by the TAME [3],[2] project at the University of Maryland. 
The key to effectively employing the generator idea for en- tire software engineering environments is 
to provide sound spec- ifications of the particular software processes used in a par-ticular organization. 
Such a specification language could be the basis for deriving tailored specifications for individual 
en- vironment tool components, customized software engineering databases, and distribution tool components 
tailored towards a specific distribution strategy. The body of knowledge required for effectively generating 
customized programming environments is tremendous. How-ever, the benefits of providing customized programming 
envi- ronments (tailored towards the organization specific processes in a natural way) as far as productivity 
and quality are con- cerned promise to be even larger.  Acknowledgements Major funding for the DAPSE 
project is provided by the U.S. Army at Ft. Monmouth with support from the DoD STARS Program Office and 
the U.S. Air Force Rome Air Development Center. We are indebted to Steve Schuman for developing our initial 
technical approach and to Stowe Boyd for contributions to an early version of the paper. We also acknowledge 
the contributions of Bob Canavello, David Loveman, Tony Mark and Kate Russell to the review and preparation 
of the paper. References <RefA>[1] M. R. Barbacci, J. M. Wing, "Specifying Functional and Timing Behavior for 
Real-Time Applications," Technical Report CMU/SEI-86-TR-4, Software Engineering Insti- tute, Carnegie-Mellon 
University, Pittsburgh, PA, Decem- ber 1986. [2] V. R. Basili and H. D. Rombach, "TAME: Tailoring an 
Ada Measurement Environment," in Proc. Fifth National Conference on Ada Technology and WADAS, Arlington, 
VA, March 1987. [3] V. R. Basili and H. D. Rombach, "The TAME Project: Towards Improvement-Oriented Software 
Environments," Technical Report TR-1983, Dept. of Computer Science, University of Maryland, College Park, 
MD, January 1988. [4] S. Boyd, M. Marcus, K. Sattley, "Extensibility in an Ada Programming Support Environment," 
in Proc. Sixth Na- tional Conference on Ada Technology, March 1988. [5] E. C. Cooper, "Distributed Systems 
Technology Survey," Technical Report CMU/SEI-87-TR-5, Software Engineer- ing Institute, Carnegie-Mellon 
University, Pittsburgh, PA, March 1987. [6] D. Cornhill, "Four Approaches to Partitioning Ada Pro- grams 
for Execution on Distributed Targets," in Proc. IEEE 1st International Ada Conference on Ada Applica- 
tions and Environments, 1984. [7] C. A. R. Hoare "Communicating Sequential Processes," Prentice-Hall 
Internationa, 1985. [8] N. C. Hutchinson, "Emerald: A Language to Support Distributed Programming," in 
Proc. Second Workshop on Large-Grained Parallelism, Special Report CMU/SEI- 87-SR-5, Software Engineering 
Institute, Carnegie-Mellon University, Pittsburgh, PA, November 1987, pp. 45-47. [9] D. C. Luckham, D. 
P. Helmbold, S. Meldal, D. L. Bryan, and M. A. Haberler, "Task Sequencing Language for Specifying Distributed 
Ada Systems (TSL-1)," Technical Report CSL-TR-87-334, Computer Systems Laboratory, Stanford University, 
Stanford, CA, July 1987. [10] M. Marcus, "DAPSE: A Distributed Ada Programming Support Environment," 
in Proe. IEEE 2nd International Conference on Ada Applications and Environments, 1986. [11] M. Marcus, 
K. Sattley, and C. M. Stefanescu, "Configu- ration Control in an Ada Programming Support Environ- ment," 
in Proc. Fifth National Conference on Ada tech- nology and WADAS, Arlington, VA, March 1987. [12] Nelson 
Bruce Jay, "Remote Procedure Call," Carnegie Mellon University, May 1981. [13] Proc. International Workshop 
on Real-Time Ada Issues, published as a special Edition of Ada Letters, Vol. VII, no. 6, Fall 1987. [14] 
H. D. Romback, "A Survey of Distributed Systems Projects," presentation, Compass, Inc., July 7, 1987. 
[15] S. C. Schaffner, M. Borkan, "SEGUE: Support for Dis- tributed Graphical Interfaces," Proceedings 
of the Twenty- First Annual Hawaii International Conference on System Sciences, Vol. II, Hawaii, 1988. 
[16] S. A. Schuman, E. M. Clarke, C.N. Nikolau "Programming Distributed Applications in Ada: A First 
Approach," Pre- sented at the 1981 International Conference on Parallel Programming, CA-8108-1201, Compass, 
Inc., 1981. [17] S. A. Schuman and D. H. Pitt, "Object-Oriented Sub- system Specification," in Proc. 
IFIP Working Confer-ence on Program Specification and Transformation, North- Holland, 1986.</RefA>  
			

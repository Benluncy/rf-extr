
 A I~COHPOSITION 14~-£ROD FOR THE AI~gLYSIS AND I~ESIG~I OF FINITE STATE PROTOCOLS Tat g. Choi and Raymond 
E. Miller* Georgia Institute of Technology Atlanta, Georgia 30332 Abstract Finite state automata have 
been applied with success to the modeling of Computer Network Protocols. The interaction of finite state 
machines can be very complex especially if the protocol involves a large number of states. To counteract 
the complexity of analysis and design, we propose an approach of decomposi- tion. Through this approach, 
the protocol graph can be partitioned into subgraphs each having a unique entry node and zero or more 
exit nodes. The exit nodes of one subgraph can be connected only to the entry nodes of other subgraphs. 
From the standpoint of protocol analysis, the correctness of the entire protocol graph can be inferred 
from the correctness of individual protocol subgraphs. From the standpoint of protocol design, the individual 
protocol sub- graphs can be designed to correspond to differ- ent phases of the protocol. If the individual 
protocol subgraphs are designed correctly and the Connections between subgraphs conform to the structure 
discussed above, then we show that the entire protocol graph will operate correctly.  I. IITROIXJCTION 
 The early eighties has seen the prolifera- tion of different types of computer networks and their application 
in various areas. With this a variety of network architectures and protocols have arisen [I]. Whether 
the network under discussion be a local network offered by a computer manufacturer or a long haul network 
offered by a common carrier, the question con- Permission to copy without fee all or part of this material 
is granted provided that the copies are not made or distributed for direct commercial advantage, the 
ACM copyright notice and the title of the publication and its date appear, and notice is given that copying 
is by persmission of the Association for Computing Machinery. To copy otherwise, or to republish, requires 
a fee and/or specific permission.  Permission to copy without fee all or part of this material is granted 
provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright 
notice and the title of the publication and its date appear, and notice is given that copying is by permission 
of the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or 
specific permission. fronting network architects remains the same: what principles can we draw on for 
the engineer- ing of these systems? In this paper, we intend to address an important area of network 
archi- tecture, that of protocol analysis and design. Despite the large number of networks in exis tence 
today and the experience gained from the implementation of these systems, the design and analysis of 
network protocols has remained ad hoc. Various efforts have been undertaken in the formal modeling of 
network protocols [2,3], yet these approaches have not solved the problem of complexity. Little has been 
done in the way of partitioning the analysis and design process, the use of canonical components for 
protocol design, or the establishment of practical theorems to aid in the analysis and design process 
[4,5]. To counteract the complexity of protocol analysis and design, we propose an approach of decomposition. 
Amongst the various ways of modeling protocols, we have chosen the finite state model for the following 
reasons. It is a simple, widely understood model, cor- rectness conditions can be simply and completely 
stated, these conditions not only are decidable but usually have tractable algorithms for test- ing their 
validity, and it has been used with success in the modeling of many practical proto- cols. We realize 
that finite state models have their limitations, for example, a complete description of some protocols 
may require a large number of states. Yet, it is precisely the state explosion problem that we intend 
to solve in this paper, by showing that finite state protocols ~re conducive to structured techniques 
of analysis and design. II. TtUS PROTOCOL MODEL Protocols are modeled by processes exchang- ing messages 
through communication channels. In finite state protocols, the processes can be represented by finite 
state machines [6]. A commonly used model for finite state protocols is one based on the work of Zafiropulo, 
et. al. [7]. In this model, a finite state protocol is defined as follows: Defintion: A Finite State 
Protocol FSP = (S,M,E,O,z) consists of: *Work on this paper was supported in part by National Science 
Foundation Grant MCS-8103608.  &#38;#169; 1983 ACM 0-89791-113-X,/83/0010/0167500.75 i. S = {S ,S }, 
two disjoint finite sets 1 2 i. s!1 = ~(si' -x) and c~13 = cij x representlng the states of processes 
P1 and P2 respectively. ii. s! = T(sj, +x) and cij = x c~ = ] 19 ii. M = {MI2,M2.}, two finite sets, 
where  MI 2 iii. s i = x(si,l) and c[j = cij  represents ~he messages that can be sent from process 
PI to process P2 and M21 Except for the one execution rule applied, all represents the messages that 
can be sent other elements of <S',C'> are equal to the from process P2 to process PI* elements of <S,C>. 
 iii. Z = {Z.,Z_}, two finite sets of events on Definition: A global state <S,C> is said to be M of 
t~e ~ollowing kind: reachable from an initial state <So,Co> iff (I) for every message x e Mij , the 
send-<So,Co> J--* <S,C> where <So,Co> = <(Ol,O2), (A,A)> t and I--* denotes the reflex- ing of message 
x is denoted by -x. ive, transitive closure of I--. Every send event -x is an element of Z.. 1  Definition: 
A transition at state s for event o is s=pecified iff T(s,~) is defined. (2) for every message x E M.., 
the 13  receiving of message x is denoted by Definition: A transition at state s for event +x. Every 
receive event +x is an is executable iff there exists a reachable element of Z.. 3 global state <(si,sj),(cij,cji)> 
with s = s i or = s., and if o Is a recelve transition +xi hen ~or s = si, c~= = xY and for s = s , 
c~ = (3) a null or internal event is denoted by I and % is an element of Z..  1 xZ, with Y and Z being 
arbitrary. 3 J~ iv. 0 = {oi,o2 }, where 01 e S. and 02  e S 2 Definition: A message x at state s is 
live iff o I and o 2 are the initia~ states for  there is a reachable global state <S,C> with S = 
processes PI and P2 respectively. (si,s~) and s = s i or s = s~and there exists an <S',C4> such that 
<S,C> I <S',C'> where S' = v. T a transition function: S. x Z. ÷ S., 1 . I  (Sk,S £) if s i, T(s ,+x) 
speci- fled and executable and if s = sj, then T(s£,+x) i~I,2. The transition functlon f~r and s = then 
k is event o E Z. at state s can be written is specified and executable. as T (s,o). ~t represents 
the next state  reached by a process after executing We now define the following four types of proto- 
 event o at state s. col errors. If T' = 01,~2,...,0 n is a sequence of events,  i. Unspecified Reqe~tions: 
A reception for then let T = ST' = o, o1,~2,...,c n. message x at state s is unspecified iff it is not 
live. Definition: An extended transition func- tion T(s,T) is defined for a state s E S i and a ii. 
Nonexecutable Interactions: A transi- sequence of events T by the following equation: tion T(s,o) at 
state s for event o is nonexecutable iff it is specified and not T(s,T) = T(T(S,~),T') executable. 
Definition: A Channel Cij is a FIFO queue  iii. State Deadlocks: A state deadlock is a connecting process 
i to process j. The contents stable state pair S = (si,sj) such that of Cij is labeled cij, it is a 
string of symbols there is no x for wSich T (s~,-x) from M.~ and represents the FIFO queue of mes 13 
 or T(s~,-x) is specified and S is ~ot a sages being sent from process i to process j. final ~ystem 
state. Each entry in cij is an element of Mij.  iv. State Ambiguities: A state ambiguity is a Definition: 
A Global State is a pair <S,C> pair of stable states S = (Sp,Sq) and S' where S = (st's2) with sl e 
I and s 2 e S 2 (Sp,Sq) = ' ' such that either representing the current statesSof process PI and 
P2 and C = (c12,c21) representing the cur- 1. Sp = Sp' and Sq ~ Sq' or rent contents of channels C12 
and C21. 2. Sp ~ S~ and Sq = s~ Definition: A Stable State Pair (sD,s q) is a  pair derived from~ob-a[ 
~taEe ~S,C~ where S = A state ambiguity is a potential design error. (sp,Sq) and C = (c12,c21) with 
both c12 and c21 empty. A binary relation I--on global states is defined as follows:  Definition: A 
global state <S,C> I-- <S',C'> iff SHere we use A to represent the null string of there exists i,j and 
cij satisfying one of the symbols, which intuitively represents the empty following execution rules: 
queue. Definition: A finite state protocol is said to be logicall~ correct w.r.t, unspecified recep- 
 tions, nonexecutable interactions and state deadlocks if and only if it is free from these errors. 
Various techniques have been applied for the validation of finite state protocols [8,9]. The most common 
one being teachability analysis. Let the finite state machines for process PI and P2 be represented by 
the finite state graphs ~ and g2 respectively. Then the protocol graph PG(gl,g2) denotes the protocol 
between process PI and process P2" The teacha- bility tree RT (gl,g2) for the protocol graph PG(gl,g 
2) can be constructed by successively generating reachable global states from the initial global state. 
 Definition: A finite state protocol is balanced if and only if the finite state graphs gl and g2 representing 
process PI and P2 respectively are isomorphic. III. "~us STRUCTURED PARTITION OF A PROT(~OLGRAPH  Let 
g be the finite state graph represent- ing process P. For the purpose of protocol decomposition, we define 
a Structural Parti- tion n of graph g into subgraphs as follows: Definition: A partition n = {GI,G2,...,G 
~} of graph g into subgraphs is a Structured Par£1tion if and only if it satisfies the following condi- 
tions: i. each subgraph G i contains a unique header node h and zero or more exit nodes e. ii. any 
node v i belonging to subgraph G i can be connected to any other node belonging to the same subgraph. 
 iii. only the exit node e of a subgraph G i can be connected to the nodes of other sub- graphs and 
any such edge is connected to the header node h of other subgraphs Gj. iv. a header node can also serve 
as an exit node e. In the event that a node acts as both header and exit nodes, the same rules apply. 
The minimal subgraph is a single node, in which case the single node acts as both a header and exit node. 
The structured partition z of a graph g is not unique. The set of all struc- tured partitions SP = {~ 
.} of graph g forms a partially ordered set. ~he largest structured partition z(1) of graph g is one 
that has a single block that includes the entire graph g. The smallest structured partition 7(0) of graph 
 g is one in which there are as many blocks as there are nodes which means that every node v i of graph 
g is a subgraph. From a smaller parti- tion ~ of the graph g, we can construct a larger partition ~' 
of graph g by forming the union of subgraphs of partition z such that the resulting subgraphs satisfy 
the structured requirements state above. The algorithm for constructing structured partitions can be 
found in [16]. In the following, we will refer to a graph g or subgraph G i by its nodes {v.}. By that 
we 1 mean the graph or induced subgraph whlch includes all the nodes {vi}. Example 3.1 Consider the 
graph structure g for the call control phase of Recommendation X.21 as shown in Fig. 3.1 [10]. We have 
omitted state 13 since the final transition can occur as soon as state 12 (READY FOR DATA) is reached 
and is not con- sidered to be part of the call establishment procedure. Recommendation X.21 provides 
many options which network implementors can choose from. We have chosen the option to include all the 
states thus omitting all bypassing links in the state diagram. In that case, the graph structure g = 
(I, 2, 3, 4, 5, 6A, 6B, 7/10, 8, 9, 10his, 11, 12, 15). The smallest structured partition ~(0) = {GI, 
G2, G3, G4, G5, G6A, G6B, G7/10, GS, G9, G10bis, G11, G12, G15}, where G I = (I), G 2 = (2), G 3 = (3), 
G 4 = (4), G 5 = (5),   G,A (? ;) = )( G6B = (6B), G7/I. 0 = (7/10), G 8 = (8), G 9 , G10bi s = (10bls;, 
G11 = (11), G12 = (12) and G15 = (15) are single node sub- graphs. From the smallest structured parti- 
tion ~(0), we can optionally construct a larger partition ~' = {G~} by forming subgraph G~ = G I U G 
2 U G 8 with th~ rest of the subgraphs remain- ing the same. Thus G{ = (1,2,8), G~ = (3), G~ = (4), 
G~ = (5), G~A = (6A), G~B = {6B), G~/10 (7/I0), G~ = (9), G{0bi s = (10bis), G~I = ~11), G{2 = (12) 
and G{5 = (15). This partition will be needed in our later discussion. IV. A STRIR~TURETHEORYFOR FINITE 
STATE PROTOCOLS  Consider the protocol between two processes PI and P2 connected by communication channels 
C12 and C21. Let process PI be represented by the finite state graph ~ which can be parti- tioned structurally 
into m subgraphs H I = (GI,...,Gm). Let process P2 be represented by finite state graph g2 which can 
be partitioned structurally into n subgraphs ~2 = (G|,..., G~). Let subgraphs G I and GI be the initial 
subgraphs for gl and g2 respectively, where they contain the initial node for each graph. Let G i be 
the i th successor subgraph to G I in graph gl and G 1 be the i th successor subgraph to GI in graph 
g2" We say that G I in g2 is the corre- sponding subgraph to G i in g1" For balanced protocols, the corresponding 
subgraphs are quite obvious since graphs gl and g2 are identical in structure. In other cases, we are 
referring to the pair of corresponding subgraphs that are reachable from the initial pair of subgraphs. 
Let G i U h denote the union of subgraph G i with the header node h of its successor subgraph 169 Gj. 
Consider an arbitrary subgraph G i U h of 91' and its successor subgraph G~. Its corre- J  sponding 
counterparts in 92 are subgraphs G i U h' and G~. See Fig. 4.1. Between subgraphs G i U G. an~ G! U G!, 
there are four regions of j i interaction. See ~able 4.1. We can distinguish between two kinds of interactions. 
 Fig. 3.1 The graph structureg for the call control phase of x.21 with state 13 omitted  Process P1 
Process P2 c12 JU C21  Fig. 4.1 The Protocol Subgraph PG(G i U Gj, G[ U G~) I. Expected Interactions 
 In both regions I and 2, while process P! is in subgraph G i U h or G~, process P2 is in its corresponding 
subgraph G i U h' or G~ respec- 1  tively. When they exchange events in these subgraphs, we refer to 
them as the 'expected interactions' between subgraphs. 4.1 ~ Regim~ of XmteEactioa ~£ons of Interactlon 
Process P! Process P2 ~egion 1 G i U h G[ U h' region 2 ~ G~ re~ion 3 G i U h G~ region 4 Gj G~ U h' 
 2. Cross Interactions In regions 3 and 4, while process P! is in subgraph G i U h or Gj, process P2 
is in its corresponding successor or predecessor subgraph, namely, G 3 or G 1 U h' respectively. This 
can happen as a result of one process racing ahead into its successor subgraph while the other process 
lags behind. By itself, this does not signify that a process in one subgraph will exchange events with 
another process in its predecessor or successor subgraph. However, if they do so, we refer to this as 
a 'cross inter- action' between subgraphs. In some instances, either process P! or P2 can race ahead 
into successor subgraphs of G~. or G! while the other process lags behind in d! U h~ or G i U h. In those 
cases, we can -i have 'cross interaction' between processes that are separated by more than one subgraph. 
Clearly, from the standpoint of a structured approach to protocol analysis and design, these are the 
interactions we want to avoid. In a well de- signed protocol, one would expect that whatever events are 
exchanged between subgraphs G i U h and G 1 U h', they would be confined to those subgraphs, and once 
process P! or P2 enters subgraph Gj or G~, the other process will follow suit. In the -following, we 
will state two different propositions under which 'cross inter- action' is absent. Propo. sition 4.1: 
If the set of events in protocol graph PG(G i U h, G~ U h') is totally different from the set of events 
in PG(Gj, G3) , then there can be no 'cross interaction' 5etween the two subgraphs. The reason for this 
is obvious. However, the above condition may not always be the case and we will have to rely upon the 
following proposition for no cross interaction. Prq~osition 4.2: If the protocol given by the protocol 
graph PG(G i U h, G[ U h') is cor- rect, then all the messages sent by process P! in subgraph ~ h will 
be received by P2 in subgraph GI __'Uand vice versa, i.e. there can be no cross interaction between 
the two sub- graphs. 170 If there are no cross interactions between subgraphs, then the reachability 
tree of PG(G i U Gj, GII U G~) is the union of the teachability tree of PG(G i U h, GII U h') and the 
teachability tree of PG (Gj, G~ ) over the global state <(h,h'),(A,A)>-plus a transition region. See 
Fig. 4.2. The transition region represents intermediate states where one process races ahead into subgraph 
G. or G_'. while the other 3 3 , h' process lags behind in subgraph G i U or G i U h. It is generated 
as a result of connecting subgraph Gj to G i and G~ to G[. The correctness of the prdtocols given by 
PG(G i U h, G 1 U h') and PG(Gj, G~) guarantees the correctness of the transiti6n legion. This is because 
for any sequence of transitions through the transition region, there is an equivalent sequence through 
the union of the teachability tree of PG(G i U h, G.~ U h') and the reachability tree of PG(Gj, G~). 
By equivalent sequences, we mean the two sequences have the same set of events except the order in which 
they occur [11]. Reachabillty Tree (G i V h, ~<S.~ TrRe: tion l of PG(Gj, G;) ( Region 2) / Fig. 
4.2 Reachability Tree of PG(G i U Gj, G~ U G~)  Lemma 4.1 The correctness of the protocols given by 
the protocol subgraphs PG(G i U b, G[ U h') and PG(G~, G~) implies the correctness of the pro- J  tocol 
given by PG(G i U Gj, G[ U G~). We now see that the converse is not neces- sarily true. Lemma 4.2 
The correctness of the protocol given by the protocol graph PG(G i U Gj, G~ U G~) does not imply the 
correctness of th~ protocols given by the protocol subgraphs PG(G i U h, G[ U h') or PG (Gj ,G~). We 
will now generalize the situation to include multiple successor subgraphs to G i and G~. Let {G~}, k 
= 1,...,m be~the set of succes- sor subgra~s to G i and {G~ }, £ = I .... ,n be the set of successor 
subgraphs to G I. Let H i = {h k} be t~e set of header nodes of successor subgraphs {G ~. } and H' = 
{ h' } be the °set of header node~ of successor su~graphs {G'~.}. We extend the term 'no cross interaction 
~etween subgraphs' to mean that process PI in subgraph G i U H i should not e~change events with process 
P2 in any subgraph G: . Similarly process P2 in subgraph G 1 U HI should not ~xchange events with process 
PI in any subgraph G_.. Let PG(G i U H i , G 1 U H I) be the protocol g~aph formed by the union of subgraph 
G i and G.I' with the set of header nodes H i and s I. See Fig. 4.3. For m successor subgraphs to G i 
and n successor sub- graphs to G I, there are m x n combinations of header state pairs of the form (hx,h 
;) . Only a subset of these header state pairs are reach- able. The existence of stable header state 
pairs of the form (hx,h¢) in the reachability tree of PG(G i U Hi, G[-U HI) means that when process 
P~ makes a transition into successor subgraph G';, process P2 can make a similar transition 3into subgraph 
G 'y. 3 Process ~i process P2 Gi C12 C21 For multiple successor subgraphs the reaGh- ability tree 
of PG(G i U G. U .. U G m, G" U G~ i U ,n . . .~.  .. U G. ) is the unlon o@ the reac~ablllty ~ree 
of PG(~ i U H i , GlI U H11) with the teachability trees of Drotocol subgraphs of the form PG(G x, G'. 
~r) where (G x, G'. y) is any pair of reachable 3 successor subgr~phs 3 to (G i U H i, GI 1 U HI), plus 
a set of transition regions, see Fig. 4.4. Lemma 4.3 If the protocol given by the protocol graph PG(G 
i U Hi, G.~ U HI) is correct and for every reachable stable header state pair (hx,h¢) of PG(G~ U H4. 
G" U H') , the protocol "given x ~y ~  by PG(G., G'. ) is also icorrect, then the proto- col given 
~ PG(G: U G. U ... U Gin., G' U G~ U U G 'n i -~--~A-~ i 3 ~ 3 ,. . ) S ~Ua &#38;~;L. 3  Again, the 
converse is not necessarily true. Lemma 4.4 The correctness of the protocol given by I m ,  the protocol 
graph PG(G i U G. U .. U G , G i ,I ,n  U G U .. U G ) does not impl~ the correctness of ~he protoc~l 
given by PG(G i U Hi, G~ U H.~) or PG(GX., G! y) where (G x, G 'y) is any pair of reachable s%ccessor 
sub'rapes to (G i U Hi, G~ U HI)  <S.C~ - < (hx.hy) .(A.A) <s',c'> - <(h,,h$),(^,^)> ReachabilityTree 
of PG(Gi U H i, G[ U H~) tion ° ° J G~. w~ere(hx,h ~) and (hu,h~) ~e any ~ea=hable stable header state 
pairs of PG(G~ u H i , G[ u S~) Finally, we generalize the situation to include the entire protocol graph 
and arrive at the following theorems.  Theorem 4.1 Given a protocol graph PG(91,92) where 91 representing 
process PI which can be partitioned  = .,. - l~i:gS~:~Sp~hic{hG~n ~eG%ar~i~i~e~e~o n subgraphs ~. = 
{G~,...,G' }, then the protocol given by the ~rotoc~l grap~ PG(G I U .. U Gm, G{ U .. U G~) is correct 
if i. the initial protocol subgraph PG(G I U HI, G{ U H{) is correct, and ii. if the protocol given 
by PG(G u U Hu, G$ U H$) is correct and (h x, h$) is a stable header state pair of PG(G u U H u, G$ U 
H$), then the protocol given by PG(G x U Hx, G' U H~) must also be correct where G x is {he successor 
subgraph of G u with header h x and G~ is the successor subgraph of G$ with header h~. For balanced 
protocols, the processes PI and P2 are represented by identical graph struc- tures. In that case, there 
is a one-to-one correspondence between the subgraphs of process PI and the subgraphs of process P2" If 
the protocols are well designed, the processes engaged in the protocol will not enter into different 
successor subgraphs. This means that for the protocol subgraph PG(G i U Hi, GI U Hi), the only stable 
header state pairs reachable will be of the form (hx,h~) where (hx,h~) are the header nodes of successor 
subgraphs to (Gi,GI). Under those circumstances, we have the following corollary to the theorem. Corollary: 
 Given a protocol graph PG(91,92 ) consisting of n subgraphs, if for each protocol subgraph PG(G i U 
Hi, G i U Hi), the only stable header state pairs reachable are of the form (hx,h~), then the correctness 
of the protocols given by the individual subgraphs plus the header nodes of successor subgraph PG(G i 
U Hi, G i U HI), i = 1,...,n implies the correctness of the entire protocol graph PG(G I U .. UGn, G{ 
U .. U G~). The converse is not necessarily true. Theorem 4.2 Given a protocol graph PG(91,92 ) where 
91 representing process PI which can be partitioned into m subgraphs ~I ='{GI'''''Gm} and 92 repre- senting 
process P2 which can be partitioned into n subgraphs ~2 = %G2,...,G~}, the correctness of the protocol 
~iven ~y the*~ntire protocol graph PG(G I U ... U G m, G~ U ... U GA) does not imply the correctness 
of the protocols given by the protocol subgraphs PG(G k U Hk, G~ U H~) where (G k U Hk, G~ UGh) is any 
pair of subgraphs reachable from initial subgraphs (G I U HI,   G~ u .{) For balanced protocols, we 
have the follow- ing corollary to Theorem 4.2 Corollary: Given a balanced protocol graph PG(91,92 ) 
consisting of n subgraphs, the correctness of the protocol given by the entire protocol graph PG(G I 
U ... U G n, G{ U ... U G~) does not imply the correctness of the protocol given by the individual protocol 
subgraphs PG(G i U H i, G 1 u Hi), i = I ..... n.  V. S ~ ~ I'IK~DCOL ANALYSIS AND DES I(~ Based on 
the theory discussed in section IV, we have developed a structured approach to protocol analysis and 
design. This approach provides a systematic method to the analysis and design of finite state protocols 
based on proto- col subgraphs. A. Structural Protocol Analysis In the following, we restrict our analysis 
procedure to balanced protocols. This ensures that there is a one-to-one correspondence between the subgraphs 
of 91 and 9 2 . We begin our analysis with the smallest structured parti- tion ~(0) and whenever we detect 
the possibility for cross interaction between subgraphs, we form a larger partition until that cross 
interaction is eliminated. If the protocol graph is cor- rect, then we arrive at a partition z in which 
all the protocol subgraphs are correct and there are no cross interactions between any two proto-  col 
subgraphs. This partition can be the largest structured partition ~(I) which means that we have to analyze 
the protocol graph as a whole. Let PG(@I,@2) be the balanced protocol graph to be analyzed, the structured 
analysis method for PG(gI,~2 ) is given as follows: Step 1= Let ~ be the current structured urr partition 
of the protocol graph PG(@I,@2 ) to be analyzed. Initia- lize ~ to the smallest structured CUrE partltzon 
z(0).  Ste~ 2: For the protocol graph PG(@I,@2) partitioned according to ~ , con- struct the protocol 
tree pTC~/~,T2 ) by converting graphs @I and @2 into trees T I and T 2 respectively using the following 
algorithms:  Algorithm 5.1 i. Let the initial subgraph G I of ~ be represented by the root node of 
t~r~ree " T I ii. Let the immediate successor subgraph G i to G I in graph 91 be represented by the 
immediate descendants to node G I in the tree T I . iii. For each successor subgraph Gi, let the immediate 
successor subgraph G= to G i in graph @I be represented by th~ immediate descendants to node G i in the 
tree T I. iv. Repeat (iii) until every terminal node of the tree T I is either a duplicate node or a 
final node. Using the same algorithm, we can construct tree T 2 for graph @2" The protocol tree PT(TI,T 
2) so constructed is equivalent to the protocol graph PG(@I,@2). Step Starting with the root node G 
I and G{ of the protocol tree PT(TI,T2), con- struct the teachability tree for the protocol subgraph 
PG(G I U HI, G{ U H{). If the teachability tree RT(G I U H, G{ U H{) contains protocol errors, then go 
to step 4, else go to step 5. Step 4 For any protocol subgraph PG(G u U Hu, G~ U H~), if there are state 
deadlocks or unspecified receptions, then we have to distinguish between 'definite' protocol errors and 
'potential' proto- col errors. Let p be any node of subgraph G u and q be any node of subgraph G~. Let 
h~ and h i be the header nodes of any Immediate succes- sor subgraphs G~. and G~ y to G u and G~ respectively. 
~et X ~d Y denote any arbitrary sequences of messages. Table 5.1 makes the distinction be- tween what 
are 'definite' protocol errors and what are 'potential' proto- col errors. By potential errors, we 
 mean those errors that may vanish as a result of forming larger partitions. This is because partition 
~CURR is too fine and as a result we have cross interactions between subgraphs. By definite errors, we 
mean that they are errors not only for the protocol subgraph PG(G u U H u, G~ U H~), but will also become 
errors for the entire protocol graph PG(gI,@ 2) as well.  5.1 ~tentl~ and ~fMite ~otocoE ~z~m Definite 
Potential Protocol Erroz Protocol Error  State DeadlOCks T <(p,q},(A,A)> <(hx,q),(A,A)> <(p,h~),(A,A)> 
 Onsp~=ified Receptions <(p,q),(X,Y)> <(hx,q),(X,Y)> ((p,q},(X,A)> <(hx,q),(A,¥)> <(p,q),(A,Y)> <(p,h~),(X,Y)> 
 <(bx,q),(X,A)> <(p,b~),(X,A}> <(p,h~),(A,Y)> <(bx,h~),(X,Y)> <(hx,h~),(A,Y)> <(bx,h~),(X,A)>  T<(hx,b~), 
(A,A)> is r~ard~ u a final global state of ~(G i U Hi, G i U Hi). If the state deadlocks and unspecified 
receptions in the teachability tree RT(G u U Hu, G~ U H$) are all definite protocol errors, then record 
these errors. Record the nonexecutahle interactions and state ambiguities and go to Step 5. If the teachability 
tree RT(G u U H u, G~ U H$) contains potential protocol errors, then con- struct a larger partition ~ 
> ~CU RR by forming the union of su~graphs G u and G v ' with its successor subgraphs for which cross 
interaction is pos- sible and in addition any other sub- graph whose inclusion is required by the definition 
of a structured parti- tion. Let ~NEW be ~CURR and go to Step 2.  Step 5 If the final global states 
for PG(G u U Hu, G~ U Hi) are of the form <(hx,h~),(A,A)> where h x and h i are the h~ader nodes of successor 
sub- graphs G x and G~ respectively, then the next set of ~rotocol subgraphs we need to examine are of 
the form PG(G x U Hx, G~ U Hi). For each protocol subgraph PG(Gx U H x, G'y U H'),y con- struct the 
reachabili~y tree RT(G x U Hx, G~ U H i) . If it contains protocol errors, then go back to Step 4, else 
repeat Step 5 until all reachable pairs of subgraphs have been examined. 173 The structured technique 
described above simpli- fies the analysis process by looking only at subtrees RT(G u U H u, G~ U H~) 
of the entire teachability tree RT(gl,g 2) and omitting transi- tion regions which for our purpose can 
be viewed as 'redundancies' in the teachability tree. B. Structured Pzotocol Design The theory discussed 
in section IV provides us with a definition for structured protocol design. By structured protocol design, 
we require the following: i. the entire protocol graph PG~I,@2 ) is constructed from the union of protocol 
subgraphs PG(G i U Hi, G[ U HI), i = 1,...,n with each protocol subgraph designed to correspond to some 
phase of the protocol. ii. there are no cross interactions between protocol subgraphs.  iii. when one 
process makes a transition into one of its successor subgraphs, the other process will follow suit and 
make a simi- lar transition into its corresponding subgraph. The structured protocol design approach 
for PG(gl,g 2) is given as follows: step I: Construct the initial protocol sub- graph PG(G I U H I, 
G~ U H~) using, for example, the production rules of Zafiropulo [12]. Let subgraphs G I and G{ be the 
root nodes of trees T I and T 2 to be constructed.  Step 2: To determine which nodes in subgraphs G 
I U H I and G~ U H{ can act as header nodes h x e H I and h~ ~ H{ for succes- sor subgraphs to G I and 
G{ respective- ly, use design rule I. Design Rule I= Let p and p' be any node of subgraph G i U H i 
and G~ U H~ other than the header nodes h i and h~. Let q and q' represent any nodes of subgraph G i 
U H i and G~ U H! respectively including p and p'. I~ in the reachability tree of PG(G i U Hi, G[ U H~), 
there exists a global state of the form <(p,p'), (A,A)> without any accompanying global states of the 
form <(p,q'),(X or A, Y)> or <(q,p'),(X, Y or A)>, then nodes p and p' can serve as header nodes h x 
and h~ for successor subgraphs G x and G x ! respectively. In order to avoid processes from entering 
into different successor subgraphs, use design rule 2. Desi@n Rule 2: Let (hx,h ~) be the header state 
pair for successor sub- graphs to G i and G[ chosen using design rule I. We disallow choosing any other 
stable state pairs of the form (hx,h ~) or (hy,h~) as header state pairs for successor subgraphs to 
G i and G[. Step 3: For every header state pair (hx,h ~) chosen in step 2, construct the proto- col 
subgraph PG(G u U Hu, G i U Hi). Let the subgraphs G u and G~ be the immediate descendants to G I and 
G{ in trees T I and T 2 respectively. step 4: Using design rule I and 2, determine the new header state 
pairs (hx,h l) for each protocol subgraph PG(G u U H u, G i U H i) with h x e H u and h' e H'. x u 
Step 5: For each header state pair (hx,h~), construct the protocol subgraph PG(G v U H v, G~ U H~). Let 
the subgraphs G v and G~ be the immediate descendants to G u and G i in tree T I and T 2 respec- tively. 
If subgraph G v and G v have appeared in trees T I and T 2 before i.e. it is a duplicate node, then 
subgraph G v and G$ are terminal nodes of tree T I and T 2 respectively. If the protocol subgraph PG(G 
v U Hv, Gj U __H~ is a final subgraph i.e. ~ = H$ then subgraph G v and G v are terminal nodes of tree 
T I and T 2 also. Repeat steps 4 and 5 until every leaf of tree T I and T 2 is a terminal node. step 
6: Finally convert the protocol tree PT(TI,T2) so constructed to the proto- col graph PG(@I,~2) by merging 
identi- cal nodes in trees T I and T 2. Using the structured design technique described above we can 
construct complicated protocol graphs by connecting together relatively simple protocol subgraphs. This 
forms the basis for a building block approach to protocol design. In the following we will illustrate 
the above procedures with a practical example, We have chosen to use the call control phase of CCITT 
Recommendation X.21. Recommendation X.21 has been validated by different authors [13,14]. It is not 
our intention to revalidate this protocol" but only to demonstrate how the structured approach would 
apply. We will not examine the issue of time limits and timeouts but only the logical correctness as 
given by the state diagram. Example 5.1 The call control phase for circuit switched service is specified 
by the state diagram Fig. A-2 in Recommendation X.21 [10]. The state diagram can be translated into separate 
state transition graphs for the DTE and the DCE parti- cipating in the protocol. See Fig. 5.1. The  
174 four main interface circuits are T, C, R, I, [15]. s(t,c) and s(r,i) represent a send event by the 
DTE and DCE respectively, while r(r,i) and r(t,c) represent a receive event by the DTE and DCE respectively. 
Let ~I and ~2 be the state transition graphs representing the DTE and DCE respectively. The PG~I ,~ 2 
) represents the protocol between the DTE and DCE. In this case, the two graphs 91 and g2 have an identical 
structure . The smallest structured partition of g is given by ~(0) = {GI, G 2, G 3, G 4, G 5, G6A, 
G6B, G7/I0, G8, G 9, G10bi s, GII, G12, G15~. See Example 3.1. Frcx, the protocol graph PG(~I,g2), we 
construct the protocol tree PT(TI,T2). Since both trees T I and T 2 have an identical structure, we will 
call it T. See Fig. 5.2. =(o,om s(~,on) ),) ~ =(o,oN) =(+,QfT) $11 ,(RI) S{÷,O~l 11 ca) ) S (L~3, 
(AY) I ¢ ( sy~ ,o1~1 ¢(IAS,OS) I  S{I,~) ¢1IA5 ,aFF) TIC,OFt) ¢11, ¢ ( Ir~,w, ~ly } s(m.~ I ~(l,crr) 
 ~ (~'B,OFFI ~(L%5,CeT) s (sTe,~) s { .T33 ,o1~1 i s(1,~)  / Fiqo 5.2 The T~ae T o~ Gr~ g For structured 
protocol analysis, we will first examine the protocol subgraph PG(G I U H I, G 1U HI). See Fig. 5.3. 
Since the teachability tree of PG(G I U H, G I U H I) contains an unspeci- fied reception of the form 
<(s2,s8), ([0,ON], [BEL,OFF])> which is a potential protocol error, we form a larger subgraph G{ = G 
I U G 2 U G 8. The new partition so formed ~' = ~G~, G~, G~, G~, G~A, G.~ B, G~/10, G~, G{0bi s, G{I, 
U{2, U{~ xs given in Example 3.1. For the new partz- tion ~, we construct a new tree T' of ~ as shown 
in Fig. 5.4. The protocol tree PT(T{,T~) tells us that the protocol graph PG(gl,g2 ) is correct iif the 
protocol subgraphs PG(G.~ U "' G' "i' O H~), = I, 3, 4, 5, 6A, 6B, 7/10, 9, 10bis, 11, 12, 15 are correct. 
See Fig. 5.5. For the simple protocol subgraphs of Fig. 5.5, the validation can be done by sight. Fig. 
5.3 The Protocol Subgraph PG(G 1 U H I, G~ U H~) ) / Fig. 5°4 The Tree T' of C~aph  For structured 
protocol design, we will first construct the protocol subgraph PG(G{ U H|, G] U H{) and let G{ and G{ 
be the root nodes of trees T] and T~ to be constructed. Using rules I and 2 discussed above, we chose 
(s3,s3), (s9,Sg), and (s15,s15) to be the header state pairs of successor subgraphs to G]. Next we construct 
protocol subgraphs PG(G~ U Hi, G~ U H~) PG(G~ U H a, G~ U H~), and PG(G{5 U H]5, G{5 U H{5) and let subgraphs 
G~, G~, and G]5 be the immediate descendents to G] in trees T{ and T~. Following the structured protocol 
design procedure described above, we build up trees T] and T~. The process terminates when we arrive 
 at subgraphs G~A and G]I which are duplicate nodes and subgraph G{2 which is a final node. 175 s¢o,om 
c (m~,ol, T; r (o,ou) s (~,orr) rig. s.s ~ ~.~o~ s,~r~.~= ~(~[, a[, 4;...~) Finally, convert the protocol 
tree PT(T~,T~) to the protocol graph PG(@I,g2). The protocol so constructed is a structured protocol 
since it satisfies the three requirements stated above.  VI. CK~ICLUS IOHS In this paper, we introduced 
a 'Structured Partition' of a finite state graph into sub- graphs and described the properties of such 
a partition. Based on the structured partition, we presented a structure theory for finite state protocols. 
We developed a structured approach to protocol analysis and design based on sub- graphs. We applied the 
technique to the analysis of the call control phase of CCITT Recommendation X.21 and verified its correct- 
ness. We also found that the call control phase of Recommendation X.21 conforms with our requirements 
for structured protocol design. The extension of the structure theory to protocols involving more than 
two processes can be done in a straightforward manner. In the limited space available, we have presented 
a summary of our work. A complete account is given in [16].  wJ~J~mgCES  <RefA>[I] <SinRef><author>A. S. Tanenbaum</author>, "<title>Network 
Protocols</title>," <journal>Computing Survey</journal>, <volume>Vol. 13, No. 4, </volume><date>Dec. 1981</date>, pp. <pages>453-489</pages></SinRef>. [2] <SinRef><author>C. A. Sunshine</author>, "<title>Formal Modeling 
of Com- munication Protocols</title>," <publisher>University of Southern California</publisher>, <tech>ISI RR-81-89</tech>, <date>March 5, 1981</date></SinRef>. [3] <SinRef><author>National 
Bureau of Standards</author>, "<title>Formal DescriptionTechniques for Network Proto- cols</title>," <tech>Report No. ICST-HLNP-80-3</tech>, 
<date>June 1980</date></SinRef>. [4] <SinRef>T. F. Piatkowski, "An Engineering Disci- pline foe Distributed Protocol Systems," <booktitle>Proc. 
INWG/NPL Workshop on Protocol Test- ing</booktitle>, Vol. <volume>I</volume>, <date>May 1981</date>, pp. <pages>177-215</pages></SinRef>. [5] <SinRef><author>H. Rudin </author>and <author>C. H. West</author>, 
"<title>Validation of Protocols using State Enumeration: A summary of some exper ience</title>," <booktitle>Proc. INWG/NPL Workshop 
on Protocol Testing</booktitle>, Vol. <title>I</title>, <date>May 1981</date>, pp. <pages>371-375</pages></SinRef>. [6] <SinRef><author>G. V. Bochmann</author>, "<title>Finite State Description of 
Communication Protocols</title>," <journal>Computer Networks</journal>, Vol. <volume>2</volume>, <date>Oct. 1978</date>, pp. <pages>361-372</pages></SinRef>. [7] <SinRef><author>D. Brand </author>and <author>P. Zafiropulo</author>, 
"<title>On Communi- cating Finite State Machines</title>," <tech>IBM Research Report RZ 1053</tech>, <date>Jan. 1981</date></SinRef>. [8] <SinRef><author>C. H. West</author>, 
"<title>General Techniques for Com- munication Protocol Validation</title>," <journal>IBM J. Res. Develop</journal>., <volume>Vol. 11, No. 4</volume>, <date>July 
1978</date>, pp. <pages>393-404</pages></SinRef>. [9]<SinRef><author> H. Rudin</author>, <author>et. al.</author>, "<title>Automated Protocol Validation: One chain of development</title>," 
<journal>Computer Networks</journal>, <volume>Vol. 2, No. 4/5</volume>, <date>1978</date>, pp. <pages>373-380</pages></SinRef>. [10]<SinRef> <title>CCITT Recommendation X.21</title>, <location>Geneva, Switzerland</location>, 
<date>1980</date></SinRef>. [11] <SinRef><author>J. Ruhin </author>and <author>C. H. West</author>, "<title>An Improved Protocol Validation Technique</title>," <journal>Computer Networks</journal>, 
Vol. <volume>6</volume>, <date>1982</date>, pp. <pages>65-73</pages></SinRef>. [12] <SinRef><author>P. Zafiropulo</author>, <author>et. al</author>., "<title>Towards Analyzing and Synthesizing Protocols</title>," 
<journal>IEEE Trans. on Communications</journal>, <volume>Vol. COM-28, No. 4</volume>, <date>April 1980</date>, pp. <pages>651-661</pages></SinRef>. [13] <SinRef><author>C. H. West </author>and <author>P. Zafiropulo</author>, 
"<title>Automated Validation of a Communications Protocol: the CCITT X.21 Recommendation</title>," <journal>IBM J. Res. Develop</journal>., 
<volume>Vol. 22, No. I</volume>, <date>Jan. 1978</date>, pp. <pages>60-71</pages></SinRef>. [14] <SinRef><author>R. Razouk </author>and <author>G. Estrin</author>, "<title>Validation of the X.21 Interface 
Specification Using SARA</title>," <booktitle>Proceedings of the NBS Trends and Applications Symposium</booktitle>, <date>May 29, 1980</date></SinRef>. [15] 
<SinRef><author>H. C. Folts</author>, "<title>Procedures for Circuit Switched Service in Synchronous Public Data Networks</title>," <journal>IEEE Trans. 
on Communica- tions</journal>, <volume>Vol. COM-28, No. 4, </volume><date>April 1980</date>, pp. <pages>489-496</pages></SinRef>. [16] <SinRef><author>T. Y. Choi</author>, "<title>A Structured Approach 
to the Analysis and Design of Finite State Proto- cols</title>," <note>Ph.D. Thesis</note>, <journal>School of Electrical Engineering, 
Georgia Institute of Techno- logy</journal>, <date>1983 </date>(in preparation</SinRef>).</RefA> 176  
			

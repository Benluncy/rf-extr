
 178 An Approach to Performance Evaluation of Software Architectures Simonetta Balsamo*, Paola Inverardi 
 and Calogero Mangano* * Dip. di Mat. ed Informatica, Universita di Udine, Via delle Scienze 206, Udine, 
Italia, balsamo@dimi.uniud.it Dip. di Mat. Pura ed Applicata, Universita dell Aquila, Via Vetoio, Coppito, 
L Aquila, Italia, inverard@univaq.it Dip. di Informatica, Universita di Pisa. Corso Italia 40, Pisa, 
Italia ABSTRAC I In this puper we present an approach to evaluuting the expected pe~formante of u software 
architecture. The method uutomuticmlly derives a performance evaluution model, bused on N Queueing Network 
Model, from a .software architecture .spec@ation formally described in CHAM (CHemicwl Abstract Machine). 
The goal of this rrpprouch is to provide a #set of measures to compare the per+formance of two or more 
competing software urchitectures, even at their high level of abstraction. This rneuns thut we will be 
able to derive mathemutical relations crmony: the purameters---that is, the evaluution indic,c.s---churu~teri,-ing 
the competing models. Besides clssisting in the choice of a softwure architecture, these relations give 
information on how to curry on the development process in order to mantrrin the given performcrnce. To 
u certain extent, the relations provide filrthrr requirements to be ,fulfilled by an implementation in 
order to sgtisjj the chosen pe@rmance criteria. Keywords Software Architecture, CHAM, performance evaluation, 
Queueing Network Model, performance indices 1 Introduction Software Architectures (SA) describe software 
system structures at a high level of abstraction [ 13,141. They represent at an early stage of development 
the phase in which basic choices of components and interactions among components are made. Ideally, those 
choices reflect any constraints imposed by the hardware architecture upon with the system is to run. 
Designers are often faced with the problem of choosing among different functionally equivalent software 
architectures. This choice is driven by non-functional factors such as performance, reliability, and 
topological/economical constraints. Among these, performance is one of the most influential factors to 
be addressed. In this paper we present an approach to evaluating the expected performance of a software 
architecture. The method automatically derives a performance evaluation model, based on a Queueing Network 
Model [7,8,9], from a software architecture specification formally described in CHAM (CHemical Abstract 
Machine)[5,6]. Due to the high level of abstraction of SA, the evaluation of the model can only be carried 
out symbolically. The results are a set of mathematical relations characterizing the competing models. 
These measures can be used either to directly compare the models or to derise the performance of the 
given architectures under further hypothesis by suitably instantiating the symbolic parameters. Parameter 
instantiations identify potential implementation scenarios, analyzing the behaviour of the system in 
these scenarios can provide useful insights on how to carry on the development process in order to satisfy 
the chosen performance criteria. The inpact that quantitative analysis of software system can have in 
software design has been recognized long ago in the software engineering community. Comprehensive approaches 
to this topic exist, notably the pioneeristic work by Smith [ 15,161. There exists a general agreement 
that quantitative analysis of software system is important and useful for requirements and design, and 
the earlier it can be performed in the software development life cycle the better it is. In the software 
practice the problem is that software is complex and the evaluation process, in terms of model definition, 
is very empirical [4], thus it is not easy to apply to software systems the same evaluation approaches 
used for hardware systems. We believe that, in order to be successful, this kind of analysis has to be 
automatized as much as possible. The software architecture level of software modelling although simple 
is very informative, since important design choices have already been taken. Our approach is based on 
the assumption that, in building the evaluation model, as much work as possible has to be automatically 
derived by the Software Architecure description. Our choice is to use the CHAM description of a SA, but 
the approach is not commited to it. Permission to make digital or hard copies of all or part of this 
work for personal or classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advantage and that copies bear this notice and the full citation on the first 
page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior 
specific permission and/or a fee . WOSP98, Santa Fe, NM. (c) 1998 ACM l-58113-060-O/98/00... $5.00 The 
paper is organized as follows: in Section 2, the CHAM formalism and its use to specify software architecture 
are introduced. The approach is exemplified by using the well-known example of the multiphase compiler, 
which will be used throughout the paper to illustrate the performance evaluation method. Section 3, briefly 
summarizes the characteristics of Queueing Network Models (QNMs) and of their creation process. Section 
4, presents the algorithms to derive from the CHAM specification of a Software Architecture a partially 
defined QNM. The completion of the QNM definition and its evaluation, are carried out in Section 5. Section 
6 adds some concluding remarks and discusses future work. 2 Cham For Software Architectures In this section 
we briefly introduce the CHAM formalism and its use for the description of Software Architectures as 
introduced in 161. We refer to that paper for more details. A Chemical Abstract Machine is specified 
by defining rnolrc~u1e.sm, m . m ,... defined as terms of a syntactic algebra that derive from a set 
of constants and a set of operations and .solutions s s, S ,... of molecules. Molecules constitute the 
basic elements of a CHAM, while solutions are multisets of molecules interpreted as defining the .stute.r 
of a CHAM. A CHAM specification contains tronsjhrmtrtion rules T, T ,... that define a truns~~rrntrtiorz 
relution S -T S , dictating the way solutions can evolve (i.e., states can change) in the CHAM. The transformation 
rules (also called reaction rules) can be of two kinds: general luws that are valid for all CHAMs and 
specific rules that depend on the particular CHAM being specified. At any given point, a CHAM can apply 
as many rules as possible to a solution, provided that their premises do not conflict that is, no molecule 
is involved in more than one rule. In this way it is possible to model parallel behaviors by performing 
parallel transformations. When more than one rule can apply to the same (set of) molecule the CHAM makes 
a nondeterministic choice as to which transformation to perform. The CHAM description of a software architecture 
[6] consists of a syntactic description of the static components of the architecture (the molecule), 
a solution representing the initial state of the architecture, and of a set of reaction rules which describe 
how the system dinamically evolves through reaction steps. The syntactic description of the components 
is given by an algebra of molecules. Following Perry and Wolf [ 131, we distinguish three classes of 
components: data elements, processing elements, and connecting elements. The initial solution is a subset 
of all possible molecules that can be constructed using the syntax. It corresponds to the initial, static 
configuration of the system. Transformation rules applied to the initial solution define how the system 
dynamically evolves. The CHAM formalism allows for different analysis techniques which permit to analyze 
and verify various properties of the system under specification. In particular, it is possible, taking 
advantage of its operational flavor, to derive transition systems from specifications and then reason 
at the transition-system level. Here, we will base the derivation of the evaluation model on the transition 
system but it will also be necessary to make use of the algebraic specification. 2.1 The two competing 
SA for a multiphase compiler Let us recall the well known mutiphase compiler architectures [6,I3]. The 
data elements are characters, tokens, phrases, correlated phrases (i.e.,phrases signifying name uses 
related to phrases signifying name declarations), and object code. The processing elements are the text 
(i.e., the producer of source characters), lexer (i.e., lexical analyzer), the parser, the semantor (i.e., 
semantic analyzer), and the code generator. An optional processing element is the optimizer. The connecting 
elements consist of two operations, i and o, acting on the data elements and representing the communication 
ports, input and output respectively. The clussiccrl multiphase compiler architecture [see Figure 2.1 
] fits the processing elements together sequentially in the obvious way, with each processing element 
running its phase to completion before passing data elements on to the next processing element. A rather 
different architecture [see Figure 2.21 fits the processing elements together via concurrent access to 
a shared repository. The processing elements run their phases opportunistically and in parallel so that, 
for example, the semantor can correlate phrases at the same time as the lexer is creating new tokens. 
FIGURE 2.1 The CHAM specification of the sequential architecture consists of the molecule syntax Xseq, 
transformation rules T ,, T, and T, and the initial solution S, defined as follows: M::=PICIMoM P ::= 
text I lexer I parser I semantor I optimizer I generator D ::= char I tok I phr I copbr I obj C ::= i(D) 
I o(D) where P is the set of processing elements, D is a set of constants representing the data elements 
and C is the set of connecting elements of the compiler. At the molecules level, we also introduce an 
infix operator <> that we use to express the status of a processing element with respect to its input/output 
behavior. For example, the molecule i(tok)oo(phr)oparser represents the parser in the state in which 
it can consume tokens as input and then go in a state in which it can produce phrases as output. The 
molecule parseroi(tok)oo(phr) represents the parser in the state of having consumed all input tokens 
and prodeuced all output phrases. As we said in the previous section, a state change is achieved by applying 
suitable reaction rules. T, = text o o(char) --, o(char) o text T*=i(d)om,.o(d)om2+ m,oi(d),m*oo(d) T3 
= o(obj) o generator o i(cophr) + i(char) o o(tok) o lexer, i(tok) o o(phr) o parser, i(phr) o o(cophr) 
o semantor, i(cophr) o o(cophr) o optimizer, i(cophr) o o(obj) o generator where ml, m2 EM and cl ED. 
The next step is to define an initial solution S , . This solution is a subset of all possible molecules 
that can be constructed under Zseq and corresponds to the initial, static configuration of a system conforming 
to the architecture. Transformation rules applied to the solution define how the system dynamically evolves 
from its initial configuration. S, = textoo(char), i(char) o o(tok) o lexer. i(tok)o o(phr)o parser, 
i(phr) o o(cophr) o semantor, i(cophr) <> o(cophr) o optimizer, i(cophr) o o(obj) o generator. The first 
rule makes source text available for compiling. The second rule describes pairwise input/output communication 
between processing elements. Completion of the communication, that is, the result of the transformation, 
is indicated by a rewriting of the molecule such that the data port is moved to the right- most position 
of the molecule. The third transformation rule restores the processing elements to their initial states 
after the code generator has completed its task and offered object code as output. This allows the system 
to begin processing a new source text. Let us now briefly present the CHAM specification of the second 
multiphase compiler architecture. The primary difference is that there are new elements among the connecting 
elements, to represent the use of the repository. In particular, there is a repository element and two 
new operations, ir and or, whose roles are analogous to the i and o operations already introduced, but 
apply to the repository rather than to the processing elements. In addition, the structure of the molecules 
is enriched by introducing an infix operator II to syntactically represent a composed molecule that can 
be broken down into parallel subcomponents, thus allowing multiple reactions to occur simultaneously. 
In more familiar terms, it can be intuitively interpreted as a parallel operator. The syntax Cc,, of 
this architecture is obtained by augmenting &#38; as follows. M::=PICIMoMIM IIM P ::= text I lexer I 
parser I semantor I optimizer I generator D ::= char I tok I phr I cophr I obj C ::= i(D) I o(D) I ir(D) 
I or(D) I repositoryi Next, we need a solution to represent the initial configuration. Let us call it 
S 1 : = textoo(char), i(char)oo(tok)olexer, i(tok)oo(phr)oparser, i(phr)oo(cophr)osemantor, i(cophr)oo(cophr)ooptimize 
 i(cophr)oo(obj)ogenerator, ir(tok)orepository 1, ir(phr)orepository2, ir(cophr)orepository3 The solution 
contains a molecule that represents concurrent access to the repository at the granularity of the three 
kinds of data elements stored in the repository. To complete the specification, a new set of transformation 
rules is defined. Tg = i(char)oo(tok)olexer, o(char)otext -o(tok)olexeroi(char), textoo(char) Tg =ir(d)orepositoryi, 
o(d)om -ir(d)Orepositoryi, m 00(d), or(d)Orepositoryi T7 = i(d)-, or(d)Orepositoryi + m c-i(d), mfdjorepositoryi 
Tg =i(d)om, or(d)orepositoryi + m <S(d) T9, w1,lm2l...lm,, -m,,m2, ,mn Tin = p oi(dl Wd4) -WI )o+$)op 
.- T11 = m oi(d) + i(d)om T12 = text oo(char) + o(char)otext T13 = text oa(char) -text where ml, m2 ,..., 
mnEM, d,d,,dzE D, PEP and iE{ 1,2,3}. Ts is a specialization of the generic reaction rule T2 from the 
sequential compiler architecture that describes the input of text to the lexer. T6 through Ta are reaction 
rules that generically describe the communication of data elements between the repository and the processing 
elements; flow of data from a processing element into the repository is described by T6 while T7 and 
TX describe the reverse. Tg breaks apart a complex molecule into its (parallel) components, which can 
then participate in (parallel) reactions; Tlo reactivates an inert processing element; TI 1 reactivates 
the input port for a processing element before that processing element performs output; and T12 makes 
more of the source text available for compilation, thereby continuing the whole compilation process for 
a given source text. Finally, T13 is a reaction rule that terminates character input, indicating that 
the source text has been exhausted. The effect of T13 is to eventually cause all processing of a particular 
source text to stop. 3 The Queueing Network Model Queueing Network Models (QNMs) have been extensively 
applied to represent and analyze the performance of resource sharing systems, such as production, communication 
and computer systems. A QNM is represented as a network of queue which is quantitatively evaluated through 
analytical or simulation methods to obtain a set of measures, the performunce irldic~s. A network of 
queue is a collection of service centers, which represent system resources, and customers, which represent 
users which share the resources. A QNM can be represented as a directed labelled graph where nodes are 
service centers, arcs represent transitions of customers along nodes and labels on arcs define the routing 
probability. QNM can be single class when all the customers have the identical behaviour. More generally, 
different types or classes of customers can be modelled by multiclass queueing networks to represent 
various characteristics of customer service and routing behaviour through the network. QNM can be open, 
closed or mixed. In an open network model there is at least one arc coming from outside and at least 
one arc going out the network. The customers arrive from the external, queue in order to ask for service 
at a service center after which it either leave the system or ask for other services to some service 
center. In a closed network there are no external arcs, the number of customers in the system is constant, 
they neither enter or exit the network and they keep circulating among the service centers. Multiclass 
networks can be either open, closed or mixed. A mixed network is open with respect to some customer types 
and closed with respect to others. The queueing capacity of each service center can be finite to represent 
system resources with limited waiting rooms. QNMs with finite capacity queues are more appropriate models 
for systems with finite buffers and blocking, but their analysis is in general more complex 12,121. For 
more details on QNMs and their evaluation see [2,7,8,9,10,12]. For simplicity, hereafter we will only 
deal with open models, therefore we only consider features of open models. Informally a QNM can be described 
by three basic elements: l service centers (also called nodes). We specify the number of service centers 
and for each node: - the service discipline, i.e. the scheduling of the customers in the queue; - the 
number ofservers, which represents the maximum number of customers that can be simultaneously served 
by the node. Each server executes a service and all servers are identical; - the service rate, i.e. 
units of services per unit of time;  l customers; we define: the arrival process to each node, i.e. 
the arrival of the customers at the system; this is usually a stochastic process for open networks, while 
it reduces to the total customer population for closed models; the customers required services to each 
node, expressed in service units; this is usually a random variable; the classes (or chain or type) q! 
customers that partition customers in subsets with similar behavioural characteristics; . node interconnection 
structure (or topology) represents the possible customer transitions among the nodes and their behaviour 
that can be either stochastic or deterministic. Non-deterministic customer behavior is represented by 
a stochastic routing matrix whose entries are the routing probabilities between nodes ant that is defined 
for each class of customers. The creation of a (open) QNM can be splitted in three steps: definition, 
which normally encompass the definition of service centers, their number, class of customers and topology; 
parameterization, to define the alternatives of the study, e.g. by selecting the arrival processes and 
service rates, evaluation, to obtain a quantitative description of the system behaviour described by 
the QNM. This step is based on the computation of a set of figures of merit or performance indices. If 
the system is never saturated, that is a customer never waits an indefinitely long time to be served, 
then it reaches a stationary or steady-state behaviour. We assume that this stationary condition holds 
and we analyze the steady- state system model. The analysis of a QNM is carried out depending on its 
characteristics. Under general assumptions it can be reduced to the analysis of an underlying stochastic 
process. Under some constraints the QNMs analysis can be greatly simplified. For the so called, product-form 
class of QNM efficient solution methods have been defined [7,8,9,10]. The models we will use fall in 
this class. The analysis of the QNM allows a set of performance indices to be computed. These indices 
can be local to a resource or global to the whole system. We will consider the following local indices 
for a node i: - ni the random variable number of customers at node i; - Ni = E[ni] mean of ni; -Ri mean 
response time of a customer at node i ; -Ui utilization of node i; -Xi throughput of node i. and the 
global indices : -N mean of the number of customers in the network; -R mean network response time of 
a customer; -U overall utilization; -X overall throughput. Note that the number of customers in an open 
network is a random variable. 4 From The CHAM SA To The QNM In this section we present the algorithm 
to derive the performance evaluation model out of a CHAM specification of a software architecture. Actually, 
referring to the modelling process described in the previous section, the algorithm performs the first 
step, i.e. the definition. The algorithm is based on the analysis of the transition system (TS) associated 
to the CHAM specification. TS represents the dynamic behavior of CHAM architecture and it can be represented 
by a directed labelled graph whose nodes are the system states, arcs are the transitions between states 
and labels are the transition rules which allow state transitions. The generation of the QNM depends 
on the interactions among the customers and the components of the system. This kind of information is 
dynamic and it can only be derived from the analysis of the dynamic behaviour of the system. The algorithm 
is organized into two sequential steps. The first step (PHASE 1) examines all the TS paths, it looks 
at the states along a path (i.e. solutions) in order to single out all the pairs of element which are 
involved in an interaction. The second phase (PHASE 2) uses these interaction pairs to device the topology 
of the evaluation model and the customers classes. The two portions of the algorithm are presented in 
Figure 4.1 and 4.2, respectively. The complexity of this phase is O(nm*a) where n=number of nodes of 
the TS, m=maximum number of molecules contained in a solution and a=maximum number of adjacent nodes. 
PHASE I takes in input sets derived from the CHAM specification: the set of processing elements P; the 
set RR of reaction rules that describe the interactions between P and PaC where PaC is a subset of C 
(connecting elements) and contains passive connection elements only, i.e. the elements used for asynchronous 
communication; TS is the transition system. A generic output set Ii contains all the pairs obtained by 
checking a TS node and its adjacent nodes to determine the interactions; the elements in a pair are in 
the set PaCUP and signal a flow of data elements from the first to the second elements of the pair. PHASE 
1: INPUT: P = {processing elements}; RR = {relevant reaction rules}; PaC = {passive connection elements}: 
TS = Transition System: OUTPUT: II.l2,13,... Ii = {interaction pair?}; hegin S:={ S i }: i:=O; while 
S do hegin s._c:=extractfirst(S);(and mark} AS:=AdjacentStates(s_c); if #Ii >O then i:=i+l; while AS 
do begin s-a:=extractfirst(AS); insert(s_a,S);{if s-a is not marked} if et(s-c,s-a)ERR then begin <single 
out the pair of molecules involved in the reaction> <build the Interaction Pair IP> li:=IiUIP end end 
end end: Figure 4.1 In the second phase the Ii sets computed in the first phase are examined in order 
to associate to them elements of the QNM. In input, besides the sets P and PaC we also need a set A (where 
A is subset of P) denoting the set of processing elements representing the external environment. Elements 
in A can be seen as sources which model the production of customers of the system. Let us informally 
introduce how the second phase algorithm works. At the beginning every element in P is considered as 
a simple server, along the computation it can become part of a more structured element. The idea is to 
initially consider each processing element as an autonomous service center, thus modelling the maximum 
level of concurrency, then the interaction puirs permit to identify those processing elements that can 
be merged in a service center since they are always executed sequentially. The goal is to determine the 
real level of concurrency of the system and consequently of the QNM. This is very important in order 
to obtain QNMs that faithfully represent the given system. When all the sets Ii have been examined the 
algorithm proceeds by performing merging operations to reach the final configuration of the service centers. 
There are several merging operations as listed in Figure 4.2. The result of these merging operations 
is a set of service centers. In order to identify the model constituents that will be incrementally built 
by the algorithm, we have introduced a set of auxiliary definitions with their graphical counterparts. 
For brevity, we will only report the one used in the following example, full details are given in 1 I 
I]. Definition 0 this symbol represents the Simple Server e, c denoted by SS(e) it provides a service 
performed by the processing element this symbol represents the Complex Service e I ,_._, en , denoted 
by SC(e I ,..., en) it provides, as a unique service, the set of services performed by the simple servers 
SS(el), . . . . SS(e,) in the given order; its average service time results from the summation of the 
average times of the simple servers; this symbol represents the multiclass server (el e2)(el e3), denoted 
by SM((el e2)(el e3)) it provides different services (in this case two); a generic user can choose one 
of the services associated to the two complex servers; this symbol represents the service center e, 
denoted by CdS(e) it provides the services offered by the processing element e; differently from the 
simple server it has an infinite buffer to queue users waiting for services; this symbol represents the 
service center e with external arrivals denoted by CdS,(e) it is like CdS(e) but it allows users from 
outside the system; [e l , ,e, 1 it represents the partial path el , . ,e, denoted by CP(el, . . . ,e,); 
it indicates the processing elements that can be traversed by a user, it identifies a possible history 
of the requested services to the system by a generic user; cl this symbol represents the partial le e21 
multipath(e1 e2)(el e3) denoted by le e31 MCP((el e2)(el e3)) it indicates that a user can mutually 
exclusively enter one of the two sequence of processing elements; analogously it can be extended to m 
tuples of different dimensions; a + b it represent a transition from a to b a user leaving a goes to 
b ; a can be a simple server, a service center or a service center with exogenous arrivals while b can 
be a service center or a service center with exogenous arrivals; PHASE 2: INPUT: A = {exogenous processing 
elements}: P = {processing elements} A; PaC = {passive connection elements}: I = { Ii }; OUTPUT: QNM 
; beginfor each i do for (el Q)Eli do begin if r2EP then (if elEA then begin build Cd&#38;(q); build 
CP(lel,e21) end else (if e lEPaC then build ( dS(e2))): if e 1 ,qtP then begin IYairs:={(el ez)}U{(ej 
e4)Eli I ez=q &#38; e2 fe4 &#38; e4EP) if #pairs>1 then  begin build SM(pairs); build MCP([pairsl) end 
else begin build SC(el e2); build CP(lel . e21) end end: for each (el e2)Eli begin pairs:={(ej e4)Elj 
I J>i &#38; e2=e3 &#38; el fe4 &#38; e [ .e4EP &#38; e2EPaC); pairs:= 0; for each (ej e4)Epairs do begin 
build e I +eq;pairs := pairs U{(el e4)} end if #pairs > I then build MCP(pairs ) else build CP([el , 
e4l)  end; merge all the compatible complex servers; merge all the compatible multiclass servers; merge 
all the compatible complex and multiclass servers; merge all the complex servers and all the service 
centers; merge all the multicass servers and all the service centers; merge all the compatible partial 
paths; merge all the compatible partial multipaths; merge all the compatible paths and partial multipaths; 
 end. Figure 4.2 The algorithm for the second phase is shown in Figure 4.2.The complexity of this phase 
is O(nt2c2) where nt is the number of sets Ii and c is the maximum number of pairs contained in a generic 
Ii. It is worth noticing that nt has as upper bound the number of states of TS (nt<n) and c has as upper 
bound the maximum number of adjacent nodes (c<a). From the algorithm we do not obtain a completely specified 
QNM. This is expected since we have only performed a functional analysis of the system. We still need 
to establish some of the quantitative parameters that characterize the model. That is we have to perform 
the parameterization step of the modelling process. The parameters to be still defined are: l the distributions 
characterizing the service times for every center. If the model has more than one customer class these 
service times have to be provided for every class; the distributions characterizing the customers arrival 
processes to every center. The complete specification of the QNM has to be done by the designer according 
to the information gained in running the algorithms and his knowledge of the QNMs. It is in fact important 
to fix the quantitative parameters SO that the resulting QNM be in a class that admits an efficient solution. 
5 Evaluating The Two Compiler SA In this section we derive the two QNMs associated with the sequential 
and concurrent architectures of the multiphase compiler. In the normal practice, evaluation models are 
derived in an empirical way, by analyzing the system. We show how we can use the CHAM specification and 
the algorithm defined in the previous section to derive the topology of the model and how to determine 
the quantitative parameters that have to be fixed in order to Transition System of the sequential compiler 
FIGURE 5.1 carry on an efficient numerical evaluation of the two models. 5.1 The model for the sequential 
architecture From the CHAM specification of the sequential architecture, starting from S, by applying 
T,, T, and T3, the TS in Figure 5.1 can be derived. where S, is that defined in section 2.1 while S2 
= u(char)otext, Sj = text o o(char), i (char)oo(tok)olexer, o(tok)olexeroi(char), i(tok)oo(phr)oparser, 
i(t ok)oo(phr)oparser, i(phr)oo(cophr)osemantor, i(phr)oo(cophr)osemantor, i(cophr)oo(cophr)ooptimizer, 
i(cophr)oo(cophr)ooptimizer, i(cophr)oo(obj)ogenerator i(cophr)oo(obj)ogenerator S4 = textoo(char), S5 
= textoc)(char), lexeroi(char)oo(tok), lexeroi(char)oo(tok), o(phr)oparseroi(tok), parseroi(tok)oo(phr), 
i(phr)oo(cophr)osemantor, o(cophr)osemantoroi(phr), i(cophr)oo(cophr)ooptimizer, i(cophr)oo(cophr)ooptimizer, 
i(cophr)oo(obj)ogenerator i(cophr)oo(obj)ogenerator S6 = textoo(char), S6 = textoo(char), lexeroi(char)oo(tok), 
lexeroi(char)oo(tok), parseroi(tok)oo(phr), parseroi(tok)oo(phr), semantoroi(phr)oo(cophr), semantoroi(phr)oo(cophr), 
i(cophr)oo(cophr)ooptimizer, o(cophr)ooptimizeroi(cophr), o(obj)ogeneratoroi(cophr) i(cophr)oo(obj)ogenerator 
 We can now apply the algorithm presented in Section 3, to carry on the first step of the modelling process. 
For simplicity let us denote as T the TEXT, L the LEXER, P the PARSER, S the SEMANTOR, 0 the OPTIMIZER 
and G the GENERATOR. For PHASE 1, we have: INPUT: P = {T, L, P, S, 0, G }; RR = {T2}; PuC = 0 ST = Transition 
System of Figure 5.1 The execution of PHASE 1 goes as follows: s-c s-a IP Ii none Sl S2 (T L) I1 =(TL) 
s2 s3 12 = (L P) s3 s4 CL PI I3 = (P S) s4 s5 (P S) 14 = (S 0) s5 StY 6 0) s5 s6 (S (3 I4 = I4U{(S (31=I@ 
0) , (S (31 ( 0 G) I5 = (0 G) s6 s6 the OUTPUT of PHASE 1 is the set of sets Ii in Table 5.1: pqgq Table 
5.1 For PHASE 2 we have: INPUT: P = { L, P, S, 0, G ) A=(T) PaC=0 ST = TS of Figure 5.1 I = {I,, I,, 
. . . . Id where the set P differs from the one in PHASE 1 for the A elements. A contains the processing 
element representing the exogenous customers, in this case Texts. PuC is empty as in PHASE 1 and I contains 
the sets Ii. We synthesize PHASE 2 as follows: l from I, it is generated the exogenous arrivals service 
center CdS,(L) and the partial path CP([T, L]) T -CID 3 [T Ll 0 l from I, the complex server SC(L, P) 
and the partial path CR L PI ) 0 CD 3 1 l-9 PI 8 l from I, the complex server SC(P, S) and the partial 
path CP( [P, Sl 1 from I, the multiclass server SM((S, O)(S, G)) and the partial multipath MCP( [S, 
O][S, G]) s, 01 S, Gl Q l from I, the complex server SC(0, G) and the partial path CPt lo, Cl 1 After 
the analysis of the Ii sets, merging operations start: l merge all the compatible complex servers, from 
SC(L, P), SC(P, S) and SC(0, G) the complex servers SC(L, P, S) and SC(0, G) are derived l merge all 
compatible multiclass servers, since there is only one multiclass server no fusion happens; l merge all 
the compatible complex and multiclass servers, from the complex servers SC(L, P, S) and SC(0, G) and 
from the multiclass server SM((S, O)(S, G)) the multiclass server SM((L, P, S, 0, G)(L, P, S, G)) is 
generated. The merging operations merge all the complex servers with service centers , merge all the 
multiclass servers with the service centers and merge all the complex servers with the exogenous arrivals 
service centers have no effect since no more service centers or complex servers are left; It remains 
to perform the operation: l merge the multiclass servers and the exogenous arrivals service centers, 
thus from CdS,(L) and SM((L, P, S, 0, G)(L, P, S, G)) the exogenous arrivals service center CdS,((L, 
P, S, 0, G)(L, P, S, G)) is generated:  3 +---J  After merging the structures which define the topology 
of the queue network model, the merging operations among paths are performed. These allows the characterization 
of type of customers depending on the customers requests. *merge all the compatible partial paths, from 
the partial paths CPUT, LI), CPUL, PI), CP([P, Sl) and CP([O, GI) the partial paths CP([T, L, P, S]) 
and CP([O, G]) are generated. I-L Ll l-l-, L PI > l-9 PI L-L L, P, Sl 3  [PI Sl l merge all the compatible 
partial multipaths; no fusions are performed since only one multipath exists; l merge all the compatible 
partial mutltipaths and paths, from the partial paths CP([T, L, P, S]) and CP([O, G]) and the partial 
multipath MCP([S, O][S, G]) the partial multipath MCP([T, L, P, S, 0, G][T, L, P, S, G]) is obtained: 
rL L, P, Sl [St Gl E 01 0 [Q Gl The resulting model is shown in Figure 5.2. Its topology is a unique 
service center with exogenous arrivals that can offer two different services. One is the service consisting 
in the five compilation phases, optimization included; the other consists of four phases, excluding the 
optimization. The two tuples [T, L, P, S, 0, G] and [T, L, P, S, G] characterize two classes, each one 
requires services to the processing elements in the order indicates in the tupla. Since the first element 
of both tuples is an element in A we associate an open chain to the two classes of customers. We assume 
a FCFS discipline. for Sequential Architecture Figure 5.2 51.1 Paraineterization In order to characterize 
the workload we have to define parameters for the arrival processes and the mean service time for both 
customers classes. Since we are at a very high level of abstraction we consider symbolic parameters which 
will assume a relative meaning only during the comparison with the other competing software architecture. 
Thus we denote with: . hi, mean arrival rate of the customers of the first class; l ho, mean arrival 
rate of the customers of the second class; l l/u~, mean service time for a customer of the first class; 
l l/uo, mean service time for a customer of the second class. 5.1.2 Evaluation As already discussed 
in Section 3, in order to efficiently evaluate the model we generate product-form QNMs. To this purpose 
we assume that the distributions for the arrival time and the service time are exponential. Moreover 
we assume that arrivals and services are independent. In this way it is possible to evaluate each node 
and/or classes separately. Before carrying on the evaluation we have to assume that the stationarity 
condition holds that guarantees the existence of a steady model solution. The network is stable if both 
the two classes associated to the unique node are stable. In this case we have that the first class is 
stable if its arrival rate is smaller than its service rate, i.e. h~<p~; similarly for the second class 
for which it must hold ho+o. Therefore we impose these conditions and proceed with the analysis of the 
first class. Let us introduce the following notation: nN, the random variable (ryv.) number of customers 
of the first class (i.e. those not requiring the optimization phase) in the model; no, the r. v. number 
of customers of the second class in the model; p~=h~/p~, traffic intensity of the first class of the 
model; it is defined as the ratio between the mean arrival rate and the mean service rate. po=ho/po, 
traffic intensity of the first class of the model. Given the hypothesis discussed above, we observe 
that our model can be evaluated by the M/M/l queueing system whose simple closed-form solution is well-known 
in the literature [7,8]. Thus we can easily evaluate the performance indices of the system M/M/I which 
characterize the model under study. The analysis of the two classes of the model shown in Figure 5.2 
is the same and we derive the following performance indices for each class I=N,O: l mean customer number 
of class I: NI = ELM = m/Cl- PI)  l throughput of class I: XI = AI l mean responce time of of class 
I: RI = NI / h, = l/(u,*( I- pI)); l utilization of class I: Ut = Prob{nI> 0} = pt We can evaluate 
the global indices of the network as follows: l mean number of customers: N = &#38;{N, 0) NI = Pdt I-k 
N) + PO/t1 - PO) l throughput: x = CIE{N. O}xI = AN + hO l mean responce time: R = (EIE{N, O>RI XI 
) / X= + ROANMAN + ho) (RN~N . utilization: u = &#38;E{N, O}u[ = PN + PO It is worth noticing that the 
assumptions made to define the model are satisfied by the software system, i.e. the model is representative. 
Moreover the model solution is exact. 5.2 The model for the concurrent architecture The technique to 
derive the model for the multiphase concurrent compiler architecture carries on analogously to the previous 
case, thus we only summarize the resulting model, We assume a FIFO discipline at each service center. 
QNM for Concurrent Architecture Figure 5.3 The QNM is formed by five service centers and its topology 
is shown in Figure 5.3. From the algorithm we obtain two tuples [T, L, P, S, 0, G] and [T, L, P, S, G] 
that characterize two class of customers as in the sequential architecture. Each class of customers behaves 
according to an open chain, thus the resulting model is open multiclass network. 5.2.1 Parameterization 
To characterize the workload of the network model, we define the parameters of the arrival processes 
to the network and the service time for each service center. We denote with: . ho, mean arrival rate 
of the customer of the first class to service center L; l hN, arrival rate of the customer of the second 
class to service center L; I/PO, mean service time at service center 0 of a l throughput : X,=b; customer 
of the first class; l I/uI,j, mean service time at the service center jE{L, P, S, G of a customer of 
class I E{O,N}. 52.2 Evaluation In order to effiently analyze the QNM we make some assumptions which 
guarantee that the model has a product-form solution. In particular we assume that the arrival times 
and all the service times are independent exponential random variables for each customer class. The service 
discipline of each node is FCFS. The network topology is tandem for each class according to the ordering 
(L,P,S,O,G) for class 0 and (L,P,S,G) for class N, respectively, as shown in Figure 5.3. Then the obtained 
QNM is a Jackson network with product-form solution which can be easily analysed by decomposition into 
five M/M/l systems with appropriate parameters. The network model is stable if all the nodes are stable. 
For the two classes of customers we obtain the following constraints A+ min({po>U {uo,j I jE {L,P,S,G])) 
hN< miIl{wj 1 jE {L,P,S,G}}. If these stationarity conditions are satisfied the analysis of the network 
model is obtained by the M/Ml solution for each node, similarly to the anaiysis of the model of the sequential 
architecture. We summarize the results as follows. Let us define: l nI,j, r.v number of customers of 
class lE{O,N} at node jE-L P, S, Gl; l pI,j =hI/pI,j lE{O,N}, jE{L, P, S, G}, traffic intensity of class 
1 at service center j; it is defined as the ratio between the mean arrival rate and the mean service 
rate of class I at service center j. the r. v. number of customers at node 0; l 0, l po =A&#38;po, traffic 
intensity at service center 0. Therefore we can derive the following performance local indices for every 
node and for each customer class: mean number of customers of the class IE{O,N } at node jE{L, P, S, 
G}: NI,j = E[nI,jl = PI,j/(l- PI,j); throughput of class I E{O,N} at node j E{L, P, S, G}: Xlj = Al mean 
responce time of class I E{O,N}at node jE {L, P, S, G}: RI,j = NI,j / AI= l/(uI,j*(I- pIj )); utilization 
of class lE{O,N}at node jE{L, P, S, G}, UIj = Prob{nIj > 0) = pI,j; For the center 0 we have: l mean 
number of customers: NO = Hnol = Ml-PO); . mean responce time: R. = No / AQ = I/(Po*( I- po )I; . utilization 
: UO = Prob{ng > 0} = PO;  We now derive the global indices for each node as follows: l mean customer 
number at node jE{L, P, S, G}: Nj = 0) NIj = 0} PI,j/(l-PIj) CIE{N, xIE{N, l throughput of node jE{L, 
P, S, G}: xj = xIE{N, O>xI,j = O&#38;I =hN + hO zIE{N, l mean responce time of node jE{L, P, S, G}: Rj 
= (CIE{N, XIj ) / xj= O&#38; = (RN,jh+ RO,jh)/(h+ LO) l utilization of node jE{L, P, S, G}: uj = CIE{N, 
O} I,j = + PO,j PNj Then we obtain the network performance indices for both classes of customers: mean 
customer number of class IE{O, N}: No= EjE{L, P, S, 0, CJ NI,j =XIE{L, P, S, G} PI,j/( I- Plj) + PO/( 
I- PO) NN =EjE{L. P, S, G} NI,j = Xj E{L, p, s, G} PI,j/(l- PIj) throughput of class lE(0, N}: x1+ mean 
responce time of class IE{O, N}: RI = N1 /Al Finally we can evaluate the global to the system performance 
indices: mean number of customers in the system: N = zjE{L, P, S, 0, G} Nj =cjE{L, P, S, G} lE{O,N} Pl,jhl-Plj) 
+Pd(l-PO); throughput: X=EIE{N, O}XI,j=~IE{N, O}hI =hN + ho mean responce time: R =tEje{L,P, s, G)IE{N, 
o>Pl,j/(l-PIj) + ~d(l- PO)YX. 5.3 Comparing the two Software Architectures In this section we carry 
on the comparison between the two software architectures. For brevity we will only discuss one performance 
index, namely throughput. See [l l] for a comprehensive comparison. In order to compare the two QNMs, 
the same workload has to be considered, i.e. the inputs to these models have to be equally specified. 
More precisely, these amounts at imposing identities between the the load measures, arrival rates of 
customers and total service demands, of the two models. Let us denote with: his arrival rate of customers 
of class IE{N,O} in the sequential model; hlC arrival rate of customers of class lE{N,O} in the concurrent 
model; l/p~~ mean service time of a customer of class IE{N,O} in the sequential model; mean service time 
of a customer of classl cLl,j c IE{N,O} to the center jE{L, P, S, G} in the concurrent model; I /pOc 
mean service time of a customer to the center 0 in the concurrent model. The relation between the corresponding 
arrival rates of customers is obtained by imposing: hlC = hlS for the arrival rate of customers of class 
IE{N,O} while as far as the total service demand is concerned, we observe that a customer of class IE{N,O} 
in the sequential architecture requires l/pls mean service time, while in the concurrent architecture 
the mean service time is the summation of the mean service times corresponding to the various service 
centers. Thus this mean service time is CjE{t,, p, s, c}l/pO,jc + l/kc and CjE{ L, P, s, c} PNJ .c for 
a customer of class 0 and N, respectively. Therefore the relation is the following: 1 1 1 1 1 1 +-~-+-c~+c+-(5.1.a) 
&#38;I d,L iu0.P P0.S PO P&#38;G (5.1.b) vib &#38;,L &#38;G,P &#38;,s vh.0 We can now compare the performance 
indices of the two models. To this purpose we present some examples by considering three different scenarios, 
which allow US to instantiate some of the quantitative measures. 1) The mean service times of the nodes 
in the concurrent model have the same degree of magnitude. This corresponds to assume that all the compilation 
phases perform comparable elaborations. 2) The mean service time for a class at some center in the concurrent 
model is of the same degree of magnitude of the mean service time of the same class of the center in 
the sequential model. This corresponds to the situation in which one of the compilation phases is so 
expensive that the others become not influential. 3) There exist centers, in the concurrent model, with 
minimum and maximum mean service time, so that all the other service times fall in that interval. Now 
we can proceed by comparing the performance indices of the two models in the given scenarios. For simplicity 
in the following we will only present the performance comparison in terms of throughput. It is interesting 
to look at this comparison since for the throughput, due to the workload assumptions above, we cannot 
simply compare the resulting measures. 53.1 Throughput We observe that it is meaningless to directly 
compare the throughput of the two models. Indeed, this index directly derives from the mean arrival rates 
at the models that are assumed identical in the two models. Therefore the throughput index for the two 
models is identical. However, it is meaningful to compare the two models by considering the maximum throughput 
that they can support, provided that the stationarity condition holds. For class IE{N,O} the stationarity 
condition is h&#38;~l~ for the sequential model, and h%min ({~oc>U{/A~,jc jE{L, P, S, G} ) and hNC<min 
({pN,j I jE{L, P, S, G}) for the concurrent model. Thus we obtain the maximum throughput for the sequential 
model as follows: &#38;, = $4 (5.2) and for the concurrent model and class IE{N,O}: X&#38; = min({rhj,j~L,P,S.G}}U[~~}] 
(5.3.a) Id&#38; = min[ ,uh,j, j~U ,S.G}} (5.3.b) From (5.1.a) and (5.1.b) it follows XoseqiXocon e that 
is the maximum throughput of the XNS13CpNCO ~ sequential model is less than the throughput in the concurrent 
model for both classes. Let us now consider the three scenarios introduced above: 1) From the hypothesis, 
we can write: 1 1 -=- jE{L, P, S, G}, IE{N,Ol vI Pi,j  1 I for center 0 F T 0 that is YN and YO represent 
the common vaIue of the mean service rates of the two classes, up to a negligible approximation error. 
Hence by (5.3.a) and (5.3.b) it follows that: = v, IE{N,O}. X con On the other side for the sequential 
model we can write: vO vN  xteq= 1L;= -, XN w =P;=-. 5 4 Thus, as expected, we obtain that: 5 4 that 
is the maximum throughput of class 0 in the concurrent model is 5-times bigger than that of the sequential 
model and for class N it is 4-times. 2) From the hypothes it is follow that for a given class I and a 
center, say L, we can write 1 1 --I---lE{N,Ol (5.4.a) 4 &#38;L 1 1 ---,-cF << L-jE{P,S,G} lE{N,O}. (5.4.b) 
Pi ,j PO d,L Hence we obtain: X con = &#38;,L I~{N,O~ X 9 =P; IE{N,Ol Then, from (5.4.a) we observe that 
the two models have nearly the same throughput. 3) From the hypothesis we can write for a node j in the 
concurrent model: II s ,M; j 5 UI jE{L, P, S, GI, IE{N,OI (5.5.a) 10 syuo (5.5.b) where I, = min ps,j,jq 
LP,Si.GI}U((I;)] 1-i U. = max {{ po,,, jW-,P,S,G~)Ub&#38;-} I,,, = min p ,,j,j e{L,P,S,G} i ) t/N = max 
,Ui,j, j E{L, P, S, G} i 1 This and formulas (5.3.a) and (5.3.b) lead to: x con I, IW,Ol = Substituting 
relations (5.1 .a) and (5.1.b) in formulas (5.5.a), (5.5.b) yildes to 1 5-1-S 55.L (5.6.a)F uo 0 10 (5.6.b) 
UN ; IN which leads to IN 05 ps s Uo V+!L. 5 O-7 4 4 By comparing Xlseq and Xlcon we have uo x%q UN 
x!eq that is the maximum throughput of class 0 in the concurrent model is k-times bigger than that of 
the sequential model where kE[5(lO/uO), 51 while for class N it is kE[4(lo/uo), 41. 6 Conclusions In 
this paper we have presented an approach to evaluate the performance of software architectures specified 
in CHAM. The method allows the automatic derivation of a QNM that can then be efficiently evaluated. 
In carrying on this work we have made two main choices, let us briefly discuss them in the following. 
Why Queueing Network Models ? Queueing Network Models have been a popular tool in the performance evaluation 
world since they achieve a favorable balance between accuracy and efficiency. From our perspective of 
software architectures, QNM can be defined, parameterized and evaluated at a low cost and their level 
of abstraction easily allows a faithful modelling. Other approaches to performance evaluation of software 
system specification have been proposed, which iclude stochastic process algebra and stochastic Petri 
nets, e.g. [ 1,3]. Most of the approaches are based on Markovian processes, which although very general 
have the drawback of not guaranteeing efficient solutions. Why CHAM specijication? The approach we have 
presented is not committed to the use of the CHAM formalism. The derivation of the QNM starts from a 
labelled transition system which represents the dynamic behaviour of the system. Actually, the algorithms 
presented in Section 4 need also some auxiliary information (the INPUT sets) which are directly derived 
from the algebraic specification. In principle any formalisms that has a transition system semantics 
suitably enriched with some auxiliary information on the nature of the interconnection mechanisms can 
be used. The work presented in this paper represents a first step towards the construction of a flexible 
environment for the evaluation of software architectures specified in CHAM. At present we can automatically 
generate the transition system out of a CHAM description. Future work is the realization of a user-friendly 
environment to drive the completion of the QNM definition, with the possibility of creating several different 
scenarios in which evaluate the models. References <RefA>1. G. Balbo, G. Conte and M. A. Marsan. Performance 
Models of Multiprocessor Systems. Series in Computer Systems, The MIT Press, (1986). 2. S. Balsamo. 
Properties and Analysis of Queueing Network Models with Finite Capacities. LNCS (Springer- Verlag), No. 
729, (1994).  3. M. Bernard0 and R. Gorrieri. Extend Markovian Process Algebra. In Proc. CONCUR 96, 
315330, LNCS 1119.  4. G. BBckle, H. Hellwagner, R. Lepold, G. Sandweg, B. Schallenberger, R. Thudt, 
S. Wallstab. Structured Evaluation of Computer System. IEEE Computer Society, 45-5 1, June 1996.  5. 
D. Compare, P. Inverardi and A. L. Wolf. Uncovering Architectural Mismatch in Dynamic Behavior. Technical 
Report CU-CS-828-97, Department of Computer Science, University of Colorado, Boulder, Colorado, February 
1997, to appear in Science of Computer Programming , Juanuary 1999.  6. P. Inverardi and A. L. Wolf. 
Formal Specification and Analysis of Software Architectures Using the Chemical Abstract Machine Model 
. IEEE Transactions on Software Engineering, Vol. 21, No. 4, 373-386, April 1995.  7. K. Kant. Introduction 
to Computer System Performance Evaluation. McGraw-Hill, 1992.  8. L. Kleinrock. Queueing Systems. Vol. 
1: Theory. (Wiley 1975).  9. E. D. Lazowska, J. Zahorjan, G. Scott Graham, K. C. Sevcik. Quantitative 
System Performance: Computer System Analysis Using Queueing Network Models. Prentice-Hall, Englewood 
Cliffs, (1984).  10. E. D. Lazowska, J. Zahorjan and M. Vernon. A Comparison of Performance Petri Nets 
and Queueing Network Models. Modelling Techniques and Performance Evaluation, edit by S. Fdida and G. 
Pujolle, Elsevier Science Publishers B.V. (North-Holland), 191- 202, (1987).  Il. C. Mangano. Valutazione 
delle Prestazioni di Architetture Software. Laurea Thesis in Computer Science, University of Pisa, April 
1997. 12. R. 0. Onvural. Survey of Closed Queueing Networks with Blocking. ACM Computing Surveys, Vol. 
22, No. 2, 83-121, June 1990. 13. D. E. Perry e A. L. Wolf. Foundations for the Study of Software Architecture. 
ACM SigSoft Software Engineering Notes, Vol. 17, No. 4,40-52, October 1992. 14. M. Shaw and D. Garlan. 
Software Architecture: Perspectives on an Emerging Discipline. Prent. Hull, (1996). 15. C. U. Smith. 
Performance Engineering of Software Systems. Addison- Wesley Publishing Company, (1990). 16. C. U. Smith 
and L. G. Williams. Software Performance Engineering: A Case Study Including Performance Comparison with 
Design Alternatives. IEEE Tran. on Software Engineering, Vol 19, No. 7, 720-741, July 1993. </RefA>  
			

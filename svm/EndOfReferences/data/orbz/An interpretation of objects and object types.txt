
 An Interpretation of Objects and Object Types Martin Abadi Luca Cardelli Digital Systems Research Center 
Digital Systems Research Center ma@pa. dec. com luca@pa. dec. com Ramesh Viswanathant Isaac Newton Institute 
for Mathematical Sciences R. Viswauathan@newt on. cam. ac .uk Abstract We present an interpretation of 
typed object-oriented con­ cepts in terms of well-understood, purely procedural con­ cepts. More precisely, 
we give a compositional subtype­ preserving translation of a basic object calculus supporting method 
invocation, functional method update, and subtyp­ ing, into the polymorphic ~-calculus with recursive 
types and subtyping. The translation techniques apply also to an imperative version of the object calculus 
which includes in­ place method update and object cloning. Finally, the trans­ lation easily extends 
to Self types and other interesting object-oriented constructs. 1 Introduction Object-oriented programming 
languages have introduced nu­ merous ideas, structures, and techniques. Although these contributions 
are not always conceptually clear (or even sound), they are often original and useful. One of the most 
 basic contributions is the notion of self the operations asso­ ciated with an object (its methods) can 
refer to the object as self, and invoke other operations by indirecting through self, with dynamic dispatch. 
A related contribution is the notion of subsurnptton: an object can be replaced (subsumed by) any object 
that supports the same or more operations; in typed languages, subsumption is systematized in rules for 
subclasszng and subtyptng. Object-oriented programming is not limited to object­ oriented languages. 
One can emulate objects in some proce­ dural languages, such as Scheme and C. So it is possible that, 
 despite its originality, object-oriented programming can be reduced to procedural programming. Such 
a reduction 1s not straightforward. Interesting difficulties arise at the level of types: the most natural 
definition of objects as records of functions (the self-applzcatzon semantzcs [Kam88]) does not validate 
the expected subtypings, so subsumption is blocked. Address: Digital Systems Research Center, 130 Lytton 
Avenue, Palo Alto, California 943o1, U.S.A. Supported by NSF Grant CC R-9303099 and a Rosenbaum Fel­ 
lowship. Address Isaac Newton Institute for Mathematical Sciences, 20 Clarkson Road, Cambridge, CB3 OEH, 
U.K. Permission to make digital/hard copies of all or part of this material for personal or classroom 
use is granted without fee provided that the copies are not made or distributed for profit or commercial 
advantage, the copy­right notice, the title of the publication and its date appear, and notice is given 
that cop yright is by permission of the ACM, Inc. To copy otherwise, to republish, to post on servers 
or to redistribute to lists, requires specific permission andlor fee. PQPL 96, St. Petersburg FLA USA 
@ 1996 ACM 0.s9791-769-3/95 /01 ..$3.50 In this paper we develop an interpretation of object­oriented 
programming in terms of procedural programming (specifically, in terms of a fairly standard J-calculus 
with subtyping). We show a translation of objects into records of functions, and a translation of object 
types into types built up from record types, existential types, and recursive types. These ingredients 
should not be surprising, but their combi­nation is new. The translation is faithful in that it respects 
operational semantics, typing rules, and subtyping rules; it yields a syntactic proof of soundness for 
those rules. In order to make this interpretation both manageable and precise, we develop it in the context 
of object calculi [AC94b], Object calculi are formalisms analogous to A­calculi, based on objects rather 
than on functions. Their only primitives are objects, method invocation, method up­date, and (for imperative 
calculi) cloning. Method update is the most unusual of these, but forms of method update do appear in 
several languages [Lie81, And92, Tai92, MGV92, MMPN93, ALBC+93) App93, Car95]. The primitives are quite 
expressive: they allow representations of both class­based and object-based notions, for example classes, 
sub­classes, protection, prototyping, and mode switching, When typed, object calculi include a subtyping 
relation and a sub­sumption rule. We believe that our interpretation of objects is com­pelling for several 
reasons. First, it makes precise the vague intuition that objects have something to do with abstract 
data types and re­cursive types. That intuition has been important in previous works that studied A-calculi 
with subtyping and used them to emulate objects to various extents (see the next section). The target 
calculus of our trans­lation is the result of those previous works. The translation is sufficiently complicated 
to confirm that objects provide a useful abstraction mdependent of procedural concepts. On the other 
hand, it 1s simple enough to serve as an explanation of objects in terms of well-understood constructs. 
Finally, the translation is not limited to one particular object calculus. With some modifications, it 
applies both to functional and imperative execution models; and it can be adapted to account for Self 
types and structural rules [AC95b], which are operationally sound but unsound in common denotational 
models In the next section we review some of the background, describing related works, and give an informal 
overview of our interpretation. Section 3 defines a first version of the translation precisely; Section 
4 gives an imperative transla­tion; Section 5 deals with additional type constructs. 2 Informal Review 
and Overview We first review a basic untyped object calculus [AC94b] since we use its notation in what 
follows, In this calcu­lus, an object [11 = ~(zl)bl, . . . . in = ~(zn)bn] is a collec­tion of methods 
~(zl)bl, . . . . ~(z~)b~ with respective names 11,. ... in; the method bodies are bl, . . , b~, and the 
vari­ableszl, ..., Z. denote self. The order of the methods does not matter. The only operations on objects 
are method invocation and method update. If o is the object [11 = g(zl)bl, . . . . 1~ = r(z~)b~], then 
the invocation of its method 1,, written o.1,, consists in replacing o for xi in bi; the method update 
o.1, + ~(z)b yields an object like o but where we have 1, = ~(z)b. For now, we take the update construct 
to be functional, that is, to create a new object. Fields (in­st ante variables) are easily expressible 
as methods that do not use their self parameters. This untyped calculus is the basis for a first-order 
calcu­lus with subtyping, called Obl<,. In Obl <, an object type [11 : B1, ..,, 1~ : B~] is the type 
of objects which have meth­ods 11, . . ., 1% that, when invoked, result in values of types i31, . . . 
. Bn respectively. A characteristic of object-oriented languages is that an object with more methods 
can be used wherever an object with fewer methods is expected. In Obl<,, this is supported through a 
subtyping relation <:. An object type with more methods is a subtype of an object type with fewer methods 
provided that the common methods have exactly the same result types; for example, [11 : B1, 12 : B2] 
<: [11, Bl] for any types B1 and Bz. The self-application semantics [Kam88] provides a sat­isfactory 
explanation of untyped objects as records of func­tions. Let us write {11 = al, . . . L = an} for the 
record with fields 11,. ... 1~ with al, , an as values; a ~1 for extracting the field 1 of record a; 
and a ~1 := b for updating the field 1 of record a to be b. In the self-application semantics, a method 
is a function of its self parameter; an object is a record of such functions; met hod invocation is field 
selection plus self­application; method update is record update: This interpretation respects the operational 
behavior of both method invocation and method update. Unfortunately, the self-application semantics does 
not extend to typed systems such as Obl <,. In particular, it does not validate the essential subtypings 
between object types. Following the self-application semantics, one would naturally interpret the object 
type A ~ [1, : B, =l ] as a recursive record type, the solution to the type equation: A = {1, : A-B, 
l n} where {1, : C, =l m} denotes the evident record type. Be­cause of the contravariant occurrences 
of the object type A, we do not obtain subtypings valid in Obl<, such as [11 : BI,12 : Bz]<:[JI : B,]. 
In part because of this difficulty, there have been several other interpret at ions of objects. Most 
of them were defined as ways of emulating objects in procedural settings, rather than as precise translations, 
so it is somewhat hard to give a full account of their scope. In short, many of them con­tributed interesting 
and useful techniques but they all suf­fer from limitations. The recursive-record semantics [Car88] validates 
the expected subtypings, but it does not model method update (or even field update); the generator seman­tics 
[CO089] deals with update, at the cost of separating objects from object generators. The existential 
interpreta­tion of [PT94, HP95] also validates the expected subtyp­ings, and models class-based constructs 
where methods and fields are rigidly separated and it is only the fields that can be updated; unfortunately, 
the translation of objects is type-directed, and rather elaborate. An imperative in­terrxetation (ESTZ951 
can solve the m oblems. of the self­application semantics with judicious side-effects; its main limitation 
is that it does not model the cloning construct of object-based imperative languages. Finally, some inter­pretations 
give up on subtyping altogether, and reduce it to coercion functions [AC94a, R6m94]; the coercion functions 
are cumbersome, destroy the flavor of the original programs, and preclude an explanation of object subtyping 
in terms of more primitive subt yping relations. At this point, a possible conclusion is that it is easy 
to understand the computational behavior of obiects. but that ./ their desired typing and subtyping 
properties make them fundamentally different from records and functions. It was this view that originally 
led to the formulation of object cal­culi. Our interpretation of objects, which we discuss next, sheds 
some new light on this matter. It does provide a rather complete account of objects in terms of records 
and functions. It applies both to class-based and object-based constructs, places no restrictions on 
method update, and val­idates the expected subtypings. On the other hand, because it is not straightforward, 
it does not remove the usefulness of object calculi as a setting for studying object-oriented concepts, 
In this paper we develop translations of several object calculi into ~-calculi. The translations are 
faithful in that they respect the operational semantics, typing rules, and subtyping rules of the object 
calculi. The first translation maps Obl <, into F< ,W, the polymorphic ~-calculus with subtyping and 
recursive types; we preview this translation next, explaining informally how it treats types. Consider 
a type A -[11 : B1, . . . . 1~ : B~]. Because of subsumption, an object o containing additional methods 
be­sides 11, . . . ,1. can be an element of A. If we think of the true type of o as the type listing 
all its methods, then the type A only partially reveals the true type of o; what is publicly visible 
are only the methods 11, . . . . 1,., We there­fore take the translation A* of an object type A to be 
a type abstraction with representation type the true type of the ob­ject. Using the notation 3( X<:C)B 
for a type abstraction with an interface B and an unknown representation type X that is a subtype of 
C, we define A* as a recursive type, with the following equation: A* = 3( X<: A*){1; : (X-B;) e n, self 
: X} (1) The subtyping assumption X< :A* for the representation type expresses that the true type is 
known to be a subtype Table 1: Operational Semantics of Oblz, and F< ~ If a-[1, =<(z, :A)b,{z, } l ], 
Obl<. (Eval Select) a.lj (Eval Update) al, + <(z : A )b (Eval Beta) (Eval Beta2) (Eval Record Select) 
F<+ (Eval Unfold) (Eval Unpack) open c as .Y<:A, where c = pack of the object type. The field 1~ 1 is 
the method 1, treated as a function of self. The field l~p(i provides the ability to update method 1, 
given a new method that is a function of self, it returns a new object. The field self is the object 
itself with all its methods (including the private ones); through self, the methods 11, . . . . in can 
access methods not listed in the interface. Each of the ingredients in this translation is necessary. 
In particular, the use of existential types in addition to re­ cursive types is essential for getting 
the desired subtypings. Similarly, it is essential to model method update via a field l~p l: if method 
update were modeled by an update of the field @ then this would leave the field se~ unaffected, so the 
operational semantics would be distorted. In the next section we detail this translation of Obl <.. In 
Section 4, we consider an imperative version of the trans­lation, which deals correctly with cloning 
but is in some ways simpler than the functional one thanks to side-effects. In Section 5, we show that 
the translation of Obl<. can be extended to account for richer object-type constructs with Self types 
and variance annotations. 3 Interpretation of an Object Calculus with Functional Upclate In this section, 
we describe the translation of the object cal­culus Obl< into the functional calculus F< P. In Sections 
3.1 and 3.2, we briefly describe the calculi Obl c and F< ~, and in Section 3.3, we detail the translation 
of Obl<. into F< ,W. The precise typing rules for the two calculi are given in Appendices A and B. 3.1 
An Object Calculus: Obl<, The types of Obl< are generated by the grammar: A,B ::= TOP I [1; :Bi =1 ] 
 where n ~ O. The type Top is the supertype of all types and [L : Bt 1 n ] is the type of objects with 
methods L returning results of type B,. The terms of the calculus are similar to those of the untyped 
calculus described in Section 2 except that g-bound variables have type annotations: a,b ::= x I[1,= 
<(z, :A)b, ln] [a.1 Ia.1 -+ <(z :A)b j E1. ..n + b]{.} + [1, = <(z: A)b, 1, = ~(x, : A)bi ~{ }-{ }] 
 (J(r : A)b{z})(a) -+ b{a} (A(X<:A)b{X})(A ) w b{ A } {1, = b, e } ~ 1, + bj forj~l. ..n unfold(fold(A, 
a)) + a z :B{X} in d{X, z} :D -+ cl{C, b{C}} X<:A = C with b{X} : I? {X} A subset of the terms generated 
by this grammar are iden­ tified as well-typed terms by a set of typing rules described in Appendix A. 
The rules are used to derive judgments of the form E k 3, where Y is an assertion and E is an en­ vironment 
describing assumptions about the free variables in Y. The assertion o means that E is a well-formed en­ 
vironment, A means that A is a well-formed type, A< :B means that A is a subtype of B, and a : A means 
that a is a well-formed term of type A. An important rule, (Sub Object), states that A is a subtype of 
A if A has all the method names given in A and moreover the result types of these methods are exactly 
the same in A and A (so object types are invariant in their component types). The operational semantics 
is defined via a reduction sys­tem; it is free of side-effects. The primitive redexes given in Table 
1 correspond to method invocation and method up­date; we write b{z} to distinguish a variable z that 
may oc­cur free in b, and b{a} for the result of replacing z with a in b once z is clear from context. 
The one-step reduction relation --+0 is the congruence closure of * (t. e., we can reduce any subterm 
that is a redex); the many-step reduction relation ~o is the reflexive, transitive closure of +0. We 
define results to be terms of the form [L = ~(m, : A)b, =l ]; we say that a closed term a converges, 
and write a .1,10,if there exists a result v such that a ++ ~ u. 3.2 A Functional Calculus: F<:p The 
system F<,, is the standard extension of System F with recursive types and subtyping. While records and 
existen­tially quantified types are encodable in terms of the other constructs of F< ,P, we present them 
as primitive for sim­plicity, System F<:P is defined in detail in Appendix B; in this section, we describe 
informally some of its constructs. Records are collections of fields with associated values; the only 
operation on records is field extraction (written T 1). The basic types are function types and record 
types. A record type {1, : B, e } lists the field names and the types of the values associated with 
them. Record types are covariant in their component types. We use the recursive type p(X)B{X} to denote 
a solution to the type equation X = B{X} where X could occur free in B. The isomor­phism between ~(X)B{X} 
and its unfolding B{p(X)B{X}} is given by the constructs fold and unfold: if a is of type p(X)13{X} then 
unfold(a) is of the unfolded type, and if b is of the unfolded type then fold(p(X)B{X}, a) is of type 
 p(x)l?{x}. The existentially quantified type 3( X<: A)B{X} is the type of a term a (roughly) if there 
exists a type C that is a subtype of A for which a is a term of type B{C }. More formally, given a term 
a of type B{C }, the term pack X <: A= Cwitha: B{X} has type 3( X<: A) B{ X}. What we achieve by packing 
a in a term of type 3(X< :A)B{X} is the hiding of information about the type C at which a realizes 3( 
X<: A) B{ X}. (Recall that data abstractions have existential types [MP88]. ) Given a term c of type 
3(X< :A)B{X}, we can access its inside by writing the term open c as X<:A, y : 13{X} in d : D, where 
X stands for the representation type and y for the inside . We can use X and y in d but the typing rules 
ensure that d can­not assume any information about X other than that it is a subtype of A, and the type 
D specified for d must not depend on the representation type X, i. e., X cannot occur free in D. Table 
1 specifies reduction for F< W. The one-step reduc­tion relation f is the congruence closure of w, and 
f is the reflexive, transitive closure of ---+ ~, As for Obl <,, we distinguish certain terms as results; 
the set of results, de­fined in Appendix B, includes A-abstractions and records. We say that a closed 
term o. converges, and write a .lj.f, if there exists a result v such that a . Using recursive types, 
we can easfl~ define a (call-by­name) fixed point operator. It is also routine to define letrec; we write 
letrec ~(zl : Al) ~. . (an : An) : B = b in c to denote a recursive definition of a function f of type 
Al-+ ~. +A~+B, used in the term c. 3.3 Translation We are now ready to describe the translation of Obl<. 
into F< ,P. The translation is in two parts. The first part is a translation of types which maps every 
type A of Obl <, to a type A* of F< W and is defined by induction on the structure of types in Obl<,. 
Top = Top [Jt , B, t~l...n ] * = p(Y)3(x<:Y) {1; , (X+ljy) =1 ~, l:P<~: (4y+B; )+x tel...%, self : X} 
 The interpretation of object types given here is the same as that of Section 2, but here we use a p 
rather than an equation (Equation (1) ) for defining the existential type re­cursively. Note that in 
the translation of the object type A=[li:Bi E ], the field 1/ 6 makes the type A* covariant in B; and 
the field 1~] ~ makes it contravariant in B:. Our interpretation thus explains the invariance of object 
types in their component types as arising from a covariance due to invocation and a contravariance due 
to update. The key consequence of our translation of object types is that it gives the expected subtypings. 
More formally, we use the translation of types to define a mapping E* for environments, and establish 
Theorem 3.1 which states that well-formed types of Obl <, get mapped to well-formed types of F<, P and 
that the subtyping judgments of Oblz, are preserved by the translation. Theorem 3.1 1. If E 1-0 is derwable 
in Obl<,, then E* R o as dertvable in F<.P. 2. If E k A w der~vable m Obl<,, then E* t A* as deriv­able 
in F<,W. 3. IfE &#38; A<:B is derivable in Obl<,, then E* 1-A*<:B*  .. is derivable in F<,P. The second 
part of the translation is for terms. To make the main ideas in the translation of terms transpar­ent, 
we first informally explain the results of the translation as untyped J-terms, omitting the type annotations 
associ­ated with using recursive and existential types; we make the details precise later. Informally, 
every term a of Obl<, is mapped to its meaning, ((a)), which is a J-term. Apart from the typing restrictions 
imposed by the recursive and existen­tial types, the translation of an object type is a record type with 
two fields l~el and l~r (~ for each method 1, and a field self. The field l~ei is the method 1, treated 
as a function of self, and the field l~ud returns a new object when applied to a new method treated as 
a function of self. With this understanding, the translations of method invocation and update are straightforward. 
((a.lj)) = ((a)) ~1~ (((a)) ~seZf) ((a.lj -+ <(z) b)) = ((a)) ~1~ (J(z) ((b))) The most delicate part 
of the translation of terms is that for objects. This may be expected since we did not do any­thing computationally 
interesting so far we just delegated responsibility to the fields l~el and l~P ~ provided by the in­terface 
of objects. To understand the translation of objects, it is instructive to consider first an incorrect 
attempt, which will also explain the presence of the field 1~~. Suppose we chose not to have the field 
l~r [l in the record interface for objects and instead modeled method update by an update of the field 
l~ t, i.e., for an object o -[1, = ~(z,)b, ~l ], we would have that ((0.i, + s(z) b)) = ((0)) t; := A(z)((b)) 
(wrong) Invoking a method lj of o would still be interpreted as ex­tracting the l~ i field and applying 
it to the field self. Since the object o is a record with field 1~ ~ equal to the method b, treated as 
a function of its self parameter, and since method invocation is modeled by application to the field 
self, the field self then has to be the object itself. We arrive at the following recursive definition 
for ((o)): ((o)) = {1~ = J(z,)((b,)) e n, self= ((o))} (wrong) The problem with this (functional) interpretation 
of objects is that when a method gets updated the object changes but since we only update the field 13 
of the record, this change is not reflected in the field self and consequently we lose the dynamic binding 
of self. Thus, if some other method uses lJ in its body, then its invocation modeled by application Table 
2: Translation of Obl <, into F< ~ ((z)).kj = z (([Lt= r(z, : A)b, ~=1 n ]))E = l;:ly(yte (f, : A*-B~) 
(f. : A*_ B;) : A* = pack X<:A* = A* with {1~ ~ = f, =l , l; [l = /\(g : A*~l?:) create (fl) . . (f, 
]) (g) (f,+l) ., (fn) =l , Sdf = CTWak (fl) (fn)} : CA{ X}) in create (~(zl : A*)((bl))E,~l.A) (J($n 
: A*)((b~))E)~~.A) where A = [1, : B, =l ] ((a.1))~ = open unfold(((a))~) as X<: L1,B, z : {1 : (X-+B*), 
self : X} in (z l l)(z self) : b where B = (E, a)l ((at ~ ,(z : A)b))E = open unfold(((a))~) as X<.A 
, y : CA{X} in (y l P~)(~(z : X)((b)) ~,ZA) : A* to the field set~ would not see the result of the update. 
So, an important idea in the context of our translation is that method update is not modeled as record 
update. The second idea to glean from this flawed attempt is that defining the object itself recursively 
would not reflect the computational behavior of objects accurately. Intuitively, update has no chance 
of working once the recursion freezes self to be the state of the object at the time of creation, t. 
e., if recursion is used too soon. (Those familiar with the recursive-record interpretation [Car88] may 
note that the source of its prob­lems in modeling method update can also be traced to the early use of 
recursion. ) The solution is to define not the object itself recursively, but the dependence of the object 
on its methods recursively. That is, we define a function create that when applied to n methods, returns 
an object with those n methods and it is the definition of create that is recursive. An object can then 
be defined by the application of create to its methods, as follows: We now define the translation notations, 
more precisely. We use Notation: 1.For any object type A ~ [L F< P type CA {X} with free of terms with 
typing the following notation. : B, El m], we define variable X: an­the Cd{.Y} ~ {1: ] : (X-+ l! Pd : 
(X-+ s elf : X} B:) =l B;)_X , 61 , 2. For any method name 1 and Obl <. type B, we define the F<,W 
type L1,B by: Lt,B ~ w(Y)3(X<:Y){l ~ : (X~B*), self : X} 3. SupDose. for anv term a and environment 
E. that E k a: ~. .,l:B ,. ~.] is provable in Obl<,. Then by the minimum-types property of Obl< [AC94b] 
and by the invariance of object types, we have that if E > a : [.,.,1 : B ,...] then B ~ B . So we let 
@,a)l be the unique type Bsuchthat E \ a : [...,1:B, ...] is provable if it exists, and be undefined 
otherwise,  For any term a in Obl <. and environment E, Table 2 defines a term ((a))E of F< ,W. The 
translation proceeds by induction on the structure of a. In particular, the translation of a judgement 
E \ a : A does not depend on its derivation in Ob 1< , and consequently, we can avoid coherence issues 
in our proofs. The inclusion of the environment E in defining the meaning of a term arises for purely 
technical reasons. It is to give the necessary type annotations in the translation of method invocation, 
If we had omitted type annotations from the target calculus or put more type information in the syntax 
of the term for method invocation, we could have defined the meaning of the term without any dependence 
on the environment. Some remarks regarding the translation of terms are in order. The translation of 
method invocation explains the presence of the field self in the translation of object types: using x 
instead of x self would not lead to a typable re­ sult. In the translation of method update, the use 
of J(z : X) ((b))~,a.A Is motivated by the reduction rule (Eval Up­ date) which asserts: ([L = {(z. 
: A)bt 1 +ti].l, @ {(z: A )b) --i [lj=<(z A)b,... ] with A instead of A in the type annotation of x 
in the updated object. The use of J(z : A*) ((b)) E,.. A instead of J(z : X) ((b)) ~,c .,l would be acceptable 
from the point of view of typing but would not fit with the rule (Eval Update).  400 The following theorem 
states that our translation pre­serves typing judgments and the computational behavior of terms. Theorem 
3.2 1. If E k a :A M derwable in Obl<: then E* t ((a))E : A* is derivable in F<,W. 2. If E 1-a : A is 
derivable in Obl<, and a Ob then ((a)) ~-~((b))E  The translation can serve as a basis for validating 
rea­soning principles for objects from reasoning principles for functions. In particular, we can prove 
that two objects are equivalent by showing that their translations are equivalent. We have been able 
to check a few non-trivial object equiv­alences in this manner. This proof method is not complete, because 
the translation is not fully abstract; however, it is sound, because the translation is computationally 
adequate, as we show next. Let a and b be two closed Obl<, terms of type A. We say that a and b are operationally 
equivalent at type A, and write a =0 b : A, if we have that C[a] &#38; if and only if C[b] &#38; for 
any context c[.] which is well-typed assuming the hole [,] is of type A, We define the relation of opera­tional 
equivalence similarly for F< ,P, and write a =~ b : A. The first part of the following theorem states 
that the trans­lation is comput ationally adequate; the second part, which is a corollary of the first, 
states that if two Obl <, terms have operationally equivalent translations then they are op­erationally 
equivalent. Theorem 3.3 Assume that Ot-a : A and 0 t-b : A are de­rivable m Obl<,. Then: 1. a &#38; Zf 
and only zf ((a)). d,l~. 2. If ((a))O -f ((b)). : A* then a so b : A.  In summary, there are three 
key ideas in the translation. The first is that interpreting an object type as a recursive type abstraction 
gives the desired subtypings. The second is to model method invocation not as application to the object 
itself, but rather to a field self which holds the current value of the object. And finally, by splitting 
each method into a field for invocation and a field for update and by using recursion in a function that 
creates objects, we obtain dynamic binding. 4 Interpretation of an Imperative Object Calculus In this 
section, we show how the ideas embodied in the trans­lation described in Section 3 are also useful to 
the interpre­tation of imperative object-oriented constructs. Our formal setting is the imperative object 
calculus of [AC95a]. 4.1 An Imperative Object Calculus The terms of the untyped imperative object calculus 
are generated by the grammar: As the previous calculus, this imperative calculus has terms corresponding 
to objects, method invocation, and method update. However, the operational semantics is imperative in 
that method names denote locations where the closures of the corresponding methods are stored and method 
update is done in place. Thus, method update has a side-effect of changing the object rather than returning 
a new object. In addition, we have two new primitives: (1) clone(a) returns a shallow copy of the object 
a, i. e., an object with the same method suite as a stored in fresh memory locations; (2) the let construct 
evaluates a term, binds it to a variable, and then evaluates a second term with that variable in scope. 
Sequential evaluation (;) and eagerly evaluated fields can be defined from let. The type system is given 
in Appendix C; it is an extension of that of Obl<,.  4.2 Translation We translate the imperative object 
calculus into an impera­tive version of F< ,Y, which here we describe informally. The syntax of this 
imperative version extends that of F< ,W wit h field update for records (written a. 1 := b) and with 
an unini­tialized value of each type (written nii(l?)). Because of the presence of field update, record 
types must be invariant in their components. The operational semantics of the impera­tive version is 
significantly different from that of F< ~ in two respects: (1) The field names in records now denote 
memory locations and field update is done in place. It is therefore more accurate to think of a record 
as a collection of mem­ory locations rather than as a collection of values. (2) In the mesence of side-effects. 
one needs to fix an evaluation order: we assume call-by-value evaluation for the target calculus. Then 
let a = a in b can be defined as (J(z) b)(a), and a; b can be defined as (J(.z)b)(a) for some z not free 
in b. The main departure from the translation described in Section 3.3 is that. in the imperative settirm. 
we do not sdit a method into two distinct &#38;elds correspo~ding to met~od invocation and method update. 
Recall that the essential rea­son for the split in the functional case was that the field self would 
not detect the change to a method if method update was modeled by record update of the field corresponding 
to the method. However. in the rmesence of imperative. features . in the target calculus, we can use 
the field self to store a pointer to the record itself (that is the meaning of the ob­ject), thus ensuring 
that any changes to the other fields of the record are reflected in self. The translation of types uses 
the ideas described in Sec­tion 2. In addition, we include a cloning function in the public interface 
of an object. For types we therefore have: Top = Top [1, : B, e n]* = w(Y)3(X<:Y) {li , (X+B~) e , clone 
: {}+X, self : X} The distinction between the fields self and clone is that the former contains a pointer 
to the record itself while the latter returns a shallow copy of the record (under a dummy ab­straction). 
We need to distinguish the two since, in method invocation, one must apply the method to the object rather 
than to a shallow copy of the object. As before, the use of a recursive type abstraction yields the desired 
subt ypings. 401 Table 3: Translation of the Imperative Object Calculus (Sketch) ((z)) = z (([1, = r(cc,)b, 
 ~ n ])) = letrec create (f,) ,.. (fn) = let z = {L = f, =l , clone = ml, self = nd] in z ckme := 
J(z)create (2 11) (.Z . L); z . self := z; z . self in create (J(zl)((bl)) . (J(z~)((b~))) ((a.lj)) = 
let z = ((a)) in (Z 1,)(z self) ((al e ~(z) b)) = let y = ((u)) in y 1, := ~(~)((b)) ((clone(a))) = (((a)) 
ckme)({}) ((let z = a in b)) = let z = ((a)) in ((b)) We give the precise definition of the translation 
of terms below. For now, we refer to Table 3 which states the transla­tion omitting type annotations 
in terms. In the translation of an object, we declare a skeletal record structure z where the fields 
clone and self are uninitialized, and then update these fields so that they can point circularly to the 
record structure. Note that we retained the idea of defining a create function recursively rather than 
the object itself recursively. This is necessary for cloning to return the correct copy of the object 
after updates; if we had defined the object recur­sively, then clone would have been frozen to return 
a shallow copy of the state of the object at the time of its creation. (Cf. the semantics of [ESTZ95], 
which does not accommo­date cloning.) In our translation, the field clone is defined to be an abstraction 
so that the application of create termi­nates under call-by-value evaluation. Method invocation is interpreted 
in the same way as in the functional case while method update is interpreted as record update. Cloning 
is interpreted as an application of the field clone to a dummy argument (the empty record). The precise 
definition of the translation of terms, in Ta­ ble 4, relies on the following notation: Notation: Cyp{x} 
~ {1, : (X+ B:) =  n, clone : {}+X, self : X} 2. For any method name 1 and type B, we let: L/~ ~ p(Y)3(X<:Y){l 
: (X+B*), self : X} 3. The type Mzn Z y (E, a) 1s the minimum type of a in environment E, z e., the 
type A such that E + a : A is provable if and only if E t-A<: A ; it is undefined if a is not typable 
in E. The type (E, a)l is as in Section  3.3. We can prove a soundness theorem for this translation. 
We omit it from this paper since its statement requires lengthy definitions detailing and relating the 
operational se­mantics of the imperative calculi.  5 Extensions to Richer Object Types In this section, 
we consider richer typing disciplines for ob­jects: variance annotations, Self types, and structural 
rules (all described in [AC95b]); we show how our translation ex­tends to account for them. In Section 
5.1, we begin by giving an overview of these typing disciplines and an informal de­scription of our interpretation 
for them. In Section 5.2, we describe an enriched object calculus more precisely. Finally, in Section 
5.3, we give a translation of this object calculus. 5.1 Preview  Variance Annotations Variance annotations 
are an extension to object types; they are symbols (+, , 0 ) attached to method names in object types. 
The annotation 1+ indicates that method 1 is only invocable, 1 indicates it is only updatable, and 1° 
indicates that it is both. These annotations allow finer protection on the access of methods, and give 
desirable subtyping prop­erties. Object types are covariant in the types of their + components, contravariant 
in the types of their compo­nents, and invariant in the types of their 0 components. Variance annotations 
naturally fit in the framework of our interpretation. Namely, we can translate object types to the same 
recursive type abstractions with both record components 1 [, l p~ for a method 1°; only the 1 I compo­nent 
for 1+; an d only the 1 ~~ component for 1-.  Self Types The Self-type construct yields flexible typing 
for objects with methods that return objects of the type of self. Ex­ tending the notation for object 
types, we write obj(x)[h : Bt{x} G ] where Obj binds a type variable X that can occur covari­ antly 
in the result types B,; intuitively the variable X stands for the type of self, called the Self type. 
A longer object type is still a subtype of a shorter one: Obj (X)[L B. l n+-] <: Obj(X)[L : B, 1 m] Recall 
that in the translation of simple object types given by Equation 1 we viewed the representation type 
as the true Table 4: Translation of the Imperative Object Calculus ((~))E = ~ (([~a = ((z, , A)bi ~el...n 
]))~ = letrec create (jI : A*--+Bf) . . . (jn : A*-+B~) : A* = let z : C~p{A*} = {1, = f, l n, clone 
= nzl({}-iA*), self in ,2 ~ clone := J(z : {}) create (z ~11) . . (z . in); z . self := fold(A*, pack 
X<: A* = A* with z : C~~P{X}); z . self in create (~(zl : A*)((bl))~,ml,A) . . . (~(z~ : A*)((b~))E,~w,A) 
where A s [1, : B, eln] = nil(A*)} ((a.1))~ = open unfoid(((a))~) in (z . 1) (z self) where B = (E, a)l 
as : B* X<:L&#38;,z : {1 : (X+B*), self : X} ((a./ + <(a: A)b))~ = open unfold(((a))~) in fold(A*, pack 
X <: with y . lj as X<:A*, y : Cr{X} A* = X := )(z : X)((b))~,r.~ : C~~z {X }) : A* ((clone(a)))~ = open 
unfold(((a))~) in (x clone)({}) where A = A4in7 y(E, as X<: a) A*, z : CP{X} ((let z : A =a in b))~ = 
let 2: A* = ((a))E in ((b)) E,.,A type of an object. We take this true type to be the Self type; therefore, 
for A -Obj(X)[L : B,{X} eln], we let: A = 3( X<: A*){1;C1 : X-+ B;{X} l , l;P 1 : (X+l?; {x})+x ~~1~, 
self : X} With this straightforward extension, our interpretation ac­counts for Self types. Structural 
Rules While the subtyping rules for object types assert that a longer object type is a subtype of a shorter 
object type, structural rules arise as consequence of the stronger struc­tural assumption that the only 
subtypes of an object type are longer object types. An example of such a structural rule, using the simple 
object types of Obl<,, is the follow­ing modification of the rule (Val Update) of Table 8: (Struct Val 
Update) For A -[1,:B, elm] EEC<:A Eka:C E,x:Ckb:B, Et-a.lj~~(x:C)b:C  In our interpretation, structural 
assumptions on object types are reflected as structural assumptions on recursive types. Specifically, 
structural rules for object types are vali­dated if we strengthen the target calculus with a structural 
rule for recursive types: (Struct VaJ Unfold) E t-C<: V(X)B{X} E E a :C E > unfold(a) : B{C} The rule 
(Struct Val Unfold) can be seen as a consequence of assuming that any subtype of a recursive type arises 
through the reflexivity rule ((Sub Refl) of Table 7) or the subtyping rule for recursive types ((Sub 
Ret) of Table 9). For example, suppose that E F C<:p(X).B{X} because of (Sub Ret). Then C is of the form 
K(X) B {X} and if E k a : C then E k unfold(a) : B {C}. Further, we have that E, Y <: Top, X<:Y k B {X}<:B{Y}. 
In particular, since E t-C< :C, using C for both X and Y we get that E t-B {C} <:B{C} and using subsumption 
we get the con­sequent of the rule (Struct Val Unfold). We can see informally how the rule (Struct Val 
Update) is validated thanks to (Struct Val Unfold). Assume that E 1-C*<:A* and E K ((a)) : C*. Using 
the definition of A* as a recursive type and applying (Struct Val Unfold), we can conclude that: E + 
unfold(((a))) : 3( X<: C*){. ,l~i : (.. )+X,...} I,,><i The result of an update is of type C* , since 
lJ returns a result of type X and X<: C*. In contrast, with the weaker, non-structural rule (Val Unfold) 
of F< ,P (Table 9), we can conclude only that E t-unfold(((a))) : 3( X<: A*){. . .} and the result of 
the update has to be given the weaker type A*. 5.2 An Enriched Object Calculus The calculus Ob ~ is an 
extension of Obl <, with variance annotations, Self types, and structural rules. Like the se­mantics 
of Obl<,, the semantics of Ob~ is free of side­effects. The types of Ob~ are generated by the grammar: 
A,B ::= X I Top I Obj(X)[l; vi : Bi{X} l n] where v, 6 {+, , }. As described in Section 5.1, Obj binds 
the Self type, and the variance annotation v, specifies the operations permissible on method 1,. Table 
5: Operational Semantics of Ob~ If a - obj(X =A)[L =<(z, : X) b,{ X,z, } =l ], j = I...n (Eval Select) 
all - bj{A, a} (Eval Update) al, + (Y<: A , y : Y)<(z : Y)b{Y, y} N obj(X = A)[t, = <(z : X)b{X, a}, 
L = <(Z, : x) f)t + ~}-{ }] Because of Self types, the term syntax of Ob~ is slightly different from 
that of Obl<.: An object has the form obj(X = A)[l. = <(z, : X)b, ~lm] with X standing for the Self type. 
Method update is written a.1 s (Y<:A, y : Y)<(z : Y)b where A is a known type for a, Y denotes the Self 
type of o,, ~ is bound to the object being updated (a), and z is the usual self parameter in method b, 
The parameter y is useful because it is given type Y while a has the weaker type A, The typing rules 
for Ob~ are structural. They appear in Appendix D. The operational semantics is defined via a reduction 
sys­tem whose redexes are given in Table 5. In the rule for method update, note that the object a gets 
substituted for the parameter v. Apart from this, the only difference from the ~orrespond{ng riles of 
Obl < is the type propagation the actual type of self gets substituted for the formal type parameter 
X standing for the Self type. We denote the many-step reduction relation for Ob~ by ., 5.3 Translation 
We translate Ob~ into an extension F~!~ of F< P; this extension has the same operational semantics as 
F< ~ but includes a structural rule, namely the rule (Struct Val Un­fold) of Section 5.1. The translation 
of types combines the ideas for variance annotations and for Self types described in Section 5.1   
x =x TOD* = Tov p(Y)3(x<:Y){(Lv, : Bt{.Y})t ~l n ~ where the fields (l, v, : B;{X} )t are defined by 
case analysis on the variance annotation v, as follows: (i: : B.{X})t = (l: : B,{ X})t, (l~ : B,{X})t 
~ We define the translation of environments as in Section 3.3, with the additional clause (E, X<: A)* 
= E*, X<: A*, The following theorem states that well-formed environ­ments are mapp~d to well-formed environments, 
that well­formed types are mapped to well-formed types, and that the translation preserves subtyping 
judgments, Theorem 5.1 1. IfE \ o M dertvable an Ob~~, then E* k o M derivable in F< ~, and a forttort 
xn F~v. 2. If E + A w derwable in Ob ~, then E* + A* M dertv­able tn I?<.P, and a forttorz in l?~ p. 
 3. If E E A<:B M dertvable an Ob~, then E* t A*<:B* is derivable tn F< ~, and a fortiori in lj~ p. 
 We give the translation of terms in Table 6, using the following not ation: Notation: 1. For A -Obj 
(X)[l, vz : Bt{X}], we define: Cfi {x} : {(ttz/t : B.{x})f =1 ~, self : X} 2. For a type A, environment 
E, and method name 1, we define the Ob~~ type (A, E)l as follows. If A ­Obj(X)[. . . ,lv : B{X},. . 
.], then (A, E)i is B{ X}. If A ~ X (a type variable) and E ~ E , X<: A , E , then (A, E)l is (A , E 
)t, In all other cases (e.g., for A E Top), (A, E)l is undefined, 3. As in Section 4.2, the type Min 
Ty(E, a) is the mini­mum type of a in environment E, (We can prove that such a minimum type exists in 
Ob~T , )  If we omit type annotations then the translation of terms is basically the same as that described 
for Obl < The main novelty of the translation is that it shows that we can attach suitable type annotations 
to the untyped terms described in Section 3.3 so that well-typed terms of Ob~T get mapped to well-typed 
terms of F~!A. The following theorem states that the translation preserves typing judgments and com­ 
putational behavior. Theorem 5.2 1. IfE \ a : A ZS derzvable zn Ob~~ then E* K ((o,))~ : A* M derivable 
m F~W, 2. If E k a : A M dertvable an Ob ~ and a_O. b then ((a)).  f((b))E 404 Table 6: Translation 
of Ob~ into F~P ((Z))E = x ((obj(X = A)[l; = ~(q : X)b;{X} 6 ]))E = letrec create (jl : A*-B~{A*}) 
. . . (f. : A*~B~{A }) : A* = fold (A*, pack X<:A* = A* ~l~h {1:,1 = f, ,61.. ~, Z;pd = A(g : A*~B~{A*}) 
create (fl) . . ~ (.ft-1) (9) (ft+l) self = create (fl) (fn)} : C~{.Y}) in create (A(zl : A*)((bl{A}))~,Zl 
A) . . (~(a~ : A*)((b~. where A -Obj(X)[l, v, : B,{X} cl n] ((CZ.l))E = open UnfOld(((a))E) as .Y<:A*, 
z : {1 ( : (X--+ B*{X}), self : X} in (z 1 ~)(z . se~) : B*{ A*} where A = Mzn Ty(E, G), I?{X} = (A, 
E)l ((cz.1+ (Y<:A, y : Y)<(x : Y)b))~ = open unfold(((a))~) as X<: A*, z: {lUP(l : (x~B*{X})-X, self 
: X} where B = (A, E)l Conclusions We have presented a new interpretation of objects and ob­ject types 
that preserves subt yping and behavior; its basic idea works for both functional and imperative semantics. 
Our interpretation is more general than previous solutions in that it handles object-based constructs 
such as cloning and method update, as well as the common class-based con­structs. Moreover, it is simpler 
than other proposals in the sense of being syntax-directed. It is the first interpretation of this kind. 
Our interpretation offers insights into the nature of ob­jects. It describes, in principle, a type-safe 
way of coding objects in procedural languages. However, as is the case even with more limited interpretations, 
it cannot be used in actual programming practice because of its pragmatic com­plexity. This fact confirms 
the commonly held belief that object-oriented languages differ significantly from procedu­ral languages 
in practical expressive power. References<RefA> [AC94a] M. Abadi and Luca Cardelli A semantics of object types. 
In Proceedings of the Ninth Annual Sympo ­smm on Logzc m Computer Science, pages 332 341, July 1994. 
[AC94b] M. Abadi and Luca Cardelli. A theory of primitive objects: Untyped and first-order systems. In 
The­oTetzcal Aspects of ComputeT Software, pages 296 320. Springer-Verlag, April 1994. [AC95a] M. Abadi 
and L. Cardelh. An imperatwe object cal­culus: Basic typing and soundness. In SIPL 95 Pvoceedzngs of 
the Second ACM SIGPLAN Wovk ­shop on State in Programming Languages. Tech­nical Report UIUCDCS-R-95-1900, 
Department of Computer Science, University of Illinois at Urbana-Champaign, January 1995. [AC95b] Martin 
Abadi and Luca Cardelli. An imperative ob-Ject calculus. In P D Mosses, M Nielsen, and MI. Schwartzbach, 
editors, TAPSOFT 95: Theory and Practice of Software Development, pages 471-485. Springer-Verlag LNCS 
915, May 1995 [ALBC+93] O. Agesen, C. Chambers L. Bak, B.W. Chang, U. Hoizle, J. Maloney, R.B. Smith, 
D. Ungar, an: M, Wolczko. The Self 3.0 programmer s ;eference manual. Sun Microsystems, 1993, [And92] 
B. Andersen. Ellie: a general, fine-grained, first­class, object-based language. Journal of Object Or­iented 
Programming, 5(2),35 42, 1992. [App93] Apple Computer, Inc. Apple, The NewtonScvipt Programming Language, 
1993. [Car88] L. Cardelli. A semantics of multiple inheritance. In­formation and Computation, 76:138-164, 
1988, Spe­cial issue devoted to Symp. on Semantics of Data Types, Sophia-Antipolis (France), 1984, [Car95] 
L. Cardelh. A language with distributed scope. In Conference Record of the Twenty-Second An­nual ACM 
Symposium on Principles of Progr-am­ming Languages, 1995. [CO089] W.R. Cook. A Denotational Semantics 
of Inhe?+ tance. PhD thesis, Brown Umversity, 1989. [ESTZ95] J. Eifrig, S. Smith, V. Trifonov, and A. 
Zwarico. An interpretation of typed 00P in a language with state Lzsp and Symbolic Computation, 1995. 
To appear. [HP95] Martin Hofmann and Benjamin Pierce A unify­ing type-theoretic framework for objects 
Journal of Functional F wgrammtng, 1995. To appear. Previous version appeared in the Symposium on Theoretical 
Aspects of Computer Science, 1994 (pages 251-262). [Kam88] S. Kamin. Inheritance in Smalltalk-80: a denota­tional 
definition. In ACM Symp. Pnnczples of Pro­gramming Languages, pages 80 87, 1988. [Lie81] H Lieberman. 
A preview of Actl. Technical Report AI Memo No 625, MIT, 1981. [MGV92] B.A Myers, D.A Giuse, and B. Vander 
Zanden. Declarative programming in a prototype-instance 405 system: object-oriented programming without 
writ­ing methods. In Proc. 00 PS.LA 92, pages 184 200, 1992. [MMPN93] O.L. Madsen, B. Moller-Pedersen, 
and K, Nygaard. Ob~ect-ortented programming in the Beta program­ming language Addison-Wesley, 1993 [MP88] 
J.C. Mitchell and G.D. Plotkm. Abstract types have existential types, ACM Trans. on Programming Languages 
and Systems, 10(3):470 502, 1988. Pre­liminary version appeared in Proc. 12th ACM Symp. on Principles 
of Programmmg Languages, 1985. [PT94] Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations 
for object-oriented pro­gramming. Journal of Functional Programming, 4(2):207-248, 1994. [R6m94] D. R6my. 
Programming Objects with ML-ART, an extension to ML with Abstract and Record types. In Theoretical Aspects 
of Computer SoftwaTe Springer-Verlag, April 1994. [Tai92] A. Taivalsaari. Kevo, a prototype-based object­oriented 
language based on concatenation and mod­ule operations. Technical Report LACIR 92-02, Uni­versity of 
Victoria, 1992. </RefA>Appendix In this appendix we summarize several calculi, giving both grammars and rules. 
We often use assertions of the form EFZ Vi~l . . . n to indicate n hypotheses; by convention, this means 
E 1-0 when n = O. A The Obl<. Calculus The calculus Obl<. consists of the rules given in Tables 7 and 
8. It has the following syntax: Environments E::= OIE, Z:A Types A,B ::= Top I [Zi : Bt El ] Variables 
X>Y Terms a,b ::= z I [L = s(2, :A)b, l ] I a.1 \ a.1 + <(z :A)b Results v ::= [1, = <(at : A)b; e ] 
 El The F<:P Calculus The calculus F<.P consists of the rules given in Tables 7 and 9. It has the following 
syntax: Environments E ::= OIE, X: AI E, X<:A Type Variables X, Y Types A,B, C ::= X I Top \ A--+B I 
{1, : B, e m} [ p(X)A I V(X<:A)B \ 3( X<:A)B Variables X)Y Terms a,b,c, d ::= x I}(z :A)b Ia(b) I{1, 
= b, l n} Ia 1 I fold(A, b) I unfold(a) I A(X<:A)b I b(A) [ pack X<:A = C with b : B{X} lopencas X<: 
A,x:Bind:D Results ::= A(z : A)b I {li = bi 61 } v I fold(A, v) I J(X<:A)b I pack X<:A = C with b : B{X} 
Other definitions of the set of results could be adopted. The one given here is convenient for our adequacy 
theorem; it is however not particularly compelling. Fortunately our techniques are not too sensitive 
to changes in the definition of the set of results. C The Imperative Variant of Obl<, The typed imperative 
object calculus contains all the rules of Obl<. (described in Appendix A) and contains the typ­ing rules 
given in Table 10 for its additional terms. As for Obl <., we can prove a minimum-types property for 
the typed imperative calculus. (This is a convenient departure from the original calculus of [AC95a]: 
the terms described here contain more type information. ) The syntax is: Environments E::= OIE, Z:A Types 
A,B ::= TOp I [t, : B, =ln] Variables X)Y Terms a,b ::= z \ [~i = S(Z, :A)b, l ] Ia.1 Ia.1 + <(z :A)b 
I clone(a) lletc:A=ainb D The Ob$ Calculus The calculus Ob~ consists of the rules given in Table 7, 
the rules (Env X), (Type X), (Sub X) given in Table 9, and the rules of Table 11. It has the following 
syntax: Environments E ::= O\ E, X: AI E, X<:A Type Variables X, Y Types A,B ::= X I Top I Obj(X)[l,v, 
: B, ln] with v, ~ {+, ,0} Variables X>Y Terms a,b ::= z I obj(X=A)[l, =q(z, :X)b, sl n] 1 U,.1 I al&#38; 
(Y<A,y : Y)<(z : Y)b 406 Table 7: Common Typing Rules Environments Subtyping EkA Ek A<:B El- B<:C (Sub 
Refl) EkA<:A (Sub Trans) EI-A<:C Eka:A EkA<:B (Val Subsmp) Eka:B Top (Type Top) E~ET~p (Sub TOP) E hEA~T.p 
 Table 8: Additional Typing Rules for Obl < 407 Table 9: Additional Typing Rules for F< ~ Types E , X<:A, 
E b O (Type X) (Type +) E , X<:A, E k X EFB, Vi C1. ..n (Type Record) (Type Ret)Et-{1, : B, =l n} E, 
X<:AFB (Type All) (Type Exists) E + V(X<:A)B Subtyping E , X<:A, E 1-0 Et-A <:A Ek B<:B (Sub X) (Sub 
+)E , X<:A, E k X<A E # A* B<: A ~B EkB, <:B~, di~l. ,,n EkB~, Vi En+l. ..n+m (Sub Record) E+ {1, : B, 
1 n+ }<:{1, : B; e n} E ~ p(X)A E + w(Y)B E, Y<: Top, X<:Y t-A<:B (Sub Ret) E + K(X) A<:p(Y)B EkA <:A 
E) X<.A E B<:B E k A<:A E, X<:A K B<:B (Sub All) (Sub Exists)E t-V(X<:A)B<:V(X<: A )B E t-3( X<: A) B<:3(X<:A 
)B Term Typings E,x:Akb:B E+ b:A+B Eka:A(Val Fun) (Val Appl) E + ~(X : A)b A-+B E+ b(a):B Ekb, :B, Viel. 
,,n (Val Record) E&#38; {1, = b% El n} : {1, :B, = } Eba:{l, :B, =l } (Val Record Select) Ekall:BJ 
 g~ n E+ b: B{A} (Val Fold) E + fold(A, b) :A A - ( X)B{X} EFb:A (Val Unfold) E + unfold(b) : B{A} 
 A + ~( Y)B{x} E, X<: Akb:B E+ b :V(X<:A)B E+ A <:A (Val Fun2) (Val App12) E h A(X<:A)IJ : V(X<:A)B 
E!-b(A ) : B{ A } E F C<:A E 1-b{C} :B{ C } (Val Pack) E 1-pack X<:A = C with b{X} : B{ A } : 3( X<: 
A)B{X} E\c:3(X<:A)B EFD E, X<: A,x:Bkd:D (Val Open) E+(open .as X<: A,x. Bind: D): D Table 10: Additional 
Typing Rules for the Imperative Calculus 408 Table 11: Additional Typing Rules for Ob~ Variance Subtypings 
o (Sub Covariant) E K ~~~ B<~+>\O } (Sub Contravariant) E E ~~ ~B<~_>\ } EFB (Sub Invariant) E t- l?<: 
B Object Types and Subtyping E, X<: Topt-B, {X} Viel... n + , 0}, B, ~ovariant in x (Type Object) Z 
ie{,E + Obj(X)[l;vi : B~ e n] (Sub Object) For A = Obj(X)[tiv; : B;{X} G +m], A = Obj(X)[t,v: : B:{X} 
e ] E, Y<:A 1-v, B,{ Y}<:v(B~{Y} Vi c 1.. .n E t-A<:A Term Typings E)z, :A1-b,{A}:B, {A} Vi~l... n 
(Val Object) A = Obj(X)[Lv, : B,{X} ~ln] E K obj(x = A)[l, = f(z, : X)bt{X} 61 ] : A (Struct Val Select) 
For A = Obj(X)[Lv, : 13{X} 1 ], v, G $+~o~<:fi,l . . . n E!-a:A E t-a.l$ : Bj{A} (Struct Val Update) 
For A = Obj(X)[Lv, : B,{X} G n],v, ~ {-, o}, j E 1.. .n Eka:A EHA<:A E, Y<: A,y:Y, z: Y+ b: Bj{Y} E E 
al, @ (Y<:A, y :Y)r(z :Y)b :A  
			

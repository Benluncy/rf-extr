
 AnalysisandExpdmm withanInformatwnsystemDeveiopnmtMethoddagy Manmahesh Kantipudi and Joseph E. Urban 
ArizonaState University Abstract Irsthis pa a methodology for development of Information Systems ( Ss) 
is r presented. The demand for 1Ss is constantly increasing. 1Ss are beiig used in critical areas and 
managers are relying more on 1Ss for &#38;cision making. flte software systems are getting larger and 
the applications are getting more complex. The IS designs have to he extremely reliable, artd yet easy 
to modi@. A number of formai design techniques have been suggested in the past. Some of these techniques 
are studied. CASE, 4GL s and reuse are being applied to increase the productivity of the developer. These 
tectilques should be exploited to develop 1Ss. A survey of the various tools available is presented. 
Y fCASE The impact of CA E and 4GL s on software development, and the reuse paradigm are put forth. The 
above mentioned techniques (CASE, 4GL s and Reuse) have been used widely and rather than reinventing 
the wheel each time, a methodology that optimizes these techniques and uses them collectively towards 
efficient IS development is presented. Index Terms 4GL s, Automated Tools, CASE, Design Techniques, Design 
Criteria, Information System, Information Asset, Management, Software Design Methodology, Software Development, 
Software Reuse.  Introduction Information systems (ISs) are becoming increasingly popular and usefid 
in everyday lives of people. 1Ss are being used in making crucial decisions and their failure or erroneous 
functioning can cost millions of dollars. These systems have to be developed with care md the design 
should accommodate future enhancements and changes, rather than redesigning the IS. In this paper some 
of the software desi n techniques that have been developed are described. CAS8 , 4GL s and reuse are 
techniques that improve productivity. These are being used widely in the industry individually, but by 
combtig these techniques under a common umbrella of a methodology individual benefits of each of these 
can be reaped. The impact of CASE and some of the commonly used tools are discussed. Contribution of 
4GL s and how they fit into the development methodology is considered. Reuse is being advocated as a 
necessity for efficient development in the future [32]. Questions such as how can reuse be applied to 
the development of 1Ss ? are answered. Applying reuse may require acquiring software rather than developing 
it. Some guidelines for the purchase of software are suggested. Finally tie above techniques are integrated 
Permission to copy without fee ell or pert of this material ia granted provided that the copies are not 
made or distributed for direct commercial edvanta~e, the ACM copyright notice and the title of the publication 
and its date appear, and notioe ia given that copying is by permission of the Association for Computing 
Machinery. To copY otherwise, or to republish, requires a fee and/or specific permission. 87992 ACM 
0.89T9~.502.X/92/0002/~ ~73... $ j .50 into a development methodology. Many IS problems are attributed 
to man.a ement failures rather than technical problems. Some o/ the management tasks that should be a 
plied hand in hand with the suggested methodology are Y e ucidated. The section on design techniques 
Wlefly describes design techniques that have been considered. The section on CASE and 4GL s discusses 
the impact of CASE and 4CL s on software develo ent. The reuse section describes the value and impact 
or reuse, its applicability towards the development of 1Ss and a development strategy for developing 
1Ss applying reuse. The paper progresses into the section on the methodology for developing 1Ss wherein 
the proposed methodology for developing 1Ss is explained. Also mentioned are mmagement issues , reasons 
for 1Ss failure, and a note on the experience in using this methodology. Design Techniques Marty design 
techniques have been proposed in the past and there is confusion about their advanta ea and disadvantages. 
This section briefly describes some o P the design techniques that exist. The techniques considered are: 
SADT, PSLJPSA, Structured Design, MIL, HIPO, Jackson s design methodology, Object Oriented Design, Program 
Design Lan uage and Nassi-Shneidermart diagrams. SADT and PSL/P EA are considered to be anal sis techniques, 
but have been used successfully to design solware. Using either of these techniques eliminates the need 
for a separate analysis technique. Structured Design, HIPO, Jackson s design and Object Oriented design 
were chosen based on their popularity in industry. MIL supports large projects and it was appropriate 
to consider it for designing 1Ss -which tend to be large. PDL and Nassi-Sfmeiderrnsn diagrams are detailed 
design techniques. These techniques are classified into: Architectural design and Detailed &#38;sign 
[15, 47]. Archltecturai Design Techniques The specifications are transformed into a system structure. 
The major components of the software are identified and relationships between them are established. Although 
each of the techniques has a different approach to architectural derivation, all of them recognize the 
holistic view of software. Architectural design can be viewed as an answer to what functions are needed 
for the program . The architectural design techniques are further classified into Proceaa-Oriented and 
Data-Oriented [47]. Process-Oriented Techniques These techniques emphasize the process of decomposition 
and structure in creating a software architecture. The following techniques are classified under thk 
categoty: SADT (Structured Analysis and Design Technique) is based on Structures Analysis (SA) &#38;veloped 
by Ross [34, 35]. SA is a graphical l~guage -used [or explicitly expressing hierarchical and functional 
relationships among any objects and activities. The analysis can be done in a top-down, structured, modular 
or even hierarchical manner. The SADT methodology includes management planning and configuration control 
procedures. SADT has been used successfully as an artrdysis technique. SA is not bound to any language 
and yet is designed to communicate units of thought without dependence on a specific language. Decomposition 
of units is done so that it suits the thinking and understanding of the audience. PSL/PSA was developed 
by Teichroew at the University of Michigan [37]. PSL (Problem Statement Language) is a formal language 
for statement of a problem, supported by art analyzer called PSA (Problem Statement Analyzer). PSA accepts 
PSL as input and is used to produce a number of reports describing internal and external dataflows, managementinformationandotherrelatedsystemdata. 
PSA also checks for inconsistencies in naming. PSL serves as an effective documentation tool by permitting 
the analyst or designer to specify the actions to be taken within a procedure and to showthe hierarchicaldecompositionof 
the system. Structured Design (SD) is based on the concept originated by Yourdon and Constantine [42, 
49, 50]. SD is a data-flow based method. SD transforms the data flow into a structure. While decomposing 
a system one must know if the decomposition is good or bad. SD allows the designer to evaluate a design 
in terms of modularity, cohesiveness and coup ling thus giving the designer art assessment of the design. 
SD provides metrics for evaluating designs. SD is widely used because it allows a designer to express 
the problem in terms of dataflow and transformation diagrams. MIL stands for Module Interconnection Language 
and was introduced by DeRemer and Kron, [13]. programming in a large-scale software system is dfferent 
horn programming in a small scale software system. Most current languages do not have any mechanism to 
specify interconnection between modules. MIL formally specifies structure and linkage. Besides specifying 
intrarnodule connections MIL cart also serve as a project management tool. There have been other MIL 
s developed such as GDL (Graph Description Language), which incorporated automated reasoning techniques 
to perform consistency checking of component interconnection. HIPO (Hierarchy, plus Input, Process, 
Output) was developed at IBM [41]. HIPO consists of a set of diagrams which were originally used as a 
documentation tool. HIPO has the ability to represent relationships between inputloutput data and software 
processes. Wlule using this method inputs, outputs and processes are identified. Each input and output 
is connected to the respective processes. Each process can be further decomposed. We start at the highest 
level of abstraction and refiie the process into subprocesses with new input/ou ut. HIPO is easy to learn. 
This tectilque can also be used ?or detailed design. Jackson s Design Methodology [22 23] suggests that 
the program structure be closely related to the ~oblem structure, the problems can be reduced to the 
creatmn of a mapping from an input structure to the output structure, and that the design method be easy 
to learn. The Jackson method is aimed primarily at data processing applications. Essentially one builds 
a program structure based on the input structure and output structure. This method haa to have the input 
end output structures known up-front and is not capable of doing thii analysis itself. Jackson s method 
must be preceded by an explicit analysis method. The program design is sensitive to changes in input 
or output. The quality of the software developed using this technique does not depend on the ex rience 
of the designer, each step cart be verified, md dl rferent designers working on the same problem will 
produce the same design.  Data-Oriented techniques ~;em~hniques emphasize the data design component 
of ObJectOriented Design (OOD) by Booth [7, 8] has become popular. 00D is a data oriented technique dtat 
is based on the concepts of Parrtas i.e., Information hiding [31]. All resources are viewed as objects. 
All objects have operations which manipulate the data inside that object. Using this methodology the 
designer can create abstract data type and map the problem domain into the newly created abstractions, 
instead of mapping the problem domain into the predefmed control and data structures of an implementation 
language. This approach is more natural than the process-oriented design techniques. The designer can 
concentrate on the system design without worrying about the details of the data objects used in the system. 
 Detailed Design Techniques The human mind has limited capacity for technical detail and so design representations 
should be used as a communication tool. The following techniques are detailed design techniques. PDL 
(Program design language, [9]) is a language-based tool using English-like statements. This technique 
is based on the fact that if the user interface is t%endly, then the errors made by the designer will 
be minimized. A PDL is alternatively called pseudocode . There are formal PDL s evolving which have a 
strict syntax so that they can be processed by machines. A PDL is used to describe the algoriti it can 
also specify interfaces and give a description of what that fimction is to do. PDLs are machine processable, 
easy to read and can be read continuously in a top-down manner. Nassl-Shneiderman Diagram (N-S Diagram, 
[48]) was develo~d to sup~rt structured progrtunmirtg. N-S diagram is a dlagrammattc representation of 
detailed design. The tltnctiottrd domain of this technique is well defined; arbitrary transfer of control 
is not permitted (as in flowcharts), scope of local and global data can be easily determined and recursion 
can be easily represented. The code generated by translating N-S diagrams will be structured. The N-S 
diagram has representations for all the structured programming constructs such as sequence, i~ case and 
for. From the above study the authors have found that Object tMented Design is best suited for designing 
a large software oduct. 00D is easy to use and comprehend and has a ~exible structure that cart be modifitxt, 
Object oriented techniques cart be extended to re uirements malysis (OOA) and programming languages (8 
OP). Thus the whole development methodology cm be based on an object oriented paradigm. The transition 
from analysis to design is clear, and then the implementation of the &#38;sign uairr GOP is straightforward. 
The tool support for 00A, 00 %, and GOP covers a wide range of the life cycle. GOD uses objects, many 
of which are common to most applications, thus the operations on these objects can be reused. GOD also 
has features such as data encapsulation, and exception handliig. Thus 00D is recommended as a design 
technique in this methodology.  CASE and 4GL s CASE: CASE is defined as a set of development tools to 
automate certain portions of software development methodologies. Thus CASE tools work within a methodology 
rather than compose a methodology themselves. Formal methods of software design have not been widely 
accepted. These formal methods are tedious in nature and a lot of time has to be invested into them. 
A ---- CASE environment provides the developer with facilities for drawing, dejining objects and data, 
identifying relationships and aiding in management procedures, over the quality of software &#38;veloued. 
CASE also helDs CASE lets dte developer d&#38;ument and-dei an IS from the audit a ;omp~eted system agaima~ 
ita design and hel~s initial requirements through the design and implementation maintain the system description. 
CASE can be applied to and ; ~them qt@y tests for consistency, completeness and phases of the life cycle. 
[40] shows a six phase life different con$ nance standards. By using CASE one haa control cycle using 
CASE. TOOL FUNCTION COMMENTS %lnrdlltl Phase Lista functions system must perform &#38; models initial 
data structore More common for engineering 1Configuration Tracks versions of ~ogra.ms and than data-processing; 
StandManagement Tool their relationships alone tools becoming commonII Project Mmagement Tracks Schedules, 
reports Needs to be integrated into tools Tool degree of completion, time for entire devehrttent mocess 
)esign phase Draws pictures, flowcharts, modules, Dlagrammer structures. organization Writes code to 
produce screen layout Common; usually integrated with tools Screen Painter after programmer designa it 
that genmte actual code for screen Data Assists designer in ensuring data are Not common; applies only 
to large Normalizer consistently defined data-processing systems Data Lists data elements; cross references 
and One of the most common tools; Dictionary ensures consistency in modules should be integrated with 
other tools 1 Data Reooaitorv/ IDD exmnded with info. as oroeedural LASScommon than DD, but more Encycl~pedia 
-rules &#38; definitions for data ~lements useful as constraints on data are m-e Control-Flow Maps interactions 
of Useful when control flow Analvzrx programs and modules desire tools are used Ensures that modules 
pass data Useful for languages with strict Interface Modeler correctly and consistently data typing 
-Ada II ..- Data-Flow Models path of data through system, Many availableModeler shows connection between 
modules; Tasking Ensures parallel taska in real-time Not commw, analysis is hard to do; Analyzer Isystems 
are synchronized I used in military !mulementation Phase Most produce usable code Commonly used, even 
if not in I the form of CASE tool Syntax-Driven editor I Understand format and syntax of text being editeck 
identifies errors I Commonly used I Scripting Tool Records interaction users and system between Used 
for testing interaction between user and system Test Data Develops complete set of data to Most are primitive; 
but Generator I test all modules I efficiency can be improved I Teat Data Tracks relation between versions 
of Rare; teat data generators are Manager I test data &#38; test conditions more common Online Code Debugger 
I Shows data during program execution. hi~hli~ts errors Common, one of the older tools Code Feedback 
Tool I Changes specs. to reflect code charmes Uncommon, difficult to construct hqport Phase BackfHl dictionary 
Documents logic and provides references for existirut code cross Useful at high level Code reeonatructing 
 Tidies up existing code to make it Usefid, but cannot compensate Tool Figure 1-A Sample of CASE Tools 
and Their Functioms. Figure 1 illustrates some types of CASE tools anti their functions. [18, 21]. This 
analysis is included here so that in our proposed methodology one can use this analysis to select the 
kind of tool needed for a particular purpose. Despite the advantages of CASU the most difficult issue 
in using CASE is to integrate the tools into the methodology [20, 39]. The authors believe that it is 
thus better to include CASE into the development methodology rather than adapting the tools to the methodology. 
The users should be formally trained and a commitment to the use of the tool should be made. Frequently 
changing tools will reduce productivity [51]. 4GL s: 4GL s stand for Fourth generation lan uages and 
are also called non-procedural languages. %Sitlg third generation languages, if the data structures were 
chang~ the application wss seriously affected. These languages were based on machine architecture and 
so the programs had information about de fhing variables and expressing program flow, rather than information 
about solving the problem. Elimination of this extra information leads to an increase in productivity, 
reliability and comprehensibili and reduces program size [11]. The 4GL s are resu 7t oriented and specify 
what is required as against the thiid generation which tedously speci~ how the problem should be solved. 
4GL s are easy to use and can be effectively applied for prototyping [5] and end user computing [27]. 
One problem with 4GL s is that the lack processing eficiency and hence are not as popular as z ASE. 4GL0s 
have been found particularly productive for developing prototypes. Since 1Ss are mostly used by non software 
engineers, it is a good idea to develop a prototype in the early sta es of the life cycle so as to demonstrate 
the functionality ot the IS. The importan~ of prototyping for 1Ss goes without saying [36]. Prototypirt 
in the early stages gives the user some feedback and lea *to increased satisfaction for the user and 
fewer changes for the developer in the later stages of the life cycle. In [17] again the importance of 
4GL s is emphasized, but Gavttrin also mentions that a prototype is better used as a part of a life cycle. 
 Reuse Improving software productivity is critical because of the magnitude of software costs [6]. Jones 
[24] shows that 85% of code is reusable for some applications. Reuse plays a central role in software 
productivity , maintainability, quality, portability and stsutdards [3~ 38]. Software factories [10, 
12] have started to exploit the concepts of reuse. Despite the need and potential for reuse, it has not 
been accepted widel . There is a lack of reusability strategy [4] and training J The absence of an appropriate 
top­ [4 ]. msnagement reuse strategy results in project managers and software engineers being unmotivated 
to reuse software, management also has a resistance to allocate up-front costs to put reuse into practice. 
Managers feel threatened that there may be budget cuts if reuse is implemented. Managers are short sighted 
and are always occupied with projects and deadlines, the do not want to invest time and resources into 
reuse. The e?fects of reuse are not immediately apparent and this is d~couraging to managers. 1Ss are 
large projects and in the time for developing the design, the requirements can change easily. Hmg this 
period the funding may still not be available. An asset based development methodology is suggested for 
developing 1Ss so that reuse cart be used in the development process [2, 25, 26]. Figure 2 shows the 
development methodology [2]. I Usa Assets Level 1 Figuse2-Asset-BasedLifeCycle The asset-based life cycle 
model focuses on the development construction, management and utilization of assets. The model defines 
two kinds of work work to build assets and work to use those assets to build products. Assets are machines, 
communication facilities, operating systems, DBMSS and computer programs. This model has three levels 
of productivity. At level 3, maximum productivity is achieved by servicing r uirements that reuse -without 
modification -assets that1 ave been previously engineered and uced. The level 2 is where modified assets 
are used for r vekqnmmt of the IS. Level 2 is called customization o assets. If neither 1 or 2 are possible 
then a new asset is L veloped. The assetisdeveloped and stored so that next time it can be used. The 
assets have to be developed with reuse in mind. A project team must define these assets as part of their 
planning; they must commit funds to btdkling them, An advantage with thk system is that assets can also 
be purchased by a company just as hardware is purchased for project development. It may be nexxssaty 
to acquire software for development of 1Ss [44]. The following attributes of the software could help 
in the decision of its purchase. New or Old -We may want to &#38;ve@ new software or reuse old software. 
Urgency and quality are to be considered. Mileage -Old software is good software. This is because people 
have been using it and it has no problems. Keep in mind that so!lware has no wear/tear associated with 
it.  Maintenance record -Look at the times errors have been found how long it took to fix and whether 
after fixing, more errors were found. Reputation -If the software is from a good company you may be influenced 
to buy it. Appearance -Looking at the code we cart get an idea of programming style, maintainability, 
reliability and modifiability Standards -{ f the software complies with certain standards in documentation, 
testing, design then it should be a potential candidate for reuse. Warranty -To establish credibility 
and viability of new and used programs the seller must povide warranties. The seUer is thus responsible 
for errors and fining them. Price -Some software packages may come with features that may not be needed, 
but the developer thought should be included. Unused tittctionality costs more. Reuse of softsvsre can 
be done at various levels [14, 28]. The asset based strategy does not extend itself to reuse of design 
or specificationiy lt reuses assets. These assets are added to a library. Here concerns of fiidmg the 
correct assets, or the most likely to be usefld asset is important so that new assets are not simply 
developed every time. The library retrieving system must be sophisticated and precise.  Methodology 
for Developing IS s Design techniques, CASE, 4GL s and reuse have been discussed. All the above are technical 
aspects that have to be considered, but the managerial aspects towards development are just as important 
because, despite the best technical support if there is no management support the system is bound to 
fail. The followirt is a synthesis of the common reasons for 1Ss faihtre [29,30 f. 1. Lack of adequate 
senior management sup ort and involvement -they are not considered knowledgea t le about the use of IS 
resources, it is hard to train them, some organizations do not have senior management steering committees. 
2. Lack of use of a standard development methodology. 3. Lack of knowledge of alternative development 
techniques -many are unaware of SA, SD automated tools for analysis and design. 4. Management does not 
want to change. 5. There is no formal training in manv orm.nizations. informal means of knowledge a~uisition 
&#38;e u;ed such * magazines and conferenmw, they are not reviewed.  6. Some use formal design but only 
in a superficial manner, the full benefits are not used. 7, Feasibility studies for cost estimation and 
benefiki are not done in or animations and if done are done only superficially i us increasing costs. 
  8. The maintenance problem is not taken seriously. No one wants to move from unstructured COBOL, because 
of the investment already made. 9. Post implementation audits are not done. 10. Some organizations 
overreact to new systems and tools­personnel are trained in multiple approaches, but the approaches are 
not evaluated nor is stmdardization done.  A software development methodology is a biend between a collection 
of technical procedures and a set of management techniques. The maria ement should &#38; responsible 
for the following functions ! [4 ]: Linkage of project phases -Management preserves the effective communication 
of system progress throughout development. Evaluation of progress -Reviews and walkthroughs should be 
done formally and at more than one point in the system development activity. Reviews and walkthroughs 
give the manager a better idea of the progress and the troubled areas early in the life cycle. Personnel 
Deployment -A person who is a good software engineer may not be a good analyst or a good manager. The 
methodology must provide alternative roles for individuals and find ways to use them appropriately on 
different projects. Release control -The methodology must establish when to release a new version of 
the software to replace the old one. This requires configuration management, which keeps detailed track 
of each item associated with the project. Thus the methodology not only has to manage people, but also 
the software products of the organization from their conception to their final release. New technical 
procedures -Once the methodology is in working order it must be reviewed and place for change has to 
be provided. Change is progress, and the managers must be on the look for new techniques and/or ways 
to further improve the present setup. Information Systems are large projects and though until now have 
adhered to the classicaf life cycle of development. Many methodologies have been suggested [3, 19]. The 
authors have discussed techniques that improve the productivity of 1Ss development and contend that integrating 
these techniques into a methodology would improve the ease of development and productivity. customer 
s curiosity and help the customer to clearly identi~ the requirements. To identify a complete set of 
requirements may require iterations between the prototype and the r@rements analysis phase. After developing 
the prototype and identifying the requirements to the satisfaction of the customer, the development methodolo 
y should embark on the design of the IS. During this pf aae CASE should be applied to increase productivity. 
CASE is used to improve the productivity of the various stages of the methodology such as analysis, design, 
search, and testing. GOD has been suggested as a technique that can be used to design the IS. Using 00D, 
one can identify objects and operations. The reuse paradigm can be applied to these objects and operations 
to evaluate what can be reused. One must have RELs (Reusable entity libraries) with a workbench (a consistent 
development environment) so that we cart get consistent reusable operations [1, 16]. Such art environment 
leads to the increase in productivity. The difference between CASE and reuse is that CASE helps in the 
development, but reuse is part of the development. There can be a CASE tool that supervises and implements 
reuse. The parts that are to be reused have to be extensively documented so that the new product is readable 
artd maintainable. Currently reuse is mostly done at the code level, thk should be extended to a much 
higher level and be applied to design and specifications. Figure 3 shows the authors perspective of a 
development methodology for 1Ss. The figure shows how the various techniques fit into the methodology. 
CASE is used throughout the process with a view of automating as much of the life cycle as possible. 
The use of CASE, 4GL s and reuse increase productivity and the use of a structured design technique increases 
reliability and maintainability. While interacting with the end product 4GL s cm be used because they 
are easy to use. However end users must be warned of the problems with end user development -undocumented 
code, no standard interfaces, and rewriting the same code again and again. m  The users of 1Ss are usually 
not software engineers and their Figure3 -An IS Development Methodology probability of changing the requirements 
is high. The authors suggest that a prototype be produced to satisfy the To apply this methodology the 
problem considered was that of an ethylene plant txmtrol system in which various analog and digital signals 
are read at certain intervals of time. Various parameters are stored in a database which is continuously 
updated and a variety of displays and reports can be generated. A complete specification of the problem 
CSlt be found in [43]. For the above problem m initial requirements analysis was done using dataflow 
diagrams. Based on this analysis a prototype which indicated all user interfaces and total functionally 
was simulated. The to making the requirements clear. ~e~i;;$;~~g~ were made, and after a couple of iterations 
the final requirements could be specified. Using this approach the user can see up-front the interface 
and can perceive any modifications. The design phase was then initiated. An Object Oriented &#38;sign 
was done; objects and operations were identified snd the operations were further broken down into functions. 
Twenty four functions were identified and several were found to be potential candidates for reuse. This 
is simply because objects such as keyboards, screens, menus and files are used in most applications. 
45.8% of the functions could be totally reused (11 out of 24). 16% could be partially reused (4 out of 
24). Ordy 37.5 % of the code had to be developed from scratch. As the library grows, the percentage of 
reuse would increase. Presently a library does not exist and hence the percentage of functions that could 
be further reused is not known. The library is in implementation stages. Since the reuse here refers 
to reuse of code the integration problems would not be any different than those encountered m a total 
development of the project from scratch. This implementation has indicated that by following the methodology, 
the requirements specification is more precise, the user is satisfiti the probability of changes is reduced 
and by using GOD the scope for reuse is improved. By automating the methodology by using CASE tools for 
requirements analysis (dataflow diagrams), design, and testing; and by using a library for storing and 
retrieving required reuse functions, the productivity of the development team is improved. Using the 
guidelines for acquiring software, further development time can be cut and by applying the management 
issues mentioned the development effort can be managed so as to avoid management failure. A methodology 
for developing 1Ss has been proposed. The reasons for the use of formal design tcctilques have been mentioned. 
A number of design techniques have been surveyed. The authors have shown that CASE, 4GL s and reuse cm 
all be exploited for the development of 1Ss. For effective application of CASE towards IS development 
and the various kinds of tools available have been presented. Use of 4GL s in prototyping of 1Ss is presented. 
A reuse based development method has been illustrated. While trying to use the reuse paradigm? acquiring 
software is an important issue and some guidehnes were mentioned. Management participation and responsibilities 
towards IS development have been addressed. Finally, an experience using this methodology was described. 
 References<RefA> [1] Apte Uday; Shankar S. Chetan; Thakur Meru; Turner John E., Reusability-Based strategy 
for Development of Information Systems: Implementation Experience of a Bank ; MIS Quarterfy, December 
1990, pp. 412-433. [2] Appleton Daniel S., Very Large Projects ; Datamation, January 151986, [3] Avison 
D. E.; @X&#38;&#38;r A. T.; TnformationSystcms Development Research An Ex loration of Ideas in Practice 
; The Computer Journal, Vol. 4 No. 2,1991, pp. 89-112. [4] Benham Harry C.; Price Leon R.; Wagner Jennifer 
L., Comparison of Structured Development Methodologies ; fnbnnation Executive, Vol. 2, No. 2, Spring 
1989, pp. 18­ [5j Bleth~ Stare Parker Caxys, How to Design Information Systems ; Information Age, Vol. 
12, No. 1, January 1990, pp. 4248. [6] Boehm B. W., Improving Software Productivity ; tEEE Computer, 
Vol. 20, No. 9, September 1987% pp. 43-57. [7] Booth Grady, Object oriented Design ; Reprinted in Tutorial 
on Sojtware Design Techniques, 4th Edition, IEEE Computer Society press, August 1983, pp. 420-436. [8] 
Booth Grady, Object Oriented Develo ment ; IEEE Transactions on Software Engineering, fiol.12, No.2, 
 February 1986, pp. 211-221. [9] Caine S. H.; Gordon E. K., PDL A Tool for Software Design ; Reprinted 
in Tutorial on Software Design Techniques, 4th Edition, IEEE Computer Society Press, Au ust 1983, pp. 
485-490. [lOf Chang, Carl K.; Aoyama Mikio, Software in the Far East ; IEEE Sojtware, March 1989, ~ 11-12. 
 [11] Cobb Rtchard H., In Praise o 4GLS ; Datamation, Ju]y 15 1985, pp. 418-422. [12] Cusumano, Michael 
A., The Software Factory: A Historical Interpretation ; IEEE Software, March 1989, pp. 23-30. ii3] DeRemer 
F.; Kron H. H., Programmitt g-In- I%e-Large versus Programming-In-The-Small ; IEEE Transactions on Sojlware 
Engineering, Jutte 1976. Reprinted in Tutorial on Sojlware design Techniques, 4th Edition, IEEE Computer 
Socie press, August 1983, pp. 321-327. [14] %reeman Peter, Reusable Software Engineering: Concepts and 
Research Directions:, Information Systems, Vol. 8, 1983. Reprinted in Tutorial on Software design Techniques, 
4th Edition, IEEE Computer Society press, August 1983, pp. 63-75 [15] Freeman Peter, Fundamentals of 
Desi ; Tutorial on Software Design Techniques, 4th Edition, EEE Computer Socie press, August 1983, pp. 
2-22. [16] %reeman Peter; Ruben Prieto-Diaz, Classifying Software for Reusability ; IEEE Sof~are, January 
1987, pp. 6-16. [17] Gavurin Stuart L.; Where Does Prototyping Fit in IS Development? , Journal of Systems 
Management, Febuary 1991, pp. 13-17. [18] Gibson Michael L.; Snyder Charles A.; Houston Carr H., Implementing 
a Corporate Wide Information Strategy Through CASE ; Journal of Information Systems Management, Vol. 
7, No. 3, Summer 1990, pp. 8-17. [19] Hamilton M.; Zeldin S., The Functional Life Cycle Model and Its 
Automation USE.IT ; The Journal of Systems and Software 3, 1983, pp. 25-62. [20] Hayley K. J.; Lyman 
H. T., The Realities of CASE; Journal of Information Systems Management, Vol. 7, No. 3, Summer 1990, 
pp. 18-23. [21] Hedge Bartow, CASE Tools Increase Productivity ; ~~rmation Executive, Vol. 2, No. 2, 
Spring 1989, pp. 25­ [22] Jackson M. A., Constructive Methods of program Design ; Reprinted in Tutorial 
on Software Design Techniques, 4th Edition, IEEE Computer Society press, August 1983, pp. 514-532. [23] 
Jackson M. A., Systems Development, Prentice-Hall, 1983. [24] Jones T. Capers, Reusability in Programming: 
A Survey of the State of the Art ; IEEE Transactions on Sof~are Engineering, Vol. 10, No. 5 September 
1984, pp. 488-497. [25] Ksrimi Jahsngir, An Asset-Based Development A each to Software Reusability* 
; MIS Quarterly, June l;~. tm. 179-198. [26] ~hitni Jahsngir, An Automated Software Design Methodology 
Using CAPO ; journal of Management ~~[~tion Systems, Winter 1986-87, Vol. III, No. 3, pp. -. [27] Konsynski 
Berm R., Advances in Jrtformation System Design ; Journal of Maria ement It$ormation Sciences, Winter 
1984-85, Vol. 1, No. ~. DD. 5-32. [28] Lanergm Robert G.; G;&#38;so Charles A., Software Engineering 
with Reusable Designs and Code ; IEEE Transactions on Software Engineering, Vol. 10, No. 5 S tember 1984, 
pp. 498-501, [2~] More Elizabc~ Irtfortnation Systems: Peo l~~jtte~ Journal of l~ortnation Science, Vol. 
16, No. f,. 311-320. [30] Necco Charles R., Evaluatin Methods of Systems Development: A Management f 
urvey ; Journal of Ir@ormation Systems Management, Winter 1989, pp. 8-16. [31] Psrnas D. L., On the 
Criteria to be Used in Decom osing Systems into Modules ; Communication of the AC$, Vol. 15, No. 12, 
December 1972, pp. 1053-1058. Reprinted in Tutorial on So@are design Techniques, 4$h Edition, IEEE Computer 
Society press, August 1983, pp. 304-309. [32] Poole John Bemsrdi The Future is Now: Reflections of the 
Software Enzineeriru Industw : Itiormation Executive. Winter 1991, pp.-24-27. --­ [33] Rombach H. D., 
Software Reuse: A Ke to the Maintenance Problem : Information and ~oftware Technology, Jamtary/Fe~ary 
~991, Vol. 33 No. 1, ~. 86­ 92. [34] Ross D. T., Structured Anal sis (SA): A Lartgua e for Communicating 
Ideas ; IEEE ? ransactions on So&#38; are En ineering, January 1977. Re ittted in Tutorial on So~are 
Design Techni~ues, 4th l%ition, IEEE Computer Socie press, August 193, pp. 96-114. [35] ~oss D. T.; 
Schoman, Jr., Structured Analysis for Requirements Deffition ; IEEE Transactions on So~are Engineering, 
January 1977. Reprinted in Tutortal on Sojlware Design Techni ues, 4th Editiow IEEE Computer 1 Society 
press, August 193, pp. 86-95. [36] Rouse William B.; Cody William J., Information Systems for Design 
SupporC An Approach for Establishing Functional Requirements ; In ortnation and Decision Technzdogies, 
Vol. 15, No. 4.199, J pp. 281-289. [37] Sa atti Hasan H., PSA/PSL at the Age of Fifteen ; Tutor~a Y: 
System and Sofware Requirements Engineering ~e;~l~ H. and Dorfman M.; IEEE Computer Society [38] Schn~idewind 
Norman F., The State of Software Maintenance ; IEEE Transactions on Software Engineering, Vol. 13, No. 
3 March 1987, pp. 303-310. [39] Souza Eileen, Strategies for Software Engineering Implementation ; Journal 
o{f {n ormation Systems Management, Summer 1990, pp. 3-37. [40] Souza Eileen, The Impact of CASE on Software 
Development ; Journal of Information Systems Maria ement, Vol. 8, No. 1, Winter 1991, pp. 17-24. [41] 
~tay J. F., HIPO and Integrated Program Design ; Reprinted in Tutorial on Software Design Techtu ques, 
4th Edi~ion, IEEE Computer Society press, August 1983, pp. 177-lt7R ~42] ~t~vens W. P.; Myers G. J.; 
Constantine L. L., Structured Design ; Reprinted in Tutorial on Software Design Techniques, 4th Edition, 
IEEE Computer Society ess, August 1983, pp. 328-352. r43] Thor Merrill G., Computer Systems Specification 
Design ; Mini and Microcomputer Control in Industrial Processes : Handbook of Systems and Application 
Strategies, Van Nostrand Reinhold Company, NY 1980, Robert Skrokov (Ed). pp. 193-197. [44] Tracz Will, 
Reusability comes of Age ; IEEE Sojhvare, January 1987, pp. 6-8. [45] Wasserman A. 1,, Information System 
Desi n f Methodology ; Journal of the American Society or It$ormation Science, January 1980. Reprinted 
in Tutorial on Sojlware Design Techniques, 4th Edition, IEEE Computer Society press, August 1983, pp. 
43-62. [46] Woodfield Scott N.; Embley David W.; Scott Del T., T8? prog~r Reuse Software ; IEEE Software, 
July [47] %u S. S.; Tsai J. P., A Survey of Software Design Techniques ; IEEE Transactions on Sot?ware 
EnQineerinQ. Vol. 12; No. 6, June 1986, pp. 713-721 .-- [48] Yader C. M.; Schrag M. L., Nassi-Shneiderman 
Charts: An Alternative to Flowcharts for Design ; Reprinted in Tutorial OB So@wrre &#38;sign Techniques, 
4th Editio~ IEEE Computer Society press, August 1983, pp. 506-513. [49] Yourdon Edward What Ever Happened 
to Structured Analysis ; Daramation, June 1, 1986, pp. 133-138. [50] Yourdort E.; Constantine L. L., 
Structured Design. New York: Yourdan Inc., 1975. [51] Zagors@ Carol, Case Study: Managirtg the Change 
to CASE; .70urnal of lt#ormatwn Systemr Management, Vol. 7, No. 3, Summer 1990, pp. 24-32.</RefA>   
			

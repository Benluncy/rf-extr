
 A Formal View Integration Method Joachm Blskup and Bernhard Convent Umversltat Dortmund lnformatlk VI 
Postfach 500 500 4600 Dortmund 50 Federal Republic of Germany Abstract The design of an appropriate conceptual 
database scheme 1s one of the most difficult tasks m usual database apphcatlons Especially, the design 
of a common glo-bal database scheme for many different user groups requires a great amount of effort 
and skill, because the desired scheme should fit a great variety of requirements and expectations Here, 
view integration is a natural method that should help to manage the complexity of such a design problem 
For each user group the requirements and expectations are separately collected and specified as views, 
that are subsequently integrated into a global scheme supporting all those different views In this paper, 
we carefully develop a formal model, clarifying many notions and con-cepts, related to the view mtegratlon 
method This formal model serves as a theoretical basis of our mtegratlon approach that uses equivalence 
preserving, local scheme transformations as the mam integration operations 1 INTRODUCTION View integration 
1s a method that should help to cope with problems related to the design of conceptual database schemes 
for extensive database apphcatlons In such an extensive appllcatlon, there exist a lot of different user 
groups, each of them requlrmg particular lnformatlon on the whole apphcatlon to fulfill their spe-clal 
tasks I e , each user group has its own view of the whole apphcatlon which can formally be described 
by a small (view) database scheme, representing the mfor-matlon needs and rights, associated with that 
particular user group Of course, one of the mam goals m database apph- cations is to centralize all information 
in a single global database that can support all views By this centrahza- tlon. redundancy 1s avoided 
and the threat of mconsls- tancles between the views 1s reduced So, several data- base schemes for the 
different views and a smgle, global database scheme for the centrahzed global database have to be designed 
 According to a common approach, first the global database scheme 1s designed, and afterwards suitable 
portions of it are selected to form the view schemes for the different user groups But this approach 
bears at least the followmg deficiencies This research was supported m part by the Deutsche Forschungsgemelnschatt 
under grant number Eli 311/1-l Permlsslon to copy wlthout fee all or part of this matenal 1s granted 
provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright 
notlce and the title of the pubhcation and its date appear, and notlce IS given that copymg IS by permlsslon 
of the Assoclatlon for Computmg Machmery To copy otherwise, or to repubhsh, requires a fee and/or specdic 
permlsslon @ 1986 ACM 0-89791-191-l/86/0500/0398 $00 75 The immense number of expectations and requlre-ments 
of all user groups can hardly be managed and overviewed Thus, it IS rather difficult to get a suitable 
global scheme that really can fit all those requirements The classical formal design algonthms ([Codde] 
[Fagl]. [BDB]) can hardly be used to find a global scheme of an extensive application These algo-rithms 
are based on a speclficatlon of the form (U C). where U 1s a set of attributes (the universe), and C 
1s a set of functional and multivalued dependencies Usually, such speclficatlon means are not sufficient 
to capture all the relevant details of an extensive application Thus, the clas-sical approaches are rather 
inadequate to the design of global schemes, while they are still quite useful, when designing smaller 
user views So, view integration seems to be a much more natural approach At first, the requirements and 
expec-tatlons of all user groups are separately collected and specified as view schemes Thereafter, all 
those views are integrated into a global scheme that supports all views This view integration approach 
can be embedded into a methodology for the whole database design pro-cess According to [Lum], [TeFr], 
[YNW] the design pro-cess can be divided into five phases Reqmrement Analysls The requirements of all 
user groups are analyzed, collected and formally specified so that both the information and processing 
requirements are made explicit View Modellmg Using the mformatlon requirements of the first phase, a 
database scheme for each user group IS constructed, representmg Its special view of the apphcatlon These 
user views are generally specified on a more abstract level of a conceptual data model, which should 
be independent of any concrete database management system ken lntegratlon All the user views are analyzed 
m order to specify the connect:ons and relatlonshlps between them and to detect possible conflicts Then 
the views are integrated into a global scheme for the cen-tralized, common database that should be able 
to sup-port all views This global scheme IS also specified on the abstract level of the chosen data model 
Implementation Dezngn The global conceptual database scheme IS refined in order to get a processlble 
scheme of the target database management system Phyglcal Deglgn On the physical level of the target data- 
base management system, an appropriate storage struc- ture IS chosen to get an efficient Implementation 
of the whole apphcatlon The above design phases are still of such a size and complexity that any of them 
can hardly be done without interactive computer support Thus, there IS a need for computer-aided design 
tools for all phases of the whole design process In order to be useful and acceptable, such tools should 
be based on a clear, formal back- ground Although several work ([BaLe,BLM], [ CaVl] [MaWl,WlMa]. [NaGa]. 
[YWH]) was directed to the view integration phase, such a complete formal basis 1s still rmssing At least 
the followmg details should be clarified as a basis for a computer-aided view mtegra- tion tool 1) A 
data model with a clear formal semantics must be chosen This data model forms a kind of mter- face to 
the other phases, since all user views and the global scheme are specified wlthm this model 2) A formal 
speclficatlon language must be given that can be used to describe the connections and rela-tionships 
of different views 3) The notion of conflicts between several views has to be formalized 41 There 1s 
a need for a formal concept of the mclu-slon of database schemes, describing when a global database scheme 
supports a user view 4 Using the above concepts, a complete formal description of the view integration 
problem should be elaborated In our research, we try to develop such a theoretl- tally based view mtegratlon 
method, extending many concepts and results of a former approach due to Casanova/Vldal [CaVl] The paper 
1s orgamzed as follows In Section 2 we carefully develop our formal model clarlfymg the notions and concepts, 
needed for the view integration phase In Section 3, our integration algorithm 1s presented that uses 
equivalence preserving local scheme transformations as the main integration opera-tions Section 4 concludes 
this paper by pointing out some open problems and dlrectlons for further research 2 A FORMALMODELFORTHEVIEWINTEGRATION 
2 1 PRFJJbUNARlEs At first, we briefly present some basic definitions and notation, used throughout the 
paper Let U be a fixed finite set of attnbutes and let T be a fixed finite set of basic types 1 e each 
TET 1s a count- able set of values contammg at least 2 elements A function domU-->T associates each attribute 
with a basic type An ordered subset X=[Al, AnjcU will be represented as X=Al An 1 e as a word over U 
For two ordered subsets X, YCU the assertions XCY, XnY=$ will hold if the same assertions hold for the 
corresponding unordered sets Furthermore, the function dom 1s extended to ordered subsets of U by the 
unique mor-phism dom U* --> T* A telatzon scheme R[X] consists of the relation name R and an ordered 
set X=Al AncU of attributes A tzLple t over XIS an element tcdom(Al)x xdom(An) A relataon r over X IS 
a finite set of tuples over X A data- base scheme D=<RlC> consists of the name D. a finite set R=IRl[Xl]. 
,Rn[Xn]{ of relation schemes and a finite set C of integrity constraints A database d=(rl, ,m) over R 
associates each relation scheme Rl[Xll with a relation rl over X1 A database d over R that addltlonally 
satisfies all integrity constaints in C 1s called an mstance or a valid database of D, denoted by dcsat(C) 
= n,,$at(c) The set of all vahd databases of D 1s denoted by I(D) htegrzty constsaants are understood 
as state-ments about time-invariable properties of the real world that must be satisfied by every meaningful 
database So, integrity constraints are a formal means to dlstmgulsh between meaningful and meaningless 
databases with respect to the real world Here, we concentrate on functional dependencies (FDs), mcluslon 
dependencies (INDs) and exclusion dependencies (EXDS) A junctzonal dependency over R [Codd2] 1s an expression 
c of the form c=Rl Y->Z, where Y, ZCX~ A database d=(rl, ,rn) over R satisfies c, denoted by dcsat(c), 
lff for all t, t Er1 t[Y]=t [Y] ==> t[Z]=t [Z] An znclusson dependency over R [CFP] 1s an expression 
c of the form c=Rl[YlcR~[Zl, where YcXl, ZcXl and dom(Y)=dom(Z) dcsat(c) lff n[Y]cr][Z] Sirmlarly, an 
ezcluszon depen-dency c over R [CaVl] 1s of the form c=RI[Y]IIRJ[Z]. where YcXI, ZCX], dom(Y)=dom(Z) 
and dcsat(c) lff ri[Y]nrj[Z]=$ Remark Note, we use ordered sets of attributes instead of usual, unordered 
sets and we define tuples to be sequences instead of mappings This notation turns out to be quite useful 
m connection with mcluslon and exclusion dependencies Beyond these basic definitions, we assume the reader 
to be farmliar with the operations of the relational algebra, as for instance described m [Male] [Ullm] 
 2 2 THE DATA HODEL Within conceptual database design a data model is used to develop an abstract representation 
of the relevant parts of the real world, which should not depend on the database management system chosen 
for the lmplementatlon (See [Brod] for an overview of data models ) As already indicated, our analysis 
of the view integration problem 1s based on a relational model of data [Coddl] In the followmg, we adopt 
some common restnc-tlons on the use of integrity constraints to get a proper subclass of so-called normalized 
database schemes This normalization should guarantee that only semanti-cally meaningful integrity constraints 
are used Let D=<RIC> be a database scheme D IS called a proper database scheme, lff for all relation 
schemes Rl[xl]~R there IS a pair (Kl,Pl), where KinPi=+ KlPl=Xl and a) -_ -- for all RI[XI~~R the set 
of all FDs refermg to RJ 1s equivalent to the single FD RJ KJ->PJ, b) for-all RJ[Y]cRI[Z]EC Rl#Rl and 
( (Y=KJ and (ZcKl or ZcPl)) or (Z=Kl and (YcKJ or YcPJ)) ). for all RJ[Y]IIRI[Z]EC V4 (stock dlvlslon) 
RJ#RI. Y=KJ and Z=Kl 1 Name I Qty a) restricts the use of FDs as mtrarelatlonal con-straints A proper 
database scheme 1s a collection of entitles and relatlonshlps. each identified by a unique key Attributes 
m Kl are called adentzjyang attrabutes of the oblects (entitles or relatlonshlps) of type RI, whereas 
attnbutes m Pi are called property attrzbutes b), c) restrict the use of INDs and EXDs as mterre-latlonal 
constraints, guaranteeing that they are always via keys, which make them hkely to be supported by concrete 
database management systems An IND of the form RJ[KJ]cRI[Z] denotes that m any instance d=(rl, rn) all 
objects of type RJ, occurmg in rJ. are used either as an identifying or as a property part of oblects 
m rl An IND of the form RlrYlcRlrKll denotes that the properties of any object 07 type Rl occurmg either 
as identifying or as property part of an object in rl. can be found m rl An EXD RJ[KJ]IIRI[K~] denotes 
that the oblects in r-1 and rl are distinct, although they belong to a common general type of obJects 
Although the above restrictions seem to be techru- tally rather comphcated we believe that they are usu-ally 
satisfied when modellmg real world sltuatlons All views and the desired global scheme should be specified 
as proper database schemes Thus, it 1s the task of the view modellmg phase to supply all views m that 
normal-ized form We finish this paragraph with a still rather small example that will often be reused 
throughout the paper Stock-emps II-1 Name Address 2 3 INTEGRATION CONSTRAINTS Let Vl, ,Vn be a set of 
database schemes that have to be integrated into a single global scheme As all these schemes represent 
overlappmg portions of the same part of the real world, normally, a considerable amount of data IS shared 
These connections between the different views must be analysed and specified Sratements descnbmg time-invariable 
connections between several views are called antegrataon con-s traznts In our approach, we use integration 
constraints with a formal semantics essentially based on the seman-tics of INDs and EXDs But nevertheless, 
we stress that it 1s important not to nux up integrity constraints and integration constraints, as done 
m [CaVl], because of different intended meanings Integration constraints describe the connections between 
different views, and so they form some kmd of structural inter-view con-straints which have to be considered 
during mtegra-tlon On the contrary, Integrity constraints specify pro-perties of the real world, and 
so they deterrmne what nre meaningful databases Thus, throughout the paper a different syntactical notation 
is used to dlstmgulsh the two types of constraints Example Suppose that a small trading company 1s divided 
into four dlvlslons (personnel, pay-roll, market-mg and stock dlvlslon) Of course, each dlvlslon has 
its own special mformatlon needs which will be modelled as a proper database scheme We present these 
views VI=<RIICI> m the usual tableau-oriented manner with the identifying attributes underlined and the 
correspondmg FDs ormtted The followmg abbreviations are used Employee mlslon, Identity, Salary, Account, 
Order-date, Delivery-date, Quantltv, Product Vl (personnel dlvlslon) Employees -1 Name 1 Address 1 Date 
1 Dlv V2 (pay-roll dnnslon) Salaries II&#38;I Name I Sal I #Act Pay-roll-emps Address Pay-roll-emps[#Id]cSalarles[#Id] 
V3 (marketing dlvlslon) Articles 11-P I Name I Price Customers YCustomer I Name 1 Address Orders I carder 
I #Customer I Ord-date I Del-date Order-contents )l&#38;&#38;der 1 #Art&#38;e 1 Qty Marketing-emps I 
Name Address Orders[#Order]cOrder-contents[#Order], Orders[#Customer]cCustomers[#Customer]. Order-contents[#Order]cOrders[#Order], 
Order-contents[#Artlcle]cArtlcles[#Artlcle] In the followmg, we first present some typical con-nections 
between different views using our former exam-ple again A complete formal definition of the syntax and 
semantics of the integration constraints will be given afterwards Example (continued) Naturally, all 
employees (and only employees) draw a salary So the data seen by the per-sonnel dlvlslon and the pay-roll 
dlvlslon 1s partly Identl-cal This 1s expressed by the adentaty constraant Employees[#Emp,Name] id Salanes[#Id,Name] 
 In the personnel dlvlslon. mformatlon about all employ-ees must be available. whereas m the marketing 
dlvlslon this information IS needed only for exactly those employees, workmg m that particular dlvlslon 
This IS specified by the selectzon constraant Marketing-emps[#Emp,Name,Address] se1 (Dlv= marketmg Employees)[#Emp,Name,Address] 
 We assume that every employee 1s attached to a unique dlvlslon Thus, the data belonging to the Marketmg-emps 
scheme and the data related to the Stock-emps scheme are disJoint, although both schemes descnbe the 
same type of mformatlon on employees This IS expressed by the dqoant constraant Marketing-emps[#Emp] 
disJ Stock-emps[#Emp] Assume, most articles that are sold (and only such artl-cles) are m stock, but 
sometimes there may be articles out of stock This IS specified by the contaanment con-s traant Stock[#Prod,Name] 
con Artlcles[#Artlcle.Name] To summarize all connections and relatlonshlps that belong to our example, 
we present the following set I of integration constraints Employees[#Emp,Name] id Salaries[#Id,Name], 
Pay-roll-emps[#Id,Address] se1 (Dlv= pay-roll Employees)[#Emp,Address].  Marketing-emps[#Emp Name,Address] 
se1 (Dlv= marketmg Employees)[#Emp,Name Address] Stock-emps[#Emp,Name Address] se1 (Dlv= stock Employees)[#Emp,Name 
Address], Pay-roll-emps[#Id] dlsl Marketmg-emps[#Emp], Pay-roll-emps[#Id] dlsl Stock-emps[#Emp], Marketmg-emps[#Emp] 
dlsj Stock-emps[#Emp], Stock[#Prod,Name] con Artlcles[#Artlcle.Name] = Now, we present the general syntaz 
of the mtegratlon constraints Let Vl, ,Vn be a set of proper database schemes, each representmg a different 
view An tntegrataon constraznt over VI, .Vn IS a statement of one of the followmg forms -zdentzty constratnts 
(IDS) Rl[Y] id Rl[Z], where Rl and RJ belong to different views and for some Y cPl. Z CPJ (Y=KlY . Z=KJZ 
. dom(Ki)=dom(KJ) and dom(Y )=dom(Z )). -selectzon constraxnts (SELs) Rl[Y] se1 (b RJ)[Z]. where Rl 
and RJ belong to different views, b 1s a condo- tlon for a selectlon on the attrlbutes of RJ and for 
some Y cPl. Z CPJ (Y=KlY , Z=KJZ . dom(Ki)=dom(KJ) and dom(Y )=dom(Z )). -dzsloznt constraznts (DISJS) 
Rl[Y] dis) RJ[Z], where Rl and RJ belong to different views, Y=Kl, Z=KJ and dom(Kl)=dom(K1), -contaznment 
constraznts (CONS) Rl[Y] con RJ[Z], where Rl and RJ belong to different views and one of the followmg 
condltlons holds 4 for some ##Y CPI, ##Z CPJ (Y=KlY , Z=KJZ . dom(Ki)=dom(KJ) and dom(Y )=dom(Z )). 
b) (Y=Kl and (ZCKJ or ZCPJ)) or (Z=KJ and (YcKI or YCPI)), In order to give the semantws of these mtegratlon 
constramts we need the notlon of an extended database scheme An e&#38;ended database scheme D 1s a triple 
D=<qClI>, where <NC> IS a proper database scheme which IS extended by a finite set of mtegratlon constraints 
I A database d over R IS an znstance of the extended scheme D, lff dcsat(C)nsat(I), where sat(Rl[Y] Id 
RJ[Z]) =sat(R1[Y]cRJ[Z])nsat(RJ[Z]CRl[Y]), sat(Rl[Y] con RJ[Z]) =sat(Rl[Y]CRj[Z]), sat(Rl[Y] dls) RJ[Z]) 
=sat(Izl[Y]IIRJ[Z]). d=(rl, ,rm)Esat(Rl[Y] se1 (b RJ)[Z]) <==> n[Y]=(a, rJ)[Z] sat(I) = n,,pat(l) Again, 
the set of all anstances of D 1s denoted by I(D) Remarks Sometimes we will regard a proper database scheme 
D=<RiC> as an extended database scheme D=<aCjI> with I=#. and vice versa We note that we do not assume 
any impllclt con-nections and relatlonshlps through names of attn-butes or relations Although equal names 
surely indicate possible connections, they should expla-cztly be specified Besides the posslblhtles to 
specify connections and relatlonshlps between the views through mtegratlon constramts, there IS the addltlonal 
posslblhty to add several manager views to the set of all views These manager views can then be connected 
with the other normal views through additional integration constraints In our approach, we ~111 not dlstmgulsh 
the different types of views Note, that for some integration constraints, namely DISJs and CONS of the 
form b), there exist correspondmg integrity constramts which conform to the restnctlons, required for 
proper database schemes These are called szmple zntegratwm con-straants. whereas the others are called 
pure antegrataon constraants So. pure integration con-straints are more powerful than the integrity con-stramts 
that are used m proper database schemes They are needed to describe situations in which even properties 
of objects are redundantly seen in different views, whereas these sltuatlons should be avoided within 
a single, proper database scheme 2 4 CONFLICTFREE VIEWS Now, we are able to give a precise defimtlon 
of what we understand by the conflictfree combmatlon of several views to describe all valid global sltuatlons 
Let Vl=<RlICl>, ,Vn=<RnlCn> be a set of proper data-base schemes with pan-wise disjoint sets of relation 
schemes Furthermore, let I be a finite set of mtegra-tion constramts over Vl, .Vn The combanataon of 
Vl; ,Vn wath respect to I 1s the extended database scheme Comb(V1. ,Vn,I) =<RlClI>, where R = u ,=, ,@ 
and C = U,=, Cl We often write Comb Instead of Comb(V1 Vn 1) whenever Vl ,Vn and I are understood Instances 
of Comb are also called valad global satuataons Thus, a valid global sltuatlon 1s a combmatlon of valid 
vlew-instances which additionally satisfies all integration constraints Naturally, a user of a specific 
view expects that every instance of his own view IS represented by at least one valid global sltuatlon 
If there exists an instance of a view that cannot be combined with others to form a valid global sltuatlon, 
then we argue for assunung at least one of the views 1s not correctly specified For it allows a view 
database that 1s meaningless with respect to the whole application Or, much more harmfully, there exist 
conflicts between the views However, both cases should be avoided This motivates the followmg definitions 
Let Comb=<qCiI> be the combmatlon of VI, ,Vn with respect to I Furthermore let d=(rll. ,rll,, , , ml 
ml,) be an instance of Comb, where i-11, ril, are associated to the relation schemes of Vi For l<lsn, 
theprolectaon of d to Va 1s defined by d[Vl] =(nl. ,ril,) Snmharly. the pr&#38;ectaon of I(Comb) to Va 
1s defined by I(Comb)[Vl] =[d[Vl] 1 dcI(Comb)j The vzews Vl. , Vn are conflactfree wath respect to I, 
off for all iE[ 1, .nl I(Comb)[Vl]=I(Vl) In the known literature, conflicts between the views are often 
informally described and simply reduced to be nammg conflicts We note that our formal notion of confhctfreeness 
only depends on structural connec-tions between the views, while different user groups are still allowed 
to choose their own appropriate names Example (continued) It IS easily shown that the views of our example 
are conflictfree with respect to the given set I of integration constraints Any instance of any view 
can obviously be extended according to I, m order to form a valid global situation, so that I(Comb)[Vl]=I(Vi) 
is satisfied for all views Vl .  2 5 INCLUSION AND EQUIVALENCE OF DATABASE rmmmallty of G To sum up, 
we have the followmg SCHEMES definition Next, we motivate our notion of mcluslon and equivalence of database 
schemes which we believe to be suitable m the field of view integration In the litera-ture, one finds 
several approaches to this problem, for instance [AABM], [Conn]. [Hull], [Rlss] We use a slightly modified 
version of weakly included as defined by Atzem/Auslello/Batml/Moscarml [AABM] Intultlvely, a database 
scheme G supports another database scheme V, If there exists a mappmg f which associates every instance 
gel(G) with an mstance f(g)EI(V) Additionally, f(I(G))=I(V) is required. so every mstance of V IS supported 
by at least one instance of G In the field of view integration only instances of a global scheme G are 
physlcally stored, while the corresponding view-instances should easily be computed via f Thus, we further 
require that f 1s given by an expression of the relational algebra More precisely, f IS an n-tupel of 
queries f=(fl, ,fn), where f(g) =(fl(g), ,fn(g)) This leads to the followmg definitions Let V=<IRlrXll. 
,RniXnlllC> and G=<iRl rXl l. , Rm [Xm ] jiC+ be two database schemes --G supports V (or Vu ancluded 
an G). denoted by VsG, lff there exists a relational query f=(fl, ,fn) f(I(G))=l(V) G and V are equavalent. 
denoted by V=G lff V<G and Gz.# These definitions are obviously extended to include extended database 
schemes Now suppose, a global scheme G supports a view V via f and only the instance g of G 1s physically 
stored A query q against V can be evaluated by first using f to compute the corresponding view instance 
v =f(g) and thereafter, the desired answer q(v) IS computed But much more efficiently, we ~111 first 
take the complete query qof and optmuze It to get an equivalent query q against G which IS then evaluated 
to the answer q k)=qb) 2 6 THE FORMALIZED VIEW INTEGRATION PROBLEM Now, we motivate our formal descrlptlon 
of the view integration problem Let Vl .Vn bk the set of views that have to be integrated and let I be 
the corresponding set of mtegratlon constraints, specifying the connections between the views A global 
database scheme G 1s sought which describes all valid global situations and simultaneously supports all 
views Obviously, Comb(V1 ,Vn,I) 1s such a database scheme, but it 1s rather useless as a global scheme 
because of several deficlencles Comb includes many comphcated integration constramts On the one hand, 
these constraints cause avoldable redundancy m the instances of Comb which makes them rather mefficlent 
to be stored On the other hand, m case of updates, additionally all mtegratlon constramts have to be 
checked which 1s rather difficult and inefficient, too To avoid these dlfficultles, we demand G to be 
a proper database scheme without integration con-straints, simultaneously supportmg all views, 1 e , 
CombsG This requirement implies the existence of a query f agamst G such that f(I(G))=I(Comb) Moreover 
f 1s also ezplzcztly needed for the transformation of queries against the views. as described above Fmally. 
we believe GsComb to be another appropriate property of the desired global scheme G. because instances 
of G should only represent such mformatlon, that 1s really used m valid global sltuatlons and nothmg 
else So, this requirement assures a kind of Let Vl, ,Vn be a set of proper database schemes and let I 
be a set of corresponding integration constraints A solutzon to the vzew zntegratzon problem (given by 
Vl. ,Vn and I) IS a pair (G,f), where a) G 1s a proper database scheme, b) Comb-G, c) f 1s a relational 
query such that f(I(G))=I(Comb) We finish this section with a simple result, showing that m case the 
views are confllctfree, a solution to the view integration problem can really be used to support all 
views Proposition 2 1 Let Vl, .Vn be a set of confhctfree, proper views with respect to a set I of integration 
con-straints Furthermore, let (G,f) be a solution to the given view integration problem Then G supports 
every view, 1 e , VlsG, for i= 1, ,n Proof straightforward by showing Vl&#38;omb m case the views are 
conflictfree .  3 THEINTEGRATIONMETHOD 3 1 INTRODUCTION In this paragraph, we develop our method to 
solve view integration problems which IS based on a more gen-eral philosophy for database design [Bask] 
The required properties of a solution are split into a basic property r that 1s easy to achieve and an 
addl-tlonal property R which 1s much more difficult to achieve In a first step, an mltlal design satlfymg 
the basic property 1s produced In a second step, this ml-teal design 1s improved step-by-step by local 
transfor-mations which ehmmate forbidden substructures until the additional property IS satisfied, while 
the basic pro-perty 1s still preserved In our particular case, we have a set Vl, Vn of proper database 
schemes and a set I of corresponding integration constraints A solution to the given view integration 
problem 1s a pair (G,f), and we use - as basic property I ((G,f)) <==> G=<RICII> IS an extended database 
scheme such that G=Comb and f IS a relational query against G such that f(I(G))=I(Comb). - as additional 
property n((G,f)) <==> G 1s a proper database scheme, - as forbidden substructure an integration constraint 
ICI  In this particular case, the first step of the above design philosophy IS rather trivial Obviously, 
(Comb,ld) already satisfies the basic property, where id denotes the identity query against Comb So, 
we will use (Comb,ld) as the mitral design which has to be improved by the second step The basic notions, 
needed for the formal defimtlon of the desired local transformations, are shortly described by using 
our former example Example (continued) The followmg relation schemes and the corresponding integration 
constraint form a local part of the extended database scheme Comb Employees[m,Name,Address.Date,Dlv] 
Salarles[&#38;Id,Name Sal,#Acc] and Employees[#Emp Name] Id Salanes[#Id Name] This ldentlty constraint, 
fornung a forbidden substruc- ture, can simply be ehmmated by merging both relation schemes together 
to get a new one representing both old schemes Emp-Sal[lEmp.Name Address,Date.Dlv Sal #Act] This transformation 
not only ehmmates the undesired Identity constraint. but simultaneously avoids the redundancy induced 
by it . There are smuhar transformations for all other kmds of integration constraints For instance, 
a selec-tion constraint RlrKlPll se1 cb RI)IKIZ~ will be ehm-mated by removmg the*red&#38;danc ;eiailon 
scheme RI A containment constraint Rl[KlY] con RJ[KJZ] will be slmpllfied by removing the redundant attributes 
Y m Rl Finally, a simple integration constraint 1s ehmmated by replacing it by its equivalent integrity 
constraint But we are still faced with another problem, because whenever a relation scheme IS changed 
by such a transformation, we have to guarantee that all other constraints, belonging to this scheme, 
can be transformed correspondmgly That IS, m general the relevant local part of an extended database 
scheme, changed by a transformation, is somewhat larger than it 1s indicated by the above example So, 
m general a transformation 1s divided into the fol- lowing steps choose an integration constraint that 
should be elunmated, compute the set of all constraints (1 e , integrity and integration constraints). 
formmg the relevant local part for the intended transformation, check, whether the above set of constraints 
can be transformed correspondmgly, finally, perform the complete transformation Most of those constraints 
that form the relevant local part of an intended transformation can easily be transformed correspondmgly 
However, sometimes there are some so-called disturbing constraints, that cannot be changed Havmg the 
above proposed transformations m mmd, we can give a simple syntactl-cal characterization of those disturbing 
constraints Let B be a set of constraints (1 e , mtegrlty or mtegra-tlon constraints), and let 1 be an 
integration constraint dut&#38;nng(B 1) = {bcB 1 b#l, b refers to both RJ and Rlj. If I=RJ[KJY] Id Rl[KlZ], 
 [be:B 1 b#l. b refers to RJ~, if I=RJ[KJPJ] se1 (b Rl)[KlZ], [bcB 1 b#l, b refers to both RJ and to 
an attrlbut of Yj, if I=RJ[KJY] con Rl[KlZ] and Y, Z+I otherwise 1 not-cf&#38;urbzng(B,l) =B\dlsturbmg(B,l) 
tJ In case there exist dlsturbmg constraints, an intended transformation 1s performable only if those 
constraints are redundant More formally, let D=<RlCII> be an extended database scheme and let 1 be an 
mtegratlon constraint, according to an Intended transformation performable(D 1) <==> 14 and not-dlsturbmg(CuI,l) 
I= dlsturbmg(CuI,i), where I= denotes @ate logical lmphcatlon [FaVa]  3 2 THE SCHEME TRANSFORMATION% 
Now, we will give a precise definition of the local transformations that are used to solve view mtegratlon 
problems Let EDBS be the set of all extended database Schemes which are denoted by D=<RICII> or D =<R 
plI > 1) ----->,d c EDBSxEDBS, where D ----->,d D <==> there exists an integration constraint I=RJ[KJY] 
id Rl[KlZ], such that KJPJ~(P~\Z)=#, performable(D,l). R =R\~RJ,RIJ u ~RJ[KJPJ(PI\Z)]J, C =lb lthere 
exists an bEnot-dlsturbmg(C,l) and b results from b after the renammg according to (Rl[KlZ] ==> RJ[KJY])J, 
I =lb lthere exists an benot-dlsturbmg(I,l)\Ilj and b results from b after the renammg according to (Rl[KlZ] 
==> RJ[KJY])~, 11) ----->se, c EDBSxEDBS, where D ----->se, D <==> there exists an integration constraint 
~=RJ[KJPJ] se1 (b Rl)[KlZ], such that performable(D,i), R =R\[RJJ, C =not-disturbing(Q), I*=not-dlsturbmg(I,i)\Ilj, 
 111) ----->con c EDBSXEDBS. where D ----->con D <==> there exists an Integration constraint I=RJ[KJY] 
con Rl[KlZ], such that y. zz$J, performable(D,l). R =R\IRJJ u [RJ[KJ(PJ\Y)I, C =not-disturbing(Q), I 
=not-dlsturbmg(I,l)\llj u {RI[KJ] con Rl[Kl]J,  1v) ----->s,m c EDBSXEDBS. where D ----->s,m D <==> 
there exists a simple mtegratlon constraint 1. such that performable(D,l), R =R C =Cu[c,{. where c, 1s 
the integrity constraint equivalent to 1, 1 =1\{1J.  4 --> c EDBSxEDBS, where --> = ----->,d ----->sel 
----->con ----->a,m Remarks For slmpllclty of notation, we choose the above nammg conventions in the 
----- rd- transformations Sometimes other names may be more sultable for the new relation scheme, but 
of course, later renammgs are still possible Note, that a selection constraint can only be ellm-mated, 
if a complete relation scheme stands on the left hand side of the selection constraint Hence often, one 
first has to remove some attn-butes by transformations of ---> con before a ----> .e,-transformatlon 
can be used Kent also studies scheme transformations [Kent] but with another aim m mmd His transformations 
should help covermg a wide range of possible different design optlons whereas the above transformations 
can only be used to simplify data-base schemes by elnnmating complicated mtegra-tion constraints Now, 
we are able to show that the above scheme transformations have all those propertles that are demanded 
by our proposed design approach Theorem 3 1 Let D and D be two extended database schemes such that D-->D 
Then D=D and a query f against D with f(I(D ))=I(D) can effectively be computed from the elnnmated mtegratlon 
constraint Proof see Appendix . This Important result shows that the transforma-tions can be used to 
slmphfy the mltlal design (Comb,ld) until the addltlonal property R IS achieved, while the basic property 
I 1s preserved The whole method IS presented again as a frame of a program PROGRAM Integrate. INPUT (*a 
view integration problem*) Vl. ,Vn proper database schemes, I set of iriteg+ation constraints. OUTPUT 
(*a solution to the view integration problem+) G proper database scheme, -f query against G, VAR stop 
BOOLEAN, Corollary 3 2 Let Vl. .Vn be a set of proper database schemes-and let 1 be a set of correspoidmg 
mtegratlon constraints Furthermore, let Comb=Go--> -->Gn=G be a sequence of scheme transformations, where 
G IS a proper database scheme For i=l, ,n let fi be a query ;;Ez;trnGl, where f(I(Gl))=I(G(l-1)) accordmg 
to the last Then (G.f) IS a solution to the given view integration problem, where f =flo ofn Proof by 
induction and the above theorem . In determmmg a sequence of scheme transforma-tlons to simplify an extended 
database scheme to a proper one, ---> ,i,transformatlons can be ignored until only simple mtegratlon 
constraints are left This 1s a special case of the next theorem Theorem 3 3 For l=O, ,n, n>O, let Dl 
be some extended database schemes such that Do-->Dl--> -->Dn Then there exist 1. mcN,, and some extended 
database schemes Dl , where Oclrm4n, Do -->Dl --> -->Dm . Do =Do, Dm =Dn, (Dl .D(l+ 1) ) E -->\----->sim 
for 0~14 (Dl ,D(l+l) ) E ----->.,m for l<i<m .Proof see the full paper [BlCo] 33 THEINTFiGRATIONYZl'HOD 
Now, we sketch our mtegratlon method, as developed above In the first step, (Comb,ld) 1s taken to be 
the ml-teal design satisfying the basic property r In the second step, we try to achieve the addltlonal 
property Q by ehmmatmg all mtegratlon constramts with our local scheme transformations According to the 
last theorem, we first try to elimmate all pure mtegratlon constraints and thereafter, the remamdmg simple 
ones are transformed In this second step, there IS a kind of nondeter- mmistic choice. when selecting 
any performable transformation We propose, that this choice should be guided mteractlvely by the designer 
Often, It 1s useful to select those transformations, which result m the most significant simplifications 
I e , ---> sai transformations should have the highest pnonty, fol-lowed by ----->,d-transformatlons, 
which are followed by transformations belongmg to ----->con Whenever there are still pure mtegratlon 
con-straints left, although no correspondmg transformation 1s performable, an mteractlve exceptlon handlmg 
must be started to solve the sltuatlon manually or to stop the integration for a more detalled mvestlgatlon 
of the problem BEGIN stop = FALSE, READ(V1, ,Vn,I), G =Comb(Vl, ,Vn,I), f =ld, WHILE there are still 
pure integration constraints left AND (NOT stop) DO BEGIN SELECT ANY pure integration constraint 1 such 
that performable(G,l). IF any such pure integration constraint could be selected THEN oerform the corresDondine 
transformation on G and update f accor&#38;ngly - ELSE exectlon-handlmg(stop), (*stop 1s possibly changed 
to TRUE l )  END, (*WHILE*) IF stop THEN WRITE( Stopped dunng exception handling ) ELSE BEGIN transform 
the remamdmg simple integration constramts, WRITE(G,f), END, END The View Integration Algorithm Example 
(continued) At first, all selectlon constraints can be ehmmated by the correspondmg ----> ,,,-transformations 
because the disturbing dlslomt constraints are all redundant Thereafter, an ----->,d-transformatlon can 
be used to ehmmate the Identity constraint Snndarly, the containment con-straint IS slmphfied by the 
associated ---> cnn-transformatlon At least, the remamdmg slm- --._ ple integration constraint 1s transformed 
to Its equivalent mtegnty constramt and we get the followmg solution (G.f) G Employees II-1 Name 1 Address 
1 Date 1 DIV [ Sal ( #Act Articles Name ( Price Stock 11 Ypro&#38;j Qty Customers II m 1 Name I Address 
Orders [I LOrder ( #Customer 1 Ord-date 1 Del-date Order-contents I( &#38;Q&#38;r 1 YAr&#38;&#38; Qty 
Stock[#Prod]cArtlcles[#Artlcle], Orders[#Order]cOrder-contents[#Order], Orders[#Customer]cCustomers[#Customer], 
Order-contents[#Order]cOrders[#Order], Order-contents[#Artlcle]cArtlcles[#Artlcle] f IS chosen according 
to the followmg assignments (The relation names on the left side belong to the rela-tion schemes of Comb, 
whereas the names on the right side belong to the relation schemes of G ) Vl Employees <--Employees[#Emp,Name,Address 
Date,Dlv] V2 Salarles <--Employees[#Emp,Name,Sal,#Acc] Pay-roll-emps <--Employees)[#Emp,Address] (%= 
pay roll V3 Articles <--Articles. Customers <--Customers, Orders <--Orders Order-contents <--Order-contens, 
Marketing-emps <-- Employees)[#Emp,Name,Address] hhv= marketmg v4 Stock <--(Stock W IProd=IArt,cle Artlcles)[#Prod 
Name,Qtyl, Stock-emps <--Employees)[#Emp,Name,Address] (%= stock Now, G can be used as a global database 
scheme, sup-porting the views of all different dlvislons and with the help of f queries agamst any of 
these views can easily be translated into queries against G . The mam goal of our work has been to develop 
a computer-aided view integration tool, based on a strictly formal background Therefore m Sectlon 2, 
we have chosen a data model with a clear formal semantics. to specify both the user views and the global 
database scheme Then we have introduced Integration con-straints as a formal means for speclfymg the 
connec-tlons and relationships between the views These mtegratlon constraints are strictly dlstmgulshed 
from simple integrity constraints, because of a different intended meaning Then we have given a formahzed 
notlon of conflictfreeness of a set of views with respect to a speclficatlon of their connections and 
relation-ships After mtroducmg a formalized concept of mclu-slon and equivalence of database schemes, 
we have presented a complete formal descrlptlon of the view mtegratlon problem Particularly, this clarifies 
the details 1) -5). as mentioned in Section 1 On this formal basis, we have developed our integration 
approach, which starts with the combma-tlon of all views and the specified connections and rela-tionships 
This mltlal design IS slmpllfied step-by-step by local scheme transformations until a solution to the 
given integration problem 1s found In Section 3. we have presented those local, equivalence preserving 
scheme transformations and proved their basic proper-ties Finally. we have sketched our algorithm for 
a computer-aided view mtegratlon There are still vamous problems left open, which should be mvestlgated 
m some further research Decmon of Confhctfreeness When using our approach m real world apphcatlons, one 
surely wishes for an automated declslon algorithm for the conflictfreeness of the specified views with 
respect to the correspondmg set of integration constraints Unfortunately, conflict-freeness m general 
IS undecidable [Conv2], so that we have to look for a decidable subclass which 1s still of great practical 
relevance In all other cases conflictfreeness must still be proved manually We note that the decision 
of conflictfreeness is closely related to the followmg problem lmphcatlon of Constramts When checking 
whether a transformation according to a given Integration con-straint 1 1s applicable, we have to decide 
whether performable(D,l). 1 e , to decide the lmpllcatlon problem noLdisturbmg(Cu1) I= dlsturbmg(Cu1) 
(see 3 1 ) These lmphcatlon problems are known to be rather difficult [CaVl]. [CFP], [ChVa], (FaVa], 
[Mltc] Indeed, m [Conv2] finite logical lmphcatlon for the used class of integrity and mtegratlon constraints 
1s shown to be undecidable m general So, for practical reasons, we propose to use an efRclently Implementable, 
mcomplete version weakly-performable(D,l) with weakly-per-formable(D,l) ==> performable(D,l) . which 
should be able to show the logical lmphcatlons at least for simple, often occurmg special cases, using 
suitable heurlstlcs Prehmmary results to these imphcatlon problems can be found m [Convl] Updates through 
Views In our approach, we solely con-sidered static aspects of database design For concrete real world 
apphcatlons, dynarmc aspects, especially updates through views, have to be Investigated, too This problem 
alone 1s known to be rather comphcated and IS still a topic of current research [CoPa], [FuCa], [Kell], 
[Stle] Currently, we are involved m lmplementmg a pro-totype design tool for both view modellmg and view 
integration  APPENDIX Proof of Theorem 3 1 Let D=<RlClI> and D =<R IC ll > be two extended data-base 
schemes such that D-->D According to the ehm-mated integration constramt, there are several cases Case 
1 D----->,,D according to I~RJ[KJY] id Rl[KlZ] W I o g , we assume that R, R . J and 1 are of the followmg 
forms R=[Rl[KlPl], ,R(n-l)[K(n-l)P(n-l)],Rn[KnPn]j, R =IRl [Kl Pl ]. ,R(n-l) [K(n-l) P(n-l) ]j, J=n-1 
and I=n Then we have Rk =Rk, for k= 1, ,n-2, KJ =KJ and PJ =PJ(PI\Z) Now, define queries f and f as follows 
f Rk <--Rk , for k=l, ,n-2, RJ <-- RJ [KJPJ] and Rl <--RJ [KJY(PI\Z)] f Rk <--Rk, for k=l. ,n-2. RJ <-- 
(RJ MKIyzmz RNKJPJ(PWI At first, we prove a) f (I(D))=I(D ) C For d=(rl, ,r(n-2),rJ,rl)d@) and d =(rl 
, ,r(n-2) ,rJ ) =f (d) we have to show that d EI(D ) Since d satisfies 1 rJ and rl are consistent, 1 
e , they Join completely So, we have rJ [KJPJ]XJ and Morerd;~Y(PWl~r~ d satisfies the FDs RJ KJ->PJ and 
RI Kl->PI and rJ 1s the result of the equlJom of rJ and r1 on the superkeys KJY and KIZ Thus, d satisfies 
the FD RJ KJ->PJ(PI\Z) and we have rJ [KJPJ]=rJ and rJ [KJY(Pl\Z)]=rl ((*) Note this lmplles f(f (d))=d, 
for all dcl(D) ) Since rJ contains rJ and rl as proJections. and since d satisfies C and 1. it follows 
that d satisfies the mhented constramts C and I , 1 e d EI(D ) 3 For d =(rl ,r(n-2) rJ )EI(D ) we define 
d=(rl, .r(n-2),rJ rl) =f(d ) We have to show that dcI(D) and f (d)=d ((**) Note, this lmphes f (f(d ))=d 
. for al1 d EI(D )I) Since d satisfies the mhented constraints C and I , and since rJ and r1 are sultable 
proJections of rJ , d satisfies not-dlsturbmg(CuI,l)\[lj Moreover, 1 1s obviously satisfied by d, and 
hence all con-straints m CuI, since not-dlsturbmg(CuI,l) I= dlsturbmg(CuI,l) I e , dEI(D) Since both 
proJectlons rJ and r1 include the key attnbutes, rJ IS losslessly decomposed into rJ and rl. ie, rJ =(rJ 
t=&#38;,,=,, rI)[KJPJ(Pl\Z)] Thus f (d)=d Now, we prove b) f(I(D ))=I(D) From a) it follows that f(f 
(I(D)))=f(I(D )) and usmg (*) we get I(D)=f(I(D )) To summarize a) and b), we have D=D which completes 
Case 1 Case 2 D----->,,D accordmg to ~=RJ[KJPJ] se1 (b RM W Define f and f as follows f Rk <--Rk for 
k#J. RJ <-- (a,, Rl )[KlZ] f Rk <--Rk, for k#J Again, it IS easily shown that the queries have the required 
properties Case 3 D-----> conD according to I=RJ[KJY] con RI[KlZ] Define f and f as follows f Rk <--Rk 
. for k#J, RJ -c-- (RJ ~ImRl IIK~Z(P~\Y)I f Rk <--Rk, for k#J, RJ <-- RJ[KJ(PJ\Y)] Again, it IS easily 
shown that f and f have the required propertles Case 4 D----->,,,D according to a simple integration 
constraint In this case D and D are obviously equivalent, where f and f are the IdentIty queries . Remarks 
In all cases, f and f are inverses of one another Hence, D and D are equivalent even according to some 
stronger notions of equivalence, as for instance presented m [AABM] and [Hull] Only a subset of the relational 
operations are used to define the queries f and f f IS defined using proJections, eiulJoms and selections 
and f 1s defined using only proJections and equlJoms This will be Important when consldermg the view 
update problem  REFERENCES <RefA>[ AABM] P Atzem, G Auslello. C Batml, M Moscarini, Inclusion and Equivalence 
between Relational Database Schemata , Theoretical Computer Science 19, 1982 267-285 [ BaLe] C Batml, 
M Lenzenm, A Methodology for Data Schema Integration in the Entity-Relatlonshlp Model . m Entitv-Relationshm 
ADuroach to Softwaie Engmeeimg . C G D&#38;s,-.!j JaJodia, P A Ng, R T Yeh (eds ), North-Holland, 1963, 
413-420 [BW J Blskup. U Dayal, PA Bernstem, Syntheslz-mg Independent Database Schemas , ACM-Slgmod International 
Conference on Manage-ment of Data, 1979, 143-151 [BlCo] J Blskup, B Convent, A Formal View Integra-tlon 
Method , Forschungsberlcht Nr 206, Umversltat Dortmund. 1985 [Blsk] J Blskup, Entwurf von Datenbankschemas 
durch schrlttwelses Umwandeln verbotener Tellstrukturen . GI-EMISA-Fachgespri+ich Entwurf von Informatlonssystemen 
-Methoden und Modelle , 1965. 130-146 C Batml. M Lenzenm. M Moscanm. Views Integration , m Methodology 
and Tools for Data Base Design , S Cen (ed ), North-Holland, 1983, 57-84 [ Brod] M L Brodle, On the Development 
of Data Models , in On Conceptual Modellmg . M L Bro-die, J Mylopoulos, J W Schrmdt (eds ) Sprmger-Verlag, 
1984, 19-46 [Cavil MA. Casanova, V.M.P. Vidal, Towards a sound View Integration Methodology , 2nd ACH-Sigact-Sigmod 
Symposium on Principles of Database Systems, 1983, 36-47. [CFPI M.A. Casanova, R. Fanin. C.H. Panadimitriou. 
Inclusion Dependenci&#38; and their-Interaction with Functional Dependencies , 1st ACM-Sigact-Sigmod 
Symposium on Principles of Database Systems, 1982. 171-176. [ChVa] A.K. Chandra, MY. Vardi. The Implication 
Prob-lem For Functional And Inclusion Dependencies Is Undecidable , SIAM J. Comput.. Vol. 14. No. 3, 
671-677, 1985. [Coddl]E.F. Codd, A relational Model of Data for large shared Data Banks , Comm. ACM 13 
(8). 1970, 377-387. [Codd2] E.F. Codd. Further Normalization of the Data Base Relational Model , in Data 
Base Systems , R. Rustin (ed.). Courant Computer Science Sym-posia 8. Englewood Cliffs, N.J., Prentice-Hall, 
1972, 33-64. [ Conn] I T.S. Connors, Equivalence Of Views By Query Capacity , 4th ACM-S&#38;act-Sinmod 
Svmoosium on Pri&#38;iples of Database Systems, i985, 143- 148. [Convl ] B. Convent, Ein fonnaler Ansatz 
zum rechnergestiitzten Entwurf von Datenbank-schemata mlttels View-Integration , Diplom-arbeit, Universitlt 
Dortmund. 1984. [Conv2] B. Convent, Unsolvable Problems Related To The View Integration Approach , in 
preparation. [CoPa] S.S. Cosmadakis, C.H. Papadimitriou, Updates of Relational Views , 2nd ACM-Sigact-Sigmod 
Symposium on Principles of Database Systems, 1983,317-331. CFagil R. Fagin, Multivalued Dependencies 
and a New Normal Form for Relational Databases , ACM TODS 2 (3) 1977, 262-278. [FaVa] R. Fagin. M.Y. 
Vardi. The Theory of Data Depen-dencies -A Survey , IBM Research Report RJ 4321, IBM Research Laboratory, 
San Jose, 1984. [ FuCa] A.L. Furtado, M.A. Casanova, Updating Rela-tional Views , Technical Report 020, 
IBM do Brasil, 1984. [Hull] R. Hull, Relative Information Capacity of Sim-ple Relational Database Schemata 
, 3rd ACM-Sigact-Sigmod Symposium on Principles of Database Systems, 1984, 97-109. [Ken] A.M. Keller, 
Updating Relational Databases through Views , Dissertation, Stanford Univer-sity, 1985. [Kent] W. Kent, 
Choices in practical Data Design , 8th VLDB. 1982. 165-180. b-4 V.Y. Lum et. al., 1976 New Orleans Data 
Base Design Workshop Report , 5th VLDB. 1979, 328- 339. [Maie] D. Maier, The Theory of Relational Databases 
, Computer Science Press, 1983. [MaWi] R. El-Masrl, G. Wiederhold, Data Model Integra-tion using the 
Structural Model , ACM-Sigmod International Conference on Management of Data, 1979, 191-202. [Mitt] J.C. 
Mitchell, The Implication Problem for Functional and Inclusion Dependencies , Infor-mation and Control 
56. 1983, 154-173. [NaGa] S.B. Navathe, S.G. Gadgil, A Methodology for View Integration in Logical Database 
Design , 8th VLDB, 1982, 142-184. [Riss] J. Rissanen, On Equivalence of Database Schemes , 1st ACM-Sinact-S&#38;mod 
Svmnosium on Principles of Database Syst&#38;ns, 1982.23-26. [Stie] H. Stiefeling, Anderungen auf Sichten 
relation-aler Datenbanken , Diplomarbeit. Universitgt Dortmund, 1984. [TeFr] T.J. Teorey, J.P. Fry, Design 
of Database Struc-tures , Prentice-Hall, 1982. [Ullm] J.D. Ullman, Principles of Database Systems , Pitman, 
1982. [WiMa] G. Wiederhold. R. El-Ma&#38;, A Structural Model for Database Systems , Technical Report 
Stan-CS-79-722. Stanford University, 1979. [YNW] S.B. Yao, S.B. Navathe, J.-L. Weldon, An Integrated 
Approach to Database Design , Data Base Design Techniques I, Requirements and logical Structures, NYU 
Symposium New York, 1978. l-30. WHI S.B. Yao. V.E. Waddle, B.C. Housel. View Model-ing and Integration 
using the Functional Data Model , IEEE Trans. on Software Engineering, Vol. SE-8. No. 6, 1982, 544-553.</RefA> 
 407 
			

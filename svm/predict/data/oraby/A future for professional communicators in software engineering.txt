
 A Future for Professional Communicators in Software Engineering John K. Horberg Rensselaer Polytechnic 
Institute horbej @rpi.edu Introduction The major difficulties of creating good software are well documented, 
being almost universally agreed upon, and can be deseribed very briefly. Basically, since its beginning 
software engineering has suffered from prob­lems that result in software being late, over budge~ and 
not entirely satisfactory to its users. The professional software community is well aware of this image 
and has launched an agenda of finding the reasons for and creating solutions to those problems. One result 
of that agenda is that a large number of technical aids have been and are being created new softxvare 
paradigms designed and advocatd software development tools developed and standardized, and soft­ware 
engineering environments reconsidered and rede­signed to accommodate specialized requirements. A second 
result is that communication is taken more seri­ously now than in the pas~ Assessments of the need for 
effective communication in softwme development teams, the importance of understandable software documents, 
the need for customers and users to be involved in the engi­neering process, and recommendations that 
professional communicators participate in software engineering appear rather often in even the most technical 
computer journals. At the same time, the technical communication community is expressing a strong interest 
in applying its members expertise to the efficient design and develop­ment of software. Professional 
communication journals, anthologies, and proceedings earnestly profess that techni­cal writers should 
be involved in software engineering projects in ways other than the traditional documentation producing 
role. This seems a formidable task, however. Redish and Ramey [1993 ]remind us tha~ especially in lean 
Permission to copy without fee all or part of this material is granted provided that the copies are not 
made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association of Computing 
Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. DOC 94-10/94 
Banff, Alberta, Canada @ 1994 ACM 0-89791 -881 -619410010 ...$3.50 economic times, technical communicators 
face pressure to justify their existence even within their own departments. If they are to justify a 
more active role in an outside field such as software engineering, communicators need to make a strong 
case for their ability to measurably add value to those projects. They might do so in terms of shortening 
software development time, freeing software engineers to do their work more effectively, in terms of 
better quality products, and, overall, in terms of their pres­ence resulting in software tlat is free 
from the above prob­lems. The point here is that merely looking at software engineering and saying, I 
think we can help here is sure to be less successful than a rigorous agenda of specifying problem areas 
and showing precisely how communicators can help improve these areas. This paper s goal is not to convince 
the software community that communicators should be involved in the software engineering process-this 
seems to be well accepted already. Recent survey research indicates that the software industry would 
gladly add trained technical communicators with computer science backgrounds to their software development 
teams [but] for the technical writing professional to help solve the software problems plaguing the industry, 
the professional must first have a demonstrable understanding of the theory and process that drive software 
development [Bresko, 1991]. In p-then, this paper is a call for technical communicators to learn more 
about software engineering: a challenge to place themselves accurately witim the framework of software 
environments. Communicators need to be able to show exactly where they fit into software engineering-how 
they can improve software products and software develop­ment processes. That is, they need to be able 
to make spe­cific proposals and detailed plans selling software engineering on their ability to help 
the field progress. The purpose of this paper is to specify areas in which technical communicators should 
become more competen~ and in which software engineering managers should consider involving communicators. 
If we can pinpoint areas where communication is particularly difficult-where engineers, customers, and 
other participants can not understand each other or tend to interpret meanings differently, we should 
be able to create solutions to those problems. By not understanding the problems thoroughly we allow 
them to perpetuate. In working toward these goals I first present one explanation of how the problems 
of creating software come about and why they are difficult to overcome, stress­ing the need for communication 
in sofhvare engineering. Second, I present the results of my 1993 survey of software engineers and customers 
regarding their communication practices and satisfaction with sofhvme engineering. Finally, I follow 
up on those issues by specifying areas in which communicators am likely to enhance software engi­neering. 
 Part One: Difficulties of Software Engineering Why is it so d.iflicrdt to aeate good software? One 
reason, according to Brooks and Farkas, is that software is a complex, intellectual, and intangible product 
and, there fore, necessarily difficult to produce. Brooks [1987] writes that software s inviability makes 
it hard to visualize a program s structure that it impedes the design process and creates communication 
dimdtk that result in the already-mentioned product ftaws, cost overruns, and schedule delays. Farkas 
[1991] adds that since software consists of many highly integrated elements it is inherently prone to 
failure. The hardest part of software develop­ment then, is the conceptual design work rather than cod­ing 
and testing the software. Brooks and Farkas also agree that lie a piece of writing, software is iniinkly 
rework­able. Brooks notes that software, unlike mechanical prod­ucts, is pure thought-stulY and can be 
changed at any time. Farkas adds that no materials have been cut no chemical processes have been hMate&#38; 
nothing need be declared complete until everyone is satisfied with it. Another dilli­culty lies in the 
fact that software engineers and customers are members of different professional communities, having 
different views of quality, different backgrounds, and dif­ferent areas of expertise. Correspondingly, 
software engi­neers and customers tend to have different perspectives of how quality is defined in a 
piece of software users often describe good software in terms of being easy to use and doing what they 
want it to, while developers focus on soft­ware that is technically correct and easy to design and cre­ate 
[Gillies, 1991]. Software engineers and customers appear to have different agendas, different views of 
soft­ware quality, different backgrounds and knowledge, and different goals. Bostrom [1989] sums up these 
differences (and resulting problems) quite clearly, stating that the par­ties involved bring different 
frames of reference to the situ­ation, e.g., they frame the world differently. If users and developers 
framed the world similarly, they would proba­bly have few problems in communicating with one another. 
Historically, then, customers have not had much input in creating the software they request [Spinas, 
1989]. Gillies [1991] agrees that a distinct communication gap exists between software engineers and 
customers: Tradi­tionally, the designers have assumed that they know best. Users have generally known 
that what they get is not what they wan~ but have been unable to communicate what they do want. They 
have also been blissfully unaware of the constraints under which developers operate. Researchers argue 
that software enginetm try to satisfy their customers needs but that considerable improvement is needed. 
Gould, Boies, and Lewis [1991] claim that engineers are enthusiastic about following a usability design 
process since doing so results in better software, but that such tech­niques are rarely used. The important 
questions, then, become What are these techniques? Why aren t they used? How can they be implemented? 
 The Complexity of Software Graham, et. al, [1982] argue that one of the most difficult problems facing 
softxvare engineering is that of evahating the performance of a proposed design before it is actually 
implemented . Conceptually, software engi­neers have to check their work against the specifications and 
against the customer s needs, both of which may change throughout the engineering process. Baber [1991] 
agrees, comparing software engineering unfavorably with classical engineering because, unlike mechanical, 
electri­cal, or civil engineers, software engineers am unabie to verify analytically, before actually 
building the object in question, that their design will satisfy the specifications. My argument however, 
is that improving software quaMy is not a simpIe matter of eliminating the errors that occur during engineering-not 
just a matter of creating techni­cally correct software. A successful software project requires engineers 
and customers to create a common image of the software to be built [Bostom, 1989]. Curtis, I@sner and 
Iscm [1988] conclude that constant communi­cation is needed for customers and engineem @ establish a 
mutual understanding of the software. Gillies [1991] adds that unless software users and engineers understand 
each other s goals, the final results are likely to please neither. Engineer and Customer Problems Still, 
a common criticism of the software industry is that it has focuses on building error-free software rather 
than creating software that works as users want it to. Tra­ditionally the engineer s job has been to 
collect customer requirements and create software to meet those require­ments. Most software maintenance, 
however, is needed because sofhvare engineers do not understand customer requirements [Ramamoorthy, et.al, 
1984], and much research concludes that engineers should put more effort into specifying and analyzing 
software requirements at the start of a project. Severe requirements problems, routinely cited in the 
journals, are in fact often caused by poor infor­mation-gathering techniques on the part of the software 
engineers [Curtis, 1988]. Donald Norman [1988] believes that software engi­neers often expect the user 
s mental model to be identical to the engineering design model. Eason and Harker [1988] indicate that 
software engineers often feel driven to develop the functional aspects of a software system (make it 
do as much as possible) and that this leads to dissatisfied customers This has resulted in a growing 
awareness that it is necessary to provide an appropriate level of function­tilty which can only be determined 
by understanding the requirements of target groups of users. Heckel [1984] advises that engineers are 
also used to working against adversaries who are logical, consisten~ and predictable. As such, they are 
used to putting formal procedures to work at completing a task. Research, however, suggests a need for 
tectilques that are informal, flexible, and people­oriented. Ultimately, software engineers are responsible 
for creating software that is not only technically correct but is truly useful to the customers. Engineers 
must take responsibility for implementing software engineering tech­niques that result in high quality 
software. If it is the engineer s responsibility to collect requirements, it is the customer s responsibility 
to provide those requirements. Sharnlin [1990] takes this view: the user is the expert concerning what 
is needed and should communicate these requirements clearly to the software producers. She adds that 
customers are responsible for understanding the costs and benefits of design proposals and for making 
their own decisions rather than relying on what the engineers tell them. Sharnlin finlher advises cus­tomers 
to insist that engineers provi&#38; understandable design proposats, rejecting umeadable documents. Cus­tomers 
also have to know when to let the engineer take ove~ going beyond specifying what you require, to speci­fying 
how to incorporate it into the design, will not only over-constrain the designers from fully applying 
their tech­nical expertise, but will result in a system that maybe both more expensive and less satisfactory. 
Others agree that customers are partly to blame for poor software. A frequent accusation is that customers 
produce valuable design information without passing it on to the engineers because they assume that it 
is not needed [Curtis, 1988]. Another complaint is that customers have unrealistic performance expectations, 
expecting perfect software without having to become involved in the process [Gilties, 1991]. Studies 
atso point out that software cus­tomers are not as involved in the engineering process as they could 
be, reporting that (for whatever reasons) engi­neers and customers too often work separately with little 
direct communication between them, that engineers do not seek feedback from customers, and that customers 
do not effectively communicate their needs to their engineers [Gillies, 1991; Gould, et. al, 1991; Spinas, 
1989]. The Need for Communication Software engineers may incorrectly assume that they are representative 
users of their products, avoiding the need for communication [Olson, 1991]. During a field study of a 
large university s attempt to implement a large database, Bostrom, acting as project manager, worked 
with tmtb the developers and the users of the database after three previous attempts to implement tie 
system had failed. The project was ultimately successful, but illus­trates an (apparently common) lack 
of communication txxween engineers and customers. Bostrom observed thrm instead of helping users build 
good models, developers got some ideas from users and then constructed the system with little feedback 
from users. When questions arose, the developers tended to fill in missing information based on their 
models rather than eliciting information from users. As a msu16 the final models embedded in the system 
reflected the developers perspectives rather than those of the users [BostoQ 1989]. Person-to-person 
communication reportedly bene­fits software engineering tasks, with fkquent informal communication improving 
the design quality [Geisler, 1991]. One explanation is that non-verbal signals found in face-to-face 
communication are valuable indicators of whether common ground is being reache~ allowing group members 
to form a common image of the product to k built [Krauss and Fussell, 1991]. Further, researched indi­cate 
that engineers and customers should work together actively-that simply exchanging information does not 
satisfy the requirements for a successful project [B@ker and Gr@nbec~ 1991; Doheny-Farin% 1992]. There 
is evidence, however, that software engineers are not in the best position to perform needed communica­tion 
tasks. Baker, Cheatham, and Green for example, rec­ommend moving toward more formal computer-assisted 
engineering methodologies, reporting that engineers should spend more time considering optimization issues 
and hence, do a better job [Baker, et. al, 1983]. Cohill [1991] echoes these sentiments, writing that 
it is au engi­neer s job to build systems that work comectly but that it is a designer s job to create 
systems that work as users expect it to. But the benefits of good communication can not be ignored. Face-to-face 
interaction between designers and customers results in higher quality software due to improved input 
from customers and increased attention from engineers [Gillies, 1991], and Bostrom [1989] believes that 
poor communication is consistently associ­ated with customer dissatisfaction, while effective commu­nication 
results in improved product quality. Others agree that poor quality software results in part from engineers 
misunderstanding a customer s intentions [Curtis, e~ al, 1988]. Ramamoorthy et. al, [1984] make this 
point by stat­ing: if programmers understood users requirements bet­ter, if they documented specifications, 
design, and code properly, and if they tested the system better before release, 78 maintenance would 
not be so difticult and costly. Part Two: Survey of Software Engineers and Customers Dfilculties in 
Communicating As mentioned earlier, software engineering is often viewed as a methodical process of ensuring 
that new soft­ware meets all customer requirements. Thus, software engineers prefer to deal with system 
requirements that can be specified precisely, and can be verilied and tested to check for compliance 
with the agreed-upon specifica­tions. This is one reason why effective communication techniqua are not 
often used m software development projects, even though research shows the need for and the value of 
such communication. A second mason has to do with the quality of shared information. Firs4 although communication 
behveen developers and users is consis­tently associated with improved user satisfaction, merely initiating 
communication does not result in better software [Bostrom, 1989]. Second, even when software designers 
take a user-centered approach to building software, they do not necessarily collect good information 
l@ming, 1991]. Finally, as Doheny-Farina [1992] reports the amount and clarity of information will not 
necessarily lessen uncer­tainty. .. communication based on transferring information is not enough. Research 
also indicates numerous human prob­lems when software engineers and customem do try to work closely together. 
When Curtis et-al, [1988] con­ducted personal interviews with the sofhvare engineering personnel of 17 
large software projects, interviewees indi­cated that customers did not understand the difficulty of 
the engineers job, did not consider the effects requested changes had on the rest of the software, and 
thought it easy for the engineer to implement changes. In addition, when developers and users meet they 
may lind that different values, work styles, even languages get m the way of com­municating [Gmdin, 1991]. 
Researchers indicate that sofhvare engineering suf­fers from stubbornly relying on traditional methods 
of development and failing to use effective communication techniques [B@ker, 1991; Bresko, 1991]. Cohill 
[1989] warns that it will not be easy to r~lace rigid engineering methods with flexible design processtx 
It is the uncer­tainty of the design process that is so troublig to those who do not understand itj yet 
that uncertainty is what leads to more elegant solutions. Given the professional mem­bership of software 
engrneers and the seeming inconsistent nature of personal communication, it seems natural that communication 
has been passed over m favor of technical solutions up until now. However, the suggestion that soft­ware 
engineers are better at engineering software than they are at communicating with customers, together 
with the established need for communication, seems to identify a huge niche for professional communicators. 
In an effort to gather spedic data on how real world software engineers and customers go about creating 
soft­ware and to uncover areasin which professional communi­cators could be most valuable m assisting 
in software engineering, I designed two questionnaires to collect infor­mation from software engineers 
and customers working m the Minneapolis/St. Paul area. [Horberg, 1993]. Each questionnaire was six pages 
long and asked 26 questions m the following areas: Demographics.  Collecting software requirements. 
 Creating proposals and designs.  Satisfaction with software engineering.  Suggestions for improvements. 
  Demographics I received completed questionnaires from 33 of the 50 software engineers and 17 of the 
30 software customem a 6690 and 56% return rate, respectively. The 33 partici­pating software engineers 
consisted of 79% men and 15% women. Most of the 17 participating software customers were men as well, 
with 65% men and 29% women. (A few members of each group did not report their gender.) Soft­ware engineers 
reported staff sizes rangrng from 1 to 50 software engineers with 8170 of responding engineers working 
with a relatively small staff of one to five persons. Collecting Software Requirements The majority 
of sofhvare engineers reported that they do a good job of collecting customer requirements. Eighty-one 
percent of responding engineers agreed or strongly agreed that they do a good job, with only 6~0 dis­agreeing 
At the same time, customers felt that engineers are responsive to their software needs, with 69~0 of 
responding customers agreeing or strongly agreeing witl that perception. Most engineers agreed or strongly 
agreed that their customers are satisfied with existing requirements docu­ments. Sixty-five percent of 
customers agreed or strongly agreed that they do a good job of providing engineers with accurate software 
requirements, although only 3170 felt that engineers are satisfied with the resulting documents. Software 
engineers and customers ahnost unanimously agreed on the benefits of considering non-functional soft­ 
ware requirements. In fact, 97~0 of responding engineers and 1007o of responding customers agreed or 
strongly agreed that non-functional requirements are important to software quality. Further, 8170 of 
engineers and 77% of 79 customers indicated that engineers are willing to include non-functional requirements 
in software requirements and design documents. That is, engineers appear quite willing to commit to meeting 
fuzzy software performance requirements.  Software Proposals and Designs Software engineers and customers 
reported a variety of methods by which engineers present their software design proposals to customers 
both reported that verbal descriptions and illustrations are the two most widely used methods. Formal 
design documents are also widely used with almost 80% of customers and 50% of engineers reporting their 
use. Use of flow charts and computer-based simulations rank lower, with 4770 of software engineers and 
3090 of customers respectively reporting occasional use of these methods. I asked how customers give 
feedback once engi­neers have presented their design proposals. The most common method, reported by rdmost 
all respondents, is verbal communication between engineer and customer. The second most common method 
is for customers to write comments marking changes and questions to the engineem. I also asked how engineers 
get customer feedback once a working software version is available. Again, the most fre­quently reported 
method is interviews or meetings with customers-76% of engineers and 87~0 of customers reported that 
this is usually or always done. This is fol­lowed by written comments by customers+3% of engi­neers and 
64Z0 of customers reported that this is usually or always done. Direct observation of users is reported 
to be third most common, followed by customers filling out user logs or questionnaires about the software. 
Despite the pop­ularity of protocol analysis in technical writing, 97% of engineers and 94% of customers 
reported that they rarely or never make audio or video recordings of customers working with their software. 
 Use of Prototypes and Low Tech Methods Because prototypes give customers the opportunity to work with 
and give feedback on their software before it is completed, I asked software engineers and customers 
to respond to five statements about prototyping: (1) proto­types result in software that is more technically 
correct (2) prototypes result in software that is more user-friendly (3) prototyping makes it easier 
to create high quality softwarq (4) prototyping is worth the time and effort requird, (5) customers appreciate 
having prototypes to work with. Most respondents agreed or strongly agreed with all these statements. 
Engineers and customers were unsure, how­ever, whether prototyping makes engintig easier (4090 of all 
respondents gave a neutral response to this state­ment). It is noteworthy that engineers under-estimated 
how much customers appreciate having prototypes to work with: only 6370 of engineers agreed or strongly 
agreed with that statement (compared with 88% of customers). At the same tie, however, several responding 
engin~rs com­plained that customers do not spend enough time working with prototypes when available. 
Interestingly, low technology methods of presenting software designs seem to be seldom used by engineers. 
asked how often software engineers used three such meth­ods: storyboards, mock-up work sessions with 
non-func­tioning computers, and cooperative work sessions with customers. The mean response to both storyboards 
and mock-up sessions was below 2.0 (less than rarely ). Both engineem and customers reported that cooperative 
work sessions are more common, with a mean customer ranking of 3.2 (just above sometimes ).  Satisfaction 
with Software Engineering Overall, software engineers reported that they are quite pleased with the quaMy 
of the software they provide, Figure 1 shows that 94% indicated that they are satisfied or very satisfied 
with their final produc~, only one software engineer was dissatisfied and none were very dissatisfied 
with their software quality. Software customers also seem happy with the quality of the software they 
receive. Sev­enty-seven percent reported that they are satisfied or very satisfied, with, again, only 
one respondent reporting dissat­isfaction with software quality, However, software engineers are slightly 
less satis­fied with the cost of the software they produce. Figure 2 shows tha~ while a high number of 
engineers remain satis­fied or very satisfied, an increasing number of neutral or dissatisfied responses 
appear here. Software customers reported significantly less satisfaction with software costs than the 
engineers. Only 12% of responding customers are satisfied, with 31 ZOrepordng that they are dissatisfied 
with costs. Customers are also less satisfied than engineers with the time needed to create software. 
Figure 3 shows that while 5570 of engineers are satisfied or very satisfied in this arq only 18~0 of 
customers were satisfied. And, while a relatively large 30% of engineers are dissatisfied or very dissatisfied 
with the time needd a full 41 % of customers reported being dissatisfied or very dissatisfied. 80 Figure 
1: Overall software quality. F@me 3: The amount of time needed to develop and deliver a piece of software. 
60% I Engineers 50~o 113 Customers I I 40?40 t 3070 20 %0 1070 0 !/0 L + Very Dissatisfied Neutral Satisfied 
Very Satisfied Dissatisfied Figure 2 The fihd cost of the software. 60?!0 50 %0 40~o 30% 20% 10 % o 
?40 Very Dissatisfied Neutral Satisfied Very Dissatisfied Satisfied Figure 2: 50% 40% R Customers F 
r 30% 20?/0 10% o Yo Very Dissatisfied Dissatisfied  Suggestions for Improving Software Engineering 
Responding sofhvare engineers were slightly more satisfied with their own efforts than with those of 
their cus­tomers. Although only one software engineer claimed to be dissatisfied with customer efforq 
no software engineers reported being very satisfied. At the same time, 76% of software engineers claimed 
to be satisfied or very satisfied with their own efforts. Software customers, on the other han~ rated 
the efforts of software engineers just as highly as the engineers themselves did. Seventy-six pereent 
said that they are satisfied or very satisfied witi the effort expended by engineers. On the other hand, 
software cus­tomers rated their own efforts more highly than did soft­ware engineers did. While only 
64% of engineers said that they are satisfied with customer effom a full 82~o of cus­tomers were satisfied 
or very satisfied with their own work. Despite these high levels of satisfaction, a number of recommendations 
were reported by respondents. Engi­neers and customers strongly believed that improved com­munication 
between them would result in better quality software. In fac~ 81% of responding engineers and 82 ZOof 
customers agreed or strongly agreed with that statement. Software customers reported that engineers could 
aid the software engineering process most by improving their work processes. Suggestions included do 
more design and testing and do more of the work onsite. Customers also suggested that engineers improve 
their scheduling, work faster, and use a specific process or methodology to create their software. Seeond, 
customers reported that Neutral Satisfied Very Satisfied engineers could improve the way in which they 
work with customers. Suggestions for engineers included keep bet­ter track of customer expectations and 
spend more time observing the actual application for which the software is being developed. Third, customers 
recommended that engineers work to improve the software itself, suggesting: avoid the just one more feature 
syndrome and pro­vid[e] software with a consistent style. Customers also recommended that engineers improve 
tieir requirements­gathering techniques, that they provide better software documentation, testing, and 
training and that they spend more time at the customer s work location observing the environment in which 
the softsvare will be used. Software engineers, on the other hand, asked cus­tomers to spend more time 
thiing about the software they wane that they try to provide better software require­ments, and work 
to improve the way software projects are handled within their companies. In addition, software engineers 
voiced the opinion that customers should b-y to ~cognize the diiliculties involved in software engineering 
and help guide the process as much as possible. However, one (apparently discouraged) software engineer 
advised that customers could help most by staying out of the soft­ware engineering process ! The most 
common suggestions, though, were for software customers to do more work at the start of software engineering 
projects. Customers should define the software requirements more thoroughly, and be prepared to explain 
what they want to the engineers, Another recommendation for software customers was to provide engineers 
with better information about the appli­cations for which the software is inteude~ engineers reported 
that they need to know more about the environ­ ment in which the software is to be use~ and they need 
sample data that is representative of actual work conditions to test the software properly. The most 
frequent problems described by engineers focused on the difficult nature of software engineering. Engineers 
complained that they t%cea wide variety of cus­tomer requirements with rapidly changrng hardware and 
operating system environments, and that they must educate themselves constantly to keep up with technology. 
Engi­neers also described the difficulty of determining customer software requirements, reporting that 
it is difficult to obtain a complete list of necessary features, that they receive vague and incomplete 
information from customers, and that customers often reverse decisions in the middle of projects. Overwhehningly, 
customers reported that their biggmt problem rnvolves the time and cost of getting soft­ware, and the 
quality of the finished product. Seventy-five percent of customers making suggestions complained about 
long development times, budget constraints and cost over-runs. Part Three: Tasks for Professional Communicators 
Software engineering literature often concludes that engineers and customers need to communicate, but 
some­times does little more than state the need for good commu­nication, Authors seem to either think 
the matter simple enough that elaboration is unnecessary, or they just don t know what to recommend. 
Sadly, the term good commu­nication is handed out as if it were a self explanatory solu­tion that can 
be simply inserted into the software engineering process. The results of my survey seem to back this 
up. Engineers and customers reported surpris­ingly high levels of some communication activities during 
their sofhvare engineering projects. And although respon­dents reported high satisfaction with software 
quality, they had definite problems with software cost and development time. In addition, customers and 
engineers had a number of communications-related complaints and recommendat­ions for each other. If we 
take the position that software engineers are not the ideal communicators we might con­sider more strongly 
the proposition that professional com­municators can take a prominent place in the software engineering 
community. Professional communicators, widely recognized as havrng excellent communication skills and 
being staunch user advocates, are in a good position to atlack the prob­lems identified in thk paper. 
Ramey [1991] finds that in their traditional role as user advocate, communicators can ensure that [software 
engrneers] look at the problem from the end user s perspective. Doheny-Farina [1992] agrees that software 
engineers should work with technieat writers because such collaboration improves product qualhy and increases 
customer satisfaction. If communicators can transfer their traditional skills successfully to software 
engineering environments, they will be able to help soft­ware customers describe what they need more 
efficiently to software engineers. At the same time, they can help soft­ware engineers relate how the 
software being created will work for the customers. With more efficient two-way com­munication occurring 
throughout software engineering projects, it seems likely that the resulting products will be less surprising 
and more acceptable to software customers and UStXS. Despite the seemingly natural fit between profes­sional 
communication and software engineering, concerted efforts must be made to create the space in which commu­nicators 
will make their contributions. One way of defin­ing these roles is to make explicit connections between 
the steps that occur during engineering and the communication tasks that are problematic. The waterfall 
model views soft­ware development as a sequence of independent steps tha~ when followed, results in a 
complete software product. [t relies on the principle that software is created sequentially tirst adyses 
are conducte~ then a system is designed to meet the assessed needs, then software is created and tested, 
and, finally, software is released to users with main­tenance continuing through the life of the system. 
Although the waterfall model does not accurately portray the events that take place in any real software 
development projec~ it does represent real phases that must be accom­plished in creating software. The 
remainder of thii paper usesthesephases (analysis, design, coding and testing, and operations and maintenance) 
to identify entry points for professional communicators rnto software engineering. Analysis Phases The 
analysis phases of software engineering are conducted through a combination of interpersonal commu­nication 
processes and formal data analysis method~ inter­views are conducted with customers and potential software 
users; field observations provide data on how the tasks for which the software is needed are performec 
specifications of existing software are examined to determine whether portions can be re-implemented 
in the new software. These studies are intended to help engineers understand the problem domain, the 
environment the software is needed for, and the need for the software itself. Documents cre­ated during 
this phase include feasibility reports, white­paper reports, and preliminmy user s manuals. Such docu­ments 
are used by engineers to help them design systems in domains that they might not be expert in, and should 
be used by customers to help ensure that the software is being built around their expectations and needs, 
rather than those of the developers. Given the importance of software requirements that are complete, 
consisten~ and correcq researchers have pro­vided a number of recommendations regarding these docu­ments. 
One such recommendation is that specifications include both text and graphics, and that documents be 
writ­ten in both formal and natural languages [Ramammrthy, et. al, 1984]. Pfleeger agrees that two separate 
re@re­ments documents should be used one written in kmguage that the customer can understand, and the 
other in the tech­nical language needed by engineers to create the software. In addition, Pfieeger asks 
developers to create a conceptual design document telling the customer what the proposed system will 
do, how to enter and receive data, what the screens look like, and how menus and options will be used 
[Pfleeger, 1987]. Researched also question the value of specification and requirement documents, complaining 
that such documents are often useless and poorly written with the needs of the readers not planned for 
tDoheny-Farina, 1992 Kostnr and Hall, 1991]. This makes sense to Mce­wen-Beeman [1991] who reminds us 
of the language diffi­culties software engineers and customers encounter: A software engineer s environment 
is full of jargon, acro­nyms, and technical language. Although it can be very dif­ficult to refrain from 
using technical terminology, when a document is prepared for a customer, technical jargon can confuse 
and lead to misunderstanding. Professional communicators are in an excellent position to help software 
engineers collect appropriate cus­tomer and end-user requirements. Communicators are practiced in interviewing 
and observation techniquw and, as user advocates, are likely to empathize with customers who have trouble 
understanding the software that is being created for them. In addition, communicators are accus­tomed 
to collecting information ftom one set of persons, translating it appropriately, and reporting it to 
a different audience, This allows communicators to relay information along multiple paths: from customer 
to software engineer, from engineer to customer, and from technical expert to software engineer. In addition 
to their interviewing skills, communicators should be able to apply their writing talents and sense of 
audience, purpose, and need toward the soft­ware documents created. Amid countless complaints that these 
documents are poorly written and fail to account for the needs of the users, professional communicators 
are needed to help create usable and correct documents from the beginning of a projec~ rather than being 
called in later in a strictly service role. Whh proper training and under­standing of software engineering 
processes, technical com­municators can incorporate visual elements into requirements and specifications 
documen~, they can also create two sets of documents-one set adapted toward the needs of software engineers 
and the other adapted toward the users or customers needs.  Design Phases Whiie software is being designe~ 
the customer­advocate responsibility of the technical communicator can be used in severaI ways. First 
communicators can help ensure that the software is being designed to do what the customers want it to. 
Once again, technical communica­tors can accomplish this by interviewing, obseming, writ­ing, and reporting 
to both customers and software engineers throughout the design phases. Communicators can also write and 
maintain separate design documents, again creating one set for customers and another set for engineers. 
As has been pointed OUL traditional software models often place little emphasis on customers needs. By 
allowing professional communicators to work directly with customers and end-users, these group s needs 
can be taken seriously without sacrificing engineer s design and pro­gramming time. An important aspect 
of an iterative design process is letting users work with some form of the software long before Finalizing 
the system requirements. This suggests the value of having customers and communicators work together 
with something cheaper and easier to produce than computtx-based prototypes. For example, storyboard­ing-drawrng 
pictures of the screens customers would see if using the yet non-existent software--is recommended often. 
Users can sit at a non-functional computer station and pretend to use the software as the drawn screens 
are placed in front of them [Olson, 1991; B@ker, 1991]. B@d­ker writes that this process lets users give 
their opinions very early in the design process, allowing experts to add their technical knowledge at 
the same time. These mock­ups can also be used to experiment with hardware armnge­ments. Through protocols, 
for example, customers and communicators can decide whether a mouse is needed, how many buttons should 
be on the mouse, and what func­tions the mouse should perform. As soon as software has, to any exten$ 
been designed, technical communicators can employ another of their traditional skills to begin testing 
those designs determining whether they seem to be leading up to prod­ucts that customers expect and need. 
The difference between software analysis and software design phases is that while analysis results in 
descriptions of what require­ments the software needs to mee~ the design phases pro­duce actual visions 
of what the software will be like. Communicators conducting protocol tests of preliminary designs allow 
both engineers and customers to focus on what they do best. In addition to providing explicit links between 
the agreed-upon software requirements and the developing design, such testing and constant communica­tion 
can offer assurances to engineers and customers alike that the software development is proceeding according 
to everyone s expectations.  Coding and Testing Phases Perhaps the most popular recommendations for 
soft­ware engineering involve some form of evolutionary development. These methods (spiral model, rapid 
proto­typing, incremental delivery, etc.) dl provide customers with a partly functional prototype that 
has the look and feel of the finished product. This prototype is evaluated by users and then refined 
by the programmers m successive cycles until the program is complete ll%rkas, 1991]. Researchers almost 
unanimously support some sort of pro­totyping, citing increased user participation and feedback, better 
customer understanding of the software, and a better common image of the product. Iivari and Karjalainen 
agree that proto~ing provides the users with a tangible means of comprehending and evaluating the proposed 
sys­tem, it provides a common reference point for both user and designers, prototyping supports user 
participation and commitment to a projec~ it establishes better communica­tion and relationships between 
users and designers, and it helps to ensure that the nucleus idea of the system is right [Iivari and 
Karjaltinen, 1989]. B@lker and Gr@nb&#38;k [1991], for example, agree but criticize engineers for using 
prototypes to passively collect user information. They emphasize that successful prototyping entails 
a creative design process conducted with active participation of both users and engineers. There are 
several areas that seem highly appropriate for professional communicators to participate in during these 
production phases of software engineering. FirsL communicators can contribute directly to the engineers 
work by designing screens, writing on-screen text and instructions, and designing colors, shapes, sounds, 
and movements of on-screen objects and actions. Technical communicators seem highly qualified to determine 
the cues needed by users as they wait for tie software to per­form ti. Communicators should be able to 
effectively design and test operational sequences as the code is being written and incmpated into the 
software. SeconG researchers stress that early testing is a key reqnirenwmt for creating programs that 
contain few errors and that need little debugging and post-delivery modifica­tion. Again, communicators 
should be able to do an excel­lent job of running user protocol tests with early prototypes of the software 
or of individual modules or small operating pieces of the software. In addition, communicators can design 
and conduct what Yonrdon [1989] calls structured walkthroughs-formal work sessions in which users are 
walked through the software code or partially functional programs, with their likes and dislikes, comments 
and con­cerns discussed and noted. Such common sense proce­dures are seldom performed, at least in part 
because traditional software engineering personnel don t have the time to spare. With the cost of neglect 
so high and so often described in the software engineering literature, it seems very likely that technical 
communicators can provide cost­effective services, adding measurable value to these stages of software 
engineering. Operations and Maintenance Phase The full results of having professional comtnunica­tors 
working in the software design and engineering pro­cm will appear once the resulting software products 
have been released into the world of actual customem and usem. One result will be that this software 
will get into users hands mom quickly than sofhvare that did not receive sim­ilar treatment. Thii software 
will be higher quality, contain fewer outright errors, and be more satisfying to the users). It will 
also have lower development costs than similar soft­ware created without professional communicators. 
We might also expect that technical communicators who work throughout software engineering projects will 
create exceptionally high quality documentation for those software packages. Thm result coupled with 
the higher quality software should ensure that fewer complaints about the software will be made. Further, 
when complaints are made, communications professionals will be on hand to receive those complaints and 
to work to understand and solve the problems that prompted the difEcnlties. A Few Final Thoughts The 
point of this article is not that professional com­municators should become sofhvare engineers, nor is 
it that software engineers desperately need the services pro­vided by communicators. Rather, the point 
is that profes­sional communicators, with additional training and broadened perspectives and expertise, 
are in an excellent position to make substantial contributions toward improv­ing the processes of designing 
and engineering software. The software engineering process is heavily dependent on effective communication 
between diverse groups of people at all stages of production an4 as software itself is a com­munication-intensive 
produc~ it seems reasonable to con­clude that technical communicators should be able to measurably add 
value to software engineering. In addition, the fact that software engineering stiers from such an agreed 
upon set of production problems, and the fact that so much of the computer literature focuses on communica­tion 
issues.,considerably strengthens the potential for com­municators to be incorporated thoroughly into 
software engineering. Such an arrangement would seem to be highly bene­ficial to all concerned software 
engineers would benefit ikom communicators expertise and knowledge, and would be free to concentrate 
on the areas in which they are uniquely qualified designing, coding, and implementing software systems. 
The field of technical communication as a whole would greatly benefit as well. Professional techni­cal 
writers and researchers would have new areas open to them areas that seem vital to an agenda of understanding 
human communication more completely and of using com­munication research for practical purposes. Finally, 
cus­tomers for and users of software would benefit from cheaper, more readily available, and higher quality 
soft­ ware products than are now available. 85 Bibliography <RefA>Baber, R. (1991). Error-free software know-how 
and know-why of program correctness, John Wiley &#38; Sons, New York. Balzer, T. Cheatham, and Green. 
(1983). Software tech­nology in the 1990 s using a new para­digm, Computer. vol. 16,39-45. B@ker, S. 
and G@nbeck. (1991). Cooperative prototyp­ing: users and designem in mutual activi­ty, I.nternationaJ 
Journal of Man-Machine Studies. vol. 34,453--478. B@ker, S. (1991). Through the interface: a human activity 
approach to user interface design. HiLls­dale: Lawrence Erlbanm Associates. Bostrom, R. (1989). Successful 
application of communi­cation techniques to improve the systems development process, Journal of Infor­mation 
&#38;Management. vol. 16, 279 295. Bresko, L. (1991). The need for technical communicators on the software 
development team, Tech­nical Communication. vol. 38,214-220. Brooks, F.P. (1987). No Silver Bullet EssencesandAcci­dents 
of Software Engineering. Computer, vol. 20(4), 10-19. Cohill, A.M. ( 989). The Human Factors Design Process 
in Software Development. In G. Salvendy &#38; M.J. Smith (Eds.), Designing and using human-computer interfaces 
and knowl­edge-based systems. (pp. 19-27). Amster­dam Elsevier. Cohill, A.M. (1991). Information Archkcxure 
and the De­sign Process. In J. Karat (Ed.), Taking software design seriously, (pp. 137-155). New York 
Academic Press. Curtis, B. Krasner. and Iscoe. (1988). A Field Study of the Software Design Process for 
Large Sys­tems. Communications of the ACM, vol. 31(11), 1268-1287. Doheny-Farin&#38; S. (1992). Rhetoric, 
innovation, technolo­gy: case studies of technical communica­tion in technology transfers. Cambridg~ 
The MIT Press. Eason, KD. and Harker. (1988). The Supplier s Role in the Design of Products for Organizations. 
Computer Journal, vol. 31(5), 426-430. Farkas, D.K. (1991). Collaborative Writing, Software De­velopmen~ 
and the Universe of Collabora­tive Activity. In M.L. Lay &#38; W.M. Karlis (Eds.), Collaborative writing 
in industry: investigations in theory and practice @p. 13-30). Amityville, New York Baywood Publishing. 
Geisler, C. (1991). Writing abont the material world communication tasks in engineering de­sign, IPCC91 
Proceedings: The Engi­neered Communication, vol. 1, 128 133. Gillies, A.C. (1991). Humanization of the 
Software Facto­ry. Information and Software Technology. vol. 33(9), 641-646. Gould, J.D., Boies., and 
Lewis. (1991). Making Usable, Useful, Productivity-Enhancing Com­puter Applications. Communications of 
the ACM, vol. 34(l), 74-84. Graham, Clancy and DeVaney. (1982). A Software Design and Evaluation System. 
In Edward Yonr­don (Ed.) Writings of the revolution: se­lected readings on software engineering, (pp. 
112-122). Yourdon Pws. Grudin, J. (1991). Obstacles to User Involvement in Soft­ware Product Development 
with Implica­tions for CSCW. International Journal of Man-Machine Studies, vol. 34(3), 435­ 452. Heckel, 
P. (1984). The elements of friendly software de­sign. New York Warner Books. Horberg, J.K. (1993). Engineer/customer 
communication practicw a study of software engineering. Masters Thesis. University of Minnesota. Iivari, 
J. and Karjalainen. (1989). Impact of Prototyping on User Information Satisfaction During the IS Specification 
Phase. Information and Managemen4 vol. 17(1), 31-45. Kostnr, P. and Hall. (1991). Avoiding Miscommunication 
How to Analyze and Edit for Meaning. IPCC91 proceedings: the engineered com­munication, vol. 1, 18-25. 
Krauss, R. and Fussell. (1991). Mutual lmowledge and communicative effectiveness. In M. Lay and W. Karlis, 
(Eds.) Collaborative writing in industry investigations in theory and practice, @p. 111 145). New York 
Bay­wood Publishing. Lanning, T.R. (1991). Let the Users Design! In J. Karat (Ed.) Taking software seriously 
(pp. 127­135). Boston: Academic Press. Mcewen-Beeman. (1991). Communication Engineered as Process. IPCC91 
Proceedings: The Engi­neered Communication. vol. 1, (pp. 57­59). Norman, D.A. (1988). The psychology 
of everyday things. New York Basic Books, Inc. Olson, G.M. and Olson. (1991). User-Centered Design of 
Collaboration Technology. Journal of Or­ganizational Computing, vol. l(l), 61-83. Pfleeger, S. (1987). 
Software engineering: the production of quahty software. New Yorlc Macmill­an. Ramamoorthy, A. Tsai, 
and Usuda. (1984). Software en­gineering: problems and perspectives. Computer, vol. 17,191-209. Ramey, 
J. (1991). Communication: Usability Engineering. IPCC91 Proceedings The Engineered Communication, vol. 
1, (pp. 60-64). Redish, J. and Ramey. (1993). Measuring the value added by professional technical communicators. 
IEEE Transactions on Professional Com­munication, vol. 36, pp. 158-161. Shamlin, C. (1990). The other 
side of software a user s guide for defting software requirements. New York AMACOM. Spinas, P. (1989). 
User Oriented Software Development and Dialogue Design. In M.J. Smith &#38;G. Salvendy (E&#38;) Wmk with 
computers: or­ganizational, managemen~ stress and health aspects, (pp. 200-207). Amsterdam Elsevier. 
Yourdon, E. (1989). Structured walkthroughs. New Jer­sey: Yourdon Press. </RefA>
			

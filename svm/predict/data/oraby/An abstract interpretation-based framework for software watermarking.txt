
 An Abstract Interpretation-Based Framework for Software Watermarking Patrick COUSOT and École Normale 
Supérieure 75230 Paris cedex 05, France Patrick.Cousot@ens.fr Abstract Software watermarking consists 
in the intentional embedding of in­delible stegosignatures or watermarks into the subject software and 
extraction of the stegosignatures embedded in the stegoprograms for purposes such as intellectual property 
protection. We introduce the novel concept of abstract software watermarking. The basic idea is that 
the watermark is hidden in the program code in such a way that it can only be extracted by an abstract 
interpretation of the (maybe non-standard) concrete semantics of this code. This static analysis-based 
approach allows the watermark to be recovered even if only a small part of the program code is present 
and does not even need that code to be executed. We illustrate the technique by a sim­ple abstract watermarking 
protocol for methods of JavaTM classes. The concept applies equally well to any other kind of software 
(in­cluding hardware originally speci.ed by software). Categories and Subject Descriptors: D.2.9 Software 
Engineer­ing/Management: Copyrights. General Terms: Algorithms, Reliability, Security, Languages, Theory, 
Legal Aspects, Veri.cation. Keywords: Abstract Interpretation, Authentication, Copyrights Protection, 
Fingerprinting, Identi.cation, Intellectual Property Pro­tection, Obfuscation, Software Authorship, Software 
Watermark­ing, Static Analysis, Steganography, Stegoanalyst, Stegoattacks, Stegokey, Stegomark, Stegosignature, 
Tamper-proo.ng, Trustwor­thiness, Validation Watermarking. 1. Introduction Digital information hiding 
techniques such as steganography, dig­ital watermarking and .ngerprinting have received much attention 
from the research community and industry. With few notable ex­ceptions [4, 15, 16], relatively little 
work has been done on software watermarking that consists in embedding (that is the indelible un­obtrusive 
.xing of invisible stegosignatures1 or watermarks, such as cryptographic signature and timestamp, in 
subject programs) and extraction (that is the detecting) of the stegosignatures) embedded in the stegoprograms 
(that is watermarked program sources). 1 stego-xxx means xxx in the context of hiding some em­bedded 
secret information. Permission to make digital or hard copies of all or part of this work for personal 
or classroom use is granted without fee provided that copies are not made or distributed for pro.t or 
commercial advantage and that copies bear this notice and the full citation on the .rst page. To copy 
otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission 
and/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. Radhia COUSOT CNRS &#38; École Polytechnique 
91128 Palaiseau cedex, France Radhia.Cousot@polytechnique.fr Digital watermarking is to be contrasted 
with public-key encryp­tion, which also transforms subject .les into another form so that they become 
unusable without the decryption key. Once the soft­ware is decrypted, it is free of any residual effect 
of encryption. Hence, licit use can only be ensured by keeping a list of certi.ed customers of the decrypted 
software, by using licensing informa­tion, by hardware monitoring of the program execution or by link­ing 
the software to the hardware of a speci.c machine or to a spe­ci.c movable piece of hardware such as 
a dongle [4, 16] or to a speci.c user public key. An alternative would be to use encrypted execution 
so that code never executes in-the-clear thus requiring a customized encrypted execution mechanism. These 
techniques are in.exible (e.g. for software to be downloaded from a web page). Unlike encryption, digital 
watermarking leaves the subject object basically intact, recognizable and usable. Further, whereas de­crypted 
documents are free of any residual effects of encryption, digital watermarks are on the contrary designed 
to be persistent in viewing, printing, or subsequent re-transmission or dissemination [10]. Watermarking 
does not aim so much to stop illicit use, but to prove ownership of the software and the algorithms used 
in the software [16]. Notice that in general the watermark may hide an en­crypted signature, a problem 
that we handle by taking the signature to be an arbitrary number within an arbitrary large bound. We 
illustrate our approach on the watermarking of methods in JavaTM classes. Complete sophisticated JavaTM 
applications can be easily constructed from sets of JavaTM classes including reusable methods with high 
proprietary content (such as licence control code or original algorithms) which one might want to watermark. 
JavaTM classes are easy to decompile and reverse engineer since they are distributed in hardware independent 
virtual machine code retaining almost all the information of the original JavaTM code. Obfusca­tors and 
code transformers can be used to make reverse engineer­ing more dif.cult [6] but also to hide the origin 
of JavaTM classes. In this case indelible watermarking is an appealing complementary solution. Two types 
of digital watermarks may be distinguished. Visible wa­termarks (such as a logo placed in a corner of 
the screen image by the TV industry) discourage the illicit use by immediately claiming ownership. Invisible 
watermarks, on the other hand, are potentially useful as a means of identifying the source, author, creator, 
owner, distributor or authorized consumer of a multimedia object (image, audio, video, text, etc). For 
this purpose, the objective is to perma­nently and unalterably mark the object. Since the watermark is 
not visible, a special detection software is needed to extract the original signature. In the event of 
illicit use, the watermark would facilitate the claim of ownership. Copyright 2004 ACM 1-58113-729-X/04/0001 
...$5.00 According to Collberg and Thomborson s informal taxonomy of software watermarking techniques 
[3], one can distinguish between static and dynamic watermarking. Static watermarking stores signatures 
in the program source either as data (e.g. an image, a string, etc) or code (e.g. in the code control 
structure). So, the stegosignature can be extracted from the text of the program (or the program syntax), 
without any need for execution.  Dynamic watermarking stores signatures in the program ex­ecution state 
and so requires the program to be executed in order to extract the stegosignature. [3] distinguishes 
between:  Easter egg watermarking stores signatures in a piece of code exe­ cuted for a highly unusual 
input to the application. Dynamic data structure watermarking stores signatures in the pro­gram data 
if and when executed with particular inputs. The signa­ture is exhibited by a watermark extraction routine 
examining these signed program data. Dynamic execution trace watermarking stores signatures in the program 
execution trace when executed with special inputs. The ex­traction consists in recognizing speci.c properties 
of the addresses or operations on the trace. One dif.culty with dynamic watermarking is that the special 
input revealing the watermark can be localized by monitoring program execution using standard instrumentation 
techniques and removed by debugging techniques in which case it must be considered in­effective. Dynamic 
data structure watermarking can be obliter­ated by program transformations such as variable splitting/merging 
while dynamic execution trace watermarking can be erased by pro­gram optimization and transformation. 
This pessimistic view dis­misses all current and future dynamic watermarking schemes as completely ineffective. 
Abstract watermarking is the new framework that we intro­duce for software watermarking. Abstract watermarking 
is fully automatic and different from both static and dynamic watermark­ing. Abstract watermarking is 
a static watermarking in that the extrac­tion of the signature requires no execution of the program. 
It fol­lows that no easily recognized special input is needed for extraction. Abstract watermarking is 
a dynamic watermarking in that the stegosignature is hidden in the concrete semantics of the program 
(which may be a non-standard one). However execution of the ste­goprogram (or just of the stegomark inserted 
in the subject pro­gram) will not reveal the stegosignature. Abstract watermarking is different from 
existing static or dynamic watermarking methods in that the stegosignature extraction is by static analysis 
of the stegoprogram that is by abstract interpreta­tion of its (non-standard) concrete semantics (whence 
the abstract quali.er of this watermarking method). Moreover the abstract ex­tractor can be parametrised 
by a stegokey to .x the speci.c abstract domain used for the signature extraction. Enriching the terminol­ogy 
of [15], this is a semi-visible watermarking in that even if the presence of a stegomark may be visible 
(e.g. by making public the watermark embedding algorithm), the watermark or signature will be invisible 
to those not owning the detection software and the cor­responding secret stegokey. 2. Principle of Software 
Watermarking We let P be the set of considered programs and S be the set of stegosignatures. The watermark 
embedder is W .P . S.P . The watermark extractor is E .P . P(S). The principle of soft­ware watermarking/.ngerprinting 
is that the stegosignature can be extracted from the stegoprograms, that is for all s .S and P .P , s 
.E[W[ P](s)]. (Following the conventions of denotational se­mantics for the application, syntactic arguments 
are between dou­ble square brackets [...] while semantic/mathematical arguments are between round brackers 
(...).) The stegomark approach to software watermarking .rst consists in de.ning a stegomarker Mr .S 
.P to encode the signature s into a program Mr (s) called the stegomark. Second, a stegoinlayer I .(P 
×P ) . P is used to compose the stegomark Mr (s) with the subject program P .P to get the watermarked 
stegoprogram:  W[ P](s) =I[ P, Mr (s)]. 3. Abstract Software Watermarking In abstract software watermarking, 
the signature is hidden in the se­mantics of the stegomark embedded in the subject program, whence in 
the semantics of the stegoprogram. The signature extraction is by static analysis of the stegoprogram 
using some abstract interpreta­tion of the stegoprogram semantics. 3.1 Concrete Semantics Since the stegosignature 
is hidden in the program semantics, we must de.ne a collecting semantics [7], at some level of abstraction 
such as sets of traces, sets of reachable states, etc. In this applica­tion, we consider the set of reachable 
states that is the set of possible descendants of the initial states during program execution. Formally, 
the small-step operational semantics of the program P is a triple (2[ P], I[ P],t[ P]) where 2[ P] is 
a set of (memory and control) states, I[ P] .2[ P] is the set of initial states and t [ P] .2[ P] ×2[ 
P] is the transition relation relating a state s to a possible successor s' whenever (s, s').t [ P]. 
The semantics S[ P] of the program P is the set of execution traces generated by (2[ P], I[ P],t[ P]). 
We consider the reachable states abstraction of this semantics [7]. Formally, given a set S and relations 
t, t'. S ×S, we let t0 . = {(s, s)|s .S}be the identity, t ot' .'')|.s').t . ={(s, s'.S :(s, s ', tn+1 
. (s, s'')}.t'}be the composition of relations t and t'=t otn  be the powers of t, t * .tn be the transitive 
re.exive closure of = n=0 t and post[t](X) ={s'|.s .X :(s, s').t}be the right image of X by t (also called 
the strongest post condition of X for t). The set of reachable states of program P is:  . (r n R[ P] 
. = post[t [ P]*](I[ P]) = lfp F [ P] = F [ P](Ø) n=0 where F [ P](X) = I[ P] .post[t[ P]](X). and lfp= 
f is the =-least .xpoint of f (the existence of which is guaranteed above by Tarski s .xpoint theorem). 
R[ P] is, gener­ally, not computable. 3.2 Abstract Semantics Using abstract interpretation, concrete 
program properties (that is subsets of 2[ P]) are approximated in an abstract domain L[ P] through an 
abstraction function a and a concretization function . chosen such that we have the Galois connection 
[7]: . (P(2[ P]),.) --.(L[ P], ) . (1) .-- a By de.nition of Galois connections, this means that (P(2[ 
P]),.)is a partially ordered set (it is indeed a complete lattice), (L[ P], )is also a partially ordered 
set and for all X . 2[ P] and X . L[ P]: a(X) X .. X . .(X). Given an abstract transformer Fa[ P] such 
that for all X . L[ P]: F [ P] o .(X) . . o Fa[ P](X) the abstract semantics is de.ned as: Ra[ P] = 
lfpFa[ P] . (2) If (L[ P], ) is computer representable and satis.es the ascending chain condition then 
Ra[ P] is computable iteratively as: rn Ra[ P] = Fa[ P] (.) (3) n=0 where .= a(Ø) is the in.mum and the 
join  X = a( .(x)) x.X abstracts set union. The abstract semantics Ra[ P] is an approxi­mation of the 
reachable states of program P in that: R[ P] . .(Ra[ P]). (4) A static analyser is a terminating program, 
written for a given ab­straction a, which, given a program P as input, outputs Ra[ P]. The static analyser 
can be made parametric in a computer repre­sentation of the abstract domain (L[ P], ,.,u) and the abstract 
transformer Fa[ P] so that e.g. the .xpoint computation: (rn lfpFa[ P] = Fa[ P] (.) n=0 can be generated 
automatically. Static analyser generators contain generic abstractions a which are prede.ned in terms 
of simpler ones. For a simple example, let us consider that the states (c,m). 2[ P] = C[ P] × M[ P] are 
made up of a control state c . C[ P], and a memory state m . M[ P] as­signing values m(X). V[ P] to program 
variables X . X[ P] so that M[ P] = X[ P] . V[ P]. Assume that we are interested in analy­ses recording 
information for a subset V of the program variables only (for example V might be the set of variables 
of a given type, such as the integer variables). Static analyser generators such as SOOT [20] provide 
a non-relational abstraction as a prede.ned ab­stract domain L[ P] that is parametrised by an abstract 
domain D abstracting the values of variables: . (P(V[ P]),.)--.(D, ) . .-- a .P,V Then, we have (P(2[ 
P]),.)-(L[ P], ) by de.ning the .---- ----. aP,V global abstraction aP,V (X) of X . 2[ P] as: aP,V 
(X) =a({m(X) |(c,m). X}). c.C[ P]X.V This global abstraction aP,V , which we implicitly use in the fol­lowing, 
collects for each program point c and each variable X . V we are interested in, an abstraction, by the 
elementary a, of the set of values of this variable (which is reachable in some execution of P from the 
initial states). The abstract transformer Fa[ P] can then be prede.ned in terms of basic abstract operations 
of the language P . The abstraction 0 of a k-ary concrete operation · (with domain dom(·) and codomain 
codom(·)) should satisfy for all x1 . L[ P], ..., xk . L[ P] [7]: {·(x1,...,xk )| x1 . .(x1). .... xk 
. .(xk ). (x1,...,xk ). dom(·)}. .(0(x1,...,xk )) . 3.3 Abstract Software Watermarking The principle 
of abstract software watermarking is to choose a particular abstraction a as well as an abstract extractor 
E(Q) . L[ Q] . S to extract the stegosignatures of a program Q . P : E[ Q] = E(Ra[ Q]). (5) The correctness 
conditions of Sec. 2 must be satis.ed, so: s . E(Ra[W[ P](s)]). Informally stated, we can watermark the 
subject program P with stegosignature s by transformation of the program P into the ste­goprogram W[ 
P](s) where s is invisible. The signature can be ex­tracted from the stegoprogram W[ P](s) by extraction 
with E from its abstract semantics Ra[W[ P](s)] which is entirely speci.ed by the abstraction a. By maintaining 
a and E secret, it is computation­ ally hard, if not impossible to extract the stegosignature. The method 
is not static in that the stegosignature is not directly hid­den in the program syntax that is the data 
or the control structure of the stegoprogram W[ P](s)nor dynamic since it is not hidden in the concrete 
semantics R[W[ P](s)] of the stegoprogram (which need not be executed to extract the signature from an 
execution trace). It is abstract, that is hidden in the abstract semantics Ra[W[ P](s)] of the stegoprogram, 
which is computable by static analysis of this stegoprogram. In particular, the concrete semantics which 
is used, need not be the collecting semantics for the standard semantics as considered up to now. For 
example, if we want to watermark a method M of a program P, we can use the semantics of M where the parameters 
and global variables are all unknown as in a so-called monovari­ant intraprocedural static analysis. 
The semantics of M can also be chosen to be non-standard and kept as an additional secret. A simple example 
would be a non-standard interpretation of .oating point constants and operations as integer constants 
and operations. 3.4 Principle of Parametrised Abstract Software Watermarking and Fingerprinting In order 
for the public to be con.dent in the robustness of the pro­posed abstract software watermarking method, 
it is necessary to publish the watermarking method, including the speci.c abstrac­tion a and abstract 
stegosignature extractor E which are used. Therefore in practice it is more convenient to have the abstraction 
an and abstract extractor En be parametrised by a secret stegokey n. The abstraction .n ·an and the abstract 
key extractor .n ·En can be made public provided the abstract semantics En(Ran [ P]) is hard, if not 
impossible to compute when n is unknown. Moreover, the abstract software watermarking embedders and ex­tractors 
will produce different stegosignatures for different ste­gokeys as if we had different watermarkers, 
which can therefore be utilized separately and independently. We now illustrate this principle of parametrised 
abstract software watermarking by a particular instance.  4. Abstract Software Stegosignature Embedding 
4.1 Signatures A secret signature will be an arbitrary large natural number c . N so that S = N. In practice 
the natural numbers representable within the numeric primitive types must be less than or equal to a 
given maximum m (e.g. MAX_VALUE for long in JavaTM). In order to bypass the implementation requirement 
c =m, we use the Chinese remainder theorem stating that: Let n1, ..., ne be e =1 positive integers which 
are pairwise co­prime (meaning gcd(ni,nj)=1 whenever i= j) then Z/n1...neZ is isomorphic to the cartesian 
product Z/n1Z ×... ×Z/neZ. So in order to embed a secret signture c of size strictly bounded by n1 ...ne 
with 1 <ni =m for all i =1,...,e we can isomorphically embed e keys (c1,...,ce).[0,n1 -1]×...×[0,ne-1]such 
that: e i-1 e e c = nj.ci .nj(mod nj ). (6) i=1j=1 j=i+1 j=1 So the secret key can be assumed to be 
a tuple (c1,...,ce).[0,n1 -1]×...×[0,ne -1] to be embedded/extracted in a pro­gram by successively embedding/extracting 
ci , i =1,...,e. The principle of stegosignature embedding is to add a stegomark to the program in order 
to hide the constant ci while the extrac­tion consists in a static analysis of the program revealing 
this con­stant ci . Not knowing the secret factor ni it is computationally hard if not impossible to 
retrieve ci . However knowing the e-ary ste­gokey (n1,...,ne), the static analysis can be repeated e 
times to retrieve the secret signature c. After explaining signature embed­ding in Sec. 4.3 and signature 
extraction in Sec. 5.1, we will show that the above restriction to a maximal value m can be lifted. 
4.2 Stegomark We let c .Z be a stegosignature satisfying (6) to be embedded in a program (indeed a JavaTM 
method). As explained in Sec. 4.1, we successively embed ci , i =1,...,e. Each ci , i =1,...,e is hidden 
in a stegomark Mr (ci ). The stegomark is built up in three parts, the stegomark declaration part (introducing 
a new auxiliary stegovari­able, say W, hiding the value of the secret key ci .): int W; the stegomark 
initialization part: W = P(1) in Z and the stegomark iteration part: W = Q(W) in Z such that: P(1) = 
ci in Z/ni Z and ci = Q(ci ) in Z/ni Z that is once initialized, the stegovariable W is constant in Z/ni 
Z. This property will be used to extract the stegosignature ci . Al­though it is constant in Z/ni Z the 
value of W will appear to be stochastic in successive executions of the stegomark iteration part W =Q(W). 
 4.3 Stegomark Inlaying The watermarking W[ P](ci ) of the program P consists in .rst choosing a method 
M, and in watermarking M. Formally W[ P](ci ) is P where the chosen method M is replaced by W[ M](ci 
).In JavaTM, the method seems to be the smallest unit of algorithmic interest, hence our choice. It is 
trivial to generalize the approach to the case where the stegosignature is spread over a class or the 
full program. The watermarking W[ M](ci ) of a method M consists in inlaying the stegomark Mr (ci ) in 
the method M with I[ M,Mr (ci )] de.ned as follows: the stegomark declaration part is included among 
the local dec­larations of the method M;  the stegomark initialization part is embedded at a random 
posi­tion of the initial basic block of the method M;  the stegomark iteration part is inserted later 
at a random position in the body of the method, preferably within a loop.  4.4 Obfuscating the Stegomark 
The stegomark should be obfuscated in order to hide the stegosig­nature ci . First, the auxiliary variable 
W can be any integer program variable which is dead at the initialization point, in which case the extra 
declaration of W is not necessary. The initialization assignment W = P(1) uses a (e.g. second-degree) 
polynomial P of the form: P(x) = x2 +k1.x +k0 with the coef.cients k1 =-(1 +ci ) and k0 =2.ci . In order 
to hide the secret signature ci , these coef.cients are incremented, within the limit m, by a random 
number of times the modulo ni . Therefore: k1 =-(1 +ci )+r1.ni k1 = ci +r2.ni where integers r1 and r2 
are random integers. Observe that in Z/ni Z, we have P(1) = ci . Indeed, the polynomial value P(1) is 
better computed by Horner s method: P(x) = (x +k1).x +k0 by successive assignments (where T is another 
new temporary vari­able2): W =1; ... T =W+k1; ... T =W*T; ... W =T+k0 introduced at random successive 
points in the method s initial basic block. A polynomial of higher degree can also be used if necessary. 
In the iteration assignment W= Q(W) of the stegomark, Q is chosen to be of the second degree (or higher), 
of the form: Q(x) = a.x2 +b.x +c where a and b are (not too large) non-zero random numbers and c is chosen 
to ensure that ci =Q(ci ): c = ci -(b.ci +a.ci 2) 2 T can also be another program variable which is dead 
at that point. Again, we use Horner s method: (x) = (a.x +b).x +c to compute Q(W), by introducing the 
following sequence of assign­ments at random positions in the body of the method: T =W*a; ... T =T+b; 
... T =T*W; ... W =T+c . The last instruction is inserted only if c =0. If c is negative, we use the 
difference -instead of addition +for naturalness.  5. Abstract Stegosignature Extraction By de.ning 
ai such that Rai [ P] performs constant propagation in Z/niZ for all methods M of P, a static analysis 
will be able to recognize that some variable (i.e. W) has the constant value ci in Z/niZ once initialized 
(or ultimately if a dead variable has been reused) thus indicating that the method M had been watermarked. 
We now explain the technical details of this static analysis. 5.1 Abstract Domain and Operations Let 
n be some n1, ..., ne (or their product n1 ...ne in case n1 ...ne = m). We now introduce a program static 
analysis, parametrised by n and to be repeated e times for n = n1, ..., ne, in order to retrieve the 
secret signature c by successively discover­ing c1, ..., ce. Basic Abstract Domains: We let Z/nZ ={{hz 
|h .Z}|0 = z < n}~ =[0,n -1]be the ring of integers modulo n > 1. The unit element for addition is 0 
and that for multiplication is 1. The basic abstract domain is that of constant propagation [13] for 
the ring Z/nZ that is the complete lattice: Ln ={.,T}.Z/nZ where .abstracts the empty set (that is unreachable 
code), Tab­stracts Z/nZ (that is an unknown value) and c .Z/nZ abstracts the congruence class {hc |h 
.Z}. The set Ln is ordered by: .x .Z/nZ :. .c xx c T T which abstracts set inclusion. Ln is a complete 
lattice where the join u(abstracting set union .) and the meet n(abstracting set in­tersection n) are 
de.ned, for all x .Ln, y .Z/nZ such that x =y, by: .ux = x u.= xx ux = x Tux = x uT= T x uy =T .nx = 
x n. = . x nx = x Tnx = x nT = xx ny =.. Basic Abstractions: We let .n .Z .Z/nZ de.ned as: .n(z) = let 
r =zmod n in if r =0 then r else r +n be the canonical embedding of the set Z of integers onto [0,n -1]isomorphic 
to the quotient ring Z/nZ . The abstraction an speci.es how a subset of Z/nZ should be approximated. 
The intuition is that the empty set (Ørepresented by .) and equivalence classes ({hc |h .Z} represented 
by .n(c) where c .Z) are preserved exactly while any other subset is approximated by Z/nZ (represented 
by T). Formally, an is de.ned by: an(Z) ={.n(z) |z .Z}. The concretization .n speci.es which subsets 
of Z/nZ are repre­sented by elements of the abstract domain Ln: .n(.) =Ø, .n(z) ={hz |h .Z} if z .[0,n-1], 
.n(T) = Z . We obtain a Galois connection [7]: .n (P(Z),.)-.-.(Ln, )---- --. an such that for all Z .P(Z) 
and Z .Ln: (an(Z) Z) .. (Z ..n(Z)) . Basic Abstract Operations: The abstraction 0of a k-ary con­crete 
operation · (with domain dom(·) and codomain codom(·)) should satisfy for all x1 .Ln, ..., xk .Ln [7]: 
{·(x1,...,xk)|x1 ..n(x1).....xk ..n(xk). (x1,...,xk).dom(·)}. .n(0(x1,...,xk)) . The abstract unary (k 
=1) operation 0(such as the abstract inverse e) abstracting the concrete operation ·(of the inverse -) 
is de.ned as follows: 0. =., 0T=T, 0z = an({·x |x ..n(z)ndom(·)}) if z .[0,n-1] = .n(·z). The abstract 
binary (k =2) operations 0(of addition ., subtraction eor multiplication .) for the concrete operation 
·(of addition +, subtraction -or multiplication ×) are de.ned as follows: .0z =., 0.=., if z .Ln, z1 
0z2 = an( {x1 ·x2 |x1 ..n(z1).x2 ..n(z2). (x1,x2) .dom(·)}) if z1,z2 .[0,n-1] = .n(z1 ·z2), T0z =T, z0T=T 
if z .Ln . Abstract Integer Variable Domain: Let n1, ..., ne be e =1 positive integers which are which 
are pairwise coprime. The ab­stract domain is the product e (L, . ) =( Lni , .) (7) i=1 smashed for .and 
Twhich, by the Chinese remainder theorem, is isomorphic to the abstract domain: (L, ) = ({.,T}.Z/n1...neZ 
, ). (8) When n1 ...ne> m the analysis on (8) cannot be directly imple­mented using machine integers. 
It can be replaced by an analysis with abstract domain (7), which is always more precise (and even strictly 
more precise since one can discover that a variable is con­stant modulo some nj although it might not 
be constant modulo the product n1 ...ne). Moreover a static analysis with (7) is equivalent to e successive 
analyzes with Ln =Ln1, ..., Ln =Lne . Abstract Environment Domain: Given the set X[ P] of vari­ables 
of program P, the abstract domain is extended pointwise to environments mapping variables to integer 
values. Recall that the set of memory states is M[ P] = X[ P] .V[ P]. We let Xint[ P] . X[ P] be the 
subset of program variables which are of integer type. We have: ..n1...n e .------- ( P(M[ P]), .).------.( 
M[ P], ¨ ) -. a.n1...n e e where M[ P] = Xint[ P] . Lni i= 1 and for all m . M[ P] and m . M[ P]: e a.n1...ne(m) 
= . X . Xint[ P] · ani ({ .(X) | . . m} ) i= 1 ..n1...ne(m) ={ . . M[ P] |. X . Xint[ P] :.i .[ 1,e]: 
.(X) . mni (m(X)i )} . All information on non-integer variables is lost while the informa­tion on integer 
variables is restricted to modular constant informa­tion. Abstract Reachability Domain: Given the set 
C[ P] of con­trol points c of a program P, the abstract environment domain is extended pointwise to all 
program points (recall that 2[ P] = C[ P] × M[ P]). The abstract domain L[ P] which is used for sig­nature 
extraction in a program P is therefore: L[ P] = C[ P] . M[ P] satis.es the requirement (1) since: .¨n1...n 
e .------- . ( P(2[ P]), .) ------.( L[ P], ¨ ) (9)-. a¨n1...n e where given S . 2[ P] and S . L[ P]: 
a¨n1...ne(S) = a.n1...ne({ m |( c, m). S} ), c. C[ P] .¨n1...ne(S) ={( c, m)| c . C[ P] . m . S(c)} . 
 Static Analysis: Collecting Semantics: The considered concrete collecting se­mantics R[ P] of each 
method P is the set of descendants of the ini­tial states of the method P with an initial environment 
.X·.V[ P] where all variables are unde.ned.  Abstraction: The extraction of the secret signature for 
the ste­gokey ( n1, ..., ne) starts with the computation of an overapprox­imation of the abstract semantics 
R[ P] that is by constant  a¨n1...n e propagation in the abstract domain L[ P] for each method P of 
the program. Therefore the static analysis is purely intraprocedural on local variables of integer type 
using the abstraction (9). In prac­tice, this is equivalent to the successive (or simultaneous or paral­lel) 
static analyses propagating constants in the abstract domains corresponding to the individual Lni , i 
= 1,...,e since: e R [ P] = R [ P] . a¨n1...na¨ni e i= 1 Abstract Transformer: To simplify the abstract 
transformer F¨[ P] is de.ned using the following approximations (fur­ an1...n e ther re.nements to deter 
obfuscation may be necessary as discussed later): the initial state of the integer local variables is 
unde.ned (T );  the only operations taken into account in the control .ow graph are the addition, the 
subtraction and the multiplication;  tests as well as other operations such as procedure and function 
calls are simply ignored;  for loops, tests and branching the environment pointwise union is used at 
control junction points.  Abstract Semantics: The abstract semantics  R [ P] a¨n1...n e of the method 
P is de.ned as the least .xpoint of the abstract trans­former F¨[ P] as de.ned in (2). It can be computed 
iteratively an1...n e (3) using any chaotic or asynchronous iteration strategy, as usual in abstract 
interpretation. The result of the analysis is the set of constants belonging to the ring Z/ni Z which 
are the constant values of local integer variables of the method P for i = 1,...,e. Application of Static 
Analysis to Validation Watermarking: Validation watermarking [15] consists in embedding a watermark in 
a software, which may be visible hence simply concatenated to the software, and yields the essence of 
the software. This digest can be used to verify that the software is still essentially the same as when 
authored. The essence extraction process can be (a cryp­tographic digest of) the abstract reachability 
analysis Ra[ P] for a secret abstraction a chosen such that it is essentially invariant for all versions 
of the subject software. Then a publicly available veri.er can detach the watermark from the software, 
make the static anal­ysis of the software and compare the result with the watermark to check that the 
software (hence, its abstract semantics) have not been modi.ed. Observe that the veri.er itself must 
not be faked whence its integrity should be ensured by a signature or a MD5 checksum. Signature Extraction: 
The extractor (5) uses the result R [ P] of the static analysis of the method P to extract the a¨n1...n 
e stegosignature. The stegosignature c is extracted by the abstract extractor E if and only if all ci 
, i = 1,...,e are extracted from the abstract semantics R [ P] of the method P. a¨n1...n e To extract 
ci , the abstract extractor E has to determine whether the static analysis has detected that some local 
integer variable of the method P has the abstract value ci at two program points at least (at least one 
should appear after the stegomark initialization part and another one the stegomark iteration part). 
Despite the overapproximation (4), signature extraction from the watermarked method always succeeds: 
THEOREM 1(CORRECTNESS). For all methods P . P , stegokey n1 ...ne, stegosignature c = c1 ...ce, the ab­stract 
extractor En1...ne will extract the stegosignature c from the watermarked method Wn1...ne [ P](c) that 
is c . En1...ne(Ra¨n1...n[Wn1...ne [ P](c)]). e More generally, we would like to prevent attacks by pro­gram 
transformation. Ideally, the probability that there ex­ist a polynomial syntactic program transformation 
algorithm T that preserves the semantics S[ P] of program P (may be up to some observational abstraction 
aO : . P . P : aO (S[ P]) = aO (S[T [ P]])) and that can attack the watermarked program (i.e. c . En1...ne(R 
[T [Wn1...ne [ P](c)]])) should be very low. a¨n1...n e The characterization of all such transformations 
T is quite dif.cult. Hence such an ideal theorem would be hard to prove. Potential attacks are further 
discussed in Sec. 7, 8 and 9.  5.2 Example Subject Program: Let us consider the embedding of the stegosignature 
in the main method of the following sample pro­gram: public class Fibonacci { public Fibonacci() {} 
 public static void main(String[] args){ int n=Integer.parseInt(args[0]); int a=0; int b=1; for (int 
i=1;i<n;i++) { int c=a+b; a=b; b=c; } System.out.println("Fib("+n+") = "+b);}} For this program, we 
are only interested in the values of n and b at the .nal states reachable from the initial states as 
de.ned by its operational semantics (and this de.nes its observational abstraction aO ). Stegokey and 
Stegosignature: The secret stegokey is assumed to be e =2, n1 = 30001 et n2 = 5421. The stegosignature 
is c1= 21349 and c2 = 3012. Stegomark: The stegoprogram is obtained by inclusion of the following stegomark 
(where, for clarity, the variables W and T are given explicit names of the form <W:ni :ci > and <T:ni 
:ci >,1 = i = e which, for discretion, should be chosen as more anonymous identi.ers by obfuscation). 
Stegomark for c1: int <W:30001:21349>, <T:30001:21349>; <W:30001:21349> = 1; <T:30001:21349> = <W:30001:21349> 
-111353; <T:30001:21349> = <W:30001:21349> * <T:30001:21349>; <W:30001:21349> = <T:30001:21349> -47305; 
 <T:30001:21349> = <W:30001:21349> * 4; <T:30001:21349> = <T:30001:21349> + 1566; <T:30001:21349> = <T:30001:21349> 
* <W:30001:21349>; <W:30001:21349> = <T:30001:21349> + 21494; Stegomark for c2: int <W:5421:3012>, <T:5421:3012>; 
 <W:5421:3012> = 1; <T:5421:3012>=<W:5421:3012>+-35539; <T:5421:3012>=<W:5421:3012>*<T:5421:3012>; <W:5421:3012>=<T:5421:3012>+11445; 
 <T:5421:3012>=<W:5421:3012>*658; <T:5421:3012>=<T:5421:3012>+971; <T:5421:3012>=<T:5421:3012>*<W:5421:3012>; 
<W:5421:3012>=<T:5421:3012>+4623; Stegoprogram: public class FibonacciWatermarked { public FibonacciWatermarked() 
{} public static void main(String[] args){ int n=Integer.parseInt(args[0]); int a=0; int b=1; int 
d=1; int e=35538; int f=1; int g=-111353; e=d*e; d=e+11445; g=f*g; f=g-47305; for (int i=1;i<n;i++) 
 { int c=a+b; e=d*658; f=f*4; a=b; g=g+1566; e=e+971; g=g*f; e=e*d; b=c; d=e+4623; f=g+21494; } System.out.println("Fib("+n+") 
= "+b); }}  5.3 Lifting the Data Size Physical Limitation The physical data size limitation, as given 
by the maximal integer m which can be represented by the type int in our sample abstract watermarking 
algorithm, can be lifted by considering integers of arbitrary size in the stegomark and stegoprogram 
non-standard se­mantics whence in the abstract semantics R¨[ P] computed an1...nby the static analyser. 
e For the static analyzer, the concrete interpretation of modulo arith­metic operations is in Z (whence 
non-standard for the program se­mantics). To handle this non-standard semantics correctly, the static 
analyzer must use libraries of big numbers. Of course such big numbers could also have been used in the 
stegomark but this would be too easily recognizable. The concrete execution of the instructions of the 
stegomark inlaid within the stegoprogram may over.ow. Fortunately this is com­pletely harmless with the 
standard integer modulo arithmetic. The only limitation to be taken into account is for the constants 
(like k0, k1, a, b, c) appearing in the text of the stegomark, which must be within the physical limitation 
imposed by the language. When too large in the standard concrete semantics, these constants can be computed 
in the non-standard semantics by program expressions using only constants satisfying the physical limitation 
imposed by the language standard semantics. Actual evaluation of the stego­mark (with over.ow in the 
standard concrete semantics but not in the non-standard one) will then be harmless thanks to modulo arith­metic. 
In case m is chosen much larger than the physical limitation and is kept secret, the stegosignature extraction 
is even harder if not impossible.  6. Requirements Satis.ed by Abstract Software Watermarking Our abstract 
software watermarking method satis.es a number of criteria discussed below which are advisable for all 
software wa­termarking methods (e.g. to be effective in the protection of the ownership of intellectual 
property). 6.1 Practical Requirements Satis.ed by the Watermarks Functionality Preservation: The watermarking 
should preserve the functionality of the subject program and so the semantics of the stegoprogram W[ 
P](s) should be identical as that of the subject program P 3. Formally, this means that up to some observational 
abstraction aO , the operational/denotational semantics S are the same and so for all P . P and s . S: 
aO (S[ P]) = aO (S[W[ P](s)]) = aO (S[I[ P, Mr (s)]]). Typically the abstraction aO gets rid of the auxiliary 
variables and the effect of the code which are inlaid in the subject program to encode the signature. 
Performance Preservation: The performance of the subject program should not be signi.cantly degraded. 
Our abstract soft­ware watermarking method preserves execution time up to some small constant factor 
(which is negligible for large programs). 3 up to e.g. a little more time and memory consumption for 
ex­ecution of the stegomark. Universality Preservation: If the subject program is universal (i.e. can 
be executed on any hardware with appropriate compiler or interpreter) then no special hardware should 
be required for ex­ecuting the stegoprogram (contrary to native code with encrypted signatures [6]). 
Unbounded Signature Size There should be no bound on the size of the signature (or it should be very 
large) thus allowing embedded signatures to be arbitrarily encrypted unique identi.ers. This is achieved 
both by decomposition of signatures c of size strictly bounded by n1 ...ne into e keys (c1,...,ce).[0,n1 
-1]×...×[0,ne -1] [Sec. 4.1] and by choosing large ni , i =1,...,n beyond the machine limitation m thanks 
to a non-standard reinter­pretation of modulo arithmetic in Z [Sec. 5.3]. Credibility and False Recognition: 
Since the signature uniquely identi.es the copyright owner, the watermarking should provide an authentic, 
clear, secure and indubitable proof that the stegoprogram is protected (as opposed to a false recognition 
or a probabilistic detection). For the watermarking to be credible, most programs should be unmarked 
that is the extraction of stegosig­nature from programs in which no signature has been embedded should 
not produce a false recognition. Formally, for all P, Q .P and s .S such that Q =W[ P](s), we should 
have: s . E[ Q] . (10) Of course, theorem 5.1 does not exclude false positives (since we want to be able 
to watermark the same method several times with the same stegokey). This means that it is possible to 
.nd a sub­ject program variable which happens to be a constant . in Lni for some i .[1,e]. This constant 
. might create an ambiguous result at extraction time whenever 0 =. =ci in contradiction with (10). A 
simple solution is to perform a signature extraction just af­ter signature embedding to check that this 
does not happen. If this happens one can either change the stegokey ni used for em­bedding/extraction, 
or change the stegosignature ci in the secret database of stegosignatures (for the given stegokey ni 
), or main­tain . as invalid for the stegosignature ci for the program P in the secret database for the 
stegokey ni , etc. Secrecy: The watermark, i.e. the stegomark inlaid in the subject program, should not 
reveal the signature when discovered by the average observer (but should be readily detectable by the 
proper authorities). In case the stegomark can reveal the signature, it is a good practice to encrypt 
the signature encoded within the stego­mark. Extracting the Signature from the Stegomark: It should be 
impossible, or at least computationally hard, to extract the stegosig­nature s .S from the stegomark 
Mr (s). As in many cryptographic methods, this is based on the use of a random stegokey n .N which is 
kept secret, so that the stegomark: int W; ... W = P(1); ... W =Q(W) can hardly reveal the signature 
which is left invariant by the stego­mark computation. Indeed, given polynomials P and Q, the ques­tion 
is to solve for the unknown x, n where: x = P(1)mod n x = Q(x)mod n . Following [12], let us set Q ' 
(X)= Q(X)-X,sowenow have x = P(1)mod n 0 = Q ' (x)mod n or equivalently 0 = Q ' (P(1))mod n. Anyone can 
compute Q ' (P(1)), which is some number i, and the problem is now to .nd n such that i =0 mod n which 
essentially amounts to factor i in order to .nd one factor of i (or even all of them). Factoring can 
reasonably be assumed to be hard for large factors. Hence one might want to check that i has large factors 
(which is easier when already knowing the factor n) and consider lifting the data size physical limitation 
as explained above. In prac­tice extracting the stegosignature s without knowing the secret ste­gokey 
n then essentially amounts to randomly trying all possible stegokeys n .N (or, at least a very large 
number of the possible stegokeys). Extracting the Stegomark from the Stegoprogram: Finally, it should 
be impossible, or at least computationally hard, to auto­matically discover the stegomark within the 
watermarked program W[ P](s) = I[ P, Mr (s)]). Obfuscation methods are helpful for that purpose. Again 
the static analysis method for signature ex­traction proposed in Sec. 5.1 En[Wn[ P](s)] depends on the 
secret stegokey n so that when n is unknown, the signature extraction es­sentially amounts to randomly 
trying all possible stegokeys. Robustness/Perenniality: The watermarks should be perma­nent. If visible, 
they should be hard or impossible to remove with­out investing a lot of time and/or without severely 
damaging the ste­goprogram so much that it becomes hardly usefully usable or leave traces on the modi.ed 
stegoprogram which can be immediately de­tected by comparison with the undamaged subject program. If 
not impossible, it should be computationally hard to re­cover the subject program P from the stegoprogram 
W[ P](s) = I[ P,Mr (s)]. One solution is for the software watermarker W[ P](s) to include an obfuscation 
of the stegoprogram. However this is not mandatory since obfuscation pursues different objectives. Moreover, 
and contrary to [2], we do not aim at obfuscating the observable semantics aO (S[ P]) of the program 
P (which can be speci.ed e.g. in a publicly available reference manual). Multiple Watermarks: Abstract 
software watermarking allows several different signatures to be embedded in the stegoprogram hence is 
robust against rewatermarking. Formally, marking with a new signature should not delete previous signatures: 
' if s .E[ P] then s .E[W[ P](s )] . The number of signatures should be unbounded (or very large) at 
the time that the subject program is created. Indeed the value of the stegokey n .xes the number of possible 
stegosignatures for that ste­gokeys, but the number of stegokeys is itself unbounded. Moreover if a program 
is signed several times, the extractors are only able to recover the signatures for which they are authorized 
provided they are given different stegokeys n. Fingerprinting: The abstract software watermarking method 
does allow .ngerprinting to uniquely mark each program for ev­ery buyer by a unique licence number. If 
that buyer then makes an illicit copy, the illicit duplication may be convincingly demon­strated by extracting 
the stegosignature which is the given licence number. 6.2 Practical Requirements Satis.ed by the Abstract 
Embedding/Extraction Algorithms Our stegosignature embedding/extraction algorithms satisfy the fol­lowing 
requirements which are desirable for all software water­marking tools. Automaticity: Signature embedding 
and extraction are fully au­tomatic and require no manual preparation of the subject program. Hence they 
are usable on a large scale and allow for checking of legal use, e.g. on the web. Low Cost: Signature 
embedding and extraction have a low com­putational complexity, comparable to compilation. Resistance 
to Counterfeiting: The watermark should withstand direct and automatic attacks (e.g. by creation of counterfeit 
of the subject program using typical automatic program transformations that are common to program manipulation 
applications such as ob­fuscation) but not disallow the copying of the signed .le. Formally, the watermarking 
should resist program transformations T . P . P that do not change the observable abstraction of the 
subject program semantics. This means that for all P . P , s . S: if aO (S[W[ P](s)]) = aO (S[T [W[ P](s)]]) 
then E[W[ P](s)] = E[T [W[ P](s)]] . In our case, the static analysis can be made more dif.cult so this 
problem is further discussed in Sec. 9. Resistance to Fraudulent Reuse Including with Hardware Protection: 
Since extraction requires no execution of the stego­programs at all, it is possible to extract the signature 
of the stego­program if only part of it is available but not executable (provided obviously that the 
available part of this stegoprogram contains the stegosignature). This makes possible the tracking of 
stegoprograms on the web or of parts of the stegoprogram included in another pro­gram itself protected 
e.g. by a hardware dongle. Public Domain: The embedding/extraction algorithms can be made public since 
they require a secret stegokey (but not the sub­ject program) for extraction. Moreover different extractors 
can be authorized owning different stegokeys without possible interactions between them. Pervasion: The 
embedding/extraction of the signature in the ste­gomark is symmetric since both depend on the same secret 
stegokey (n in Sec. 6.1). As noted by [12], it may be absolutely necessary to disclose information from 
time to time which may require, in ab­sence of trusted third authority, to make public the secret stegokey. 
In this case, copies of the software previously watermarked using the same stegokey, will be unprotected 
after the .rst action taken to enforce the watermark. One solution is to use .ngerprinting, that is a 
unique stegomark for each copy of the software with different stegokeys or to insert several stegomarks 
in all copies. A complementary solution is to choose the stegosignature s and the stegokey n as large 
primes (assuming again that the data size phys­ical limitation is lifted for unbounded signature size 
as in Sec. 5.3). The stegoprogram is marked with s by inserting the stegomark ini­tialization part: W 
= P(1) in Z and the stegomark iteration part: W = Q(W) in Z such that: P(1) = s in Z/nZ and s = Q(s) 
in Z/nZ as discussed in Sec. 4.2. The stegoprogram is then deposited with accompanying signatures s.pi 
where the pi , i = 1,...,k are large prime numbers for safekeeping by one or better several trusted third 
parties. In order for an unbiased third party to equitably verify that the stegoprogram is signed, the 
veri.er is given (at the i-th veri.ca­tion): the stegosignature s.pi ;  the abstract stegosignature 
extractor E;  the stegokey n.pi .  By ensuring that P(1) = s.pi in Z/n.pi Z and s.pi = Q(s.pi ) in 
Z/n.pi Z the veri.er can check that the stegoprogram is signed by s.pi and can do the same with the originally 
signed program. If the information (E,s.pi ,n.pi ) is made public, claimants might be able to discover 
the signature s.pi by designing their own pro­gram analyser. This may be a good reason to keep the extractor 
E private, or at least to have the extractor not reveal where the ste­gomark is within the stegoprogram, 
and shows the necessity for deterring attacks on stegomarks as discussed in next Sec 7. Never­theless, 
neither s nor n can be computationally discovered so that (s.pi+1,n.pi+1) can be used for the next veri.cation 
of stegopro­grams whose stegomark is persistent.  7. General Attacks on Signatures and Stegomarks Manual 
attacks against watermarked programs can hardly be avoided if enough manpower and time are available, 
so we con­centrate on automatic attacks. Let us recall the various attacks con­sidered by [3]: Subtractive 
attacks detect the presence and approximate location of the stegosignatures and eliminate the part of 
the program where it is supposed to be located. Examples of subtractive attacks in­clude static dead 
code elimination in case the stegosignatures are supposed to be hidden in dead code (see e.g. [14]) or 
dynamic ob­servation of the dead code in case the dead code is protected by an opaque predicate (opaque 
means that the outcome of the predicate is known at watermarking time but the predicate is dif.cult for 
an adversary to resolve i.e. to .nd the truth value solution of [1, 6, 14]). Distortive attacks apply 
transformations to the object so that the stegosignatures can no longer be extracted. Obfuscation and 
op­timizing compilation to generate machine code are such distortive attacks. Another example is [19] 
where secrets are hidden in se­quences of machine code, which can be easily distorted by replac­ing machine 
instructions by equivalent ones. Additive attacks watermark with new signatures so that one can­not be 
proved that the original mark temporally precedes the pirate ones. Collusive attacks remove signatures 
by comparison of different versions of the same program watermarked by different .nger­prints. An example 
would be diff (which is naïve since it can be easily defeated by obfuscation). For example [3, 16] encodes 
signatures into graphs generated when executing the program for special inputs. Program monitoring or 
a probabilistic static analysis can be used to discover the parts of the program that are seldom executed. 
Then a dependence analysis as in program slicing can be used as a subtractive attack eliminating the 
part of the program producing the graph. A distortive attack would modify the graph whence the signature. 
 8. General Attack Deterrence Subtractive attacks are made dif.cult if the elimination of the sig­nature 
changes/destroys the semantics of the program so that it be­come unusable. Therefore a good strategy 
is to make the stegomark dependent upon the subject program and reciprocally e.g. by trans­forming the 
subject code so that some values are computed as func­tions of the stegomark or have original and stegovariables 
merged, a well-known distortive attack! Distortive attacks may not all be disturbing. For example ob­fuscation 
makes reverse engineering even more dif.cult so might sometime be considered helpful. The same way code 
generation prevents easy redistribution hence is also a form of protection. Some distortive attacks can 
be prevented by considering only part of the code to extract signatures. Many of the obfuscation methods 
considered in [5, 6] can be defeated in this way. For example in­troducing dead and irrelevant code or 
converting a reducible to an irreducible .ow graph does not change the abstract interpretation of the 
useful code. The same way, opaque test and loop predi­cates [1, 6, 14] is no problem if the signature 
extraction does not depend upon predicates. However the embedding might include such opaque predicates 
for obfuscation purposes. Restructurations of classes (such as modifying inheritance relations, extending 
the inheritance hierarchy tree, false refactoring, method inlining, clone methods as considered in [5]) 
are ineffective if the signatures are embedded at the method level and the signature extraction is purely 
local, not depending on global variables. Some other distortive attacks can be prevented by considering 
only part of the program data to extract signatures. Among the obfus­cation methods, array restructuration 
considered in [5] and object aliasing considered in [6] can be simply defeated by putting no data in 
structured static or dynamic data. Additive attacks are dif.cult to .ght in particular if the embed­ding 
algorithm is made public. Note however that unique signatures as well as original and signed programs 
can be revealed to trust­worthy authorities at the embedding time to authenticate temporal precedence 
whence determine the actual owner of the program. Collusive attacks can be prevented by allowing the 
embedding of multiple signatures. A common initial watermark can be embedded in all copies. Moreover 
obfuscation of the copies using different program transformations (including e.g. different code reorderings) 
would make comparisons very dif.cult. Obviously not all possible attacks have been considered. The most 
harmful ones will be discussed in next Sec. 9. 9. Possible Harmful Speci.c Attacks The considered signature 
embedding and extraction methods dis­arm the general attacks considered in Sec. 7. We now consider spe­ci.c 
attacks against the protocol as described in [3, 6] that might be harmful. Obfuscation methods are obvious 
candidates for pre­venting signature extraction by making static analysis dif.cult, if not impossible. 
First note that if the protection is required at the method level we might be happy to consider only 
attacks which affects a method at a time. Otherwise the method is no longer ex­tractable from the whole 
program, which can be considered as a form of protection against illicit use. However most attacks aims 
at hiding the copyright so that masked signature redistribution in the large should be considered harmful. 
Counter-attacks may be classi.ed as follows: Light-weight counter-attacks essentially consist in improving 
the general-purpose abstract signature extractor for routine use (or us­ ing several ones with different 
analysis strategies according to the possible obfuscation strategies). Heavy-weight counter-attacks 
may need human help and the sub­ject program in order to built a speci.c abstract signature extractor 
for a case study (e.g. to prove copyright infringement). 9.1 Subtractive Attacks and Tamper-Proo.ng 
Counter-Attack One can easily design a dependence analysis to discover which lo­cal variables of the 
method will have no effect on the method com­putation. The auxiliary variables W and T could be located 
in this way and the corresponding embedding instructions eliminated by program dependence analysis and 
slicing. Classical tamper-proo.ng methods can detect if the program has been altered and cause the program 
to fail when. tampering is evi­dent [4]. They can therefore be used to prevent subtractive attacks. A 
simple tamper-proo.ng method to avoid automatic subtractive attacks consists in creating dependencies 
between the subject pro­gram and the inserted code. We consider three examples: 1. values can be allocated 
on the heap instead of in variables which make live/dead variable analysis much more dif.cult; 2. one 
may, on one hand, have the random values a and b be chosen as values of the program integer constants, 
have c be computed in terms of a and b and then a recomputed back in terms of b and c and b recomputed 
back in terms of a and c. This false dependency could only be discovered by symbolic computation which 
is beyond the scope of most compilers and obfuscators; 3. since the static analysis does not take tests 
into account, opaque predicates [1, 6, 14] can be used to anchor the stegomark statements inlaid in the 
stegoprogram by creating interferences between the two which spuriousness or genuineness is computationally 
dif.cult, if not impossible to detect. Let W be an integer variable used in the stegomark, V be a variable 
used in the subject program, let B(V, W) be an opaque predicate which is always false (like B(x, y) =7y2 
- 1 = x2 where x, y . Z [1]) and g(V, W) be any integer expression depending upon V and W. Then a stegomark 
statement of the form W = f (W) can be anchored in the stegoprogram in the form:  if (B(V, W)){W= f 
(W);V= g(V, W) } Since the value of the subject program variable V depends upon the value of the stegovariable 
W, it is hardly possible for an obfuscator to determine that the opaque predicate B is always false and 
so the value of W is thought to be indispensable so that the stegomark can­not be eliminate. If this 
unexecuted code can be located by run-time observations, then variants can use an opaque predicate B 
which is not identically false as in: if (B){V ' = V; W = f (W);V= g(V, V ' , W) } ... if (B){V=V ' 
} Just in case, we propose a more advanced and original method to create a dependence between the stegomark 
and that of the subject method. For that purpose, we can use properties of the stegovariable W which 
hold in the standard semantics (more precisely signed 32 bits arithmetic). This is possible, for example, 
when the stegokey n is a power of 2. Indeed, assume that n = 2k . Then, we have: W = v + a.2k in Z . 
We also have, always in Z, that, for all j . k : W%2 j = v %2 j where x%y denotes the operation returning 
the rest of the euclidean division of x by y. Observe that this property remains trivially true in Z/232Z 
which is the domain of value of integer variables in JavaTM. We can therefore use these arithmetic properties 
to mod­ify the computations of the subject method in which the stegomark is inlaid. For example, assume 
that n =216 and that v =18. Then whichever the value of the variable W is, we always have: W%4 =2 . If, 
for example, the constant 1 appears explicitly in the subject pro­gram, then it can be replaced by W%4 
-1. Now, if the variable W is dynamically modi.ed using the techniques developed in Sec. 4, the variable 
W takes values during program execution which apparently stochastic, but have a hidden invariant which 
is used for stegomark anchoring. The stegoprogram thus modi.ed preserves its original concrete semantics 
but would be irreversibly damaged if the stego­mark is eliminated. An involved static [11] or dynamic 
analysis of the behaviour of the variable W is necessary to detect the invariant on which relies the 
dissimulation. Moreover, such constant dis­simulations can be automatically generated at random points 
of the program. 9.2 Subtractive Attacks on Low Stealthiness and Counter-Attacks Static Attack on Low 
Stealthiness: As shown in the example of Sec. 5.2, this watermarking scheme often results in very unusual 
integer literal constants being inserted into the program. Literal constants with 5 or 6 digits as in 
the example can be extremely rare in real programs. An anonymous referee collected and classi.ed all 
the integer literals from some 600 Java programs, 1.4 million lines in all and observed that 80% of all 
literal integers are between 0­99, 95% are between 0 and 999, 92% are powers of two or powers of two 
plus or minus 1. Because of this lack of stealthiness, the anonymous referee suggested that an attacker 
could expect to be able to locate the watermark code simply by looking for large literal constants. A 
light-weight counter-attack would be to compute large constants in term of small ones privileging powers 
of two or powers of two plus or minus 1 in this computation. A diversion would consists is spreading 
large integers elsewhere in the code, may be with dependences so that there elimination would make the 
code inoperative. In the same line one can try to detect the iterations of polynomials of degree greater 
than or equal to 2, which are operations rarely occuring in practice. When the stegokey n =2k is a power 
of 2, a static attack consists in extracting modulo n ' where n ' is is the greatest power of 2 dividing 
'' i =Q ' (P(1)). This yields c =P(1)mod n such that the value of ' the signature c corresponds to the 
k lower bits of c . Since k is un­known, this provides only partial information on c, maybe too much 
for this choice to be considered safe. This shows that in all cases the stegosignature c should be an 
encryption of the information not to be revealed. In all cases, an obvious counter-attack on low stealthiness 
would be to hide the stegomark using a non-standard concrete semantics for signature extraction. Dynamic 
Attack on Low Stealthiness: In Sec. 4.2, we observed that the variable W will take on values that are 
stochastic . An anonymous referee suggested to monitor the program execution to look for integer variables 
updated within loops whose values are random. A light-weight counter-attack consists in making the stegomark 
seldom executed together with pseudo-random number generators spread in the program for diversion. Other 
appropriate datatype obfuscations are considered in Sec. 9.5, including using a nonstandard semantics 
of (e.g. heap-allocated) .oating point num­bers for which such dynamic attacks would be much harder. 
Dynamic Attack on Unusual Variable Values: An anonymous referee suggested to monitor the execution to 
keep track of the se­quence of values i0, i1, ..., ik successively taken by all integer variables I of 
the program. If I is a watermark variable then nj |g for some j .[1,e]where g =gcd(i1 -i0,i2 -i0,...,ik 
-i0).A large g is an indication that I might be a watermark variable and provides information on nj for 
factoring. A light-weight counter-attack consists in exploiting the random­ness in tests so that some 
assignments to watermark variables are rarely executed whence leading to a small k. Extraction is un­changed 
since tests are ignored. Another counter-attack is to rely on a non-standard semantics for the static 
analysis as considered e.g. in Sec. 5.3 since the above reasoning assumes the concrete values of watermark 
variables that are abstracted for extraction to be their execution values. 9.3 Reinterpretation and 
Counter-Attack Reinterpretation or table interpretation consists in reencoding the program for a different 
virtual machine code. If the virtual machine speci.cation is secret then again signatureless redistribution 
is im­possible in the large whence might be considered harmless. Otherwise this may require the redesign 
of the abstract interpreter used for signature extraction in order to take the virtual machine code into 
account. This might require rewriting the abstract signa­ture extractor for all (known) JavaTM virtual 
machines, an obviously heavy weight counter-attack. 9.4 Control Obfuscation and Counter-Attack The objective 
of control obfuscation is to obscure the control .ow without changing what the code does at runtime. 
Typically, selec­tion and looping constructs are changed so that they no longer have a direct JavaTM 
source code equivalent. Let us consider several clas­sical such transformations. Sequential Code Reordering 
and Counter-Attack: Reorder­ing of the code sequential composition, test and loop statements must preserve 
the order in which the elementary statements are ex­ecuted in a method (unless this order is irrelevant) 
and so the static analysis of Sec. 5.1, which does not take the control structure of the method into 
account, is insensible to this transformation. If neces­sary, goto statements can easily be handled in 
static analysis. Proceduralization and Counter-Attack: Conversion of static to procedural data (make 
a procedure to compute a value instead of original constant). Constant propagation can be trivially extended 
from the intrapro­cedural case considered here for stegosignature extraction to the interprocedural case 
[18], in which case the extraction technique remains the same. Outlining and Counter-Attack: Splitting 
a method into several disjoint methods (e.g. by inlining and different reproceduraliza­tion). Again the 
counter-attack is interprocedural constant propagation. Parallelization and Counter-Attack: Conversion 
of sequential to parallel programs. Again the transformation must preserve the order in which the ele­mentary 
statements are executed so the static analysis of Sec. 5.1 is insensible to this transformation. Otherwise, 
the static analysis can be extended to parallel programs (see e.g. [8]). 9.5 Data Obfuscation and Counter-Attack 
Another form of obfuscation is data obfuscation where the program global, local and heap data are reallocated 
in more complex struc­tures. We now consider a few examples. Globalization and Counter-Attack: Replaces 
all or some local variables into global variables. This might be easily taken into account by the analyser 
which could also consider global integer variables, either all possible global vari­ables or only the 
necessary ones, which may not be very dif.cult to detect for those possessing the subject code (the list 
of such global variables might be a parameter of the static analysis). Built-in Datatype Reallocation 
and Counter-Attack: Put all data in arrays or heap allocated structures. First note that the ab­sence 
of simple datatype variables is quite suspect. But not moving all simple variables means that the ones 
used to hide watermarks might be omitted. Using arrays means that constant propagation can detect indices 
designating simple variables so heap allocated structures should be preferred. But then note that if 
the obfuscator is likely to create a small dynamically allocated structure so that its shape might be 
easily determined by analysis algorithms using a threshold widening [17]. Otherwise cache behaviour and 
addi­tional garbage collection might severely worsen the program per­formance. Then note that this idea 
might be used to hide the stegovariables in dynamically allocated data structures which could hardly 
be modi­.ed by obfuscating by fear of modifying the program semantics but for which the signature extraction 
would be possible by designing analysers speci.cally for the type of structure which is used (e.g. balanced 
trees [9]). Built-in Datatype Obfuscation and Counter-Attack: Obfus­cating built-in datatypes (such as 
integers and strings) by variable splitting and merging. To do so, obfuscators routinely use the alge­braic 
law of integer arithmetic to transform the code. For a trivial example, consider the assignment: e=35538; 
which can be transformed into: f=71077; e=(f-1)/2; Since the integer division is not used in the stegomark, 
the static analyser need not implement the abstract version of integer divi­sion, which will be simply 
ignored, whence obliterating the signa­ture extraction. An obvious riposte is for the static analyser 
to anticipate all such possible obfuscating transformations and to: 1. use non-standard semantics which 
are invariant under such transformations (which, e.g. might not be the case when interpret­ing modulo 
arithmetic as integer arithmetic); 2. implement all abstract operators corresponding to the concrete 
operators that can be used for program transformation by obfusca­tors; 3. obfuscate the code in order 
to prevent further obfuscations.  A complementary solution consists in relying on program con­structs 
for which data and operation transformation is very dif.cult. This is the case for example for .oating 
point arithmetic which does not satisfy the usual mathematical identities (such as associativity, commutativity, 
etc) which are valid for the reals. It follows that obfuscators will have more dif.culties to modify 
all .oating point operations, except trivially. Consequently, a simple riposte to obfuscation is to implement 
the stegomark with .oating point arithmetic. Care must be taken to prove the absence of over.ow (since 
.oating point arithmetic is not modular) or to catch all potential exceptions that can be raised in the 
stegomark and to annihilate their effect. It follows that the stegomark does not perturb the normal stegoprogram 
execution. Now in the non-standard semantics which is used for signature ex­traction, and therefore in 
the abstract semantics for the static anal­ysis, all .oating point operations of the stegoprogram can 
be inter­preted as integer operations. The translation is simply one to one for arithmetic operators. 
Floating point constants must be converted into integers (may be up to some secret factor). 10. Implementation 
The abstract software watermarker that we have designed and used for our experimentation is based on 
SOOT [20] which is a static analyser generator for JavaTM itself written in JavaTM. The SOOT optimizing 
framework offers different possible interme­diate representations of JavaTM source programs. For simplicity, 
we assume that the subject program P . P is represented in Jim­ple style [20] , that is unstructured 
stackless 3-address code using typed auxiliary variables. Moreover, we can also assume that the jsr bytecode 
has been eliminated and the intermediate code is or­ganized as a control .ow graph of basic blocks. A 
decompiler is necessary to see the Jimple code in JavaTM form. The stegosignature embedder is implemented 
as speci.ed in Sec. 4. The implementation of the extractor essentially amounts to that of the basic abstract 
domain, as well as the abstract environments, of the corresponding basic abstract operations and those 
used in the abstract transformer in SOOT. Then SOOT can generate automati­cally the static analyser described 
in Sec. 5.1. Finally, the abstract software watermarker has essentially to maintain a database of own­ers 
of stegokeys and corresponding stegosignatures and provides an elementary user interface. 11. Experiments 
Ef.ciency: The abstract software watermarking takes no addi­tional developer time (but to choose which 
methods should be wa­termarked, to choose a stegosignature and to submit the subject software to the 
automatic stegosignature embedder). The recogni­tion time to extract the stegosignature is comparable 
to compilation time and so is ef.cient. The runtime costs are also negligible since for medium and large 
programs we could not observe signi.cant modi.cations in the re­quired memory and computation time resources. 
Robustness: We have conducted several experiments which con­sist in watermarking one method in a class, 
then in obfus­cating the class with JavaTM obfuscators (JcloakTM and Zelix klassmaster) and then in extracting 
the signature from the ob­fuscated class. After a few improvements of the static analyser as described 
in Sec. 9, these obfuscators mainly using name obfusca­tion, .ow obfuscation and string encryption could 
not disarm the stegosignature extraction. Consequently, obfuscators can be used after signature embedding 
to obscure the work of stegoanalysts. 12. Conclusion We have proposed a new class of software watermarking 
and .n­gerprinting methods called abstract software watermarking. The key idea is to anchor a stegomark 
in the program, that is state­ments which static analysis will reveal the stegosignatures. We exempli.ed 
an instance based on modular constant propagation parametrised by a secret stegokey, which is equivalent 
to in.nitely many distinct instances of the abstract watermarker. The key idea is that the stegosignature 
extraction is neither static (it is based on the semantics of the program not on its syntax), nor dynamic 
(pro­gram execution does not reveal the stegosignature) but abstract (the stegosignature is revealed 
by abstract interpretation of a (may be non-standard) state or trace-based collecting semantics of the 
pro­gram). Since static analysis is undecidable (even for simple anal­yses like constant detection), 
the static analyser which is used for extraction can be designed to be involved enough so that extrac­tion 
is impossible if the extraction algorithm is not perfectly known. Even if the signature extractor is 
made public, it is still possible to use abstract domains parametrised by secret stegokeys which make 
signature extraction computationally hard, if not impossible. It is clear that stegoanalysis against 
this new class of abstract soft­ware watermarkers will improve. In response, the abstract soft­ware watermarking 
framework allows considering more sophisti­cated abstract interpretation-based static analysers thus 
making ste­goattacks even more dif.cult. As is the case in cryptography, the rivalry between watermarkers 
and attackers may be endless and the source of much progress. Acknowledgements: This work was supported 
by the RNRT ( Réseau National de Recherche en Télécommunications of the french Ministère de la Recherche 
and the Ministère de l Économie, des Finances et de l Industrie ), project n. 95 Tatouage électronique 
sémantique de Code Mobile Java , 1999 2002. We thank J. D. GUTTMAN for his help with Sec. 6.1 and for 
inspiring Sec. 6.2, M. RIGUIDEL for bringing our attention to software watermarking, A. VENET for his 
participation in the early stage of the project, the Sable Research Group at McGill Univer­sity, Montreal, 
Canada, in particular L. HENDREN,P. LAM and F. QIAN, for their help in the use of SOOT, especially during 
P. COUSOT s visit at McGill in September 2000, B. BLANCHET,J. FERET,A. MINÉ,D. MONNIAUX,X. RIVAL and 
the anonymous referees for their shrewd comments. 13. References <RefA>[1] ARBOIT, G. A method for watermarking 
JavaTM programs via opaque predicates. In Proc. Int. Conf. Electronic Commerce Research (ICECR-5) (Montreal, 
CA, 23 27 Oct. 2002). [2] BARAK, B., GOLDREICH, O., IMPAGLIAZZO, R., RUDICH, S., SAHAI, A., VADHAN, S., 
AND YANG,K. On the (im)possibility of obfuscating programs. In Proc. CRYPTO 2001, Santa Barbara, CA, 
LNCS 2139 (19 23 Aug. 2001), J. Kilian, Ed., Springer, 1 18. [3] COLLBERG, C., AND THOMBORSON, C. Software 
water­marking: Models and dynamic embeddings. In 24th POPL (San Antonio, TX, 20 22 Jan. 1997), ACM Press, 
311 324. [4] COLLBERG, C., AND THOMBORSON, C. Watermarking, tamper-proo.ng, and obfuscation tools for 
software protec­tion. IEEE Trans. Software Engrg. 28, 8 (Aug. 2002), 735 746. [5] COLLBERG, C., THOMBORSON, 
C., AND LOW, D. Break­ing abstractions and unstructuring data structures. In Proc. 1998 ICCL (Chicago, 
IL, 14 16 May 1998), IEEE Comp. Soc. Press, 28 38. [6] COLLBERG, C., THOMBORSON, C., AND LOW, D. Manu­facturing 
cheap, resilient, and stealthy opaque constructs. In 25th POPL (San Diego, CA, Jan. 1998), 184 196. [7] 
COUSOT,P., AND COUSOT, R. Systematic design of program analysis frameworks. In 6th POPL (San Antonio, 
TX, 1979), ACM Press, 269 282. [8] COUSOT,P., AND COUSOT, R. Invariance proof methods and analysis techniques 
for parallel programs. In Automatic Program Construction Techniques, A. Biermann, G. Guiho, and Y. Kodratoff, 
Eds. Macmillan, 1984, ch. 12, 243 271. [9] GHIYA, R., AND HENDREN, L. Is it a tree, a dag, or a cyclic 
graph? a shape analysis for heap-directed pointers in C. In 23rd POPL (St. Petersburg Beach, FL, 1996), 
ACM Press, 1 15. [10] GOSLER, J. Software protection: Myth or reality? In Proc. Advances in Cryptology 
 CRYPTO 85, LNCS 218 (Santa Barbara, CA, 18-22 Aug. 1985, 1986), H. Williams, Ed., Springer, 140 157. 
[11] GRANGER, P. Static analysis of arithmetical congruences. Int. J. Comput. Math. 30 (1989), 165 190. 
[12] GUTTMAN, J. D. Private communication. 21 Jan. 2003. [13] KILDALL, G. A uni.ed approach to global 
program opti­mization. In 1st POPL (Boston, MA, Oct. 1973), ACMpress, 194 206. [14] MONDEN, A., IIDA, 
H., MATSUMOTO, K., INOUE, K., AND TORII, K. A practical method for watermarking JavaTM pro­grams. In 
24th IEEE Computer Software and Applications Conf. , Compsac 2000 (Taipei, Taiwan, 25 29 Oct. 2000), 
191 197. [15] NAGRA, J., COLLBERG, C., AND THOMBORSON,C. A functional taxonomy for software watermarking. 
In 25th Aus­tralasian Computer Science Conf. (ACSC 2002) (Melbourne, Australia, Jan. 2002), M. J. Oudshoorn, 
Ed., Conferences in Research and Practice in Information Technology, ACS. [16] PALSBERG, J., KRISHNASWAMY, 
S., KWON, M., MA, D., SHAO, Q., AND ZHANG, Y. Experience with software water­marking. In Proc. 16th ACSAC 
00, New Orleans, LA (11 15 Dec. 2000), IEEE Comp. Soc. Press. [17] SAGIV, M., REPS,T., AND WILHELM, R. 
Shape analysis. In Proc. Int. Conf. CC 2000, LNCS 1781 (Berlin, DE, 25 Mar. 2 Apr. 2000), D. A. Watt, 
Ed., Springer, 1 17. [18] SAGIV, M., REPS,T., AND HORWITZ, S. Precise interpro­cedural data.ow analysis 
with applications to constant propa­gation. Theoret. Comput. Sci. 167, 1&#38;2 (1996), 131 170. [19] 
STERN, J., HACHEZ, G., KOEUNE,F., AND QUISQUATER, J.-J. Robust object watermarking: Application to code. 
In Proc. 3rd Int. Work. on Information Hiding, IH 99 (Dresden, DE, 29 Sep. 1 Oct. 1999), A.P.tzmann, 
Ed., vol. 1768 of LNCS, Springer, 368 378. [20] VALLÉE-RAI, R., HENDREN, L., SUNDARESAN,V., LAM, P., 
GAGNON, É., AND CO, P. Soot a JavaTM optimiza­tion framework. In CASCON 99 (IBM Center for Advanced 
Studies Conference) (Toronto, Ontario, CA, 8 11 Nov. 1999), 125 135</RefA>.   
			

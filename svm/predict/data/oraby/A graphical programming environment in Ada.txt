
 A GRAPHICAL PROGRAMMING ENVIRONMENT IN ADA Jorge L. Diaz-Herrera George Mason University and Shawna 
C. Gregory IBM Corporation INT~TI~ In this paper we present a system, implemented in Ada, aimed at 
aiding the understanding of structured software. The most meaningful program structure (as seen by the 
designer) is lost in the linear nature of program text. It is possible, however, to preserve it in the 
underlying program environment as a flexible file structure to which compilers (and other tools) can 
simply add further more detailed information. We find that a solution is to separate design concerns 
EXPLICITLY from the outset, and to provide more appropriate representational and operational mechanisms 
than convetionsl flowcharts and pencil and paper. The use of the HSD notation and the Pascal/HSD system 
were originally developed to address these needs [2,3]. The HSD graphical notation is suitable for representing 
program designs showing levels of decomposition using well-structured programming constructs. The underlying 
methodology clearly separates the notions of the enclosing environment within which a program exists 
(semantics definitions derived from object-oriented design) from the design decisions generated by the 
division of the problem into subproblems. The Pascal/HSD programming system provided an opportunity for 
experimenting with these ideas. The system provides a systax-directed structured editor, a compiler and 
an interpreter, all integrated around a program data base, and interfacing with the user through a satellite 
graphics computer. In extending this initial effort, Pascal/HSD has been rewritten using Ada as the 
implementation language. Although the flexibility of Pascal/HSD editor allows for the use of virtually 
any source language, the system still accept only Pascal programs. The decision to continue to use Pascal 
as the source language was made purely based on the desire to have the system working rapidly. Dispite 
this, Ada's lack of set operations caused minor problems in implementing the compiler and the interpreter 
(see below). Major changes were made related to the handling of the tree- structured program data base, 
and to the graphics terminal interaction. COPYRIGHT 1986 BY THE ASSOCIATION FOR COMPUTING MACHINERY, 
INC. Permission to copy without fee all or part of this material is granted provided that the copies 
are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of 
the publication and its date appear, and notice is given that copying is by permission of the Association 
for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. 
 ~T~TI~ The notion of abstraction is at the heart of current software design philosophies. We generally 
agree that software design can be viewed as the process of devising appropriate higher-level abstractions, 
both to hide the actual implementation of the objects and the actions upon them, (e.g. Abstract types), 
and to delay the detailed implementation of design decisions or subalgorithms (e.g. top-down refinement 
steps). The resulting designs show both a linear hierarchy of languages, and an inherent tree-like structure, 
which comes from the definition of higher-level abstract types and from the successive use of refinements 
steps, respectively. It is our contention that this program structure must be retained, and easily "seen", 
in the final software in order to increase program comprehensibility as well as the confidence of the 
reader. Furthermore, refinement steps should be accentuated and their presence maintained, throughout 
the development process, at as many levels of abstraction in a program as desired. Glinert and Tanimoto 
[6] present a convincing argument as to the benefits derived from a programming language that records 
and reflects the thought processes used in the solution of a problem. Pascal/HSD is such a programming 
language. The program design is represented graphically using a minimal number of constructs, each made 
of combinations of only two symbols. Most software developers cross the bridge from design to implementation 
by hand-translating the design representation to actual code. However, a systematic implementation of 
the various kinds of abstractions, as actual language constructs, presents a number of difficulties. 
In fact, the main source of problems stems from the lack of understanding about the kinds of abstractions 
dealt with in programming (e.g., refinement steps and functional abstractions), and from the confusion 
between the abstract notions of program design and organization and their concrete implementation as 
language constructs [e.g., procedures, packages, modules, blocks. This separation of concerns is particularly 
useful for producing more reliable, modifiable, and reusable software because it eases program comprehensibility 
and its correctness proof. It is also of critical importance from the point of view of the semantics 
of the abstractions introduced and their implementation. At this point it seems useful to discuss further 
the fundamental notions of Global (or problem) abstractions and Local (or design) abstractions, as important 
mechanisms for program design and implementation. (A more detailed discussion can be found in [4]). 
Global (or problem) Abstarctions During Object-oriented design "objects and operations found in the 
problem domain or real- world domain must be translated into corresponding objects and operations in 
the problem-solving domain..." [13, p126]. This leads to the definition of a set of Global Abstractions 
which refer to general concepts being used throughout the solution to the problem. They define enclosing 
environments within which programs exist. We call this programming approach BOTTOM-UP ABSTRACTING. Global 
abstractions specify higher-level operations on higher-level data structures. They describe an interface 
between the problem on hand and the programming language used to solve it; in this sense, global abstractions 
are like primitives of a "new" problem-oriented language. Hence, we also called them problem abstractions. 
Users of global abstractions are not concerned with their implementation (no more than they are concerned 
about the implementation of any programming language), they only need to know their specification. Modern 
programming languages provide good facilities for implementing problem abstractions, including the ability 
to compile them separately. Local (or design) Abstractions During top-down step-wise-refinement program 
development one describes the actions required, at a given level of abstraction, using simple imperative 
natural language statements. The next step is to refine one of the "abstractions" introduced producing 
a solution to this subproblem in terms of more abstractions. One of these abstractions is in turn refined, 
and the whole process repeated until a level of detail is reached in which all abstractions can be written 
in a programming language. Thus, design abstractions are generated by the division of the problem into 
subproblems. We have called these intermediate designs, Local Abstractions, since their sphere of influence 
is strictly within the context of a subproblem. Local abstractions represent complete subalgorithms, 
hiding design decisions, and can be substantially more complex than global abstractions. A more important 
notion about local abstractions is that they occur only once in a program and within the context of other 
subalgorithms; therefore, the organization of local abstractions in the form of libraries does not make 
sense (as is the natural and common practice for global abstractions), since these abstractions are used 
only ONCE in a program, and furthermore, their meaning is strictly restricted to the context where they 
are used. Programming languages do not provide specific constructs for representing local abstractions 
or refinement steps. The most we can do is to implement each of these design abstractions as subprograms 
or simply "in situ" code. In fact, programming textbooks make heavy use of procedural abstraction as 
the general style for implementing refinement steps, they invite programmers "to formulate a sequence 
of statements as a procedure once..."[14]. Furthermore, recent studies [1,11] indicate that this is the 
current practice. (For example, half of the procedures used in the programs examined were called only 
once and 92% of the procedures had no more than two parameters!). There is an important deficiency in 
this process of substituting refinements by subprogram calls: the Local Abstractions, which describe 
intermediate stages of the deslge, are replaced by their corresponding implementation. This is precisely 
the aspect we want to call attention to, since ALL local abstractions must be present in the final solution 
in order to enhance its readability (and to know how the program was designed~). Subprograms are NOT 
at all adequate for specifying refinements, their use in this context presents a number of significant 
shortcomings, giving rise to additional problems, a description of which can be found in [5].   THE 
PASCaL/HSO SYSTEM A great deal of attention is being given to the advantages of interactive systems in 
addition to the use of graphics for program representation [6,8,9, and lO]. Graphics is a more natural 
representation and Pascal/HSD reduces the complexity inherent in most higher level programming languages 
by retaining the higher level abstractions and associating the corresponding refinements appropriately. 
 In ensuring structured programming, Pascal/HSD forces top-down, step-wise refinement: a fundamental 
aspect of software engineering principles. A novice programmer does not have to be knowledgeable about 
software engineering or worry about the maintenance aspects of programming such as indentation or keyword 
memorization. Pascal/HSD handles these details. Since the program is represented as a binary tree which 
can only be viewed via the Pascal/HSD tools, the user is free to concentrate on the solution to the problem 
at hand. The set of tools provided in the system includes a graphical syntax-directed program editor, 
a compiler and an interpreter for Pascal/S [15], all interfacing with the user via a graphics terminal 
and integrated through a program data base. User programs are edited using the HSD graphical notation, 
which may also be shown while the program is being compiled and interpreted. This, incidentally, provided 
a powerful tool for demonstrating how the compiler works. The  interactive top-down interpretation of 
the source (graphical) program not only showed the executed source statements, but also all the levels 
of abstraction (both the higher level design decisions, refinements and the lower level s-code produced 
by the compiler). The actual body of a called procedure could also be shown at the time of the call. 
This resulted in an effective debugging tool. The system was implemented on a VAX 11/780 and written 
in Telesoft ADA Version 1.5. The actual code amounts to about 15,000 lines of Ada code, grouped into 
several packages isolating the device dependencies and grouping related entities (see figure 1). The 
programmer interface was implemented for a Tektronix 4107 Graphic Display Terminal. This module required 
the use of non- standard packages specially provided to by-pass the VMS operating system. Figure l: 
SYSTEM COMPONENTS Unit Size Type Description V23USR 40 Ass. Rt O.S. Interface VMS IFACE lO0 package Ada-O.S. 
Intface TEK--UTIL 165 package TEKTRONIX routines TEK--OPCD 330 package TEKTRONIX op code TEK'-1680 package 
Terminal Handler UCS GDATA 170 package UCS Graphics Data UCS-'GSYM 375 package UCS Graphics Symbols UCS-DEBG 
80 package UCS debugging UCS--GRAPH 1500 package UCS Graphics Interface UCS-DATA 410 package UCS General 
data UCS-SUBP 414 package UCS General Subprograms PS_SYMSET 80 package Pascal/S symbol set PS TYPSET 
80 package Pascal/S Type set PS--_ERRSET 80 package Pascal/S error set EDIT TEXT 315 procedure Editor 
Text Mode EDIT--TOKN 455 procedure Editor Token Mode EDIT--UITL 480 package Editor Utilities HSDEDIT 
255 procedure Pascal/HSD Editor COMP DATA 500 package Compiler Data COMP--UTIL 520 package Compiler 
General COMP--LX 650 package Lexical Analyzer COMP--BK1 455 package Syntax Analyzer COMP--BK2 1575 
package Syntax Analyzer COMP--BK3 1005 package Syntax Analyzer HSD-~OMP 135 procedure Compiler Main 
 COMPCG ll5 package Code Generator INT UTIL 701 package Interpreter Utilities HSD--INTR 419 procedure 
Interpreter Main HSO STAB 770 procedure Syntax Table Genergrator The VMS Interface Telesoft ADA Version 
1.5 has a crude interface to the VAX assembly language implemented by calls to a package called VMS CALL. 
It calls an ADA kernel module that in tur~-calls an assembly code routine supplied by the user. This 
scheme allows a user to pass a "function code" and up to three system addresses to the assembly code 
module. When the assembly code module gets control, the function code number and any specified addresses 
have been loaded into specific registers. Return is to the ADA kernel which eventually gets back to the 
requesting ADA procedure. Since Ada's low-level features are not implemented in the version of the compiler 
we had access to, it was necessary to write the VAX assembly code for queueing the I/O requests directly 
bypassing any VMS operating system interception or echo to the terminal on input. It was also necessary 
to write the assembly code which determines the channel the terminal is connected to as this is needed 
to queue the I/O request. Each function was assigned a code number and this modified assembly code module 
was used in place of the system provided routine. This approach is similar to the use of an implementation-supplied 
Ada standard Low Level IO package. The VMS interface package, written in Ada, accepts channel, input, 
and output requests. It takes care of obtaining the system addresses of the parameters to pass to the 
assembly routine, and also passes the correct function code for the request. The Tektronix 4107 Graphic 
Display Station Tektronix commands are listed in the Tektronix manuals as "Setup Mnemonics" along with 
the actual control sequence opcodes that would have to be transmitted from a computer to perform that 
command. There are over 250 graphic display commands. Three Ada packages were provided in order to use 
the Tektronix. The first package was used to convert the Tektronix Mnemonics to the actual ASCII sequence 
that must be transmitted to the HSD programs. This centralized the ASCII sequences in one place. The 
second package provided the utility functions for working with the Tektronix; subprograms in this package 
take application program values and perform the encoding algorithms passing back the encoded string; 
others maintain a stack of picture "segments" (a graphic entity that can be stored in Tektronix internal 
display station memory). The third package in this group contained the "Applications Interface" to Tektronix 
command functions; the package handled entirely the input from the Tektronix keyboard and the output 
to the display station buffer queue. User Communication Subsystem The User Communication Subsystem 
(UCS) is the next higher-level set of abstractions supporting the Pascal/HSD system, and it was implemented 
in six packages. Two packages (UCS GData and UCS_GSym) grouped declarations of types~ variables, data-structures, 
and constants used throughout the UCS graphics control code, and contained the Tektronix draw commands 
for each of the graphics symbols representing language constructs (e.g. IF symbol).  A third package 
(UCS Graph) contained the "real" UCS graphics interfac~ to and from the Pascal/HSD editor, compiler, 
and interpreter. It maintains a "display file" data structure model which keeps track of all symbol occurrences 
that are currently active in the session, the text included in the symbols, where they should be located 
on the display screen, and other control information. This is the most important package of this group, 
so let's explain it a bit further. All of the basic HSD symbols are drawn once at package initialization 
time and stored as segments in the Tektronix internal memory. As symbol occurrences are requested, new 
segments are built by "including" a copy of that master copy and then adding any text specific to the 
occurrence. The editor, compiler, and interpreter send integer values through the interface procedure 
(UCS_SUBP.Puttty) to request services such as inserting a symbol, moving the cursor to the next symbol, 
"refining" a symbol, starting text editing, inserting a character, moving the text cursor, moving the 
picture to the right, etc. There are approximately forty-six function requests that it services. For 
example it will take six requests for picture movement and zooming requests directly from the keyboard 
without passing anything to the driving Pascal/HSO processing program.  This package also directs the 
Tektronix to maintain a"dialog area" on the screen which can be used to carry on regular text conversations 
or to display messages. The dialogue area "surface" sits out in front of the graphics area surface so 
the pictures do not get overwritten. A new request code was added to this package so that the Pascal/HSD 
programs could request this dialogue mode service. It should be noted that this third package does not 
actually perform the Tektronix 4107 manipulation. It performs the services requested at a "logical" level 
with the display model and then requests services from the device controller package to physically manipulate 
the 4107 display. Two more packages in this group contained global data (UCS Data) for use by all of 
the remaining Pascal/H-SD packages and procedures, and global subprograms (UCS SUBP) that had originally 
been repeated in all Pa~al/HSD system components. The final package was used for recording debug information. 
Trace variables recorded all communications traffic to and from the UCS and proved extremely valuable 
in the "integrated testing" phase of this project. The remaining components of Pascal/HSD were re- written 
in Ada from their original Pascal version. Following are some aspects of this process. FRON PASCAL TO 
The task of converting Pascal/HSD was divided into five discrete pieces with the integration of these 
pieces occurring toward the end of the project cycle. Considering the limited interaction between the 
four student members of the team, the results at integration time were extremely positive. Although there 
was a linear dependency between the components, as illustrated in the following figure, the integration 
phase progressed as a faster pace than originally expected. Overall, the entire project was completed 
within a four month time frame with only four graduate students, two of whom were part-time. I USER 
I ^^ II VV I GRAPHICS INTERFACE I ...... : ................. : ................. : .......  I I I V 
V V  .............. f .............. f .............. I Pascal/HSO l=i=,l Pascal/HSO l=i=,l Pascal/HSO 
I I Editor I 1 I Compiler I 1 I Interpreterl .............. ^ e .............. e ^ .............. ^ 
I .................... I .............................. I I SYNTAX TABLE I .................................................. 
 Based on the value of this experience, we would like to discuss some of the problems that this effort 
incurred. In addition, we will identify some of the deficiencies and advantages of using Ada as the implementation 
language. As stated earlier, Pascal/HSD was originally implemented in Pascal. The conversion to Ada 
as the implementation language was, in itself, the real experience. With the exception of the User Communications 
Subsystem (originally in assembly language), the components of Pascal/HSD were almost directly translated 
from Pascal. The Syntax table generator, the Syntax-Directed Editor, the Pascal/HSD Compiler and the 
Pascal/HSD Interpreter form the rest of the Pascal/HSD system. These programs were not substantially 
modified (from the point of view of the algorithms) other than grouping items (objects and subprograms) 
into suitable packages. The original User Communications Subsystem was written in assembly language 
for an IMLAC satellite computer graphics system. The conversion of the User Communications Subsystem 
required a thourough understanding of the algorithms involved in order to generate the correct Ada version. 
(Most of this effort was already discussed in the previous section). One of the primary advantages of 
translating ADACOMPILER LIMITATIONS from Pascal to Ada lies in the similarities of the programming constructs 
in these higher-level languages. As stated in [12]"program conversion can often be undertaken successfully 
without a detailed understanding of the algorithms involved." Our experience with the Pascal/HSD Editor, 
Compiler, and Interpreter supports this position. However, the lack of understanding of the underlying 
algorithms resulted in the propogation, from the Pascal version to the Ada version, of some procedural 
dependencies and unclear control structure. As an example, each invocation of the SETGETNSG procedure 
call must be paired with a DELETEMSG call; since these fall in different areas of the logic, the checking 
to insure that the pairing has occurred is difficult to determine. The most "difficult" aspect of dealing 
with the control structures was with the IF-THEN- ELSE construct. This was primarily due to the multiple 
levels of nesting used in the Pascal version. The package structure of Ada proved invaluable as it eliminated 
the redundancy of subprograms" that existed in the original implementation of Pascal/HSD. This was beneffCCal 
bo~h from coding and maintenance standpoints. For the most part, the logical relationships between the 
subprograms were used to define the packages. One problem encountered in the conversion was the fact 
that Pascal supports a number of standard functions and procedures. For each standard function and procedure 
encountered in the Pascal version, it was necessary to write a comparable function or procedure in an 
Ada package. One example is that Ada does not support sets as does Pascal so a package was written to 
overcome this obstacle. Actually, since Telesoft Ada Version 1.5 does not support generics (see below), 
three packages had to be written to accommodate the set functions needed to preserve the logic from the 
original implementation. Other aspects of this project were based on implementation decisions arrived 
at by the project team. Some of these include the use of fully qualified names rather than the USE clause 
to achieve direct visibility. From a maintenance standpoint, Pascal/HSD is a large software project and 
using fully qualified names will make any future maintenance easier. It was also agreed, with few exceptions, 
that variable and subprogram names would be preserved from the Pascal version to the Ada version. In 
a few cases, existing names were replaced with more meaningful, descriptive identifiers. In addition, 
some names were changed since they conflicted with reserved words in Ada (e.g., DELAY and CONSTANT). 
Another decision in this category was in the initialization of the symbol table that defines the acceptable 
syntax for an end user. Code was incorporated in the executable part of a package's body to handle the 
initialization of the syntax table automatically. In making references to the Ada compiler used, it 
should be noted that we originally started this project intending to use the Telesoft Ada 2.1 compiler, 
which is not a fully validated compiler but was available along with the Telesoft Ada 1.5 compiler. Early 
in the project, it was discovered that this compiler had problems of its own and so we decided to use 
the Telesoft Ada 1.5 version instead. Although this version did not have all the features of the 2.1 
version (generics and library facilities) it was a more stable compiler. Telsoft's 1.5 Ada compiler 
had a number of size restrictions. Limitations on the length of certain data structures and the amount 
of dynamically allocated storage available for an executing program were encountered by the User Communication 
Subsystem component. Unfortunately, most of these were not documented anywhere and even worse, the error 
messages rarely indicated that size was the problem. This problem singly accounted for the bulk of time 
lost on this project due to determining the cause of the problem and redesigning our proposed Ada implementation 
to get around it. Some of these restrictions resulted in a redesign of the packages, particularly for 
the Pascal/HSD compiler. The syntactic analysis phase was originally designed to be translated to a single 
package but the Ada compiler has a restriction on the size of the input file (native code size limit) 
and this resulted in the syntactic analysis portion being redesigned to three smaller packages. One 
other major problem with the Ada compiler was that dynamic de-allocation of acquired storage during execution 
was not supported. The display file model was first implemented using dynamic storage so that there would 
not be a predetermined maximum for the number of symbols but with high numbers of insertions and deletions, 
storage violation messages were returned. This happened because the storage acquired for entries that 
were since deleted is still tied up. The display file is currently implemented as a fixed size structure 
array which has a static limit but that number is the least amount available.  Other restrictions directly 
affected this project and are identified here. Generic program units were not implemented and this resulted 
in three set packages being written rather than one generic package. Instantiation of the Telesoft Ada 
provided DIRECT IO package is only allowed within a package body,--not within the specification. The 
solution here was to move all operations on the program file to a single package. A package specification 
and its corresponding package body had to be compiled in the same compilation unit. The net result here 
was that complete packages had to be recompiled for single procedure or function changes. Finally, TASK 
TYPES were not supported which in turn prevented an implementation of the User Communication Subsystem 
that could have handled multiple terminals. Additional facilities As there was no system provided debug 
tool for Ada programs, the Pascal/HSO Ada implementation includes a debug assist. In the compiler code, 
each procedure has logic which will write a message to a disk file each time a procedure or function 
is entered. This assist is invoked by modifying a variable (Compiler_Debug) located in a package used 
by the compiler only. The User Communications Subsystem and the Interpreter have implemented a similar 
feature. CONCLUSIONS AND FURTHER Our primary intent of rewriting Pascal/HSD in Ada was to promote portability 
of these tools. The machine dependent aspects of this system have been isolated by the package structure 
that Ada provides. The HSD editor can be targeted to ADA by just changing the syntax table. However, 
more needs to be done in order to be able to input the programs produced to an ADA compiler. This can 
be done in two ways, namely by introducing additional tools for pre-processing the data base, or by redesigning 
the data base to comply with a given APSE. A good choice would be to redesign the program data base to 
make it compatible with the file structure defined for the standard APSE (this is depending on the outcome 
of the CAIS effort). In the meantime, we are looking at the DIANA tree representation, thus making the 
tools available to some existing APSE's. It is our contemtion that we cannot expect a significant increase 
in the production of high- quality software, if our programmers are compelled to write "structured" programs 
before adequate tools are made available to them. A mechanism is needed to monitor the development of 
programs keeping track of the tree-like program structure (local abstractions) and of the environment 
introduced to solve the problem (global abstractions). While the program structure is apparent, and meaningful 
to humans, it is possible to preserve it, as seen by the designer, in the underlying hardware representation 
as a flexible file structure, to which the compiler can simply add compiled code (the ultimate refinement). 
 AC~EI~S The effort of translating the Pascal implementation of the editor, compiler, and interpreter 
was achieved by John Kinsley, Shawna Gregory, and John Woodward. Joe Caldwell did an excellent job in 
getting the user communication interface working. All of the former were graduate students at SUNY University 
Center at Binghamton, Watson School of Engineering, Department of Computer Science. Binghamton, New York 
13901. Author's address: Dr 3orge L. Diaz-Herrera George Mason University Dept. of Computer and Information 
Sciences Fairfax, VA 22030 (703) 425-3958 RE~ <RefA>1. Cook, R.P and Lee, I."A Contextual Analysis of Pascal 
Programs" (Software Pract.&#38; Expr., Vol. 12(2), 1982)  2. Diaz-Herrera,O.L. &#38; Flude, R.C."Hierarchical 
Structured Diagrams" (Online Conf. Computer Graphics 80, pp 535-547, Brighton, UK)  3. Diaz-Herrera,J.L. 
&#38; Flude,R.C. "Pascal/HSD: a graphical programming system" (Compsac-80, IEEE Conf. Chicago pp 723-728, 
Oct. 1980).  4. Diaz-Herrera, J.L. "Pragmatic Problems with Stpe-wise Refinement Program Development" 
(ACM SIGSOFT~ Software Engineering Notes Vol. 9 no.2 pp 80-88, April 1984).  5. Diaz-Herrera, 3.L. "Subprograms 
considered harmful" (Submitted for publication IEEE Trans. Soft. Eng.)  6. Glinert, P. and Tanimoto, 
S.L. "Pict: An Interactive Graphical Programming Environment". (IEEE Computer, Nov. 1984, pp 7-25)  
 8. Nordstrom, B. and Wikstrom, A. "The Design of an Interactive Program Development System for Pascal". 
(Software-Practice and Experience, Vol. 14(2), 1984, pp. 177-190.  9. Powell,M.L. and Linton,M.A. "Visual 
Abstraction in an Interactive Programming Environment". (ACM, pp 14-21) i0. Rubin,R.Vo, Colin, E.3. and 
Reiss, S.P. "Think Pad: A Graphical System for Programming by Demonstration". (IEEE Software, March 1975, 
pp 73- 78) ll. Shimasaki,M. et al "An Analysis of Pascal Programs in Compiler Writing" (Software Pract. 
&#38; Expr., Vol. i0(2))  12. Wichmann, B. A. and Meijerink, 3. G. L. "Converting to ADA Packages". 
(NPL Report DITC 39/84, National Physical Lab., Teddington, UK, March 1984) 13. Wiener,R. and Sincovec, 
R. (Software Enqineerinq with Modula-2 and Ada (John Wiley and Sons 1984)  14. Wirth, N. "Program development 
by stepwise refinement" (C.ACM vol. 14, no. 4, pp 221-227, 1971).  15. Wirth, N. "Pascal/S" ETH ch-8092. 
Zurich, march 1976.</RefA>   
			

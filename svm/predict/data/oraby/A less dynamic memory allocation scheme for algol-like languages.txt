
 A Less Dynamic Memory Allocation Scheme for ~gol-li~e Languages Thomas P. Murtagh Department of Compoter 
Sciences Purdue University West Lafayette, IN 47907 A~ran: The conventional storage allocation scheme 
for block structured languages requires the allocation of stack space and the building of a display with 
e~.h procedure call. This paper describes a technique for analyAng the call graph of a IXogram in a block 
structured language that makes it possible to elim- inate these operations from many call sequences, 
even in the presence of recm~on. L Intraductim Current progranar~ng methodologies 4,11 recommend that 
programs be decon'q3osed into fairly small procedures that each perform simple a~tract operations. This 
approach to program design makes the efficiency with which transfers can be made between procedures critical 
7. Unfortunately, a cons/derable amount of overhead is associated with procedure calls in current implementations 
of languages like Algol and Pascal,, even on machine architectures designed to support such languages 
5,6. This paper describes a new approach to memory management for procedure activation records that may 
significantly reduce this overhead. The code generated for a procedure call by a typical translator of 
a language like Algol includes instructions to: (1) Calculate the values of the actual parameter, (2) 
Save register values and other components of the caller's state,  Permission to copy without fee all 
or part of this material is granted provided that the copies are not made or distributed for direct commercial 
advantage, the ACM copyright notice and the title of the publication and its date appear, and notice 
is given that copying is by permission of the Association for Computing Machinery. To copy otherwise, 
or to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0283 
$00.75 (3) Allocate space on a stack for the local variables and parameters of the called procedure, 
and (4) Build a "display" of pointers to the stack segments con- talning non-local variables that may 
be referenced by the called procedure 2.  Operations 3 and 4 are included in call sequences to support 
a language feature that is not used by all pro~dures -the abil- ity to make recursive calls. If none 
of the procedures in an Algol program are called recursively, a translator could allo- cate all variables 
for the program statically. This would make it po~ible to efininate operations 3 and 4 from all call 
sequences for the program. Even if some of the procedures in a program are called recursively, it is 
often possible to eliminate operations 3 and 4 from many of the call sequences generated by a tt,mslator. 
For example, suppose the main procedure in a program, P, contains declarations for two procedures Q and 
R such that P may call O, O may call R, R may call P, and no other calls are possible. Because all three 
of these procedures may be called recursively, this looks like an example in which dynamic allo- cation 
is required with each procedure call. If, however, a translator generates code to allocate the local 
variables for all three procedures each time P is called, then calls can be to O and R without allocation. 
This will reduce the execution lime of the p~gram, since the allocation of space for all three procedures 
takes no more time than the allocation of space for P alone. The signifr, ance of this example is that 
such o~-~tions of stack space allocation can be made automatically. Walter 8 refers to the property that 
makes such ol~n~mtions possible as "relative nonrecu~veness" and provides a method for recogniTing cases 
of it based on the static nesting of pro- cedures. It is possible, however, to do better by directly 
analyAng a program's call graph. Tne key is to recogn/ze 283 groul~ of procedures in which the task of 
allocating space for all of them can be shifted to just one of them. The next sec- tion presents a tedmiq/~e 
for recognizing such groups of pro- cedures. ,Section three explains how to perform storage allo- cation 
u~g this information. Section four presents algorithms that make a further optim/mtion when procedures 
are recog- ni~d to be absolutely nonrecurs/ve. Sections five, mx and seven explain how these optin/mtions 
of stack space aIloca- tion affect the building of displays. Finally, section eight sum- marines the 
techniques presented. 2. lnta'vals iu a Call Graph A call graph for a program P is a directed graph with 
one node for each procedure in P and an edge between two nodes O and R if the procedure corresponding 
to Q may call the procedure corresponding to R. The node corresponding to the main program is called 
the initial node. We assume that all nodes in the call graph are re~e from the initial node. The wurd 
may in this description of a call graph is critical It is impc~ble to detern~ne whether one procedure 
will call another, even under very weak assumptions about the language involved 9,10. Weih]9 and Walter 
$ present algo- rithtm for congmting call graphs. An interval I with bender h in a directed gral~ G is 
defined to be a connected set of nodes in G such that: (1) The node h is contmned in every path from 
a node not in I to a node in I. (2) t- 0,} is acycUc The notion of an interval was lust used by Allen 
and Cocke 3 to recogni,e loops in wogram flow graphs, but it is also exactly what we need to recognize 
groups of relatively nonrecun/ve procedures in a can graph. If storage is allocated for all of the procedures 
in an interval each time the header is called, then calls to all of the other procedures in the interval 
can be made without doing any storage allocation. Furthermore, a  call graph can be partitioned into 
maximal intervals by a ran- ple algorithm. One version of this algorithm is shown in H&#38; 1. A more 
detailed vers/on of the algorithm that runs in time proportional to the number of edges in the can graph 
can be found in ~. 3. Memory A~catiou fm" ~ When a ca]] is made to the header of an interval, stack space 
should be allocated for all the procedures in the inter- val. Th/s does not, however, mean that the amount 
of space allocated must equal the sum of the amounts required for the individual procedures, For exmnl~, 
if the subsnOl for ms interval takes the form shown below, the space allocated for B can overlap that 
for C. In this case, the space allocated for the interval need only equal the sum of the s/~ of A and 
the larger of B and C. let the sO.e M" a pa~h in a call gmph be the mun of the simes of the ectivation 
records for the procedures on the palh. 1"hen, the space allocated for an interval need only be as as 
the si~ of the largest acyclic path in the interval. "[his can % G/yen a call gra~ with initial node 
no, this progrmn % will set INTS equal to the set of sets of nodes that % form the m~mal interval partition 
of the call Sraph. % % H is the set of nodes known to be the heads of % intervals that have not yet 
been co.tiered. % DONE is the set of nodes that have been placed in % intervals. % % SIll denotes the 
set of ~,_~mots of nodes in L % P[x] denotes the set of predecessors of the node x. INTS :,= 0 H := 
(n0} lX3~ "= 0 while H ~0 do x := any element of H call MAXX(xJ) INTS := INTS U {I} ~:= DONE U 1 H := 
(H- {x}) U ( SIll - I - DONE) od ~cedure ~CI(h,X) % This procedure sets I equal to the set of nodes 
in % the ~ interval with header h. % be~n I :=(h} while there exim x in (S[I] - I) such that P(x) C [ 
do I :=I U(x} od end Figure L The Allen. ~ Inroad Partition Alsvrltbn. 284 be accomplished by allocating 
space for each procedure in the interval at a displacermm equal to the ~e of the larsest acy- clic path 
from the header to the im3cedure. Thus, the dis- placemem for the header is zero and the d/splacement 
for any other procedure is equal to the largest of the d/splacements at which the spaces allocated for 
its predecessors end. These displacements can be corrqmted emily during the construction of the interval 
partition, beca-~ a node is added to an inter- val only after all of its predecessors have been added. 
The space allocated in this way is the ninirnmn that must be allocated when the header is called. In 
some instances, however, some of it may be wasted. Consider the call graph in Fig. 2. A, B, C, D and 
E form one nmin~ interval. F alone forms another. Assuming that each procedure takes one unit of space, 
4 units must be allocated for the first interval whenever A is called. If the path (A,C,D,E) is followed, 
then all of this space is actually required. If the path (A,B,E) is followed, however, only three units 
are actually used. Worse yet, if C calls F, only two Units are actually used. Fortunately, in this last 
case, the unused units can be recovered by simply allocating space for F inenediately after the space 
for C instead of at the end of the space for the interval. Thus, as a rule, space for a new interval 
should be allocated at the end Flgwe 2. of the space allocated for the procedure that called its header, 
rather than at the end of the space for the interval conta/nin8 the caller. 4. Slatk Aaecmim The call 
graph of a progrem is a representafioa of the relation "A nay call B directly." 1"he transitive cloture 
of this relation is the relation "A may precede B in a sequence of calls." Using the u'anMtive ~, cm 
can detem/ne that a procedure is nonrecarsive by asking whether "A may precede A in a sequence of calls" 
The fact that a procedure is nonre- cursive is stronger than the fact that a group of procedures forms 
an interval in the call graph. It implies that space for the procedure can be allocated statically. In 
a conventional implementation of an Algol-like language, it would be advantageous to statically allocate 
activa- tion records for all nonrecursive procedures detected in this way. With an interval based allocation 
scheme, static alloca- tion of a procedure is only worthwhile if all of the procedures in the same interval 
are nonrecursive. This is because the main savings obtained through static allocation is the cost of 
stack space allocation, which is zero for all procedures except headers in the interval based scheme. 
The advantase of limit- in s static alkr.ation to procedures that fall in intervals that are nonrecm~ve 
is that it is generally less expen~ve to deteragne which intervals are nonrecu~ve than to determine which 
ixo- cedures are nonre~usive. It can be done by computing the tran~tive closure of the der/ved ca//grCph 
defined as follows: (1) For each interval in the call graph there is one node in the derived call gaph. 
 (2) If A and B are two intervals, there is an edge from A to  B in the derived call graph if and only 
if there is a path from some node in A to the header of B in the caU graph. In most cases, the derived 
call graph will contain fewer nodes than the call graph. Therefore, computing its tran~t/ve clo- sure 
will not be as expenave as computing the tran~tive clo- sure of the full call graph. When nonrecurs/ve 
intervals are allocated statically, the space used need not equal the sum of the amotmts of space needed 
for the individual intervals. Instead, space for many intervals can be overlapped by allocating each 
nonrecursive interval at a displacement equal to the maximum of the end- ing addresses of the storase 
segments allocated for procedures in nonrecursive intervals that precede its header. These dis- placelmnts 
can be computed by first constructing a uaph with: (I) one node for each lXocedure in a nonrecun~e interval, 
 (2) an edge from A to B if there is a path from A to B in the original graph such that all nodes on 
the path except A and B fall in recur~ve intervals,  and then visiting the nodes of the graph in topological 
sort order setting each node's allocation displacement equal to the maximmn of the ending displacements 
of its predecessors. 285 In the case of a program in which all procedures are non- recur~ve, this scheme 
will lead to the static allocation of space for all procedures. Th/s is a satisfying result, since it 
implies that this scheme leads to the best pos~ble allocation of storage in what is probably the most 
co~n case it will encounter. On the other hand, the savings obtained by static allocation in this case 
are in~gnif~ant. The use of intervals will have 'already elin'/nated all but one allocation of stack 
space in such a program. Static allocation is more significant in the case of a pro- gram in which a 
nonrecurs/ve pro~dure is called from recur-dye procedures in different intervals. For example, in a corn- 
Idler udng a recursive descent parser, many of the recursive routines in the parser would call some sort 
of 'geLlexeme ' routine, which is likely to be nonrecun/ve. If the parser pro- cedures that call 'get..lexeme' 
fall in distinct intervals, then 'get..lexeme' will be the header of a separate interval. There-fore, 
if nonrecursive intervals are not allocated statically, every call to 'geLlexeme ' will involve stack 
space allocation. "Ibis overhead can be eli~nated by u~ng static allocation. The notion of an interval 
in a call graph also provides a way to reduce the overhead associated with display building. This can 
be seen fairly easily by temporarily assuming that the language being con~dered supports neither procedure 
vari- ables nor the use of procedures as parameters. Recall that the display associated with a procedure, 
P, is just a sequence of pointers to instances of the procedures that statically sttrround P. "lhe first 
element of this sequence points to the outenuost surrounding procedure. The last ele- ment points to 
the irmnediately surrounding procedure. In the absence of Ixocedure variables and parameter, a pnx~dure's 
display can always be built from the display of its caller. If a procedure is called by the procedure 
in which its definition occurs, its d/splay is constructed from its caller's d/splay by adding a pointer 
to the caller's e~dvation record. Otherwise, the called procedure's d/splay is formed by remov- ing 
ero or more pointers from its caller's display. This implies that the d/splay associated with any procedure 
in an interval must con~st of some prefix of the display assc~ated with the interval's header followed 
by zero or more pointers to the activation records of other procedures in the same instance of the interval. 
Furthermore, the display associated with an interval's header cannot contain any pointers to instances 
of other pro- cedures in the interval. If it did, then such a pointer would have to be included in the 
display for the first instance of the header created, which is impossible dnce the fast instance of the 
header must be created before an instance of any other procedure in its interval can be created. Together, 
these two facts imply that any procedure's display can be partitioned into sub-sequences of pointers 
to procedures in distinct intervals, as illustrated in Fi&#38; 3 (a). H ~ointer to [prcc. A 3ointer to 
I ' i~c. B ~ointer to [ proc. c l 't membemof interval I pointer to proc. D i tr~mber of interval 2 pointer 
to interval 1 pointer to pointer to proc. E pointer to members of interval 3 interval 2 pointer to proc. 
F interval 3 (a) Co) Figure 3. storage for all of the procedures in an interval is allocated in one 
block, as suggested in section 2, such a display can be compressed by rep]ac/ng each subsequence of pointers 
to pro- cedures in a Oven interval by a single pointer to the block of memory allocated for the entire 
interval. The comp/ler ~n~l. y u2ses the interval pointers together with the known displace- ment of 
each procedure from the beginning of the stora~ for the interval. Figure 3 03) shows how the display 
shown in Hg- ure 3 (a) would be compressed u.~ng this technique. Compressing displays obviously saves 
storage. More importantly, it reduces the overhead associated with display building dnce a display change 
only occurs when a call is made to the header of an interval. All other procedures in the interval share 
the display built when the header is called. 6. _Pr~_~e ~ and 8imply ~ l~m~s To simplify the preced/ng 
explanation of display sharing, we have assumed that the language involved allowed neither procedure 
variables nor procedure parameters. We will con- tinue to assume the absence of procedure variables, 
~Jlce the wesence of both procedure variables and the ability to nest procedure definitions in a language 
would require the reten- tion of activation records or some other mechanism to avoid dangling references. 
Procedure parameters, on the other 286 hand, a~e found in two of the best known languages to which these 
tedmiques could otherwise be applied, Algol ¢~0 and Pascal. The problem with procedure parameters is 
that the display associated with a procedure called through such a parameter is detern~ed at the time 
at which the parameter is bound rather than at the time the call is made. If a call is made using a procedure 
parameter that was bound outs/de of the current instance of the current interval, the display formed 
may not have the form described above. The skeleton of a program in which this problem can occur is shown 
in Fig- ure 4. Its ca]] graph is shown in Fif~ 5. In this example, the main program forms one interval. 
The pro~dures R, F, G and H form another. If the recurve procedure R calls itself with G as parameter 
and the new instance of R invokes G through the parameter FP, then the display built when G calls H will 
contain a pointer to R in the fast instance of the inter- val containing R and a pointer to G in the 
second instance of the interval. As a result, these two pointers cannot be replaced by a single pointer 
to either instance of the interval. This problem can be avoided by refuting the maximal interval partition 
of the call graph to obtain intervals in which the use of procedure parameters is approwiately restricted. 
begin procedure R(FP); procedure FP; bep procedure G( ); begin ... H( ) ... end; procedure H( ); begin 
... end; if ... then R(FP);  it ... then S(G); FP() end; procedure F( ); begin ... end; R~; ... end 
Fisure 4. Figure 5. We define a singly scoped interval to be an interval I with header h such that the 
set of formal parameter names that may be bound to any procedure in I - Or} is a subset of the formal 
parameter names declared by the procedures in I - (It}. The following lemma implies that the pnx~dures 
in a ~ply scoped interval can all share the display built for the header if storage for all the procedures 
in the interval is allocated together. Lemma: If I is a simply scoped interval in a call graph with header 
h, then the dlsi~ay associated with any instance ¢g a procedure 0 in I at nmtime will ~-~st of some weRx 
of the display associated with the most recently created active instance of h followed by zero or more 
pointers to the most recently created active itmtances of other procedures in I that fall on acydic paths 
from h to Q. The lenuna can be proven by induction on the length of the longest acyclic path from the 
header to a particular pro- cedure in 1, which we call the distance from h to the pro- cedure. The displays 
of all i~x~dures at distance zero from the header dearly have the required form. Now, a~ume that the 
displays of all procedures at a distance less than n from the header have the de,red form. If P is a 
procedure at dis- tance n from the header, then any procedure Q that calls P must be at a d/stance less 
than n from h. Therefore, by assumption, the display of 0 has the desired form. But, unless 0 calls P 
through a formal parameter name, the display of P will be built either by adding a pointer to 0 to the 
display of 0 or by removing a suf~ from the display of O. In both cases the resulting display will have 
the required form. If a procedure calls P through a formal parameter name, the d/splay associated with 
P is not detem~ed at the IXXnt of call It is deterrr~ned at the points at which F is bound to for- ma] 
parameters. So, con~der all calls of the form R( ... P...) The display to be associated with" P when 
called through this 287 formal parameter binding is formed from the display of the procedure Q in which 
the call to R occurs by either adding a pointer to O's activation record to or removing a mffuc from 
O's display. We will say that Q precedes P in I if Q wecedes P on some acyclic path from h to P. If Q 
precedes P in I, then the resulting display must have the desired form, since the distance from h to 
Q must be less than n. IfQ does not precede P in I, the form of the display associated with P does not 
matter, because the binding made can never be used to call P. This is because no parameter, X, defined 
by a pro- cedure that does not precede P in I can be used to call P or to make a binding between P and 
any parameter, Y, defined in a procedure that precedes P in 1. To call P tLclng X, one would have to 
reference X in the caller. But the caller must precede P in L This implies that its distance from h must 
be less than n and, by our assumption, that the only pointers to procedures in I on its display are pointers 
to procedures that precede P in I. Therefore, it cannot reference X or any other identifier defined in 
a procedure in I that does not pre- cede P in 1. Similarly, to make a binding between P and Y u~ng X, 
X would have to be referenced by the procedure that called the procedure that defined Y. But, such a 
pro- cedure nmst precede P in 1. Therefore, by the same argu-ment as above, X cannot be referenced by 
any such procedure. 7. Rd'm~ag the Interval ParUtlon intervals cornimted by the algorithm in Fig. 1 may 
not be ~mply scoped. Each of the these intervals, however, can be partitioned into a set of ~mply scoped 
intervals. Hg. 6 shows an algorithm that simultaneously partitions a call graph into maximal intervals 
and partitions each mammal interval into simply scoped intervals. This algorithm may not wtxh~ maz/ma/simply 
scoped intervals when applied to programs that bind procedures to parameters that are never used. This 
does not seem important, however, since such binclin~ prob~iy indicate a prograrr~ng error. Given this 
lmrtition, the pro- cedures in a program are split into three dames: 1) headers of maximal intervals; 
2) headers of simply scoped intervals and 3) members of intervals other than the headers. Calls made 
to the fast type of procedure require both stack space allocation and display building. Calls made to 
the second require only display building. Calls made to all other procedures need nei- ther. s. st=.,=ry 
We h~ve presented a technique for organi~ng the activa- tion records of procedures in block structured 
languages that % Given a call graph with initial node nO, this program will % set IHTS equal to the 
set of sets of nodes that ~rm the % maximal interval partition of the call grggh and SSlICrs % equal 
to a set of sets of nodes that forms a refinement % of this ln~tition into simply axed intervals. % % 
His the set of nodes known to be the heads of % intervals that have not yet been considered. IX)NE is 
% the set of nodes that have been placed in intervals. % % SIll denotes the set of successors of nodes 
in L % l~x] denotes the set of predecessors of the node x. := ~ := DONE := 0 H := {nO} while H * 0 do 
x := any element of H can ~(x,I) Ih'IS := INTS U (I} DONE := DONE U I  u := 0~- {x)) u (s[q - I - DONE) 
od procedure MAX](hj) % This procedure sets I equal to the set of nodes in % the maximal interval with 
header h, % ssI-I is the set of nodes known to be the heads of ~mply % scoped subintervals of the current 
ms:cimal interval. %  ~esm I:=0 ssH := {h} while ~*0do ssh := any element of ss]-I can ss](~,=~ SSINTS 
:= SSIN'rS U {ml} I :=IUssl mH := { x I l~x] C I and x E (S[I] - I)} od end wocedure SSI(ssh,ssl) % 
This procedure sets ssl equal to the set of nodes in a % gimp]y scoped interval with header mh. % be~ 
= {~} while there exists an x in (S[ssl] - ssl) such that ssl D l~x] and ssl D { p I p defines a formal 
parameter that may be bound to x} do ~ := ssl U {x} od end Figure 6. 288 Rdm can significantly reduce 
the overhead associated with stack space allocation. In addition we have shown how this tech- nique can 
lead to a reduction of the overhead involved in building displays in languages that allow nested IXOcedure 
definitions. We are confident that these techniques ~uld be of significant value, because we believe 
that relatively few lXO -grams depend heavily upon recunion. Some experimentation is needed, however, 
to detemdne how useful these tech-niques are when applied to programs that are recursive. The author 
thanks IvL CrDormell, T. Korb, C. RaBgiefi and J. Manning for their helpful conanents on earlier versions 
of this paper. <RefA>I. Aho, A.V. and J.D. Ullman, The Theory of Poising Trans- lation and Compiling, Prentice 
Hall, Inc., Englewood Cliffs, New Jersey (1972). 2. Aho, A.V. and J.D. Ullman, Principles of Conp~ler 
Design, Addison-Wesley Publishing Co., Reading, Mas- sachusetts (1979). 3. Allen, F.E. and J. Cocke, 
"A Program Data Flow Analysis Procedure," Cu,,,,,~micalions of the ACM 19(3) pp. 137-147 (March 1976). 
 4. Dijkstra, E.W., "Rotes on Structured Progranmdng," in Structured Progr~r~nin 8, O-j. Dahl, E.W. Dijkstra, 
and  C.A.R. Hoare,, Acaderr/c Press (1972). 5. Lampson, B.W., "Fast Procedure Calls," Proceedings of 
a Symposiwn on Architectural Support for Progr~ Lzmsuage$ and Operming Systems, pp. 66-76 (March 1982). 
6. Patterson, D.A. and CSL Sequin, "RISC I: A Reduced Instruction Set VLSI Computer," Eigth Symposiwn 
on Computer Architecture, pp. 443-457 (May 1981). 7. Tanenbaum, A.S., "Implications of Structured Program- 
n-ring for Machine Architecture," C~,,¢,,,mications of the ACM 21(3) pp. 237-246 (March 1978). 8. Walter, 
K.G., "Recursion Analysis for Compiler Optimi- zation," ¢c~mications of the ACM 19(9) pp. 514-516 (September 
1976). 9. Weihl, William E., "Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure 
Variables, and l.a~l Variables," Conf. Rec. Seventh ACM Syn~osium on Priaei~es of Progr~,d~ lag, my.s, 
pp. 83-94 (January 1~0). 10. Winklmann, K.A., "A Theoretical Study of Some Aspects of Parameter Passing 
in ALCg)L fi0 and in S/mi- lar Progranm-/ng Languages," Ph.D. The=s, Purdue UBiv=r~ (~=t 1977). 11. 
W'trth, N., "Program Development by Stepwise Refinement," Coii~i~ications of the ACM 14(4) pp. 221- 227 
(April 1971).  </RefA>289  
			

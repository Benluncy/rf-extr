
 A Fast: and Accurate Iterative Solution of a Multi-class Threshold-based Queueing System with Hysteresis 
 Leana Golubchik John C.S. Lui t Department of Computer Science &#38; UMIACS Department of Computer Science 
&#38; Engineering University of Maryland at College Park, USA The Chinese University of Hong Kong leana@cs.umd.edu 
cslui@cse.cuhk.edu.hk ABSTRACT In this paper, we consider a K-server multi-class threshold-based queueing 
system with hysteresis in which the number of servers, employed for servicing customers of each class 
i, is governed by a forward threshold vector F, = [F,(1), F, (2), .., Fi(Ki -1)] and a reverse threshold 
vector R = [Ri(1), Ri(2), ..., Ri(K; -1)]. There are many applications and systems where a multi-class 
threshold-based queueing sys- tem can be of great use. One motivation for using threshold- based techniques 
is that such systems incur significant server setup, usage, and removal costs. And, as in most practical 
situations, an important concern is not only the system per- formance but rather its cost/performance 
ratio. The mo-tivation for use of hysteresis is to control the cost during momentary fluctuations in 
workload. Moreover, servers in such systems are often needed by multiple classes of work- loads, and 
hence, it is desirable to find good approaches to sharing these serw~rs among the different workloads, 
prefer- ably without statically partitioning the server pool among the classes; threshold-based techniques 
constitute one cate- gory of such approaches. Consequently, an important and distinguishing characteristic 
of our work is that we consider a multi-class system, which is needed in modeling of many applications 
and systems. Our main goal in this work is to develop an efficient method for solving such models and 
computing the corresponding performance measures of in- terest, which can subsequently be used in evaluating 
designs of threshold-based systems. 1. INTRODUCTION In this paper, we consider a multi-class K-server 
threshold- based queueing system with hysteresis in which the number of servers, employed for servicing 
customers of class i, i = *This work was supported in part by the NSF CAREER grant CCR-98-96232. tThis 
work was supported in part by the Mainline and RGC research grants. Permission to make digital or hard 
copies of all or part of this work for personal or classroom use is granted without fee provided that 
copies ar e not made or distributed for profit or commercial advant -age and that copies bear this notice 
and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute 
to lists, requires prior specific permission and/or a fee. SIGMETRICS 2000 6 00 Santa Clara, California, 
USA &#38;#169; 2000 ACM 1-58113-194-110010006-.$5,00 1,... N, is governed by a forward threshold vector 
Fi = [F~(1), F;(2), ..., F~(K~ -1)] (where F~(1) < Fi(2) <-.. < F~(Ki-1)) and a reverse threshold vector 
Ri =[Ri(1), Ra(2), ..., R~(K~ -1)] (where R~(1) < Ri(2) <--- < R~(Ki -1)). This multi-server multi-class 
queueing system has a total of K servers where the allocation of servers to classes is performed as follows. 
Each class is allocated a minimum of one server. Thus, a customer of class i arriving to an empty system 
is served by a single server. A new arrival of a class i customer to a system with Fi (j) class i customers 
already there (and j servers already allocated to that class) forces an attempt, to allocate one additional 
server to class i, where j = 1... Ki -1, and Ki is the maximum number of servers that can be allocated 
for service of class i customers. A departure of a class i customer from a system (with j + 1 servers 
allocated to that class prior to this departure) which leaves behind R~ (j) customers of class i forces 
a de-allocation of a server, where j = 1... K~ -1 -- that is, it forces the return of a server, that 
was earlier allocated to class i, to the pool of "free" servers which are available for allocation to 
all classes Hence, the N classes share a pool of K servers, with a dynamic allocation of servers to classes 
governed by a set of . . N thresholds with hysteresis behavmr. If ~=1 Ki < K, then the classes do not 
"interfere" with each other. Of course, the more interesting case is where ~v=l K~ > K, as motivated 
below. One motivation for using a threshold-based approach is that many systems incur significant server 
setup, usage, and re-moval costs. And, as in most practical situations, an im-portant concern of a system 
designer is not only the system performance but rather its cost/performance ratio. Further-more, servers 
(resources) in a system are often needed by multiple classes of workloads (applications), and hence, 
it is desirable to find good approaches to sharing these servers among the different workloads, preferably 
without statically partitioning the server pool among the classes. More specif- ically, under light class 
i loads, it is not desirable to op-erate unnecessarily many servers for that class, due to the incurred 
setup and usage costs as well as due to the perfor- mance consequences of that class under-utilizing 
the servers while other classes are (possibly) experiencing high loads. On the other hand, it is also 
not desirable for a system to exhibit very long delays, which can result from lack of servers under heavy 
loads. One approach to improving the cost/performance ratio of a system is to dynamically react to changes 
in workload through the use of thresholds. For in- stance, one can maintain the expected job response 
time in a system at an acceptable level, and at the same time maintain an acceptable cost for operating 
that system, by dynamically adding or removing servers, depending on the system load. Similarly, one 
can use the threshold-based server allocation approach to reduce the sensitivity of performance character- 
istics of a class of customers to the workload of other classes without having to statically partition 
resources between the classes. (We illustrate this further in Section 4.) There are many applications 
where threshold-based resource management policies can be employed, and thus performance evaluation of 
such systems through analysis of multi-class threshold-based queueing systems can be of great use. For 
instance, the Novell file server maintains a memory pool such that a fraction of it is used for communication 
buffers and a fraction is used for file buffers, where threshold-based poli- cies are implemented in 
order to make decisions about when to increase the number of network buffers and when to de- creases 
it; the threshold values are based on perceived packet losses due to increases in network traffic activity. 
Similarly, OS design has been moving towards maintaining a common buffer space pool that can be dynamically 
managed between the various I/O processes. Furthermore, in transport proto- cols of communication networks 
[12], several transport-layer connections are multiplexed onto a single network layer con- nection. Whenever 
the traffic exceeds a certain threshold in the network-layer connection, another network-layer con- nection 
can be created to service the incoming traffic from the transport layer. Using such a control mechanism, 
severe degradations in throughput and delay can be avoided; at the same time operation costs can be kept 
at an acceptable level. Another example application is a system providing informa- tion query service 
via the Internet. As the number of queries increases, the number of servers, needed to maintain certain 
(acceptable) system response time characteristics, is also in- creased. Since the cost of setting up 
server connections can be significant 1, the use of a threshold-based approach can result in a cost-controlled 
creation and deletion of these con- nection, according to the changes in the workload. Thus, the model 
presented in this paper and its efficient solution will be beneficial for many systems and applications. 
As in the case of electronic circuits that are prone to oscil- lation effects, a "simple" threshold-based 
system may not suffice. In a computer system, one reason for avoiding oscil- lations are the above mentioned 
server setup and removal costs, i.e., oscillations coupled with non-negligible server setup and removal 
costs can result in a poor cost/performance ratio of a system. More specifically, it is desirable to 
add servers only when a system is moving towards a heavily loaded operation region, and it is desirable 
to remove servers only when a system is moving towards a lightly loaded op- eration region --it is not 
desirable to alter the number of servers during "momentary" changes in workload, i,e., dur- ing oscillations. 
Such oscillation regions can be avoided by adding a hysteresis to the system -- hence the motivation 
for looking for efficient analysis techniques of threshold-based queueing systems with hysteresis behavior. 
1For instance, it may be necessary to broadcast information about the newly added server to the already 
active servers in the system. As already mentioned, a threshold-based queueing system with hysteresis 
is defined by the forward and the reverse threshold vectors (see Section 2 for details). The actual val- 
ues, or rather what are "good" values for these vectors is a function of many factors, such as the characteristics 
of the server setup, usage, and removal costs, characteristics of the arrival process and the service 
rates, as well as the possible "interaction" between the different classes of work- loads. Our main goal 
in this work is to develop an efficient method for solution of multi-class multi-server threshold- based 
queueing models with hysteresis and computation of corresponding performance measures of interest. The 
ques- tion of optimal values for the threshold vectors is, in general, a difficult problem and is outside 
the scope of this paper. We must point out, however, that efficient model solution tech- niques can be 
of great use in evaluating various parameter settings (such as the threshold values) and hence are needed 
for performance evaluation of systems that manage resources in a threshold-based manner. Such analytical 
models are es- pecially useful at design time, when the speed of evaluation is key. Thus, we believe 
that our solution method, due to its efficiency, facilitates accessible experimentation techniques for 
investigating the "goodness" of various threshold-based designs and parameter settings (refer to Section 
4 for nu- merical examples). Given the above motivation for the use of threshold-based systems with hysteresis, 
in this paper we present an efficient technique for solving the corresponding analytical models and computing 
various performance measures of interest. We begin with a very brief survey of some of the existing literature 
on the threshold-based queueing problem. A two- server system is considered in [13], [14], and [20]. 
An approx- imate solution for solving a degenerate form of this problem (where all thresholds are set 
to zero) is presented in [6, 8]; an approximate solution for a system that employs (non- zero) thresholds 
is presented in [21] (but without hystere- sis). In [7], the authors solve a multi-server threshold-based 
queueing system with hysteresis, using the Green's function method [5, 9, 10]. In [16] We give a solution 
of several forms of the multi-server threshold-based queueing system with hysteresis using stochastic 
complementation [17]. Lastly, techniques for computation of bounds for performance mea- sures of multi-server 
threshold-based queueing systems with hysteresis and non-instantaneous server activation are given in 
[3]. In this work, we consider and solve a multi-class multi-server threshold-based queueing system with 
hysteresis. The con-tributions of this work are as follows. To the best of our knowledge, none of the 
works described above give an effi- cient analyticM solution technique for analyzing multi-class threshold-based 
systems with hysteresis behavior. Since in many applications, such as the ones described above, mul-tiple 
types of workloads "compete" for a pool of resources, we consider it an important and distinguishing 
characteris- tic of our work. Specifically, we present an iterative solution technique which solves the 
multi-class model by "breaking" it up into N single class models, "coupled" through a set of model parameters 
which capture the interaction between classes. As shown in Section 4, in most test cases, this it- erative 
approach produces accurate results and allows for efficient computation of performance measures of interest. 
 Furthermore, we study the performance characteristics of threshold-based systems and show that proper 
choices of design parameters, such as threshold values, can produce significant improvements in system 
performance. Using this study, we illustrate the utility of our approach in evaluating designs of threshold-based 
systems, where "good" parame-ter settings constitute not only an important but a difficult problem. We 
believe that the efficiency and accuracy of our approach facilitates large-scale experimentation with 
param- eter settings and subsequent performance evaluation studies of threshold-based designs of systems. 
Finally, we note that a variety of iterative approaches have been used in the literature for construction 
of approxima- tion techniques (e.g., refer to [2]). For instance, an iterative technique for a somewhat 
different control schemes for dy- namic resource sharing between multiple classes is employed in [18, 
19]. The remainder of this paper is organized as follows. In Sec- tion 2 we give a description of our 
model (with further details given in [4]). Section 3 describes our iterative approach to solving the 
multi-class model (with details of the derivation of an individual class model solution, utilized by 
the itera- tire approach, given in [4]). The goodness of this approach, i.e., its accuracy and utility 
in system design and evalua-tion, is discussed in Section 4 through the use of numerical results. Finally, 
our conclusions are given in Section 5. 2. SYSTEM MODEL In this section, we describe our multi-class 
threshold-based queueing model with hysteresis behavior which has an in-finite state space and can be 
defined as follows. There is~a total of K servers in the system, where K is unre-stricted. The service 
time requirements of a class i cus-tomer are exponentially distributed with parameter #i. The customer 
arrival process is Poisson with rate A and prob-ability ai that an arriving customer is of class i, where 
g ~i=lai = 1 and 1 < i < N. That is, we consider a multi-class system with N classes, where N is unrestricted. 
Addition and removal of servers for serving customers Of class i is governed by the forward and the reverse 
thresh-old vectors F~ = [Fi(1),Fi(2),... ,F~(IK,-1)] and Ri = [R~(1),R~(2),---,R~(Ki-1)] where F~(j) 
< Fi(j + 1) for l _< j _< Ki -2, Ri(j) < R,(j + i) for 1 < j _< K, -2, and R~(j) < El(j) for 1 _< j _< 
Ki -1. Given a pool of K servers where each server is able to serve a customer of any class, each class 
i starts-out with one server and may attempt to obtain at most Ki servers. These servers are allocated 
for service of class i customers and returned to the pool of available servers based on the number of 
class i customers currently in the system (as stated more formally below). In general, ~/N=i I4"i may 
be greater than, equal to, or less than K; although the more interesting case is where ~iN=l Ki > K. 
Given a K server N class threshold-based queueing system with hysteresis, we model it as a Markovian 
process .A4 with the following state space S: S ---- {(nl,sl,n2,s2,... ,nN,SN) I n, >_ 0, si {1,2,...,K,},~si_<K,i=I,...,N} 
 where ni is the number of class i customers in the system and s; is the number of servers currently 
allocated to class i. Upon an arrival of a class i customer, if Fi(j) _< nl _< Fi(j) + a i J where a~J 
>_ 0 and j = sl, then the system at-tempts to allocate an additional server for service of class i customers, 
which is possible only if ~iN=l sl < K. Note that in a system where ~iN=l Ki > K, it may not always be 
pos- sible to allocate another server to class i upon arrival, since at that time all K servers may have 
already been allocated. In this case, the arriving class i customer joins the queue of class i requests 
as long as F~(j) <_ ni < Fi(j) + a i 3 (where J > 0 and j = si). Whenn~ = Fi(j) +a~, the arriving al 
_ class i customer is rejected by the system (i.e., dropped) if there is no server available for allocation 
to class i (i.e., if si = K). For correctness, we assume the following con- J. straint on all al. _j+l 
Fi(j) + a{ < Fi(j + 1) + ~i for i = 1, 2,.g. ,N and j = 1,2,...,Ki-1. We also as-sume that a i i = o0; 
hence, we have no restrictions on queue length when the maximum number of servers that maybe needed by 
class i have been allocated (i.e., when sl = Ki). The limitation on queue length when sl < Ki is motivated 
by system design considerations. That is, if the system reaches a point where its design dictates that 
an-other server be allocated for class i workload, but a server is not available (i.e., all K of the 
system's servers are al-ready allocated), then it is reasonable to assume that the system is (at least) 
temporarily overloaded, partly due to sharing of resources with other classes. And, rejection or blocking 
of customers is a reasonable approach to dealing with overload conditions. Of course, a "real" system 
will also not have an infinite queue length, when the maximum number of servers (K{) for class i has 
been allocated. In this case, we may either (1) use a finite queue length model (i.e., a/K i is finite) 
and study the system's performance under a given queue size limitation, or (2) allow an infinite queue 
length (i.e., a/K i = oo) and use the model to study queue length requirements of the corresponding system. 
Our solu- tion methodology (refer to Section 3) allows for either type of a model, but for simplicity 
of exposition, in the remain- der of the paper we will focus our discussion on the infinite queue version 
(i.e., where a{ is finite, for j.= 1,... , K~ - 1, and al K' ---- cx:~) 2. Formally, the transition structure 
of .A/I is as follows. The transitions corresponding to arrivals are: ~c~i (hi, sl,.  , hi, s,... , 
aN, sN) > (nl,Sl .... ,ni +l, sl,... ,nN,SN) if C1 (1) Ao~i (ni,sl,... ,nl,sl,... ,nN,sg) (ni,si,... 
,ni+l, si+l,... ,nN,SN) if C2 (2) 2Note that, the server allocation/deallocation scheme de-scribed here 
does not preclude potential idling of servers, due to (a) requiring that each class is allocated at least 
one server and (b) allocation of servers to classes on arrivals only. Many other control schemes are 
possible and are subject of future work. where C1 is to the workload of other classes. Hence, in general, 
there is a non-zero probability that class i, which has already activated sl servers, is not able to 
add a server upon the forward threshold crossing. Let us refer to this as a "block- (s, < Ki) ^ (~ sj 
= K) ^ (F,(s~) < n, < F,(si) + a?)    ( j=l ) ni < Fi(sl) --bait and C2 is C2= ~<K ^ s~< ^ (s~)< 
 / V=' The transitions corresponding to departures are: Si~i (nl,Sl,... ,hi,sir... ~nN,SN) (nl,Sl,... 
,ni--l, si,... ,nN,SN) if C3 (3) (nl, Sl,... , hi, Si,... , aN, SN) silzi > (hi,S1,... ,hi --1,si --1,... 
,nN,SN) if C4 (4) where C3 is C3 (nl > 0)A(si = 1)) V  ((ni > O)A(ni--l> Ri(si--l))A (s~> l)) and 
C4 is 64= ((nl > O) A (ni --l = Ri(si --1)) A (si > 1)) A more detailed explanation of the derivation 
of conditions C1 through C4 is given in [4]. 3. ITERATIVE METHOD FOR SOLUTION OF A MULTI-CLASS MODEL 
In this section we describe our iterative approach to solving the model presented in Section 2. As described 
in Section 2, the corresponding Markov process, .Ad, is infinite (in mul- tiple dimensions), and hence 
our choices for solution are to either (a) simulate Ad, or (b) look for special structure, or (c) look 
for efficient approximation techniques. Since .M ap- pears to lack sufficient structure for an efficient 
exact solu- tion, below we describe an approximate solution technique, using iteration. The use of an 
approximation is motivated by the desire to construct an efficient solution approach (and simulation 
can be significantly slower than analytical solu- tions). 3.1 Basic Approach The basic approach that 
we pursue here is as follows. The original model .hd is approximately "broken up" into N sin- gle class 
Markovian models, .A/~i,.A/~2,..., jk..~g, which are "coupled" through a set of blocking probabilities 
(see Sec- tion 3.2 for a more detailed description of the .A,4i's). More specifically, the interaction 
between classes occurs when class i requires allocation of another server (due to the crossing of a forward 
threshold), and no servers are available in the system (i.e., all K servers have already been allocated) 
due ing" probability 7ai,~i,which (approximately) captures this interaction between classes 3. We now 
describe our iterative approach. Let .AdZ n) be the Markovian process corresponding to the individual 
class i model at iteration n with a correspond- ing steady state probability vector $¢},0. The parameters 
of each .Ad} n) are computed as a function of blocking proba- l~(n) ~(n) ~(~) }, which are in turn bilities, 
pin) = (--i,1 , 4,2 ,.." ,--i,Ki-1 computed as a function of the steady state probability vec- z_(n-D 
tor, "i , obtained during the previous iteration. (We give the details of the construction of .hd~ =) 
and the compu- tation of ~'}=) below4.) Then, an overview of our iterative approach is (a more detailed 
and formal description is given in Section 3.3): 1. construct ^A(°) ^A(°) AA(°)' ,v,1 ,--,2 ,... ,'''N 
,set n=0 (this is it- eration 0); 2. solve Ad~),.hd(2'~),... ,.ADZ ), i.e., compute the corre-sponding 
steady state probabilities to obtain ~n), #~,~) ..,#(gn); set n----n--b1; 3. use these steady state 
probabilities to compute pin),  ..., 4. use these blocking probabilities to update the indi-vidual class 
models, i.e., construct .AdZ '0, A4(2 '~), ..., .A4~v~), where for each i = 1,... ,N, parameters of .hd} 
~) are computed as functions of P}~) (but not PJ'~) where j 7t i); 5. continue the iterative process 
(i.e., go back to step 2) until the values of all Pi's converge   3.2 Individual Class Model Since 
our iterative approach involves solution of individ- ual class models (.Adi's) we now briefly describe 
the class i model, which can be defined as follows. There are Ki servers (Ki is unrestricted), each with 
an exponential ser- vice rate /zi. Customer arrivals are governed by a Pois-son process with rate Ai 
= aiA. Addition and removal of servers is governed by the forward and the reverse thresh- old vectors, 
namely FF~ = [Fi(1), Fi(2),..., F~(K~-])1 and R, = [ni(1), R~(2),... , Ri(K -1)1. Given a Ki-server single 
class threshold-based queueing sys- tem with hysteresis, we model it as a Markov process .hdl with the 
following state space Si: Si = {(k,j) l k_> O, j E {1,2,... ,Ki}} where k is the number of customers 
in the class i queueing system and j is the number of allocated servers. Figure 1 3Of course, this is 
an approximation, and hence, the fol-lowing description of the .Adi'S used in the iterative solution 
technique is also an approximation. 4Note that there are multiple approaches to constructing A4(0), i 
s, i.e., multiple ways to start the iteration; we give details of one such approach below. ~. i ~i ~ 
i Pi,l. ~ ~ i Pi,1 k~_ _4/2pi k._ .~2gi _2glk~'2~Zgi k.:2.~2[1 i _2gi~+l'_Y2gi k~_+2'~2g i Figure 1: 
State transition diagram for a class i system with Ki = 2. illustrates the state transition diagram for 
such a system where Ki ----2. Formally, the transition structure of .hdl can be specified as follows 
5 , where all transitions are from state (k, j), with the state description given above: Next State [ 
Rate Condition (k+l,/) At (I_<j<K~)A (k<F,(j)) (k+l,j) Ai j=Ki (k + 1, j) AiPl,j (1 _< j < gd^ ( F,(j) 
< k< F,(j) + a~ ) (k+l,j+l) Ai(1 -Pij) (1 _< j < gd^ (5) (Fi(j)_< k < F,(j) + a~) (k. 1,j) j#, (k_>l~ 
(I<j_<Ki)A (k--1 >Ri(j-1)) (k-1,j-1) j#i (k > 1) A (1 < j _< Ki) A(k -- 1 = R¢(j -1)) (k-l,j) #, (j=l) 
A(k>l) We now proceed to a more detailed'description of our iter- ative solution technique for the multi-class 
system. We do this under the assumption that, given Pi, we know how to construct .A41 (using Equation 
(5) above) and compute ~i (the steady state probability vector corresponding to Adi). The procedure for 
computing ~i, is given 6 in Section 3.5. 3.3 Iterative Computation First, note that in general, there 
are two cases to consider here: Case 1: ~/N=i Ki ~ K; that is, we have a "trivial" case, where the classes 
do not interfere with each other, and we can solve each individual class model once (i.e., no need for 
iteration) using the procedure given in Section  3.5 with P~,j = 0, Vi, j. Case 2: ~V=l Ki > K, where 
it is possible that an attempt at server allocation for class i may fail because all K servers in the 
system are currently allocated. As de- scribed above, in this case a form of blocking occurs and we solve 
the model using our iterative approach outlined in Section 3.1 whose details are now presented below. 
5Note that, the transition rates described here are a function of the blocking probabilities, T'i,t, 
which change from itera- tion to iteration, as outlined above; however, for simplicity of notation, we 
do not indicate the iteration step number in the description of the transition structure of a class i 
model. 6The motivation for first discussing the iterative technique is to simpfify the presentation of 
our approach. Note also that, the main difficulty in the iterative technique outlined in Section 3.1 
is in determining an appropriate pro- cedure for computing the blocking probabilities which cap- ture 
the class interaction, i.e., the probabilities that, upon a forward threshold crossing, it is not possible 
to allocate another server to class i. Recall that, during the n th it-eration (n _> 0), 7~},~ ) is the 
blocking probability of class i (1 < i < N) to which l servers have already been allo- cated (1 < l < 
Ki -1). Before we proceed, let us state the following definitions. DEFINITION 1. Let ,~ and y be two 
non-negative random variables having values in {1, 2, ...) and let 7rx and lry be their respective probability 
mass functions. Let Z be another non-negative random variable where Z = 2¢ + y; then ~z --7r x ® ~'y 
where ® is the convolution operator. DEFINITION 2. Let X be a non-negative random variable having values 
in {1;2,..., } and let 7rx be its probability mass function. Let 2('={ X if Ll < 2d < L2 0 otherwise. 
 Then the probability mass function of X', denoted by ~'x,, is equal to g(Trx, L1,L2) where function 
g is defined such that: 7rx,[k] = ~x[~]EL~L, ~X[m] if L1 < k < L2 ---- (6) 0 otherwise Let ~}n)[k, j] 
be the steady state probability of class i hav- ing k customers (k > 0) in the system and an allocation 
of j servers (1 _< j _< K~), computed during the n th iter- ation. Let It} '~) denote the steady state 
probability vector of the number of servers allocated to class i, where 7r} n) [j] denotes the steady 
state probability of j servers having been allocated to class i, as computed during the n *h iteration. 
Thus, we have: "'i w,J] (7) k Finally, let Q~n) be the transition rate matrix corresponding to the class 
i model Ad} '~), during the n th iteration, which is computed using the transition structure of Ad} '~) 
given in Equation (5) and p[,~-l), where 1 < l < Ki -1. Then, the iterative procedure is as follow: 200 
Initialization step: set n = 0 and set 7 ~(°) ~ 0 for i,l 1 < l < Ki. Given these initial values of blocking 
prob- abilities, for each class i, we can construct Q}0) using the transition structure given in Equation 
(5) and then compute ~i=(°) using the procedure given in Section 3.5. Once we compute the steady state 
probability vector ~.~0) for each class i, we can then compute their respec- _(o),~ tire server allocation 
probability vectors, "i ~, using Equation (7). The ~r~°)'s are in turn needed in the computation of the 
blocking probabilities, T'(U's (step i,l 2 below).  2. Updating of blocking probabilities step: n = 
n + 1, and o ifK >-/c P~,?) = 0 ifK-l>~j=l,S¢i J (8) F(i,l,n) otherwise The first condition in Equation 
(8) indicates that the system has a sufficient number of servers for all classes (we include this for 
completeness). The second condi- tion indicates that the system has sufficient resources to allocate 
at least one more server to class i with- out affecting the maximum possible server allocation of other 
classes. In the last condition, the F function is used to compute the blocking probability, at iteration 
n, for class i which has l servers already allocated to it. F(i,l,n) can be computed as follows. Let 
.Am(i,l,n) be the random variable, at iteration n, denoting server allocation of class m, when class 
i has been allocated l servers. Let Tin(i, l, n) be the probability mass func- tion of .An(i, l, n). 
Then we have: Tm(i,l,n) = g(Tr~-l),l, Lm) (9) for m = {1,2,... ,i-1,i+1,... ,N} where function g is defined 
through Equation (6) and Lm is as follows: { Km ifK-l-(N-2)>Km (10)L~ = K-l-(N-2) otherwise and ~(,~-1) 
in Equation (9) is computed using Equa- tion (7). The normalization in Equation (9) is used to account 
for the fact that if we know that the sys- tem already allocated l servers to class i, then the sys- 
tem only has (K -l) servers remaining. Out of these (K -l) remaining servers, the system needs to allo-cate 
(N -2) to customers that are neither in class i nor in class m (i.e., the system allocates at least one 
server to each class). Therefore, if the system poten- tially has at least Km available servers, then 
Am (i, l, n) can have values in {1,... ,Kin}; otherwise, the ran-dom variable .A~(i,l,n) can only take 
on values in {1, 2,... ,K- l-(N-2)}. Let B(i, l, n) be a non-negative random variable, at it- eration 
n, denoting the server allocation of all classes except class i, where class i already has l servers 
al-located to it. Let ~(i,l,n) be the probability mass function of/3(i, l, n). Then we have: qY(i,l,n) 
= g ((Tl(i, l, n) ® T2(i,l,n).--Ti-l(i,l,n) ®Ti+l(i,l,n)®.-.®TN(i,l,n)),N-1, K-l) (11) The normalization 
in Equation (11) is used to account for the fact that if the system has already allocated l servers to 
class i, then the number of servers that have been allocated to other classes can only range in {N-i,N,... 
,K-l}. Lastly, F(i, l, n), the function used to compute blocking probabilities, at iteration n, corresponding 
to class i with l allocated servers is: where q(i, l, n; K -l) = Prob[B(i, l, n) = K -l] and ~I'(i, l, 
n) is computed using Equation (11). 3. Updating of individual class models step: given the blocking probabilities 
P[,~) of class i in Equation (8), we can compute the new rate matrix Q~n) (based on the transition structure 
given in Equation (5)) and then compute the corresponding steady state proba-bilities ~r~ '~) (using 
the procedure given in Section 3.5) as well as ~'~), the probability vector of server alloca- tion of 
class i (using Equation (7)). (The Ir~ ~)'s will in turn be needed in theupdating of the blocking proba- 
bilities, "P[,7+l)'s (step 2 above).) 4. Test of convergence step: if I~/,?)-:P[,?-I)[ _< e for each 
class i, 1 < i < N, and eachl, 1 < l < Ki-1, then stop. Otherwise, go to step 2 and continue iterating. 
 3.4 Computation of Performance Measures In this section we briefly discuss computation of perfor- mance 
measures. Given the steady state probabilities "wl, i = 1,... , N, computed using the iterative approach 
described above, we can compute various performance measures of in- terest. More specifically, for each 
class i we can compute performance measures which can be expressed in the form of a Markov reward function, 
7~i, where T~i = ~ ~i[k, j]Ri(k, j) k,j and R/(k,j) is the reward for state (k,j) of class i. Some useful 
performance measures include: (a) expected number of customers of class i, (b) expected response time 
for cus- tomers of class i, (c) probability of dropping a customer of class i upon its arrival, (d) throughput 
of class i customers, and so on. For instance, let EINi] and E[Ti] denote the expected num- ber of customers 
and the expected response time, respec- tively, of the class i model, corresponding to the Markov pro- 
cess .A4i. Then E[N~] can be expressed as ~k,j k~i[k, j]. (A more detailed expression for [Ni] is given 
in [4].) Of course, using Little's result [15], we have E[Ti] = ~E[Ni], where A~ is the class i throughput. 
To compute A~ we need to account for the customers that are dropped from the system (see Sec- tion 2). 
Hence, A~ = Ai(1 - ~-,g,-I Pih~i[Fi(j) + a~,j]). L-,j=I We believe that the more interesting performance 
measures are those computed on a per class basis, since a useful part of studying performance of multi-class 
threshold-based sys- tems is to discover the effect that the various classes have on 201 one another. 
Hence above (and in Section 4) we have concen- trate on per class performance measures. However, we can 
also use these to compute overall system performance mea- sures, for instance, as a weighted average 
of the individual class performance measures. For example, we can compute the expected system response 
time, E[T], as follows: E[T] = ~ E[T~] + ~ E[T~] + . . . + ~ E[TN] where A* = ~N=~ X~. 3.5 Analysis 
of the Individual Class Model In this section we briefly summarize the solution technique for the individual 
class model which was defined in Section 3.2. Specifically, we use the single class solution technique 
we derived in [16] with some modifications needed to ac-count for the structure of the multi-class model. 
Since these modification axe mostly straightforward, we only summarize the solution technique in this 
section, ~nd give the details in N The general approach is as follows. As already stated, we model the 
class i queueing system as a Markov process, .h,4j, where: (1) the main goal is to compute the" steady 
state probabilities of the Maxkov process and use these to compute various performance metrics of interest 
and (2) the main difficulty is that the Maxkov process is infinite (see Section 3.2) and thus "difficult" 
to solve using a "direct" approach 7. As is often done in these cases, we need to look for special structure 
that might exist in the Markov process; specif- ically, we take advantage of the stochastic complementa-tion 
technique [17]. The basic approach to computing the steady state probabilities of the Maxkov process 
and the corresponding performance measures is as follows. We first partition the state space of the original 
Maxkov process .L,/~ into disjoint sets. Using the concept of stochastic comple- mentation, for each 
set, we compute the conditional steady state probability w;ctor, given that the original Maxkov pro- 
cess A,4j is in that set. (A relatively simple construction of the stochastic complement is possible 
due to the special structure that exists in the individual class models; specifi- cally we exploit the 
"single entry" structure as in [16].) By applying the state aggregation technique [1], we aggregate each 
set into a single state and then compute the steady state probabilities for the aggregated process, i.e., 
the prob- abilities of the system being in any given set. Lastly, we ap- ply the disaggregation technique 
[1] to compute the individ- ual (unconditional',} steady state probabilities of the original Maxkov process 
.Adj. These can in turn be used to compute various performance measures of interest. (Refer to [4] for 
a detailed derivation of the solution of .Adj.) as compared with simulation as well as (2) the use of 
our solution technique in studying performance of designs of threshold-based systems with hysteresis 
behavior. Accuracy of our approach. We begin with the illustration of accuracy of our iterative solution. 
Thus, in addition to solving each example model, represented by the Maxkovian process .h,4, using our 
iterative approach (as described in Section 3) we also simulate .A/l, for the purpose of validating this 
solution technique. In all experiments presented here, our iterative approach uses = 0.0000001 (refer 
to Section 3 for details). Note that, in this section, we use the mean response time of each class i, 
as the performance metric of interest. Lastly, parameter settings s for all test cases presented in this 
section are listed in Table 1. Figures 2 and 3 depict the difference in results obtained through simulation 
and through the iterative approach. class '1 (iterative} t ' ' ' ' 5 class 1 (simulation) ---x--- class 
2 (iterative) .... ~- . . . . ~4 class 2 (simulation) class 3 (iterative) ...... ~ ...... ---m .... ~.------m----~'-~ 
~.,:.:.:.:.~'~ ......... / - class 3 (simulation) ---e--- .~:.:.:" " ./ 3 ~.~.~" .e b-, i I I I I I 
I 0 0 1 2 3 4 5 6 System Arrival Rate Figure 2: Test Case -flA. 3.5 class 1 (iterative) , class 1 (simulation) 
---x .... .,.(k) 3 class 2 (iterative) .... ~---- m'/"" class 2 (simulation) ....... t3 ...... ...;:::a" 
2.5 class 3 (iterative) -.-u .... .,11.~¢~¢~" class 3 (simulation) -'-~'-" .~.,@; .... 2 1.5 1 0.5 I 
I I I < 0 0 5 10 15 20 System Arrival Rate Figure 3: Test Case ~iB. 4. NUMERICAL EXAMPLES AND VALIDA- 
TION OF APPROXIMATION In this section, we present numerical examples which illus- trate (1) the accuracy 
of our iterative solution technique 7We could consider finite versions of the model or trunca- tion of 
the infinite version [11]; however, in either case the Maxkov process would still be very large and the 
computa- tional complexity of a "direct" solution for a reasonable size system still high. As can be 
seen from these figures, the difference between the two results is small (e.g., in the case of Figure 
2, the largest difference is ~ 5%). Given such small differences, which are difficult to assess using 
graphs, we present the remainder of the accuracy related experiments using tables 8For ease of specification, 
we use the following notation aj = [a~..... al Ki'-l] to indicate the a~ values for each class i with 
j allocated servers (see Section 2). Test Cases Parameters Settings Test Case #IA K= 10, K1 = K2 = K3 
= 4, 0/1 = 0.6, 0/2 = 0.3, 0/3 : 0.1, ~1 = #2 = P3 : 1.0 F1 = [4, 8, 12],//1 -- [2, 6, 101, F2 = [8, 
12, 16], R2 -- [5, 9, 13], /'3 = [6, 10, 14], R3 -- [3, 7, 11], al -- [2, 2, 2], a2 = [2, 2, 2], a3 = 
[2, 2, 2]. Test Case #IB K = 10, t(1 -~ K2 -~ K3 = 4, #1 = 3.0, ~2 -~ 2.0, ~.L3 = 1.2 F1 = F2 = F3 = 
[4, 8, 12],//1 =//2 =//3 = [2, 6, a0] 11 = a2 -~ a3 = [2, 2, 2], 0/1 -~-0.5, 0/2 = 0.3, O/3 = 0.2 Test 
Case #2 K = 10, K1 = 4, K2 = 4, K3 = 4,#1 = #2 = #3 = 1.0, F1 : F2 : .F3 = [6, 10, 15],//1 ://2 ://3 
= [4, 5, 8], al : a2 : a3 [3, 3, 3]. Test Case #3 K = 10, K1 = 3, K2 = 3, K3 = 8,~ul = ~2 = #3 = 1.0, 
F1 = [6, 10l, R1 = [4, 7], al = [3, 31, F2 = [6, 10],//2 = [4, 7], a2 = [3, 3], F3 = [6, 10, 14, lS, 
22, 26, 30],//3 = [4, 7, 10, 13, 16, 19, 21], a3 = [3, 3, 3, 3, 3, 3, 3]. Test Case #4 /( = 12, K1 = 
3, K2 = 3,/(3 = 3, K4 = 5, el -~ [3, 3], a2 = [3, 3], a3 = [3, 3], a4 ~-~ [3, 3, 3, 3], #1 -~/~2 = ,3 
~---1.0, El ----[6, 10],//1 [4, 7], F2 = [4, 8], //2 = [2, 4], F3 = [8, 12], t/3 = [6, 9], F, = [5, 
9, 13, lZ], R4 = [3, 6, 9, 12]. Test Case #5 K = 12, K1 = 3, I(2 = 3,/(3 = 3, Ka = 6,~zl =/~2 = #3 = 
1.0 F1 = [6, 10],//1 = [4, 7], al = [3, 3], F2 = [4, 8],//2 = [2, 4], 12 = [3, 3], t'3 ---- [8, 12],//3 
---- [6, 9], a3 ---- [3, 3], F4 --- [5,9, 13, 17, 21],//4 -~ [3,6,9, 12, 15], a4 -- [3,3,3,3,3]. Test 
Case #6 K = 10, K1 = K2 =/(3 = 4,#1 = #2 =/~3 = 1.0, F1 = F2 = F3 = [6, 10, 15], //1 =//2 =//3 = [4,5,8], 
11 =12=13=[3,3,3],A1 =A2=2.0. Test Case #7 K ~- 8, K1 = K2 = K3 = K4 = 3,#1 -~/~2 ~- #3 = 1.0 F1 = F2 
= F3 = [10, 20], //1 "~-//2 -~ //3 = [5, 15], al -~ a2 : a3 = a4 : [2, 2], 0/1 ~- 0/2 : 0/3 : 0/4 = 0.25. 
Class 4 has three configurations: (A) .F4 = [5, 10],//4 = [3, 7]; (B) F. = [7, 14],//4 = [4, 11]; (C) 
F4 = [10, 20],//4 = [5, 15]. Test Case #8 K = 10, K1 = 6, K2 ~- 4, K3 = 2, 0/1 = 0.6, 0/2 = 0.3, 0/3 
= 0.1, O,1 = [2, 2, 2, 2, 2], a2 = [2, 2, 2], a3 = [2], #1 = #2 = #3 = 1.0. There are two configurations: 
(A) F1 = [4, 8, 12, 16, 20], R1 = [2, 6, 10, 14, 18], F2 = [6, 10, 14], R2 = [4, 8, 12], F3 = [8], R3 
= [6]; (B) F1 = [4, 8, 12, 16, 20],//1 = [2, 6, 10, 14, 18], F2 = [8, 12, 16], R2 = [6, 10, 14], 2"3 
= [8], R3 = [6]: Test Case #9 K = 10, K1 = K2 = K3 = 4,11 = a2 = a3 = [2, 2, 2], #a = 1.0, #2 = I0.0,/.L 
3 = I00.0, F1 = F2 = F3 = [4,8, 12],Ra = R2 = R3 = [2, 6, 10]. Table 1: Data Sets. Tables 2-6 illustrate 
several other experiments of validating the accuracy of our technique. (Due to the large size of the 
tables we only give the iterative result and the percentage error.) In all cases, the percentage error 
(%E) is defined as:  %E = [simulation result -iterative result[ x 100% (13) simulation result Although 
Table 2 is not the most interesting case from a design point of view, it is used to illustrate that our 
iter-ative approach "does the right thing", i.e., it produces the same results for all classes, for a 
system where all classes behave identically. Furthermore, as can be seen from Tables 2-6 the accuracy 
of our technique is good, even under high contention. cases corresponded to fairly high contention cases. 
These are also the cases that likely corresponded to "poor" designs where a reduction in contention for 
resources between classes is needed in order to obtain a system with good performance characteristics. 
In most of our experiments (some of which are presented below), the performance improvements that could 
be obtained, for instance, through better threshold settings, were significantly higher (percentage-wise) 
than the loss in accuracy due to our approximation. Hence, this is a good indication that our iterative 
technique is a useful tool for fast and fairly accurate assessment of threshold- based designs that can 
be used, for instance, for searching for good threshold settings. Next, we illustrate some of the performance 
tradeoffs and designs that can be studied using our technique. Note that, we have performed many more 
experiments than Response time behavior. we have been able to include in the paper. The results of We 
begin by illustrating, in Figure 4, the somewhat "pe-those experiments are similar to the ones included 
here and culiar" response time behavior of threshold-based resourcecan be found in a technical report 
[4]. OverM1, the percent- management techniques as well as their potential utility inage error in most 
cases we tested was within 5%, with few dynamic resource management of systems. In this figure we cases 
having an error of greater than 12%. depict a three class system where we fix the arrival rate of classes 
1 and 2 (at A1 = A2 = 2.0) and vary the arrival rateAs is probably expected, in our experiments, the 
higher error A~ A2 A3 E[T, ] E[T2] E[Ts] % error % error % error (iterative) (iterative) (iterative) 
(class 1) (class 2) (class 3) 0.40 0.40 0.40 1.630272 1.630272 1.630272 1.202181 0.735494 1.153579 0.80 
0.80 0.80 2.597491 2.597491 2.597491 3.058886 2.665640 3.148594 1.20 1.20 1.20 3.156590 3.156590 3.156590 
2.877489 2,619260 2.598514  1.60 1.60 1.60 3.304191 3.304191 3 304191 2.000313 1.749316 1.993638 2.00 
2.00 2.00 3.321952 3.321952 3.321952 1.630424 1.625574 1.719706  2.40 2.40 2.40 3.379876 3.379876 3.379876 
2.282249 1,994334 2.188239 2.80 2.80 2.80 3.592408 3.592408 3.592408 3.792533 3.334905 3.770227 3.20 
3.20 3.20 3.981657 3.981657 3.981657 1.820473 1.245720 1.811621  3.60 3.60 3.60 5.010319 5.010319 5.010319 
0.601689 1.198128 1.858318 Table 2: Test Case ~2. limb E[T,] E[T2] E[T3] %error % error % error (iterative) 
(iterative) (iterative) (class 1) (class 2) (class 3) 0.30 0.30 O.30 1.421688 1.421688 1.421680 0.413537 
0.181734 0.318665 0.60 0.60 0.60 2.122039 2.122039 2.122039 2.657185 2.095714 2.378890 0.90 0.90 0.90 
2.795585 2.795585 2.795464 3.284193 2.855018 2.994942 1.20 1.20 1.20 3.180244 3.180244 3 178452 2.371027 
1.896997 1.832370  1.50 1.50 1.50 3.357821 3.357821 3.344765 1.286876 0.882332 1.135763 1.80 1.80 1.80 
3.470854 3.470854 3.412461 0.711188 0.498285 0.647543 2.10 2.10 2.10 3.641093 3.641093 3.441965 0.564150 
0.070303 0.557836  2.40 2.40 2.40 4.068188 4.068188 3.462714 0.491789 0.814125 0.468379 2.70 2.70 2.70 
5.600409 5.600409 3.512400 0.911634 2.755618 0.956535 2.70 2.70 3.20 5.611609 5.611609 3.646626 0.158437 
3.637028 2.843098 2.70 2.70 4.00 5.647604 5.647604 3.935655 0.236337 3.279166 5.373869 2.70 2.70 4.80 
5.693371 5.693371 4.113839 0.126605 1.469008 1.825511 2.70 2.70 5.60 5.733468 5.733468 4.178537 0.048777 
0.166028 0.909810 2.70 2.70 6.40 5.763689 5.763689 4.135517 0.767475 1.791951 1.555702 2.70 2.70 7.20 
5.785786 5.785786 4.301380 2.732223 2.217973 1.388458 Table 3: Test Case #3. 5 i i ill ~ Performance 
sensitivity. 4.5 class 1 (iterative) i / We continue in Figures 5 and 6 with the demonstration of class 
2(iterative) ---~----/ / the last point, where we illustrate that it is worth while to [.. 4 class 3(iterative) 
.... *--- study the behavior of threshold-based systems, for instance, 3.5 to search for better threshold 
settings, as the changes in performance (due to better parameter settings) are often 3 significant. Given 
a fast and fairly accurate analytical so- 2.5 lution technique (such as ours), these studies can be made 
.< /,' efficient /2 11 , i i , , i i , ~1 I i i 1 i i 1.5 0 0.5 1 1.5 2 2.5 3 3.5 10 class 1,2,3 (class 
4 at config A) i ,.~.~.._ class 4 at config A ---×--- /~7"-"---:~ o Arrival Rate for Class 3 9 class 
1,2,3 (class 4 at config B) ----~---/7class 4 at config B .--.-o...... ~ 8 class 1,2,3 (class 4 at config 
C) -.-l,-- ..2" Figure 4: Test Case ~6. ~ 7 /. "............ ...- class 4 at config C -.-o-.-~ ~-----"-~ 
........... D / / ~ 6 .El" I" ° 5 o of class 3. We can make a couple of observation here: (1) the 4 
~ ..9 ......... ..~¢'" response time curve of class 3 shows the "peculiar" response ~ 3 time behavior 
mentioned above, i.e., it first increases, then 7 2 "flattens" out and then increases again, as a function 
of in- < 1 I I I I I I I I 0 1 2 3 4 5 6 7 8 creasing arrival rate; (2) the response time curves of classes 
System Arrival Rate 1 and 2 are flat, i.e., the increased workload in the system due to class 3 does 
not appear to affect the response time of Figure 5: Test Case #7. classes 1 and 2, ewm though there 
is contention for resources between all classes. The first observation is, of course, due to the fact 
that In Figure 5 all classes begin with the same characteristics. in threshold-based systems the response 
time can improve We then vary the threshold settings of class 4 to experiment at higher loads due to 
the crossing of a forward threshold with the effect this has on class 4 performance as well as on (which 
does not occur at lower loads). The second obser- the performance of the remaining classes. As can be 
seen vation suggests that threshold-based techniques can reduce from this figure, we are able to improve 
class 4 performance the sensitivity of performance characteristics of a class of with "more aggressive" 
threshold settings, without it hav- customers to the workload of other classes without having ing a significant 
effect (in most cases) on the performance of to partition resources statically. the remaining classes. 
It is interesting to note that in places St 0.90 0.90 1.80 2.70 X~ 0.90 1.80 1.80 2.70 ~3 1.80 1.80 1.80 
2.70 A4 4.50 4.50 4.50 4.50 E[Ti] (iterative) 2.797506 2.853014 3.581616 5.734653 E[T2] (iterative) 1.994472 
2.441160 2.504496 4.849304 E[T3] (iterative) 4.529838 4.543077 4.671432 6.490237 E[T4] (iterative) 4.374533 
4.375314 4.384649 4.530748 % error (class 1) 2.961873 4.506275 2.517501 0.130256 % error (class 2) 6.642513 
2.851423 3.911467 1.235332 % error (class 3) ! 0.469696 0.630932 2.294438 1.043941 % error (class 4) 
0.212680 0.393236 0.122387 2.141307 Table 4: Test Case #4. )~1 0.90 0.90 1.80 2.70 A: 0.90 1.80 1.80 
J 2.70 A3 1.80 1.80 1.80 2.70 A4 5.40 5.40 5.40 5.40 E[T~] (iterative) 2.843976 3.108633 3.785969 5.762419 
E[T2] (iterative) 2.017333 2.510323 2.640827 4.868467 E[T3] (iterative) 1 4.543616 ' 4.687938 4.934167 
I 6.52125.3 E[T4] (iterative) 4.177035 4.186058 4.211717 4.377117 % error (class 1) 4.322296 11.183943 
2.996919 1.494872 % error (class 2) 7.654710 3.839499 2.662320 0.799943 % error (class 3) 0.677994 2.575381 
3.703350 2.778988 % error (class 4) 6.927892 2.158903 0.066877 0.505154 5.5 i t i ~ 5 class I at config 
A I class 2 at conlig A --...X--- class 3 at conlig A ---~--. class 1 at config B -----~..... class 
2 at config a -.-II-----4.5 4 class 3 at config B -..o---.+/! 3.5 +. V- 3  ..-- +, +'+ 1+" zJ 2.5 /i 
++~" .11+. N 2 ~ 1.5 ~" I I I I I I I I I 2 3 4 5 6 7 8 9 System Arrival Rate Figure 6: Test Case #8. 
where this does have an effect on the performance of the other classes (e.g., at A = 6.3) the actual 
effect is somewhat unexpected. That is, one might expect that the "more ag- gressive" threshold settings 
of class 4 might detriment the performance of other classes; however that is not the case here. In general, 
it is often difficult to predict the effects of changes in threshold settings, partly due to unusual 
response time behavior of threshold-based systems and partly due to the interaction of such behavior 
with systems employing some form of blocking behavior. In the case of Figure 5, this be- havior may partly 
be due to the "more aggressive" threshold settings aiding in processing of the class 4 workload faster 
and hence resulting in greater resource availability for the other classes as well. Thus, experimentation 
with effects of threshold settings on system performance is of importance, and the ability to solve the 
corresponding models efficiently facilitates such experimentation. In Figure 6 we study the effects of 
changes in threshold settings of class 2 where all three classes exhibit signifi- cantly different characteristics. 
In this case, partly due to the "more aggressive" settings of thresholds (in configura- tion A as compared 
to configuration B), the performance of class 2 improves, but again without having a significant effect 
on the other two classes. Lastly, although we have not provided proofs of convergence or of the performance 
of the iterative technique in terms of Table 5: i i i J J ~ll !.,.'" ~, .at.-.-.-.-II-.-.--=ll----.-ii.---'"-/ 
/~,~ .-~ - .~ ..... -X-/ Test Case #5. convergence rates, we have performed extensive experimen- tations 
to gather empirical evidence that our technique does converge, and that it converges fairly quickly. 
Our exper- iments indicate that for most test cases the iterative ap- proach converges within approximately 
5 to 10 iterations. Based on the "wall clock" time, in most test cases, it pro- duces results more than 
two orders of magnitude faster than simulation. We note that, in general, theoretical characteri- zation 
of convergence of iterative techniques which use more than a single parameter (to characterize the intercation 
be- tween the models), which is the case in our approach, is difficult. In summary, the main focus of 
this section was the illus- tration of utility of our approach in evaluating designs of threshold-based 
systems, where "good" parameter settings, such as threshold valhes, constitute a difficult problem. We 
believe that the efficiency and accuracy of our solution tech- nique facilitates large-scale experimentation 
with parame- ter settings and subsequent evaluation of performance of threshold-based designs of systems. 
5. CONCLUSIONS In this paper, we have considered a K-server multi-class threshold-based queueing system 
with hysteresis in which the number of servers, employed for serving customers of each class i, is governed 
by forward and reverse threshold vectors. The main motivations for using a threshold-based approach was 
that (a) many applications incur significant server setup, usage, and removal costs and (b) that it is 
a good approach to dynamically managing a pool of resources between multiple workload classes. The motivation 
for the use of hysteresis was to control the cost during momentary fluctuations in workload. An important 
and distinguish- ing characteristic of our work is that we developed an effi- cient analytical solution 
technique for analyzing multi-class threshold-based systems with hysteresis behavior, which is needed 
in modeling of many applications. Specifically, we proposed an iterative solution method, which our empirical 
evidence indicates to be fast and fairly accurate. Most of our test cases were within 5 percent of the 
simulation results (used for validation purposes) with more than two orders of magnitude improvement 
in computation time (as compared to simulation). Furthermore, we studied the performance characteristics 
of threshold-based systems and showed that proper choices of design parameters, such as threshold val- 
ues, can produce significant improvements in system per- ~1 ~2 ~3 E[T1] E[T~] E[T3] (iterative) (iterative) 
(iterative) 3.6 3.6 3.6 4.623164 0.146230 0.010373 3.6 I 8.0 8.0 4.623164 0.192905 0.010867 3.6 116.0 
16.0 4.623164 0.239999 0.011862 3.6 24.0 24.0 4.623164 0.282280 0.012948 3.6 32.0 32.0 4.623163 0.343896 
0.014069 3.6 36.0 36.0 4.623165 0.462318 0.014623 3.6 36.0 60.0 4.623203 0.462322 0.017553 3.6 36.0 80.0 
4.623463 0.462348 0.019412 3.6 36.0 160.0 4.639706 0.463973 0.027313 3.6 36.0 240.0 4.701579 0.470160 
0.034302 3.6 36.0 320.0 4.776830 0.477684 0.038680 3.6 36.0 360.0 4.813562 0.481358 0.048136 Table 6: 
Test Case %error (class 1) 2.174990 0.344933 2.330279 3.795961 0.004456 0.397470 1.912505 1.140015 
1.656744 8.421698 2.454293 6.936106 #9. % error (class 2) 4.145004 6.774970 2.286976 0.633505 0.161939 
0.331783 0.602542 1.303909 1.143159 0.446514 2.720231 4.665342 % error (class 3) 0.192437 0.110304 0.550988 
1.696513 3.182985 4.019064 6.828556 7.189398 8.942603 7.297695 4.943296 12.454153 formance. Using this 
study, we illustrated the utility of our approach in evaluating designs of threshold-based sys- tems, 
where "good" parameter settings constitute not only an important but a difficult problem. We believe 
that the efficiency and accuracy of our approach facilitates large- scale experimentation with parameter 
settings and subse-quent performance evaluation studies of threshold-based de- signs of systems. Acknowledgements: 
The authors are grateful to the ano- nymous referees for their helpful and insightful comments. 6. REFERENCES 
<RefA>[1] P. J. Courtois. Decomposability : queueing and computer system applications. ACM monograph series, 
Academic Press, New York, 1977. [2] E. de Souza e Silva, S. S. Lavenberg, and R. R. Muntz. A perspective 
on iterative methods for the approximate analysis of closed queueing networks. In G. Iazeola, P. J. Courtois, 
and A. Hordijk, editors, Mathematical Computer Performance and Reliability, pages 225-244. North Holland, 
1984. [3] L. Golubchik and J. C. Lui. Bounding of performance measures for a threshold-based queueing 
system with hysteresis. In Proceedings of 1997 ACM SIGMETRICS Conf., Seattle, WA, June 1997. [4] L. Golubchik 
and J. C. Lui. A fast and accurate iterative solution of a multi-class threshold-based queueing system 
with hysteresis. Technical Report CS-TR-4115, University of Maryland, March 2000. [5] S. Graves and 
J. Keilson. The compensation method appfied to a one-product production/inventory problem. Journal of 
Math. Operational Research, 6:246-262, 1981. [6] O. Ibe. An approximate analysis of a multi-server queueing 
system with a fixed order of access. Technical Report RC9346, IBM Research, 1982. [7] O. Ibe and J. 
Keilson. Multi-server threshold queues with hysteresis. Performance Evaluation, 21:185-212, 1995. [8] 
O. Ibe and K. Maruyama. An approximation method for a class of queueing systems. Performance Evaluation, 
5:15-27, 1985. [9] J. Keilson. Green's Function Methods in Probability Theory. Charles Griffin, London, 
1965. [10] J. Keilson. Markov Chain Models: Rarity and Exponentiality. Springer, New York, 1979. [11] 
F. P. Kelly. Reversibility and Stochastic Networks. John Wiley and Sons, 1979. [12] P. King. Computer 
and Communication Systems Performance Modeling. Prentice-Hall, New York, 1990. [13] R. Larsen and A. 
Agrawala. Control of a heterogeneous two-server exponential queueing system. IEEE Trans. on Software 
Engineering, 9:552-526, 1983. [14] W. Lin and P. Kumar. Optimal control of a queueing system with two 
heterogeneous servers. IEEE Trans. on Automatic Control, 29:696-703, 1984. [15] J. D. C. Little. A proof 
of the queueing formula L = AW. Operations Research, 9:383-387, May 1961. [16] J. C. Lui and L~ Golubchik. 
Stochastic complement analysis of multi-server threshold queues with hysteresis. Performance Evaluation, 
35(1-2):19-48, March 1999. [17] C. Meyer. Stochastic complementation, uncoupling markov chains and the 
theory of nearly reducible systems. SIAM Review, 31(2):240-272, 1989. [18] D. Mitra and I. Ziedins. Virtual 
partitioning by dynamic priorities: Fair and efficient resource-sharing by several services. In B. Plattner, 
editor, International Zurich Seminar on Digital Communications, Lecture Notes in Computer Science, Broadband 
Communications, pages 173-185. Springer, 1996. [19] D. Mitra and I. Ziedins. Hierarchical virtual partitioning: 
Algorithms for virtual private networking. In IEEE GLOBECOM, pages 1784-1791, 1997. [20] J. Morrison. 
Two-server queue with one server idle below a threshold. Queueing Systems, 7:325-336, 1990. [21] R. Nelson 
and D. Towsley. Approximating the mean time in system in a multiple-server queue that uses threshold 
scheduling. Operations Research, 35:419-427, 1987.</RefA> 206  
			

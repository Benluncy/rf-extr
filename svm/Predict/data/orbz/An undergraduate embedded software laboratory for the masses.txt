
 An Undergraduate Embedded Software Laboratory for the Masses André Stollenwerk Chate Jongdee Stefan 
Kowalewski Embedded Software Laboratory RWTH Aachen University {stollenwerk,chate,kowalewski}@embedded.rwth-aachen.de 
 ABSTRACT In addition to lectures on basic theoretical topics nowadays curricula demand more and more 
practical experiences from the students. Due to the so-called bologna process in Eu­rope the graduation 
scheme at the department of computer science at RWTH Aachen University was changed, towards Bachelor 
and Master degrees. Within this change additional courses were established in order to improve the quality 
of education. The paper presents a lab course given at RWTH Aachen University already twice. It gives 
third semester bachelor students a .rst impression on creating embedded software. The course has to be 
attended by all undergraduate stu­dents. Due to the increasing number of students in computer science 
this will be up to 250 students, which is one of the biggest challenges of this course. In addition to 
embedded programming many system software concepts are practically implemented in this lab course. This 
enables the students to gain crucial knowledge in basic .elds of computer science. Categories and Subject 
Descriptors K.3.2 [Computers and Education]: Computer and In­formation Science Education; B.3 [Hardware]: 
Memory Structures; B.4.3 [Input/Output and Data Communi­cations]: Interconnections (subsystems); C.3 
[Computer Systems Organization]: Special-Purpose and Application-Based Systems Microprocessor; D.4.1 
[Operating Sys­tems]: Process Management Scheduling; D.4.2 [Operating Systems]: Storage Management General 
Terms Algorithms, Experimentation, Theory, Documentation, Ver­i.cation  Keywords Computer Science Education, 
Lab Course, Operating Sys­tem, Microcontroller, Undergraduate Course, Curriculum Permission to make digital 
or hard copies of part or all of this work or personal or classroom use is granted without fee provided 
that copies are not made or distributed for profit or commercial advantage and that copies bear this 
notice and the full citation on the first page. To copy otherwise, to republish, to post on servers, 
or to redistribute to lists, requires prior specific permission and/or a fee. :(66 09, Oct -Oct 1 , 
2009, GreQREOH )UDQFH &#38;#169; ACM 2009 ISBN: 978-1-60558- - /09/10...$10.00 &#38;#169; ACM 2009 ISBN: 
978-1-4503-0021-6/09/10...$10.00 1. INTRODUCTION Practical undergraduate courses have become more and 
more important in modern curricula. The basic idea is to deepen the students knowledge already in early 
states of their aca­demic life with the help of practical experiments [4]. This shall support the gaining 
of further knowledge and motivate them in acting and thinking like a computer scientist. The ideas described 
above are also re.ected in the result of the bologna process [6]. As a .rst result for the German academic 
landscape, the graduation scheme was changed to­wards Bachelor and Master of Science as academic degrees. 
At the department of computer science at RWTH Aachen University this transition was used to revise the 
curricu­lum. In order to improve the quality of education in di.er­ent .elds, the lab course Hardware 
Programming was estab­lished from scratch. This lab course pursues di.erent goals. The students shall 
get familiar with embedded hardware and the restrictions linked to the process of software development 
for devices like microcontrollers. In addition practical experience on system software design like implementing 
di.erent parts of an op­erating system shall be gained. This enables the students to get a better sense 
for low-level interfaces and restrictions of resources which is a valuable advantage in their further 
studies [14]. Beside this, other skills shall be addressed indi­rectly, e. g. software engineering, team 
work and presenting ones results. These skills are not addressed explicitly in the documentation handed 
out during this course but taught implicitly. The course was established in 2007 and will be held for 
the third time this winter. It is rated to 4 ECTS Credits (18 hours of presence exercises + 100 hours 
of homework) and lasts about 3.5 months. The course is a mandatory part of the computer science bachelor 
curriculum at RWTH Aachen University, resulting in a number of participants of approximately 250. This 
big number of students already shows the di.erence between the course and many other embedded systems 
laboratories [7, 9, 3]. Because of these conditions the concept for the lab course has to be adapted. 
On the one hand robust hardware is needed, in order to have a reliable platform to work on, on the other 
hand the stu­dents have to do as much preparation at home as possible. Therefore simulators and test 
hardware are needed, which enables testing previous to the presence exercises. In ad­dition to all this 
the organizational complexity grows with  Table 1: Schedule of the Lab Course Experiment Topic 1 Boot 
Loader 2 Scheduler 3 Memory Management 4 Process Manager 5 External Memory Chip 6 Application Task the 
increasing number of participants. Problems like .tting the individual appointments to the students schedule 
and being able to guarantee enough manpower for supervising each appointment arise. The paper is organized 
as follows: The organizational struc­ture and the educational targets of the presented course are given 
in section 2. Then the .rst two runs of the described lab course are evaluated; the consequential following 
steps are discussed in section 4, we present our conclusions in sec­tion 5.  2. COURSE STRUCTURE AND 
GOALS During this lab course the third semester undergraduate stu­dents develop their own operating system 
on a microcon­troller. The operating system is divided in di.erent mod­ules which are implemented during 
six experiments (see ta­ble 1). This strThis structure o.ers the chance to develop such a complex construct 
as an operating system step by step. Because of this modularization it was necessary to de­.ne some interfaces. 
These interfaces guide the students to implement many of the tasks in means of component based design. 
Some examples would be the process manager or the memory management. We intended the students to imple­ment 
these functions as modular as possible in order to be able to reuse the code. The process manager for 
instance is extended several times in order to get new sub-menus. Since it would be lots of copy and 
paste work we encourage the students to create reusable components for this. The students are organized 
in teams of two. Thus they have to solve the given tasks in teamwork. This increases social skills and 
reduces the workload of each student. The students receive the tasks for each experiment two weeks in 
advance. They are expected to solve these tasks as home­work within their team. To support this, the 
students have the opportunity to use either a simulation or the hardware from the lab course for preparation. 
In a computer pool run by the department of computer science we placed .ve microcontroller boards with 
additional programming hard­ware. Since this computer pool is opened and supervised almost the whole 
day, the students are able to validate their implementation on their own. Additionally there is a bul­letin 
board and regular consultation-hours to support the teams, if they got stuck during solving their tasks. 
The preparation for each experiment also contains the cre­ation of a 5-minute presentation. This presentation 
usually contains information about problems the students did face during the preparation, basic ideas 
for the solution or some of the aspects in their homework which were most demand­ing in their perspective. 
During the individual experiments .rst of all some of the students present their prepared home­work to 
all other present students. The mentioned prepara­tion (implementing the code and creating the presentation) 
is intended to take about 15 hours per experiment in aver­age. During the presence exercises the students 
are supervised by 3 tutors. Each of the experiments takes approximately 3 hours. During this time the 
teams receive so called test programs from our side. These programs use the functions implemented by 
the students and either test them for some of the boundary conditions or just for correctness of per­formance. 
For each of the experiments we have a test pro­gram, which just checks for stability during correct using 
of the functions. In these test programs the implemented func­tions are used as closed as possible to 
their intended purpose with randomized (but valid) arguments. We expect the stu­dents code to execute 
this program stable for more than one minute. This is usually the test program the students struggle 
most about. In addition to the test programs the students have to explain their implementation to at 
least one of the tutors. There are no other additional examinations. The students have to successfully 
pass all six experiments in order to pass the lab course. They do not receive a grade for the course 
due to the fact that too many students attend for this course and each experiment is supervised by a 
di.erent tutor. The fact that each experiment (except the second one) is based on the previous experiment, 
leads to the need to o.er the students a second attempt for failed experiments within a few days. This 
is an additional logistic overhead, but also forces the students to keep in touch with the prob­lems 
they occurred. Each student has the chance to fail in one of the experiments; if more than one experiment 
is failed the whole course will be stated as failed for these students. 2.1 Hardware Platform The hardware 
platform used in this course is based on an ATmega microcontroller. The actual printed circuit board 
(PCB), which embeds the microcontroller to peripheral de­vices like e. g. a LCD or a serial interface, 
was developed at our chair [5] (shown in .gure 1). It o.ers various interfaces (RS232, JTAG, ISP etc.) 
and peripheral devices (buttons, LEDs and a LCD). Thus, the students are able to directly interact with 
the Microcontroller. Of course necessary fea­tures like stabilized 5 V power supply or a voltage converter 
for the RS232 interface are integrated on this PCB. Many but not all of the o.ered features are also 
used in this lab course; since this platform is also used in other courses [11, 10] and even in rapid 
prototyping during re­search projects there are further features. The currently used microcontroller 
is an ATmega644. This choice is based on problems which came up during the .rst run of this lab course. 
During this .rst run in the winter term 2007/08 an ATmega16 was used. This microcontroller o.ers 16 kilobyte 
of program memory which caused some students programs to exceed this o.ered amount of mem­ory, although 
there were teams who were able to solve all tasks with this small amount of memory. So we know that it 
is possible to solve all tasks on an ATmega16. Neverthe­  Figure 1: ATmega Evaluation Board [5] less 
we recognized the students shall concentrate more on solving the given tasks than .tting their code in 
the given 16 kilobytes. Thus a microcontroller is used which o.ers 64 kilobytes of data memory. Besides 
the mentioned prob­lems we decided to stick to the ATmega-family since these microcontrollers come with 
some bigger advantages like an extensive, free of charge development environment or many available programming 
examples in the datasheet or on the internet. Other Microcontroller which o.er more functions or generally 
have more computational power usually come along with a more complex internal structure and can not o.er 
such a detailed datasheet which led us to our decision. The microcontrollers clock is driven by a crystal 
oscillator at 20 MHz and is con.gured or programmed through a JTAG interface. As development environment 
Atmel AVR Studio [1] is used. This software allows the students on the one hand to directly access the 
microcontroller (no additional tool­chain is needed for debugging) and on the other hand it o.ers the 
opportunity to monitor variables as well as memory or register contents. The students programs are written 
in C and compiled with avr-gcc (out of the Software WinAVR [17]). Using the JTAG interface for programming 
comes with the big advantage that on-line debugging is possible which allows the students to have a better 
understanding on what their code is doing and how the compiler is working. These features allow them 
to .nd bugs faster and retrace misunderstandings with the compilers way of interpreting the code.  2.2 
Simulation In this lab course the students have to implement many dif­ferent facets of an operating system. 
Since the presence time where they are guided and the hardware for testing is lim­ited there is a need 
to simulate the hardware. This need is additionally underlined by the big number of students at­tending 
for this course. If we would like to o.er all of them a su.cient chance for developing on the real hardware 
we would have to o.er way more microcontrollers than we do at the moment. These additional microcontrollers 
would need more place for hosting them. The integrated Simulator of AVR Studio [1] is used in or­der 
to simulate the behavior of the microcontroller. At this point a simulation for the embedding hardware 
platform is still needed. For this task we use the hardware simulator HapSim [16], which is able to directly 
hook up to AVR Stu­dios simulator. HapSim directly comes along with the sup­port for the LCD used in 
our hardware con.guration. Other hardware extensions we use were added by ourselves to the software. 
Due to the fact that the .rst experiment uses the bootloader functionality of the microcontroller, which 
AVR Studio is not able to simulate this experiment can not be simulated completely. In addition not all 
the behavior of the exten­sion hardware for the application task experiment is simu­lated correctly. 
The simulator is for example at this point not checking all needed registers to be initialized correctly. 
We are currently working at this issue. Nevertheless the stu­dents are already able to generally test 
their implementation; for the incorrect simulated parts we give explicit hints in the documentation. 
In general we have taken care of simulating the hardware as realistic as possible. Especially the func­tionality 
which is tested by our .nal test programs during each experiment is fully covered by simulation. Once 
the students have .nished developing and testing with the simulator, they have the chance to test their 
implemen­tation on the hardware in the computer pool.  2.3 Teaching Contents This lab course primarily 
addresses two di.erent educational goals. The students shall apply operating system compo­nents like 
boot loader, scheduler or memory management. The second target is to realize this implementation on em­bedded 
hardware. Especially in the domain of system software there are many di.erent possible algorithms to 
implement, e. g. di.erent memory allocation strategies. The students have the chance to implement and 
evaluate the di.erent solutions possible. This results in a better understanding of the advantages and 
disadvantages of the di.erent solutions. We strived to address with each experiment a speci.c set of 
educational goals out of system software concepts linked to the topics like listed in table 1. As mentioned 
before one of the main goals is to make the students familiar with embedded hardware and the process 
of writing low-level software and the restrictions linked to it. Although there is a number of students 
who already did software projects before the majority of the students have never programmed a microcontroller 
before. Nowadays most of the students are used to object-oriented program­ming languages e. g. Java or 
C#. A very small number have programmed in C or assembler before. Because of this background we want 
the students to experience the char­acteristics on these languages when programming low-level code. This 
includes tasks as con.guring the microcontroller and its peripheral devices through the microcontroller 
s reg­isters, usage of the microcontroller s fuses and usage of the di.erent types of memory within the 
microcontroller. Another new aspect most of the students have to face is to create a software project 
with more than one person. This comes along with challenges like e. g. properly documenting ones code. 
 In parallel to this lab course there is a lecture on operating systems and system software respectively. 
A subset of its content is implemented in our lab course. The knowledge on computer engineering was already 
conveyed during a .rst semester lecture and the knowledge on the physical basics has been consolidated 
during an additional lab course in the second semester. There are no admission requirements for registration 
to this course (besides being enrolled as a student and minimum in the 3rd semester). Due to this fact 
we can not expect spe­ci.c knowledge (though we recommend certain courses like e. g. programming and 
the above mentioned ones). Because of these circumstances we created some general guiding doc­uments 
for the students. They are not required to read these documents but we recommend it. The following additional 
guidelines are given to the students: AVR Studio Guide -In this Guide the development environment is 
introduced and some advices on the installation and the usage of this program are given.  Programming 
Guide -This document introduces the language C and gives some guideance on coding stan­dards.  Doxygen 
Guide -The Doxygen Guide explains the documentation Tool Doxygen [15] to the students. We use this tool 
to document our code and encourage the students to do the same with their code.  ATmega 644 Guide -This 
Guide gives some infor­mation on the used microcontroller and the available hardware. It is a kind of 
short and incomplete data sheet.  Debuggers and Testing Guide -This last guide is actually still under 
development. We want to o.er the students a introduction to di.erent techniques to .nd bugs in their 
code and to be able to properly test the functions they have implemented.  In addition to the mentioned 
guides there is a dedicated doc­umentation for each experiment. In this documentation .rst of all the 
goals of each experiment are introduced. This is followed by the theory needed for the experiment and 
im­plementation instructions. The theoretical part of the doc­umentation is additionally strengthened 
by so called ques­tions on learning success . In these questions the students can test if they have understood 
the explanations. In addition to the main educational goals other software en­gineering skills like planning 
the software development pro­cess, testing and verifying code or properly documenting the code are introduced. 
These topics are not addressed in the given tasks, but are explained in the given documentation. Tools 
for simulation and tools for documentation (Doxygen [15]) are introduced. 2.3.1 Operating Systems The 
overall goal of the course is to create a multi-threading operating system on the given microcontroller 
which is able to run di.erent processes. The operating system is split up in di.erent modules as already 
mentioned and shown in Table 1. Each of these modules focuses on a di.erent aspect of system software. 
In the following we will explain these in detail. Some of the mentioned topics cover more than one experiment 
due to organizational reasons. 1. Boot Loader In the .rst experiment the students have to create a boot 
loader for the microcontroller. This boot loader shall receive additional software through the RS232 
interface, save it to the application memory and pass over control to this code. In addition di.erent 
scheduling strate­gies (e. g. ring counter or round robin) [12] are imple­mented. The operating system 
is able to run di.erent 2. Scheduler In this experiment the students start from scratch again by creating 
a timer-interrupt based sched­uler. The results of the boot loader are not used any more here because 
the boot loader would need appli­cation memory again and it would make the whole is called periodically 
Figure 2: Control.ow in the Scheduler process a is interrupted and after scheduling process b is enabled 
3. Memory Management During the third experiment the students start implementing the memory manage­ment. 
A heap with an according heap-map for dy­namic memory allocation is established. Each process can allocate 
either private or shared dynamic memory in this heap. One di.culty during this experiment is to implement 
an e.cient memory management since the resources are very limited. The memory used for dynamic allocation 
(payload and heap-map) is smaller than 2 kilobytes. Because of this the map represents a very restricted 
number of states, which also causes that no address translation has to be implemented. Therefore it is 
not possible to implement an e.cient defragmentation. Hence di.erent memory allocation strategies are 
necessary. The ratio between map and payload is 2 : 1. Each byte of the heap­map can save the state of 
2 bytes of dynamical usable memory (payload). This arrangement is also shown in .gure 3.   Figure 3: 
Arrangement of the Data Memory half the memory is used for all processes stacks; the other half is shared 
by heap and global variables There is also a function to free each part of dynami­cally allocated memory. 
Therefore additional memory protection techniques have to be implemented. As al­ready mentioned before, 
dynamic shared memory is available. This causes several constraints e. g. read­write-dependencies or 
access restrictions [13]. Because of these dependencies the students have to take into account to withdraw 
the remaining operating time to the scheduler. 4. Process Manager This exercise is based on the pre­vious 
ones. The existing scheduler and the memory management are extended by a user interface. The students 
create a process manager that is controlled through the available buttons and uses the LCD on the evaluation 
board. This process manager enables the user to start, pause or stop the di.erent processes running on 
the embedded operating system. In addi­tion it has to be possible to start multiple instances of any 
process. Furthermore the process manager is also able to show information about the dynamic memory, like 
used and available amount of memory or the owner of a chosen memory cell. 5. External Memory Chip During 
the .fth experiment the memory management is applied on an external RAM-chip. This chip is accessed via 
a latch IC due to the fact that otherwise the available I/O pins would not be su.cient. This experiment 
mainly focuses on the signaling aspects between the di.erent devices. In addition timing issues have 
to be taken into account. The used PCB is shown in .gure 4. 6. Application Task The last experiment 
of the pre­sented lab course o.ers the students the choice between di.erent application tasks. Detailed 
information on these tasks are explained in section 2.4.  2.3.2 Embedded Hardware Programming Figure 
4: External Memory Board connected to the Evaluation Board The di.erent tasks given to the students during 
lab course face them with varying facets of programming embedded devices. The following section will 
describe a selection of di.erent characteristics the students have to deal with: USART As mentioned 
before in the .rst experi­ment a boot loader is established. This boot loader receives data that shall 
be loaded on the microcon­troller through a RS232 interface. For this applica­tion the USART of the ATmega 
is used. In some of the version of the sixth experiment di.erent ways of communication are established; 
di.erent RS232 con­nections are used. The connection also has to be fault sensitive, e. g. functionalities 
like parity error check or frame format check should be used. This enables the students to get a deeper 
view into low level communi­cation mechanisms.  Interrupts Di.erent interrupts are used all over the 
lab course. Beginning from the .rst experiment where the RS232 interface is interrupt controlled along 
the scheduler which is based on a timer interrupt towards miscellaneous versions of the application task 
where varying kinds of interrupts are used. Since many di.er­ent interrupts are used the students get 
familiar with di.ering kinds of boundary conditions of these inter­rupts. The conditions vary from prescalers 
over proto­col de.nitions towards con.guration of electrical char­acteristics. Beside all the mentioned 
conditions the students also get to know to the advantages and dis­advantages of nesting interrupts. 
They are not used in this course due to complexity reasons, but since they might be used under certain 
circumstances the overall concept is explained.  I/O Pins Input and output pins are used all over the 
course. On the one hand the user interaction is real­ized through these interfaces on the other hand 
also complex devices like the LCD or the external RAM­chip are connected through I/O pins. The drivers 
for the LCD are made available to the students at the be­ginning of the course, in order to give them 
a chance to quickly run a Hello World! like program. Using   the I/O interface comes along with handling 
electrical characteristics like pull-up resistors or timing charac­teristics. During the .fth experiment 
it is additionally necessary to regularly change some of the pins from input to output mode and vice 
versa. These varying aspects are experienced throughout the di.erent tasks. Memory Di.erent kinds of 
the microcontroller s mem­ory are used throughout the lab course. During the boot loader experiment for 
example the special pur­pose program memory area for boot loaders is used. From on experiment number 
three the data memory has to be partitioned with respect to the already ex­isting structures in this 
memory. This also demands an understanding of the structures which are already created by the compiler. 
 SPI In some of the application tasks the SPI-interface is used in order to communicate with other 
peripheral ICs. Because more than one peripheral IC is used the SPI concept of master slave connection 
between these ICs and the microcontroller has to be applied.  ADC One of the application tasks uses 
an optical interface for communication. Reading from this in­terface is based on measuring an analog 
voltage and interpreting it.  During this lab course many di.erent peripheral devices and interfaces 
of the microcontroller are used. This shall impart knowledge on electrical characteristics of the used 
devices and interfaces, but shall also show up the problems which usually come up during software development 
for embedded hardware which is an important quali.cation for an arising computer scientist[10].  2.4 
Applications Inspired by other courses we decided to o.er the students an application problem in the 
end of this lab course. From our point of view creating something applied will motivate the students. 
Because di.erent students have di.erent .elds of interest we created four di.erent application tasks. 
These tasks will be introduced in detail in the following paragraphs of this section: 2.4.1 Digital Picture 
Frame During this task a digital picture framework is implemented. The students are o.ered a color LCD 
and a SD chip card reader. Both devices are connected through SPI. This me­diates the master-slave communication 
concept. Software libraries will be o.ered to the students in this task. Nev­ertheless they will be able 
to get an impression on how a .le system works and basic impressions of image processing. During this 
task also basic functions such as rotate, mirror and .ip are implemented .nally. In addition some of 
the LCDs advance functions such as brightness, contrast and inverted color may be used. 2.4.2 RFID Reciver 
In the second application task the students get an RFID receiver. This receiver contains already the 
RF and signaling circuits to capture and decode the data inside di.erent RFID tags. It o.ers the students 
a digital interface which can be easily read through one of the I/O ports. The biggest challenge of this 
task is to read the code out of a RFID tag. Due to the fact that the signal is noisy it has to be post 
processed. The best way to organize the communication with the RFID reader is a input-interrupt. Here 
di.erent kinds of input-interrupts are possible to use. This allows the students to learn more details 
about the di.erent interrupts available on the microcontroller. In the end of this task the students 
shall implement an application which is using RFID; e. g. access control to the existing process manager. 
2.4.3 Keyboard driver In this task the students are o.ered an adapter in order to connect a PS/2 keyboard 
to the microcontroller. The PS/2 protocol is based on synchronized RS232. Because of this USART can be 
used to create a driver for the keyboard. After establishing basic communication the protocol of the 
keyboard has to be implemented. The challenging parts during this are the di.erent scan codes the keyboard 
is able to send out. PS/2 protocol has to be understood in order to read information from the keyboard. 
Finally during this task the students shall implement an application for the key­board. For this application 
the game hang-man and a simple LCD based text editor is foreseen. 2.4.4 Communication Interface The last 
o.ered application task shows up di.erent ways to communicate with two microcontrollers. On the one hand 
the RS232 interface is used and on the other hand an opti­cal interface based on a LED and a photo resistor 
is used. During the boot loader experiment the students already got familiar with the USART interface. 
In this task the usage of the USART is extended by more special features as par­ity, non usual frame 
formats and error supervision. This shall illustrate the di.erent possibilities of such a common interface. 
The optical interface introduces the students to the electrical characteristics of such an interface 
and the problems linked to it. Each time a high voltage level is sent out the LED starts lighting the 
and subsequently the voltage at the photo resistor is changing. This behavior is monitored through one 
of the ADCs and interpreted in order to receive data. This very simple interface leads to a transmission 
rate of approximately 1 byte per second and enables the students to see and better comprehend the communication. 
 3. EVALUATION This lab course was established in 2007 and held for a second time in 2008. Some of the 
presented ideas already came up through the evaluation of a predecessor we did in the previous year. 
Examples for this are the possibility to test and validate the code on the actual hardware or the o.ering 
of a choice of application tasks. The evaluation is done in several ways We have established our own 
web based feedback form. Students are encouraged after each experiment to .ll in these forms. This kind 
of evaluation is .lled by approximately 40 -50 % of the participating students.  The big advantage is 
that we get dedicated feedback to each experiment, which enables us to improve speci.c details. In this 
form the students do also have the chance to .ll in a free-text .eld. As a second evaluation tool the 
RWTH Aachen Uni­versity uses feedback forms for each course done once in a semester across the whole 
university. This is done by handing out real-paper forms during one of the ex­periment which are .lled 
by the students. This causes a participation rate of more than 90 %.  As a third kind of evaluation 
we introduced round ta­bles in an neutral atmosphere. This enables us to get the feedback in a dialogue 
which is better in order to really understand the matter of feedback.  The presented numbers are based 
on the evaluation in 2008. The following discussion is based on the observations out of both years. The 
course scored an overall ranking of 2.7 (where 1 is very good and 5 is bad). This result is at .rst sight 
not what we would expect. If we pay respect to the fact that each third semester student has to pass 
this lab course and many of them have not handled a software project before one might better understand 
this result. If we take a deeper look in the evaluation forms other questions come up which show that 
the students see an advantage in this course. The content of teaching of this course was considered as 
im­portant (2.0), while the students say that they were able to learn very much in this course (1.4). 
Another remarking point is the assessment of the gained factual knowledge and the ability to apply this 
on new tasks. Both points were con­sidered as good (2.0). This especially was also very present during 
some of the direct conversations with the students. Many of the students were interested in getting a 
microcon­troller evaluation board themselves at home to be able to implement own projects. Because of 
this we also decided to publish our printed circuit designs and a list of all needed parts on our website 
[5]. In additions to the bare numbers of the questionnaires many valuable improvement suggestions came 
up during personal discussions with smaller groups of the participating stu­dents. The most prominent 
example may be the extension of the application tasks. In both runs of the laboratory only one application 
task was o.ered. During the next run of the lab course the students will be o.ered the choice of the 
presented four tasks (see section 2.4). Additional useful information we could gain out of these discussions 
is the speci.c workload of each experiment. We got to know that there is room for improvement in the 
order of the given tasks within the experiments.  4. DISCUSSION The presented lab course focuses on 
creating an operating system for embedded hardware. During the .rst two runs of the course the feedback 
from the students has shown that the workload of the individual tasks during the di.erent ex­periments 
is strongly varying and should be adjusted. Hence it is planned to rearrange the content of each individual 
ex­periment. As already introduced before, the students give a short pre­sentation about their preparations 
at home. They do not know if they were selected for presentation in advance since the teams who shall 
present are picked by a random gen­erator. We could recognize that this on the one hand leads toward 
a better preparation of the students and on the other hand improve the students ability to present the 
work done by the team. Finally these presentations also prevent other teams to get stuck in the same 
problems like one that was already presented. Due to inspiration from comparable other courses [2, 7] 
dif­ferent application tasks were established. The students have the choice between four di.erent tasks. 
We have also dis­cussed about o.ering the students a free of choice application (the students would be 
able to conceive the task themselves) as the last experiment. But we came to the awareness, that proper 
support would not be possible if each team will im­plement their own task. Understanding each team s 
code with regard to the chosen task would lead to inconvenient long response times in supporting the 
students. Furthermore it is in discussion to tackle new tasks towards other operating system components 
such as implementing a .le system or a network interface. These things will be taken in consideration 
during one of the next round tables with the according students. It was already shown before that the 
presented course has a big number of attending students. This causes a great ef­fort for supporting the 
students. During each experiment in general three tutors are present. In addition to this we o.er a bulletin 
board and regular consultation-hours to support the students. Nevertheless we consider this investment 
to the students education to be justi.ed by the results. At this point .rst of all the outcome of the 
evaluation can be mentioned. The students perceive the content of teaching of this course to be a big 
assistance for their further studies [8] and it enables them to understand the theoretical gained knowledge 
and be able to apply it. In Addition we were able to recognize during the students further studies that 
they better understood computer engineering aspects and how to interact with hardware in order to get 
ones software project running. From our point of view this lab course is a consequent continuation of 
previous courses [11]. Like already mentioned in section 1 a lab course with such a big number of participants 
comes along with some challeng­ing requirements. Nevertheless the .rst two runs of this lab course have 
shown that the tasks we have given to the stu­dents were feasible. The feedback from our students showed 
us that the specially developed evaluation board, diverse kinds of support (e.g. bulletin-board, consultation-hours) 
and the chance of simulation and testing lead to the point where we could successfully organize the course. 
 5. CONCLUSIONS This paper has presented a third semester undergraduate laboratory for computer science 
bachelor students. On this background the main purpose is to familiarize these students with a varying 
range of aspects related to embedded systems soft-and hardware. In additions to this the students get 
to know the basic concepts of system software by implementing the most important modules of an operating 
system. Many practical experiences about these .elds are gained through­out the whole course.  In addition 
to the already mentioned skills the students face many other challenges varying from working in teams 
towards presenting their preparation in a short summary. Many of these challenges in addition lead towards 
the nowa­days often required soft skills. The presented lab course was attended by 154 bachelor stu­dents 
in 2008 out of the department of computer science. Re.nements towards the next run in the winter of 2009 
were already reported. Beyond this additional improvements are planned to be established within the next 
months. Finally we are also evaluating of di.erent prospects to give the students more chances to test 
directly on the actual hardware.  6. ACKNOWLEDGMENTS We gratefully acknowledge the .nancial support 
we gained by the students union which enabled us to o.er the variety of application tasks in the sixth 
experiment and to improve the already existing courses in computer science teaching at RWTH Aachen University. 
Additionally the gratefully ac­knowledge the support of the German Research Foundation (Grant KO1430/8-1) 
which enables us to evaluate di.erent application tasks. In addition we want to thank the computer service 
group at the department of computer science for o.ering space and capacities in order to o.er the chance 
of testing beside the actual presence parts to our students.  7. REFERENCES <RefA>[1] Atmel Corporation. AVR 
Studio 4.16 SP1, May 2009. http://www.atmel.com/dyn/Products/tools card.asp? tool id=2725. [2] A. Behrens, 
L. Atorf, R. Schwann, J. Ball´e, T. Herold, and A. Telle. First steps into practical engineering for 
freshman students using matlab and lego mindstorms robots. Acta Polytechnica: Journal of Advanced Engineering, 
3, 2008. [3] D. Brylow and B. Ramamurthy. Nexos: A next generation embedded systems laboratory. In WESE08, 
2008. [4] S. W. Director, P. K. Khosla, R. A. Rohrer, and R. A. Rutenbar. Reengineering the curriculum: 
Design and analysis of a new undergraduate electrical and computer engineering degree at carnegie mellon 
university. Proceedings of the IEEE, 83(9):1246 1269, 1995. [5] Embedded Softeare Laboratory, RWTH Aachen 
University. An atmega evaluation board design and components list, 2008. http://www.embedded.rwth­aachen.de/doku.php?id=lehre:wise0910:hnp. 
[6] European Ministers of Education. The bologna declaration, June 1999. http://www.magna- charta.org/pdf/BOLOGNA 
DECLARATION.pdf. [7] A. Hansson, B. Akesson, and J. van Meerbergen. Multi-processor programming in the 
embedded system curriculum. In WESE 08, 2008. [8] P. Koopman, H. Choset, R. Gandhi, B. Krogh, D. Marculescu, 
P. Narasimhan, J. M. Paul, R. Rajkumar, D. Siewiorek, A. Smailagic, P. Steenkiste, D. E. Thomas, and 
C. Wang. Undergraduate embedded system education at carnegie mellon. ACM Trans. Embed. Comput. Syst., 
4(3):500 528, 2005. [9] A. Phalke, M. Biller, S. Lysecky, and C. Harris. Non-expert construction of customized 
embedded systems to enhance stem curricula. In WESE 08, 2008. [10] F. Salewski and S. Kowalewski. Hardware 
platform design decisions in embedded systems: a systematic teaching approach. SIGBED Rev., 4(1):27 35, 
2007. WESE06. [11] F. Salewski, D. Wilking, and S. Kowalewski. Diverse hardware platforms in embedded 
systems lab courses: a way to teach the di.erences. SIGBED Rev., 2(4):70 74, 2005. WESE05. [12] A. Silberschatz, 
P. B. Galvin, and G. Gagne. Operating System Concepts, volume 7. John Wiley &#38; Sons, 2005. [13] A. 
S. Tanenbaum, A. S. Woodhull, and und Alfred Woodhull. Operating Systems Design and Implementation, volume 
2. Prentice Hall, 1997. [14] M. T¨orngren, M. Grimheden, and N. Adamsson. Experiences from large embedded 
systems development projects in education, involving industry and research. SIGBED Rev., 4(1):55 63, 
2007. [15] D. van Heesch. Doxygen source code documentation generator tool, April 2009. http://www.doxygen.org/. 
[16] H. Wallner. HAPSIM Helmi s AVR Periphery Simulator, May 2009. http://www.helmix.at/hapsim/. [17] 
J. Wunsch. Winavr, March 2009. http://winavr.sourceforge.net/. </RefA>  
			

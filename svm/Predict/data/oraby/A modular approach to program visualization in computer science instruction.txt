
 A Modular Approach to Program Visualization in Computer Science Instruction Don C. Stone Department 
d Mathematics and Computer Science Cqassboro State College ~assboro, NJ 08028 ABSTRACT: The approach 
to program visualization in computer science instruction discussed here has two components: the graphic 
display of algorithms and the graphic display of their execution. Both types of display are based on 
the same hierarchical representation of an algorithm (in terms of Scandura FLOWforms, an enhancement 
and generali- zation of Nassi-Shneiderman diagrams). The execution display is obtained by the addition 
of explicit display commands to the basic algorithm, but the execution display details can be largely 
suppressed when the algorithm itself is being displayed. Two major characteristics ol this approach are 
the modularity and the easy modifiability of demonstration procedures. The hardware required is an IBM 
PC or AT or compatible. I. INTRODUCTION : Considerable attention has been focused recently on various 
program development and program visualization aids, both for professional programmers and for instruction. 
Examples of such aids are syntax- directed editors, visual programming environments (including flowchart-oriented 
systems) and program animation systems. (See, for example, Raeder [1985] and Brown, et M [1985].) The 
purpose of this article is to discuss the use of a particular modular approach to program visualization 
in computer science instruction. (In the terminology recommended by Brad A. Myers [1986], Permission 
to copy without fee all or part of this material is granted provided that the copies are not made or 
distributed for direct commercial advantage, the ACM copyright notice and the title of the publication 
and its date appear, and notice is given that copying is by permission of the Association for Computing 
Machinery. To copy otherwise, or to republish, requires a fee and/ or specific permission. &#38;#169;1987 
ACM 0-89791-217-9/87/0002/0516 75¢ program visualization, or PV, is the graphic illustration of programs 
or their execution.) This approach to PV is now being used for classroom demonstrations of data structures 
and algorithms, with the goal of helping students learn computer science concepts more rapidly and thoroughly 
via intuitive, dynamic visual displays. The distinctive feature of this approach to PV is that its two 
components, the graphic display of an algorithm and the graphic display of its execution, are based on 
the same hierarchical representation of the algorithm. The graphic display of algorithms is done via 
the TurboFLOW 512 system = discussed below; the display of their execution is implemented via Pascal 
code (generated by the TurboFLOW system) which includes Turbo Pascal graphic commands (and libraries 
of data structure display procedures calling on them). The required hardware (the IBM PC or AT or compatibles) 
is widely available. Two major characteristics of this approach to PV are the modularity and the easy 
modifiability of demonstration algorithms. The modularity is due to the fact that demonstrations of different 
computer science concepts can be developed relatively independently. A modest set of data structure display 
routines is generally sufficient to illustrate the concepts in a particular area, e.g., linked lists, 
and the sharing of ~l'urboFLOW was obtained by Glassboro State College by special arrangement with Intelligent 
Micro Systems, Inc. (IMS), 1249 Greentree Lane, Nart~rth, PA 19072. TurboFLOW is a simplified version 
of IMS's PRODOC system, based on research by Prof. Joseph M. Scandura (1987) and his associates at the 
University of Pennsylvania. TurboFLOW and PRODOC are trademarks of Intelligent Micro Systems, Inc.  
516 [SORT1.RUL]:sort Copyright 1986 Scandura Ascending selection sort of the first n numbers in array 
a. Set the boundary after the last active element in the array a. Repeatedly scan up to boundary, exchange 
largest with last before boundary and move boundary forward. Figure I. Selection sort with one level 
of refinement I [SORT1.RUL]:sort Copyright 1986 Scandura Ascending selection sort of the first n numbers 
in array a. boundary := n WHILE boundary > 1 DO Scan up to boundary, looking for largest. Exchange largest 
with last before boundary. Move boundary forward. Figure 2. Selection sort with three levels of refinement 
 [SORT1.RUL]:sort Copyright 198&#38; Scandura Ascending selection sort of the first n numbers in array 
a. I boundary := n WHILE boundary > 1 DO loc of largest := 1 FOR i := 2 to boundary DO IF a[i] > a[loc_of_largest] 
THEN Iloc_of_largest := i L i tamp := a[boundary] a[boundary] := a[loc_oflargest] ia[loc_of_largest] 
:= temp boundary := boundary - 1  Figure 3. Selection sort with six levels of refinement 517 demonstration 
procedures and display routines allows people to build on the work of others rather than "starting from 
scratch." The easy modifiability of demonstration algorithms is a consequence of the use of a uniform 
hierarchical representation of algorithms and of the modularity just described. If an instructor wants 
to modify an algorithm, he or she makes the changes just once (in the hierarchical representation). This 
means, for example., that the instructor can alter a sample procedure during a classroom demonstration 
and immediately display both the altered algorithm and its effects on data structures. 2. ILLUSTRATING 
THE ALGORITHMS THEMSELVES: The vehicle for illustrating the algorithms themselves is the TurboFLOW 512 
system (hereinafter referred to simply as TurboFLOW). It is a system for the IBM PC or AT (or compatibles) 
which allows users to design procedures graphically and interactively, representing and displaying them 
as Scandura FLOWforms (Scandura, 1987), an enhancement and generalization of Nassi-Shneiderman diagrams. 
The user initially 8ires a high-level description of a procedure in a single box, which he or she then 
refines on the screen into a sequence, selection or loop, whose components are specified and then (as 
appropriate) further refined on the screen by the user. When the procedure is fully specified, the higher 
level (pre-refinement) descriptions of subprocesses are still available, and thus the generation of documentation 
is built into the programming process. TurboFLOW allows the user to insert, delete. move, and edit FLOWform 
components (or groups of components) interactiveIy, so long as the result is structured. TurboFLOW automatically 
generates Pascal source code from these FLOWforms; syntactic and formatting details such as indenting 
and the insertion of ";', DEGIN and END, are handled automatically at this point. As an example of the 
use of TurboFLOW, consider the top-down development of a sorting algorithm. The first FLOWform, Figure 
1, gives the high level description which the user will enter initially; the user will then refine the 
steps in this FLOWform, producing the second chart, Figure 2, which will then be elaborated into the 
third chart, Figure 5, which gives the most detailed description. (It should be pointed out that when 
a FLOWform element is refined into a sequence structure, the sequence components are indented within 
the large box corresponding to the structure as a whole. This produces at the left of the sequence a 
vertical bar which shows the extent of the sequence and thus allows us to see the structure of a nested 
set of sequences. In Figure 3, for example, the body of the While loop can be seen to be a sequence of 
three elements, the first of which is itself a sequence of two, the second of which is a sequence of 
three, and the third of which is a sequence of one'.) After the user has completed the FLOWform, he or 
she will use the declaration capability of TurboFLOW, in which the system will find the variables and 
constants used in the FLOWform and will ask the user for the role and type of each. The user will then 
have the system generate source code from the FLOWform and declaration data. The code generated by TurboFLOW 
for this sorting example is shown as Figure 4. PROCEDURE so[t n : INTEGER; var a = INTEGER ARRAY ); 
 VAR boundary : INTEGER; loc_of_largest : INTEGER; i : INTEGER; temp : INTEGER; BEGIN BEGIN boundary 
: = n END; mILE boundary > i DO BEGIN BEGIN loc_of_largest := I; FOR i := 2 to boundary DO BEGIN IF 
a£1] > aEloc of_largest] THEN loc_of_largest := i END END; BEGIN temp := a£boundary3 ; aEboundary] 
:= a£1oc_of_largest3; a£1oc of largest3 := temp END; BEGIN boundary := boundary -I END END END; Figure 
4. Source code generated for selection sort by TurboFLOW =A sequence of one element often occurs when 
a higher-level description of a process turns out to be implementable by a single detailed command. Keeping 
both levels of description in the FLOWform generally helps make it more intelligible. 518 When TurboFLOW 
is used in a classroom to illustrate the structure of an algorithm, the algorithm will generally have 
been typed in earlier, especially if the algorithm has been augmented by data structure display commands. 
However, the algorithm can still be displayed via TurboFLOW in a fashion which reflects its top--down 
development. When TurboFLOW initially draws a FLOWform, it draws only the first level of detail, e.g., 
what is shown in Figure 1. An additional level of detail is drawn when the user gives a right- arrow 
movement command which would move into that level. For example, if the instructor uses the arrow keys 
to move to one of the two dements in the sequence structure of Figure I and then presses the right arrow 
key, the refinement of that step would then be shown. To make it visually easy to distinguish FLOWform 
elements which are higher-level descriptions (and have been or will be refined) from those which are 
executable commands, Intelligent Micro Systems, Inc., recommends writing the higher-level descriptions 
as sentences (beginning with an upper case letter and ending with a period) and writing executable commands 
entirely in lower case. Note that the hierarchical representation of algorithms in terms of Scandura 
FLOWforms allows the details of the data structure display process to be largely suppressed while the 
 algorithm is being displayed: when a higher-level data structure display description becomes visible, 
the instructor will not use the right arrow key to show its refinement. 3. ILLUSTRATING THE EXEOUTION 
OF ALGORITHMS: Our approach to illustrating the execution of algorithms is to have instructors explicitly 
include calls on display routines in their demonstration procedures (such as the selection sort discussed 
above). These display routines currently rely on the graphic capabilities of Turbo Pascal, although Microsoft 
Windows is being investigated as a language-independent environment for supporting the graphic displays. 
The execution of the sort procedure, for example, can be graphically illustrated by showing the array 
being sorted at several successive points in time. In our display of the array, we chose to distinguish 
visually (by color) the sorted numbers (those which are in the locations they should be in for the final 
ordering) from those that are not necessarily where they should be. In addition, we have used a line 
to indicate the boundary between the sorted numbers and the unsorted or only partially sorted numbers. 
 Figure 5 shows how such a display would look for an array of four numbers after the first time throush 
the main loop of the sort procedure.  2171 31 4 I 4 l:!:!:!ai:i:!l Figure 5. Selection sort of four 
numbers: array after first scan and exchange. Figure 6 shows the same array after the second time through 
the main loop of the sort procedure.  2}4 ) 4 I::::::S::::::I Figure 6. Selection sort of four numbers: 
 array after second scan and exchange. These displays are produced by adding a few display commands 
to the sort procedure described earlier. Figure 7 ,shows an S19 augmented version of this sort procedure, 
including high-level descriptions of the display operations. Display routines with the following capabilities 
were used to implement the animation of the sort: a routine which displays specified elements of an 
array as vertically stacked boxes; Its parameters include the array name, the range of subscripts to 
dlsplay, the box height, width and color, the spacing between boxes, and the position of the first box; 
 a routine which displays a specified line;  a routine which waits for a keypress;  a routine which 
initiates graphic mode and fills ~aphic window with specified color; a routine which initiates text mode 
and fills window with specified color. A somewhat more elaborate version of the animation, highlighting 
the scanning process of the inner loop, could easily be prepared. Further refinements are possible, e.g., 
along the lines of the sorting displays in the film Sortie" Out ,Yort, i~,~,"by Baecker and Sherman (1981). 
In addition, text commentary can be added to animations. An executable animation is produced by generating 
Turbo Pascal source code from the augmented sort FLOWform. After the instructor has shown the sorting 
algorithm via TurboFLOW, he or she will run the demonstration under Turbo Pascal, probably for several 
data sets. If the instructor wants to modify the algorithm and animate the result, he or she can make 
the changes in the FLOWform and then generate source code for this revised algorithm and run it under 
Turbo Pascal.  [ANIMSRT2.RUL]:animated_sort Copyright 198&#38; Scandura Ascending selection sort of 
the first n numbers in array a. Do graphic initialization. boundary := n Display elements 1 through n 
of array a in green. Display line below nth element of a. ] ause WHILE boundary > 1 i iDO Scan up to 
boundary, looking for largest. Exchange largest with last before boundary. f Move boundary forward. 
Display elements 1 through boundary of array a in green. Display line beloH element in position boundary 
of a. Display elements boundary+l through n of array a in red. pause Do text initialization. Figure 7. 
Selection sort with indication of animation operations 520 The animated demonstration procedure will 
be embedded in a Pascal program which includes the other components necessary to allow the demonstration 
to run and display its work. In addition to the graphic routines, this will include a data generation 
or input routine. The program will also include the definitions of the relevant data structures. These 
definitions may include additional components, to store screen coordinates, for example. Figure 9 shows 
the display after insertion of the element with the value 4. Head  LJ p I I  The approach of having 
the instructor add explicit display commands to a demonstration procedure can be contrasted with various 
approaches to PV which involve automatic generation of dynamic data structure displays. The automated 
approach is well-suited for use, for example, by a programmer who is debugging. The approach discussed 
here involves slightly more work for the instructor, but in return the instructor gets the ability to 
fine-tune the display, adding, for example, the color and boundary line in the sorting example. In general, 
it allows the instructor to have the kind of control over screen design which is appropriate for the 
instructional context. 4. A SECOND EXAMPLE: LINKED LIST INSERTION: A second example will be given to 
show a simple way of displaying a linked list. The basic linked list display routine draws a linked list 
as a vertically stacked set of partitioned boxes, as shown in the left hand portion of Figure 8. The 
algorithm for determining how to draw the arrows (representing pointers) is fairly simple: the arrow 
is drawn to the nearest midpoint of a side of the pointed-to box. Head I Is Figure 9. Singly--linked 
list after insertion of new element. More sophisticated techniques for display of linked lists (e. g., 
curved arrows and interactive positioning of list elements) are discussed by Rambally (1985), but the 
above approach appears to be adequate for simple linked list demonstrations. 5. CONCLUSIONS : We believe 
that the techniques described above support the study of algorithms and data structures in a graphical 
and relatively language--independent fashion; the use of flowchart displays, for example, allows students 
to focus on the concepts of algorithms without having to deal simultaneously with the syntax of a specific 
programming language. We expect that these techniques will thus enable students to visualize and grasp 
concepts more readily; students often find it necessary to re-read narrative descriptions of dynamic 
processes a number of times; we expect that the PV materials will help them understand these processes 
with fewer re-readings. Instructors who are using this approach or similar approaches are encouraged 
to share their demonstrations and graphic routines with each other and with the author. Figure 8. Singly-linked 
list prior to insertion of new element. 521 6. REFERENCES <RefA>Augenstein, Moshe, and Yedidyah Langsam (1986), 
"Graphic Displays d Data Structures on the IBM PC', ACMSIC~EBulIe~n, 18: 73-81. Baecker, R. and D. Sherman 
(1981). So.r~hg Out Sortlns; 30-minute color sound film, Dynamic Graphics ProJect, Computer Systems Research 
Institute, University of Toronto. (Excerpted in SIC~YRAPH Video R e w'e ~. .7, 1983.) Brown, Gretchen 
P., Richard T. Carling, Christopher F. Herot, David A. Kramlich and Paul Souza (1985), "Program Visualization: 
Graphical Support for Software Development', Computer, 18: 27-55. Myers, Brad A. (1986), "Visual Programming, 
Programming by Example, and Program Visualization: A Taxonomy', [~-oc. CIII~?6 Human Facto, r~ in Comput/~,~r~tems 
(Boston), ACM, New York, 59-66. Raeder, Georg (1985), "A Survey of Current Graphical Programming Techniques', 
Computer, 18: 11-26. Rambally, Gerard K. (1985), "Real-time Graphical Representations of Linked Data 
Structures', ACM SIG~E Bullet~n, 17: 41-48. Scandura, Joseph M. (1987), "A Cognitive Approach to Software 
Development: The PRODOC Environment and Associated Methodology', Journal of Pascal. Ada. Nlodula-2, 
in press. (Earlier version in ~ocee~s ~st Internatlbnal Conference on Ada PrograrnnTing Lans"uage Apphbatlbns 
for the NASA Space Sta&#38;bn. University of Houston-Clear Lake and Johnson Space Center: June 2- 5. 
1986.)</RefA>   
			

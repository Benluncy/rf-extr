
 A New CRT-RSA Algorithm Resistant to Powerful Fault Attacks Nevine Ebeid Rob Lambert Certicom Corp. 
Certicom Corp. a Subsidiary of Research In Motion Limited a Subsidiary of Research In Motion Limited 
Mississauga, Ontario, Canada Mississauga, Ontario, Canada nebeid@certicom.com rlambert@certicom.com 
ABSTRACT CRT-RSA is widely deployed in embedded devices to ac­celerate the RSA signature generation by 
about four times compared to regular RSA. However, since the Bellcore at­tack of 1996, research into 
securing CRT-RSA has remained active as countermeasures are themselves attacked. In this paper, we propose 
a new countermeasure designed with a powerful attacker in mind. The attacker may inject multiple precise/random 
faults and may alter the program counter to skip one or more instructions. The strength of our countermeasure 
derives from combining signature validation with signature unblinding modulo n. Keywords: RSA, Chinese 
Remainder Theorem, Fault in­jection attacks, Countermeasures. 1. INTRODUCTION Securing the CRT-RSA signature 
scheme against fault at­tacks (FA) has attracted the attention of several researchers since the Bellcore 
attack was introduced in 1996 by Boneh et al. [8]. In general, fault attacks aim to produce an erroneous 
result in one or more steps of a cryptographic computation. Collecting partially erroneous results or 
faulty and correct results from the same computation can help the attacker deduce secret information 
and possibly break the system. The immediate objective of inducing a fault may be to change some bit 
values in memory locations or internal registers, and may also involve changing the values of the program 
counter or stack pointer and, by this means, skipping some or all of the remaining steps in the algorithm. 
The fault may also attempt to toggle the result of a conditional check [20]. There are various ways to 
induce faults in a device while per­forming a cryptographic application. Arbitrary faults may be injected 
by varying temperature, the external clock, the supply voltage, or more accurately targeted faults may 
be injected with laser, X-ray or ion beams [4]. Permission to make digital or hard copies of all or part 
of this work for personal or classroom use is granted without fee provided that copies are not made or 
distributed for pro.t or commercial advantage and that copies bear this notice and the full citation 
on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires 
prior speci.c permission and/or a fee. WESS 10, October 24, 2010, Scottsdale, AZ,USA The CRT-RSA signature 
algorithm has become a well-known target of these attacks. Consisting of two lengthy exponenti­ations 
modulo each of the secret factors of the RSA modulus, it is relatively easy to induce a fault in just 
one of these two operations of CRT-RSA. Collecting a single faulty signa­ture, an attacker may factor 
the modulus, sidestepping this computationally hard problem on which the mathematical security of the 
RSA scheme is based. Since the publication of this attack, several countermeasures have been proposed 
and many attacks on these countermea­sures have also been developed. Countermeasures for CRT-RSA often 
avoid the use of e, which is a public component of the RSA public key, since it is not one of the personalization 
parameters p, q, dp, dq and q -1 mod p. However, some of theses countermeasures require d, the private 
exponent, as part of a precomputation phase, which is also not a person­alization parameter [5, 6, 21]. 
Conventionally, e is de.ned to be a relatively small integer, allowing the signature ver­i.cation to 
be more e.cient than signature generation. In this paper, we investigate what is possible if e is available. 
We present a new approach which, employing e, blinds the whole CRT-RSA computation, and which includes 
an im­plicit blinded signature validation modulo n in the unblind­ing computation. In Sect. 2, we provide 
a brief overview of attacks and the previously proposed countermeasures, we also discuss their vulnerability 
to fault attacks under our attack model. In Sect. 3, we present our new CRT-RSA computation, inter­woven 
with countermeasures against fault analysis attacks. The security and performance evaluation of the proposed 
algorithm is presented in Sect. 4 and Sect. 5. Finally, we provide our conclusions in Sect. 6. 2. FAULT 
ATTACKS ON CRT-RSA AND PRO-POSED COUNTERMEASURES In this section, we review the Bellcore attack on CRT-RSA 
and the various countermeasures that have been proposed. 2.1 CRT-RSA signature scheme In the RSA signature 
scheme [25], party A owns a long-term public key (n, e) and a corresponding private key (p, q, d), where 
n = pq; p and q are large primes, e is the public exponent;1 <e<f(n)=(p - 1)(q - 1), gcd(e, f(n)) = 1 
and d = e -1 mod f(n) is the private exponent. To sign a message m, or rather a hashed and/or padded 
Copyright 2010ACM 978-1-4503-0078-0 ...$10.00. version thereof, A calculates the signature s = m d mod 
n and sends it to B who, using A s public key, can con.rm A s signature on m by verifying that m = s 
e mod n. An approximately four times more e.cient computation was suggested by Quisquater and Couvreur 
[24] using the Chi­nese Remainder Theorem (CRT), where A performs the fol­ where iq mod p. Here (3) is 
referred to as Garner s lowing steps to compute s sp = m mod p dp , (1) sq = m mod q dq , (2) s = CRT(sp, 
sq) , = sq + q · (iq · (sp - sq) mod p) , (3) -1 = q CRT recombination [15].  2.2 The Bellcore Attack 
Bellcore researchers [8] have presented a fault attack on CRT-RSA as follows: A fault is injected in 
the device dur­ing the computation of (1) (equivalently (2)), resulting in a faulty value sp (sq), and 
hence a faulty signature s. Now we have spe = m (mod p) , sqe = m (mod q) , (4) gcd(s e - m, n)= q, thus 
factoring n and solving the computationally hard prob­lem underlying RSA. This attack is also referred 
to as the gcd attack [21].  2.3 Previous Countermeasures Several countermeasures to the gcd attack have 
been pro­posed (we refer the reader to [20] for a chronological overview). The earlier countermeasures 
were based on inserting one or more conditional checks in the algorithm to verify the in­tegrity of the 
values [2, 10, 17, 18, 27]. Yen et al. [32] noted that fault injection on status regis­ter .ags can bypass 
conditional checks in countermeasures. They hence introduced the concept of infective computation which 
aims at infecting the resulting signature, i.e., render­ing it unusable for the attacker in the case 
where a fault is in­jected in one of the two exponentiations. Several subsequent countermeasures [5, 
6, 11] employed infective computation. Kim and Quisquater [20] injected a second fault with the intent 
of skipping the .nal step of the algorithm where the signature is validated and were thereby able to 
retrieve the faulty signature and perform a Bellcore attack. Therefore, they proposed keeping the signature 
blinded until it is vali­dated and perform the validation in a way such that it infects the signature 
if it was faulty. Another technique was proposed by Boscher, Naciri and Prou. [10] and later slightly 
modi.ed by Boscher, Hand­schuh and Trichina [9]. It is based on the checks performed after the right-to-left 
exponentiation is executed and a simi­lar check after the CRT recombination of the signature com­ponents. 
The checks ensure that the contents of the working registers were not modi.ed during the exponentiation 
or the recombination computations. In Sect.4.4, we will review in more detail the previous coun­termeasures 
in light of our attack model and show how they can be compromised.  3. NEW COUNTERMEASURE TO FAULT ATTACKS 
ON CRT-RSA In this section we present our new FA resistant CRT-RSA algorithm and discuss its correctness. 
Algorithm 1. Blinded CRT-RSA Algorithm Input Private parameters: p, q, dp,dq,iq = q -1 mod p, public 
parameters: n, e, message (padded and hashed): m. Output Signature s. 1. Select random values .p,.q,r1,r2,t 
and a at the be­ginning or right when needed. 2. d.p . dp + .p(p - 1) // mask the private exponents 
 3. d.q . dq + .q(q - 1) 4. p * . r1 p // blind the moduli 5. q * . r2 q 6. bp * . t ae mod p * // 
message blinding multipliers 7. bq * . t ae mod q * 8. mp * . m mod p * // message components 9. mq 
* . m mod q *  * )(d.p -1) * 10. s p * . ((mp * bp mp * ) mod p dp a(1-e) // = mp t (mod p) * )(d.-1) 
* 11. s q * . ((mq * bq q mq * ) mod q dq a(1-e)  // = mq t (mod q) 12. s . ( sq * + q ( iq ( sp * 
- s q * ) mod p * )) mod n  d a(1-e) // = m t (mod n) 13. b . (bq * + q ( iq (bp * - bq * ) mod p * 
)) mod n // = t ae (mod n) trunc((mb + a(e-1) - ( sb)e) mod n) 14. s . mod n st a(e-1) = m d // = (mod 
n) st 15. Return(s) The values .p, .q, r1, r2, t and a are random values gen­erated by the algorithm. 
Suggestions for the sizes of these values are given in Sect. 5. trunc is the truncation function as discussed 
below. In the following, we discuss the correctness and purpose of each component of our countermeasure. 
The resistance of the algorithm to fault attacks is assessed in the next section. The RSA moduli p and 
q are blinded by multiplying them by r1 and r2, respectively. This is similar to the blinding in [5, 
6, 11, 18, 20, 21]); however, a novelty is that we do not require that r1 and r2 be co-prime, and we 
do not need to compute their Euler totient values. This is based on the following two facts: A value 
v reduced modulo p * is congruent to vp = v mod p : Let vp = v mod p = v - k1p ; vp <p and vp * = * ** 
v mod p = v - k2p ; vp * <p for some integers k1 and k2. Reducing vp * modulo p, we have vp = vp * mod 
p = vp * - k3p = v - k2p * - k3p = v - k4p; vp <p for some integers k3 and k4. From the division algorithm, 
we have k1 = k4 and vp = vp. Therefore, vp * = vp (mod p) . (5) In a residue number system, a value v 
mod n, where n = pq, can also be expressed by its residues (v mod p, v mod q), when p and q are co-prime. 
For correctness of the RSA-CRT signature, we require a value in residue form (sp,sq), where: dp dq sp 
= m mod p, and sq = m mod q. We cal­culate instead the signature components modulo the randomized moduli 
assuming the message blinding and the exponent randomization, which will be discussed subsequently, were 
removed: sp * = dp dq m mod p * , and sq * = m mod q * . From (5), sp * = sp (mod p), and similarly sq 
* = sq (mod q). We form our combined signature in a Garner-like form: . ¯ s = sq * + q (q -1 mod p)(sp 
* - sq * ) mod p * modn, (6) where, notably, we do not need to compute q *-1 as in [11, 20, 21]. Using 
(5), .rst modulo q, we have s = sq * = sq (mod q). Similarly, modulo p we have: s = (sq * mod p) +(q 
mod p)(q -1 mod p)[sp - (sq * mod p)] (mod p) , = (sq * mod p)+[sp - (sq * mod p)] (mod p) , = sp (mod 
p) . Since a .nal reduction mod n is performed, and because s is correct modulo both p and q, then computing 
(6) is equivalent to computing m d mod n. Note that r1 and r2 are not used as moduli for aux­iliary checks 
(as they are in [2, 5, 6, 11, 18, 20, 21]). Having no restrictions on the values of r1 and r2 conve­niently 
enables choosing new ones for every signature and requires no precomputation. Blinding the RSA moduli 
in this manner helps prevent side-channel at­tacks (such as the di.erential power analysis (DPA) attack 
in [13]) and also timing attacks (as in [26]) that exploit the modular reduction modulo p and q. It also 
protects against the injection of chosen bases designed to aid an attacker in discovering secret exponents. 
 The private exponent dp is randomized by adding a random multiple of p - 1 to obtain dp as in Step 2 
[2]. Similarly, dq is obtained from dq. This randomization is useful in thwarting safe-error fault attacks 
[30]. The random multiplier .p and .q are randomly chosen for every signature generation. Note that 
.rst-order DPA attacks (see e.g., ZEMD in [23]), where an attacker guesses the exponent bits one at a 
time and computes intermediate values of the ex­ponentiation algorithm, do not apply to the CRT-RSA algorithm 
since p and q are not available to the attacker for computing those intermediate values [13].  Antipa 
s inversionless message blinding [1] is employed to blind the two main exponentiations to prevent tim­ 
 dp ing attacks [26]: Let sp = m mod p be the value required to be computed. A random value r of ade­quate 
size is chosen, r e mod p is computed, then s p = (r e m)d-s m s mod p is the blinded signature compo­ 
1-es d nent; s p = rm (mod p). Then s p is unblinded by computing s p r es-1 mod p. The public exponent 
e is used in this blinding; this is generally acceptable since it was suggested in [7] that the device 
veri.es the signature before releasing it by checking whether s e mod n = ? m. On the other hand, the 
full private exponent d = e -1 mod (p - 1)(q - 1) is not required as was the case in other countermeasures 
[5, 6, 21], where it was used in a precomputation phase. It is the use of e that allows our combination 
of signature veri.cation and unblinding on the signature modulo n; this work could be interpreted as 
examining the advan­tages of using e. For example, in the personalization procedure of smart cards in 
a mass-production, if e is a constant small value, as is usually the case, it may be made available to 
every card without being part of the personalization parameters. In Algorithm 1, where we have set s 
= 1 and r = ta , this message blinding serves the purpose of keeping the signature components, as well 
as the recombined sig­nature, blinded until it is validated according to the concept proposed by Kim-Quisquater 
[20, 21] where they employed di.erent blinding methods to prevent attacks that attempt to skip the validation 
steps of the algorithm [20]. However, the Kim-Quisquater vali­dation values, though computed after the 
CRT recom­bination, in essence validate each signature component separately since they are computed modulo 
the aux­iliary moduli that are used to blind p and q; whereas our new validation technique is applied 
directly to the recombined signature using a recombined validation value as we discuss below. We show 
in Sect.4.4 how that separate signature validation is vulnerable under our attack model. To unblind the 
recombined signature s , we need to a(e-1) compute s = . stIn order to make this unblind­ ing conditional 
on the validity of s, the exponent of t is expressed as f(m, e, s, t, a) such that this function evaluates 
to a(e - 1) only if s = m d (mod n) with overwhelming probability. In Step 14, we have f(m, e, sb)e, 
s, t, a) = trunc((mb+a(e-1)-( )mod n) where, from Step 13, b = t ae (mod n) and trunc() is a function 
that truncates its input to a bit length no less than that of a(e - 1). If no fault occurs, then the 
following holds da(1-e) ae ( sb)e = (mt t )e (mod n) , = (m d t a)e (mod n) , = mb (mod n) . We recommend 
additional measures to our algorithm. For example, we can avoid processing the secret values p, q, dp, 
dq, iq explicitly. Instead, they may be input to the algorithm as randomly split components that are 
not combined until each component is processed separately in a computation. For example, p may be represented 
as p1 - p2 and Step 4 carried out as p * . r1p1 p * . p * - r1p2 Since all secret components have a random 
representation in every run, a powerful attacker cannot employ bit-set-reset faults (cf. Sect.4.1) to 
mount safe-error attacks. Further countermeasures that seal side-channel information can be integrated. 
Exponentiation protected against side­channel leakage and fault injection should be employed. Ran­domization 
of the computation sequence and/or location is also a valuable additional measure.  4. SECURITY EVALUATION 
In this section we provide an overview of previous attack models and present ours. In light of our attack 
model, we assess the resistance of previous countermeasures then that of Algorithm 1 to various fault 
attacks. 4.1 Blömer s Attack Models In [6], Bl¨ omer et al. gave a collection of attack models, iden­tifying 
di.erent parameters that de.ne a model: control on the fault location,  control on the fault timing, 
 control on the number of bits a.ected,  the fault type:  stuck at fault,  bit .ip fault,  bit set 
and reset fault,  random fault.   According to the authors, the strongest attack model is the bit-set-reset 
(bsr) type where the attacker has complete control over the fault location targeting an exact bit in 
an exact value and the timing injecting the fault at a precise time while running the device on his clock. 
They mention that this is only plausible if the device, e.g.,a smartcard, is not equipped with hardware 
countermeasures such as randomized clocks, memory encryption/decryption schemes, and randomized address 
scrambling. uller Aum¨et al. [2] also mentioned that current smartcard ICs are equipped with sensors 
and .lters to detect variations in the supply voltage that are outside the tolerable range to pre­vent 
voltage spike attacks, which they could switch o. in their lab experiment in order to test the validity 
of their software countermeasure. In the countermeasure presented by Bl¨ omer et al., the val­idation 
of the signature was performed via values reduced modulo small primes ti,i =1, 2. In their security analysis, 
the random errors yielded higher attack success probabil­ity since the faulty values were in the range 
[0,ti), whereas the stronger attacks, such as the bit or byte errors, yielded lower success probabilities 
since the faulty values were more restricted. However, in his cryptanalysis using a byte error example, 
Wagner [29] made use of the predictability of the error pattern since the errors can be enumerated. Therefore, 
for every attack model, one should investigate the weakest point of the countermeasure and assess its 
resistance to a fault at that point. 4.2 Wagner s Framework The framework introduced by Wagner in [29] 
is useful in assessing the security of an algorithm. He suggests modeling the state of the device si 
as the contents of the registers and memory, the set of possible states is S. Each step of the algorithm 
is represented as a relation on S × S. The algorithm is then viewed as a sequence of steps: (x, k) = 
s0 s1 ··· sn = (y) , where x represents the collection of inputs, k that of secrets and y that of outputs. 
The attack model de.nes a family of possible faults F as a relation i on S × S. A fault attack is speci.ed 
by the tuple (x, 1,..., n). An algorithm is secure, if for all the tuples that could be chosen, an attacker 
cannot learn y or a part thereof. The faulty computation is represented as (x, k) = s0 s1 1 s1 s2 2 s2 
··· sn n sn = (y) . 4.3 Our Attack Model In our model, we assume that the attacker has full control 
over the timing and the location of the fault, i.e., can tar­get a speci.c bit or more in a speci.c variable 
at a speci.c step of the algorithm or can opt to inject a random fault to completely change a value. 
F comprises the following fault types: multiple bit-set-reset (bsr) faults in one or multiple values, 
in one or multiple steps. We assume that when multiple faults are injected in the same execution step 
and in the same value, they can alter only a small portion of that value; for example a byte or a word 
thereof,  skipping a single or multiple instructions by possibly injecting a fault in the program counter 
(PC) register,  changing the outcome of a conditional check by inject­ing a fault in the status register. 
  This model depicts a powerful attacker injecting faults in a device where hardware countermeasures 
are not perfect. However, we must assume that the CRT-RSA parameters p, q, dp,dq,iq are protected and 
are error-free (see also Sect. 4.5). 4.4 Previous Countermeasures Viewed Under Our Model The most recently 
proposed countermeasures were Kim-Quis­quater s [20, 21] and Boscher-Handschuh-Trichina s (BHT) [9]. 
The BHT countermeasure modi.ed the initialization of Bo­scher, Naciri and Prou. s (BNP) [10] exponentiation 
algo­rithm in order to render it resistant to DPA attacks. In fact, the BNP exponentiation was based 
on the right-to-left bi­nary algorithm which originally employed two working reg­isters, performing a 
squaring operation in every iteration and a multiplication only if the exponent bit is 1. An ex­ponentiation 
algorithm with uniform iterations is required in order to resist simple side-channel attacks [22]. Hence, 
a third working register was added in the BNP exponen­tiation and the multiplication was performed in 
every it­eration. The time performance was then the same as the Montgomery ladder [19] or the square-and-multiply 
always [12] algorithms but as the authors mention, was 33% faster than the slower Fumaroli-Vigilant algorithm 
[14] (which em­ploys an additional squaring). The relation maintained between the three working regis­ters 
is used at the end to verify that their contents have not been modi.ed. The authors mention that If the 
loop is attacked such that it ends before all the bits were pro­cessed or if the exponent k is corrupted, 
this will not be detected, so additional checksums over the inputs should be computed. In the same way, 
even if the exponent is veri.ed to be unchanged at the beginning of the exponentiation, a bit-set-reset 
fault that toggles an exponent bit during the course of the exponentiation would go undetected just as 
would a modi.ed input exponent. Merely the output rela­tion between the registers is checked, but this 
relation holds for any exponent value if the register contents are unaltered. The three values of the 
exponentiation modulo p are CRT­recombined with their counterparts modulo q, then the same check is performed 
on the recombined values. The coun­termeasure is therefore vulnerable to exponent bit-set-reset faults 
i.e., a faulty signature component would be unde­tected, since the relation between the three recombined 
val­ues would hold without any dependence on the exponents used to compute its components. We now discuss 
Kim-Quisquater s modi.cation of Ciet-Joye s scheme [11, 20], where the authors introduced the impor­tance 
of validating a blinded signature. In Step 1, the sig­nature and validation component are computed as: 
** dq mod f(r2) sp = (a+ m dp ) mod p, s2 = (a+ m ) mod r2 , ** dp mod f(r1) sq = (a+ m dq ) mod q, s1 
= (a+ m ) mod r1 , where r1 and r2 are relatively small coprime integers, p * = r1p, q * = r2q and a 
is a random integer in Z* r1r2n. The recombined signature s * is validated by computing: c1 =(s * - s1 
+ 1) mod r1 ,c2 =(s * - s2 + 1) mod r2 . In the case where no fault occurs, we have c1 = c2 =1 and the 
signature is correctly unblinded. Ciet and Joye had stated The order of the computation is very important: 
sp* , * ** s2, sq and s1. If the computation is carried out as sp, s1, sq and s2 then a long-lived fault 
on m before the computation of sq * (and after s1) would go undetected (i.e., c1 = c2 = 1) ; using the 
unblinded signature, a gcd attack would yield q. We argue that even with the recommended ordering of 
operations, an attack can be mounted: If the attacker injects a precise fault in m as it is read for 
the computation of the signature component sp* , and again injects the same fault before the computation 
of its validation component s1, then c1 would evaluate to 1 and the gcd attack is applicable. The same 
argument can be carried to Kim-Quisquater s scheme in [21] and also to Bl¨ omer-Otto s improved BOS 
[6] scheme in [5]. In general, this attack is expected to apply to schemes that rely on validating the 
signature components modulo p and q separately, where the validation components are a function of m. 
Therefore, our new validation technique is performed instead on the recombined signature. On a side note, 
we would like to draw the attention to a potential safe-error attack on Kim-Quisquater s exponenti­ation 
algorithm in [21], where the authors were improving Fumaroli-Vigilant s exponentiation algorithm [14] 
due to its vulnerability to fault attacks when used in the CRT-RSA computation. Yet in the improved algorithm 
[21], the accu­mulator is multiplied by a value adi where di is the current exponent bit. To determine 
the jth bit, an attacker may toggle a precise bit in a0, for example, at the beginning of the jth iteration 
and toggle it again before the following it­eration and observe whether this toggling had a.ected the 
results; if there is no e.ect then the attacker concludes that dj = 1 since a0 was not used in this iteration. 
(Note that bit toggling is possible in our model even if we assume that the attacker can only set/reset 
a bit, it may just require repeat­ing the attack to discover the modi.ed bit s original value before 
knowing whether to set it or reset it.) This attack is feasible since the values a0 and a1 are constant 
and do not evolve with the computation as in the Montgomery ladder method [16] cited by the authors. 
Another possible attack scenario for a powerful attacker re­sults from expecting constant values as the 
outcome of a validation step, such as the values c1 = c2 = 1 as men­tioned above or some values being 
0, as in [28], where the conditional checks can be converted into infective values, as the author pointed 
out. We assume that, if small locations are used to store these values, the attacker may be able to set 
these locations in RAM to their required values. This certainly requires a more controlled attack than 
setting the status bits in the control register to toggle the outcome of conditional checks. 4.5 Security 
Assessment of Algorithm 1 As mentioned previously, the strength of Algorithm 1 is that the signature 
validation is not performed modulo p and q, or separately modulo their blinding values r1 and r2 as in 
[11, 20, 21], but instead modulo n, and after the signature has been CRT-recombined but before the signature 
has been unblinded. Moreover, the validation computation is infective in nature and also does not yield 
a constant value. We should .rst establish that the CRT-RSA parameters p, q, dp,dq,iq are error-free; 
for example, using CRC tech­niques as was proposed by Ciet-Joye [11]. Another possible protective measure 
is to provide the parameter n, since it would then be computationally infeasible for an attacker to modify 
p, for example, and modify n accordingly without knowing q. Otherwise, in this case, if an attacker can 
change p into p and n is not provided, but is instead computed in­ternally as n = pq, then a gcd attack 
is applicable using the original n as in (4). The question now is how can an attacker inject a fault 
in a computation modulo one of the moduli only and successfully bypass the .nal validation so that the 
gcd attack can be mounted. In order to achieve that goal, the attacker may choose to inject a fault in 
variables and/or computations modulo p, and not those modulo q, or vice-versa, then inject one or more 
subsequent faults in order to counteract and/or bypass the blinding of these values. He may target dp, 
mp * , s p * or their blinding values/computations. We .rst focus on injected faults that alter a value 
in a reg­ister or memory location, then we discuss faults that alter the value of the program counter. 
We are not concerned herein with faults that alter the status register values since Algorithm 1 does 
not rely on conditional checks. Following Wagner s framework notation as recalled in Sect. 4.2 and emphasizing 
only the a.ected steps of the computa­tion, we examine the following scenario: An attacker injects a 
fault in dp such that dp = dp (mod p - 1). Note that if an attacker knows how to modify dp into dp = 
dp (mod p - 1), then the attacker also knows p and has no need for a faulty signature. On the other hand, 
injecting a random fault that completely modi.es dp will succeed with probability around 1/p. Moreover, 
if the attacker succeeds in making dp = dp (mod p - 1), then the scheme is not a.ected, and there will 
be no fault in sp * that can enable a gcd attack. where bt and ß mb - mb mod n. Can the at­ dp dp = dp 
(mod p - 1) , s p * = s p * (mod p) , s = m t d a(1-e) (mod n) , ( sb)e = mb (mod n) , s = s t trunc(mb-mb)+a(e-1)) 
mod n) (mod n) , = m d t ß (mod n) , = m t dq ß (mod q) , = sq * (mod q) , ae == tacker, by injecting 
other precise faults, modify any of the values of the algorithm to reduce ß to 0? This would require 
modifying m in Step 14 to a precise value that the attacker cannot compute without knowing b or m. More 
generally, is it possible to inject a combination of precise faults that would result in s = sp while 
still s = sq? As another illus­tration, an attacker can apply the same attack as the one we demonstrated 
on Kim-Quisquater s [20, 21] in 4.4: The attacker can inject a fault in mp * in 8, which would result 
in the following sequence mp * 1 mp * = mp (mod p) , s p * = s p * (mod p) , d a(1-e) s = mt (mod n) 
, ( sb)e = mb (mod n) , s = m d t ß (mod n) , dq ß = mt (mod q) , = sq * (mod q) , which leaves the attacker 
in the same position, needing to modify m in Step 14 to an unknown value. Attacks on sp * directly result 
in similar conclusions; the attacker has the power to alter any variables but has no knowledge of their 
expected values. Our validation is performed on the recombined signature itself, not on each modular 
component, as in the previous countermeasures [2, 5, 6, 11, 18, 20, 21]. This yields a new strength: 
when our infective validation fails, it infects both signature components. If the attacker opts to inject 
a random fault, then the small­est candidate value to change is the exponent in Step 14 which is the 
outcome of the truncation function. The bit length of that outcome, then, is a security parameter that 
depends on the bit length of e and a. Speci.cally, a is chosen based on a compromise between performance 
and security (see bit-length suggestions in Sect. 5). Can the attacker modify the sequence of the algorithm 
in or­der to avoid countermeasure instructions? For example, can the attacker skip the multiplications 
instructions mp * bp * mod p * and mq * bq * mod q * that blind the message and then skip the unblinding 
multiplication in Step 14? We assume this is possible. However, with careful implementation, it can be 
ensured that the result would be an unpredictable value: To illustrate this design concept, let registers 
A and B hold the values mp * and bp * , respectively. Then, register A should not be the target of the 
multiplication, otherwise, if it is skipped, then it would hold the same value without apply­ing the 
blinding. If we let the target register be C, we should make certain that C contains no values of sensitive 
nature that would aid the attacker. Along the same lines, we should ensure that the .nal register/location 
from which the signa­ture is copied to the output bu.er does not contain any sen­sitive values produced 
during the execution of the entire al­gorithm. We must also assume here that register addressing operations 
are su.ciently protected to render the attacker unable to precisely control which register locations 
are being manipulated.  5. PERFORMANCE EVALUATION Regarding the time requirement of Algorithm 1, as 
was men­tioned in Sect. 3, r1 and r2 are not chosen as prime or even coprime integers [5, 6, 11, 18, 
20, 21]); hence, there is no requirement to compute their totient values as in the cited countermeasures 
that include a random multiplier of p and q. Moreover, there is no inversion required modulo the RSA 
moduli or their multiplier(s) as was the case in several coun­termeasures [5, 6, 11, 21, 28]. Therefore, 
there is no need for a precomputation phase. Nevertheless, Steps 2 to 7 can be performed before the next 
message to be signed is available. The following are the overhead computations compared to an unprotected 
CRT-RSA scheme, where |a| denotes the bit length of a value a (Suggested bit lengths for random values 
are typical for 1024-bit RSA; they are large enough in order to thwart multiple attacker attempts without 
much a.ecting the time and memory requirements): 1. A general overhead of O(|ri|2) where |ri| = max(|r1|, 
|r2|) in all modular multiplications modulo the prime mod­ uli, as a result of blinding; r1 and r2 may 
be 32 bits long (e.g., [17, 27]). 2. An overhead of O(|.||ri|2) where |.| = max(|.p|, |.q|) in the two 
main exponentiations resulting from the ex­ponent blinding; .p and .q may be 32 bits long. 3. Two exponentiations 
modulo p * and q * , respectively, where the exponent is ae and t is a random value of the same bit length 
as p and q. For example, if e =216 +1 then a may be 15 bits long. Note that if we eliminate the assumption 
that an attacker can directly set the value of the validation exponent in Step 14, then we can set a 
= 1. The validation exponent would then always be expected to have the value e - 1. 4. Four modular 
multiplications in Steps 10 and 11(which include the overhead mentioned in item 1 above). 5. A CRT recombination 
in Step 13. 6. A multiplication and an exponentiation modulo n in Step 14 where the exponent is of bit 
length |ae|.  The blinding overhead, including the cost of randomness generation, is typical for all 
protected CRT-RSA implemen­tations. In fact, the message blinding technique we adapted [1] is more advantageous 
since it requires no inversion as in other countermeasures [14, 21]. The main new overhead we introduce 
is in the implicit veri.cation in Step 14. For 216 example, for a 1024-bit n, e = + 1 and a 15-bit a, 
this overhead is roughly 12.5% of the unprotected CRT exponen­tiations. For a 2048-bit n, the overhead 
is reduced to 6.25%, since e is proportionally smaller. As for the space requirement, the extra values 
that would need to be stored are bq and bp which can be later replaced by b. Other values to be stored 
are t and a which are typically used in countermeasures that blind the message [20, 21]. Also the extension 
of the prime moduli should be taken into account in the extra storage needed, if employed.  6. CONCLUSION 
In this paper, we have presented a CRT-RSA countermea­sure designed to resist a powerful attacker who 
can inject bit-set-reset faults in the same execution step or across dif­ferent steps, control the algorithm 
clocking and target spe­ci.c small locations. We have also assumed that the attacker can skip one or 
more intermediate instructions and can alter the result of conditional checks. We have presented and 
analysed the performance and secu­rity of a new CRT-RSA countermeasure: The scheme allows easy randomization 
for each signa­ture, since there are no requirements on the random values used to blind the moduli, the 
exponents or the message.  The blinding computation does not require precompu­tation.  The CRT recombination 
does not require the compu­tation of q *-1 , i.e., the inverse of one of the blinded moduli.  Unlike 
previous countermeasures, the validation of the blinded signature is implicitly performed modulo n af­ter 
the CRT recombination rather than prior to it. In case the validation fails, the entire blinded signature 
is infected and the unblinding yields a random value modulo both p and q. Hence, it is infeasible for 
a powerful attacker to precisely inject one or more faults aiming at modifying one signature component 
without a.ecting the other one and mounting a gcd attack.  References <RefA>[1] A. Antipa. Method and apparatus 
for exponentia­tion in an RSA cryptosystem. United States Patent #7,177,423, February 13, 2007. [2] C. 
Aum¨uller, P. Bier, W. Fischer, P. Hofreiter, and J.- P. Seifert. Fault attacks on RSA with CRT: Concrete 
results and practical countermeasures. In Cryptographic Hardware and Embedded Systems CHES 02, volume 
2523 of LNCS, pages 260 275. Springer-Verlag, 2002. [3] H. Bar-el, H. Choukri, D. N. M. Tunstall, and 
C. Whe­lan. The sorcerer s apprentice guide to fault attacks. In Workshop on Fault Diagnosis and Tolerance 
in Cryp­tography -FDTC 04 in association with the Interna­tional Conference on Dependable Systems and 
Networks -DSN 04, pages 330 342, 2004. [4] H. Bar-el, H. Choukri, D. N. M. Tunstall, and C. Whe­lan. 
The sorcerer s apprentice guide to fault attacks. Proceedings of the IEEE, 94(2):370 382, Feb. 2006. 
An earlier version of this paper appeared in [3]. Also avail­able at http://eprint.iacr.org/2004/100.pdf. 
[5] J. Bl¨and M. Otto. Wagner s attack on a omer se­cure CRT-RSA algorithm reconsidered. In Work­shop 
on Fault Diagnosis and Tolerance in Cryptogra­phy FDTC 06, volume 4236 of LNCS, pages 13 23. Springer-Verlag, 
2006. [6] J. Bl¨ A CRT­omer, M. Otto, and J.-P. Seifert. new RSA algorithm secure against Bellcore attacks. 
In ACM Conference on Computer and Communications Security CCS 03, pages 311 320. ACM Press, 2003. [7] 
D. Boneh, R. A. DeMillo, and R. J. Lipton. On the importance of eliminating errors in cryp­tographic 
computations. In Advances in Cryptol­ogy EUROCRYPT 97, volume 1233, pages 37 51. Springer-Verlag, 1997. 
This paper appeared after a Bellcore press release in 1996, for ex­ample see http://findarticles.com/p/articles/mi_ 
m0EIN/is_1996_Sept_26/ai_18720539/pg_1. [8] D. Boneh, R. A. DeMillo, and R. J. Lipton. On the im­portance 
of eliminating errors in cryptographic compu­tations. Journal of Cryptology, 14:101 119, 2001. This is 
an expanded version of an earlier paper that appeared in [7]. [9] A. Boscher, H. Handschuh, and E. Trichina. 
Blinded fault resistant exponentiation revisited. In Workshop on Fault Diagnosis and Tolerance in Cryptography 
 FDTC 09, pages 3 9. IEEE Computer Society, 2009. [10] A. Boscher, R. Naciri, and E. Prou.. CRT RSA al­gorithm 
protected against fault attacks. In Informa­tion Security Theory and Practices. Smart Cards, Mo­bile 
and Ubiquitous Computing Systems WISTP 07, volume 4462 of LNCS, pages 229 243. Springer-Verlag, 2007. 
[11] M. Ciet and M. Joye. Practical fault countermeasures for Chinese remaindering based RSA. In Workshop 
on Fault Diagnosis and Tolerance in Cryptography FDTC 05, pages 124 131, 2005. [12] J.-S. Coron. Resistance 
against di.erential power anal­ysis for elliptic curve cryptosystems. In Cryptographic Hardware and Embedded 
Systems CHES 99, volume 1717 of LNCS, pages 292 302. Springer-Verlag, 1999. [13] B. den Boer, K. Lemke, 
and G. Wicke. A DPA attack against the modular reduction within a CRT implemen­tation of RSA. In Cryptographic 
Hardware and Embed­ded Systems CHES 02, volume 2523 of LNCS, pages 228 243. Springer-Verlag, 2002. [14] 
G. Fumaroli and D. Vigilant. Blinded fault resistant exponentiation. In Workshop on Fault Diagnosis and 
Tolerance in Cryptography FDTC 06, volume 4236 of LNCS, pages 62 70. Springer-Verlag, 2006. [15] H. 
L. Garner. The residue number system. IRE Trans­actions on Electronic Computers, 8(6):140 147, 1959. 
[16] C. Giraud. Fault resistant RSA implementation. In Workshop on Fault Diagnosis and Tolerance in Cryp­tography 
 FDTC 05, pages 142 151, 2005. [17] C. Giraud. An RSA implementation resistant to fault attacks and to 
simple power analysis. IEEE Transac­tions on Computers, 55(9):1116 1120, 2006. An earlier version appeared 
in [16]. [18] M. Joye, P. Paillier, and S.-M. Yen. Secure evaluation of modular functions. In Cryptology 
and Network Security CNS 01, pages 227 229, 2001. [19] M. Joye and S.-M. Yen. The Montgomery powering 
ladder. In Cryptographic Hardware and Embedded Sys­tems CHES 02, volume 2523 of LNCS, pages 291 302. 
Springer-Verlag, 2002. [20] C. H. Kim and J.-J. Quisquater. Fault attacks for CRT based RSA: New attacks, 
new results, and new coun­termeasures. In Information Security Theory and Prac­tices. Smart Cards, Mobile 
and Ubiquitous Computing Systems WISTP 07, volume 4462 of LNCS, pages 215 228. Springer-Verlag, 2007. 
[21] C. H. Kim and J.-J. Quisquater. How can we overcome both side channel analysis and fault attacks 
on RSA-CRT? In Workshop on Fault Diagnosis and Tolerance in Cryptography FDTC 07, pages 21 29. IEEE 
Com­puter Society Press, 2007. [22] P. Kocher, J. Ja.e, and B. Jun. Di.erential power anal­ysis. In Advances 
in Cryptology CRYPTO 99, volume 1666 of LNCS. Springer-Verlag, 1999. [23] T. S. Messerges, E. A. Dabbish, 
and R. H. Sloan. Power analysis attacks of modular exponentiation in smart cards. In Cryptographic Hardware 
and Embedded Sys­tems CHES 99, volume 1717 of LNCS, pages 144 157. Springer-Verlag, Aug. 1999. [24] 
J.-J. Quisquater and C. Couvreur. Fast decipherment algorithm for RSA public-key cryptosystem. IEE Elec­tronics 
Letters, 18(21):905 907, 1982. [25] R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital 
signatures and public-key cryp­tosystems. Communications of the ACM, 21:120 126, 1978. An earlier version 
appeared as Technical Report MIT/LCS/TM-82 (1977). [26] W. Schindler. A timing attack against RSA with 
the Chinese Remainder Theorem. In Cryptographic Hard­ware and Embedded Systems CHES 00, volume 1965 
of LNCS, pages 109 124. Springer-Verlag, 2000. [27] A. Shamir. Method and apparatus for protecting pub­lic 
key schemes from timing and fault attacks. United States Patent #5,991,415, November 23, 1999. Pre­sented 
earlier at the rump session of EUROCRYPT 97. [28] D. Vigilant. RSA with CRT: A new cost-e.ective so­lution 
to thwart fault attacks. In Cryptographic Hard­ware and Embedded Systems CHES 08, volume 5154 of LNCS, 
pages 130 145. Springer-Verlag, 2008. [29] D. Wagner. Cryptanalysis of a provably secure CRT-RSA algorithm. 
In ACM Conference on Computer and Communications Security CCS 04, pages 92 97. ACM Press, 2004. [30] 
S.-M. Yen and M. Joye. Checking before output may not be enough against fault-based cryptanalysis. IEEE 
Transactions on Computers, 49(9):967 970, 2000. [31] S.-M. Yen, S. Kim, S. Lim, and S.-J. Moon. RSA speedup 
with residue number system immune against hardware fault cryptanalysis. In Information Security and Cryptology 
 ICISC 01, pages 397 413, 2001. [32] S.-M. Yen, S. Kim, S. Lim, and S.-J. Moon. RSA speedup with Chinese 
Remainder Theorem immune against hardware fault cryptanalysis. IEEE Trans. Computers, 52(4):461 472, 
2003. An earlier version of this paper appeared in [31].</RefA>  
			


 A GROUPING GENETIC ALGORITHM FOR COLORING THE EDGES OF GRAPHS SAMI KttURI TIM WALTERS YANTI SUGONO 
Dept of Math &#38; Computer Science Virage, Inc. 2017 Paseo Del Sol San Jos4 State University San Mateo, 
CA San Jos6, CA San Jos6, CA khuri@cs.sjsu.edu t.walters@computer.org ysugono@hotmail.com Keywords: combinatorial 
optimization, edge coloring problem, genetic algorithms, grouping genetic algorithm ABSTRACT This paper 
investigates applications of heuristic tech- niques for solving the edge coloring problem, which seeks 
the minimum number of colors to color the edges of a graph such that no two adjacent edges (edges that 
share a common vertex) get the same color. Except for special cases, such as bipartite graphs, the edge 
coloring prob- lem is NP-complete. Thus, the search for exact algo-rithms is replaced by the investigation 
of approximgttion and heuristic algorithms (unless P=NP). In this work, we consider both simple graphs 
and multigraphs, and compare three heuristics for the edge coloring problem. The first is a greedy algorithm, 
and the two others are genetic algorithms: a genetic algorithm that makes use of LibGA and a grouping 
genetic algorithm. Our results show that the grouping genetic algorithm outperforms the greedy heuristic 
for many problem instances. This paper supports the clainl that the edge coloring problem is more amenable 
to grouping genetic algorithms. INTRODUCTION The edge coloring problem seeks to label a graph's edges 
with a minimmn number of colors ill such a way that no two edges that share a vertex also share a color. 
The minimum muuber of colors required to color the edges of a gra.ph G is called the chromatic index 
of G and is generally denoted by ~:'(G), It should not be confused with tile minimum number of colors 
to color the vertices of G, tile chromatic number, which is usu- ally denoted by ,~(G). Ilolyer proved 
that the edge coloring problem is N P-hard [9]. Thus, the search for finding exa.ct algorithms for the 
edge coloring problem should be replaced by designing efficient approximate algorithms and heuristic 
algorithms. In this work, we investigate and compare two genetic algorithms (GAs) Permission to make 
digital or hard copies of all or part of this work for personal or classroom use is granted without fee 
provided that copies are not made or distributed for profit or commercial advantage and that copies bear 
this notice and the fifll citation on the first page. To copy otherwise, to republish, to post on servers 
or to redistribute to lists, requires prior specific permission and or fee. SAC'00 March 19-21 Como, 
Italy (c) 2000 ACM 1-58113-239-5/00/003>...>$5.00 with a greedy heuristic. We apply these heuristics 
not only to simple graphs but also to multigraphs: graphs that allow more than one edge between two vertices. 
We note that on multi- graphs, the edge coloring problem can be approximated within 1.1 + (0.8/opt) [13]. 
The edge coloring problem has many practical ap- plications including various scheduling problems, par- 
titioning problems [7], timetabling problems [2], and wavelength-routing in optical networks [14]. We 
design and implement two genetic algorithms; the first makes use of LibGA [3] and the second is a Grouping 
Genetic Algorithm [6]. We also implement a greedy heuristic. Experimental results obtained by the GAs 
and the greedy heuristic on 28 simple graphs and 15 multigraphs are presented. Some graphs are taken 
from I(nuth's Stanford GraphBase [12], and are part of the DIMACS's (Center for Discrete Mathematics 
and Theoretical Computer Science) benchmark graphs [4]. The other graphs were generated by us. The rest 
of this work is organized ill tile following fashion. Section 2 defines tile edge coloring problem. Section 
3 introduces tile greedy heuristic. Tile two GA implenmntations for the edge coloring problenr are given 
ill Section 4. Tile implementation for the GCL~, and all stochastic operators used in both (-iAs, including 
the fitness function, are discussed ill this section. Section 5 describes the test cases used in this 
work, as well as the results and analysis of lhe performance of the different heuristic Mgorithms. Section 
6 contains our concluding remarks. 2 THE EDGE COLORING PROBLEM As mentioned earlier, determining the 
chromatic index of G, denoted by x'(G), is NP-hard [9]. As a matter of fact, even the restricted case 
of deciding whether a simple graph has chromatic index of three or less is NP-complete. As one might 
expect, x'(G) is related to the maximum vertex degree of G, denoted by ~x. If G is a bipartite graph, 
then x'(G) = £x [2]. If G is a nonbipartite, simple graph, then either x'(G) = ~x or x'(G) = £x + 1 [16]. 
This fact makes the edge coloring problem unique. It belongs to a handful of problems 422 that are known 
as "within one unit of optimum" [8]. Indeed, the fact that the optimum solution is one of two quantities, 
&#38; or dx + 1, makes it easy to evaluate the efficiency of the heuristic being studied. An efficient 
heuristic has to consistently produce a number of col- ors in the neighborhood of (not much larger than) 
the graph's maximum vertex degree. The following formal definition of the edge coloring problem uses 
Stinson's terminology for combinatorial optimization problems [15J. We introduce concepts and notations 
that are used in subsequent sections. Problem instance: A graph G = (V,E), where Y = {v~ .... ,v~} is 
the set of vertices and E = {el,...,em} the set of edges. We denote by Adj(ei) the set of edges adjacent 
to ei, i.e., the set of edges in G that share a common endpoint with ei. Feasible solution: A feasible 
solution is represented by a vector ff = yl y2 ---ym where Yl = j means that the i th edge ei is given 
color j, 1 _< j < m. The components of ff are essentially the colors assigned to the m edges of G. We 
assume that the smallest value of any yi is 1 and that if q = rnax{yi I 1 < i < m}, then for any t, 1 
< t _< q, there exists at least one k, 1 < k < m such that yk = t. In other words, the colors are denoted 
by 1,2,... ,q. We also have: ej E Adj(eO ~ yl # Y3 In other words, two a(ljacent edges have different 
colors. Objective thnction: For a feasible vector .g, let P(:~7) be the number of colors used in the 
coloril~g of the edges represented by LT. More precisely, P(~) = -,.a:,:{v, I v, is a eompouent of ~}. 
Optimal solution: A feasible vector .g that yichls the smallest P(~). A GREEDY HEURISTIC FOR THE EDGE 
CO-LORING PROBLEM EdqeCoh)ringAssign'mcnt is a greedy algorithm that ran-domly chooses a.n edge e~ to 
color. To make sure that c, gets a different color from its adjacent edges, the algo- rithm makes use 
of Adi(eO. Recall tlhat Adj(eOrepre-sents the set of edges adjacent to el, for i = 1, 2,..., m. To color 
ei, EdgeColoringAssignment checks the colors of every edge in Adj(ei) and gives ei the smallest num-bered 
color not already assigned to any of ei's adjacent edges. Let color[ei] be the color number assigned 
to edge ei, and assignedcolorset be the set of colors of the edges in Adj(ei) that have already been 
colored. Algorithm EdgeColoringAssignment: Randomly choose an edge, say el, and assign it color number 
1; color[ei] = 1; fori:=2 tom { assignedcolorset:= 0; randomly select an edge that has not been colored, 
say % ; check each member in Adj(ej); if it is already colored then add that number to assignedcolorset; 
k := 1; while k is in assignedcolorset k:=k+l; color[ej] = k;//k is the smallest unassigned color. The 
running time of the above algorithm is O(mA). 4 THE GENETIC ALGORITHMS We start by discussing our implementation 
of the GA that uses LibGA, and then turn our attention to the grouping genetic algorithm. Some features, 
such as the fitness function, are the same for both GAs. 4.1 Representation and GA Operators A coloring 
of a graph's edges is represented by using a non-binary string, yl y2 ... Ym, where m is the number of 
edges. The value of y~ represents the color assigned to the jth edge. If a graph has 12 edges, for example, 
then the following string is a possible coloring, where edge el has color number 5, edge e~ has color 
number 3, and so on. , ~ a 4 ~ 6 r s ,a 10,~,2 Figure 1: Chromosome representation for the edge coloring 
problem In our study, we use geuerational genetic algorithms with roulette wheel selection, uniform crossover, 
and uniform mutation for both genetic algorithms. Each string in the population occupies a slot on the 
roulette wheel of size inversely proportional (since the edge col- oring problem is a minimization problem) 
to the fitness vahle. Unlike mauy other approaches that handle constrain- ed optimization problems by 
a knowledge-based restric- tion of the search space to feasible solutions, the GA described here ,,ses 
a penalty function to handle con-straints. Infeasible strings join the population, but at a price. A 
penalty term reduces an infeasible string's fitness. The fitness function obeys the following princi- 
ple [10, 11]: The fitness functions use g,ztded penalty functions. Two infeasible strings are not treated 
equally. The penalty is a function of the distance from feasibility. The fitness function implemented 
for the edge color- ing problem is the sum of two terms: 1. the objective function as given in Section 
2, P(ff) which calculates the total number of colors used to color the edges of the graph (represented 
by if). 2. a penalty term used to penalize infeasible strings, where the weight of the penalty is proportional 
to the number of violations (number of adjacent edges with the same color).  The penalty term is the 
sum of two parts. The first part is the maximum vertex degree to which one is added, i.e., &#38;+l. It 
is an offset term but does not guar- antee that an infeasible vector will always yield a fitness value 
irfferior to the ones obtained from feasible vectors. To have a strict separation between feasible and 
infeasi- ble strings, one would have to use, for example, m: the number of edges, as an offset, since 
we cannot do worse than coloring m edges with ra colors. But we noticed that £x+l was good enough to 
be used as an offset term. The second part of the penalty term is the number of violated pairs. This 
imposes a heavier penalty on infea- sible strings with greater number of violated edges, thus differentiating 
the degree of infeasibility among strings. The fitness function of ff = yly2.., ym, used with both genetic 
algorithms, is given by: f(ff) = P(ff) + s[(&#38; + 1) + T(ff)] where P(y) is the number of different 
values of the com- ponents of ff (the objective function in Section 2), s = 0 if ~ is feasible and s 
= 1 otherwise, &#38; + 1 is the offset term, and T(ff) is the number of pairs of edges that vio- late 
the color condition. In other words, T(ff) represents the number of adjacent edges that have the same 
color. 4.2 Representation aod Operators for the GGA The grouping genetic algorithm, GGA [6], as the 
name suggests, tocuses purely on problems with grouping prop- erties. The edge coloring problem consists 
in placing the rn edges of the graph in the minimum number of groups (colors) under certain restrictions. 
GGA adopts all the basic notions of tire GA studied in the previous section. with au alteration in the 
representation of strings. To capture the grouping entity of the problem, the sim-ple (standard) chromosome 
is augmented with a group part. For example, the chromosome of our hypothetical 12-edge graph given iu 
Figure 1 is represented by the string in Figure 2. In the example, we label colors with 15131,1 l,131 
l;141,1,1 ll l l l,lqTIcl 101,,lol l+l,l l,L Figure 2: Chromosonm in GGA representing the chromosome 
of Figure 1. letters so as to be able to distinguish them from edges (that are labeled with numbers). 
The first half is the object part and is identical to the entire chromosome seen in the previous section, 
while the second half is the group part. The fitness function of a string considers the object part of 
the string only and computes the fitness value as explained in the previous section. In GGA, we use the 
same roulette wheel selection as we do in GA. Since the new chromosome architecture does not affect the 
fitness value of a string, there is no need to modify the existing selection strategy. The crossover 
operator, however, has been altered to work solely with the group part. Two parents are randomly chosen 
from the mating pool and two crossing sites are chosen for each parent. Note that the crossing sites 
are chosen between groups of colors. For example, consider the group parts of two chromosomes, where 
the delimiters represent the crossing sites. I I I I The entire group part between the two crossing 
sites of the second parent, i.e., is then in- jected into the first parent at the beginning of its cross- 
ing site. After injecting the crossing section of the second par- ent into the first parent, we have: 
Since new groups are now included, we will gener- ally have groups with the same label. In our example, 
we have two groups labeled B, two labeled C and two labeled D. We resolve this redundancy by eliminating 
groups B, C, and D from their old membership (i.e., from the first parent string), yielding    b_l 
l, IM The string is now free of duplicate groups: however, it. is likely that it still contains d~@icate 
objects. In this case, edges 8 and 11 are duplicates. We need to remove these objects from their old 
membership as well (from the first, parent string), resulting in This leaves out edges 6 and 7 from any 
group. At this stage we carry out the first-fit heuristic to reassign (re- color) these edges: it visits 
the groups one at a time, assigns the object to the first, group that is able to ac-commodate it. or 
to a randomly selected group if none is available. After tile first offspring has been generated, the 
roles of the two parents are reversed and the construction of tile second offspring is started. This 
implementation complies with the guidelines suggested by [6]. The mutation operator is quite different 
from a ran- dom alteration of values in the chromosomes as done in GA implementations. We adopt the strategy 
of proba- bilistically removing some groups from the chromosome and reassigning the missing objects. 
We consider the chromosome in Figure 2. Assume that color (group) C is removed due to probability. In 
doing so, we leave edges (objects) 2, 6, and 12 unassigned. Consequently, we need to perform a first-fit 
heuristic on these objects. Each unassigned edge is assigned to the first group that is able to take 
it. The strength of this mutation strat-egy is that, if a string is feasible before mutation, it is highly 
likely that it will still be feasible after mutation. In the worst case, if no other group is available, 
all the edges may again be assigned to the original group it initially belonged to. After crossover and 
mutation are performed on the group part, the object part is rear-ranged accordingly to reflect the changes 
that the group part has undergone. 5 EXPERIMENTAL RESULTS 5.1 The Test Graphs We present the computer 
simulation results of the GA that uses LibGA and the GGA implementation for the edge coloring problem, 
and compare them with the gree- dy algorithm EdgeColoringAssignment. For our exper-imental runs, we use 
28 simple graphs and 15 multi- graphs. For the simple graphs, we consider 21 bench- mark graphs from 
Knuth's Stanford GraphBase [12] and DIMACS [4], and seven complete graphs. From the Stanford GraphBase, 
we use the five book graphs (anna, david, homer, huck, jean), gamesl20, the two miles graphs (miles250 
and miles500), and nine queen graphs. From the DIMACS collection, we use the four problem instances based 
on the Mycielski transformation (my-ciel3, myciel4, myciel5 and myciel6). These problems were originally 
created for the vertex coloring problem. We also consider complete graphs with 20, 25, 30, 35, 40, 45, 
and 50 vertices, that we denote by eomp20, comp25, comp30, comp35, comp40, comp45, and comp50, re-spectively. 
The number of edges of the 28 problem in- stances varies from 20 (myciel3) to 2596 (queen12_12). The 
multigraphs we use in our experimental runs were generated by repea.tedly assigning edges to ran-domly 
chosen pairs of vertices until each vertex has a. fixed degree. We deuole the multigra.phs we generated 
by rexmgl0_x, rexmg2{hx, and rexmga0_x, where 10, 20 and 30 a.re the number of vertices and x is the 
degree and has the values of 10. 2/L 30, 40 and 511. In all three t:tbles (Ta.ble 1, Table 2 and Table 
3), we give lhe gr~tph name, and the number of vertices followed by the number of edges (the chromosome 
size for the GAs). The density of the graph, which is the ratio of the number of edges to the number 
of vertices, is given, followed by t.h~ maximum vertex degree of the graph.  5.2 Results and Discussion 
 In our study, we use a generational genetic algorithm with roulette wheel selection, crossover, and 
mutation. The intial population was randomly generated. In each string the m edges were randomly assigned 
values in the range of 1 to m. Table 1 summarizes the results of exe- cuting the greedy algorithm and 
the genetic algorithms for the edge coloring problem with 21 problem instances. The results tabulated 
under the Greedy Algorithm are the best, the number of times the best solution was ob- tained (Frequency), 
and the mean results we obtained after 1000 runs on each of the 21 problem instances. As for the genetic 
algorithms, the results reported in the ta- ble were obtained by running our GA that uses LibGA once 
on every problem instance. For all 21 problem inn- stances, we use the same number of generations (500), 
the same population size (100), the same crossover rate (0.6), and the same mutation rate (0.2). The 
GGA obtained its best solution very quickly. So, we decided to run all 21 problem instances with a smaller 
pool size (50), smaller number of generations (100), crossover rate of 0.6, and mutation rate of 0.2. 
We report the results of 100 such runs of the GGA in the last columns of Table 1. The three last columns 
of Table 1 contain the best, the frequency the best was ob- tained, and the mean for all 100 runs of 
the GGA. Also, although we ran the genetic algorithm for t00 gener-ations, most of the results recorded 
in the table were obtained before the 50 th and some within 15 genera- tions. Problems that exhibit a 
"grouping property" are more amenable for the GGA [6]. As a matter of fact, the decision of running the 
LibGA-based GA only once was dictated by the fact that multiple runs did not alter the best result. We 
thus decided to focus on the compar- ison between the greedy algorithm and the GGA only for complete 
graphs and for multigraphs. Table 2 summarizes the results for the seven com- plete graphs. The results 
tabulated under the Greedy Algorithm are the best, the percentage of times it found the best repotted 
in the previous column and the mean results we obtained after 1000 runs on each of the seven problem 
instances. As for the GGA, we used a popula- tion size of 50, crossover rate of 0.6 and mutation rate 
of 0.2. The results obtained by the GGA were much better than the ones obtained by the greedy algorithm. 
Here too, we ran the genetic algorithm for 100 genera- fions, but most of the results recorded in the 
table were obtained very early in the run, some within 15 genera- tions. Table 2 shows that the greedy 
Mgorithm was able to achieve the success obtained by the GGA in just a few cases. For t,a,o p~ol>lem 
instances, the resnlts ob- tMned by the GGA are better than the ones obtained by the greedy algorithm. 
For the remaining complete graphs, although the results reported under Best are similar, the Dequencies 
for obtaining these results are far less than the GGA's. Table 3 s,mmarizes the results obtained from 
the fifteen multigraphs. The settings for both the greedy Mgorithm as well as the GGA are similar to 
the ones we described in the previous paragraph for the com-plete graphs. The difference between the 
GGA and the greedy algorithm is even more pronounced than with tile complete graphs of Table 2. More 
precisely, in all but three, the best result obtained by the GGA is bet- ter than the ones obtained by 
the greedy algorithm. For the remaining three problem instances, rexmgl0_20, rexmg20_10 and rexmg30_20, 
the results reported under Best are similar, but with a drastically lower frequency for the greedy algorithm. 
As far as computing time is concerned, we note that in general, the difference in run- ning times between 
the greedy algorithm and the GGA increased with larger problem instances. For example, it took 4.84 seconds 
for the 1000 runs of the greedy algo- rithm to produce the 11 colors for rexmgl0_10 (see Ta- anna.col 
 david.col homer.col huck.col jean.col games120 .col miles250.col miles500.col queen5-5.col queen6_6.eol 
queen7_7.col queen8_8.col queenS..12.col queeng_9.eol queenlO_lO.col que enl 1 ..3_ 1. col queen 12_12.col 
myciel3.col myciel4.col myciel5.col myciel6.eol LibGA I Best [ Freq. [Mean 138 "493 0.28 71 71 100% 
71 71 71 100% 71 87 406 0.21 82 82 100% 82 82 82 100% 82 561 1629 0.34 99 99 100% 99 99 99 100% 99 74 
301 0.25 53 53 100% 53 53 53 100% 53 80 254 0.31 36 36 100% 36 36 36 100% 36 120 638 0.19 13 14 38.8% 
14.66 14 13 96% 13.04 128 387 0.33 16 16 72.9% 16.28 16 16 100% 16 128 1170 0.11 38 38 85.3% 38.16 38 
38 100% 38 25 160 6.40 16 16 59.7% 16.43 16 16 100% 16 36 290 8.06 19 19 11.1% 20.36 19 19 100% 19 49 
476 9.71 24 24 59.8% 24.45 24 24 100% 24 64 728 11.4 27 27 8.4% 28.28 27 27 100% 27 96 1368 14.3 32 33 
11.3% 34.66 34 32 16% 32.84 81 1056 13.0 32 32 63.5% 32.40 32 32 100% 32 100 1470 14.7 35 35 13.7% 36.18 
35 35 100% 35 121 1980 16.4 40 40 66.1% 40.43 40 40 100% 40 144 2596 18.0 43 43 20% 44.09 43 43 100% 
43 11 20 0.55 5 5 70.4% 5.30 5 5 100% 5 23 71 0.32 11 11 100% 11 11 11 100% 11 47 236 0.20 23 23 100% 
23 23 23 100% 23 95 755 0.13 47 47 100% 47 47 47 100% 47 Table 1: Test. results for the GraphBase and 
DIMACS problem instances. Problem Instances Greedy Algorithm GGA Name comp20.col F"'200""T-'196"-T~ comp25.col[ 
25 l 300 ] 12.o ~omp30.eol I Z0 I 435 I 14.5 comp35.col I 35 I 595 I 17.0 comp40.col [ 40 [ 780 [ 19.5 
comp45.col I 45 [ 990 I 22.0 comp50.col 50 1225 24.5 Table 2: Test results for the complete graph problem 
instances. ble 3), while the GGA ran for 2.34 seconds to complete the 100 generations. On the other hand, 
the running times for the greedy and the GGA with rexmg30_50 were 110.4 seconds and 205.68 seconds, respectively. 
The runs were performed on a 300 MHz Pentiumll computer. We would also like to add that no fine-tuning 
or tinkering with the stochastic operators was performed.  6 CONCLUSION AND FUTURE WORK This paper 
investigated applications of heuristic tech-niques for solving the edge coloring problenl. The in-quiry 
has compared a greedy algorithm with two ge-netic algorithms by applying all three algorithms to GraphBase 
and DIMACS benchmark graphs, complete graphs, and multigraphs. Our findings support the claim that the 
GGA outperforms the greedy heuristic, espe-cially for dense graphs. In future work, we intend to use 
a repair mechanism in place of the penalty term in the fitness function. This technique has produced 
promis-ing results with the set covering problem [1]. We also intend to compare our results with those 
obtained by Eibeu and van Hemert [5] who use an adaptive evolu-tionary algorithm. Another extension to 
this work is to use other test suites generated specifically for test-ing tile performance of evolutionary 
algorithms (EAs). The EA community has created test problem gener-ators in which random problems with 
certain charac-teristics can be generated automatically and methodi-cally. Drawing conclusions about 
the behavior of an EA can be facilitated when test suites are randomly created with certain characteristics. 
For instance, Joe Culber- son has files for the graph-coloriug generators available at. http: / /web.cs.ualberta.ca/-joe 
/Coloring/ Generators. ACKNOWLEDGMENTS The authors would like to thank Thomas Erlebach from TUM for 
helpful discussions and careful readings of the paper. They would also like to thank one of the review- 
ers for comments and suggestions that improved this work. REFERENCES <RefA>[1] B/~ck, T., Schlitz, M., and 
Khuri, S. "A com-parative study of a penalty function, a repair heuristic, and stochastic operators with 
the set-covering problem", Artificial Evolution: Lecture 426  Problem Instances GGA rexmglO_lO 10 rexmglO_20 
2O rexmglO_30 3O rexmglO_40 40 rexmglO_50 50 rexmg20_lO 10 rexmg20_20 20 rexmg20.30 30 rexmg20_40 40 
rexmg20.50 50 rexmg30_lO 10 rexmg30.20 20 rexmg30_30 30 rexmg30_40 4O rexmg30_50 Table 3: Test results 
for the multigraph problem instances. Notes in Computer Science, vol. 1063, Springer Verlag, Berlin, 
pp. 320-332, 1996. [2] Bondy J.A. and Murty, U.S.R. Graph Theory with Applications, McMillan, New York, 
1976. [3] Corcoran, A. and Wainwright, R. " LibGA: A user-friendly workbench for ordered-based ge-netic 
algorithm research", Proceedings of the 1993 A CM/SIGA PP Symposium on Applied Computing, ACM Press, 
pp. 111-117, 1993. [4] DIMACS: Center for Discrete Mathematics and Theoretical Computer Science. ftp://dim 
acs. rutgers, edu/pub/ehallenge/graph/ benchmarks/color". 1990. [5] Eiben. A. and van llemert, .I.[. 
"SAW-ing EAs: Adapting the fitness function tbr soh'ing con-slrained problenrs", New Melho(I.~ in Optimisa-lion. 
Advanced Topic.+ i~ (]on/1)ating, McClraw-Hill, 1999. [6] [:alkena.uer, E. "A new rel)rescnl.alion and 
oper- ators for genetic algorithms applied lo grouping problems," Evohttio,ary ('omputation, pp. 123- 
144. The MIT Press, Massachusetts, 1!)94. [7] Fiorini, S. and Wilson, R.,1. Edge-Colourings of Graph.s, 
Pitman, London, 1977. [8] llochba.um, D., editor. Approximation algorithms for NP-hard problems, PWS 
Press, Boston, MA, 1997. [9] Holyer, I. "The N P-compleleness of edge coloring," SIAM .lournol of Computing, 
vol. 10, pp. 718-720, 1980. [10] Khuri, S., B£ck, T., and HeitkStter, J. "An evo- lutionary approach 
to combinatorial optimization problems," Proceedings of the 22 na A CM Com- puter Science Conference, 
pp. 66-73, ACM Press, 1994. [11] Khuri, S. and Chiu, T. "Heuristic algorithms for the terminal assignment 
problem," Proceedings of the 1997 A CM Symposium on Applied Computing, pp. 247-251, ACM Press, 1997. 
[12] Knuth, D. The Stanford GraphBase: A Platform for Combinatorial Computing, ACM Press, NY, 1993. [13] 
Nishizeki, T. and Kashiwagi, K. "On the 1.1 edge- coloring of multigraphs," SIAM Journal of Discrete 
Mathematics, vol. 3, pp. 391-410, 1990. [14] Ramaswami, R. "Multiwavelength lightwave net- works for 
computer communications," IEEE Com- munications, vol. 21, no. 2, pp. 78-88, 1993. [15] Stinson, D. An 
Introduction to the Design and Analysis of Algorithms, The Charles Babbage Research Center, Manitoba, 
Canada. 2nd edition, 1987. [16] Vizing, V. "On all estimate of the chromatic class ofa p-graph" (in Russian). 
Diskrel. Analiz., vol. 3, pp. 25-30, 1964. </RefA>
			

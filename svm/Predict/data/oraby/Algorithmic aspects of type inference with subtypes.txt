
 Algorithmic ~pects of type Patrick Lincoln * Computer Science Department Stanford University Stanford, 
CIA 94305 lincoln@cs. stanf oral. edu Abstract We study the complexity of type inference for pro­gramming 
languages with subtypes. There are three language variations that effect the problem: (i) ba­sic functions 
may have polymorphic or more limited ~ype%(ii) the subtype hierarchy may be fixed or varY as a result 
of subtype declarations within a program, and (iii) the subtype hierarchy may be an arbitrary partial 
order or may have a more restricted form, such as a tree or lattice. The naive algorithm for infer­ring 
a most general polymorphic type, under variable subtype hypotheses, requires deterministic expo~en­tial 
time. If we fix the subtype ordering, this upper bound grows to nondeterministic exponential time. We 
show that it is Np-hard to decide whether a lambda term has a type with respect to a fixed subtype hier­archy 
(involving only atomic type names). This lower bound applies to monomorphic or polymorphic lan­guages. 
We give PSPACE upper bounds for deciding polymorphic typability if the subtype hierarchy has a lattice 
structure or the subtype hierarchy varies arbi­trarily. We also give a polynomial time algorithm for 
the limited case where there are of no function con­ stants and the type hierarchy is either variable 
or any fixed lattice. 1 Introduction Subtyping is a basic feature of typed object-oriented languages, 
such as C++ and Eiffel [Str86, Mey88], * Supported in part AT&#38;T Bell Laboratories Doctoral Schol­arship 
and sources listed under t . t supported in part by au NSF PYI Award, matching funds from Digital Equipment 
Corporation, the Powell Foundation, and Xerox corporation; NSF grant ccR-8814921 and the Wal­lace F. 
and Lucille M. Davis Faculty Scholarship. Permission to copy without fee all or part of this materdal 
is granted provided that the copies are not made or distributed for direct commercial advantage, the 
ACM copyright notice and the title of the publication and ha date appear, and notice is given that the 
copying is by permission of the Association for Computing ~achinery. To copy otier­wise, or to republish, 
requires a fee and/or specific permission. @ 1992 ACM 089791-453-81921000110293 $1.50 inference with 
subtypes John C. Mitchellt Computer Science Department Stanford University Stanford, CA 94305 mitchell~cs. 
stsnf oral. edu and also occurs in many other languages in limited cases such as the relation between 
integer and real (or floating-point) numbers. In 1984, the second author described an algorithm for Milner-style 
type inference with subtyping [Mit84, Mit91]. Given a pure, untyped lambda term, this algorithm finds 
a most general typ­ing statement that describes the set of possible typings with respect to any subtype 
hierarchy. Various aspects of the algorithm have been studied by other authors, with Fuh and Mishra elaborating 
algorithmic alter­natives [FM90] and Wand and O Keefe studying the computational complexity of typability 
[W089]. An extension with polymorphic record operations [JM88] has been implemented by Jategaonkar [Jat89]. 
Unfor­tunately, the straightforward implementation of the type inference algorithm with subtypes requires 
ex­ponential time, even in the absence of polymorphic let declarations (see [KMM91]). This may be an 
ob­stacle to practical type inference for object-oriented languages. It is therefore important to investigate 
the inherent complexity of type inference and type check­ing in the presence of subtypes. The most general 
typing assertion about a pure lambda term (without constant symbols) may have exponential size, even 
using concise directed acyclic graph (dag) representations of type expressions. Con­sequently, it is 
not possible to compute most general types with subtyping in less than deterministic expo­nential time. 
However, the related decision problem of determining whether a term has any type might be solved more 
efficiently. By comparison, even though the Curry-type of a pure lambda term without subtyp­ing can be 
exponential, when written as a string, there exist linear-size dag representations and linear algo­rithms 
that decide Curry-typability [KMM9 1]. The decision problem is relevant to practice since an ef­ficient 
decision procedure could verify the absence of type errors at compile time without printing most­general 
types. Since this is the only form of typing problem that could be solved in less than exponential time, 
we focus on decision problems for type inference. There are three language variations that have an effect 
on the complexity of typing: The subtype hierarchy may be fixed or vary as a result of subtype declarations 
within a program. Term constants may be polymorphic functions or restricted to monomorphic functions 
or atomic data (non-functions). The subtype hierarchy may be an arbitrary par­ tial order or may have 
a more restricted form, such as a tree or lattice. If term constants have restricted functionality, this 
may simplify the type inference problem. Therefore, when possible, we prove lower bounds for restricted 
term constants and upper bounds for polymorphic types. A subtle issue is the relationship between the 
sub­type hierarchy at the point of declaration of some iden­tifier and the subtype hierarchy at a possible 
point of use. For example, consider a function ~ of two argu­ments that requires the type of the first 
argument to be a subtype of the type of the second. An implicit assumption in [Mit 84, Mit 9 I.] is that 
the appropriate typing statement to infer about f is some formaliza­tion of this English description, 
regardless of whether types A and B with A a subtype of B have been declared. The reason is that we may 
want to call the function f in some scope where two such types have been declared. Therefore, the type 
inference al­gorithm given in [Mit84, Mit91] deduces a most gen­eral typing statement that includes arbitrary 
assump­tions about the relationships between types of func­tion parameters. While this seems reasonable 
for pure lambda terms without constant symbols, the situation becomes more complicated in a realistic 
programming language. This is discussed in Section 3. The main lower bound in this paper is that it is 
NP-hard to decide whether a lambda expression with constants has a type, given a set of subtyping rela­tionships 
between ground (atomic) types. This ap­plies to polymorphic and monomorphic languages, and languages 
without functional constants. This lower bound improves the main result of [W089], which re­quires a 
constant with a polymorphic type. We also observe that if type parameters and subtype assump­tions are 
given explicitly in the syntax of terms, it fol­lows from the results in [Tiu91] that deciding whether 
an explicitly-typed term has a type is PSPACE hard. We give two algorithms for the decision problem. 
The more general algorithm applies to terms with ar­bitrary constants, but assumes either that the subtype 
hierarchy may vary arbitrarily or that the fixed sub­type hierarchy is a lattice. (Either condition makes 
it possible to determine in polynomial space whether an exponential-size set of subtype assumptions is 
satisfi­able.) In the special case that there are no functional constants and the subtype hierarchy is 
either vary­ing or is a fixed lattice, our second algorithm solves the problem in linear time. Since 
this case is NP-hard for arbitrary partial orders, our results emphasize the value of restricting the 
subtype relation to obtain prac­tical typing algorithms. Further discussion of the relevant language 
char­acteristics and their relationship to type inference is given in Section 3, following the preliminary 
defini­tions in Section 2. The lower bound is presented in Section 4 and the upper bounds in Sections 
5 and 6. For those familiar with [W089], we note that their claim that the decision problem reduces to 
the par­tial order problem PO-SAT has been retracted [Wan91]. This invalidates both the claimed NP algorithm 
for the general problem and the claimed polynomial algo­rithm when the subtype hierarchy is a tree. 
 2 Preliminaries We review the essential definitions and results from [Mit84, Mit91]. We study typing 
algorithms for untyped lambda terms, possibly cent aining constant symbols. Lambda terms are formed according 
to the grammar M::= z/c] MlM2 Ikr. ikf, where z may be any variable, c a constant symbol, lvfliMz is 
the application of Ml to h4z and Ax.11 is a lambda abstraction defining a function. For simplicity, we 
only consider function types, writ­ ten using type variables and type constants. Type ex­ pressions have 
the form T =. . tlo/7-l+T2 where t maybe any type variable, 6 a type constant, and rl --+ rz is the 
type of functions from ~1 to T2 . A subtype assertion has the form ~ ~ T The stan­ dard meaning of an 
assertion u ~ T M that ~ is a subset of r . An alternative interpretation that we will not discuss in 
any detail is that there is some coercion function fa+T which transforms values of type a into values 
of type ~ . Some discussion of this alternative may be found in [Mit91]. An atomic subtype assertion 
is a statement a ~ b , where a and b are either type variables or type con­ stants. All of our subtyping 
hypotheses will be atomic. Without this assumption, subtyping hypotheses such as the pair b ~ b+b and 
b+b ~ b would ex­ press domain equations, and therefore allow all pure lambda terms (terms without constants) 
to be typed (see [Mit91]). Terms and types will be written over some selected signature. A signature 
X = (B, S, T) is a triple con­ sisting of a set B of type constants, a set S of atomic subtype assertions 
about type constants in B , and a set T of term constants, each with a specific type built from type 
variables, type constants from B and + . We say a term constant c: u is polymorphic if u con­tains one 
or more type variables and non-polymorphic otherwise. Intuitively, two type expressions match if they 
have the same shape. This does not involve any substitu­tions. More specifically, we define matching 
as fol­lows: if u is a type variable or type constant, then u matches T if and only if T is a type variable 
or type constant; if u = al + UT , then u matches r if and only if T= q --+TV and al matches q ,and UP 
matches Tr . The entailment relation, # , on subtype assertions is defined by the following proof system. 
Note that if C is a set of atomic subtype assertions, and C 1-u ~ r, then u matches T.  c 6 u{(7<T}t_U<T 
R c 1-u~u The C rule allows subtype assumptions to be used in a derivation. The R rule is reflexivity 
of ~ , T is tran­ sitivity, and the Arrow rule gives subtyping for func­ tion types. Note that function 
types are antimono­ tonic in the left, or argument position, and monotonic in the right, or result position. 
If C and C are sets of subtype assertions, we write C h C! to indicate that Cku<Tforeveryu <Tin C . A 
typing statement is a formula C, A E M: u, where C is a set of atomic subtype assertions, A is a set 
of type assumptions of the form z: a, where z is a term variable, M is an untyped lambda term, and ~ 
is a type expression. The typing statement C, A 1-M : u may be read as, Under the subtype assumptions 
C and assumptions A about the types of variables, the term M has type u . The following proof rules determine 
typability with respect to any signature X = (B, S, T) . The subtype proof system enters through the 
Sub, or subsump­ tion rule. In Const, R may be any substitution of type expressions over E for type variables. 
Const C, A!-C:RU (c:a GT) Var C, AU{ Z:u}\x:a C, AF-M:u--+T C, AEN:U App C, A1-(MN):r C, AU{ Z:a}EM:~ 
Abs (z@ A) C, A1-(k.M):u-+r C, AkM:cT cUsku~T Sub c,Atiif:T  The Const rule allows a typed constant 
from the sig­nature to be given any substitution instance of its specified type. (If c : a is non-polymorphic, 
then the substitution R will have no effect.) The Var, App, and Abs rules are standard. The Sub rule 
forces a term with one type to belong to every supertype. We say that a typing statement C, A F M : n 
is provable with respect to signature Z = (B, S, T) if all of the term constants in A4 appear in T and 
all uses of Const and Sub in the derivation of the typing stat­ment are in accordance with the signature. 
As stated in [Mit84] and proved in [Mit91], one may normalize proofs of typing statements so that the 
only uses of the Sub rule are immediately following uses Var and Const. That is, the steps in any proof 
of a typing statement may be permuted so that the Sub rule only appears at the leaves of the proof. This 
prop­erty is important because the other four inference rules of this system are syntax-directed. That 
is, there is at most one normal proof of any type assertion up to uses of Sub. This property is used 
in the typing algorithms in [J M88, Mit91] and in all algorithms discussed in this paper. An alternative 
way of stating this proof nor­malization property is that the rules above are equiva­lent to the proof 
system obtained by eliminating Sub and replacing Var and Const by variants that allow a constant or variable 
to be given any supertype of its given type. If R is a substitution of types for type variables, then 
we say R respects a set C of atomic subiyping assertions if, for every a < b in C , the type expres­ 
sion Ra matches Rb . If R respects atomic C , then there is a set C of atomic subtype assertions such 
that C FRa ~ Rb for every a< bin C, and if C is another set of atomic subtype assertions with this property, 
then C E C . We write R. C for any such minimal set of atomic subtype assertions. The set R. C is efficiently 
computable from R and C , as outlined in [Mit84, Mit 91]. If A is a set of assump­ tions about the types 
of variables, then RA is the set RA={x:Ro Ix:u GA}. Wesay C , A kiVl:&#38; isan instance of C, A F M: 
u if there is some substitution R of types for type variables such that RC 1-C , RA ~A and R~ =O A typing 
C, A 1-M : IS is a most general typing for M , with respect to some signature, if it is derivable and 
has every other derivable typing statement for M is an inst ante. Theorem 2.1 [Mit84, Mit91] Jf M is 
-typab/e with respect to some signature, then there is a most gen­era! typing statement for M , computable 
from M in exponential time. Although the theorem given in [Mit84, Mit91] is only stated for pure lambda 
terms without constant symbols, the algorithm and proof are easily extended to constants with specified 
variable-free types. The algorithm may also be extended to terms with poly­morphic constants, as described 
in [JM88, Jat89]. It is possible to decide whether a set of atomic subtype assertions is satisfiable 
in a partial order, in nondeter­ministic time polynomial in the size of assertion set and the present 
ation of the partial order. This gives us the following corollary. Corollary 2.2 There is a nondeterministic 
exponen­tial time algon thm for deciding whether a typing 0, A t-M : u is derivable with respect to a 
given sig­nature. Type inference, constants and decision problems While the algorithm given in [Mit84, 
Mit91] finds the most general type of any pure term, the application of this algorithm to a specific 
programming language is relatively subtle. If M does not cent ain constant symbols, then the most general 
typing for M will only cent ain t ype variables, and type constants do not enter into the problem. With 
both type and term constants, there are some questions regarding the set of subtype assumptions that 
might reasonably appear in a typ­ing statement. A simple example that illustrates one of the problems 
with type constants is the signature with type constants int and real, with ant ~ real, and term constants 
1: int , 2: int , mult : int --+ int --+ int and div : real+ real+ real. In this signature, we can multiply 
integers 1 and 2 by writing mult 12 since both arguments have type integer, and divide by writ­ing div 
12 since by the assumption int ~ real, both integers also have type reai. However, consider the expression, 
mult (div 12) 2. This is not well-typed, given the signature, since the subexpression (div 12) only has 
type reai and not type int. The typing algorithm in [Mit84, Mit91], when extended to constants in the 
simplest way, would produce a typing statement for this term, namely, real < int F (mu/i (div 12)2) :int 
Intuitively, this typing statements says that if real is a subtype of int, then the expression denotes 
an integer. This is a correct hypothetical statement, but since the hypothesis is false, it does not 
seem to be a useful output from the type checker. The reason that the algorithm infers a typing statement 
with additional subtype hypotheses is that, in general, this is the only way to obtain most general types. 
However, it is not reasonable to change the relationship between int and real by adding new subtypes 
of existing types. There­fore, as in [FM90, W089], it makes sense to design a type checker that fails 
on the example expression above. There are several reasonable restrictions on addi­tional subtype assumptions. 
The first is to reject any term that requires subtype relations not given by the signature. Given a term 
A4 , we must find some t yp­ing statement 0, A \ M : u with empty subt yping hy­potheses. We call this 
the typing problem with jixed subtype ordering since the only subtype relations are those fixed by the 
signature. A second typing problem is to find a typing statement C, A k M : u such that the only required 
relationships between type constants are those given by the signature. In other words, we require any 
inferred C to be conservative over the sig­nature. We call this the typing problem with varying subtype 
orderingl since it is motivated by considering languages where the subtype ordering varies between different 
parts of the program. Conservativity rules out the typing for mult ( div 12) 2 above, since the signature 
does not imply real < int . Both of these typing problems may be solved by computing the most general 
typing for a given term and then testing the set of subtyping assumptions to see if it can be made empty 
or conservative over the signature by applying a type substitution. For a particular programming lan­guage 
with subtyping, the appropriate typing prob­lem may lie somewhere between these two extremes: additional 
type declarations will extend the subtype relation conservatively, but it may not be possible to obtain 
all conservative extensions. The typing problems we consider in this paper are summarized in Table 1. 
We consider both fixed and varying subtype relations, as indicated along the top of the table. Restrictions 
on the signature are listed at the left. We consider arbitrary signatures, signatures in which all term 
constants have non-polymorphic types, and signatures in which the type of each term constant is a type 
constant. This gives us a two­ dimensional matrix of typing problems. A third di­ mension is to consider 
possible restrictions on the sub­ type relation. With a variable subtype relation, the relation given 
by the signature has little effect. With a fixed subtype relation, we consider both arbitrary partial 
orders and lattices. For each of the problems, the table lists an upper bound on the upper line, and 
lower bound on the lower line, with trivial upper and lower bounds omitted. As the reader will readily 
see, we do not have matching upper and lower bounds for most of the problems listed. It is easy to show 
that each problem is reducible to the problem above it in Signature Fixed Subtype Relation Varying Subtype 
Relation Arbitrary Lattice Constants of any type F1 NExP upper bound L1 PSPACE upper bound V1 PsPAcE 
upper bound conservative over F2 conservative over L2 conservative over V2 No polymorphic types F2 reducible 
toFl L2 reducible toLl V2 reducible toVl conservative over F3 conservative over L3 conservative over 
V3 Atomic types only F3 reducible to F1 L3 linear time V3 linear time NP lower bound linear time linear 
time Table 1: Summary of problems and results. Lower bounds for F1-3 and upper bounds for L1-3 and Vi-3. 
the table, and conservative over the problem below it. ture E = (1?, S, T) , where all constants have 
This is because all are defined using the same proof atomic type, determine whether there exists a rules. 
The linear upper bound for problem L3 actu-provable typing statement C, A 1-M : u such ally holds for 
any order that is the disjoint union of that for all type constants bl, b2 G B , we have any number of 
partial orders with maximum elements. CUSkb1~b2iff St b1<b2. We state problems F1-3,, and Vi 3 in full 
below. An example may help clarify the difference Problems L1-3 are identical to F1 3, respectively, 
ex­between problems F1 and V1. The term cept that the subtype order must be a lattice. (Av.((b.(v CI))(W 
Ca))) is typable in the signature Fl: Given an untyped lambda term M, possibly con-with two constants 
c1 :8= , C2 : 8b and empty subtyp­taining constant symbols from some signature X , ing relation, according 
to the constraints of V1 but determine whether there exists a provable typing not F 1. The reason is 
that the variable v must have statement @,A ~ M : u without additional sub­ type u + ~ for some o greater 
than 8. and db . typing assumptions. A variation we will not consider is to give more in­formation about 
a term to be typed. For example,F2: Given an untyped lambda term M , possibly con­we could give term 
h4 and type u , and ask whether taining constant symbols from some signature E , there is a provable 
typing statement C, A F M : u . where all constants have variable-free type, deter-This might appear 
easier than the type decision prob­mine whether there exists a provable typing state­lem, since the added 
information could narrow the ment @,A t M : u without additional subt yping range of possibilities to 
consider. However, it is easy toassumptions. see that an arbitrary term M has a type iff the term F3: 
Given an untyped lambda term M , possibly con-Ax. KzM has type T + T , where K is the lambda taining 
constant symbols from some signature Z , term k. ~y. z . Therefore, it does not help to supply where 
all constants have atomic type, determine a type. whether there exists a provable typing statement 0, 
A h M : u without additional subtyping as­ sumptions. 4 Subtype Inference is NP-Hard Vl: Given an untyped 
lambda term M , possibly con- Wand and O Keefe give an argument for the NP­ taining constant symbols 
from some signature hardness of type inference which requires the use of a Z = (B, S, T) , determine 
whether there exists constant of polymorphic type, specifically, a constant a provable typing statement 
C, A t M : u such T with polymorphic type Va.(a + a + a) [W089], that for all type constants bl, b2 c 
B , we have roughly corresponding to our problem F 1. In this sec­ CUSt-bl ~b2iff St­ bl<b2. tion we 
improve their lower bound by proving that V2: Given an untyped lambda term M, possibly containing constant 
symbols from some signa­ture Z = (B, S, T) , where all constants have variable-free type, determine whether 
there exists a provable typing statement C, A 1-M : u such that for all type constants bl, ba ~ B , we 
have CUSkb1~b2iff Sk bl~b2. the strictly weaker problem F3 is iw-hard. Since F2 and F1 are conservative 
over F3, this lower bound also applies to these problems. We will reduce POL-SAT, stated as follows, 
to F3. Given a partial order (P,<) and a set of inequalities I of the form p < w, w < w , where w and 
w are variables, and p is a constant drawn from P , is there is an assignment from variables to members 
of P that V3: Given an untyped lambda term M , possibly satisfies all the inequalities 1 ? This problem 
is very containing constant symbols from some signa­ similar to PO-SAT, proven NP-complete by Wand and 
 Figure 1: poset for O Keefe [W089]. PO-SAT differs from POL.SAT in that it allows inequalities of the 
form w < p, which amount to upper bounds. PO-SAT may also be described as the satisfiability problem 
for inequations over a poset. Similarly, POL-SAT is also the satisfiability problem for inequations over 
a poset with the added restriction that no inequations have the form w < p for variable w and constant 
p. We first show that POL-SAT is NP-complete, and then show that POL-SAT reduces to F3. Lemma 4.1 POL-SAT 
is NP-cornpiete. Proof. It is easy to see that this problem is in NP, since one may simply guess an assignment 
of constants to variables, and check that every inequality in I is satisfied. To show that this problem 
is Np-hard, we give a reduction from 3-SAT. We begin with the empty set A , and for each clause Clausei 
= Pil V Pi2 V F ~3, we add the element named C i to A , and further add 7 more elements to A , one for 
each truth as­signment which sat isfies the clause. For convenience, we name these 7 elements by simply 
concatenating the names of the clauses with the names of the vari­ables they cent ain, using overbars 
to denote negation: C~P~~P~zP~3 , C~P~lPiz~ , CiP~~~Pi~ , etc. For each propositional variable Pj , 
we add three el­ements to A ,named Pj , PJ+ , and Pj._ . In­tuitively, these stand for the j-th proposition 
being undecided, true, and false, respectively. With the above set of constants, we define a par­tial 
order relation < on them as follows. We define the relation RP,OP to include, for each proposition pi 
, Pi+ < Pi and Pi ~ Pi . We define the rela­tion RClau~e to include, for each clause Clausei = Pil V 
Pi2 V Pi3 occurring in the 3-SAT problem, and each truth assignment which satisfies the clause, Ci < 
c~pil P~2Pi3 . We also define the relation Rtvue to include, for each clause Clause~ = Pil V P~Z V Pis 
, and each proposition in that clause Pij , a relation P+ < CiPil Pi2Pi3 for each of the 3 or 4 clause 
el~ments which correspond to Pij being true, Simi­larly, we define the relation R~at$e to include, for 
each (P VQ)A(QV=R) clause Clausei = Pil V Pi2 V Pi3 , and each proposi­tion in that clause Pij , a relation 
pi; < Ci 1%1Pizl is for each of the 3 or 4 clause types which correspond to Pij being false. The final 
partial order of inter­ est wilI be (A, RProP U Rcl.use U Rtrue U Rjar,e) . The partial order has height 
one, and contains 8 ( = 23) el­ements for each 3-SAT clause, plus three elements for each proposition. 
Figure 1 displays the partial order produced for the SAT problem (P V Q) A (Q V vR) . Clauses of length 
two were used, and the name pq was used in place of Clpq , for example, in Figure 1 to improve readability. 
 We use a set of variables, one Wpj and one wuj for each proposition Pj , and one wcj for each clause 
ClaUSej . We define a set of inequations IC1aU.e to include, for each-clause Clausei = Pil V Pi2 V Pi3 
, the inequality Ci < Wci , and for each proposition Pij in that clause, wpij < Wci . We also define 
a set of inequations lP~oP to include, for each proposition Pi , wpi ~ wui and Pi ~ wui . Thus there 
are four inequalities in IC1aU~e per 3-SAT clause, and two in­equalities in IPVOP for each proposition. 
Continuing with our simple example, (P V Q) A (Q V -IR) , the inequations Icl.u,, = {Cl ~ WC1, WPP d 
WC1, Wpq S Wcl, C2 < WC2, Wpq < WC2J Wpr < WC2) , and IPTOP = {WPP < WUP,WP, < Wuq, wpr < WU., P < WUP, 
Q 5 Wuq, R < WUr} We claim that the POL-SAT problem given by the partial order (A, R prop U fkause U 
.&#38;rue U Rfatse ) , with the inequalities IP.OP U IC1aU~e has a solution if and only if the original 
3-SAT problem has one. This may be observed by noting that every wci must be assigned some CiPil Pi2Pi3 
, since wci must be greater than Ci and some propositions. Also, the only CiPi1Pi2Pi3 which exist in 
A correspond to assign­ments of propositions which satisfy the clause. Fur­ther, wuj must be assigned 
Pj , and wpj must be assigned either P}+ or Pj~ . We claim there is a cor­ respondence between a proposition 
Pj being assigned true (or false, resp.) in the 3-SAT problem, and Wj being assigned Pj+ ( Pj: , resp.) 
in the PO L-SAT prob­ lem. Thus one may see that a solution to the 3-SAT may be derived from any solution 
to the constructed POL-SAT problem and vice-versa. _ This construction may be simplified somewhat, by 
omitting the inequalities 1pt.op , and the elements Pj (nodes labeled P, Q, and R in the example poset). 
In this case the correctness of the reduction is more difficult to establish. However, in either case 
the con­structed poset has depth one, and both the poset and the set of inequalities have size linear 
in the input 3-SAT problem. Lemma 4.2 POL-SAT reduces to F$. Proof. A POL-SAT problem is given with par­ 
tial order (P, <) , set of variables W, and set of inequalities 1. We define the set of type constants 
B = {13~lpi G P}, and a set of constants and their typings T = {ci : Oi ]Pi 6 P}. That is, for each ele­ 
ment of the POL-SAT partial order, we define a type t$ , and a constant of that type c~ . We define S 
to be a set of atomic coercions such that for each pi < pj in the POL-SAT partial order, Oi ~ Oj is in 
S. That is, we simply copy the partial order from the POL-SAT problem into a set of subt ype assertions 
about corresponding type constants. We then collect the above together into a signature E=(l?,S,T). For 
each variable Wi appearing in any inequality in the POL-SAT problem, we define the notation for two lambda 
term variables vi and ui . We number the m inequalities I in the POL-SAT problem il, ..., i~ , and define 
the translation [ij] of inequalities aS follows: = (Vz c,) (.PY 5 %1 [w 5 w,] = (v, (Vc uC))  Finally, 
we build the term (Au,. $. .(hln.(. . .((AV,. . . .(Avn. ((kc. [i,]) ((kr.[iz]) ~~. ((Ax. [im_,])[im]) 
~. )) (Ar.r))(k.%)) . . .(AZ.Z)) ~~.))) In words, we encode each lower bound on a variable as an application 
of that variable to the corresponding constant, and encode each relation bet ween variables VI and V2 
as an application of VI to the result of applying vz to uz . The variable U2 only serves as a dummy variable 
to which one can apply V2 . If the partial order has a bottom element, one could replace all uses of 
u variables with a single constant with the type of the bottom element of partial order. We build an 
abstraction over the set of function variables vi , with a body that includes a subterm for each inequal­it 
y, but throws all the results away except the first. We tie the upper and lower bounds on each function 
variable together by applying each abstraction to the identity function (~a .x) , and finally abstract 
over the u variables. Figure 2: Fixed NP-hard poset We claim without proof that this term is typable 
if and only if the corresponding POL-SAT problem haa a solution. _ Thus we have shown that F3 suffices 
to capture the essential NP-hardness oft ype checking with subtypes. As stated above, Wand and O Keefe 
show that PO-SAT reduces to F 1 [W089]. However, there also exists a straightforward extension of the 
above into a reduction from PO-SAT to F2: define the constant c~ to be of type t% -+ Oi, and [w. < Py] 
= (c: (v. u,)). Of course, there are reductions from F3 to F2, and F2 to F1, since the problems strictly 
subsume each other. Theorem 4.3 F3, F2, and F1 are m-hard. Proof. F3 is NP-hard from the above two lemmas, 
and F2 and F1 are conservative over F3, so the result follows immediately. _ Recent work by Pratt and 
Tiuryn [PT91] has shown that PO-SAT remains Np-complete for certain fixed posets. Our construction builds 
a different poset and set of inequations for each 3-SAT problem. Pratt s construction builds a different 
set of inequalities over a fixed poset, although it uses inequations of the form w < p. Thus Pratt s 
result subsumes the m-hardness of PO-SAT. With a simple modification, Pratt s NP­hardness result can 
be extended to cover the case of restricted inequalities, which corresponds to POL-SAT. Pratt shows that 
PO-SAT is m-complete even over the fixed poset containing only four elements, drawn in Figure 2. The 
following reduction from PO-SAT to POL-SAT, although not sound in general, is correct for this particular 
poset. Thus POL-SAT is also m-hard for this poset. Given a set of inequations, we must translate them 
into a form where no upper bounds w < p appear for variable w and constant p. We add two new variables, 
W. and Wb , and the new in­ equalities {a < W., b < Wb}. We then translate all upper bounds (which are 
disallowed in POL-SAT) as: [w<a]={w <w.} [w< b]={w<wb} If c is used as an upper bound on some variable 
w , then simply replace w by c in the entire set of inequa­tions, and similarly for d. Thus even for 
fixed posets with aa few as four elements POL-SAT is NP-complete. Through the reduction stated formally 
in Lemma 4.2, we therefore have the result that I?3 is m-hard even for fixed posets. Theorem 4.4 F3, 
F2, and F1 are rw-hard for a jixed posets with four elements. Note that the above m-hardness results 
for POL-SAT and PO-SAT make critical use of non-lattice partial orders. In fact, we have the following 
properties: Proposition 4.5 PO-SAT is solvable in polynomia[ time over a lattice. Proposition 4.6 POI,-SAT 
is sotvable in polynomial time over a lattice. These results lead to a polynomial algorithm for L3, as 
stated later in Proposition 6.2. At an intuitive level problem V3 allows one to complete the given partial 
order into a lattice, leading to a similar polynomial time algorithm for V3 as well. Thus the NP-hardness 
results of this section apply only to the problems F1-3, and do not directly apply to L1-3 nor to VI-3. 
 5 Subtype Inference in PSPACE In this section we investigate the computational com­plexity of problems 
V1 and L1. We give a PSPACE algorithm for V1 and then show that the same algo­rithm also solves problem 
L1. The algorithms proposed in earlier papers to solve V1 (or Fl) suffer from two sources of inefficiency. 
The first source of inefficiency is the non-lattice structure of subtype orders in the signature. These 
lend a cer­tain NP flavor to the decision problem. The second source of inefficiency is the MATCH (and 
SIMPLIFY) al­gorithm, which forces subtype relationships between complex types into sets of subtype relationships 
be­tween atomic types. The expansion of type inequal­ities c(to the leaves) causes an exponential blowup 
in the inequalities, and thus causes previous algorithms to use exponential space and time. To overcome 
this obstacle, we develop a data structure of linear size and associated naming convention for new type 
variables which allow us to represent the required subtype re­lationships succinctly. Using this approach, 
we may decide typability in PSPACE. Rather than present a deterministic PSPACE algo­rithm directly, we 
give a nondeterministic PSPACE algorithm that recognizes untypable terms. Since NPSPACE = PSPACE and 
PSPACE is closed under com­plement, this gives us a PSPACE upper bound. Our algorithm begins by building 
a proof up to uses of Sub. As discussed earlier this amounts to a normal form for the type derivation 
proof, except that the proofs above Sub are left incomplete. Next the DAG representation of the Curry-type 
of the term is com­puted, as if the type of each constant and variable were renamed with new type variables 
at each leaf occur­rence. In [Wan87] an algorithm similar to ours up to this point is presented. However, 
in our algorithm, the Sub rule presents a new kind of relation, and we ac­tually solve the equations 
generated by the algorithm in [Wan87] with unification, producing a DAG which represents the types of 
all subterms. Note that the unifications performed at this step never fail, due to type renaming, as 
is the case in [Hin89]. At each leaf a constraint u ~ r is generated by the Sub rule, which we encode 
as a dashed arc on the DAG. Note that these inequalities (represented by dashed arcs) may in­volve terms 
such as n + /3 containing function types. We will call the arcs forming the original DAG descen­ dent 
arcs and dashed arcs due to uses of the Sub rule sub arcs. We say a term Al is Curry-typable over signature 
X = (B, S, T) , if M is typable over the signature X = (1?, S , T) , where S is the complete relation 
(all atomic types are related, and thus all atomic types are interchangeable). Lemma 5.1 Given a term 
M , possibiy containing constant symbols from some signature X = (B, S, T) , then M is Curry-iypable 
over E if and only if there is a provable typing statement C, A 1-M :0 over 22 where C may have any relationship 
to S. Lemma 5.2 Given a Curry-typable untyped lambda term M , possibly containing constant symbols from 
some signature X = (B, S, T) , then VI is solvable for M if and only if the most general typing statement 
C, A k M : u for M provable with respect to .X is such that Qbl, bz. if CUSt bl < b2 then S t bl ~ b2. 
Thus there are two kinds of type failure for V1. The first is failure of Curry-typability, which occurs 
when a type variable is required to match its own an­cestor or descendant because of coercions, For ex­ample, 
terms with self application, such as h.(z z) , are impossible to type. The second type of failure, implication 
of nonexistent coercion, occurs if there is some chain or sequence of implied coerci~ns 19i < al , al 
~ U2, . . ..un_1 ~ CTn,Un < Oj such that it is not the case that St-Oi ~ (?j . The first type of failure 
is relatively easy to detect, and may be checked in linear time. If one considers the sub arcs of the 
DAG to be undirected, the first type of failure occurs if and only if the DAG contains a cycle which 
contains at least one descendent arc. This condition may be checked in linear time by considering the 
the sub arcs to be equations between parts of the DAG made up of descendent arcs. The DAG and the The 
algorithm then repeatedly guesses types and (3@--m paths in this way such that for guess i , the relation 
Ti _ 1 ~ ri is implied. Finally, the algorithm guesses types such that rn <02 is implied. If this algorithm 
succeeds in all these steps, the term is not t ypable. That is, the algorithm as described nondeterministi­ 
cally checks nun-typability in PSPACE. As an example of the second type of failure, con­  @n) Figure4: 
Untypable Self Application s DAG sider the attempted derivation of a type for the resulting unification 
probiem are of linear size, and unification may be performed in linear time [PW78]. For example, consider 
the attempted typing of ~x.(x x) shown in Figure 3. This is the unique syntax­directed proof, up to II 
and A , which are left in­complete by the algorithm. However, the coercions a ~ /3 -+ cr and a ~ ~ have 
a derived inconsistency. That is, ~ must match /3 -n, and thus no sub­stitution of types for type variables 
can satisfy those inequations. Figure 4 displays the two color DAG our algorithm builds for this term. 
The DAG which rep­resents the type of all subterms is represented with descendent arcs shown as solid 
arcs in Figure 4. The dashed arcs in that figure represent sub arcs. Assuming that the first type of 
failure does not oc­cur, we must detect the second. One could imagine converting all subtype relations 
between non-atomic types into relations between atomic types, and then searching for a solution to that 
easier problem. How­ever, an exponential number of atomic subtype rela­tions may be generated by such 
a procedure. The algorithm presented below avoids this blowup. For each type variable a , we use the 
notation al and a, , where their relationship with a is defined by a = al + ay . This is simply notation; 
we do not explicitly construct all such type variables, and the notation is meaningless if a is of atomic 
type. We define a path to be a string on the alphabet {1, r} , and we use o as path concatenation. We 
define the relation implied by a sub arc from a to c through path p as follows. If p is empty, then the 
sub arc simply signifies that a < a . If p = r op , then the sub arc implies the same relation as the 
sub arc from c+ to CT through path p . If p = 10 p , then the arc implies the same relation as the arc 
from al to CYl through path pl . Note that because of the antimonotonic Arrow rule, the sub arc in the 
1 case has changed direction. The algorithm begins by guessing two atomic type constants 61 and 02 which 
are not in the relation 01 <02 in the given signature. Then the algorithm guesses two types c and a and 
a path p such that there is a dashed arc from u to a and the relation im­plied by this arc from u to 
CY through p is 01 < T1 . Or the algorithm guesses that ~1 is a type constant Oi such that S t-61< Oi. 
term (( Av.(odd? (v 5.7))) (kc.x)) in the signature with three types constants, int , real, and bool, 
with the only subtype assumption enforcing that int~ real , and two constants, odd? : int + bool and 
5.7: real . We give the derivation in parts, leaving the proofs numbered 1.. .4 incomplete, just as our 
algorithm would do, in Figures 5, 6, and 7. We may now see that this term has no type satis­fying the 
restrictions of V1. From the required sub­type relation marked 1 in the above proof display, int --+ 
bool < ct + ~ . From this, by the arrow rule, we must have booi ~ ~ and a < int . Similarly, from the 
required subtype relation marked 2 in the above proof display, a --+ -y < r --+ a , which implies y ~ 
a and ~ < a . Using these subtype relations, and those from 3and 4, real ~ T and ~~7, wemay build the 
following chain of subtype relations: We now describe how our algorithm would discover this inconsistency 
with the given partial order. First, it would build the proof up to the applications of Sub, creating 
the DAG as described above, a fragment of which is represented in Figure 8. The algorithm then guesses 
that a derived inconsistency lies in the sub­type relation real ~ int . It then guesses the sub arc from 
~ to real , and the empty path. This implies real ~ r. It then guesses the sub arc from r --+ a to a+ 
~ ,and the path i . This implies r ~ a. The next guess is the sub arc from ~ to u , with the empty path, 
implying a ~ y . Then the sub arc from ~ + a to o --+ -y is guessed again, this time with path r , implying 
7 ~ a . The last guess is the sub arc from a--+ /3 to int --+ bool , with path r, implying a ~ int . 
The last step is through a part of the DAG not repre­sented in Figure 8. Thus the algorithm finds a chain 
of types which together imply real ~ int , contradicting the given signature. Theorem 5.3 Problem VI 
is solvable in PSPACEi. Proof. The untypability algorithm described above operates in polynomial space, 
since the prepro­cessing phases building the DAG may be completed in linear time and space, and the nondeterministic 
sequence of choices can be made with only linearly bounded storage space, since the depth of the curry­type 
is linearly bounded. Because PSPACE is closed C,{z:a}kx:darckdhu Sub c,{x:a}Fx:av r Cta<p Sub c,{z:cr}F3:@+a 
C,{x:a}t-z:p APp C,{%: a}t(zz):u Abs c, Ol-Ax.(z2):cf-+u Figure 3: Untypable Term s Attempted Derivation 
C,{v:o--+~} t odd? :int+boolco st C,{v:n+y} CUSt l-odd? :~+P 1 int--+booi~ a+/3 sub Figure 5: Partial 
derivation A c,{v:a+~}+v:a+y Var C,{v:a+y}l-v:r+a Cusl-o-+ -(-jr+a 2 c,{v:a+7} SUb C,{v:o+y} E(v5.7):cl 
t_5.7:reaic0nst c,{v:u+7} 3 CUSl_rea/<r l-5.7:7- Sub APp Figure 6: Partial derivation H C,{v:u+-y} A 
todd?:w+~ C, {V : a+y} C,@ } (~v.(odd? II c,{v:a+7} h(v5.7):ck t­(odd? (V 5.7)) :~ (V 5.7))): (a+-y) 
+~ C,@ t-(( Av.(odd? (V 5.7))) App Abs (~X.X)) C,{ Z:a}EHvarCu S\a c,{x:a}Ez: y c, OtAx.x:u+~ : @ 4 
ST Ab, Sub AI Figure 7: Whole derivation Figure 8: Fragment of Untypable Term s DAG under complement, 
this demonstrates the existence of 6 L3,F3 are Polynomial a PSPACE algorithm. D We now turn our attention 
to problems L1-3. In this section we present a linear time algorithm for L3, the restricted case of problem 
F3 where the given Lemma 5.4 L1 and F1 are solvable for term M over subtype order is a lattice. This 
algorithm also extends signature 2 if and only if M is Curry typable and to F3 where the order is the 
sum of partial orders, each C, A } M : u, the most general typing statement for with its own top element. 
That is, partial orders with M, is such that C is satisfiable over X . the property that there is a unique 
least upper bound of the upper bounds of any element. Also, this al- Proof. Immediate from the problem 
definitions and gorithm extends to V3 over any partial order. Since Theorem 2.1. The key here is that 
if C is satisfi­problem F3 is Iw-hard in general, we see that minor able over E, then there is some substitution 
R and assumptions about the subtype order permit great re­ provable instance 0, RA 1-M : RF. m ductions 
in the computational complexity of the as- The following lemma states that problem L1 is es­sociated 
decision problems. Also, small amounts of sentially the same as problem VI if the partial order flexibility 
in the subtype order (V3) permit similar re­ is already a lattice. ductions in the computational complexity. 
Lemma 5.5 If (B, S) forms a lattice and C is a In [W089], it is claimed that subtype inference may set 
of atomic subtyping assertions, possibly involving be performed in low order polynomial time if the 
given constants from B , then C is satisfiable over (B, S) subtype order in the signature happens to 
be a tree. if and only if for every pair of constants bl , bz from However, we have found examples where 
the algorithm B,if CUStb1~b2 then St-bl<b2. suggested in [W089] uses exponential space and time. Proof. 
Suppose that for every pair of constants Lemma 6.1 Let X be a signature in which all con­ bl, b2from 
B,if CUSkb1<b2 then Skbl< stants have atomic type. If M is an untyped term b2 . We show C is satisfiable 
by giving a satisfying over X , then in the most general typing for M , all assignment. For each variable 
z in C , let LB(s) be subtype assumptions have the form p < w , w < w , the set of elements b of B such 
that C US 1-b< x . where w and w are variables, and p is a type con- We assign variable x the least upper 
bound of the stant from E . set .LB(z) . This upper bound exists since (B, S) is a lattice. To show that 
this assignment satisfies C, we consider three cases: Proposition 6.2 L3 is solvable in linear time. 
 For b< z,it is the case that bc LB(z) ,so ~ Proof. Again, we solve the decision problem without is assigned 
an element of B that is greater than producing a most general typing. By Lemma 6.1, the or equal to 
b. only relevant subtyping constraints are lower bounds For z < y, we have by transitivity that LB(z) 
C on the types of terms. Thus one could choose to build LB(y) , so y is assigned an upper bound of all 
types of subterms from the topmost type constant. LB(x) , so x is assigned some element of B that Since 
all types are subsumed by the topmost type con­is less than or equal to y. stant this choice will not 
lead to any type errors which are not inevitable. One may view this as collapsing the For x < b , we 
have to use the hypothesis of the entire poset down to the single topmost point. lemma. By hypothesis, 
b b . b E LB(x) , then Thus our algorithm can be described as follows: C U S 1-b < b and so b ~ b. Therefore 
the least replace all constants in the given term by a single upper bound of LB(z) 1s less than or equal 
to fixed constant of topmost type and then apply the b. well-known linear algorithm for determining 
Curry­_ typability. If the resulting term is Curry-typable, then the given term is typable with subtypes. 
If the modi- Theorem 5.6 Probtems Ll, L2, and L9 are solvable fied term is not Curry-typable, then the 
original term in PSPACE. is not typable. _ We now consider a somewhat more general problem. A connected 
component of signature subset Proof. We begin by observing that the only proper­ ties specific to problem 
V1 that are used in the proof is a of the elements of the signature which is connected if the of Theorem 
5.3 are stated in Lemmas 5.1 and 5.2. subtype relation is taken to be bidirectional. Since Lemmas 5,4 
and 505 characterize problem L1 in exactly the same way, the proof of Theorem 5.3 also shows that L1 
also may be solved in PSPACE. By the Proposition 6.3 F3 is solvable in linear time if every obvious conservativity, 
we have the result for L2 and connected component of the signature has a topmost L3. _ element. Proof. 
Similar to 6.2. In this case, replace each con­stant of type T with a constant of the topmost type connected 
to r. One may view this as collapsing all connected components into their individual topmost elements. 
The result is a completely flat partial order, over which Curry-typability works in linear time with 
small modification. _ Special cases of this class of (easy signatures in­clude flat partial orders, lattices, 
trees, forests, etc. Proposition 6.4 V3 is solvable in linear time. Intuitively, V3 allows new elements 
to be added to the signature. Thus we may simply add a top element to the signature, and then check typability 
as above in Proposition 6.2. Thus F3 is NP-hard over certain partial orders, but V3 is solvable in linear 
time over any partial order. 7 Conclusion We identify and study several variations on the type inference 
problem for languages with subtypes. We give a single NP lower bound for three of these prob­lems, improving 
the previous lower bound of [W089]. Since the size of the most general typing of a term may be exponentially 
larger than the given term, any algorithm which prints the most general typing with subtypes must take 
exponential time. However, we show that it is possible to determine whether a term is typable at all 
using only PSPACE for VI 3 and L1 3. We do not know whether this algorithm can be im­proved to run in 
NP, and have no useful lower bound on VI 2 or L1 2. The most promising indication for practical appli­cations 
is that typing over special partial orders (such as lattices) and varying subtype relations (as would 
arise in languages with subtype declarations) may be far simpler than typing over arbitrary partial orders. 
We have seen this in the difference between problem F3 and L3 and V3: while L3, over arbitrary partial 
orders, is NP-hard, the restriction, L3, to lattices may be solved in linear time and so may the correspond­ing 
problem, V3, for languages with varying subtype relations. These results show that the complexity of 
type inference is sensitive to the kind of subtype rela­tion that may occur in a given programming language, 
and whether this order may vary. In designing type inference algorithms for languages with type declarations 
(and therefore varying subtype relations), we believe it will be useful to take into ac­count the ways 
that the subtype relation may change. To give an concrete example, suppose that in language L subtype 
declarations may only add new subtypes, not supertypes of existing types. Then in defining a type checker 
for language L, we would like to reject any declaration that will only make sense when su­pertypes of 
existing types are added. In general, we expect to find typing problems that are special cases of both 
our fixed and varying subtype problems, with only certain kinds of subtype relations definable by programs, 
and only certain kinds of variations achiev­able by additional type declarations.  References <RefA>[FM90] 
Y. Fuh and P. Mishra. Type inference with sub­types. I%eor. Computer Science, 73, 1990. [Hin89] J.R. 
Hindley. BCK-combinators and linear A ­terms have types. Theor. Comp. SCZ., 64:97­105, 1989. [Jat89] 
L. Jategaonkar. ML with extended pattern matching and subtypes. Master s thesis, MIT, 1989. [JM88] L. 
Jategaonkar and J.C. Mitchell. ML with ex­tended pattern matching and subtypes. In Proc. ACM Symp. Lisp 
and Functional Programming Languages, pages 198-212, July 1988. [KMM91] P.C. Kanellakis, H,G. Mairson, 
and J.C. Mitchell. Unification and ML type reconstruc­tion. In Computational Logic, essays in honor of 
Alan Robinson, page to appear. MIT Press, 1991. [Mey88] B. Meyer. Object-Oriented Software Construc­tion. 
Prentice-Hall, 1988. [Mit84] J.C. Mitchell. Coercion and type inference (summary). In Proc. Ilth A CM 
Symp. on Pr-in­ciples of Programming Languages, pages 175 185, January 1984. [Mit91] J.C. Mitchell. Type 
inference with simple sub­types. J. Functional Programming, 1(3):245­286, 1991. [PT91] V. Pratt and J. 
Tiuryn. Satisfiability of inequa­tions in a poset. Manuscript, October 1991. [PW78] M.S. Paterson and 
M.N. Wegman. Linear uni­fication. JCSS, 16:158-167, 1978. [Str86] B. Stroustrop. The C++ Programming 
Lan­guage. Addison-Wesley, 1986. [T1U91] J. Tluryn. Solving term inequalities is PSPACE hard. Manuscript, 
October 1991. [VJan87] M. Wand. A simple algorithm and proof for type inference. Fundamental Informaticae, 
10:115 122, 1987. [Wan91] M. Wand. Personal communication, 1991. [W089] M. Wand and P. O Keefe. On the 
complexity of type inference with coercion. In Proc. ACM Conf. Functional Programming and Computer Architecture, 
pages 293-298, 1989.</RefA>  
			


 107 A Multi-Layer Client-Server Queueing Network Model with Synchronous and Asynchronous Messages 
S. Ramesh and H. G. Perros Computer Science Department and Center for Advanced Computing and Communication 
North Carolina State University Raleigh, NC 27695 Abstract server system has been considered by Woodside, 
et al ([3] and [a]). Specifically, they developed and analyzed a queueing network model referred to as 
the Stochastic We analyze a multi-layered queueing network that mod-Rendezvous Network (SRN) model. In 
an SRN model,els a client-server system where clients and servers com- entities called tasks represent 
hardware or software ob-municate via synchronous and asynchronous messages. jects which may execute concurrently. 
A single task does The servers are organized in groups such that they form not have any internal concurrency. 
Tasks communicat,e a multi-layered hierarchical structure. The queueing net-through synchronous messages. 
A task that accepts mes- work is analyzed approximately using a decomposition sages from other tasks, 
i.e., a server task, executes two algorithm. Numerical tests show that the approximation or more service 
phases. The first phase has to do with algorithm has a good accuracy. message processing while the server 
acts on its own in the remaining phases, doing, for instance, house-keeping. A server task, during any 
phase, may send a synchronous message to another task. The SRN model is analyzed 1 Introduction using 
an MVA (Mean Value Analysis) approximation in order to obtain contention delays. I he Common Object Broker 
Request Architecture Rolia and Sevcik [4] proposed the Method of Layers (CORBA) defines a standard for 
distributed object com-(MoL) approach for modelling a distributed software sys- puting. It specifies 
the interfaces and charactleristics for tem. Software tasks are organized into Iz layers. A task the 
Object Request Broker (ORB) which delivers re-in layer 1 may only send synchronous messages to tasks 
quests to objects and returns responses to the clients belonging to layer I -1 and may receive synchronous 
making requests. The key feature of the ORB is its messages to tasks belonging to layer 1 + 1. This queue-transparency 
in facilitating client-object communication. ing model is analyzed by decomposition, considering two 
generally, the ORB automates many tasks such as object adjacent layers of tasks at a time. A separate 
queue-registration, object location, parameter marshalling and ing model is developed to represent the 
contention in the unmarshalling, framing and error handling. For a review CPU and the I/O devices. The 
two models are then com-of CORBA, see Vinoski [l]. bined using an iterative algorithm to obtain the mean 
response time. Typically, distributed objects that use an ORB or any other client-server interface, 
communicate with each The multi-layered queueing network model analyzed other by means of synchronous 
and asynchronous mes-in this paper consists of N clients and several layers of sages. When a client object 
issues a synchronous mes-servers arranged into a multi-layered structure based on sage, it gets blocked 
(i.e., it cannot receive further CPU their messaging pattern. Each of the clients may send time) until 
it, receives a response from the object to which synchronous or asynchronous messages to any of the M1 
t,he request was sent. On the other hand, it does not get servers in the first layer. Each of these A41 
servers, while blocked when it issues an asynchronous message. processing a synchronous or asynchronous 
message is- sued by a client, may in turn issue a synchronous or In this paper, we analyze a multi-layered 
queueing asynchronous message to a second layer of hilz servers. uetwork model of a client-server system 
where clients and Likewise, each of the M2 servers in the second layer, while servers communicate by 
means of synchronous and asyn- processing a message from a first layer server, may issue chronous messages. 
This is a generic model and it is not synchronous or asynchronous messages to a thzrd layerassociated 
with a specific ORB or any other client-server of MS servers, and so on. Thus, the messaging pattern 
implementation. has a hierarchical structure. There may be up to R hi-Modelling the performance of messaging 
in a client- erarchical levels of messages and the servers are grouped Permission to make digital or 
hard copies of all or part of this work for personal or classroom use is granted without fee provided 
that copies are not made or distributed for profit or commercial advantage and that copies bear this 
notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or 
to redistribute to lists, requires prior specific permission and/or a fee . WOSP98, Santa Fe, NM(c) 1998 
ACM l-58113-060-O/98/00... $5.00 Requests Clients , w Layer-1 Servers Asynchronous -i-i-G /7-Y41FA(Ie~ 
Layer-2 Servers Asynchronous w < Requzts - Synchronous Synchronous Figure 1: A Client-Server Network 
with Two Layers of Servers accordingly into different layers. A Layer-l server may receive a synchronous 
or an asynchronous message only from the N clients. A Layer-z server, 2 5 i 5 R, may receive synchronous 
or asynchronous messages only from a Layer-(i -1) server. Each client and each server at any layer is 
represented in the queueing network by a queue. Specifically, we model the queue of requests at each 
client and the queue of messages at each server. As will be seen, the pattern of synchronous and asynchronous 
messages issued by a client or by an intermediate server can be quite general. An example of such a multi-layered 
queueing network with two layers of servers is shown in Figure 1. The paper is organized as follows. 
In Section 2, we an- alyze the queueing network under study assuming only one layer of servers. We also 
assume that the service times at each server are exponentially distributed. We analyze the queueing network 
by decomposition. Specif-ically, we decompose the queueing network into two sub- systems; the server 
subsystem and the client subsystem. The two subsystems are analyzed iteratively. As will be seen, under 
the assumption that the service times are ex- ponentially distributed, the server subsystem is a closed 
queueing network with a product-form solution. In Sec- tion 3, we extend the approximation algorithm 
to the case where the service times have a Coxian distribution. under this assumption, the server subsystem 
no longer has a product-form solution and is analyzed using an ap- proximation method. The analysis of 
the queueing net-work with a single layer of servers is used as a building block for the analysis of 
the multi-layered queueing net-work, involving any number of layers of servers. This is described in 
Section 4. In Section 5, we compare per-formance measures of the system computed using the approximation 
method against those obtained from sim- ulation in order to establish the accuracy of the approx- imation 
algorithm. The conclusions are in Section 6. 2 Single Layer of Servers: Expo-nent ial Service Times Clients 
Synchronous Figure 2: The Queueing Network The queueing network under study consists of 12 queues, each 
representing a client, linked to a single laycxt of Mi queues, each representing a server, as shown in 
Fig-ure 2. Requests arrive at each client queue; their arrival is determined by a two-phased Coxian distribution 
(( 2). and they are processed in a FIFO manner. A request rt - ceives an exponentially distributed service. 
(The appros-imation algorithm can be readily extended to allow L OI Coxian service times at clients.) 
Following a service COIII- pletion, a synchronous or asynchronous message is sent to one of the Ml servers. 
If the message is synchronous, the client gets blocked, i.e., it cannot process that request. further, 
nor can it process any other request that, may bc waiting in its queue. The client remains blocked until 
a response is received from the server. Then, the current, request either receives another exponentially 
distribut,ed service, or it, departs from the queueing network, making way for the next request. If the 
message is asynchronous, the client does not get blocked, and it either proceeds to give the request 
another exponentially distribut,ed ser-vice, or the request exits the system and the client lakes up 
the next request waiting in its queue. For presenta- t,ion purposes, we distinguish between a request 
and a nlessage. A request to a client is represented by an ex- ternal customer a.rriving and joining 
the clienf, s queue. A message (synchronous or asynchronous) is a customer sent from a client to one 
of the Ml servers. The number of services each request receives from client n follows a client-dependent 
arbitrary distribution, with a maximum number of I<,. For client n, let l/y, be the mean of the exponentially 
distributed time a re- quest undergoes processing before a synchronous or asyn- chronous message is issued. 
Also, let pn(j) be the prob- ability that a request arriving at client n issues exactly j messages, and 
let ~~,,k,~~~)be the probability that the kth message for the same request is issued to server m. I,&#38; 
y(71,k.,7n)be the probability that this message is syn- chronous. lJsing the above parameters, we can 
construct an arbitrary pat,tern of service that a request may receive at a client. Finally, let (cil 
, ah ), cu,) be the parameters of the C:! distribution of the inter-arrival time of requests at client 
11, where a;) and ~2 are the rates in phases 1 and 2 respectively, and cy, is the probability of going 
from phase 1 to phase 2. Thus, the mean inter-arrival time is 1 -L+L (2.1) x, = &#38;I) op Let us now 
consider one of the A41 servers. Synchronous and asynchronous messages are served in a FIFO man-ner. 
The service at the rnth server is assumed to be ex- ponentially dist,ribui,ed with rate pm, An asynchronous 
message, upon completion of its service, departs from t,he network, whereas a synchronous message returns 
to it,s originating client, upon which the client becomes un- blocked. The queueing network described 
above falls into the category of queueing networks with blocking. In general, queueing networks with 
blocking do not have a closed- form solution. In view of this, they have been analyzed using various 
decomposition algorithms (see Perros [5]). In the queueing network considered in this paper, blocking 
of a client occurs only when a synchronous mes-sag<> is issued. The client remains blocked until a re- 
sponse is received from the corresponding server. This type of qucueing network wit,h blocking has not 
been studied before in the open literature. We will analyze the queueing network approximately using 
a decomposi- tion scheme t,hat can be viewed as a generalization of the well-known two-node decomposition 
algorithm for tandem queueing networks with blocking (see Perros [5] p. 110). In Section 2.1, we first 
present the approxi-mation algorithm assuming only synchronous messages. We then extend the algorithm 
to both synchronous and asynchronous nlessages in Section 2.2. Clients Figure 3: The Server Subsystem 
 2.1 Synchronous Messages We decompose the queueing network int,o two sub systems; the server subsystem 
and the client subsystrrtc. The server subsystem, shown in Figure 3, is a clos4 queueing network consisting 
of Ml server queues and l\ clients, but without the queue in front of each client,. As will be seen, 
the service time at each client is modific>tl to account for the lack of knowledge about its queue>. 
The client subsystem consists of N nodes represr,nl- ing the client queues. The service time at each 
client. is augmented appropriately to account for the blocking tl<>-lays due to synchronous messages. 
Each of t,he N clirnt queues is analyzed separately. The analysis of each subsystem requires infornlat 
ioll that can be obtained by solving the other subsyst.enl. This is resolved using an iterative scheme. 
We proccrld to examine each subsystem in detail. 2.1.1 The Server Subsystem This is a closed queueing 
network consisting of N CIIS-tomers, each representing a client. As will be seen, this network is of 
the BCMP type, and hence has a product- form solution (see Lavenberg [6]). Client n is associated with 
a chain consisting of I\,, classes, where K, is the maximum number of messages that may be issued by 
client n while processing a r( -quest. Thus, in the server subsystem, we have a tot,al of N chains, with 
I<, classes in the nth chain. Thr: IISI of chains and classes permits us to route a synchronous message 
in a server back to the originating client,. Wt, shall denote the class of a synchronous message by the, 
pair (n, Ic), where R is its chain and k is its class withiu the chain. Let us consider client n and 
assume that it, just, started serving a new request. This is reflected in the server subsystem as client 
n being busy with a class (n, 1) customer. The customer receives an exponent8iall>   +gsj&#38;~ CX 
a: for class (n, 1) b: for class (n,k), k > 1 Figure 4: The Service Process at Client Queues distributed 
service with mean l/v, and then it issues a synchronous message to server m. This is represented in the 
server subsystem by the client n becoming idle and its (n, 1) class customer joining the mth server queue. 
When the message finishes getting processed at the mth server, one of the following events can occur: 
l The corresponding request needs further processing. This event is represented in the server subsystem 
by the customer changing class from (n, k) to (n, Ic+ 1) and going back to the nth client. l The request 
completes its processing and exits the queueing network. This is represented by the cus- tomer changing 
class from (n, Ic) to (n, 1) and going back to the nth client. In the original system, when a request 
departs from a client, there could be another request waiting in the queue, in which case, the client 
starts processing it im-mediately. Alternatively, the queue could be empty, in which case, the client 
waits until a new request arrives. In our server subsystern, we do not keep track of the queue and of 
the state of the arrival process of requests at each client. Hence, we augment the service time of class 
(n, 1) customers at the client node to account for this idle pe- riod. The augmented service process 
of requests has a phase-type distribution and is shown in Figure 4a. Pa- rameters aA , c7p and (Y, are 
the same as the parameters of the arrival process of requests at client queue n. Also, /j(i) I = 1,2, 
is the probability that a request, upon com-pietion of service at its client, leaves the system with 
the client queue empty and the arrival process in phase i. Thus, the probabilities of entering each of 
the three ser- vice phases are pp , /?z and 1-/32)-p:) for a customer of class (n, 1). Observe that the 
server subsystem can be seen as a closed queueing network consisting of N infinite server queues, one 
per client, with class-dependent service, and Ml FIFO multiclass queues, each with a class-independent 
exponentially distributed service. There arc N chains, each containing one customer, and chain n COII-sists 
of Ii , classes. Thus, our queueing system is one of the BCMP type and admits a product-form solut,ion. 
 The server subsystem can be solved once we know O!, ) and /3i2), n = 1,2, .., N. These parameters are 
obtained from the solution of the client subsystem. For thr first time, we solve the server subsystem 
assuming some initial values for these parameters. Of interest is the probability distribution of thr 
nun-ber of customers that a customer of class (n, k) sees in the server queue m, upon service completion 
at client queue n. Define Pn,k,m(i) as the probability t,hat this customer sees i customers in server 
queue m. Lcl Gn,k,m(z) = xi pn,k,m (i) be its z-transform. Then, the Laplace-Stieltjes transform (LST) 
of the sojourn timp distribution of the customer of class (n, Ic) is given by Cn,k(S) = &#38;,k(S)&#38;,k(S), 
where &#38;,k(S) = &#38; and (The sojourn time of a customer is defined as the t.ime elapsing from the 
moment the customer joins the queue to the moment it departs from the queue.) Further, de- fine &#38;J(s) 
= &#38;J(S) and xn,k(S) = xy,k-l(+%,k(+ for Ic > 1. Then, the LST of the effective service time distribution 
of a request in client queue n in the client subsystem is given by : (2.3) k=l In order to find Pn,k,m(.), 
we solve the closed queueing network with zero customers in chain n and find Qn,m(i)3 the time average 
probability that there are i customers in the mth server queue when there are zero customers iu chain 
n. From the Arrival Theorem (see Lavenberg [7]), we have Pn,k,m(i) = Qn,m(i). Hence, it also follows 
that. P oes not depend on k, the class of the customet di?i?~ d, chain. Thus! from the server subsystem, 
we obtain the effec- tive service time distributions Y,(.), n = 1,2, .., N which are used in the client 
subsystem. Next, we solve the client subsystem, from which we obtain new values for the parameters /?:I, 
i = 1,2, n = 1, .., N. 2.1.2 The Client Subsystem The client subsystem consists of N independent single 
servers, one per client queue. The service time distri-bution for queue n is given by the LST Yn(.), 
obtained by solving the server subsystem, The arrival process is the same as the arrival process of requests 
at the corre-sponding client queue. Hence, each queue can be solved as a GI/G/l queue. In order to simplify 
the analysis, we approximate the service time distribution by a Cz using the method of moment-matching 
see Perros [5]). Each queue is then solved as a Ca/C2 I 1 queue, using Neuts algorithm [8]. From this 
solution, we can com- pute the probability /?ci)i, i = 1,2, that upon departure of a request, the queue 
is empty and the arrival process is in phase i. We note that it is not necessary to obtain the entire 
queue length distribution in order to calculate fi(X ). The entire queue length distribution is calculated 
in the final step when the approximation algorithm has converged. 2.2 Synchronous and Asynchronous Messages 
We now consider the original queueing network with both synchronous and asynchronous messages. We assume 
that when client n issues the kth message to server m, with probability q(n,k,m), it is a synchronous 
message, and with probability 1 - q(n,k,m)r it is an asynchronous message. We analyze the queueing network 
using a service re-ductzon t3echnique. That is, we subtract the rate of ar-rival of asynchronous messages 
from the service rate of each server. We then solve the server subsystem and the client subsystem as 
above. We now proceed to discuss each subsystem in detail. The server subsystem is constructed and analyed 
as before with some minor modifications in order to account for the asynchronous messages. Specifically, 
the service rat,e at the mth server is modified as follows: N K, -c An C(l-q(,,k,m))T(,,k,rrL) , 1 5 
m 2 Ml TL=l k=l  (2.4) where A, is given by (2.1). we now analyze the server subsvstem with modified 
branching probabilities. In the origi na1 queueing network, one of tKe%ollowing two events may occur 
after an asynchronous message is issued by the client. The request may exit from the queueing network 
or it may receive another service at the client. The former event is represented by the customer changing 
class from (n. k) to (nl 1) and going back to the nth client node. The lat,ter event is represented by 
the customer changing class from (n, k) to (n, k+ 1) and going back to the nth client node. In view of 
the above changes in the routing patterns of the server subsystem, (2.2) is rewritten as follows: B,,,k(S) 
= 2 l-4(n,k,n1)+4(n,k,m)r(~,k,~)G~,k,~(s -) + , 77l=l m (2.5) Finally, the client subsystem involves 
solving the same A: independent C2/C2/1 queues, but with the effective service time calculated using 
2.5. 3 Single Layer of Servers: Cox-ian Service Times So far, we have assumed that the service time at, 
each server is exponentially distributed with a chain-independent mean service t,ime. In this section, 
the al-gorithm is extended to the case where the service time at each server has a Coxian distribution 
with chain-dependent parameters. We note that the server subsyst,em does not have a product-form solution 
if the processing time at each server has a Coxian distribution. Therefore, we analyze the server subsystem 
approximately using an algorithm by Baynat and Dallery [9]. This algorithm is an extension of Marie s 
algorithm [lo] , which was devised to analyze single-chain closed queueing networks with Coxian ser-vice 
times. Baynat and Dallery extended this algorithm to allow multiple chains and chain-dependent Coxian 
ser-vice times. The multi-chain closed queueing network is decomposed to single-chain subnetworks. Each 
subnet- work is analyzed in isolation using Marie s algorithm. From the solution, we obtain a state-dependent 
Poisson arrival process to each server queue for each chain. Using this arrival process, each server 
is analyzed in isolation with the same chain-dependent service times as in the original problem. The 
solution from each single-server isolated queue provides the parameters for the service time distribution 
at the corresponding server in each sin- gle chain subnetwork. The analysis of subnetworks and isolated 
queues proceeds in an iterative fashion until con-vergence. Below, we describe briefly how this algorit,hm 
was applied to analyze our server subsystem, first assum-ing only synchronous messages, and subsequently 
assum-ing both synchronous and asynchronous messages. The client subsystem is analyzed following the 
same argu-ments as in Section 2. Therefore, in this section, we focus only on the analysis of the server 
subsystem. 3.1 Synchronous Messages Let us consider the server subsystem described in Sec-tion 2. Each 
client n is associated with a chain con-sisting of K , classes, where K, is the maximum num-ber of messages 
that client n may issue while processing a request. Each chain contains exactly one customer. This customer 
circulates between the nth client and the Ml servers, changing classes as described in detail in Section 
2.1.1. Let (Bi~)m),Bi~)m),~(72,m! be the chain-dependent parameters of the Cz distribution of the pro- 
cessing time at server m of a synchronous message issued by client n. The closed queueing network is 
decomposed into 1% single-chain closed queueing subnetworks. Each subnet- work consists of the Ml server 
queues and one client, as shown in Figure 5. There is only one customer in each subnetwork. Let us consider 
the nth subnetwork corre-sponding to the n th client. Let J?X(,,k,,) be the mean Servers Figure 5: The 
Single-Chain Closed Sub-Network for Chain rz service time of a class k customer at server m. (This mean 
is calculated iteratively, as will be seen below.) Also, let Ycn,k) be the mean service time of a class 
k customer at the ntla client. Then, the arrival rate of customers of class k at server queue m, k = 
1,2, ., Ii ,, conditioned on the queue having 0 customers of chain n is given by: r(%k,m) h(n,k,m) = 
ck &#38;I T(,,k,,)EX(wk>,) + Ck %,k) (3.6) Since messages from the nth client are synchronous, the arrival 
rate of class (n, k) customers at queue m, con-ditioned on the queue having i customers of chain n, is 
0 for i > 1. Following similar arguments, we calcu-late the arzval rate of class k customers, A(,,k,,) 
to the mcth) server queue, m = 1,2, .., Ml for each subnetwork 71 > n = 1,2, .., N, and for each k = 
1,2, .., Ii ,. Each server queue m in the original server subsystem is then analyzed in isolation as 
a multi-class queue with state-dependent Poisson arrivals and class-dependent Coxian service times. Specifically, 
there are N chains, where chain n has K, classes, n = 1,2, ., N, resulting in a to- tal of Cr K , different 
classes. The arrival rate of each class (7~, k) is A(n,k,m)r and its service time has a Cz dis- e(2) 
tribution with parameters (et: ,), (n,n), u(~,~). All cus-tomers are served in a FIFO manner. Solving 
this multi- class queue is the most computationally intensive part of the algorithm. Since obtaining 
the exact solution is infeasible even for a small number of chains and classes, the queue is analyzed 
approximately, assuming a random scheduling policy. That is, when a departure leaves behind a non- empty 
queue, the next customer for service is selected randomly from those in the queue with the same prob- 
ability. Under this policy, we need not keep track of the class of the customer at each position in the 
queue, but only the number of customers in each class that are present in the queue. The dimensionality 
of the problem is further reduced by using an aggregation of chains. I o be specific, all chains, except 
say chain n, are aggregat,catl into a single chain. The resulting two-chain system is analyzed numerically 
by solving the underlying MarkoL process. From this, we calculate the mean sojourn t,inlc\ EX(n,k,m) 
that a class k customer in the nlh chain spends in the queue, waiting for and receiving service. We rrpcnt 
the above aggregation for each chain n, n = I( 2, , IV. The details of the analysis of this multIi-class 
queue arr given in Ramesh and Perros [ll]. Having thus obtained all the mean sojourn t,inlc s Ex(~,~,~), 
n = 1, 2, .., N, k = 1,2, .., Kn and 7n = 1,2, .., Ml, we return to our calculation of thr arrival rates 
A(n,k,m) given by (3.6)). We recomput,e A(n,k,nl) iIf- ter we update each mean service EXc,,k,,) to Et,n,P,,,LIs 
fork=1,2 ,.., Ii ,,n=1,2,.,Nandm=l, L ,,,, 1Vl1. LZ r then proceed to analyze each multi-class queue 
in isola- tion as described above. This procedure is repeated un-til values obtained from successive 
iterations converge . Upon convergence, we obtain the first three mon1ent.s of class (n, k) at server 
m. From these values, the first three moments of the effective service time of a request, at a client 
n may be computed. Using moment mat#ching, we approximate the effective service time by a Cs distri- 
bution which is then used to construct the corresponding client, subsystem.  3.2 Synchronous and Asynchronous 
Messages As in the case of the exponential service times, we rc- move the asynchronous messages from 
the server sub system, The delays due to asynchronous messages arc compensated using the service reduction 
approach. The, first three moments of each class-dependent, service at each server are adjusted so that 
they reflect the ill-crease in processing time due to asynchronous messagr s. be the ith moment, i = 
1,2,3, of t)l~c, Let M(l:)rc,na) service time of a class (n, k) customer at server 71). The service time 
has a C2 distribution with paranlr:t,c,rs where X, is the arrival rate of requests at client 11, T(n,k,m) 
is the mean number of messages of class k ih-sued to server m in response t,o a request at client. 1). 
and q(n,k,m) is the fraction of the above messages that are asynchronous. Using these three moments, 
we fit a new Coxian service and solve the server subsystem as described in Section 3.1.  4 Multiple 
Layers of Servers ~Yv now consider the general case involving more than one layer of servers. An example 
of such a queueing net,work with two layers of servers is shown in Figure 1. Clients issue synchronous 
and asynchronous messages only to Layer-l servers. While a Layer-l server is pro- cessing a synchronous 
or asynchronous message from a client,, it, may issue a synchronous or asynchronous mes-sage to a Layer-2 
server. A Layer-2 server, while pro-cessing a synchronous or asynchronous message from a Layer-l server, 
may issue a synchronous or asynchronous message to a Layer-3 server, and so on. Let us assume a total 
of R such layers of servers. Kach layer i consists of Mi servers, i = 1,2, .., R. The processing pattern 
at a Layer-i server, i = 1,2, .., R-1 of a synchronous or asynchronous message has the same general structure 
as the processing pattern of a request at a client,, as described in Section 2. The processing pat,tern 
of a Layer-R server is similar to that of a server in the queueing networks analyzed in sections 2 and 
3. Each Layer-i server may only send a message to a Layer-(i+ 1) server. Layer-i servers, i = 1,2, .., 
R-1, therefore act as servers to Layer-(i -1) servers and as clients to Layer-(i + 1) servers. As in 
the queueing network analyzed in Section 3, all service times are Cz with chain-dependent parameters. 
In orcler to further clarify the interaction between the clients and the multiple layers of servers, 
we follow through a sample path of the processing of a request at a client in the queueing system shown 
in Figure 1. I,et us assume that after some processing, the client is-sues a synchronous message, call 
it SM1, to a Layer-l server. The client gets blocked and the message queues up at the Layer-l server 
for processing. When the server becomes available to the message SM1, the message re- ceives a service 
following which a synchronous message, Shlz is issued to a Layer-2 server. The Layer-l server be- comes 
blocked until SM2 is fully processed at the Layer-2 server. At that moment, the Layer-l server becomes 
un- blocked and it provides another service to SM1, upon completion of which it issues an asynchronous 
message ,4Mz to a Layer-2 server. Let us assume that at that moment,, S MI is fully processed at the 
Layer-l server. Then, the client, that issued SM1 becomes unblocked. In t,he mean time, AM2 queues up 
at the Layer-2 server for processing, and after it receives its service, it departs from the queueing 
network. The client may offer another instalment of service to the request, following which it may issue 
a synchronous or asynchronous message to a Layer-l server. Let us assume that it issues an asyn-chronous 
message. Then, the client does not get blocked and if, at that moment, the request gets fully processed, 
it departs from the queueing network. Else, the request receives another service from the client, and 
so on. The multi-layered queueing network is analyzed ap-proximately using an iterative algorithm which 
is based on the solution of the two-layered queueing network. We illustrate the approximate algorithm 
using the queueing network example shown in Figure 1. We assume N client. queues at which external requests 
arrive. In response to each request, the corresponding client, say client n, may issue up to Ii , messages 
to the group of Ml Layer-1 servers. Layer-l server m, in response to a message, may issue up to J, messages 
to the group of Ma Layer-2 servers. The system is decomposed into three subsystems, the client subsystem, 
the server subsystem 1 and server sub- system 2. The client subsystem consists of the N client queues, 
and server subsystem 1 consists of the clients and Layer-l servers as in the queueing network analyzed 
in Section 2. Server subsystem 2 is obtained from Fig-ure 3 by replacing the clients and the servers 
with Layer-l servers and Layer-2 servers respectively. These three sub- systems are analyzed iteratively. 
Each iteration consists of a backward pass and a forward pass. In the backward pass, the subsystems are 
analyzed in the order: server subsystem 2, and server subsystem 1. In the forward pass, we analyze the 
subsystems in the order: client sub-system, server subsystem 1 and server subsystem 2. The algorithm 
starts with a backward pass followed by a for- ward pass. This is followed by another iteration, and 
so on, until convergence. Backward Pass: Server subsystem 2 is analyzed using the approximation algorithm 
described in Section 2, if the service times are exponentially distributed. If they are Coxian, the approximation 
algorithm given in Sec-tion 3 is used. In order to analyze server subsystem 2, we need to know the probability 
<(n,k,m) that a message of class (n, k) in the original queueing network, upon de-parture (after it has 
been fully processed), leaves the mth Layer-l server s queue empty. Given the initial values of the probability 
<(n,k,m), 1 5 k 5 ICn:,, 1 5 n < N, and 1 5 m 2 Ml, we augment the service process at the rnth Layer-l 
server in server subsystem 2 to ac-count for the time it takes for a new message to ar-rive at the mth 
Layer-l server, given that a message departed and left the mth server queue empty. Specif-ically, a new 
phase is added, with a rate of qrn and an entry probability of Cn. The quantity qrn is the arrival rate 
of messages to the m Ih Layer-l server in the original queueing network. We have qrn = &#38;n,k) &#38;r(n,k,m) 
and cm = &#38;x,k) X,r(n,k,m)C(n,k,m)~ The server subsystem 2 is analyzed with these param- eters. Subsequently, 
we calculate the first three moments of the sojourn time of messages in the Layer-2 servers (i.e., the 
time a message spends waiting for and receiv- ing service). These moments are then used to compute the 
moments of the effective service time at the Layer-l servers of server subsystem 1. Server subsystem 
1 is analyzed next. As before, let /j(i) n , i = 1,2, be the probability that in the original queueing 
network, a request at client n departs from the queueing network (after it has been fully processed) 
leav- ing t,he client queue empty and the request arrival process in phase i. Assuming initial values 
for the probabilities p(i) ,L , 1 = I, 2, and n = 1,2, .., N, and using the values for the first, three 
moments of the effective service times computed from the server subsystem 2, we can analyze server subsystern 
1 using the approximation algorithm drlscribed in Section 3. Subsequently, we calculate the first three 
moments of the sojourn time of messages in each Layer-l server queue. These moments are then used to 
obtain the moments of the effective service tirne for re- quests at each client queue. Forward Pass: 
First, the client subsystem is analyzed following the methodology outlined in Section 2.1.2. From this 
solution, a new set of values for the proba- bilities /32 , i = 1,2, n=I,2 ,.., N,iscomputed. Next, the 
server subsystem 1 is solved again using the new values for the probabilities pf , i = 1,2, n = 1,2, 
.., N. From this analysis, we calculate new values for the probabilities <~~,k,~), 1 5 k 2 I<, , 1 5 
n 5 N, and 1 5 m 5 Ml, and then the server subsystem 2 is analyzed. The algorithm executes successive 
backward and for- ward passes until the probabilities p$ and CC~,~,~) have converged. We note that in 
the forward pass, we up- date the probabilities p? and C(n,k,m~ whereas in the backward pass, we update 
the first three moments of the effective service times of the Layer-l servers and clients. Below, we 
summarize the approximation algorithm as-suming R layers of servers. Each layer T of servers con-sists 
of M? servers. Summary of the approximation algorithm: 1. Initialize: &#38;) k = 1, 2, .., Ii ,, n = 
1,2, ..M,-1 m = 1,2, ..Mv 2. Backward pass: For r = R, R -1, .., 1, do (a) Analyze server subsystem 
T (b) Calculate first th ree moments of sojourn time in each server queue for each class of message 
  3. Forward pass: Analyze client subsystem. Calculate new values for ai! , i = 1,2, n = 1,2, .., N. 
 ,p 4-p 1 Calculate to = max(,,i) ^ yjtl n(neru) n(ncw) > For T = 1,2, .., IZ, do (a) Analyze server 
subsystem r (b) Calculate new values for parameters k = 1,2,..,K ,  iii!k ,m) n = 1,2, .., M(,-l) 
m= 1,2,..,M,. 114 4. Calculate 5. Convergence test: Is max(o<r<lt) tY 5 6 ? If yes, stop. Else, return 
to St,ep 2.   5 Validat ion In this section, we examine the accuracy of t#he approx- imation algorithms 
presented in sections 2, 3 and 4, by comparing the approximation results to results obtained from a simulation 
model of t,he queueing netSwork. Fur- ther numerical comparisons can be found in Ramrsh and Perros [ 
111. 5.1 One Layer of Servers: Exponential Service Times The queueing network under study consist) of 
6 client, queues, i.e., N = 6, and 3 server queues, i.e., Ml = 3. The maximum number of messages K, issued 
by client, queue n, n = 1,2, .., N, in response to a request, was 4, and the service rate v,, of a request 
at client queue n. n = 1,2, .., N were all set equal t,o 60. The values for T(,,~,~J are shown in Table 
1. Finally, the service rat)r ,u,,, at each server m, m = 1,2, .., Ml, were all set equal to 60. We first 
consider synchronous messages only. The ar-rival rate of re uests at each client queue was varied while 
% keeping the C values constant. The initial values for X, and C value for each arrival process are 
given in Table 2. We obtain the mean delay of requests at each client queue by varying each X, in steps 
of 20% of the respective ini-tial value so that the total arrival rate of requests ranged from 12.11 
to 24.23. The mean delay consists of the mean queueing delay of the request at the client queue plus 
the mean service time which includes the mean processing and queueing delay of each synchronous message 
at l,hc> server queues. In Figure 6, we plot t,he simulation and approximation values for the mean delay 
of requests at three of the client queues; the queue that has the largest, delay, the queue with the 
smallest delay and a queue that has a medium range delay. We observe that the ap- proximate results are 
slightly greater than the simulation estimates. The 95% confidence interval of simulation was also obtained. 
Let 6 = 100 x half width of confidence mterval simulation estimate simu!ation estrnate Then the percentage 
relative error of the approximation method lies in the range (E - S, E + 5), wit,h a probabil- ity of 
0.95. If the interval (t -6,~ + 5) encloses 0, the corresponding estimate of the approximation algorithm 
lies within the 95% confidence interval of the simulat,ion. Table 3 contains the t * 6 values. We now 
consider both synchronous and asynchronous messages. The values for N, Ml, ~(,,k,~) and Ii, remain Client, 
Server queue 1 Server queue 2 Server queue 3 Queue k=l ( k=2 1 k=3 ( k=4 1 k=l 1 k=2 1 k=3 1 k=4 1 k=l 
1 k=2 1 k=3 ) k=4 Table 1: Values for ~(~,k,~), n = 1,2, Parameter Client 1 2 3 4 5 6 Initial An 3.33 
2.14 5.63 6.67 3.12 3.33 c 0.60 0.84 0.72 0.94 0.72 0.6 Table 2: Initial X, and C2 values of the arrival 
process 0 16,- rl 0 17 . *-----1IEl= Slmulamn // 0091p. I / .--12 14 16 16 20 22 24 26 Total reouest 
amval rate Figure 6: Synchronous Messages the same as above. In addition, ~(~,k,~) = 4, for n = 1,2, 
, N, k = 1,2, , II,,, and m = 1,2, , Ml. We vary the arrival rates of requests at all client queues, 
while keeping the C2 values constant. The initial values of X, and the C values are given in Table 2. 
q was set to 0.4. The mean delay at each client queue was obtained by varying each X, in steps of 40% 
of its initial value so that the total arrival rate of requests was varied from 12.11 to 36.34. The approximation 
and simulation results for client queues 4, 3 and 1 are shown in Figure 7. Also, Table 4 contains the 
values for t f 6. .., N, Ic = 1,2, .., I<,, m = 1,2, .., Ml *= Slmulamn = Approximation 0.05 10 15 20 
25 30 36 0 Total request arrwal rate Figure 7: Synchronous and Asynchronous Messages C, X, 1 CIient 1 
( Client 3 ( Client 4 12.11 1 6.3f2.8 1 4.94f2.7 1 4.71h 2.07 Table 3: E f b values for Figure 6 C, X, 
1 Client 1 1 Client 3 1 Client 4 i 12.11 1 -1.lk2.5 1 -0.9k2.4 1 -1.7zt2.3 Table 4: c f 5 values for 
Figure 7 Chain Server 1 Server 2 Server 3 ES EXc2 EX EX EX EXC2) 1 0.011 0.0018 0.011 0.0018 0.011 
0.0018 2 0. n 1 2 0.0027 0.012 0.0027 0.012 0.0027 3 0.013 0.0033 0.013 0.0033 0.013 0.0033 2 0.014 0.0036 
0.014 0.0036 0.014 0.0036 5 0.014 0.0039 0.014 0.0039 0.014 0.0039 6 0.015 0.0041 0.015 0.0041 0.015 
0.0041 Table 5: Moments of Service Times at Servers CA I Client 1 1 Client 4 1 Client 6 12.11 1 -0.14* 
1.13 1 -0.94zt 2.34 1 -1.41 f 2.44 15.14 -1.36 * 2.14 -4.03 4~ 2.87 -4.47 f 3.23 18.16 -o.o* 3.11 0.34 
It 4.23 -1.34 f 4.23 21.19 -3.73 3~ 3.23 1.36 &#38; 4.77 3.35 414.83 24.23 -0.36*5.11 1 9.44h6.21 1 
3.94f7.32 1 L-- Table 6: f * S values for Figure 8 5.2 One Layer of Servers: Coxian Service Times 
Wr consider t,hc same queueing network analyzed in Sec- tion 5.1. The values for N, Ml, I<, and T(,,,~,~J 
re- mained the same. The arrival processes of requests at each of ithe client,s was assumed Coxian. The 
first two moments of t,he service time distribution for each chain at, each server were chosen as shown 
in Table 5. Us-ing these two moments, we fit a Cz distribution by as-suming t,hat the depart,ure rate 
out of each phase is the same. Wr, varied the mean arrival rates of re uests at ? each of the clients 
by equal increments, from X, to 2x:, for IZ = 1,2, .., N, while keeping the C2 values constant. The initial 
value Xi and C2 values are shown in Table 2. The results of the approximation algorithm plotted alongside 
the simulation results are seen in Figure 8 for the case where we have only synchronous messages. The 
c f S values are given in Table 6. Figure 9 shows the results for the case with synchronous and asynchronous 
messages. The fraction of asynchronous messages issued by any client to any server was assumed 0.8, while 
all other parameters were the same as in the earlier case. The t &#38; 6 values are in Table 7. En An 
Client 1 Client 3 Client 6 12.11 -3.23 + 2.31 0.24 zt 2.46 -0.71 dc 2.34 15.14 -2.86 zt 2.78 -2.39 III 
3.33 -2.26 * 3.74 18.16 -2.23 It 3.31 -0.28 zt 3.78 0.51 5 2.52 21.19 -0.63 * 5.36 -3.02 21 4.49 -1.51 
213.76  24.23 -2.16 5 6.25 0.30 iz 5.61 0.29 * 5.94 Table 7: t * 5 values for Figure 9 Figure 8: Synchronous 
Messages 0.065 r 0.035t Figure 9: Synchronous and Asynchronous Messages    5.3 Two Layers of Servers 
In this section, we examine the accuracy of the approx- imation algorithm for a three-layered queueing 
network model. This was obtained from the queueing net.work considered in sections 5.1 and 5.2 by adding 
2 Layer- 2 servers. Thus, we have 6 clients, 3 Layer-1 servers and 2 Layer-2 servers. The routing probabilities 
for syn- chronous and asynchronous messages from clients to the Layer-l servers are the same as above, 
and are givctl in Table 1. For Layer-2 servers, t,he following assump-tions are made. The maximum number 
of synchronous and asynchronous messages issued by a Layer-l server m, m = 1,2.., M1, in response to 
a message from a client, n, n = 1,2, .., N, is 1. The routing probabilit,ies of these messages depend 
on both Layer-l server m and the client n that issued the associated message to the Layer- 1 server. 
These probabilities are shown in Table 9. The, service times at each client, Layer-l server and Layer-2 
server are exponentially distributed with a mean service rate of 60. The arrival process of requests 
at each client Chain L-l Server 1 L-l Server 2 L-l Server 3 L-2 Server 1 L-2 Server 2 L-2 Server 1 L-2 
Server 2 L-2 Server 1 L-2 Server 2 1 0.8 0.2 0.6 2 0.6 0.4 0.48 3 0.48 0.52 0.4 4 0.4 0.6 0.34 5 
0.34 0.66 0.3 6 0.3 0.7 0.27  Table 9: Routing probabilities Parameter Client 1 2 3 4 5 6 x 2.00 1.28 
3.38 4.00 1.87 2.00 c 0.60 0.84 0.72 0.94 0.72 0.6 Table 8: Initial X, and C2 values of the arrival 
process Figure 10: Synchronous Messages is a Cp. The mean delay of requests in each client queue was 
computed using the approximation algorithm while vary-ing the mean arrival rate of requests X, at client 
n, n = 1,2 , .., N from Xz to 2x:. The value of C2 is kept constant. The values of XE and C2 are shown 
in Table 8. For synchronous messages only, the mean delay in three of the six client queues, as obtained 
by both approximate analysis and through simulation, are given in Figure 10. The E f 6 values are given 
in Table 10. For both synchronous and asynchronous messages, the fraction of asynchronous messages from 
all clients and all Layer-l servers was assumed equal to 0.8. All other parameters were the same as in 
the earlier case. The mean delays of requests to three of the six client 0.4 0.48 0.52 0.52 0.4 0.6 0.6 
0.34 0.66 0.66 0.3 0.7 0.7 0.27 0.73 0.73 0.24 0.76 of Second Level Messages CA I Client 1 1 Client 
3 1 Client 4 7.27 1 2.12zt2.42 1 0.47zt2.18 1 -4.13f2.51 Figure 11: Synchronous and Asynchronous Messages 
queues, as obtained through simulation and approximate analysis are shown in Figure 11. The c&#38;S values 
are given in Table 11. 5.4 Discussion From the results reported above, and also from other results given 
in [ll] involving larger queueing networks, we note that the approximation algorithm has a good accuracy. 
The maximum relative error of the mean delay of requests in a client queue was observed to be less than 
10%. C, X,, 1 Client 2 1 Client 3 Client 4 7.27 1 -3.3k2.66 1 -1.14k 2.11 1 5.31f3.13 )-, A, 1 7.27 1 
9.08 1 10.90 1 12.72 1 14.53 Number of 1 iterations 8 8 10 10 13 run time (in set) 1 206 1 206 1 258 
) 258 1 335 1 Table 12: Running times of the Algorithm for Figure 11 The complexity of the decomposition 
algorithm in-creases as the number of layers increases. The complex-it,y of t,he server subsystem without 
a product-form so-lution is O(M x N2), The number of iterations required to analyze the queueing network 
in the case when the server subsystem does not have a product-form solution increases as the traffic 
intensity increases. For the exam- ple given in Section 5.3, the number of iterations until convergence 
are given in Table 12. We also give the exe-cution times, in seconds for the algorithm running on an 
IBM R.S 6000.   Conclusions In this paper, we presented and analyzed a novel queue- ing network that 
models the messaging in a client-server system. This work was motivated by the work of Wood- side, et. 
al [3], [2] and Rolia and Sevcik [4]. However, un-like these papers, in our queueing network, we explicitly 
model the flow of requests and synchronous and asyn-chronous messages through the clients and servers. 
The queueing network can be seen as a queueing network with blocking (see Perros [5]). In general, such 
queueing net-works do not have a closed-form solution, and they are analyzed approximately by decomposition. 
The decom-position algorithm presented in this paper can be seen as a genera.lization of the well-known 
two-node decomposi-tion for tandem queueing networks. We believe that this generalization opens up a 
new way to analyzing queueing networks with blocking. The accuracy of the approximation algorithm was 
ex- amined by comparing the approximation results against simulation estimates. From the results reported 
here, and more detailed results given in [ll], we note that the approximation algorithm has a good accuracy. 
The max-imum relative error of the mean delay of requests in a client queue was less than 10%. Other 
performance mea-sures such as client and server utilization, and t)he queue- length distribution of messages 
in a client or a server queue are readily available from the algorithm. The complexity of the decomposition 
algorithm in-creases as the number of layers increases. Also, the num- ber of iterations required until 
convergence of t#he algo- rithm used to analyze the problem where the server sub- system does not have 
a product-form solut#ion. increases as the traffic intensity of the client queues increases. Onr may 
easily analyze a large number of layers if the mes-sage pattern is simplified to, say, one synchronous 
mes-sage per customer at each server. In t,he case where all the messages are asynchronous one can obtain 
a decom- position of the queueing network into individual client, and server queues. the arrival process 
to a Layer-i server has to be estimated from the departure process of t#he Layer-(i -1) servers. Each 
client and server queue can then be analyzed in isolation. Though the queueing network does not, explicitly 
model resource sharing among various processrs, t,he problem of CPU sharing among processes of t,he sam(l 
layer, say Layer-i, can be incorporat,ed in the network by introducing an additional server in Layer-(i 
+ I ), and in- cluding one synchronous message to this server for every chunk of processing required 
by each of the Layer-i pro-cesses that share the CPU. Naturally, the processing time at the corresponding 
Layer-i processes is set t,o zero. For instance, if 2 clients, say Client 1 and Client, 2 share the same 
CPU, we introduce a new Layer-l server tha.t motl- els the CPU. The processing times of requests at c1ient.s 
1 and 2 are set to zero, but every message issued by these clients is preceded by a synchronous message 
to the new Layer-l server. The amount of processing required at the new server is equal to the amount 
of processing required on the corresponding client if each client ran on its own CPU. Thus, we can use 
this queueing network to model certain types of CPU sharing. Finally, we note that our queueing network 
can be used to model situations such as multiple mutex primi-tives (i.e., binary semaphores) and simultaneous 
resource possession. Let us first examine the multiple mutex case. Let us assume that the N clients are 
simply co-operating processes running on the same CPU. Each process is asso- ciated with its own queue 
of requests. Let us assume that, there are Ml mutex primitives associated with these N processes. The 
servicing of a request by the nth process involves the execution of different critical and remainder 
sections. The queueing network shown in Figure 2 (i.e., with one layer of servers) can be used to model 
t,hesr N processed and M1 mutexes. Each process is reprc- sented by a client, and each mutex by a Layer-l 
server. Accessing a critical section through a mutex is modelled as issuing a synchronous message to 
one of the Layer-l servers. The queue in front of each Layer-l server rep-resents the queue of processes 
waiting on a mutex. We note that the same queueing network model can be seen as a queueing network with 
multiple window flow cont,rol mechanisms of window size of 1. The case of simultaneous resource possession 
can also be modelled by our queueing network, Let us consider, for instance, the queueing network shown 
in Figure 1. Layer-l and Layer-2 servers can be seen as two groups of different resources. Let the N 
clients represent N differ- ent processes. Servicing a customer by one of these pro- cesses may require 
simultaneous possession of a Layer-l server and a Layer-2 server. This can be modelled using only synchronous 
messages. References <RefA>S. Vinoski, CORBA: Integrating Diverse Appli- ill cations within Distributed Heterogeneous 
Environ-ments, IEEE Communications Magazine, pp. 46- 55, 1997. PI C. M. Woodside, J.E. Neilson, D. C. 
Petriu and S. Majurndar, Stochastic Rendezvous Network Model for Performance of Synchronous Client-Server-like 
Distributed Software, IEEE Transactions on Com-puters, vol. 44, pp. 20-34, 1995. PI C. M. Woodside, Throughput 
Calculation for Ba-sic Stochastic Rendezvous Networks, Performance Evaluation, vol. 9, pp. 143-160, 1989. 
J. A. Rolia and K. C. Sevcik, The Method of Lay- PI ers, IEEE Transactions on Software Engineering, vol. 
21, pp. 689-700, 1995. H. G. Perros, Queueing Networks with Blocking: [51 Exact and Approximate Solutions, 
Oxford Univer-sity Press, 1994. [61 S. S. Lavenberg, Computer Performance Modelling Handbook, Academic 
Press, 1983. [71 S. S. Lavenberg and M. Reiser, Stationary State Probabilities at Arrival Instants for 
Closed Queue- ing Networks with Multiple Types of Customers, Journal of Applied Probability, vol. 17, 
pp. 1048-1061, 1980. WI M. F. Neuts, Matrix-geometric Solutions in Stochastic Models-an Algorithmic Approach, 
John Hopkins University Press, 1981. PI B. Baynat and Y. Dallery, A product-form approx-imation method 
for general closed queueing net-works with several classes of customers, Perfor-mance Evaluation, vol. 
24, pp. 165-188, 1993. [lOI R. Marie, An approximate analytical method for general queueing networks, 
IEEE transactions on Software Engineering, vol. 5, pp. 530-538, 1979. [Ill S. R.amesh and H. G. Perros, 
A Multi-Layered Client-Server Queueing Network Model with Syn-chronous and Asynchronous Messages, Technical 
Report, Center for Advanced Computing and Com- munications, North Carolina State University, 1998. </RefA> 
			

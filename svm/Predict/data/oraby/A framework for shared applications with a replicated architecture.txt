
 A FRAMEWORK FOR SHARED APPLICATIONS WITH A REPLICATED ARCHITECTURE Thomas Berlage and Andreas Genau 
GMD (German National Research Center for Computer Science) P.O. Box 1316,53731 Sankt Augustin, Germany 
E-mail: berlage@gmd.de, genau@gmd.de ABSTRACT The interaction history of a document can be modelled 
as a tree of command objects. This model not only supports recovery (undo/redo), but is also suitable 
for cooperation between distributed users working on a common document. Various coupling modes can be 
supported. Switching between modes is supported by regarding different versions of a document as different 
branches of the history. Branches can then be merged using a selective redo mechanism. Synchronous cooperation 
is supported by replicating the document state and exchanging command objects. Optimistic concurrency 
control can be applied, because conflicting actions can later be undone automatically. KEYWORDS User 
Interface Management System, Application Framework, Computer-Supported Cooperative Work, Command Objects, 
Selective Undo and Redo, History he INTRODUCTION In this paper we describe how the history mechanism 
of the GINA application framework [19]-originally designed to provide unlimited undo-can be extended 
for multi-user applications. Multi-user applications allow spatially distributed users to work coupled 
or decoupled cm a document. It is assumed that the participants can communicate informally through another 
medium, such as an audio/video link. The resulting mechanism has the following properties: It is a generic 
framework for the implementation of single-and multi-user applications with graphical user interfaces. 
The application only few additional hooks case. Permission to copy without fee granted provided that 
the copies direct commercial advantage, the programmer has to provide specifically for the multi-user 
all or part of this material is are not made or distributed for ACM copyright notice and the title of 
the publication and its date that copying is by permission of the Machinery. To copy otherwise, or and/or 
specific permission. ; 1993 ACM O-89791-628-X1931001 appear, and notice is given Association for Computing 
to republish, requires a fee 1...$1.50 . The framework can automatically create replicated application 
instances that exchange command objects. The framework is able to handle optimistic concurrency control 
to ensure rapid local feedback. The framework supports different degrees of coupling between the participants 
ranging from common feedback for mouse operations to completely separate state. Smwnh transitions from 
decoupled to synchronous work are thus supported. Different coupling modes are implemented by varying 
the amount of data that is exchanged between replicas. The framework assists the users in merging different 
versions that result from decoupled work. Merging is performed on the basis of individual commands, accepting 
commands automatically when possible, but giving the users a choice when conflicts arise. The framework 
handles the undo problem in multi-user applications, because it allows undoing arbitrary commands from 
the history when sensible. Many of the aspects were partially solved independently by others. The integration 
of these aspects into a coherent framework is unique, because the GINA framework developed at GMD has 
already been used to implement several single-user applications with graphical user interfaces and it 
is expected that most existing GINA applications can be transformed into multi-user applications with 
only a modest amount of work. This has been partially verified with a few smaller examples. The framework 
is based on the idea to represent the interaction history as a tree of command objects. A single command 
object translates between two states. The meta­operations undo and redo can be used to get from one state 
to the other, so that each state in the tree can be reached. Generic aspects of commands are implemented 
in the GINA class library, while the specific properties of individual commands are defined in a subclass 
for every different operation. The challenge in the design of such a framework is to reduce the programmer 
s work by handling common cases, to make the definition of application- specific features short and easy, 
and to allow flexibility for approach and also provides for resolving conflicts, flexible uncommon cases. 
In particular, generic aspects of multi-user interfaces, such as teleprinters, are implemented in GINA, 
while other mechanisms for collaboration-aware applications 11], such as marking the regions others are 
working in, have to be supplied by the programmer because they are application­specific. RE~TED WORK 
One approach to implement collaboration is a shared window system, which intercepts and broadcasts events 
at the basic window system level [11]. Applications for a certain window system do not need to be modified. 
Most problems with this approach result from window systems not being designed for such a purpose. Because 
the appli­cations itself are not collaboration-aware, it is very difficult to realize loose coupling 
modes [7]. Suite [7] allows different degrees of coupling between users by associating coupling attributes 
with shared variables. The coupling attribute determines which aspects are coupled and when updates are 
propagated. In our model, the coupling mode is associated with the whole document and has only three 
possible values. On the hand, our model imposes no restrictions on the internal data structures of the 
implementation and it provides support for merging decoupled versions. A number of toolkits to implement 
multi-user applications have been described. DistEdit [10] implements a minimal set of operations for 
text editors. These operations are distributed by the kernel to replicated editors. MMConf [6] also uses 
a replicated architecture, but broadcasts low-level events. Both toolkits require minor changes to existing 
applications. LIZA [9] and Rendezvous [16] support writing new collaborative applications from scratch. 
They use a centralized architecture with explicit user interface components for each participant. Our 
model generalizes the DistEdit approach to arbitrary primitive operations (the commands). The commands 
are distributed to replicated applications. This model can be im­plemented with moderate effort in applications 
that use an object-oriented application framework like MacApp, Inter­Views/UniDraw [23], ET++ [22] or 
GINA [19], because all these frameworks support command classes. GroupDesign [2] implements a replicated 
architecture similar to ours, but for a specific application. Systems that support asynchronous communication, 
such as Quilt [12] and GroupWriter [13], usually have special features to maintain different versions 
as well as annotations. Our model handles versions independent of the application and offers automatic 
integration if possible. Annotations are not covered by our approach, they are application-specific. 
The WeMet toolkit [18] implements a persistent history tree to support collaborative work. Our system 
generalizes the coupling and merging versions. Most shared applications provide a floor control or locking 
to prevent concurrent updates by different users. Ellis and Gibbs [8] describe an optimistic algorithm 
for concurrency control in groupware systems used in the GROVE system. We use the same virtual time algorithm 
to detect parallel operations. They use a transformation to ensure that pairs of operations produce the 
same effect in either order. In contrast, we really reorder the operations so that no trans­formation 
is necessary. Prakash and Knister [17] describe another selective undo mechanism based on transposing 
pairs of operations. Our mechanism uses similar ideas, but does not need to check every possible pair 
of operations (the number of cases increases quadratically with the number of different oper­ations). 
Furthermore, whether selective undo is possible in our mechanism does not depend on the history in between 
but only on the current state. COMMAND OBJECTS IN A REPLICATED ARCHITECTURE There are several advantages 
if a graphical interactive application remembers the interaction history in addition to the current state. 
Undo and redo enable the user to reach every previous state. The history is even more important in a 
group setting. Users can revisit what they or others have done. The history is represented as a tree 
of command objects. Commands support the methods doit and undoit to change twween one state and the next 
one. The application programmer defines a subclass for every different command and implements the specific 
semantics by overriding methods. An unlimited history of command objects increases the storage requirements 
only by a small linear factor (except for some rare cases, such as applying destructive filers to large 
bitmap images, where every command must store a whole bitmap). A replicated architecture for synchronous 
cooperation can be implemented by broadcasting command objects to all participants whenever they are 
created [2,1 8]. Executing a command at every site keeps the states consistent. At the very least, every 
state-changing operation must be imple­mented as a command. If additionally WYSIWIS (What You See Is 
What I See) properties [21] are desired, every operation including object selection and scrolling must 
be implemented as a command. For example, the framework invisibly creates a command for each scroll operation 
to keep the visible region synchronized. To broadcast a command object, an external representation is 
needed. In GINA, every command object has a description that consists of the keyword-value pairs that 
are passed to the command constructor. For example, to set the value of the cell AS in a spreadsheet 
to 12.5 , the following description would be sufficient (a LISP list): (set-cell-cmd :row 5 :column 
A :new-value 12.5) This description can be constructed automatically by the framework from an existing 
command object, The keywords to include are indicated by the programmer in the class definition of the 
command. The description will be passed to a command constructor on the remote site in the following 
way: (make-set-cell-cmd : row 5 : column A : new-value 12. 5)  Constructors can accept two forms of 
descriptions, a short and a long one. The long description above is used by the framework, while the 
short description is used by the programmer when explicitly creating commands, e.g. in a callback. For 
example, the cell to be changed need not be explicitly given, but may be the currently selected cell. 
In that case the short description may be of the following form: (set -cell-cmd : new-value 12. 5) The 
values not given in the description must be filled in the method collect-missing-parameters . In the 
example, collect-missing-parameters wouId fill :row and :column from the current state if they are not 
already initialized. Short descriptions aIlow different interpretations of a command depending on the 
current state of a docu­ment, which becomes important in the context of selective redo and the merging 
of different versions of a document (see below). The external representation of a command to be broadcast 
must not contain internal references. The example above already consists of atoms that can be interpreted 
by the receiving applications. But descriptions may also contain references to other objects, that have 
to be transformed into a transportable representation. There are generic ways to provide identification 
of application objects. The WeMet toolkit [18] identifies objects by pointing to the command that created 
them the position of the creation command in the history is then a portable representation for the object 
(this mechanism becomes sIightly more complicated when a command creates more than one object). An alternative 
is to push newly created objects onto a stack and identify them via their position in the stack, The 
undo method pops the objects from the stack, therefore every state in the history maps to a particular 
stack configuration. Objects can now be identified by their position in the stack. The stack provides 
a bidirectional mapping between objects and identifications. To speed up one direction (searching for 
an object), hash tables or binary trees can be used. The generic mechanism for the identification of 
objects minimizes the effort of the application programmer, but application-specific identification of 
objects may be more efficient, because objects can often be identified by their position in an existing 
data structure of the application or by name. Both methods can be combined, In GINA, the methods transportable-representation 
(to create an identification) and parse-representation (to find an object for a given identification) 
can be specialized for every object class. RESOLVING CONFLICTS It is easily possible that users at different 
sites simultaneously submit commands before the other one s action reaches them. Not only does this result 
in different histories, but it may also cause a conflict if one user changes things that the other user 
relies on. Conflicts can be prevented by locking, but locking is undesirable because it interrupts the 
users in their work. Parallel operations can be detected by stamping each command with a logical clock 
[8,14]. Parallel commands must be sequentialized to achieve a common history. Ellis and Gibbs [8] define 
a transformation matrix that for each pair of parallel commands p and q gives variants p and q so that 
qp = pq , i.e. they define a transformation of the late-coming command so that the resulting effect on 
the application state is the same on both sites. However, the history is not the same on both sites. 
The same approach is used in GroupDesign [2], but in a simplified form because most of the operations 
in a graphical editor are sufficiently independent. Alternatively, undo and redo can be used to reorder 
the commands at one site. Of course, both sites must agree on the same ordering, which can be defined 
by an arbitrary ordering on the sites. The second command is redone in a different application state 
than during its initial invocation, so the ordinary redo method cannot be used. Instead, GINA uses the 
selective redo operation [4]. The selective redo operation in GINA is available to redo an arbitrary 
command from the history in the current state. GINA defines a method selective-redo that creates an equivalent 
command in the current state. The generic implementation uses the long command description to construct 
the new command. It is not always possible to redo a command in the current state, for example if the 
command refers to an object that no longer exists. Therefore, every command also defines a method selective-redo-possible 
that returns whether selective redo of this command is possible in the current state. This method must 
be specialized for every command class and is a simple test in most cases. Using this mechanism originally 
invented for single user interfaces, the two commands can be reordered if selective redo is possible 
for the second command (see Fig. 1). If selective redo is not possible for the second command, the two 
users have performed syntactically conflicting operations (for example, one user deletes a circle while 
the other one moves it at the same time). There is nothing the system can do about the conflict except 
canceling one of the operations, The user that wins (in an arbitrary priority Figure 1: Sequentializing 
two parallel commands by using selective redo. scheme) sees the expected system reaction, while at the 
other side the last operation is automatically undone and replaced by the other user s operation. This 
level of interference is unavoidable in synchronous multi-user interfaces [1]. In any case, the cancelled 
command is still available as a branch in the history. Using selective redo manually, it is possible 
to repeat this operation again later if the state has been changed appropriately. In particular, the 
users can decide whether they want to include the other alternative conflict resolution by undoing the 
last command and redoing the cancelled command. Semantics of Selective Redo In contrast to mechanisms 
that are based on checking the effect of one command against the other [2,8,17], the selective redo mechanism 
is designed to be independent from the commands in the history between the command to redo and the current 
state. In most cases, this makes under­standing the consequences easier and also facilitates the implementation. 
However, there are cases where commands in between affect the selective redo implementation. In a text 
editor, for example, intermediate operations can move the point in the text where the command to redo 
occurred. The mechanisms mentioned above are able to handle this problem beeause they can translate the 
position for each intermediate command. The same effect for the selective redo mechanism can be reached 
by using stable references [1], for example, by adding invisible markers that move with the text. Both 
alternatives require some work by the programmer, but the selective redo mechanism avoids the complexity 
problem of checking n command classes against each other in the common case of identifiable objects. 
DIFFERENT DEGREES OF COUPLING GINA allows different degrees of coupling between partners, from WYSIWIS 
(What You See Is What I See) to completely separate activities. More important, it also supports smooth 
transitions between synchronous and asynchronous activities. In particular, it suppurts merging different 
states when going from loosely coupled or decoupled to the tightly coupled mode. The following degrees 
of coupling are available in GINA: Tightly coupled the best approximation to true WYSIWIS that is possible 
in the environment. The individual feedback to every input event is repeated for every participant. Loosely 
coupled the participants share the same state of the document, but may have a different viewpoint, a 
different window size or a different current selection. Separate the participants work decoupled on the 
same document and individual changes are not visible for the other participants. The Tightly Coupled 
Mode The tightly coupled mode is very similar to a shared window system because every low-level event 
must be broadcast. It is easier to integrate event broadcasting in GINA, because event handlers are not 
direct] y accessible for the programmer, but are encapsulated by command classes [3], so broadcasting 
events can be handled in this encapsulation without affeeting the application code. Broadcasting events 
for feedback without floor control may lead to technical as well as conceptual problems. Technically, 
there may be problems if two users pull down a menu. For example, GINA is implemented on top of the OSF/Motif-toolkit 
and the Motif code is not prepared to show two menus at the same time or to have two different selected 
items in the same menu. Autoscrolling cannot be used by two users at the same time in different directions. 
Furthermore, the feedback for mouse operations may be misleading if two mouse operations are in progress 
in the same window. It is not possible to resolve parallel mouse operations using the undo-redo method 
described above, because the nature of the operation is not yet determined when the mouse button goes 
down. It is possible to cancel one of the mouse interactions when the conflict is detected. For example, 
Brad Myers interactor model [15] allows interactors to be aborted any time. However, it is useful to 
allow parallel mouse operations when their final effect does not cause any conflicts. Otherwise, the 
probably long feedback phase will lock out the other participants and disturb their actions. In GINA, 
only the replay of the feedback is postponed until the parallel commands have been resolved. Replaying 
commands with their associated feedback is a feature of the GINA interaction recorder [5]. Commands remember 
their interactor, i.e. the details of how they were invoked. These details can be replayed during redo. 
If two parallel mouse operations are detected, only the local feedback is shown. When one of the commands 
is finally submitted, the invocation of the other command can be replayed (if it is not skipped by the 
conflict resolution process). The Loosely Coupled Mode In the loosely coupled mode, only state-changing 
commands are executed at the other sites. For this purpose, commands are classified by the application 
programmer into two groups, the state-changing ones that have effects on the real contents of a document, 
and those that only affect the viewing parameters. In the loosely coupled mode, one site executes different 
non-changing commands than the other sites. The programmer must make sure that this does not affect the 
meaning of the state-changing commands. For example, consider a colour-change-command that works on the 
current selection. It may be executed at another site where the current selection is different, however, 
it is not allowed to use the different selection, else the resulting states are different. To help the 
programmer, GINA always broadcasts the long description of a command, which already includes the specifkation 
of the affected objects. The Separate Mode In the separate mode, the different users create different 
 branches in the history. It is not necessary to broadcast commands at all. The users may even move the 
document to a completely separate system (such as a portable computer). Histories can be stored with 
a document, because the list of command descriptions can be used as a persistent history and it is easy 
to reintegrate the changes as separate branches in the history. The real problem is to merge the changes 
from the branches into a common version (see the next section). SWITCHING BETWEEN COUPLING MODES The 
users may switch between the different levels of coupling at will and during their work. It is generally 
no problem to switch from a more tightly coupled mode to a more loosely coupled mode. Switching from 
loosely coupled mode to tightly coupled mode is more problematic, even though all users have the same 
document state. It is necessary to install a common selection, view position etc. during the transition, 
otherwise the effects of further commands may be different. But that is not enough. If the users move 
back into the history in tightJy coupled mode to a state before the mode switch occurred, they will not 
have the same history, which makes tight coupling impossible. As a solution, the part of the history 
during the loosely coupled mode is regarded as a separate branch for each user, although these branches 
share a lot of commands (namely the state-changing ones). Joining for a common view again means that 
the users have to agree on one of the branches as the current one. Although each of the branches produces 
a different presentation state, the document state is always the same. Joining requires that all users 
move to the common point in the history, which means undoing the own branch and redoing the common branch. 
As a result of the joining process, the presentation states of all participants will be synchronized. 
This process is fully automatic, although it may be not instantaneous if the branches are long. A similar 
method is necessary when moving from the separate state to one of the coupled states. The users have 
to agree on one of the branches as a starting point and all move to it. In this case, the document state 
will be different for the different branches. However, all the individual states of the participants 
are still accessible. That means that it is also possible to select any of them as the starting point 
for a merging process. MERGING VERSIONS GINA uses the basic idea that the merging process necessary to 
combine the changes of different branches can be supported by the selective redo mechanism. Ignoring 
the fact that redoing some commands might not be possible, merging can be performed by using selective 
redo to repeat all commands in one branch at the end of the other branch (Fig. 2). Figure 2: Merging 
branches by appending one path at the end of the other. In reality, merging will always be a manual process 
that can only be assisted by the selective redo mechanism. One reason is that the process may give different 
results depending on which branch is appended as the last one (because later changes take preference 
over older ones). One can also create a completely new branch from the two branches in an arbitrary mixture. 
All these variations produce different results. It should also be noted that merging is a cooperative 
process of negotiations between the different authors. GINA takes a pragmatic approach, which nevertheless 
gives a lot of support. The partners select one of the branches as the starting point and then merge 
the commands of another branch one by one. A modeless dialog box lists the position in this branch and 
a description of the remaining commands (Fig. 3). Pushing the Merge button will repeat the next commands 
using selective redo until a conflict is signalled by the application code. The most severe type of conflict 
is that the command cannot be redone in the current state. The partners have different options how to 
resolve the conflict. They can decide to Skip the command because it is no longer necessary. They can 
also skip it, but produce a corresponding effect explicitly (the dialog box is modeless, so the normal 
application interface is still operable). They can try to change the document so that selective redo 
is possible. This change may be a selective undo of some 12 of 32 mmmsmk pmcesseti e Column H from 34 
to 66 ~ B P CmUon: cd vdua hee changed EiEEilmEiil Retb whrnmt Selectkm Figure 3: The dialog box to 
merge a branch. command in the first branch, which results in neutralizing a change that had so far been 
tentatively accepted. If the partners desire, multiple dialog boxes for multiple branches can be open 
at the same time, so it is also possible to produce a mixture of the separate branches. The most important 
support GINA can give is a reeording which commands have already been merged and which commands are still 
to be regarded. Automatic checking is much less error-prone than a purely manual merge where individual 
changes may be overlooked. However, the merging process should be able to signal more subtle conflicts 
even when selective redo is possible. For example, imagine a cell in a spreadsheet has been changed in 
the first branch and another command changing it to a different value appears in the second branch. Selective 
redo is clearly possible for the second command, because the cell exists and the value is legal. However, 
the users may overlook the fact that they have both changed the same cell and only one of them wins. 
The command that changes a cell is able to detect the difference. It already contains the old value of 
the cell for undo purposes. If the old value registered in the command is not the same as the current 
value, the cell value must have been changed by another command. l%erefore, the method selective-redo-possible 
can return more specific indicators than just True or False . The return value :conflict signals that 
selective redo is possible, but a conflict has been detected. The method may also return a string that 
describes the cause of the conflict to be shown in the merging dialog box. Sometimes, selective redo 
is not possible because the re­ferred object does no longer exist. However, the users may want to apply 
the command effects to another object. For example, if text was written in a paragraph that no longer 
exists, it may still be desirable to put that text into another location. Or if a specific colour was 
seleeted for a deleted object, it may be desirable to use that exact colour value (which may be difficult 
to reproduce) for another object. If selective redo is possible only with a different interpretation 
of the command, selective-redo-possible may return different and an instructive text. In this case, selective-redo 
must be overridden to use the short constructor. The semantics of this interpretation of selective redo 
are fully controlled by the programmer. All the finer-grained control of the selective redo operation 
for the merge process need only be implemented by the application programmer for those commands where 
it is worthwhile. Commands that do not implement the additional support simply do not offer as many choices 
to the user, so that more manual work is necessary. UNDO IN MULTI-USER APPLICATIONS Undo in multi-user 
applications may have different meanings, The normal undo function (global undo) goes one step back in 
the common history. If the users do not operate exactly synchronous (for example in loosely coupled mode), 
undo may also mean undo my command because users take only their personal actions into account [1]. However, 
one user s last command may no longer be the last one in the history if another one has also submitted 
a command. The normal undo is not able to undo one without the other, Figs. 4 and 5 clarify the problem. 
The arrow points to the last command currently in effect. In Fig. 4, user B has submitted a command between 
two commands of user A. Suppose that B wants to undo this command. The normal undo facility cannot be 
used, because it would also undo the second command of user A (Fig. 5). B AA Figure 4: User A has submitted 
a command after the last command of user B. AA Figure 5: After undoing user B s command, user A s last 
command is no longer in effect. GINA provides a selective undo that (similar to selective redo) creates 
a copy of the command to undo, but with the inverse effect. Selective undo may be impossible (just like 
selective redo) because later commands have destroyed a prerequisite of the command. There is nothing 
the system can do about this, but at least the complete history is still available, so the users can 
find a solution for this conflict in a cooperative manner. To solve the problem in Fig. 4, user B can 
use the menu entry undo my command . This operation is internally implemented with selective undo and 
leads to Figure 6, where a command with an inverse effect of B s command has been appended to the history. 
 BB AA Figure 6: Selective undo of B s command appends a new command and leaves A s command in effect. 
An open question is how subsequent calls to undo my command should be interpreted. Selective undo creates 
a new command, which becomes the last command issued by user B. A simple interpretation of undo my command 
would now reverse that command, so the user can only undo and redo the last command. This is currently 
implemented in GINA. Subsequent calls to undo my command might also undo the last command of the user 
that hasn t been undone yet. This would establish unlimited linear undo on the subset of commands issued 
by one user. The implementation is straightforward by providing every command created by selective undo 
with a reference to the command it reverted. The next command to be selectively undone can be found by 
searching backwards in the history beginning with the command preceding the referenced command. SUMMARY 
OF COMMAND PROTOCOL ro summarize the methods that must or can be defined for a command, the following 
example defines a typical command class (Fig. 7). The example is written in CLOS (Common Lisp Object 
System) and realizes a command to change the colour of an object in a graphics editor. The class definition 
adds slots to store the object, the old colour and the new colour. Slots with an :initarg specification 
are included in the command description. A constructor function make-change-color-command for the command 
class is defined where all the initargs can be specified as keyword parameters. The method collect-missing-parameters 
checks whether the object sIot and the old-coIour slot have their default values and fiIIs them with 
the current state in this case. This means that a command constructor can omit those two keywords in 
the short description, The doit and undoit methods use the information in the command to set the colour 
of the affected object to the new or the old value (an extension of the command to multiple selected 
objects is straightforward). The method selective-redo-possible first checks whether the object still 
exists. If it does, selective redo is possible. For the merging process, the method returns whether the 
current colour is identical with the old colour in the command. If it is not, the colour has been changed 
by another command previously, so a soft conflict is indicated. If the object no longer exists, the method 
returns different because the command can be repeated with a different selection. The method selective-redo 
calls the short constructor if a different selection is requested, otherwise the inherited default behaviour 
(calling the long construction) is executed. This method would not have to be defined if it is not worthwhile 
to call the command with a different selection (for example, if only two colours are allowed, which can 
easily be selected again by the user). Similarly, the method selective-undo-possible checks whether the 
object still exists. The method selective-undo is implemented by calling the constructor with the old 
colour as the new-colour . The old-colour slot is set to the current colour of the object by collect-missing­parameters 
, but the affected object is taken from the command to undo and not from the current selection. Because 
changing an attribute is a very common case, some of the code in this example could be inherited from 
the GINA class value-change-command , but the code is expanded here to show the approximate complexity 
for other kinds of commands. CURRENT STATUS AND FUTURE WORK The model has been implemented in a multi-user 
spreadsheet application implemented with the GINA class library [20]. The changes to the single-user 
version of the spreadsheet were mainly in the parts implemented by GINA. The features have been integrated 
into the GINA library and transfemed to other applications implemented with GINA, such as the graphic 
editor. The application­specific effort has been moderate. Future research will concentrate on how the 
basic mechanism can be presented most effectively at the user interface. CONCLUSIONS When using a command 
history, surprising similarities show up between single-user and multi-user applications. Storing the 
history for later use by the same user also provides a mechanism to communicate commands to other users. 
The history tree not only remembers mistakes of a single user, but can also represent alternative versions 
for multiple users. Selective redo and undo allow the final result to be combined from different sources. 
Only the virtual time algorithm is specific to synchronous multi-user applications. We believe that our 
model can easily be used as the basis for an implementation of various multi-user applications that are 
similar to their single-user counterparts. This is demonstrated by the integration into our GINA application 
framework. (defclass change-colour-command (command) ((object :initarg :object :initform :selected) 
(old-colour :initarg :old-colour :initform nil) (new-colour :initarg :new-colour))) (defun make-colour-cormnand 
(document &#38;rest parameters) (make-command document :class colour-command :initargs parameters)) 
(defmethod collect-missing-parameters :after ((cmd colour-command)) ;; get selected object when not specified 
(when (eq (object cmd) :selected) (setf (object cmd) (selected-object (main-view (document cmd)))) ;; 
get current colour (unless (old-colour cmd) (setf (old-colour cmd) (colour (object cmd)) ))) (defmethod 
doit ((cmd colour-command)) (setf (colour (object cmd)) (new-colour command))) (defmethod undoit ((cmd 
colour-command)) (setf (colour (object cmd)) (old-colour command))) (defmethod selective-redo-possible 
((cmd colour-command)) (if (object-present (object cmd) (document cmd)) (if (eq (old-colour cmd) (colour 
(object cmd))) t (values :conflict Colour has changed )) (values :different Select another object ))) 
 (defmethod selective-redo ((cmd colour-command)) (if (object-present (object cmd) (document cmd)) :: 
perform default method (call-next-method) ;; else do not specify object (make-colour-command (document 
cmd) :new-colour (new-colour cmd)))) (defmethod selective-undo-possible ((cmd colour-command)) -check 
whether object still present (~bject-present (object cmd) (document cmd))) (defmethod selective-undo 
((cmd colour-command)) (make-colour-command (document cmd) :object (object cmd) :new-colour (old-colour 
cmd))) Figure 7: Implementation ofan example command class. ACKNOWLEDGEMENTS The other members of the 
GINA project team, Michael Spenke, Christian Beilken and Markus Sohlenkamp, participated in the design 
and implementation of the framework. The reviewers provided helpful suggestions to improve thepresentation 
ofthese ideas. REFERENCES <RefA>1. Abowd, G.D. and Dix, A.J., Giving undo attention. InteractingwithContputers 
4, 3(1992),pp,31 7-342 2. Beaudouin-Lafon, M. and Karsenty, A., Transparency and Awareness in a Real-Time 
Groupware System. In Proceedings of (he ACM Symposium on User Interface Software and Technology (Monterey, 
CA, Nov 15-18, 1992), pp.171 180. 3. Berlage, T., Input Handling Using Command Objects, lnObject-Oriented 
ApplicationFrameworks for Graphical User Interfaces: The GINA Perspective, Oldenbourg Verlag, Miinchen, 
1993, pp.  119 128. 256 UIST 93 Atlanta, Georgia 4. Berlage, T., Recovery in Graphical User Inte~aces 
Using Command Objects, Arbeitspapiere der GMD, 1993. 5. Berlage, T.and Spenke, M., The GINA Inte~ction 
Recorder. In Proceedings of the IFIP WG2.7 Working Conference on Engineering for Human-Computer Interaction 
(Ellivuori, Finland, Aug 10-14, 1992). 6. Crowley, T., Baker, E., Forsdick, H., Milazzo, P. and Tomlinson, 
R., MMConf An infrastructure for building shared multimedia applications. In Proceedings of the Conference 
on Computer Supported Cooperative Work (CSCW 90) ACM Press, Los Angeles, California, 1990, pp. 329-342. 
 7. Dewan, P. and Choudhary, R., Flexible User Interface Coupling in a Collaborative System. In Proceedings 
of the CHI Conference on Human Factors in Computing Systems (New Orleans, Apr 28-h&#38;ly 2, 1991), pp. 
4148. 8. Ellis, C.A. and Gibbs, S.J., Concurrency Control in Groupware Systems. In Proceedings of the 
ACM SIGMOD International Conference on the Management of Data (Portland, OR, May 3 l-Jun 2, 1989), pp. 
399407. 9. Gibbs, S.J., LIZA: An extensible groupware toolkit. In Proceedings of the SIGCHI Conference 
on Human Factors in Computing Systems (CHI 89) ACM Press, Austin, Texas, 1989, pp. 29-35. 10. Knister, 
M.J. and Prakash, A., DistEdic A distributed toolkit for supporting multiple group editors. In Proceedings 
of the Conference on Computer Supported Cooperative Work (CSCW 90) ACM Press, Los Angeles, California, 
1990, pp. 343-355. 11. Lauwers, J.C. and Lantz, K. A., Collaboration Awareness in Support of Collaboration 
Transparency: Requirements for the Next Generation of Shared Window Systems. In Proceedings of the CHI 
Conference on Human Factors in Computing Systems (Seattle, WA, Apr 1-5, 1990), pp. 303-311. 12. Leland, 
M. D. P., Fish, R.S. and Kraut, R. E., Collaborative Document Production Using Quilt, In Proceedings 
of the ACM CSCW 88 Conference on Computer-Supported Cooperative Work (Portland, Oregon, Sep 26-28, 1988), 
pp. 206-215. 13. Malcolm, N. and Gaines, B. R., A Minimalist Approach to the Development of a Word Processor 
Supporting Group Writing Activities. In Proceedings  of the Conference on Organizational Computing Systems 
(Atlanta, GA, Nov 5-8, 1991), pp. 147-152. 14. Mattern, F., Virtual Time and Global States of Distributed 
Systems. In Proceedings of the Workshop on Parallel and Distributed Algorithms (Bonas Oct. 1988), North-Holland/Elsevier, 
1989, pp. 215 226. 15. Myers, B.A., A New Model for Handling Input. ACM Trans. Inf Syst. 8,3 (1990), 
pp. 289-320. 16. Patterson, J.F., Hill, R. D., Rohall, S.L. and Meeks, W. S., Rendezvous: An Architecture 
for Synchronous Multi-User Applications. In Proceedings of the Conference on Computer-Supported Cooperative 
Work (Los Angeles, CA, Get 7-10, 1990), pp. 317­ 328.  17. Prakash, A. and Knister, M.J., Undoing Actions 
in Collaborative Work. In Proceedings of the Conference on Computer Supoorted Cooperative Work (Toronto, 
Canada, Ott 31 Nov 4, 1992). 18. Rhyne, J. R. and Wolf, C. G., Tools for Supporting the Collaborative 
Process. In Proceedings of the ACM Symposium on User Interface Software and Technology (Monterey, CA, 
Nov 15-18, 1992), pp.161-170). 19. Spenke, M. and Beilken, C., An Overview of GINA  the Generic Interactive 
Application. In User Interface Management and Design, Proceedings of the Workshop on User Interface Management 
Systems and Environments (Lisbon, Portugal, June 4­6, 1990), D.A. Duce et al., Eds., Springer Verlag, 
Berlin, pp. 273-293. 20. Spenke, M., From Undo to Multi-User Applications The Demo, Proceedings of the 
InterCHI Conference on Human Factors in Computing Systems (Amsterdam, The Netherlands, Apr 24-29, 1993), 
pp. 468--469 21. Stefik, M., Bobrow, D.G., Foster, G., Lanning, S. and Tatar, D., WYSIWIS revisited: 
Early experiences with multiuser interfaces. ACM Trans. OJ+ice Inf. Syst. 5,2 (1987), pp. 147-167. 22. 
Weinand, A., Gamma, E. and Marty, R., Design and Implementation of ET++, a Seamless Object-Oriented Application 
Framework. Structured Programming 10, 2 (1989), pp. 63-87. 23. Vlissides, J. M., Linton, M. A., Unidraw: 
A Framework for Building Domain-Specific Graphical Editors. ACM Trans. lnf. Syst. 8, 3 (July 1990), pp. 
237-268</RefA>.  
			

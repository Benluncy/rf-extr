
 A Generic Operator over Discrete Time Intervals J´er´emie Blanc Rachid Echahed Laboratoire LEIBNIZ-IMAG, 
CNRS Laboratoire LEIBNIZ-IMAG, CNRS 46, avenue F´elix Viallet 46, avenue F´elix Viallet F-38031, Grenoble, 
France F-38031 Grenoble, France Jeremie.Blanc@imag.fr Rachid.Echahed@imag.fr ABSTRACT We de.ne a new 
generic operator, V,which can be used within any programming language which allows one to de­.ne discrete 
time intervals. Let t0,...,tn be the consec­utive instants of an interval I, u aterm and vti the value 
of u at instant ti. Wede.ne theexpression V(.,e,I) u as the .rst-order term (···((e . vt0 ) . vt1 ) ... 
. vtn ). We integrate this operator into timed rewrite systems, illustrate it through several examples 
and provide an e.cient opera­tional semantics which we have implemented.  Categories and Subject Descriptors 
D.1 [Software]: Programming Techniques; D.3 [Software]: Programming Languages; F.1 [Theory of Computation]: 
Computation by Abstract Devices; F.3 [Theory of Com­putation]: Logics and Meanings of Programs; F.4 [Theory 
of Computation]: Mathematical Logic and Formal Lan­guages; I.1 [Computing Methodologies]: Symbolic and 
Algebraic Manipulation General Terms Algorithms, Languages, Theory, Veri.cation  Keywords Timed Term 
Rewrite Systems, Discrete Time Intervals, Op­erational Semantics 1. INTRODUCTION Many applications need 
the use of formal notions of time, e.g., embedded systems, real-time applications, timed data bases etc. 
Several computation models and speci.cation for­malisms have been suggested in the literature in order 
to handle time e.g., [14, 19, 18, 5, 4, 15]. In these proposals, time can have di.erent aspects, qualitative 
or quantitative, discrete or continuous, mono or multi-form etc. In this pa­per we introduce a new generic 
operator which enhances Permission to make digital or hard copies of all or part of this work for personal 
or classroom use is granted without fee provided that copies are not made or distributed for pro.t or 
commercial advantage and that copies bear this notice and the full citation on the .rst page. To copy 
otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission 
and/or a fee. PPDP 02, October 6-8, 2002, Pittsburgh, Pennsylvania, USA. Copyright 2002 ACM 1-58113-528-9/02/0010 
...$5.00. declarativity of programming languages. We only require that the underlying notion of time 
allows one to de.ne dis­crete intervals of instants. This operator, noted V, has three parameters: a 
binary .rst-order operator ., a left identity element for ., denoted e, and a discrete time interval 
I.Let t0, ..., tn be the consecutive instants of interval I and let u be a term. We note vti the value 
of uat instant ti. Wede.ne theexpression V(.,e,I) u as the .rst-order term (···((e . vt0 ) . vt1 ) ... 
. vtn ). Informally, Vacts in the same way as foldleft [20]. The main di.erence, as we shall see later, 
comes from the fact that the elements of the considered lists depend on time and thus need a particular 
operational semantics that we discuss in section 5. In the following we motivate the proposed operator, 
V, by showing how well known operators can be obtained as simple instances of it. Temporal operator 
. is the classical temporal operator always of the .rst-order temporal logic. .I u is true whenever u 
was true at each instant of I. the expres­sion .I u can be de.ned as V(and, true, I) usuch that and and 
true are the well-known boolean operators.  Likewise, the dual temporal operator eventually,de­noted 
., is such that .I u is true whenever u was true at least one instant of I. the expression .I u can be 
de.ned as V(or, false, I) u where or and false are the classical boolean operator.  The discrete integral 
over interval I,notedI, stands for V(+, 0, I).I u de.nes the sum of all values of u over the instants 
of I. Thediscreteintegral allows oneto count the number of instants a boolean term was true on a given 
interval. The temporal operator count, noted #, implements this counter. So, #I u is equal to 1(+, 0, 
I)(if u then . 1else0), i.e. I (if u then 1 else 0). Temporal operator duration, noted ., enables to 
mea­sure the duration in instants of an interval. The term . I is a shortcut for V(+, 0, I) 1, i.e.I 
1. A mean Mean I u of the values of some term u over an interval I can be de.ned as (I u)/ (. I). Temporal 
operator over lists can be de.ned too. For instance, we can build up a list, noted List I u,ofall values 
of a term u over an interval I. The de.nition of List I u is 1(append, [], I)[u] where append is the 
classical operator over lists. Several other temporal operators can still be de.ned as instances of the 
generic operator V. Parameters of the operator Vare classical but intervals of instants. There are many 
ways to de.ne intervals of instants. In this paper, we consider time intervals of the following shape 
|1 b1 .. b2 |2 where |1 and |2 stand either for the symbol [ or for the symbol ] indicating whether the 
bounds are included or not in the interval, and b1 and b2 indicate speci.c instants in the past. bi is 
de.ned by a pair noted -ns where n is a non zero natural number and s is a given clock or signal such 
as seconds, days, etc. Roughly speaking, -ns denotes the instant corresponding to n instants (ticks) 
of clock (or signal) s before the current instant. For example the interval [ -2 day .. -1 day [ would 
specify the instants of yesterday . We also use the bound now as a particular form of b2 to indicate 
the current instant. So, the value of V(.,e,[ -n1 s1 ..-n2 s2 ]) u is (···((e . vt1 ) . vt1+1) ... . 
vt2 )where t1 and t2 are the instants corresponding to n1 (respectively n2)ticks of clock s1 (respectively 
s2)before the current instant. The main di.culty in providing an e.cient operational semantics of the 
operator Vcomes from the de.nition of time intervals. Indeed, the number of instants included in an interval 
of the form |1 b1 .. b2 |2 is always changing ac­cording to the occurrences of the ticks and is not bounded 
in general. Thus, a naive operational semantics may need non bounded space memory in order to evaluate 
the expression V(.,e,|1 -n1 s1 ..-n2 s2 |2) u. We propose in this paper an operational semantics for 
the operator Vwhich uses a bounded space memory. The paper is organized as follows: In the next section, 
we integrate the operator Vinto timed rewrite systems [8] and illustrate it through an example given 
in section 3. Then, we present a .rst approach to compute with Vin section 4. In section 5, we present 
an e.cient operational semantics. Re­lated work and concluding remarks are subject of section 6. Missing 
proofs can be consulted in [7].  2. TIMED TERM REWRITE SYSTEMS In this section, we show how we can integrate 
the oper­ator Vinto a computation model where discrete time in­tervals could be de.ned. The chosen framework 
is timed rewrite systems [8]. A timed rewrite system or program is a pair P = <S ,R> where S is a timed 
.rst order signature and R is a set of timed conditional rewrite rules. A timed .rst order signature 
is a triple <S, S, . >where S is a set of sorts, S is an S+-sorted family of signals and . is an S+-sorted 
family of timed operators. S+ stands for the set of non empty strings over S. We assume that S contains 
at least the sort of booleans, bool, and the sort of naturals, nat. In ., we will distinguish timed functions 
(operators which need arguments) from timed constants. The meaning of a signal in timed rewrite systems 
is very close to the ones introduced in some synchronous languages, e.g., [12, 10]. A signal s of sort 
s1 ,...,sn ,s,noted s : s1 ,...,sn -.s is a stream of operator denotations. These denotations are associated 
implicitly to some instants over time. These instants constitute a set called ticks of s.Hence, the considered 
notion of time is linear and multi-form. Ev­ery signal s is associated to two operators: an operator 
of the  ... ... F0 F1 Ft Figure 1: Store Generation same symbol and the same pro.le as signal s which 
repre­sents the current value of the signal and a boolean operator noted !s which is equal to true on 
the ticks of the considered signal s. The family S contains a distinguished signal we call ref­erence 
signal of pro.le Ref : -. nat.More precisely, Ref is the .nest signal i.e. for all signals s in S,the 
ticks of s are mapped into those of Ref. At the beginning, the value of Ref is 0, then it increments 
by one at each instant. Its value may be useful as a time indicator which gives the number of the current 
instant. Starting from a timed signature, we introduce the notion of timed terms in order to take into 
account the temporiza­tion of operators thanks to the presence of signals. Since the de.nition of a timed 
operator may change at every in­stant, the values of the terms may change too. Timed terms extend classical 
ones by referring to past values of timed terms thanks to the generic operator V. They are de.ned as 
follows: u ::= x | . ( u1 ,...,um ) | V(., e, I) u where x is a variable, m is a natural number (m = 
0), . is a timed operator, u, u1 ,...,um are timed terms, . is a binary timed function, e is a timed 
constant and I is of the form |1 b1 .. b2 |2 as explained in the previous section, with bounds bi are 
of the form -ni si, ni and si representing respectively a non zero natural number and a signal. We call 
past terms the terms of the form V(., e, I) u. Formulas in R are timed conditional rewrite rules of the 
following form: lhs . trhs . B when C where lhs is a .rst order term, trhs is a timed term, B and C 
are possibly empty conjunctions of atoms. lhs . trhs is called head, B body and C tail.If lhs is of the 
form .( u1 ,...,um ), we say that the considered timed con­ditional rewrite rule de.nes ..An atom is 
an equation u1 == u2 where u1 and u2 are two timed terms. The role of tails is to .lter the rewrite rules 
to be considered at each in­stant. A timed program P generates an in.nite sequence of classical (atemporal) 
rewrite systems, Ft, also called stores in the sequel, as depicted in Figure 1. Intuitively, at each 
in­stant t, Ft includes all the rewrite rules clsuch that cl when C is in P and C holds at t.We write 
F.B to note that atom B holds in the classical rewrite system F. A timed operator . is atemporal or static,if 
. is de.ned classically without any reference to timed syntactic entities. Otherwise, . is called dynamic. 
Notice that a classical term rewrite systems consists only of atemporal operator de.nitions. Example 
1. As an additional example, we de.ne here the classical syn­chronous delay operator noted fby . For 
every well-sorted operator . and u of the same sort, . fby u always provides the value of u at the previous 
instant, except at the .rst in­stant at which . fby u is equal to .. It is de.ned as V(f, ., [ - 1 Ref 
..- 1 Ref ]) u such that f is some function for which . is a left identity, i.e., f verifying f(., y) 
== y. This term corresponds in Lustre [13] to . . pre u. The most simple example using fby is counter 
as de.ned below: Counter . 0 fby (Counter+1)  3. EXAMPLE This example is inspired from [2]. The aim 
is to maintain the water level in a steam boiler between two limits low level and high level as far as 
possible. Without any intervention, this level is decreasing because of the outgoing of steam. The value 
of the nat-sorted incoming signal steam provides the current measured steam, and the value of the nat-sorted 
incoming signal level provides the current measured level of water. If the level is out of the interval 
[ low level ; high level ] during more than 5 instants, an alarm must be triggered. The actual alarm 
is triggered whenever a new tick of boolean signal alarm occurs. The de.nition of alarm is: alarm . true 
when . ] -5 Ref .. now ] level > high level == true alarm . true when . ] -5 Ref .. now ] level < low 
level == true Notice that the value of alarm is always true. This is not a problem since we are just 
interested in the ticks of the signal alarm, that is to say, the value of !alarm. This value equals true 
only if one of the two tails above holds. The control of the water level is performed thanks to four 
pumps numbered from 1 to 4 of the same out.ow P. pump 1, pump 2, pump 3 and pump 4 are static operators 
of sort pumps which refer to the respective pumps. P is a nat-sorted static operator. The pumps feed 
the steam boiler with water in order to make up for the outgoing of water steam. They are controlled 
by four signals: pump order(pump 1): -. pump order sort pump order(pump 2): -. pump order sort pump 
order(pump 3): -. pump order sort pump order(pump 4): -. pump order sort  In fact, pump order is an 
array of signals de.ned over pumps. The data type pump order sort consists of two constructors, say on 
and o..When a tick of pump order(p) occurs, an or­der is sent to the pump p. pump order(p) == on means 
that pump p must be working and pump order(p) == o. means that pump p must be idle. We suppose the orders 
are executed before the next instant without failure. From a practical point of view, the di.erence between 
the array of signals pump order and some signal pump order : pumps -. pump order consists in the ticks: 
Four timed operators of the form !pump order(p) are associated to pump order,one for each possible value 
of p.Thus, pump order enables to send orders independently to each di.erent pump. Whereas there is only 
one timed operator !pump order standing for the ticks of pump order . With pump order , the sending of 
an order to only one pump is not possible. The only restriction to de.ne a new array of signals is that 
the type of the indices must be .nite. For each pump p, at each instant, the value and the tick of pump 
order(p) are calculated from a list working pumps of pumps which must work at the next instant. working 
pumps is a timed operator of pro.le working pumps : -. pumps list. In addition, work should be fairly 
distributed among pumps. The-refore, working pumps depends on two parameters: the required number req 
pump nb of pumps to be on as well as the condition of fairness among the pumps. The last pa­rameter is 
achieved by an ordering over the pumps given by a list (of pumps) ord pump list. The .rst elements of 
such a list represent the .rst pumps to be selected to perform the needed work at the next instant. ord 
pump list is a signal of pro.le ord pump list : -. pumps list. req pump nb is a timed operator of pro.le 
req pump nb : -. nat. Whenever the list working pumps is modi.ed, we send the order on to each pump belonging 
to working pumps and o. to the others. So, the de.nition of pump order is: pump order(p) . if is in(p,working 
pumps) then on else o. when is in(p,working pumps) == not (false fby is in(p,working pumps))  The list 
of pumps working pumps is the pre.x of ord pump list such that the length of this pre.x is the required 
number of pumps req pump nb. The de.nition of working pumps is (op­erators pre.x is straightforward): 
working pumps . pre.x(req pump nb, ord pump list) when !ord pump list == true  On the other hand, the 
value of req pump nb depends on the measured quantity of steam (steam)as well as the mea­sured water 
level (level). When level is greater than high level, we need to lower the water level. So, the required 
number req pump nb of working pumps is the result of the division of steam over the out.ow P.When level 
is less than low level, we need to rise the water level. So, the required number req pump nb of working 
pumps is the result of the division of steam by P, incremented by one. Thus, as the formulas calculating 
the number of required pumps are di.erent ac­cording to the position of the level of water, we use a 
timed operator req pump fct : nat -. nat which selects, at every instant, the right formula to be considered. 
req pump nb . req pump fct (steam) req pump fct (s) . sdiv P when level > high level == true req pump 
fct (s) . (s div P)+1 when level < low level == true Note that the previous de.nition induces a way 
of calculat­ing the required number of pumps di.erent from the one of [9], since req pump nb is calculated 
to nearest penny at each instant even if level is between low level and high level. The strategy we use 
to ensure a fair distribution of work among pumps consists in using pumps in turn for a .xed duration 
d1 where d1 is a natural number. The pumps which have worked less than d1 instants are said fresh.The 
timed operator fresh : pumps -. bool allows one to test if a pump is fresh or not. fresh (p) . (true 
fby pump order(p) = on) and (.[-1 pump order(p) .. now [ <d1) ord pump list is built by appending two 
sublists: the still fresh working pumps and the remaining pumps. The fresh working pumps are put at the 
beginning of ord pump list be­cause they must continue working until they reach the limit of d1 instants. 
Both sublists are ordered according to the total working duration of each pump for the last d2 instants 
where d2 is a natural number greater than d1.The timed operator before : pumps list, pumps list -. bool 
stands for the order relation over pumps. before (p1, p2) means that p1 is before p2 in ord pump list. 
before (p1,p2) . if fresh (p1) = fresh (p2) then #[-d2 Ref .. now [ (pump order(p1) = on) <#[-d2 Ref 
.. now [ (pump order(p2) = on) else fresh (p1) From this order, we can build a timed function insert 
: pumps, pumps list -. pumps list which inserts a pump in an ordered pump list and returns an ordered 
pump list (w.r.t. before). The function insert is involved in the de.nition of a timed function sort 
: pumps list -. pumps list which sorts a list of pumps w.r.t. before. insert (p,[]) . [p] insert (p1,p2::l) 
. if before (p1,p2) then p1::(p2::l) else p2::(insert (p1,l)) sort ([]) . [p] sort (p::l) . insert (p,sort 
(l)) Finally, the de.nition of ord pump list is: ord pump list . sort ( [ pump 1 ; pump 2 ; pump 3 ; 
pump 4]fby ord pump list) Now, we want a tool to analyze, in the last day, the time lapses during which 
the pumps had worked (without breaks). In a normal functioning mode, all these durations should be between 
d1 and d2. The tool we choose is an his­togram consisting of three columns. The .rst column (resp. the 
second and the third) represents the number of times a given pump has worked for a duration less than 
d1 in­stants (resp. between d1 and d2 instants and more than d2 instants). The working duration of each 
pump is encoded in an array of nat-sorted signals noted working time indexed by pumps. The tick of signal 
pumps (p) occurs only when a pump stops working because this instant is the one at which the computation 
of the working duration becomes possible. The de.nition of working time is: working time (p) . .[-1 pump 
order(p) .. now ] when !pump order(p) == true, pump order == on The beginning of a new day is given 
by the occurrence of a tick of a boolean signal, noted day. The data structure which represents the histogram 
is a timed function noted histo : pumps -. histograms where the canonical elements of histograms are 
of the form < nat, nat, nat >.If histo (p) == <b, i, a >holds, b, i and a stand for the height of the 
respective .rst, second and third columns. The following de.nition of histo is based on the fact that 
two histograms over time intervals I and I' can be merged into one over interval I . I'.So, histo is 
the merging of all the histograms built from working time (p) at the instants of interval [-2 day .. 
-1 day [ whenever a tick of working time (p) occurs. histo (p) . 1(add histo, empty histo, [-2 day .. 
-1 day [) (if !working time (p) then nat2histo (working time (p)) else empty histo) The static operator 
nat2histo : nat -. histograms calculates a histogram from the value of one given instant. add histo is 
the merging over the histograms, i.e. the function add histo : histograms, histograms -. histograms which 
performs the ad­dition of each column of the histograms. empty histo is an operator of pro.le empty histo 
: -. histograms representing the empty histogram. The de.nitions of these operators are: nat2histo (n) 
. if n <d1 then <1, 0, 0 > else if n = d2 then <0, 1, 0 > else <0, 0, 1 >. empty histo . <0, 0, 0 > add 
histo (<b, i, a >, <b , i , a >) . <b+b , i+i , a+a >  4. LABELED TRANSITION SYSTEM We assume in the 
sequel that a timed rewrite system P is givenwithsignature <S, S , . >. As depicted in Figure 1, a run 
of a program P generates a stream of stores, F 0, F 1, ..., F t,etc. In this section, we brie.y give 
a .rst, eas­ily comprehensible semantics de.ned by means of a labelled transition system. To each instant 
t, corresponds a state of such a transition system which contains, among other tech­nical entities, a 
classical term rewrite system F t. Roughly speaking, the computation of F t is done in three stages: 
P a , P ß and P . . We explain these stages in the following. For­mal de.nitions of these transformations 
can be found in [7]. This semantics is not meant to de.ne an actual operational semantics. We de.ne a 
tractable one in the next section. 4.1 Past term replacement: P a P a is obtained from P ,at instant 
t, by eliminating the past terms. This calculus is performed by a function o.) t depending on time instant 
t and de.ned on the structure of the timed rewrite rules, so that, at a given instant t, P a = oP) t 
. o.) t replaces every term u occurring in P of the form  V(. ,e, | 1 - n1 s1 ..- n2 s2 | 2) . byt in 
|1t1,t2|2 L .l t where t1, respectively t2, denotes the absolute instant which cor­responds to the value 
of Ref, n1 ticks of s1 before instant t, ' respectively n2 ticks of s2 before instant t. The annotation 
t t in the operator L .l tindicates the instant at which . must  be considered. We notevi for (...(vi1 
. vi2 ) ... . i in l vin )if l is a .nite sequence i1, i2, ..., in of indices. So, for instance, o V(. 
,e, [ - n1 s1 ..- n2 s2 ]) .) t =(...(vt1 . vt1+1) ... . vt2 ). t1 is equal to abs instant( n1 , s1 ,t 
)and t2 is equal to abs instant( n2 , s2 ,t )where abs instant is a function satisfying the following 
properties: At the instant abs instant( n, s ,t ), atickof s occurred.  Exactly n ticks of s had happened 
from the instant  abs instant( n, s ,t )until t - 1. Thus, if instant t is the current instant, abs 
instant( n, s ,t ) is the instant which happened n ticks of s ago. The function abs instant is partial. 
Indeed, abs instant( n, s ,t ) is not de.ned if less than n ticks of s had occurred from the .rst instant 
0 until t -1. So, if abs instant is not de.ned on ( n1 , s1 ,t ), then we con­sider t1 = 0. In addition, 
if abs instant is not de.ned on ( n2 , s2,t ), then u is replaced by operator e.If the interval |1 -n1 
s1 ..-n2 s2 |2 is empty then we consider u is replaced by e too. Finally, the formal de.nition of o.)t 
is given below. Recall that Pa = oP)t . By abuse of notation, we note oX)t the application of o.)t on 
X where X could be either, a program, a timed rewrite rule, a conjunction of atoms, an equation, or a 
term. t) Let P be a program and t an instant. Pa = oP)t is de.ned as follows. -on sets of timed rewrite 
rules Definition 1. (o.) oP)t = {o.)t /. .P } -on timed rewrite rules olhs .trhs . B when C)t = lhs .otrhs)t 
.oB)t when oC)t -on conjunctions of timed atoms oB .B ' )t = oB)t .oB ' )t -onequations tt t ou1==u2)= 
ou1)==ou2)ox)t = x ttt t o.( u1,...,um ))= o.)( ou1), ... , oum)) -on operators o.)t = L.lt if . is dynamic 
o.)t = . if . is static Where ., .and e are timed operators, n1 and n2 are non zero natural numbers, 
s1 and s2 are signals, x is a variable, lhs is a .rst-order term, trhs, u1,...,um-1 and um are timed 
terms, m =0, B, B ' and C are timed atoms and P is aset of timedrewrite rules. Example 2. Consider the 
following toy example: 1. t-list .1(append, [], [ -2 s1 .. -1 s2 [ ) (if !f then [Ref] else []) 2.f(x) 
.x-1 when v > 10 == true 3.f(x) .x+1 when v < 0== true 4. append([], l) .l 5. append(e :: l, l ) .e 
:: (append(l, l ))  where t-list is a nat list-sorted timed operator, f is a signal of pro.le nat -. 
nat, append is a static operator of pro.le nat list, nat list -.nat list, s1 and s2 are two bool-sorted 
incoming signals and v is a nat-sorted incoming signal. We suppose that the current instant is instant 
4 and that the following incomings are available: Instant 0 1 2 3 4 !s1 true true true false true s1 
true true true true true !s2 true true false true true s2 true true true true true !v true true true 
true true v 14 13 12 11 10 -onpastterms u of the form V(.,e, |1-n1 s1 ..-n2 s2 |2) u ' ou)t = tt in 
|1 t1 ;t2 |2 ou ' )tt if {t1 = abs instant( n1 , s1,t ) t2 = abs instant( n2 , s2,t ) if ou)t = tt in 
[0;t2 |2 ou ' )tt { abs instant is not de.ned on ( n1 , s1 ,t ) t2 = abs instant( n2 , s2 ,t ) ou)t = 
e if abs instant is not de.ned on ( n2 , s2,t ) -on the other timed terms abs instant(2 , s1 , 4) = 
1 and abs instant(1 , s2, 4) = 3. Thus, at instant 4, Pa for this speci.cation consists of .ve timed 
rewrite rules 1a , 2a , 3a, 4 and 5 where: 1a . lt-list14 .append ( if l!f11 then [lRef11] else [], if 
l!f12 then [lRef12]else[]) 2a . lf14(x) .x-1 when lv14 > 10 == true 3a . lf14(x) .x+1 when lv14 < 0== 
true Notice that the timed rewrite rules 4 and 5 are unchanged by o.)4 because append is a static operator. 
The elimination of the past terms may give rise to new terms with an unbounded size. Indeed, consider, 
at the current instant t, the past term u = . [ -1 s ..-1 Ref ] u ' . Assume that the last tick of signal 
s occurred at instant t ' . tt Then, u is replaced by a disjunctiontt.[tou ' )t. tt ,t-1] Since the 
length of the interval [ t ' ,t -1 ] will increase as far as no tick of signal s occurs, the size of 
the disjunction has no bound. So, this semantics may need an unbounded amount of memory. We show in the 
next section how this problem can be tackled using a .nite memory. 4.2 Adding needed de.nitions: P ß 
In the second stage, we compute a new program P ß . P ß = P a . In . D where In is the set of rules de.ning 
the incoming signals and D consists of rewrite rules de.ning the new operators introduced in P a,of the 
form L .l tt ,where 0 = t ' <t. The axioms in D are copied from the stores previously computed. At the 
end of this stage, is a P ß timed program without any reference to past terms. Example 3. Consider the 
timed program P a given in Example 2. At instant 4, the rewrite rules de.ning the value of the incoming 
signals (In)are: 6ß 4 .4 7ß . lRef1. lv14 .10 8ß 9ß . ls114 .true . ls214 .true 12 1 In addition, we 
need the de.nitions of l!f1, l!f1, lRef1 2 and lRef1to complete P a . These de.nitions (D), given below, 
are available in the stores F 0 and F 1. 10ß . l!f11 .true 11ß . l!f12 .true 12ß . lRef11 .1 13ß . lRef12 
.2 So, at instant 4, P ß consists of all the timed rewrite rules of P a and the rewrite rules 6ß to 13ß 
.  4.3 Tail removal: P . At a third stage, we compute a new program P . from P ß . P . consists of rewrite 
rules cl such that a timed rewrite rule cl when C is in P ß and C holds in P ß . Whenever all the tails 
of rules de.ning an operator L .l t in P ß are false, we de.ne L .l t in P . as L .l t-1 . This last 
operation enables the timed operators to have a value even if they are not rede.ned at the current instant 
(remanence property). At instant t, if s is a signal and if its value L sl t has been rede.ned, then 
atickof s occurs and the rule L !sl t . true is added to P . . Otherwise, no tick of s occurs and the 
rule L !sl t . false is added to P . . Example 4. Consider the timed program given in Example 3. At instant 
4, since the value of v is 10, neither the tail of the timed rewrite rule 2a, nor the tail of the timed 
rewrite 4 rule 3a holds in P ß . Thus, the de.nition of lf1is the one of F 3 up to renaming of the operators. 
Assume the timed rewrite rule de.ning lf13 in F 3 is lf13(x) .x-1.Hence, the 4 de.nition of lf1occurring 
in P . is: 2. . lf14(x) .x-1 In P ß, apart from the timed rewrite rules 2a and 3a,the remaining timed 
rewrite rules have an empty tail. Hence, they belong to P ., straightforward. Since f, v, s1 and s2 are 
signals, the following timed rewrite rules de.ne their tick: 14. . l!f14 .false 15. . l!v14 .true 16. 
. l!s114 .true 17. . l!s214 .true 18. . l!Ref14 .true So, P . consists of the rewrite rules 1a , 2. , 
4, 5, 6ß to 13ß and 14. to 18. . The reduction of term t-list leads to [1; 2]. Since all the timed rewrite 
rules are considered at the same instant, the deletion of their tails may be not computable due to causality 
loops. The following program illustrates the problem: A .true when B == true B .true when A == true 
The computation of the de.nition of L Al t requires the com­putation of the de.nition of L Bl t and vice 
versa. Hence, the elimination of tails is not possible in this case. The problem of causality loop exists 
in most of synchronous programming languages [14]. A solution consists in stratifying the consid­ered 
program, i.e., .nding an ordered partition of the set of the timed operators into subsets, say strata, 
such that: Requirement 1. The tails of each timed rewrite rule of a given stratum are expressed through 
the operators of the lower strata. Strati.cation of programs has also been considered in logic programming 
languages (e.g. [17]). In addition, for real­time applications, tails should be decidable and computable 
in a sensible amount of time. The problem of the number of formulae in a store: Consider the following 
speci.cation of a counter. Counter .0 fby (Counter+1) At instant 0, F 0 contains lCounter10 .0.At instant 
1, F 1 contains lCounter11 .lCounter10 +1 and lCounter10 .0.At 1 instant 2, F 2 contains lCounter12 
.lCounter11 +1, lCounter1 .lCounter10 +1 and lCounter10 .0. So, at each instant, the number of timed 
rewrite rules occurring in the current store increases by one. The memory space increases at the same 
rate. This problem will be solved in the next section. 4.4 Labelled transition system P a , P ß and 
P . are the three stages leading to the con­struction of the store F t at a given instant t. The follow­ing 
labelled transition system indicates from a more general point of view how the stores will be generated 
over time during the execution of the timed program. Definition 2. (labelled transition system) Let P 
be a timed program. The associated labelled transition system is a tuple <Q, L, -. ,Init> such that : 
 Q is the set of states.A state is a pair <H , F > where H ,called history, is a list of stores and F 
is a store. The stores de.ne at di.erent instants operators occurring in P .  L is the set of labels 
where a label is a set of rules de.ning the incoming signals.  -.. Q× L× Q is the transition relation 
de.ned as fol- In lows. We write C 1 -. C 2 for a triple <C 1 ,In, C 2 > . In -. . A transition <H , 
F t > -. <[F t |H ] , F t+1 > occurs i. F t+1 is the store computed at the instant t+1 starting from 
the program P , the history [F t |H ] and the input signals given by In. Init is a function L -. Q of 
initialization such that if In0 represents the de.nitions of the incoming signals at instant 0 then Init(In0)= 
<[] , F 0 >. A state, <H , F >, is composed of the current store, F , and the history, H , a list of 
the previous stores. Notice that the computation of F may need some de.nitions from old stores we can 
.nd in H . However, since the history is not bounded, the de.nition of the labelled transition system 
as de.ned above is not realistic. So, we propose in the following section a new tractable semantics. 
 5. ACTUAL OPERATIONAL SEMANTICS In this section, we propose some su.cient conditions un­der which we 
can develop an operational semantics using a bounded space memory. As in the previous section, we will 
show how current stores are generated following three ' stages, Pa' , Pß ' and P. . The .rst stage generates 
a timed program Pa' without any reference to past terms just like Pa . Pa' is equal to tt oP) where o.) 
is a function de.ned in the same way as o.)t . The di.erence with Pa is that the past terms u of the 
form V(.,e,I) u ' where u ' is a classical .rst order term, are replaced by Lul where Lul is a new well-sorted 
operator. In thefollowing, wecall new operators the operators of the form Lul in Pa' . The calculus of 
the de.nition of the new operator will be possible at every instant, if the following requirement are 
ful.lled. Requirement 2. Every past term u of the form V(.,e,I) u ' satis.es the fol­lowing properties: 
1. The timed term u ' contains no free variable. 2. The binary operator . is an associative, deterministic 
and recursive static operator. 3. The timed constant e is a deterministic static operator and a left 
identity for .. 4. u ' is computable in a sensible duration at each instant.  Item 1 from Requirement 
2 can be weakened. The new item is: 1 . The sorts of the free variables occurring in u ' are .nite. The 
example given in Section 3 veri.es the weakened Re­quirement 2. t The formal de.nition of o.) on the 
timed terms is: oV(.,e,I) u ' ) t = LV(.,e,I) ou ' ) t l ox) t = x o.( u1 ,...,um )) t = .( ou1) t ,... 
, oum) t ) Note that all the timed terms are transformed into classi­cal .rst order terms. Thus, all 
the new operators are of the form LV(.,e,I) u ' l where u ' is a classical .rst order term. Example 5. 
Consider the program in Example 2. The only timed rewrite rule containing a past term is the timed rewrite 
rule 1. Thus, at instant 4, Pa' consists of the .ve timed rewrite rules 1a' , 2, 3, 4 and 5 such that: 
1a' . t-list .l1(append, [], [ -2 s1 .. -1 s2 [ ) (if !f then [Ref] else []) 1 Generation of Pß ' consists 
in adding to Pa' the rewrite rules de.ning the new operators and the incoming signals. Now, we show how 
it is possible to compute the value of past terms within a bounded space. We illustrate our algorithm 
on the case of term, u,of the form V(.,e,[ -n1 s1 ..-n2 s2 [) u ' 0 t1 t2 t I9 I8 I7 I6 I5 I4 I3 I2 
I1 Figure 2: Interval partition where u ' is a classical .rst order term. Recall that, according to 
the semantics given in the previous section (De.nition 1), t t ' t the value of ou)is equal to ou )where 
t1 (resp. tt in [t1,t2[ t2) is the absolute instant corresponding to the bound -n1 s1 (resp. -n2 s2). 
The length of [t1,t2[ is not bounded, and so the number t of elements occurring in ou ' )t.To overcome 
tt in [t1,t2[ this issue, we propose a way to split the interval [t1,t2[into subintervals so that the 
computation of the value of ou)t be­ comes feasible using a bounded space memory. Let I1,...,Ik be a 
partition of [t1,t2[. We associate a constant wi for ev­ery interval Ii. wi corresponds to the value 
ou ' )tt . tt in Ii Since, by Requirement 2, . is associative, the value of ou)t is equal to wi. i.[1,k] 
 Such a partition changes over time and should be available at every instant. Hence, we should keep preparing 
the forth­coming partitions. Our proposal consists in partitioning at every instant t, the interval [0,t[ 
as follows: Definition 3. (Interval partition) Let t and t ' be two instants less than t. Assume t ' 
<t. t and t ' belong to the same interval i. 1. either t,t ' = t2 (with t2 = abs instant( n2 , s2 ,t)) 
and for all instants t '' such that t ' = t, Fttt . <t '' !s1==false and Fttt .!s2==false. 2. or t,t 
' <t2 and for all instants t '' such that t ' < t '' =t, Fttt .!s1==false. 3. or t2 does not exist (i.e., 
not enough s2 ticks)and for all instants t '' such that t ' =t, Fttt .!s1==false <t '' and Fttt .!s2==false. 
 In the previous de.nition, item (1) suggests to partition the interval [t2,t[ according to the ticks 
of s1 or s2.That is to say, [t2,t[=[t2,t1[ . [t1,t2[ .··· . [tm,t[ such that the set {t1,...,tm} consists 
of all the instants which coincide with atickof s1 or s2 in the interval [t2,t[. Item (2) suggests to 
partition the interval [0,t2[ according to the ticks of s1. That is to say, [0,t2[= [0,t1[ . [t1,t2[ 
.··· . [tm,t2[such that the set {t1,...,tm} consists of all the instants which coincide with a tick of 
s1 in the interval [0,t2[. Whenever t2 is not de.ned, item (3) suggests to partition the interval [0,t[accordingtothe 
ticks of s1 or s2. In the sequel we consider that the intervals, (Ii)i, de.ned by De.nition 3 are numbered 
from the most recent to the oldest as depicted in Figure 2. Thus, 1 is the index of the interval which 
has the form [b1,t[where b1isaninstant of the past, i.e. b1 . [0,t[. We will denote by z, l and r the 
indices of the following intervals of the partition: Iz is of the form [0,bz[, Il is of the form [t1,bl[and 
Ir is of the form [t2,br[where bz,bl and br are instants of [0,t[. Example 6. Consider the new operator 
l1(append, [], [ -2 s1 .. -1 s2 [ )(if !f then [Ref] else []) 1in Example 5. Since abs instant(1 , s2, 
4) = 3, the interval partition is {[0,0]; [1,1]; [2,2]; [3,3] }at instant 4.Thus, z is 4, l is 3 and 
r is 1. At the next instant, since abs instant(1 , s2, 5) = 4,the interval partition is {[0,0]; [1,1]; 
[2,3]; [4,4] }. Thus, at instant 5, z is 4, l is 2 and r is 1. We can show (see [7]) that at most the 
last n1 + n2 inter­vals, say, In1+n2 ,...I1 are su.cient to compute the value of term u. In practice, 
we introduce a data structure called memory and denoted Memu, which allows us to evaluate u at every 
instant. Informally, this data structure encodes ei­ther the last n1+ n2 intervals of the partition de.ned 
above as well as the evaluation of V(.,e,Ii) u ' for every interval, Ii, of the considered partition. 
Definition 4. (Memory) Let u = V(.,e,[ -n1 s1 ..-n2 s2 [) u ' be a past term and t be the current instant. 
The memory Memu at t is a triple <v, x1 ,x 2 > such that v is a sequence of n1+n2 terms and x 1 and x 
2 are sequences of n1+n2 truth values of a 3-valued logic (T -true-, .-false-, u -unde.ned-). We represent 
a memory Memu by the following .gure: vn1+n2 ... v2 v1 [ 1 1 1 1 xn1+n2 ... x 2 x1 2 2 2 xn1+n2 ... 
x 2 x1 The interpretation of elements vi, xi 1 , xi 2 is de.ned by the following invariant over the 
data structure Memu. Definition 5. (Memory invariant) Let u = V(.,e,[ -n1 s1 ..-n2 s2 [) u ' be a past 
term and Memu be the memory for u at t.Let {Iz; ...; I1}be the interval partition at t.The invariant 
for Memu is the con­junction of the following assertions: 1. (if t1 is de.ned and i =l) or (if t1 is 
not de.ned and i =z),then vi = ou ' )tt , tt in Ii x 1 i = Tif Ii begins with a tick of s1 and x 1 i 
= . otherwise,  and xi 2 = T if Ii begins with a tick of s2 and xi 2 = .otherwise.  2. i> z i. vi = 
e, xi 1 = u,and xi 2 = u. Example 7. Consider Example 6. Since the invariant is veri.ed, the memory for 
1(append, [], [ -2 s1 .. -1 s2 [ )(if !f then [Ref] else []) at instant 4 has to be:  [1] [2] [3] [1 
TT . T.T x\y T. u T TTT . T.. u T. u Figure 3: Truth table of .in the 3-valued logic From a memory Memu 
verifying the invariant, it is easy to compute at each instant the indices l and r by using the sequences 
x 1 and x 2 and then deduce the value of term u from the sequence v. We give in De.nition 6 a formal 
def­inition of the computation of the value of u. For that, we introduce .rst a couple of technical de.nitions. 
We note by Index( n, x, i)where n,i . N , n> 0, 1 =i =n1 + n2 and x is either x 1 or x 2, the lowest 
index i ' over x such that there are exactly n occurrences of Tin xit ,...,xi. Roughly speaking, Index( 
n, x 1 , 1 ) is the index of the interval be­ginning with abs instant( n, s1 ,t)where t stands for the 
current instant. Symmetrically, Index( n, x 2 , 1) is the in­dex of the interval beginning with abs instant( 
n, s2,t). Figure 3 provides the de.nition of the disjunction .in the 3-valued logic which we use in the 
following de.nition. .is the unique extension of the boolean disjunction where u is the identity. Definition 
6. (Past term calculus) Let u = V(.,e,[ -n1 s1 ..-n2 s2 [) u ' be a past term and Memu be the memory 
for u at instant t which veri.es the invariant (De.nition 5). The value of u is de.ned by: u = 12 vi 
i in Index(n1 ,x, 1),...,Index(n2 ,x, 1)+1 if Index( n1 ,x 1 , 1) and Index( n2,x 2 , 1) are de.ned. 
u = 2 vi i in n1+n2,...,Index(n2 ,x, 1)+1 if Index( n1 ,x 1 , 1) is not de.ned and Index( n2 ,x 2 , 1) 
is de.ned, u = e if Index( n2 ,x 2 , 1) is not de.ned. In the previous de.nition, the lists of interval 
indices Index( n1,x 1 , 1), ..., Index( n2 ,x 2 , 1)+1 and n1 + n2, ..., Index( n2 ,x 2 , 1 ) + 1 are 
ordered in the descending or­der because the intervals are numbered from the most recent to the oldest. 
The de.nition which we add to Pß ' is Lul.v where v is the calculated value of u. Requirement 2 ensures 
the computability of the de.nition. Example 8. Consider the memory of 1(append, [], [ -2 s1 .. -1 s2 
[ )(if !f then [Ref] else []) in Example 7. Index(2 ,x 1 , 1) = 3. Index(1 ,x 2 , 1) = 1. Thus, at in­stant 
4, the value of 1(append, [], [ -2 s1 .. -1 s2 [ )(if !f then [Ref] else []) is append(v3, v2) i.e. [1; 
2]. We focus now on the way Memu is updated at each in­stant. In Figure 4, we give the inference rules 
which are applied at each instant. Rule (V-0) initializes the data structure with left identities, e 
for sequence v and u for x 1 and x 2.Rule (V-1) is applied whenever both signal ticks of s1 and s2 are 
absent. In this case, interval I1 is augmented by one instant, and thus the new value v1 is equal to 
the value of v1 at the previous instant augmented -using opera­tor .-by the previous value of u ' , i.e. 
v0.Rule (V-2) is a (1-0) if t=0 e...e e 1 1 u ... uu 1 u ... uu v... v2 v1 n1+n2 1 1 11 1 x...xx1 n1+n2 
21 1 2 22 x...xx n1+n2 21 (1-1) vn1+n2 ... v2 v1 .v0 1 1 111 1 x...xx.x1 n1+n2 21 0 2 222 x...xx.x 
n1+n2 21 0 if Ft-1 f!s1==false, Ft-1 f!s2==false and t> 0 v... vit+2 vit vit-1 ... v1 n1+n2 vit+1 1 
1 1111 1 1 (1-2) x...xxxx...x1 n1+n2 it+2 it+1 it it-11 1 2 2222 2 x...xxxx...x n1+n2 it+2 it+1 it it-11 
 vn1+n2 ... vit+2 vit+1 .vit vit-1 ... v1 v0 1 1 1 11111 x...xxx...xx1 n1+n2 it+2 it+1 it-1 10 1 2 22222 
x...xxx...xx n1+n2 it+2 it+1 it-1 10 2 if Ft-1 f!s2==true,Index( n2 ,x, 1 ) is de.ned ' 21 ' i = Index( 
n2 ,x, 1),xit = .,i <n1 + n2, 1 x = u and t> 0 it+1 v... v2 v1 n1+n2 1 1 11 1 x...xx1 n1+n2 21 1 2 
22 x...xx n1+n2 21 (1-3) otherwise v... v1 n1+n2-1 v0 1 1 11 1 xn1+n2-1 ...xx1 10 2 22 xn1+n2-1 ...xx 
10 ' 1 where v0 stands for the value of u in Ft-1, x0 for the truth value 2 of !s1==true in Ft-1 and 
x0 for the truth value of !s2==true in 1 Ft-1.So, x0 is true i. a tick of s1 occurred at the previous 
2 instant, and symmetrically, x0 is true i. a tick of s2 occurred at the previous instant. Figure 4: 
Memory rules bit technical. Informally, Rule (V- 2) is applied whenever a tick of signal s2 occurs, t2 
shifts to next tick of s2 to the right, and no tick of the signal s1 happened at the previ­ous t2. Consider, 
for instance, the situation as depicted in Figure 2. Assume that t2 moves to the left bound of inter­val 
I3. In the new interval partition, the previous intervals I4 and I5 are uni.ed. i ' and i ' + 1 indicates 
the indices of such intervals to be uni.ed. Since . is associative (Require­ment 2), the new data corresponding 
to the uni.ed interval is given by vit+1 . vit , x 1 and x 2 .Rule (V- 3) is used it+1 it+1 whenever 
the three other rules cannot be applied. It creates a new interval, initialises the corresponding values, 
namely v1, x11 and x12, and shifts all columns one step to the left. In this case, the values of the 
preceding instant corresponding th to the (n1 + n2) interval are lost. Note that Require­ment 2 ensures 
the computability of terms v0, v1 . v0 and vit+1 . vit . Example 9. Consider the memory of 1(append, 
[], [ -2 s1 .. -1 s2 [ )(if !f then [Ref] else []) in Example 7. We calculate the new value of this memory 
at instant 5. Since F4 . !s2==true, (V- 1) is not the rule to apply. 211 Whereas, Index(1 ,x , 1) = 
1, x1 = . and x2 = u.Thus, the memory is updated by (V- 2).Since append(v2 , v1) is reduced in [2; 3], 
the memory of 1(append, [], [ -2 s1 .. -1 s2 [ ) (if !f then [Ref] else []) at instant 5 is: [1] [2;3] 
[] [1 T TT T .T Considering the interval partition at instant 5 given in Ex­ample 6, the memory veri.es 
the invariant. Hence, since Index(2 ,x 1 , 1) = 2 and Index(1 ,x 2 , 1) = 1,the value of 1(append, [], 
[ -2 s1 .. -1 s2 [ )(if !f then [Ref] else []) is v2 i.e. [2; 3]. The rules given in Figure 4 must be 
applied to the mem­ories at each instant t, before the store computation. Af­terwards, the updated memories 
verify the invariant, and thus permit a sound computation of Pß ' for instant t. Pß ' consists of the 
timed rewrite rules of Pa' in addition to the de.nition of the incoming signals and the de.nition of 
the new operators which are calculated from their associated memories. P. ' consists of the rewrite rules 
in Pß ' whose tail is either true or absent. If all the tails of the timed rewrite rules de.ning a timed 
operator . are false, we de.ne . in P. ' by its remanent de.nition borrowed from the store of the previous 
instant. The soundness of this actual operational semantics is stated in following. Theorem 1. Let P 
be a timed rewrite system satisfying requirements 1 and 2. At each instant t, for all timed operators 
., L.lt in P. ' and . in P. represent the same mathematical operation. From the point of view of e.ciency, 
if we consider the memory space for storing a term as unit, the computer mem­ory space for a past term 
memory is in O(n1 + n2). This can be reduced to O(n1) in the particular cases of inter­val of the form 
|1 -n1 s1 ..-n2 s1 |2 or |1 -n1 s1 ..now |2,be­cause the partition of the past just requires to be performed 
according to the signal s1 instead of both signals s1 and s2. Consider the execution time of . is unitary, 
that is to say, the computation of the value of x .y is performed in a duration 1. According to De.nition 
6, the calculus of the past term u = V(.,e,I) u ' is performedintime O(n1 + n2) in the worst case. This 
result has to be quali.ed, because the value of u does not need to be re-computed at each instant. In 
fact, this value only changes whenever the val­ues of Index( n1 ,x 1 , 1) or Index( n2 ,x 2 , 1 ) change, 
i.e. whenever a tick of s1 or s2 occurred at the previous in­stant. The duration for updating the past 
term memories has to be considered too. According to Figure 4, it is in O(n1 + n2). However these updates 
could be performed in a constant time if suited data structures are used such as double-chained lists, 
queues of pointers. We actually used such structures in our current implementation prototype. In the 
case of very closed ticks of Ref, the memory up­dating, even in constant time, can raise problems due 
to hard real-time requirements where updates should take a very short period of time. However, for a 
past term u = V(.,e,[ -n1 s1 ..-n2 s2 [) if b then u ' else e such that u veri.es Requirement 2, e is 
a right identity for . and b and u are timed terms, the memory, Memu, just requires to be updated whenever 
at the previous instant, a tick of s1 or s2 occurred or b was true. We only treated the case of left-open 
right-closed inter­vals. However, the operational semantics of past terms can be generalized to any kind 
of interval whatever the bounds are open or closed. The results about the space and time complexity are 
the same.  6. CONCLUSION AND RELATED WORK We have proposed a new generic operator, V,which can be used 
within any programming language which allows one to de.ne discrete time intervals. The proposed operator 
en­ables one to use some high level temporal operators in a declarative way. We showed how Vintroduces 
timed terms in rewrite systems. We also provided a concrete e.cient operational semantics of timed terms 
which we have imple­mented. Synchronous languages are specially designed for reactive programming [14]. 
However, their notion of signal is more restrictive than the one we give, because they cannot handle 
functions as signals. The most representative declarative synchronous languages are Lustre [10] and Signal 
[12]. The primitives of the latter languages may be grouped into three categories: The classical arithmetic 
or logical operators are static operators extended to streams. We can de.ne them as atemporal operators. 
 The delay operators (pre in Lustre and $ in Signal) allow one to access during the execution to past 
values of signals. The corresponding operator is fby in our formalism.  The polychronous operators perform 
intersections on signal ticks or unions with a deterministic merge of the corresponding values. This 
can be easily expressed by tail formulas.  Lustre and Signal do not provide time interval de.ni­tions 
in the respective kernel languages and thus our generic operator cannot be incorporated directly. However, 
exten­sions which provide a notion of time interval have already been developed to improve the design 
of declarative syn­chronous languages like SignalGTi [21]. In SignalGTi,if B and E are two distinct signals 
with alternative ticks, the time interval ]B,E] is a boolean signal which is true if the cur­rent instantisinaninterval 
]B,E] and false otherwise (i.e. in an interval ]E,B]). This signal can be de.ned as the past term 1(and, 
true, [ -1B.. -1E [ )false . Thisterm isinitialized to true, but an initialization to false is possible 
by using the past term 1(or, false, [ -1E .. -1B [ )true .If B and E are the same signals, ]B,B] is a 
boolean signal the value of which changes each time a tick of B occurs at the previous instant. The equivalent 
past term of such a time interval is 1(xor, false, [ -1 Init .. now [ )!B where Init is a signal, the 
ticks of which occur only at the .rst instant 0. This term is initial­ized to false. For an initialization 
to true,term not (1(xor, false, [ -1 Init .. now [ )) !B can be used. So, time interval of SignalGTi 
is an instance of our generic operator. Esterel [6] is a imperative synchronous programming lan­guage. 
All the basic elements for de.ning discrete time in­tervals such as signals are yet present in the kernel 
language. Thus, in principle, our operator can be added to such im­perative synchronous language. The 
absence of time notion in ccp has led to the devel­opment of a new synchronous paradigm tcc [22] based 
on ccp and preserving its good properties. We share with tcc the principle of a very expressive evolving 
store. However, the way of expressing the store changes is completely dif­ferent. In tcc, the stores 
are generated from processes and the process algebra is orthogonal to the formalism express­ing formulas 
of the stores. Moreover, these formulas are atemporal and not remanent. Thus, the data transmission from 
an instant to another is performed explicitly by the combinator next of the process algebra. The timed 
rewrite system, we propose, is data-oriented. The mechanisms of data transmission, which are hidden from 
the user, could be rather complicated (see Figure 4). ntcc [19] extends tcc by adding non-determinism. 
This paradigm has, among others, two operators noted ! and . !P means P will be always true in the current 
store and in the future ones , P means P will be true in the current store or in some future one . From 
a logic point of view, ! and . are the respective du­als in the future of operators . and . de.ned in 
Section 2. From a procedural point of view, ! and . can be consid­ered as behavior generators, whereas 
. and . are behavior testers. ! and . can be applied just to a speci.c interval of time in the future. 
However, this interval is expressed using the base time unit: no other granularity is provided. Another 
class of programming languages related to our formalism is the temporal logic programming languages. 
An interesting overview is presented in [18]. The meaning of temporal for languages like Templog [1] 
and Temporal Prolog of Gabbay [11] is not the same as the one in the synchronous world. The time is indeed 
represented in a constraint system and does not constraint temporally the execution of the program. So, 
the causality of the condition in formulas is not preserved in these extensions of the logic programming, 
whereas it is in our paradigm. On the other hand, these languages have the temporal operators . (al­ways) 
and . (eventually) but without scope over some time interval. Chronolog is a data-.ow temporal logic 
language [23] designed to do e.cient computation. However, this lan­guage only manages one clock. Since 
the need for a multi­granular time is very important in temporal programming, Chronolog(MC) [16] has 
been developed. Nevertheless, this language is not synchronous at all. Timed Rewriting Logic (TRL) [15] 
is an extension of Meseguer s rewriting logic. It has been introduced to extend languages based on algebraic 
speci.cation framework in or­der to specify applications which involve time. Rules in TRL are of the 
form lhs - lr . rhs which means, informally, that a rewriting step using such a rule, labeled l,lasts 
r amount of time. This formalism departs from ours. Rules in TRL are dedicated to rewrite con.gurations 
of a system. Thus, such rules could be con­sidered as transition rules of a Kripke structure whereas 
the timed rewrite rules we considered in this paper are dedi­cated to rewrite classical data terms. In 
addition, signals, clocks or instants are not considered as .rst-class citizens in TRL which make the 
de.nitions of intervals of instants not straightforward. Hence, our generic operator could not be added 
to TRL in an obvious way. Acknowledgments We would like to thank anonymous referees for helpful re­marks 
and for pointing us reference [15].  7. REFERENCES <RefA>[1] M. Abadi and Z. Manna. Temporal logic programming. 
Journal of Symbolic Computation (JSC), 8(3):277 295, September 1989. [2] J.-R. Abrial. Steam-boiler 
control speci.cation problem. In Abrial et al. [3], pages 500 510. [3] J.-R. Abrial, E. B¨orger, and 
H. Langmaack, editors. Formal Methods for Industrial Applications: Specifying and Programming the Steam 
Boiler Control, volume 1165 of Lecture Notes in Computer Science (LNCS), 1996. [4] R. Alur, C. Courcoubetis, 
and D. L. Dill. Model checking for real-time systems. In Proceedings of the IEEE Symposium on Logic in 
Computer Science, pages 414 425, 1990. [5] R. Alur and D. L. Dill. A theory of timed automata. Theoretical 
Computer Science (TCS), 126:183 235, 1994. [6] G. Berry and G. Gonthier. The Esterel programming language: 
Design, semantics and implementation. Science of Computer Programming, 19(2):87 152, 1992. [7] J. Blanc 
and R. Echahed. Synchronous functional logic programming. Technical report, Laboratoire Leibniz, 2001. 
available at http://www-leibniz.imag.fr/PMP/TIME/Timed-programs.ps. [8] J. Blanc and R. Echahed. Timed 
term rewrite systems. Electronic Notes in Theoretical Computer Science (ENTCS), 64, 2002. URL: http://www.elsevier.nl/locate/entcs/volume64.html. 
[9] T. Cattel and G. Duval. The steam boiler problem in Lustre. In Abrial et al. [3]. [10] C. Dumas-Canovas 
and P. Caspi. A PVS proof obligation generator for Lustre programs. In Proceedings of the 7th International 
Conference on Logic for Programming and Automated Reasoning (LPAR), volume 1955 of Lecture Notes in Arti.cial 
Intelligence (LNAI), 2000. [11] D. Gabbay. Modal and Temporal Logic Programming, chapter 6, pages 197 
237. Academic Press, 1987. [12] P. L. Guernic, T. Gautier, M. L. Borgne, and C. L. Maire. Programming 
real time applications with Signal. Research Report 1446, INRIA-Rennes, june 1991. [13] N. Halbwachs. 
A tutorial of Lustre. Technical report, Verimag, sept 1993. [14] N. Halbwachs. Synchronous programming 
of reactive systems. In Proceedings of the Computer Aided Veri.cation (CAV 98), volume 1427 of Lecture 
Notes in Arti.cial Intelligence (LNAI), pages 1 16, 1998. [15] P. Kosiuczenko and M. Wirsing. Timed rewriting 
logic with an application to object-based speci.cation. Science of Computer Programming, 28:225 246, 
1997. [16] C. Liu and M. A. Orgun. Dealing with multiple granularity of time in temporal logic programming. 
Journal of Symbolic Computation, 22(5 and 6):699 720, 1996. [17] J. W. Lloyd. Foundations of Logic Programming. 
Symbolic Computation Arti.cial Intelligence series. Springer-Verlag, 1987. [18] M. A. Orgun and W. Ma. 
An overview of temporal and modal logic programming. In D. M. Gabbay and H. J. Ohlbach, editors, Proceedings 
of the First International Conference on Temporal Logic,volume 827 of Lecture Notes in Arti.cial Intelligence 
(LNAI), pages 445 479, July 1994. [19] C. Palamidessi and F. Valencia. A temporal concurrent constraint 
programming calculus. In Proceedings of the 7th International Conference on Principles and Practice of 
Constraint Programming (CP 01), volume 2239 of Lecture Notes in Computer Science (LNCS), pages 302 316, 
2001. [20] L. C. Paulson. ML for the Working Programmer. Cambridge University Press, 1991. [21] E. Rutten 
and P. L. Guernic. Sequencing data .ow tasks in Signal. In Proceedings of the ACM SIGPLAN Workshop on 
Language, Compiler and Tool Support for Real-Time Systems, Orlando, Florida, 1994. [22] V. Saraswat, 
R. Jagadeesan, and V. Gupta. Constraint Programming, volume 131 of the NATO Advanced Science Institute 
Series, Series F: Computer and System Sciences, chapter Programming in Timed Concurrent Constraint Languages. 
Springer Verlag, 1994. [23] K. Zhang and M. A. Orgun. Parallel execution of temporal logic programs using 
data.ow computation. In Proceedings of the International Conference on Computing and Information, pages 
812 830, 1994.  </RefA>
			

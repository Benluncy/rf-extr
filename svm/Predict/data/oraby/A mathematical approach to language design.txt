
 Permission to make digital or hard copies of part or all of this work or personal or classroom use is 
granted without fee provided that copies are not made or distributed for profit or commercial advantage 
and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, 
to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; 
1975 ACM 0-12345-678-9 $5.00 A i]ATt{EMATI CAL APPROACH To LANGUAGE ~ESIGrl : George T. Ligler Programming 
Research Group Oxford [University Abstract: A framework for validating surface properties of programming 
language constructs , composed of proof rules (akin to those of lIoare) and supporting hypoth­eses, is 
constructed using the mathemati­cal semantics of Scott and Strachey. The following approach to language 
design is then considered: the constructs of a language should have surface properties which l)need few 
hypotheses other than assumed surface properties; and 2)have proofs consisting, as far as possible, of 
trivial fixpoint and structural induc­tions. o. INTRODUCTION The mathematical semantics Of Scott and 
Strachey [7,10,14,16,17,20,21] is capable of defining realistic programming languages fully in a concise, 
flexible, and mathematically rigorous fashion. It is therefore no surprise that properties of programming 
language constructs ex­pressed in notations similar to that of Hoare [1] can be validated as theorems 
with respect to a language description written in mathematical semantics. Such verification further ensures 
a consist­ency of those properties which might be difficult to obtain were a more intuitive approach 
taken towards their formulation. This research was supported by the Rhodes Scholarship Trust, Oxford, 
England. Section 1 of this paper presents a frame­work for the validation of surface proper­ties, which 
essentially consist of proof rules and hypotheses, in mathematical semantics . In Section 2, the techniques 
of Sec­tion 1 are used to form the mathematical underpinnings of an experiment in language design. In 
the belief that correct and well-formulated surface properties provide a subject of interest to both 
semantic theorists and the rest of the computing community, we consider the consequences of having a 
h ai!idation Criterion as an impor­tant goal of our design efforts. Loosely speaking, we require the 
constructs of a language to possess surface properties with few qualifying hypotheses (that are not then.selves 
surface properties) and easy, if not short, formal proofs. Satis­faction of the Ilalidation Criterion 
will be seen to imply greater semantic clarity in a language: that is, not only will both the semantic 
description and surface properties of each construct be less com­plicated, but a construct will also 
have fewer surface properties whose respective sets of qualifying hypotheses are mutually exclusive. 
We shall discuss general prin­ ciples of design emanating from our ap­ proach as well as the effect of 
our cri­ terion on the design of a number of parti­ cular constructs. 1. A FRAMEWORK FOR SURFACE PROPERTY 
FORMULATION AND VALIDATION After defining the notion of surface property, we discuss proof-oriented 
se­mantic descriptions , which aid our vali­dation efforts. We then introduce 3, a function which evaluates 
predicates on program variables in terms of semantic functions from the proof-oriented descrip­tion of 
the programming language under consideration. Finally, we give an exam­ple of surface property formulation 
using mathematical semantics. 1.1. SURFACE PROPERTIES lie begin with an arbitrary program­ming language 
P. A surface property of a construct r of P consists of a triple ( (P,Q), ~, (7z,, . . . . hn)) , where 
(1) (P,Q) is an ordered pair of elements of some syntactic predicate domain[15] Pred, members of which 
correspond to productions of a BNF-like grammar such as Pred ::= Expr 1= Exprzl Predl APred~l PredlvPred*l 
-Pred. Here Expr is the syntactic category of expressions in P. The formulation of Pred depends on the 
nature of P, as will that of many other syntactic and semantic domains; we shall refer to such domains 
as P-domains. (2) (h,, . . . . hn) is an n-tuple of lzypotk­eses. llypotheses fall into three cat­egories 
: (a) Assertions about the syntax and execution of r. (b) Statements about the interdepend­ence of program-variable 
values. (c) Other surface properties.  Satisfaction of the Validation Criter­ion of Section 2 will 
imply that sur­face properties contain few hypotheses of types (a) and (b), which will be called qualifiers. 
. The intention of the above definition can be made clear by using the notation of Hoare [1]: if hi through 
hn hold$ then P{r}Q. Syntactic substitution of Exprl for Exprz in Pred, Pred[Ezprl/Expr~], can be rigorously 
defined. In practice, Expr, is either an identifier, a (possibly com­posite) selection on an identifier 
of structured type, or an array or vector application; we call such expressions assignab2es. We define 
two assignable to be related if l)they are identical; 2)one is a selection on an assignable re­lated 
to.the other; or 3)one is an array or vector application of an array or vec­tor related to the other. 
We shall use this last notion in 1.4., 2.1,3., and 2.2.7. We require an explicit predicate syntax in 
order to be afile to carry out structural inductions on Pred when neces­s ary. Our restriction of possible 
predi­cates on program-variable values to such a syntax does not entail a loss of gener­ality, however, 
since any useful predicate of this type can be constructed from a fairly small set of generators. Predi­cates 
involving scope and instances of structured types will be discussed in 2.2.6. and 2.2.7., respectively. 
1.2. PROOF-ORIENTED SEMANTIC DESCRIPTIOTJS The flexibility of the definition techniques of Scott and 
Strachey implies that our surface property validations might be based on any one of a number of equivalent 
(in a sense to be discussed below) semantic descriptions of P; we restrict ourselves to proof-oriented 
semantic descriptions. A proof-oriented semantic description of P, E(P), has the following characteristics: 
(1) Abstraction denotations are text­environment pairs simj.lar to the cZosures of Lanolin [4]. (2) 
The denotations of label identifiers and special jump identifie~s (see 2.2.6.) are eontinuat<on-enuironmezt 
pairs [7], where the second component contains, if necessary, information about how the a~~ea [16] of 
the ab­stract store is influenced by the jump involved. (3) The program-ansuer P-domain A includes P-domains 
like those of abstract stores (S), environments (Env), and expressed vaZu.. (E) as summands (see [20]). 
The functionalities of eo?z­tinuatiorz domains [10,20] associated with various semantic functions are 
defined accordingly. (4) Each semantic domain B contains an error element,  B Condition (1) acts as 
an aid to proofs of the surface properties of abstraction calls by easing formulation of context conditions 
(e.g. , testing whether an identifier is a free variable of an ab­straction) ; it also makes possible 
direct proofs (by fizpoint [6,8] and structural inductio~s) both of necessary continua­tion-removal theorems 
and of propositions involving wide classes of constructs of P. By a continuation-removaZ theorem (see 
[7,12]), we mean a result justifying the decomposition of an expression written in continuation semantics 
[21] into a form allowing specification of intermedi­ate ansuers, that form usually containing functional 
composition of some sort. For example, if QEC=[S+S] is a con­tinuation and Y has functionality C+c, then 
we might wish to consider the condi­tions under which Y{(3}CJ = @.Y{au, .ol}u, where o and CT, are elements 
of S. Condition (2) helps discussions of the surface properties of jumps, while (3) implies that elements 
of domains which are important to our validation efforts may be used as intermediate an­swers . Finally, 
(4) permits greater latitude in the specification of error con­ditions. The results of Reynolds [12] 
and Milne [7] provide means for discussing the equivalence of different mathematical se­mantic descriptions 
of a language in the following sense: if correspondences be­tween the elements of respective semantic 
domains are defined (the existence of a general class of such correspondences is proven in the above 
references), then two descriptions are regarded as equivalent if, whenever they are used for correspond­ing 
evaluations, they give corresponding answers , Consequently, we can show that our insistence on having 
proof-oriented semantic descriptions does not imply a loss of generality. We stress that E(P) is meant 
to be used for the disc-ussion of implementation­independent properties of P. Our stores and environments 
are abstract, and the primitive operations on these semantic entities indicate the features common to 
implementations. Therefore, when an ele­ment of L, the domain of abstract loca­ tions, is mentioned in 
E(P), one is con­sidering a mathematical value which might be reaZized as a bit, word, or group of words 
were P to be implemented. llilne [7] discusses the correctness of implementa­tion techniques by showing 
whether or not they satisfy the conditions put on them by semantic descriptions. 1.3. %, TIIE EVALUATIVE 
FIJNCTION With Pred and 5(P) defined, semantics may be given to elements of the former using 1: Pred 
+ [Env + S + T], where + signifies that the function space being specified need not consist purely-of 
continuous functions. As mentioned in 1.2., Env and S are the P-domains of environments and stores, respectively; 
their defining equations are given in E(P) (sampie defining equations and an indication of their variety 
may be found in Strachey [20]). T is a semantic domain of truth values. ~ is defined in terrrrs of the 
semantic functions of E(P) and equal­ity relations between elements of seman­tic domains. The surface 
properties defined in  1.1. can now be formulated as follows: if hl through kn hold, then (1) 3[P]P0 
= true implies ~[Q]PiIsi = true. In (l), p, and CJ, depend on r, p, and a and are calculated using the 
equations of E(P). For example, in Algol 60, p, = p for all r except declarations and jumps; for a declaration 
of an identifier Ide, p, would equal p[6/lde], where 6 is an element of D, the Algol-domain of denoked 
va2ues (see [20]); and for a jump goto L, Pi would be the environment component of the denotation of 
L in p. The flexibility of mathematical se­mantics implies that 3 could well be defined with other functionalities. 
~lJe have simply picked a definition which in­corporates the minimum which must be ex­pected of this 
evaluative function: existence and dependence on Pred, Env, and S. 1.4. AN EXAMPLE-SIMPLE ASSIGNMENT 
IN ALGOL 60 }ie now consider the formulation of a surface property for an Algol 60 assign­ment statement, 
x := e, where z is not a function identified-. The most fruitful way to proceed is to picli tile predicates 
P and Q of 1.1. and then find those ki which make the va lid.ation of ( (P,Q), x := e, (k,, . . ..hn)) 
po~sible. In general, such searches for suitable hypotheses often suggest more sensible P-Q pairs for 
the construct under consideration. Accordingly, we let P be S [e/x] (see 1.1.) and Q be S, where S is 
any member of an appropriate Pred syntax for Algol 60; this choice gives us a surface property analogous 
to the assignment proof rule of lIoare [1]. Ne wish. to show for all p and o, 3[S[e/x]]pO = true implies 
 (2) 3[S]P01 = t~ue, where 01 = C[x := elp{A02. cJ2}0. In (2), c is the semantic function of E(Algol 
60) giving meaning to Algol commands , with functionality Cmd + Env +C -+S+ A, where C = S + A is the 
A.lgol-domain of command continuations. E(Algol 60) may be derived straightforwardly from the semantic 
description of the language given in [10]. Iiypotheses sufficient to ensure the validity of (2) are enumerated 
below> with each ki being followed by its formulation in mathematical semantics. kl : the evaluation 
of x := e terminates without error C[x := e]p{i02.02}o is not LA (see [15]) or ?A. kj : the evaluation 
of e has no side effects WeloT{AR. lo2.02}o = o, where ti is the semantic function of E(Algol 60) giving 
meaning to Algol 60 expressions which can appear on the right-hand side of an assignment statement; ~ 
is an appropriate type argument. h, : x does not skare with any other assignable (1.1.) A in S; that 
is, the abstract location which x denotes is not the L-va2ue [18,19] of A or any assignable related to 
A Notskare[x][S]pO = t~ue. liotskare , like Safe and Donnam. (below), may be defined in much the same 
fashion as 2 . We emphasize that lieare defining sharing as a property of Algol 60, not of an implementation 
of Algol 60. h : x neither shares with or is a free variable of an abstraction applied in S Safe[x][S]po 
= true. 72, : the change in the value of x does not change that of a call-by-name param­eter which does 
not share with x but is evaluated in S 7ionname[cc][S]pu = true. Ifh,, lz4, or h~ fails to hold, we say 
that x occurs implicitly in S. Such problems of implicit occurrence demon­strate the inadequacy of syntactic 
sub­stitution in program-variable predicates (1.1.). TO illustrate h , we give a situation in which our 
other hypotheses are assumed to hold and (2) is not valid: (a) S is y = funny(2) (b) e is 3 (c) funny 
is an abstraction which takes an integer parameter n and has the fol­lowing body: begin funny := x+n 
end (d) the R-va2ue [18,19] of z is not 3 with respect to p and a. As for h,, let (a), (b), and (d) hold 
as above and let y be an identifier which is a formal name parameter of an abstraction g in whose body 
t!le assignment statement under consideration is assumed to occur. Finally, assume that the con­text 
in which x := 3 is being evaluated is a call of g with an actual parameter if x=3 then doubZe(2) else 
1 corresponding to y. Given hl through hs and the basic continuation-removal theorems (1.2.) for E(Algol 
60), the proof of (2) follows principally from structural inductions on Pred and the syntactic category 
of Algol expressions. Although a completely formal proof is extensive, it is both easy and of a length 
proportional to the size of the syntactic categories involved. 2. LANGUAGE DESIGN We now consider the 
design of pro­gramming languages with satisfaction of the following Validation Criterion as our goal 
: the constructs of a language should have surface properties which have both few qua2ifiers(l. 1.) and 
proofs in mathematical semantics which mainly consist of straightforward fixpoint and structural inductions. 
The author has designed a series of block­structured, procedure-oriented program­ing languages on this 
basis> and in the rest of the paper, the most important features of these languages will be dis­cussed. 
Although few of these features are new, our reason for including them may cause them to be seen in a 
fresh light. Examples will be drawn from ProofLS, one of the languages in the aforementioned series; 
our treatment will be informal, because the principles of language design involved, not any par­ticular 
language, are the center of our attention. An important consequence of our de­sign approach has been 
the formulation and fortification of the belief that pro­gramming languages should be designed in a global 
manner, rather than construct hy construct, because the surface proper­ties of constructs are intricately 
inter­dependent. For example, the assignment statement discussed in 1.4. has surface properties which 
depend on the design of the following language features: (a) expressions presence of side effects (b) 
sharing (c) abstractions treatment of free vari­ables and choice of parameter trans­mission mechanisms. 
  We have found few constructs which satisfy the Validation Criterion in isolation; conversely, many 
constructs not mentioned in this paper might be integrated into some programming language without viola­ 
ting our standard. At best, only one qualifier, that assuming termination and error-freedom, will need 
to be used in the formulation of surface properties. The use of this hy­pothesis.has one large notational 
benefit: since error-freedom is assumed, we can ignore type-checking when proving surface properties. 
Thus some of the most intri­ cate parts of our semantic descriptions (like that in [10]) may be discarded. 
Another aspect of our approach to language design is that the constructs of a language which satisfies 
our criterion will have surface properties with proofs whose lengths are proportional to the num­ ber 
of clauses in the syntax of that lan­ guage. It is doubtful that a better rela­ tionship can be achieved. 
Remarks about syntax and semantics, puns and name clashes, and sharing will be found in 2.1. A second 
subsection dis­cusses the design of specific language constructs. Although the constructs in­cluded (1) 
are by no means claimed to form a complete (or optimal) set; and  (2) can in several cases be designed 
in a number of adequate ways, one of which is chosen for ProofLS,  it is hoped that their description 
will illustrate the major consequences of our mathematical approach to language design. 2.10 GEl?ERAL 
REMARI(S 2.1.1. Syntax and Semantics A fundamental principle which has emerged from our approach is that 
language features with different surface properties should have distinct syntaxes. The alter­natives 
to adopting this policy are (1) to formulate several sets of surface properties for the same syntactic 
con­struct, each having qualifiers which describe the semantic case under con­sideration; or (2) to 
use surface properties made more general (when possible) by the inser­tion of both additional surface­property 
hypotheses and P-Q predicate pairs with complex internal struc­ture however, this generalization makes 
validations more difficult and surface properties less clear.  The syntactic differentiation advocated 
above also facilitates confining the con­texts in which various language features can occur; for example, 
expressions with side effects can be syntactically re­stricted to a small subset of the con­structs of 
a language. The effect of such limitations of context is to make our validation task easier without forcing 
us to reject language features which, if used carefully, are compatible with the Validation Criterion. 
In our view, syntax should play an active role in helping to provide semantic clarity for a programming 
language. The process of language design thus becomes more continuous and cannot be fragmented into l!syntax!l 
and semantics stages. Indeed, we agree with the opinion of Strachey [20] that the consideration of 
semantic domains should be among the first steps in the design of a language.  2.1.2. Puns and l{ame 
Clashes A second point derived from this mathematical attempt at language design is that puns should 
be eliminated. For example, the function result mechanisms in Algol 60, Pascal, and, Fortran involve 
assigning to an identifier which in other contexts is of an unassig,nable type; be­cause this does not 
happen with any other types of assignment (apart from name clashes), the use of such~ devices runs counter 
to the spirit of 2.1.1. The rejection of this result pun accordingly simplifies the semantic description 
of both assignment and result-producing ab­stractions, thereby easing our validation task for those constructs 
(~ie discuss a replacement result mec!lanism in 2.2.6.). If this pun is not eliminated, the only alternative 
to accepting more complicated validation proofs is to include extra qualifiers: the example of 1.4., 
strictly speaking, should have had our assumption about x not being a function identifier as a sixth 
hypothesis. Along much the same lines, the only name clashes allowed are dynamic. These arise from two 
sources: (1) local variables and formal parameters of recursive abstractions; and (2) free va~iables 
of fixed abstractions  (see 2.2.5.3.). We can assume the existence of a pre­processing operation that 
removes textual name clashes from a programming language without this specification we then at­tempt 
surface property validations with respect to the preprocessed language.  2.1.3. Sharing Indiscriminate 
sharing greatly com­plicates any attempt to prove the surface properties of a construct, since changes 
to the value of an assignabZa (1.1,) might well alter the values of unrelated assignable that occur$ 
explicitly or implicitly, in the predicates under con­sideration. For this reason (others may be found 
in Iioare [3]), the type pointer is prohibited in our languages; this exclusion, however, is not in itself 
enough to remove sharing qualifiers simi­lar to h, of 1.4. from surface properties. In the absence of 
pointer variables, languages with capabilities similar to those of ProofLS, which does not have facilities 
for parallel processing, can contain three main sources of sharing between unrelated assignable: (1) 
features similar to the EQUIVALENCE statement in Fortran; (2) assignment involving instances of structured 
types; and (3) parameter transmission.  The first two of these sources must be eliminated if the Validation 
Criterion is to be met; ProofLS has no equivalence statements and uses copy rules . The third cause, 
however, need only be re­stricted. Sharing can result from parameter transmission because (a) corresponding 
actual and formal para­meters might share with respect to the environment used in the evaluation of the 
body of the abstraction being applied; or (b) distinct formal parameters might share because their corresponding 
actual parameters share.  If the dictates of 2.2.S.2 are followed and if ~i~ we rules like the s\lbstitu­tion 
proof rule of 2 .2.5.1. , sharing of type (a) necessitates neither extra quali­fiers nor complex syntactic 
operations on predicates. We limit sharing of type (b) to that between formal parameters passed by mechanisms 
which do not allow those parameters to have their values altered; in ProofLS, ealZ-by-expressed-vaZue 
(see 2. 2.5.1.) is such a parameter mechanism. Perhaps the occurrence of other type (b) sharing indicates 
that an abstraction has has been either misused or improperly de­signed, since surface properties of 
its body cannot be extended to those of its call without the inclusion of sharing qualifiers. ProofLShare 
, a variant of ProofLS, has the ProofLS restrictions on sharing with one exception: unrelated assignabies 
of structured type are allowed to share as a result of assignment operatioris invol­ ving instances of 
structured types. If we limit the contexts in which such as­signments can occur (2.2.1.,2.2.7.), sharing 
qualifiers need not be included in the surface properties of most constructs; this is another benefit 
of following the dictates of 2.1.1. Although it meets the Validation Criterion less fully than ProofLS, 
ProofLShare is useful as a tool for the analysis of the surface proper­ties of structu~,e-abstractio??s 
(2.2. 7.) in sharing situations. 2.2. THE DESIG:J OF SEVERAL LAIJGIJAGE CONSTRUCTS 2,2.1. Expressions 
ProofLS has two syntactic categories, Fullexp and Exp, for expressions with and without side effects, 
respectively. It can be shown that Exp satisfies this spec­ification: that is, if the evaluation of an 
element of Ezp terminates without error, an equation similar to that for hypothesis h, of 1.4. is valid. 
The proof of this proposition follows from the con­tinuation-removal theorems of ProofLS (1.2.) and a 
structural induction on Ezp, in which the abstraction application case is proven using both fixpoint 
and struc­tural inductions. The formal proof, al­though lengthy for a syntactic category as large as 
EXp, is straightforward. Given this result, much of our validation task may be done implicitly by requiring 
Exp in our syntax. Additionally, we use only Exp in Fred syntax (1.1.); the in­fluence of this decision 
on the free­variable qualifier k~ of 1.4. will be discussed in 2.2.5.3. The FulLexp-Exp distinction implies 
that expressions with possible side effects can be used without hindering our validation efforts provided 
(1) the contexts in which such expressions can occur are limited, so that the surface properties of most 
constructs will need neither qualifiers similar to h, Cf 1.4. nor formulations which, like t tlat of 
Fullexp assignment (2.2.2.), account for side effects. (2) the surface properties of members of Fullezp 
are carefully validated. Side effects can arise in the evaluation of an element fe of Ful~exp only if 
fe contains the call of an abstraction of type function(2.2.5.); this specification eases the fulfillment 
of the second con­ dition above,  2.2.2. Assignment In ProofLS, assignment statements con­taining the 
symbol := are limited to the form Ide := Exp , where Ide is an identifier of basic type (integer, real, 
or boolean). A surface property of this construct is (i) ((P[Exp/Ide],P), ~, ht(~)), where ~ is Ide := 
Exp and ht(A) expresses that the evaluation of A is assumed to terminate without error. The proof of 
(i) follows from (1) the continuation-removal theorems (1.2.) of ProofLS; (2) the result concerning 
Exp in 2.2.1;  (3) a short lemma about the effect of simple assignment on the abstract store; and (4) 
a trivial structural induction on pred.  For the justification of the elimination of qualifiers h~ 
to k, of 1.4., see 2.1.37 2.2.5.3. ,an d 2.2.5.1. The symbol + is used to signal the presence of a production 
of Fullexp syntax on the right-hand side of an assignment statement , with the left-hand side as above, 
e.g., Ide * Fullexp. If a surface property of Fullexp is S = ( (P,Q[Exp~/Ide]),FuZLexp~ (l re,h.l, . 
. ..hfl)l. then one can validate where T1 is Ide * Fullezp and Here R and W are the semantic functions 
of S(ProofLS) which give semantics to ex­pressions of assignable type in Exp and Fullexp, respectively. 
Finally, the polymorphic abstraction Change is used to perform assignments in­volving assignable of structured 
type. The contexts in which Change can be ap­plied are specified in 2.2.7.  2.2.3. Composition A surface 
property for composition in ProofLS is (see [2]) (iii) ( (P,R), rl;r,,~sl,sz,hj~rl~~j , where s, = ( 
(P,Q), r,, ht(r,)) and S2 = ( (Q,R), rz, ;Lt(rz)) , and 71i(A) asserts that A does not con­tain a jump 
to a point external to it­self. This qualifier may be matherirati­cally expressed using a purely syntactic 
predicate, or environment and abstract store arguments may be added to ensure that a forbidden jump occurring 
in a dy­namically unused arm of a conditional does not affect the result of the jump­free test. The validation 
of (iii) fol­lows immediately from an appropriate con­tinuation-removal theorem (1.2.) and the property 
that r, cannot contain a jump into rl in our language. ProofLS aims to keep sensible jumps while having 
hj(A) hold for as many con­structs A as possible. In an attempt to satisfy this goal> only rep2ies (2.2.6. 
) are allowed in the language, 2.2.4. Conditionals and Iterations If only Ezp syntax is allowed in boolean 
contexts, the surface properties of conditionals and boolean-controlled iterations (like whi le) are 
easily formu­lated and validated relative to the sur­face properties of their component com­ mands . 
These validations usually require fixpoint induction and no structural in­ ductions with hi and (sometimes) 
h. as J qualifiers. The Validation Criterion for for-loops is best satisfied if the syntax of for-lists 
is kept uncomplicated and if the maximum number of iterations is deter­ mined before the first evaluation 
of the for-statement.  2.2.5. Abstractions and Parameters The design of abstractions has a per­vasive 
effect on our validation efforts. In line with 2.1.1., ProofLS has three abstraction types: (1) fixed 
functions: result-producing abstractions with fixed free variables (2.2.S. 3.). These are the only ab­stractions 
whose applications can occur in Exp or Pred syntax; thus their calls have no side effects. (2) functions: 
result-producing abstrac­tions whose applications occur in Fullezp syntax. (3) routines: abstractions 
whose calls produce side effects without returning vaiues of result type; the appli­cations of routines 
are in Command syntax.  We first discuss parameter mechanisms and continue with considerations of global 
effects of abstraction calls and treatment of free variables. 2.2.5.1, Parameter Mechanisms The example 
of 1.4. demonstrates how the use of call-by-name as a parameter mechanism can necessitate additional 
qual­ifiers in the surface properties of lan­guage constructs. ProofLS employs two types of parameter 
transmission, call-by­reference and ca22-by-expressecZ-va Lue. Formal expressed-value parameters may 
not legally occur in a context which might .,, cause their values to be altered; this method of passing 
parameters is similar to a device proposed by Tennent [22] (but here we do not allow actual reference 
and exprassed-tia2ua parameters to share) . AS should be expected, abstractions of type fixed function 
may only take parameters by expressed value. The use of these para­meter mechanisms, combined with our 
re­strictions on sharing between actual para­meters, implies that parameter passing need not affect the 
abstract store and thus can have a purely environmental ef­fect. This in turn allows, for example, the 
validation of a surface property anal­ogous to the proof rule P{~}R (iv) > P ~u1,{Proe(ELq21, . . . 
..Expn)}R$ub where all free assignable of P and R must occur in I or be abstraction identifiers, P 
PIEzpl/Idel ].., [Expn/Iderl], sub R R[Ezp,/Ide,]... [EXpP1/Ide)l], sub and PY~oe is an identifier 
of type routine or function with formal parameters ldel through. Iden and body I , by a proof similar 
in size and nature to the proof of the i-calculus substitution lemma given in Wadsworth [23]. (iv) is 
similar to the substitution rule of Hoare [2]; its validity depends also on the prohibitions of 2.2.5.2. 
and 2.2.5.3. 2.2.5.2. Global Ef feets of Abstraction Calls The free variables of an abstraction f (and 
any abstraction applied within f) are like expressed-value parameters, in that their values may not be 
altered le­gally by any call of f. This convention (1) eases the specification of those pro­gram variables 
whose values can be altered by an abstraction call; and (2) makes sharing.between a free vari­able of 
an abstraction and an actual reference parameter of an enclosing  abstraction call either illegal or 
inconsequential. 2.2.5,3. Treatment of Free Variables The prohibition of 2.2.5,2. on the use of free 
variables does not solve the problem which manifests itself in the form of qualifiers like h. of 1.4. 
lie remove the need for such qualifiers, while retaining free variables, by using only fixed abstractions, 
as defined by Strachey [19], in Pred syntax: a fixed abstraction (1) takes its free variables of assignable 
type by R-value when it is declared; and (2) has abstractions as free variables only if they are fixed. 
 We do not require abstractions of types function and routine to be fixed, because the use of fixed 
free variables causes dynamic name clashes which complicate the validations of surface properties like 
that corresponding to (iv) of 2.2.5.1. Calls of abstractions of type fixed function, however, have no 
side effects; therefore the surface properties of such abstractions are trivial and our fixing causes 
no practical validation diffi­culties.   2.2.6. Jump S Although full jumps and labels may be described 
and characterized in mathemati­cal semantics [21], we use no labels and restrict jumps to Pep Lies: jumps 
which in effect complete the evaluations of specific constructs. Examples of replies and their associated 
constructs are (see [13]): return call of an abstraction of type routine resultis Exp call of an abstraction 
of type fixed function or function endcase switch break while-or for-loop. return, resultis, and the 
lil:e become special jump identifiers and have denota­tions in the environment p. The use of only replies, 
combined with rules which regulate the scopes (below) of special jump identifiers, implies that (1) the 
jump-free test of 2,2.3. is satis­fied by most associated constructs;and (2) in rl;rz , neither I 1 nor 
rz can con­tain a jump into the other. The specification of the surface properties of replies (and general 
jumps, for that matter) is aided by the use of the concept of scope. By the scope of an identifier, we 
mean that area of a program text in which the identifier can legally occur; this definition of scope, 
which is a purely textual property> is valid be­cause of our prohibition of lexicographic name clashes 
(2.1,2.). Mathematically, Ide is in scope if its denotation in the environment under consideration is 
not an error element. A surface property of, say, break is (v) ((P,Irzseope(P)), break,kt(break)), where 
Inseope(P) consists of those parts of P which can be evaluated without error with respect to the environmental 
compo­nent of the denotation of break (1.2.). The qualifier in (v) is needed solely to hypothesize error-freedom. 
The proof of (v) is immediate (vir­tually a one-liner ) if the area of the abstract store is not affected 
by jumps. If this is not the case, ~ie need to show (by structural induction) that if an identifier is 
in scope, its P.-value can always be taken without accessing any abstract locations which are not in 
the area of the store under consideration. The proofs of the surface properties of abstraction bodies 
are aided if we validate a wide range of surface proper­ties of return and WSUlt iS EXp. Though most 
of these properties are variants of (v), care must be taken over dynamic name clashes, which do not affect 
the validations of surface properties of break. 2.2.7. Structured Types Structured types nay be introduced 
into a language without violating the Validation Criterion if the contexts in which instances of such 
types might have their values altered can be limited syn­tactically. There are a number of treat­ments 
of structured types which satisfy this condition (for an example, see l!orris [9]); ProofT,S simply uses 
one such method that allows the declaration of recursive union types like Tree and List. The polymorphic 
abstraction Change (2.2.1.) serves as an assignment operator for structured types and can only be applied 
within the bodies of structure-abstrac­tions, abstractions which can have ref­erence parameters of structured 
type. P~~~d syntax can be expanded to in­clude elements like Depth(Side) = Ezp, which acts on an object 
of structured type and thereby aids the formulation and validation of surface properties of structure-abstractions 
as well as the characterization of the shape of a struc­tured type. F1ere Side is an assignable related 
to an identifier of structured type ; Depth determines the maximum length of the composite selectors 
which may be legally applied to Side if a graphical representation of the value of Side con­tains a loop, 
Depth(Side) is a suitable constant Cycle. The shape of a stiwc­tured type is defined to be whatever propositions 
involving Depth and similar measure-predicates are to be taken as invariant over all instances of that 
structured type. For example, one part of the shape of the structured type Einaryintegertree would be 
 R3[Depth(Side) + Cyetc]PU = true for all Side of type Binaryintegertree with respect to p. 3. CONCLUDING 
RENARKS The interplay between the subsec­tions of Section 2 calls attention both to the interdependence 
of language fea­tures and to the complications which can emerge from the attempt to discuss the surface 
properties of a large programming language. While we consider the first of these inherent to programming 
languages, our efforts to design languages which meet the Validation Criterion are made in the hope of 
reducing the latter. Pragmati­cally, qualifiers indicate the presence of semantic catches that a programmer 
must take into consideration when he assesses the impact of a construct in his program in the absence 
of qualifiers satisfaction of the Validation Criterion often implies simpler, and therefore more useful, 
sur­face properties. The mathematical approach to language design presented in this paper ~iill be more 
fully discussed in the authorfs doctoral dissertation [5], which will also include an introduction of 
the approach to system programming languages. Future experiments in language design should be aided by 
the compiler-compiler of Mosses [11], which is to allow both semantic descriptions to be debugged and 
imple­mentations to be given to theoretical lan­guages. Perhaps a mathematical approach to language design, 
when combined with the ideas of practical programmers , will yield more coherent design principles in 
future than are available at present. Acknowledgements The author gratefully acknowledges Chris­topher 
Strachey, Robert Milne, and Chris­topher Iiadsworth, who have provided many stimulating discussions. 
Additionally, P.D. Mosses, M.D. IIarrison, J.E. Stoy, and P.J.L. Wallis have read the manus­cript and 
have made several suggestions for improvement. REFERENCES <RefA>[1] C.A,R. Hoare, An Axiomatic Basis for Computer 
Programming, Comm.ACM,12:10, (1969), 576-580. .[2] C.A.R. Hoare, Procedures and Para­ meters : An Axiomatic 
Ap roach, Sym­posiufi on Semantics of A? gorithmic Languages, S. -Verla.g, (l97l),lO2-ll7. [3] C.A.R. 
I1oare, Hints on Programming Language Design, Stanford A.I. Labora­tory, AIM-224$ (1973). [4] P.Landin, 
The Meehanieal Evaluation of Expressions, Computer Journal 6, (1 264), 308-320. [5] G.T. Ligler, D.PhiI.Thesis, 
Oxford University, (1975), in preparation. [6] Z.Manna and J.Vuillemin, I ixpoint Approach to the Theory 
of Computation, Comm.ACPl ,15:7,(1972), 528-536. [7] R.E. Milne, The formal semantics of computer languages 
and their imple­mentations , Ph.D,Thesis, Cambridge IJniversity, and Technical Monograph PRG-13, Oxford 
University Computing Laboratory, Programming Research Group, (1974). [8] R.Milner, Implementation and 
Applica­tions of Scottts Logic for Computable Functions, SIGPLA~{ Notices 7:1 (= SIGACT News 14), (1972), 
1-6. [9] J,H.Morris, Types are not Sets,Proc. ACM Symposium on Principles of Pro­gramming Languages, 
Boston, (1973), 120-124. [10] P.D. Mosses, The mathematical seman­tics of AlgoZ. 60, Technical Monograph 
PRG-12, O.U.C.L. , Programming Research Group, (1974). [11] P.D. Mosses, Matkematiea2 Semantics and Compi2er-Generation, 
D.Phil. Thesis, Oxford University, (1974). [12] J.C. Reynolds, On the Relation Between Direct and Continuation 
Semantics, Proc. Second Colloquium on Automata, Languages, and Programming, Saar­briicken, (1974). [13] 
M. Richards, The BCPL Reference Man­ual, Technical Memorandum 69/1, Cambridge U. Mathematical Laboratory, 
(1969). [14] D.Scott, Outline of a Mathematical Theory of Computation, Proc. Fourth Annual Princeton 
Conference on Infor­mation Sciences and Systems, pp.169­176, and Technical Monograph PRG-2, O.U.C.L. 
, Programming Research Group, (1970). [15] D.scott, Continuous Lattices, PrOC. 1971 Dalhousie Conference, 
Springer Lecture l~ote Series, and Technical 140nograph PRG-7, O.U.C.L. , Program­ming Research Group, 
(1970). [16] D,Scott, Mathematical Concepts in Programming Language Semantics, AFIPS Conference Proceedings, 
VO1.40, (1972), 225-234. [17] D.Scott and C.Strachey, Touard a Mathematical Semanties for Computer Languages, 
Proc.Symp. on Computers and Automata, Polytechnic Institute of B rooklyn, and Technical Monograph PRG-6,0.U.C. 
L.,Prog.Res .Group, (1971).  [18] C. Strachey, Towards a Formal Seman­ [21] C. Strachey and C. Wadsworth, 
Contin­ tics , Formal Language Description uations A Mathematical. Semantics for Languages for Computer 
Programming, Full Jumps and Labels, Technical (cd. T. Steel), North-Ilolland, (1966), Monograph PRG-11, 
Oxford University 198-220. Computir.g Laboratory, Programming [19] C. Strachey, Fundamental Concepts 
in Research Group, (1974). Programming Languages, Unpublished, [22] R.D. Tennent, A Contribution to the 
(1970). Dev@20pment of Pascal-Like Languages, [20] C. Strachey, Varieties ming Language, Proc. Computing 
Symposium, Foundation, Venice, of Program-International pp.222-233,Cini and Technical Technical ment 
Science, (1974) of . Report Computing Queen s lJo. 74-25, and Information University, Depart-Ontario, 
Monograph PRG-10, Oxford University [23] C,.Wadsworth, The Semantics and Prag- Computing Laboratory, 
Programming Maties of the A-Calculus, D.Phil. Research Group, (1972). Thesis, Oxford University, (1971). </RefA>
 
			


 A Generic Type System for the Pi-Calculus Atsushi Igarashi Naoki Kobayashi Department of Graphics and 
Computer Science Department of Information Science Graduate School of Arts and Sciences Graduate School 
of Science University of Tokyo University of Tokyo email:igarashi@graco.c.u-tokyo.ac.jp email:koba@is.s.u-tokyo.ac.jp 
Abstract We propose a general, powerful framework of type systems for the ~r-caiculus, and show that 
we can obtain as its in- stances a variety of type systems guaranteeing non-trivial properties like deadlock-freedom 
and race-freedom. A key idea is to express types and type environments as abstract processes: We can 
check various properties of a process by checking the corresponding properties of its type environ- ment. 
The framework clarifies the essence of recent complex type systems, and it also enables sharing of a 
large amount of work such as a proof of type preservation, making it easy to develop new type systems. 
1 Introduction 1.1 Motivation Static guarantee of the correctness of concurrent programs is important: 
Because concurrent programs are more complex than sequential programs (due to non-determinism, dead- 
lock, etc.), it is hard for programmers to debug concurrent programs or reason about their behavior. 
A number of advanced type systems have recently been proposed to analyze various properties of concurrent 
pro- grams, such as input/output modes [27], multiplicities (how often each channel is used) [17], race 
conditions [4, 6], dead- lock [14, 18, 30, 38], livelock [16], and information flow [8, 10]. Unfortunately, 
however, there has been no satisfactorily general framework of type systems for concurrent program- ming 
languages: Most type systems have been designed in a rather ad hoc manner for guaranteeing certain specific 
properties. The lack of a general framework kept it difficult to compare, integrate, or extend the existing 
type systems. Also, a lot of tasks (such as proving type soundness) had to be repeated for each type 
system. This situation stands in contrast with that of type systems for functional program- ming languages, 
where a number of useful analyses (such as side-effect analysis, region inference [36], and exception 
analysis [3, 26]) can be obtained as instances of the effect analysis [34, 35]. Permission to make digital 
or hard copies of all or part of this work for personal or classroom use is granted without fee provided 
that copies are not made or distributed for profit or commercial advan-tage and that copies bear this 
notice and the 'lull citation on the first page. To copy otherwise, to republish, to post on servers 
or to redistribute to lists, requires prior specific permission and/or a fee. POPL '01 1/01 London, UK 
&#38;#169; 2001 ACM ISBN 1-58113-336-7/0110001 ...$5.00 The goal of this paper is therefore to establish 
a gen-eral framework of type systems for concurrent processes, so that various advanced type systems 
can be derived as its instances. As in many other type systems, we use the ~r-calculus as a target language: 
It is simple yet expressive enough to model modern concurrent/distributed program- ming languages.  
1.2 Main Ideas A main idea of the present work is to express types and type environments as abstract 
processes. So, a type judg- ment F ~ P, which is normally read as "The process P is well-typed under 
the type environment F," means that the abstract process F is a correct abstraction of the process P, 
in the sense that P satisfies a certain property (like race- freedom and deadlock-freedom) if its abstraction 
F satisfies the corresponding property. (In this sense, our type system may be regarded as a kind of 
abstract interpretation [2].) We define such a relation F ~ P by using typing rules. Because we use a 
much simpler process calculus to express type envi- ronments than the r-calculus, it is easier to check 
properties of F than to check those of P directly. To see how type environments can be expressed as abstract 
processes, let us review the ideas of our pre-vious type systems for deadlock/livelock-freedom [16, 18, 
33]. Let x![yl,...,y,@P be a process that sends the tu-pie [yz,..., y~] along the channel x and then 
behaves like P, and z?[yl,... ,y~]. Q be a process that receives a tuple [zz,..., zn] along x, binds 
yz,..., y,~ to zz,..., z,~, and then behaves like Q. Let us write P[Q for a parallel execution of P and 
Q, and 0 for inaction. In our previous type sys- tems [18, 33], the process P --x![z][x?[y], y![] [ z?[]. 
z?[]. 0 is roughly typed as follows: x: [[]/o]/(Ol/), z: []/(OlZ.O P Types of the form [rl ..... Tn]/U 
are channel types: The part It1,..., rn] means that the channel is used for commu- nicating a tuple of 
values of types 7"1,..., ~'n, and the part U (called a usage) expresses how channels are used for in- 
put/output. For example, the part O[I.I of the type of z means that z is used for output (denoted by 
O) and for two successive inputs (denoted by I.I) in parallel. By focusing on the usage parts, we can 
view the above type environment as a collection of abstract processes, each of which performs a pair 
of co-actions I and O on each channel. Indeed, we can reduce the type environment by canceling I and 
O of the usage of x and obtain x: [[]/O]/O,z: []/(0[I.I), which is a type environment of the process 
z![] I z?[]. z?[]. O, obtained by reducing P. By further reducing the type environment, we obtain x: 
[[]/O]/0, z: []/I, which indicates that an in-put on z may remain after P is fully reduced. Based on 
this idea, we developed type systems for deadlock/livelock- freedom [16, 18, 33]. We push the above 
"type environments as abstract processes" view further, and express type environments as CCS-like processes 
(unlike in CCS [22], however, we have no operator for hiding or creating channels). The type environment 
of the above process P is expressed as X![T]. z![r']{x? M. 0 I z?[~' ]. Z?[T']. 0. It represents not 
only how each channel is used, but also the order of communica- tions on different channels, such as 
the fact that an out-put on z occurs only after an output on x succeeds (as indicated by the part x! 
[r]. z! [~"]). The parts enclosed by square brackets abstract the usage of values transmitted through 
channels. Thanks to this generalization, we can rea- son about not only deadlock-freedom but also other 
prop- erties such as race conditions within a single framework. The new type system can also guarantee 
deadlock-freedom of more processes, such as that of concurrent objects with non-uniform service availability 
[30, 31].   1.3 Contributions Contributions of this paper are summarized as follows: We develop a 
general framework of type systems, which we call a generic type system -- just as a generic func- tion 
is parametrized by types and can be instantiated to functions on various arguments by changing the types, 
the generic type system is parameterized by a subtyp- ing relation and a consistency condition of types 
and it can be instantiated to a variety of type systems by changing the subtyping relation and the consistency 
condition.  We prove that the general type system satisfies several important properties (such as subject 
reduction), inde- pendently of a choice of the subtyping relation and the consistency condition. Therefore, 
there is no need to prove them for each type system.  We show that a variety of non-trivial type systems 
(such as those ensuring deadlock-freedom and race-freedom) can indeed be derived as instances of the 
gen- eral type system, and prove their correctness.  1.4 The Rest of This Paper Section 2 introduces 
the syntax and the operational se-mantics of our target process calculus. Section 3 presents our generic 
type system and shows its properties. As its instances, Section 4 derives a variety of type systems and 
proves their correctness. To further demonstrate the strength of our framework, Section 5 shows that 
deadlock and race conditions of concurrent objects can also be ana- lyzed within our generic type system. 
Section 6 describes preliminary results of our ongoing studies on the power of our generic type system. 
Section 7 discusses limitations and extensions of our generic type system. Section 8 discusses related 
work and Section 9 concludes this paper. For the space restriction, we omit some technical details in 
this ex- tended abstract. They are found in the full paper [11]. 1 2 Target Language 2.1 Syntax Our calculus 
is basically a subset of the polyadic 7r-calculus [23]. To state properties of a process, we annotate 
each input or output operation with a label. Definition 2.1.1 [processes]: The set of processes is de- 
fined by the following syntax. P (processes) ::= OlOl+."+a= I(PIQ) I (vxl .... , z.) P { ,P G (guarded 
processes)  ::= xrt[yl, ...,y~]. el x?t[yl,.. ,y,]. f Here, x, y, and z range over a countably infinite 
set Var of variables, t ranges over a countably infinite set T of labels called events. We assume that 
Vat n T = O. Notation 2.1.2: We write .~ for a (possibly empty) se-quence xz,..., x,~, and 11.~1[ for 
the length n of the sequence ~. (v£1) '" (u£~) P is abbreviated to (T~z..~) P or (~) P. As usual, ~ in 
x?[~]. P and .~ in (v~) P are called bound vari- ables. The other variables are called free variables. 
We as- sume that a-conversions are implicitly applied so that bound variables are always different from 
each other and from free variables. The expression [zz/~l,..., z~/x~]P, abbreviated to [~/~]P, denotes 
a process obtained from P by replacing all free occurrences ofxt,..., x~ with zl,  , zn. We often omit 
the inaction 0 and write zlt[~] for x!t[.~]. 0. When events are not important, we omit them and just 
write ~el [~]. P and x?[~]. P for x!t[~]. P and x?t[~]. P respectively. We give a higher precedence to 
+ and (v:~) than to 1. The meanings of 0, x!t[~]. P, x?t[~]. P, and P IQ have already been explained. 
G1 + " + G~ (where Gz,..., G,~ are input or output processes) denotes an external choice: It behaves 
like one of G1,..., G,~ depending on enabled com- munications. (u~)P creates fresh channels ~ and then 
ex- ecutes p.2 .p denotes infinitely many copies of P running in parallel. 2.2 Operational Semantics 
As usual [23], we define a reduction semantics by using a structural relation and a reduction relation. 
For technical convenience, we do not require the structural relation to be symmetric. The reduction relation 
P ----+ Q is annotated with a term of the form z t't' or e t'¢. The term records on which channel and 
events the reduction is performed: It is used to state properties of a process in Section 4. Definition 
2.2.1: The structural preorder -5 is the least re- flexive and transitive relation closed under the rules 
in Fig-  ure 1 (P --- Q denotes (P .5 0) ^ (Q -5 P)). Definition 2.2.2: The reduction relation ~ is 
the least relation closed under the rules in Figure 2. 1 Available from ht~p://www,yl. is. s. u-tokyo, 
ae. j p/'koba/publica~ioas .html. 2This is operationally the same as (vxl) ". (uz~) P, but we dis- tinguish 
them in the type system given in Section 3.  PIO-=P (SPCONG-ZERO) (v~) P IQ _~ (v~) (P] Q)(if &#38; 
axe not free in Q) (SPCoNG-NEw PIQ=-QIP (SPCoNG-COMMUT) P .5_ P' Q ~ Q' P ] Q ..~ P' I Q' (SPCoNG-PARPI(Q] 
R)_= (PIQ) IR (SPCONG-ASSOC) (SPCoNG-CNEw(v~) P :< (v~) Q  19 ~ *PIP (SPCONG-REP) P_~Q  Figure 1: Structural 
Preorder . p--~-~Q PIR--L+QIR t,t I P ~ Q y e (~} ~t,t t (v~) P ------4 (v~) Q . . . . . +~!~[~].P+ I. 
(R-PAR) (R-NEwl) .~- Ii~? t~ ~ . . . z t't~ . [y].Q+ ----~PI[~/$]Q t I P--L-rQ (l=et'¢')Y(l=y t' Ay¢ 
P ~_P' (v~) P ~ (v$) Q p, '>Q, Q'~Q p _L.~ Q {~}) (R-COM) (R-NEw2) (R-SPCONG) Figure 2: Reduction Relation 
 Notation 2.2.3: We write P ) Q if P --J-r Q for some I. Notation 2.2.4: When 7~1,7~2 are binary relations 
on a set S, we write 7~ for the reflexive and transitive closure of 7~1, and 7~1T~2 for the composition 
of 7~1 and 7~e. 3 Generic Type System 3.1 Types As explained in Section 1, we extend ordinary type 
environ- ments and express them as abstract processes. In the rest of this paper, we call them process 
types (or, just types in short). For most of the process constructors introduced in the previous section, 
there are the corresponding construc- tors for process types. We use the same symbols for them to clarify 
the correspondence. Definition 3.1.1 [types]: The sets of tuple types and pro- cess types are defined 
by the following syntax. -r (tuple types) ::= (xl,...,x,)r F (process types) ::= o I ~ I~1 +--" + 7. 
I (r, Its) I r~r: I ~.r ::= x!~[~], r I x?~[~], r I t.r Here, the metavariable oL ranges over the set 
of type vari- ables. Notation 3.1.2: The tuple type (:~)F binds the variables in F. We assume that a-conversions 
are implicitly applied so that bound variables are always different from each other and free variables. 
In this paper, we restrict the syntax of tuple types so that (~)F does not contain any free variables 
or free type variables. (It is possible to remove this restric- tion: See Section 7.) We write [~/~]r 
for a process type obtained by substituting .~ for all free occurrences of :~ in F. We write *F for/zo~.(r 
I o0. We often omit 0 and write xlt[7 "] and x?t[~ -] for xlt[~']. 0 and X?t[T]. 0 respectively. We also 
abbreviate x[*[( )0]. r and x?t[( )0]. F to xlt[]. F and x?t []. F respectively. We assume that #a.r 
binds a in F. We write [F/a] for the capture-avoiding substitution of F for a. We write Null(F) if F 
does not contain a process type of the form x?t[T], rl or Mt[~-]. rl. When .r = (:~)r, we call [1~[[ 
the arity of T and write [Ir[I. The tuple type (xl,... ,x,~)F is the type of an n-tuple, whose elements 
xl,..., xn should be used according to F. 0 is the type of the inaction, xIt[~']. F is the type of a 
process that uses x for sending a tuple of type r, and then behaves according to r. The output on x must 
be tagged with t. Similarly, x?tM. F is the type of a process that uses x for receiving a tuple of type 
T, and then behaves according to F. For example, if a process should have type x? tl []. y!*2[]. 0, then 
x? tl []. yltz [] is allowed but neither y!t2 []. x?~l[]. 0 nor x? tl[]. 0 1 ylt2[] is. In this way, 
we can express more precise information on the usage of channels than previous type sys- tems [17, 18, 
27]. t.F is the type of a process that behaves according to r after some action annotated with t (which 
is an input or an output action on some channel) occurs. 3 F1 I F2 is the type of a process that behaves 
according to F1 and r2 in parallel. The type 3'1 + "" + 7, represents an external choice: A process of 
that type must behave ac- cording to one of 71,..., %~, depending on the communica- tions provided by 
the environment. On the other hand, the type Fi&#38;F2 represents an internal choice: A process of that 
type can behave according to either F1 or r2, irrespectively of what communications are provided by the 
environment. For example, the process type xIt[], y!t' [ ]~,:y!t' []. :r,!t [] means that x and y can 
be used sequentially for output in any or- der; So, both xlt []. ylt'[] and ylt'[], xlt[] can have this 
type. 4 3Instead of t.F, we could introduce process types t?.r and tl.F to distinguish between input 
and output actions. We do not do so in this paper for simplicity. 4So, rl&#38;r2 is similar to an intersection 
type F1 A r2. The differ-ence is that a value of type Fi~F2 can be used only once according to either 
F1 or r2. We use the standard notation #a.F for recursive types. For example, #c~.(x?tH. a) is the type 
of a process that uses x for receiving a tuple of type r repeatedly. Notice that, unlike the ~r-calculus 
processes in Sec-tion 2, the process types contain no operators for creating fresh channels or passing 
channels through other channels. Thanks to this, we can check properties of types (as abstract processes) 
more easily than those of the Ir-cMculus processes. Instead, we have some operators that do not have 
their coun- terparts in processes. A process type of the form t.F plays an important role in guaranteeing 
complex properties like deadlock-freedom. For example, we can express the type of (vz) (x? tt []. y!t2 
[] [ y?ta []. O) as t l.y!t2 [] ] y?t3 [], which im- plies that the output on y is not performed until 
an action labelled with tt succeeds. Since actually it never succeeds, we know that the input from y 
is kept waiting forever. 3.2 Subtyping We introduce a subtyping relation Pl _< F2, meaning that a process 
of type Pl may behave like that of type F2. For example, Fi&#38;F2 < F1 should hold. The subtyping relation 
depends on the property we want to guarantee: For example, if we are only concerned with arity-mismatch 
errors [7, 37], we may identify t.r with F, and x!t[r]. F with ,!*[,11 r, but we cannot do so if we are 
concerned with more complex properties like deadlock-freedom. Therefore, we state here only necessary 
conditions that should be satisfied by the subtyping relations of all instances of our type system. We 
need some auxiliary operations. Definition 3.2.1: Let S be a subset of Var. Unary opera- tions F$ s and 
FJ" s on process types are defined by: OSs = 0 O@S = O~ { =?'[~1. (r,s) ifxES (z?'[r]. r),~ s = t.(P,~s) 
otherwise { ~!~[-1. (r,l.s) ifxE S   (~!*[~]. r),l.s = t.(FSs) otherwise (t.r)$s = t.(r+s) (71 +-.. 
+'r,).l.s = ('n.l.s) +'." + ('r,..l.s) (rl [P=),t.s = (rl,s) l(r=,s) (rl~r~)J,s = (rl,s)~(r2,~s) o~.r)$s 
= t,~.(r.l.s) P'l's = PSv.~\s F$s extracts from r information on the usage of only the channels in S, 
while FTs extracts information on the usage of the channels not in S. Example 3.2.2: Let F = y?t[r']. 
M¢[r']. O. Then r.~{~} = t.x!¢[r]. 0 and FJ'(~} = y?t[r], t'.0. Definition 3.2.3 [subtyping]: A preorder 
< on process types is a proper subtyping relation if it satisfies the rules given in Figure 3 (F1 '~ 
F2 denotes F1 <_ F2 A F2 _< F1). In the rest of this paper, we assume that _< always de- notes a proper 
subtyping relation. We extend _< to a sub- typing relation on tuple types by: rl < r2 if and only if 
there exist ff:,F1, and F2 such that rl = (.~)F1, r2 = (:~)F2, and Fx < F2. The axiom FSslFts <_ F allows 
us to forget in-formation on dependencies between some channels. For example, if F = y?t It,]. x!t' [-r']. 
O, then F J,(=} [ FT(=} = t.M¢[r].Oly?t[T].t'.0 is a subtype of F. Notice that F$(~} I FJ'{~} expresses 
a more liberal usage of x, y than F: WhiIe F means that z is used for output only after y is used for 
input, F${~} I FT{~} only says that z is used for output after some event t, not necessarily an input 
from y. 3.3 Reduction of Process Types We want to reason about the behavior of a process by in- specting 
the behavior of its abstraction, i.e., process type. We therefore define reduction of process types, 
so that each reduction step of a process is matched by a reduction step of its process type. For example, 
the reduction of a process is matched by: for 7- = (z)z!t2[]. As is the case for reductions of processes, 
we annotate each reduction with information on which chan- nel and events are involved in the reduction. 
Definition 3.3.1: A reduction relation F1 ---+ F2 on pro- cess types (where L C TO{x t''t2 I (x e Var)A(tl, 
t2 e T)}) is the least relation closed under the rules in Figure 4. We write F ---4 F' when F ~ F' for 
some L. 3.4 Consistency of Process Types If a process type is a correct abstraction of a process, we 
can verify a property of the process by verifying the corre- sponding property of the process type. When 
a process type satisfies such a property, we say that the process type is con-sistent. The consistency 
condition depends on the property we require for processes. So, we state here only necessary conditions 
that every consistency condition should satisfy. Consistency conditions for specific instances are given 
in Section 4. Definition 3.4.1 [well-formedness]: A process type P is well-formed, written WFF(F), if 
there exist no x, rl, r2, tl, t2, rl, F2, and F3 that satisfy the following conditions:  L r-# ...+~!*ltrll.rl+... 
I ...+~?"[r2l.r~+... Iv3. 2. rl ~ rz. Remark 3.4.2: We could replace the first condition with "F contains 
X!tx[Tx] and x?t2[r2], " which can be checked more easily. We do not do so, however, to allow maximal 
flexibility of type systems. Under the above condition, we can allow process types like x? t' [ri]. x! 
t~ [r2]l x! t3 [ri]. x? ta [r2], which allows x to be used for first communicating a value of type rx, 
and then for com- municating a value of type r2. Definition 3.4.3 [consistency]: A predicate ok on pro-cess 
types is a proper consistency predicate if it satisfies the following conditions: rl0-~r rz I P~ ~ F2IF1 
 r~ I(r: Ira) ~ (r, I r~) I r~ ,~.r _~ [,~.r/~]r F<F' *F < *F' (SuB-EMPTY) (SuB-COMMUT) (SUB-ASSOC) (SuB-REc) 
(SuB-ICHOICE) (SuB-REP) Pl Ira _< rl ItS ~ _< ~ for each i e {1,..., ~} -y~ +...+~, _< v~ +... +,/ F<F' 
PSs -< P'$s r<_r' [y/~]r < [y/~lr'  (r~s [rrs) _< r Figure 3: Necessary Conditions on Subtyping Relation 
rz <r2 .. + =!~,[~]. r, +... I. + =?'~[~]. r~ +... (=-52) r~ Its rl L,> p~ r2 --~ r~ r ~ r (TER-SKIP) 
r, [r~ ~'~= rl ItS (SuB-PAR) (SuB-CHOICE) (SuB-RESTRICT) (SuB-SUBST)   (SuB-DIVIDE) (TER-CoM)  (TER-PAR) 
 .. + t.P +... {t}> r (TER-Ev) Fz < rl rl L > r~ r~ _< r= (TER-SuB) F1 L> I'2 Figure 4: Reduction 
of Process Types 1. If ok(F), then WF(F). 2. If ok(F) and F > F', then ok(F'). 3. If ok(Fz) and Null(r~), 
then ok(Fz IF2)  In the rest of this paper, we assume that ok always refers to a proper consistency 
predicate. Because process types form a much simpler process cal- culus than the 7r-calculus, we expect 
that the predicate ok is normally much easier to verify than the corresponding property of a process. 
The actual procedure to verify ok, however, depends on the definition of the subtyping relation <_ : 
If we are not interested in linearity information [17], we can introduce the rule F [ F ~ F so that the 
reductions of a process type can be reduced to a finite-state machine. But if we take _< to be the least 
proper subtyping relation, we need to use a more complex system like Petri nets, as is the case for our 
previous type system for deadlock-freedom [18]. 3.5 Typing A type judgment is of the form F~P, where 
F is a closed (i.e., containing no free type variables) process type. It means that P behaves as specified 
by F. Typing rules are given in Figure 5. The rules (T-PAR), (T-CHOICE), and (T-REP) say that an abstraction 
of a pro- cess constructed by using a process constructor [, +, or * can be obtained by composing abstractions 
of its subpro- cesses with the corresponding constructor of process types. The key rules are (T-OuT), 
(T-IN), and (T-NEw). Note that channels can be dynamically created and passed through other channels 
in the process calculus, while in the calculus of process types, there are no corresponding mech- anisms. 
So, we must somehow approximate the behavior of a process in those rules. In the rule (T-OuT), we cannot 
express information that [~] is passed through x at the type level. Instead, we put [~/~]F2, which expresses 
how the channels ~ are used by a receiver, into the continuation of the output action. In the rule (T-IN), 
information on how received chan- nels .~ are used is put into the tuple type (9)(F${~t). Be-cause we 
want to keep only information on the usage of .~, we apply "${~9} to remove information on the usage 
of the other variables. Information on the usage of the other vari- ables is kept in the continuation 
Ft{uz ..... u~t of the input ac- tion. For example, consider a process x? tl [y]. y?t2 []. z!tS []. Its 
subprocess y?t2 []. z!ta[] is typed under the process type y?t2 []. z!t3 []. 0. By applying (T-IN), we 
obtain the following type judgment: x?tZ [(y)y?t~ []. t3.01, t2.z! t3 [1' 0 > x?t~ M" Y?'~ []' z!~3 [] 
Notice that the parameter type (y)y?t2 []. ta.0 of the channel x carries only information that some event 
t3 occurs after y is used for input, not that z is used for output. On the other hand, the continuation 
part t2.z!ta[]. 0 says just that z is used for output only after some event t2 occurs. In the rule (T-NEw), 
we check by the condition ok(F$(~}) that ~ are used in a consistent manner, and forget inform-at-ion 
on the use of ~ by "T(~}.  3.6 Properties of the Type System The general type system given above is 
parameterized by the subtyping relation <_ and the consistency predicate ok, OttO F i ~ P~ F 2 ~, P~ 
r~ Ir~ ~-Ol I~ Ft>P *F ~ *P F't~P F < F ~ F~P (T-ZERO) (T-PAR) (T-REP) (T-SuB) 7i t~ Gi for each i 
E {1,... ,n} 7a +"" +% ~G1 +... +G,~ F1 c,P ~t[(#)V~]. (V, I [~/.~]r2) ~ ~*[~]. P Ft~P z?t[(fi)(r~(~})].(r?~})~z?t[~].P 
  r>P ok(r$(~}) (T-CHoICE) (T-OUT) (T-IN) (T-NEw) Figure 5: Typing Rules which determine the exact 
properties of each instance of the type system. As we show below, however, several impor- tant properties 
can be proved independently of a choice of the subtyping relation and the consistency predicate. In particular, 
we can prove that if F > P holds, F is a correct abstraction of P in the sense that P satisfies a certain 
in- variant property if F satisfies the corresponding property (Theorem 3.6.2). Type Preservation We 
define a mapping l # from labels of process reductions to labels of type reductions by: (xt1't2) # ~-(X 
tl't2} and (etl ,t2 )# = {tl, t2 }. The following theorem guarantees that if F t~ P holds, for every 
reduction of P, there is a corre-sponding reduction of F. Theorem 3.6.1 [subject reduction]: If F~ P 
and P _L+ Q with WF(F), then there exists F ~ such that F -~+ F' and r'~Q. As a corollary, it follows 
that a process satisfies a certain invariant condition p if the process type of P satisfies the corresponding 
consistency condition. Theorem 3.6.2: Suppose p(P) holds for any F such that F ~. P and ok(F). If F ~ 
P and ok(F), then p(Q) holds for every Q such that P --+* Q. Proof: By mathematical induction on the 
length of the reduction sequence P ~ ... ~ Q, using Theorem 3.6.1 and the fact that ok is preserved by 
reduction. D  Normalization of Type Derivation The normal derivation theorem given below is useful for 
studying a relationship between a process and its process type, and also for developing type-check/reconstruction 
al- gorithrns. We write P t~v P if F > P is derivable by using (T-SuB) only immediately before (T-IN) 
or (T-OuT). Theorem 3.6.3 [normal derivation]: If Ft~P, then F~N P for some F ~ such that F < F *. Proof: 
This follows from the fact that each application of the rule (T-SuB) above a rule except for (T-IN) and 
(T-OUT) can be permuted downwards. [] As a corollary, it follows that if a process is trying to perform 
an input action, its process type is also trying to perform the corresponding action. (A similar property 
holds also for output.) Corollary 3.e.4: Ifr~(~l..k) (...+y?t[~]. p+... ]Q) and ok(F), then the following 
conditions hold. 1. If y ¢ {£t,...,:~k}, then F _< ... + y?t[~.].F1 +... [ F2 for some %F1, and Fz. 
2. If y e (:~l,...,:fk}, then F < .-. + t.r~ +... Ir2 for some Ft and F2.  Conversely, if a process 
type obtained by normal deriva- tion is trying to perform some action, the process is also trying to 
perform the corresponding action. Theorem 3.6.5: 1. If "" + t.F1 + "" IF2 ~lv P, then P --~ (~l..k)(y?t[~].QIR) 
or P -'4 (~x..~)(y!t[~].Q[R~, with y e (:f~,..., :fk}. 2. If ... + y?t[r].F1 + ... IF2 tan P, then P 
(~l..k) (y?.t [~]. Q iR) with y ¢ {nil ...., ~k}.  Proof: Trivial by the definition of F t~N P. O Type 
Check/Reconstruction By using Theorem 3.6.3, we can also formalize a common part of type-check/reconstruction 
algorithms: By reading the typing rules in a bottom-up manner, we can develop an algorithm that inputs 
a process expression and outputs a set of subtype constraints and consistency conditions on process types 
(see Appendix A). A process is typable if and only if the set of constraints output by the algorithm 
is satisfiable. Thus, to develop a type-check/reconstruction algorithm for each instance of our type 
system, it suffices to develop an algorithm to solve constraints on process types. Such algorithms have 
already been developed for specific type systems [12, 18]. 4 Applications We show that a variety of type 
systems --those for arity- mismatch check, race detection, deadlock detection, and static garbage-channel 
collection -- can indeed be obtained as instances of the generic type system. Thanks to the com- mon 
properties in Section 3.6, only a small amount of extra work is necessary to define each instance and 
prove its cor- rectness. The invariant properties of well-typed processes that the type systems should 
guarantee are shown in Table 1. The condition pl (P) means that no arity-mismatch error occurs immediately. 
(So, if Pl is an invariant condition, no arity- mismatch error occurs during reduction of P.) pz(P) means 
that P is not in a race condition on any output actions annotated with t. p3(P) means that P is not deadlocked 
on any actions annotated with t in the sense that when- ever P is trying to perform an action annotated 
with t, P can be further reduced, p4(P) means that after a channel has been used for an input action 
annotated with t, it is no longer used. So, it is safe to deallocate the channel af- ter the action annotated 
with t. For example, the process (~,z) (x! t~ [] [x!t~[] [ x?t3[], x?t[]. 0) satisfies this property. 
Table 2 shows the consistency condition for each type system, ok2(F) means that no race occurs on output 
actions annotated with t during reductions of the abstract process F. okz(F) means that whenever F is 
reduced to a process type trying to perform an action annotated with an event t ~ less than or equal 
to t, F can be further reduced on some channel or on an event less than t ~. (Here, we assume that is 
some well-founded relation on events, and t ~ t ~ means t -.~ t' or t = tl.) ok4(F) means that, after 
F has been reduced on an action involving a channel x and the event t, the reduced process type no longer 
performs an input or output action on the same channel. Let _< be the least proper subtyping relation. 
We can prove the following type-soundness theorem for all of the above type systems. By Theorem 3.6.2, 
it suffices to show that F~P and oki(F) imply pi(P) for each i, by using The- orems 3.6.3-3.6.5 (see 
Appendix B.2). Theorem 4.1: Let ok be ok~ (i E {1,2,3,4}). If FoP and ok(F), then pi(Q) holds for every 
Q such that P >* Q. Actually, < can be any proper subtyping relation ex- cept for the case i = 3. Choosing 
an appropriate subtyping relation for each type system would simplify type-checking or type-reconstruction. 
For example, in the above type sys- tems, we can identify t.F with F by the rule t.F ~ P, except for 
the case i = 3. For a naive arity-mismatch check [7, 37], we can ignore the order of communications by 
introducing rules like x?t[r], r ~_~?t[.] I r. The following examples indicate that our framework not 
only subsumes many of the existing type systems but also provides more powerful type systems than them 
(see also Section 5). Example 4.2: The process x?[y], z?[]. 0 [x![w]. x![] is well typed in the first 
(i = 1) type system. So, unlike in ear- lier type systems [7, 37] for arity-mismatch check, the same 
channel can be used for communicating values of different types. 5 Example 4.3: The second type system 
guarantees that the process (ul,:~) (l!t°[]l*l?t'[].x!t[]. lira[]Ix?t4[/. 0) is race-free on the channel 
x. So, unlike the linear r-calculus [17], our type system can guarantee lack of race conditions even 
on channels that are used more than once. 6 5Yoshida's type system [38] also allows such use of channels. 
6Flanagan and Abadi's type system [4] also gives such a guarantee. Because their target calculus has 
locks as primitives, the problem is a little simpler. Example 4.4: The third type system rejects the 
pro- tess P = (w)(~U)(~?~[].U!~[llY~*=[].~!~[l). The type of the sub-process x? [].y!'[]ly?t2[].x!t3[] 
is x?t[].y!t'[] [y?t2[].x!ta[]. So, in order for P to be well- typed, the following constraints must 
be satisfied: Oks(X.Tt[].tl.0lt2.x!t3[])  oks(t.y! ~* [] I y?~ []. t3.0) The former constraint requires 
that t2 -~ t (because the in- put from x succeeds only after the event t~ succeeds), while the latter 
requires that t ~ t2, hence a contradiction. Remark 4.5: A type environment in a usual type sys-tem corresponds 
to the equivalence class of a process type with respect to the relation ~ derived from an appropri-ate 
subtyping relation. (Recall that F1 ~ F2 is defined as F1 _< F2 A Fz < F1.) For example, the type environment 
z: [[]/0]/(010 , z: []/(OlI.I ) given in Section 1 corresponds to the equivalence class of a process 
type  z!t[(y)y!t[]l lz?t[(y)y!t[]l lz!t[] lz?t[], z?t[], with respect to ~ that satisfy the rules x!t[r]. 
I ~ ~ x! t' [~-]. F, =V[~].r _~ =?"[~].r, t.r _~ r, and (rss Iris) ~ r. The last rule removes information 
on the order of communica- tions between different channels. A type environment of the linear 7r-calculus 
[17] is obtained by further removing infor- mation on channel usage, by adding the rules x!t[~-]. F .~ 
x!t[~']l F, x?t[~'].F -~ x?~[~'] IF, and rlr ~ .r. A type en- vironment of the input-only/output-only 
channel type sys- tem [27] is obtained by further adding the rule *F ~ F. 5 Further Applications: Analysis 
of Race and Deadlock of Concurrent Objects The type systems for race- and deadlock-freedom, presented 
in the last section, are indeed powerful enough to guarantee some useful properties about concurrent 
objects. In essence, a concurrent object is regarded as a set of processes that provides a collection 
of services (e.g., methods) [13, 19, 29], just as a sequential object is a set of functions. Clients 
refer to an object through a record of channels that represent locations of those services. Hence, by 
giving an appropriate type to the record, we can enforce a certain protocol that clients should respect. 
Since our type system can capture, in particular, temporal dependency on the utilized services, it is 
possible to guarantee race-freedom of accesses to methods, studied by Abadi, Flanagan and Freund [4, 
6], and deadlock- freedom for objects with non-uniform service availability, studied by Puntigam [30]. 
Note that, so far, these properties have been discussed only for languages with primitive notion of objects. 
This section demonstrates how our type system can guarantee these properties. We first describe race-free 
accesses to methods. For ex- ample, the following process waits for a request on newob, and upon receiving 
a request, creates an object with a lock l, a method m to print out the string "Hello, " appended to 
a given string, and a channel r to receive a reply from the method, and exports its interface [l, m, 
r/through the reply channel r r. *newob? [r']. (ul, m, r) ( l!t' [] I .mr e [s]. ~i~t! ~' [" Hello, "]. 
r~i~t! ~' [s]. r!e[] There exist no ~1 ..... Zk, x, ~, ~, t, t', Qi, Q2, and Qs such that P _~ (~l..k) 
('" +x!t[}]. Q~ +'" I '" "+ pl(P) x?t,[z~].Q 2 +"" ]Qs) with I]~H # IIz~]l. There exist no x, dl, ..., 
~,~, z, w, t', Q1, Q2, Q3 such that pz(P) p ~ (~x.., 0 (... +z!t[~].Q~ +... [ "'" + ~clt'[~] .Q2 +"" 
[Qs). If there exist ~,...,/,~, y, ~, Q_,Rp such that, ~ [R) or P (~1..,0 ("' Pp_ (~L.,~) ("" +y?t[~].Q+"" 
~ +ps(P) y!t[~]. Q +... [ R), then P ..> for some ------~-----+* Q, then there exist Q1,Q2 such that 
Q ~ (~d) (... + x?[.~]. Q1 +... [Q2) or Q ~ (~) (... + xl[~]. Q1 +'" I Q2). p4(P) For any t', x, w~, 
.. ., uT,~, P', and Q, if P --~*~ (~l..n)P' and P' ~¢'* no Table 1: Properties of Processes okl(r) WF(r) 
WF(F), and there exist no x, t', ~'1, ~'2, F1, F2, F3 such that F .... ~* "" ÷x!t [~-1]. F1 +"' I"" ÷ 
~c!t' [~'2]. F2 + ok2(r) ... [rs. wF(r), and ift' ~ t, F ---~* F' and F' is ... + y?t'[~'].F1 + .-. 
Its or... + y!~'[~].rl + ... Ir~ for some oks(r) y, ~', t', Fi, F2, then F' ---+ F" for some L and F" 
such that (i) L = {x t''t2 } or (ii) L = {t'} and t" ~ t'. WF(F), and for any z, t', and F', if F ----+*-----¢. 
F', then there exist no T, F t, F2 such that F' ----¢-* ok4(r) .. + x?¢'[~l.rx +... I r2 or r' ---~* 
... + x!t"[~].ra +... IF2. Table 2: Consistency Conditions Since the method m should not be invoked simultaneously, 
r clients should acquire and release the lock l before and after the invocation of m, respectively. Indeed 
by using ok2, it is guaranteed that there are no simultaneous outputs to m: The exported interface [l, 
m, r] (through which clients access to the object) can be given a type: t I t I (L, m, r) * ~?t' []. 
m!t[st~g], r? []. l! [], where *F abbreviates/zc~. (O&#38;(F I c0), meaning that the tuple can be used 
according to F by arbitrarily many processes. (Here, we assume that the subtyping relation <_ satisfies 
t.F ~ F.) Then, a client /?t' []. ralt [,, Atsushi"]. r?t' []. l! t' [] I/?t' []. m! t [" Naoki"]. r?t'[]./!t' 
[] is well typed, but m!t["Atsushi"].r?t'[]..., is not. The above type of the interface roughly corresponds 
to the object type [m : ~(l)String --+ Unit. {/}. +] of Abadi and Flana- gan's type system [4], which 
means that the method m can be invoked only after the lock on the object is acquired. Similarly, we can 
express non-uniform service availability in our type system. For example, this is a process that creates 
a one-place buffer: newbuf? [r]. (vput, get, b) ( b![] I *b?[]. put?[x], get?[r']. (r'![x] l b![]) It! 
[put, get]) Now, two methods put and get are provided but they are available only alternately. By using 
oks, we can guaran-tee that invocations of the methods put and get never get deadlocked. The interface 
[put, get] can be given a type: (put, get)~.(0&#38;(p~t! t [~] I ~.get! t [(r)r! ~[~]1. ~.~)), which 
says that an output to put must come in paral-lel to or before an output to get. (Here, ¢x~.F abbrevi- 
ates #c~. (F&#38;tl .c~&#38;... &#38;t,~.c~) where {tl,..., t,~} is the set of 7We do not want an output 
like "Hello Hello " events occurring in the program. It means that it is allowed to wait for arbitrary 
events before using the value according to F.) Then, both put!t[v]l(vr) get!tit], r?[x]. - and put! 
t [v]. (vr) get! t [r]. r?[z].... are well-typed (and hence never get deadlocked on put! and get!) while 
(vr')geW[r']. r'?[x], putlt[v]..., is not. 6 Towards a General Type Soundness Theorem In Section 3.6, 
we have shown that a process satisfies a cer- tain property p if its process type satisfies the corresponding 
consistency condition ok. However, it was left to the de-signer of a specific type system to find a consistency 
condi- tion that corresponds to a process property of interest and prove that the correspondence is indeed 
correct. In fact, in Section 4, we had to find a suitable consistency condition on process types and 
prove its correctness (Theorem 4.1) for each type system. Also, there remains a general ques- tion about 
the power of our generic type system: What kind of type system can be obtained as an instance? Clearly, 
not all properties can be verified in our type system: For exam- ple, the property "a process can create 
at most n channels" cannot be verified, because process types contain no infor-mation on channel creation. 
This section gives a partial answer to those questions: For a certain class of properties of processes, 
there is indeed a systematic way for obtain- ing the corresponding consistency condition ok on process 
types, so that the instantiated type system is sound. For lack of space, details are omitted: They are 
found in the full paper [11]. We first introduce logical formulas [1,32] to formally state properties 
of processes and types. Definition 6.1: The set Prop of formulas is given by the following syntax (i, 
j denote variables ranging over the set Nat of non-negative integers and n denotes a non-negative integer 
or a variable ranging over Nat): A ::= tt Ix!tnlx?tnl (AIB) I (l)AI ev(A) C ::= I -,A I AV B I 3x.A I 
Bt.A I 3i: C.A {i~#j~,...,i~#jk} A formula A describes a property of both processes and types. Intuitively, 
x!tn means that some sub-process is ready to output an n-tuple on the channel x and that the output is 
tagged with t. Similarly, x.Ytn means that some sub-process is ready to input an n-tuple. The formula 
A [ B means that the process is parallel composition of a process satisfying A and another process satisfying 
B. (l)A means that the process can be reduced in one step to a process satisfying A and that the reduction 
is labelled with l. ev(A) means that the process can be reduced to a process satisfy- ing A in a finite 
number of steps, s As a property of processes, the formal semantics [Alp r of each formula (i.e., the 
set of processes satisfying the formula) is defined by (Proc is the set of processes and FV(A) is the 
set of free variables in A): 9 [tt]p r = Proc ~X]t'n']pr : {P I P ~ (~'~L.k) ("' + x!t[~]. Q +'" I R), 
= ¢ {~,,..., ~}, IlYll = ~} [x?tn]pr = {P I P ~ (~l..k) ('" + x?t[~]. Q +"-I R), [A I B]pr = {P ] P ~ 
(~l..k) (QI R), Q [A]p~, R [B]p,, {:~,..., :Ek} N FV(A IB) = O} [(/)A]p,={Pl P Z~Q,Q ~A]p~} [ev(A)] 
m. = {PIP )* Q, Q ~A]pr} ~-,A]pr = Proc\Hp~ Similarly, a formula can be regarded also as a property 
of process types (Type is the set of process types): ~ttLy = Type ~!:~]t, = {r I r < ... + ~!t[~]. zx~ 
+... la~, IM = ~} EAIB]t~={r I r <_-(a~ la=),a~ [Airy,a2 [B]ty} I(l)A]ty = {r I r ~ l # &#38;,A [d]t 
} [ev(m)]ty = {F [ F ----~* a, a lAity } [~A]ty = Type\lAity We can show that for any negative formula 
A defined below, a process P satisfies A (i.e., P [A]pr) if its process type F satisfies the same formula 
A. Our type system is there- fore sound at least for properties described using negative formulas. Definition 
6.2 [positive/negative formulas]: The set .~+ (~-, resp.) of positive (negative, resp.) formulas are 
81nstead, we could introduce a general fixed-point operator [32]. 9Formally, [Alp r is parameterized 
by an assignment of variables to non-negative integers: See the full paper [11]. the least set satisfying 
the following rules: tt ~+ f7.) r- x!t n, x.Tt n .~+ A,B Y r+ A IB, A V B, (1)A, ev(A),3x.A, 3t.A,3i:C.A 
 Y:+ A, B Y:- ~ A V B, 3x.A, 3t.A, 3i : C.A yr- A yr+ ~ -~A yr - A yr-~-,A yr + Theorem 6.3: Suppose 
F t> P and WF(F). If A E .T'- and F lAity , then P [Alp r holds. Conversely, if A .T "+ and P ~A]pr, 
then F lAity holds. Proof sketch: This follows by induction on the structure of A. The cases for (1)A 
and ev(A) follow from Theo- rem 3.6.1 and the cases for x!tn, x.Tt?z, and A I B follow from Theorem 3.6.3 
and Corollary 3.6.4. The other cases follow immediately from the definitions of [Alp r and lAity. [] 
Corollary 6.4 [type soundness]: Let A E .T'-and P be a closed process. Suppose that ok(F) implies F E 
lAity. Suppose also that F ~ P and ok(F). Then, if P ----4" (~) (v~) Q, then (~) Q e ~A]pr. Intuitively, 
the last sentence of the above corollary means that all the channels created during reductions of P are 
used according to A. The corollary implies that, in order to guarantee that property, it suffices to 
define the consis- tency condition ok by ok(P) ~ WF(P) A inv(A) (where inv( A ) = -,ev(-,A ) ). The type 
systems for lack of arity mismatch, race detec- tion, garbage-channel collection discussed in Section 
4 can be automatically obtained by using the above corollary: For example, in the case of arity-mismatch 
check, we can let A be -~ev(3x.3t, t'.3i, j : { i ~ j}.(x!t i l x?t'j)). In the case of race detection, 
we can let A be -,ev(3x.St'.Si, j:O.(x!tilx!t'j)). We can also obtain a variant of the linear channel 
type sys- tem [17]. Let m be -,3x.3tz, t2, ta.3n.ev((x t''t2)ev(x!t3n V x?t3n)); Then it is guaranteed 
that every channel is used ~t most once. Note that our type system is sound also for some non- negative 
formulas: Indeed, the deadlock-free property is not described as a non-negative formula, but our type 
system is still sound as proved in Appendix B.2. It is left for future work to identify a larger class 
of properties for which our type system is sound, and obtain a general type soundness theorem (like Corollary 
6.4 above) for that class. 7 Limitations and Extensions Although a variety of type systems can be obtained 
as its instances, our generic type system is of course not general enough to obtain all kinds of type 
systems. There are two major sources of limitations of our type system: One is the way in which processes 
are abstracted, and the other is the way the consistency condition ok on types is formalized. Limitations 
caused by abstraction Because information on channel creation is lost in process types (recall the rule 
(T- NEW)), we cannot obtain type systems to guarantee proper- ties like "at most n channels are created." 
We can overcome that limitation to some extent, by introducing a process type new~.F, which means that 
the process behaves like F after creating k channels. Some information is also lost in the rule (T-IN): 
Because information on the usage of bound channels (expressed by F.I.{.~} ) is put into the continuation 
of an output process and that on the usage of free channels (expressed by FJ" ~7 ) is () put into the 
continuation of the input process, the causal- ity information between communications on bound channels 
and those on free channels is lost. We can improve the type system by removing the restriction that tuple 
types can-not contain free variables (Notation 3.1.2) and changing the rule (T-IN) into the following 
rule, to allow an arbitrary de- composition of information on the usage of bound and free channels: P~P 
F1 I C~ _< r Fv(r2) n {~9) = ¢ This kind of extension is necessary to account for some exist- ing type 
systems like Abadi and Flanagan's type system for race detection [4]. In fact, the analysis of race discussed 
in Section 5 works only when the lock l and the other interfaces m and r are created simultaneously and 
passed together; Otherwise, dependencies between the usage of l, m and r are lost. To get rid of such 
restriction, the above extension of the rule (T-IN) and an extension of the rule (T-NEw) discussed in 
the next paragraph is necessary. Limitations caused by the formalization of ok To obtain common properties 
useful for proving type soundness (in Sections 3.6 and 6), we required that the consistency con- dition 
ok must be an invariant condition (recall Defini- tion 3.4.3). This requirement is, however, sometimes 
too strong. For example, suppose that we want to guarantee a property "Before a channel x is used for 
output, y must be used for input." (This kind of requirement arises, for exam- ple, in ensuring safe 
locking [5].) Note that this property is not an invariant condition: Once y is used for input, x can 
be used immediately. One way to overcome this limitation would be to annotate each channel creation (u:~) 
with the history of reductions, and parameterize ok with the history. Another limitation comes from the 
side condition ok(FJ.{~}) of the rule (T-NEw): Because of the opera-tion ${~}, only the causality between 
simultaneously cre- ated channels can be directly controlled. We can overcome this limitation by parameterizing 
the condition ok with a set of channels of interest, and replacing ok(F${~}) with ok(r, {~}). Other extensions 
There are many other useful extensions. Combining our type system with polymorphism, existential types, 
etc. would be useful. We expect that polymorphism can be introduced in a similar manner to Pierce and 
San- giorgi's polymorphic r-calculus [28]. The type system for deadiock-freedom in Section 4 is ac- tually 
naive. More special treatment of event tags t is nec- essary to obtain a sophisticated type system for 
deadlock- freedom [14] (see the full paper [11]). Besides type-soundness proofs and type inference issues 
studied in this paper, it would be interesting to formalize other aspects of type systems through our 
generic type sys- tem. Typed process equivalence would be especially impor- tant, because it is hard 
even for specific type systems [17, 27,281. Another interesting extension is generalization of the tar- 
get language. If we can replace the at-calculus with a more abstract process calculus like Milner's action 
calculi [24], type systems for other process calculi can also be discussed uniformly. 8 Related Work 
General framework of type systems Previous proposals of a general framework [9, 20, 21] are (i) so abstract 
(e.g., [9, 20]) that only a limited amount of work can be shared for developing concrete type systems, 
and/or (ii) not gen- eral (e.g., [20, 21]) enough to account for recent advanced type systems. Honda's 
framework [9] is more abstract than ours. Moreover, his framework only deal with what he call additive 
systems, where the composability of processes are determined solely by channel-wise compatibility: So, 
it can- not deal with properties like deadlock-freedom, for which inter-channel dependency is important. 
On the other hand, his framework can deal with a wide range of process cal- culi as target languages, 
not only the 7r-calculus. In KSnig's type system based on hypergraphs [20], type environments do not 
change during reduction of a process. So, it cannot deal with dynamically changing properties like linearity 
[17]. Moreover, the target calculus is less expressive than the 7r- calculus, our target calculus: It 
cannot express dynamic cre- ation of channels. Other type systems viewing types as processes Some pre- 
vious type systems also use process-like structures to ex-press types. Yoshida's type system [38] (which 
guarantees a certain deadlock-freedom property) uses graphs to express the order of communications. Her 
type system is, however, specialized for a particular property, and the condition cor- responding to 
our consistency condition seems too strong, even for guaranteeing deadlock-freedom. Nielson and Nielson 
[25] also use CCS-like process terms to express the behavior of CML programs. Because their analysis 
approximates a set of channels by using an abstract channel called a region, it is not suitable for analyses 
of deadlock-freedom (see [14] for the reason), race detection, linearity analysis, etc, where the identify 
of a channel is important. Process-like terms have been used as types also in type systems for deadlock-freedom 
[30] and related properties [31] of concurrent objects. As briefly outlined in Section 5, our type system 
can guarantee such properties without having concurrent objects as primitives. Abstract interpretation 
As mentioned in Section 1, our generic type system can be viewed as a kind of abstract interpretation 
framework [2], in the sense that properties of programs are verified by reasoning about abstract versions 
of those programs. From this viewpoint, our contribution is a novel formalization of a specific subclass 
of abstract interpretation for the 7r-calculus (for which no satisfactory general abstract interpretation 
framework has been devel- oped to the authors' knowledge) as a type system. Another novelty seems to 
be that while conventional abstract inter- pretation often uses a denotational semantics to claim the 
soundness of an analysis, our type system uses an opera-tional semantics, which seems to be more convenient 
for analyses of concurrent processes. Non-standard type systems for functional languages Un-like standard 
type systems for functional languages, our type system keeps track of not only the shape of each value 
but also information on how each value is accessed. In this re- spect, there seems to be some connection 
between our type system and non-standard type systems for functional lan- guages, especially those for 
memory management [15, 36]. It would be interesting to study whether they can be encoded into some extension 
of our generic type system. Conclusion We have proposed a general type system for concurrent pro- cesses, 
where types are expressed as abstract processes. We have shown that a variety of non-trivial type systems 
can be obtained as its instances, and that their correctness can be proved in a uniform manner. Future 
work includes a study of a more general version of the type soundness theo- rem in Section 6, and extensions 
of our generic type system discussed in Section 7, to give a complete account of the existing type systems 
for the v-calculus. Acknowledgment We would like to thank Andrew Gordon, Eijiro Sumii, and anonymous 
referees for useful discussions and comments. References <RefA>[1] L. Cardelli and A. D. Gordon. Anytime, anywhere: 
Modal logics for mobile ambients. In Proceedings of A CM SIGPLAN/SIGA CT Symposium on Principles of Programming 
Languages, pages 365-377, 2000. [2] P. Cousot and R. Cousot. Abstract interpretation: A unified lattice 
model for static analysis of programs by construction or approximation of fixpoints. In Proceed-ings 
of ACM SIGPLAN/SIGACT Symposium on Prin- ciples of Programming Languages, pages 238-252, 1977. [3] M. 
F/ihndrich and A. Aiken. Program analysis us-ing mixed term and set constraints. In Proceedings of SAS'97, 
LNCS 1302, pages 114-126. Springer-Verlag, 1997. [4] C. Flanagan and M. Abadi. Object types against races. 
In CONCUR'99, LNCS 1664, pages 288-303. Springer- Verlag, 1999. [5] C. Flanagan and M. Abadi. Types for 
safe locking. In Proceedings of ESOP 1999, LNCS 1576, pages 91-108, 1999. [6] C. Flanagan and S. N. Freund. 
Type-based race de-tection for Java. In Proceedings of ACM SIGPLAN Conference on Programming Language 
Design and Im- plementation, pages 219-232, 2000. [7] S. J. Gay. A sort inference algorithm for the polyadic 
7r- calculus. In Proceedings of A CM SIGPLAN/SIGA CT Symposium on Principles of Programming Languages, 
pages 429-438, 1993. [8] M. Hennessy and J. Riely. Information flow vs. resource access in the information 
asynchronous pi-calculus. In Proceedings of ICALP 2000, LNCS 1853. Springer-Verlag, 2000. [9] [lO] [11] 
 [12] [13] [14] [151 [16] [17] [18] [19]  [20] [21] [22] [23] K. Honda. Composing processes. In Proceedings 
of A CM SIGPLAN/SIGA CT Symposium on Principles of Programming Languages, pages 344-357, 1996. K. Honda, 
V. Vasconcelos, and N. Yoshida. Secure information flow as typed process behaviour. In Proc. of European 
Symposium on Programming (ESOP) 2000, LNCS 1782. Springer-Verlag, 2000. A. Igarashi and N. Kobayashi. 
A generic type system for the pi-calculus. Tech. rep., Department of Informa- tion Science, University 
of Tokyo, 2000. to appear. A. Igarashi and N. Kobayashi. Type reconstruction for linear pi-calculus with 
I/O subtyping. Information and Computation, 161:1-44, 2000. C. B. Jones. A pi-calculus semantics for 
an object-based design notation. In Proceedings of CONCUR '93, LNCS, pages 158-172. Springer-Verlag, 
1993. N. Kobayashi. A partially deadlock-free typed pro-cess calculus. A CM Transactions on Programming 
Lan- guages and Systems, 20(2):436-482, 1998. N. Kobayashi. Quasi-linear types. In Proceedings of ACM 
SIGPLAN/SIGACT Symposium on Principles of Programming Languages, pages 29-42, 1999. N. Kobayashi. Type 
systems for concurrent pro-cesses: From deadlock-freedom to livelock-freedom, time-boundedness. In Proceedings 
of IFIP Interna- tional Conference on Theoretical Computer Science (TCS2000), LNCS 1872, pages 365-389, 
2000. N. Kobayashi, B. C. Pierce, and D. N. Turner. Linearity and the pi-cMculus. A CM Transactions on 
Program- ming Languages and Systems, 21(5):914-947, 1999. N. Kobayashi, E. Sumii, and S. Saito. An implicitly- 
typed deadlock-free process calculus. In Proceedings of CONCUR2000, LNCS 1877, pages 489-503. Springer- 
Verlag, 2000. N. Kobayashi and A. Yonezawa. Towards foundations for concurrent object-oriented programming 
-types and language design. Theory and Practice of Object Systems, 1(4):243-268, 1995. B. KSnig. Generating 
type systems for process graphs. In Proceedings of CONCUR '99, LNCS 1664, pages 352- 367. Springer-Verlag, 
1999. B. KSnig. Analysing input/output-capabilities of mo- bile processes with a generic type system. 
In Proceed-ings ofICALPZO00, LNCS 1853. Springer-Verlag, 2000. R. Milner. Communication and Concurrency. 
Prentice Hall, 1989. R. Milner. The polyadic v-calculus: a tutorial. In F. L. Bauer, W. Brauer, and H. 
Schwichtenberg, editors, Logic and Algebra of Specification. Springer-Verlag, 1993. [24] R. Milner. Calculi 
for interaction. Acta Informatica, 33(8):707-737, 1996. [25] H. R. Nielson and F. Nielson. Higher-order 
concur-rent programs with finite communication topology. In Proceedings of A CM SIGPLAN/SIGA CT Symposium 
on Principles of Programming Languages, pages 84-97, 1994. [26] F. Pessaux and X. Leroy. Type-based analysis 
of uncaught exceptions. In Proceedings of A CM SIG- PLAN/SIGA CT Symposium on Principles of Program- 
ming Languages, pages 276-290, 1999. [27] B. Pierce and D. Sangiorgi. Typing and subtyping for mobile 
processes. Mathematical Structures in Computer Science, 6(5):409-454, 1996. [28] B. Pierce and D. Sangiorgi. 
Behavioral equivalence in the polymorphic pi-calculus. Journal of the Associa- tion for Computing Machinery 
(JA CM), 47(5):531-584, 2000. [29] B. C. Pierce and D. N. Turner. Concurrent objects in a process calculus. 
In Theory and Practice of Paral- lel Programming (TPPP), Sendal, Japan (Nov. 199~), LNCS 907, pages 187-215. 
Springer-Verlag, 1995. [30] F. Puntigam and C. Peter. Changeable interfaces and promised messages for 
concurrent components. In Pro-ceedings of the 1999 A CM Symposium on Applied Com- puting, pages 141-145, 
1999. [31] A. Ravara and V. Vasconcelos. Typing non-uniform concurrent objects. In Proceedings of CONCUR2000, 
LNCS 1877, pages 474-488, 2000. [32] C. Stifling. Modal and temporal logics for processes. In Logics 
for Concurrency, LNCS 1043, pages 149-237, 1996. [33] E. Sumii and N. Kobayashi. A generalized deadlock-free 
process calculus. In Proc. of Workshop on High-Level Concurrent Language (HLCL '98), ENTCS 16(3), pages 
55-77, 1998. [34] J.-P. Talpin and P. Jouvelot. Polymorphic type, region and effect inference. Journal 
of Functional Program- ming, 2(3):245-271, 1992. [35] J.-P. Talpin and P. Jouvelot. The type and effect 
disci- pline. In Proceedings of IEEE Symposium on Logic in Computer Science, pages 162-173, 1992. [36] 
M. Tofte and J.-P. Talpin. Implementation of the call- by-value lambda-calculus using a stack of regions. 
In Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles off Programming Languages, pages 188- 201, 
1994. [37] V. T. Vaseoncelos and K. Honda. Principal typing schemes in a polyadic 7r-calculus. In CONCUR'93, 
LNCS 715, pages 524-538. Springer-Verlag, 1993. [38] N. Yoshida. Graph types for monadic mobile processes. 
In FST/TCS'16, LNCS 1180, pages 371-387. Springer- Verlag, 1996.</RefA> Appendix A Type Reconstruction The type 
reconstruction algorithm PT given below takes a process expression as input and outputs a pair of a type 
environment (extended with expressions like ~J's and C~$s ) and a set of constraints on variables in 
the type environment. Each constraint is of the form either ok(F) or ~ _< F. The obtained pair gives 
a principal typing of the input in the sense that all the possible type environments, under which the 
process expression is well typed, are obtained from the type environment in the pair, by replacing free 
variables in the constraint so that the constraint is satisfied. PT(P) = (F,C): PT(O) = (0, 0) PT(x!t[~I 
 P0) = let (r0,c0) = PT(Po) i. (~'[(~)..]. (. 15.), Co u {~ < r0}) (where a and ors are fresh) PT(x?t[~]. 
Po) = let (Fo,C0) = PT(Po) in (x?t[(~)a,~(9}]. (a~(#)),C0 U (c~ < F0}) (where c~ is fresh) PT(P~ [P2) 
= let (F1,C1) = PT(P1) (F2, C2) = PT(P2) in (rl iF2, Cl U C2) PT(P~ +'.. + P,) = let (F1,Ci) = PT(P1) 
 (F,~, C,) = PT(P,~) in (F1 +"- + F,,,, C1U-.. UC,~) PT(*Po) = let (F0, Co) = PT(Po) in (*Fo, Co) PT( 
(uY~) Po) = let (r0, Co) = PT(Po)  in (rot{~}, Co u {ok(ro.l.{~))}) B Proofs of Theorems B.1 Proof 
of Subject Reduction Theorem (Theo-rem 3.6.1) Lemma B.I.I: (r~s z)Ts2 ----(r~'s2)~'sl = r~'slus2. Proof: 
By induction on the structure of F. [] Lenlma B.1.2 [inversion]: Suppose F ~ P. 1. If P = P1 [ P2, then 
there exist F1 and F2 such that Fi~Pi for i= 1,2 and F < Fi[F2. 2. If P ---- P1 q- "" + Pn, then there 
exist F1,... ,Fn such thatri~Pi fori=l,...,nandP _< Fl+...+rn. 3. If P = x!t [.~]. Po, then there exist 
Fo and I~ such that  r0 t> P0 and r < ~!t[(,~)r.]. (r0 iv,). ?t 4. If P -x. [~]. Po, then there exists 
F0 such that F0c> P0 and r _<~?'[(9)r0+~]. (r0t~). 5. If P = (v~) P0, then there exists r0 such that 
F0 ~, P0 Case: P = (uS0 P1 I P2 Q = (v~) (P1 I P2) and r < F0J'(~} with ok(FJ,(~}). are not free in Pz 
 6. If P = *P0, then there exists F0 such that Fo ~ P0 and r < .r0.  Proof: Immediate from the fact 
that a type derivation of Ft> P must end with an application of the rule corresponding to the form of 
P, followed by zero or more applications of the rule T-SuB. S ~ Lemma B.1.3: If r ~ r', then FT(~} --+ 
P'j'(~} where S' is the least set that satisfies the following conditions: 1. x~tl't2 ~ S implies x i 
tl't2 ¢ S' and {tl,t2} C S~; 2. t ~ S implies t ~ S'; and 3. ytx,t2 ~ S and y ~ {.~} imply ytx,t2 ~ 
St.  Proof: By induction on the derivation of F ~ r' with a case analysis on the last rule used. We 
show only the main base case below; the other cases are easy. Case TER-CoM: r .... + y!t~ [71]. F1 +... 
I ' + v?'~[~2] r~ +... r'=r,[r~ s=(y',,'~} Ti<~2 We have two subcases according to whether y ~ {~} 
or not. We will show the subcase where y = x~; the other subcase is easy.. . SinceFJ'{ }~ .... +ti.Fx~( 
}~ +... [ ...+t2.F2~'(~}+-.., ~t ~s easy to show that rT(~} ('.~:2..~} rll-(~} I r21"(~} finishing the 
subcase. 0 Lemma B.1.4: If WF(r.~s) and WF(rts), then WF(F). Proof: Suppose WF(F) does not hold. Then, 
there exist x, ~-1, T2, tl, t2, F~, F2, and F3 such that r--~* ... +x!t,[~,].r, +... I'-- + =?'=[~=].r2 
+... Ira and T1 ~ T2. By using Lemma B.1.3 repeatedly, either rl"s --¢ .. + =!~'[~1]. (r,ts) +... .. 
+ =?'~[~]. (rats) +... Irsts or r.l.s >" ... + =!" [*1]. (rl.l.s) +... I "'" + =?~[~=]. (r=,l,s) +... 
I r~a,s, contradicting the assumption WF(FJ, s) and wF(rts). [] Lemma B.1.5 [substitution]: If F ~ P, 
then [y/x]F[v/=]P. Proof: By straightforward induction on the derivation of F~P. Lemma B.1.6: If r ~ 
P and P ~. Q, then r ~ Q. Proof: By structural induction on the derivation of P ~ Q with a case analysis 
of the last rule used. We show a few interesting cases below; the other cases are easy. By Lemma B.1.2, 
there exist F1, F~, and r2 such that Fi t> Pi for i E {1,2} and r <_ F~IF2 and r~ < r~j,(~} with ok(F~$(~}). 
By the rule T-PAR, r~ I Fz t> P~ ] P2. Without loss of generality, we can assume ~ are not free in P2 
so that F2T{~} = r2 and Null(r2$(~}). Then, (F1 [F2)~'(~} = Fi~'(~} I F2 and, by the third condition 
in Definition 3.4.3, o~((r~ I r~)4(~). Thus, r~t(~) I r2 ~ (~) (P~ I P~) by the rule T-NEw. Finally, 
it is easy to show F _< F~J'($} I F2, and so, by the rule T-SuB, F ~ Q. Case: P = *Po Q = *PolPo By 
Lemma B.1.2, we have F0 ~ P0 and F < *F0. Then, by the rule T-PAR, F0 ]*F0~P0 ]*P0. Since *F0 < F0 I,F0, 
by using the rule T-SuB, r ~ Q. [] Proof of Theorem 3.6.1: By induction on the deriva- tion of P ~ 
Q with a case analysis on the last rule used. We show only main cases below. Case R-CoM: P .... + x!t[z]. 
P0 +"" I "" + =?~'[.~].Qo +"" Q = PoI[U~9]Qo l = x t,e By Lemma B.1.2 and the subtyping rules, there 
exist F~, F2, and Fa such that r < ... + x!t[(~)r3]. (r~ Ir3) +... I ." + =?~' [(~)r2.~(~]. (r~-(~}) 
r, ~ Po r2 ~ Qo. Then, since WF(r), it mustbe the case that (~)r3 <_ (9)r~$(~, that is, rs < [~/~1r25(~}. 
We can show t,t e r (~--:~ r~ I [s/~]r~ by the following calculation: t t I F {= ' >1 F~ I r~ I r2T(~} 
< rl I [~/.~]r2,t(~} I r2"r(~} = F1 < rl I[U.~]r2 (SuB-DwmE and SuB-SuBsT) By Lemma B.I.S, [~/~9]r2 ~ 
[~/~]qo. Finally, by the rule T-PAR, r, I [~/~lr~ ~ so I [~/~]Oo, finishing the case. Case R-PAR: P = 
P0 I R Po ~ Q0 q = Q01 R By Lemma B.1.2, there exist F1 and F2 such that r _< rl]r2 Fl~P0 F2~R To use 
the induction hypothesis, we show WF(F1) by contradiction. Suppose WF(F1) does not hold. Then, WF(FilF2) 
does not hold, either; it means WF(F) does not hold. Thus, WF(F1). By the induction hypothesis, there 
exists F~ such that rl ~ F~ and r~ ~ Q0. By the rules TER-SKIP, TER- PAR, and TER-SuB, F l#) F~iF2. By 
the rule T-PAR, F~ IF2 ~ Qo I R, finishing the case. By Lemma B.I.1, we have Case R-NEwl: P = (vh~)P0 
Povt'*) Q0 y e (.~} Q = (Y~) Q0 I = ~ t'tl rs.l.~,~,(~,co)(~i~..s-~)(,~+~..,,)(...+u. H.Q+"" IR) By 
Lemma B.1.2, there exists F0 such that F0t>P0 F < PoJ'(~} ok(F0$(~}). To use the induction hypothesis, 
we will show WF(F0). Since WF(r0$(~)and WF(F0J'(~}) from the assumptions, we have WF(F0) by Lemma B.1.4. 
By the induction hypothesis, there exists F~ such that t t ~ F0 {~S-+ } F~ and F~ t> Q0. By Lemma B.1.3, 
F0j'(~} (~) F~y(~} and FoJ,(~) (LL~ } F~$(~}. Then, ok(F~.l.(~}) and, by the rule T-NEw, F~(~) t> (u~) 
Q0, finishing the case. [] B.2 Proof of Theorem 4.1 Lemma B.2.7: Let < be any proper subtyping relation 
and ok be ok~. If F r, P and ok(F), then p~(P) holds. Proof: Suppose that F~ P and ok(F) hold but p~ 
(P) does not hold. By the definition of p~, there exist Q~ and Q2 such that P ~ (~--)(... + ~!~[~].Q1 
+... I '"+~?e[~].Qu+'" IQa) with II~ll ~ II~ll. By Theorem 3.6.3, it must be the case that r~u...+~!t[~].Q~+... 
I ...+x?t'[~].Q~+-- I Qa ok~(ri${~,}) for each i ~ {1,...,k} Fi-1 = FiT(¢&#38; for each i ~ {1,...,k} 
F<Fo F _< F0 and ok~(F) imply ok~(F0). By the typing rules, F~ must be of the form... + x!t [0"]. A~ 
+ ...... [ + x!* [~-']. Ax~ + .. [~xa with [1~'[1 = [1~1[ ¢ [lff~[] = IIT'[[. This con-tradicts with 
the facts okl(Po) and ok~(Fi$(~)) for each e (i,...,~}. Lemma B.2.8: Let < be any proper subtyping relation 
and ok be ok~. If F ~ P and ok(F), then p2(P) holds. []Proof: Similar to the proof of Lemma B.2.7. Lemma 
B.2.9: Let < be the least proper subtyping re- lation, and let ok be oka. If F t~ P and ok(F), then pa(P) 
holds. Proof: The proof proceeds by induction on t. Suppose F t> P, ok(F), and P ----~* P' = (~1..~) 
('" .+y?t[~].Q+... i R). (The case where P ----~* P' = (~1..,~) ("' + y!t[~].Q + .. JR) is similar.) 
Without loss of generality, we can assume that y is free in P'. Otherwise, by Theorem 3.6.3, we have 
r, ~,... + v? ~[~]. Q +... I R Pi-1 = F~?(~ A for i = 1,...,n ok(F~$(¢&#38;) for i = 1,...,n F<F0 y E 
{:~j} for some j and ok(rs$~)). By Theorem 3.6.1 and the definition of ok, there exists such that A ~, 
P' and F ----~* A. By Theorem 3.6.3, there exists T, Fx, and F2 such that A < ...+y?eN.rl+... I r~ .- 
+ y?¢[r].rl +"" Ir2t'u P' Because ok(F) holds, it must be the case that F' ~ F" for some L such that 
(i) L = (x tl't2} or (ii) L = (t') and t" -~ t'. So, by the typing rules, one of the following conditions 
must hold (c.f. Lemma 3.6.5): 1. P' _~ (~4Lm)('" + w?t"[~].Q1 + "" IQ2) with w e (,z,..., ¢,,,}. 2. 
P' ~ (~1..,~) ('" + w! t''[£l.Q1 +'" [Q2) with w e {a~,..., ~-~). 3. p' .~ (~m) ('''+~!~[~]. Q,+'" I 
""+~?~[~]" Q~+  "" I Q~). In the first and second cases, P' ----+ follows by induction hypothesis. In 
the third case, P' ~ follows immediately. [] Lemma B.2.10: Let < be any proper subtyping relation and 
ok be ok4. If F r, P and ok(F), then p4(P) holds. Proof: Suppose that F t> P and ok4(F) hold. Suppose 
---~---~* (~) (... + also that P ----+*~ (ff~)P' and P' /'t x?[~].Q1 + "" I Q2). Without loss of generality 
(c.f. the proof of Lemma B.2.9), we can assume that x is free in P. So, we have p >* > .. . /'~ ~* (~)(~)(. 
+~? tt n [9].Q1 +.. I Q~). ~t ! ,t By Theorem 3.6.1, there exists F' such that F -------+* ) ---+* . 
7 tll - r' andr'~(~)(~)(..+x. [y].Qi+'" IQ2). SyCorol- lary 3.6.4, it must be the case that F' _< --. 
+ x? t'' [r]. F~ + .., Ir !2. This contradicts with the assumption ok4(F). The case for output is similar. 
[] Proof of Theorem 4.1: This follows immediately from Lemmas B.2.7-B.2.10 and Theorem 3.6.2.    
			

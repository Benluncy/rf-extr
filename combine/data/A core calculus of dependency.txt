
 A Core Calculus of Dependency Martin Abadi Anindya Banerjee Nevin Heintze Jon G. Riecke Systems Research 
Center Stevens Institute of Technology Bell Laboratories Bell Laboratories Compaq ab@cs.stevens-tech.edu 
nch@bell-labs.com rieckeabell-labs.com ma@pa.dec.com Abstract Notions of program dependency arise in 
many settings: security, partial evaluation, program slicing, and call-tracking. We argue that there 
is a central notion of dependency common to these set- tings that can be captured within a single calculus, 
the Dependency Core Calculus (DCC), a small extension of Moggi s computational lambda calculus. To establish 
this thesis, we translate typed cal- culi for secure information flow, binding-time analysis, slicing, 
and call-tracking into DCC. The translations help clarify aspects of the source calculi. We also define 
a semantic model for DCC and use it to give simple proofs of noninterference results for each case. 1 
Introduction Systems that incorporate aspects of program dependency arise in many different contexts. 
For example, type systems for secure in- formation flow trace dependencies between outputs and inputs 
of a computation. These type systems are meant to guarantee secrecy and integrity. In the Secure Lambda 
(SLam) Calculus [13] and the while-program languages of Volpano et al. [31, 381, data may be labelled 
as high security or low security , and the type sys- tem ensures that all computations that depend on 
high-security in- puts yield high-security outputs, and conversely, that low-security outputs do not 
depend on high-security inputs. This independence property is often called the noninterference property 
[8, 9, 171 in the security literature: high-security data does not interfere with the calculation of 
low-security outputs. Fragments of the trust cal- culus [27] and JFlow [22,23] also appear to satisfy 
the noninterfer- ence property (although this is not proved). Program analyses such as slicing, call-tracking, 
and binding- time analysis are also based on dependency: the goal of these analy- ses is to compute a 
conservative approximation of the parts of a pro- gram that may contribute to the program s final result 
(and, more generally, its intermediate results). Correctness of these analyses is often expressed using 
properties analogous to noninterference. For instance, in slicing [36, 401, the aim is to determine those 
parts of a program that may contribute to the output; those parts that do not Permission to make digital 
or hard copies ofall or part of this work for personal or classroom use is granted without fee provided 
that copies arc not made or distributed for prolit or commercial advantage and !hat copies bear this 
notice and the full citation on the first page. To copy otherwise. to republish, to post on swvers or 
to redistribute to lists, requires prior specific permission and/or a fee. POPL 99 San Antonio Texas 
USA Copyright ACM 1999 l-581 13-0953/99/01...$5.00 contribute can be replaced by any expression of the 
same type. In call-tracking [33,34], we wish to determine the functions that may be called during evaluation; 
functions that are not called can be re- placed by any function of the same type without affecting the 
final value. In binding-time analysis [5, 251, we wish to separate static from dynamic computations; 
dynamic values can be replaced by any expression of the same type without affecting the static results. 
The similarity between secure information flow and other pro- gram analyses is striking, and raises a 
question: do these analyses share some common substrate? This paper provides one answer by constructing 
a general framework for type-based dependency anal- yses in higher-order programs. The framework is a 
calculus called the Dependency Core Calculus (DCC). We give a denotational se-mantics for DCC that formalizes 
the notion of noninterference. We then show how to translate a variety of calculi for security, slicing, 
binding-time analysis, and call-tracking into DCC in such a way that the noninterference results for 
the respective calculi are imme- diate corollaries of the generic results for DCC. There are three advantages 
to this foundational approach. First, DCC gives us a way to compare dependency analyses. This idea relates 
back to Strachey s conception of denotational semantics as a tool for comparing languages [32]. Second, 
the translations themselves yield a check on type systems for dependency analysis. They help confirm 
some seemingly ad hoc decisions in some cal- culi and have uncovered some problems and incompletenesses 
in others. Third, general results about DCC yield simple noninterfer- ence proofs for the individual 
dependency analyses. DCC is a simple extension of Moggi s computational lambda calculus [20]. Typically 
the computational lambda calculus has a single type constructor that is semantically associated with 
a monad. In DCC, this notion is extended to incorporate multiple monads, one for every level of a predetermined 
information lattice. The use of the computational lambda calculus in describing dependency is somewhat 
surprising. Usually, the computational lambda calculus describes languages with side effects [20], or 
forms the basis of adding side effects like I/O to pure functional languages [15]. Dependency analyses, 
in contrast, do not funda- mentally change the values being computed. Nevertheless, there is one common 
idea underlying both uses of the computational lambda calculus. In the case of Haskell, there is no way 
to com- pute a value using the I/O type constructor and pass that value to an expression of non-I/O type. 
Similarly, in information-flow systems, the test of a high-security boolean in an if-then-else requires 
that the branches of the conditional return high-security values. In both cases, the type rules of the 
computational lambda calculus enforce the necessary restriction. The rest of the paper describes DCC, 
a semantic model of DCC, and six translations from type-based dependency analyses into DCC. Certain aspects 
of dependency analysis cannot be mod- elled in DCC; we discuss this further in the concluding discussion. 
2 Commonality among Dependency Analyses Before presenting the syntax and semantics of the core language 
DCC, we give two examples of dependency analyses: the SLam calculus and a slicing calculus. 2.1 Why the 
SLam Calculus is a Dependency Analysis The SLam calculus [ 131 is a typed lambda calculus extended with 
security annotations for access control and information flow. To simplify the setting, we consider only 
the functional facet of the calculus with information flow, which corresponds to a fragment of the trust 
calculus of @rbzk and Palsberg [27]. A types is a pair consisting of a structural part, f, and a security 
annotation, K,denoting information flow and ranging over elements in a security lattice L, with least 
element L and greatest element H. For example, the type (bool,L) denotes low-security booleans; similarly, 
(bool, H) denotes high-security booleans. The type ((bool,H) -+ (bool,L),L) denotes a low-security function 
that accepts a high-security integer and returns a low-security result. The terms and type rules of the 
language are given in Section 4.1. A simple example of a well-typed SLam term of type ((bool, H) -+ (bool,L),L) 
is the constant function (hx: (bool,H). trueL)L. Note that all constructors in SLam are labelled with 
security anno-tations. Since low-security computations should not depend on high-security data, the evaluation 
of an expression such as if trueH then trueL else falseL must not produce the low-security boolean trueL, 
since otherwise information about the high-security boolean is leaked to the low- security world. The 
remedy is simple: whenever a constructor is destructed, we make the security annotation of the constructor 
flow to the an-notation of the result. Specifically, the annotation of the result is the least upper 
bound of its original annotation and that of the construc- tor. This propagation of annotations is captured 
by the following dependency-calculus principle: At every elimination rule, properties (e.g., security 
level, binding-time information, dependency annotation) of the destructed constructor are transferred 
to the result type of the expression. This principle is fundamental to the design of the dependency 
cal-culus and to the rest of the paper. In the example, then, the result of if trueH then trueL else 
falser. is the high-security boolean, trueg. The noninterference property is vacuously sat-isfied, since 
the result is a high-security boolean. More generally, if in the context (X : (t, H)) expression e has 
type (bool,L), then noninterference says that e must not depend on the high-security variable x, and 
hence must be constant with respect to X. 2.2 Why the Slicing Calculus is a Dependency Analysis In program 
slicing [36, 401, we seek the dependencies of a program--&#38;z, those subterms of the program that may 
contribute to its output. For example, the slice of the application ((hr. 3) 2) should contain only the 
function hr. 3 and the constant 3, since the argument 2 does not contribute to the final result. To identify 
such subterms, we follow Abadi ef al. [2] and use a labelled lambda calculus. We give a conservative 
approximation of the labelled op-erational semantics using a type system, whereas previous work by Biswas 
[3] employs set-based analysis. The type system for slicing is similar to that of the SLam cal-culus. 
A type s is a pair consisting of a structural part, t, and a set of labels, K,denoting slicing information. 
Note that the powerset of labels forms a complete lattice with empty set as least element and the set 
of all labels as greatest element. We give the complete type system in Section 4.2. A typing judgement 
r k e : (t, K) means that, under the assumptions r, the expression e has type t and possi- ble dependency 
K. For instance, consider the example from above, where the constructors are all labelled: It is easy 
to see that the type of the function part of the applica- tion is ((int,{nz}) -+ (int,{nl}),{nu}), so 
that the type of the whole term is (int,{nu,nt}). Thus the result of evaluating the term cannot depend 
on 12. Noninterference also holds in the slicing calculus: if under the assumption (x : (t, Kl)),the 
expression e has type (int, Kz),where K1 g K2 in the powerset lattice, then e must not depend on x. 3 
Dependency Core Calculus DCC is a minor extension of Moggi s computational lambda cal-culus [20]. Three 
features distinguish it from the computational lambda calculus. First, the calculus contains sum types 
and lifted types, as well as term recursion. Lifting allows us to model call-by-value calculi. Second, 
instead of having one type constructor T semantically associated with a monad, the calculus incorporates 
multiple type constructors Te, one for every element fJ E L of a pre- determined lattice L. This idea 
was also considered by Wadler [39]. The lattice represents different grades of information. In the secu-rity 
setting, the least element usually stands for low security. Type constructors q change the level of a 
type. For instance TH(boo1) describes high-security booleans. Third, the monad bind opera-tion has a 
special typing rule that is explained later. 3.1 Syntax The types of DCC are given by the grammar: where 
C ranges over elements of a predetermined lattice L. The lift- ing operation on types, denoted so in 
the syntax of types, induces a subset of types called the pointed types: . sI is a pointed type; . ifs 
and t are pointed types, then (s x t) and Te(s) are pointed types; and . if t is a pointed type, then 
(s + t) is a pointed type. For a recent account of pointed types, see the paper by Howard 1141 or Mitchell 
s text [181. Similarly, the Te operation on types induces a subset of types called the types protected 
at level C: Table 1: Typing Rules for DCC. Wk r,x:.~,r~-x:.~ [Unit] [Lam1 l-,x : s, t e : S2 rt (hr: 
~.e) : (s, + .v) [APPI [Puir] TIeI :s, r t e2 : ~1 r t (el,e2) : (.v x ~2) PM1 PWI r t e : si r t (injje) 
: (~1 +SZ) [Case] [UnitM] Tte:s r t (9~ e) : W4 [BindM] rte:.v [WI rt(lifte):.yi [se4 [Ret] T,f :.vt-e:s 
r t (p,f : S. e) : s s is pointed . If e E L? , then Tel (s) is protected at level l?; . if s and t 
are protected at level C, then (S x t) and Tel(t) are protected at level e; and . if t is protected at 
level 1, then (S t t) are protected at level e. The typing rules for DCC appear in Table 1. In all of 
the typing judgements in this paper, a typing environment r denotes a list of distinct variables with 
types. The rules for unit, function, product, and sum types are all standard, as is the rule for the 
monadic unit operation. The rule for monadic bind is nonstandard, using the concept of protected at level 
P for the body; usually, the body must have type G(x ) for some 3 . The model of the next section gives 
some justification for this rule. Finally, the rules [Lift] and [Seq] are just special cases of the monadic 
unit and bind operations for lifted types, and recursion is permitted only over pointed types. The operational 
semantics for DCC is a call-by-name seman-tics. In particular, the term (qe e) reduces to e, and (bind 
x = e in e ) reduces to e [e/x], where e[e /x] denotes the capture-free substitution of e for x in e. 
The rest of the operational semantics is standard and hence omitted. 3.2 Semantics The model of DCC draws 
on ideas from other noninterference proofs [ 13, 191 which use Reynolds s concept of parametricity [28]. 
The method is easiest to explain with an example with high-and low-security booleans. A high-security 
computation can depend on a high-security input, but a low-security computation cannot. Our model explains 
the difference using views of the high-security booleans, where each view is captured by a binary relation 
and where computations must respect the relations. In this simple ex-ample, the high-security view is 
the diagonal relation (i.e., x and y are related iff x = y), so that high-security computations can dis-tinguish 
between the booleans. The low-security view, in contrast, is the everywhere true relation--that is, x 
is related to y for all x and y. Low-security computations can therefore not take advantage of the distinctions 
between the high-security booleans. Sabelfeld and Sands develop these ideas in a recent manuscript [30]; 
similar constructions appear in Nielson s work on strictness analysis [24]. rt():unit rte:(s, +.Q) rtd:.vl 
r t (e d) : .y2 rte:(s, xs2) r t (pro ji e) : sj r t- e : (s, +.y2) r,x : .yi t ej : s rt (case e of 
inj ,(x). el ) injz(x). e2) : s rt-e:T&#38;) r,x:ste :r t is protected at level I rtbindx=eine :t rte:sl 
r,x:ste :t t is pointed rtseqx=eine :t We formalize these ideas via a category. Recall that a complete 
partial order (cpo) is a poset that contains least upper bounds for ev- ery directed subset; a cpo may 
or may not have a least element [ 181. Recall also that a directed-complete relation is a relation that 
pre- serves least upper bounds of directed sets. Define the category 8C (for dependency category) to 
be the category with . OBJECTS An object A is a cpo IAl and a family of directed- complete relations 
RA,e on A for every C E L. . MORPHISMS A morphism f :A + B is a continuous function such that for any 
(x,~) E R&#38;e, (f(x),f(u)) E R&#38;e. We use Hom(A, B) to denote the set of morphisms from A to B. 
The condition on morphisms is crucial. Consider, for instance, the lattice with two points L 5 H, let 
B = {true, false} with the trivial ordering, and define the objects boolH = (B, RL,RH) boolL = (B,R;,RL) 
where RL,RH,R~,RL are relations on B. The relation RL corre-sponds to a low-security viewer of a high-security 
boolean; such a viewer cannot distinguish between the booleans. Hence we choose RL to be the everywhere 
true relation, i? x B. The rela-tion RH, in contrast, corresponds to a high-security viewer of a high-security 
boolean; such a viewer can distinguish between the booleans. Hence we choose RH to be the diagonal relation 
on B. In a similar manner, we can choose both Ri and Rk to be the di- agonal relation on B. Now, if f 
: boolH + book5 is a morphism, it must send arguments related by RL to results related by RL. Since RL 
is the everywhere true relation, for any x,y E B, the pair (x,y) is in RL. Thus, (f(x),f(y)) E R ,. In 
other words, f(x) = f(y) for all x,y E B. Therefore, a function mapping high-security booleans to low-security 
booleans must be a constant function. However, a relation need not be either the diagonal relation or 
the everywhere true relation. The key property we need of BC is that it is a model of DCC (and therefore 
of the typed lambda calculus with products and CO- products). To establish this, we adapt standard results 
from cat-egorical semantics [16] to show that 2X is Cartesian closed, has coproducts, and has a monad 
for each e E L. (These results are necessary to justify the constructions in this paper; however, the 
reader unfamiliar with category theory can safely skip them.) More concretely, if A, B, C, D are objects 
and f :A + B, g : C + D: . The unit object unit is defined by the poset {T} and the iden- tity relations. 
. Coproducts are given by ]A+B] = ]A]+]R] RA+B,~ = {(ida,idb) 1 (a,b) 6 RA,~}U {(inrqinrb) 1 (a,b) 
ERBJ} inZ(f(y)) if x = inl(y) (f+g)(x) = inr(g(y)) if x = k(y) . Products are given by IA xBI = IAl x 
\BI RAxB,e = {(klb)i@,b )) I (a,~ ) E h,e, c&#38;b ) E RB,~) (f x d(X,Y) = (f(47dY)) . Exponentiation 
is given by l;A;fj = ~4lAl~I~I) = {(f,s) I v(a,a ) E h,e, (f(a),f(a )) E he) (f* i)(h : ffMf4C))(x: A) 
= dh(fb))) . Lifting is given by IAd = {@ >a) I a E IAIIU{(l,~) RAd = {((0,x), (0,~)) I for all (x,Y) 
E h,e)u ) = where ((0,~) ( a E [AI} is ordered as in IAl, and (1,1) is or- dered below all other elements. 
. The monads are given by IMA)I = IPI ifeEl RA,e~Rfi(A),el = IAl x IAl otherwise Q(f:A+B) = f We also 
define the maps r(e[A] : A --t c(A) and pl[A] : WMA)) -+ WA) rle[Al(x) = x ve[Al(x) = .X That is, both 
maps are based on the identity function. How-ever, these morphisms are not the identities in the category, 
since they do not have the same domain and codomain. The first four of these definitions are not surprising; 
Mitchell s text [ 181 gives a history of these definitions. This structure gives us all the machinery 
needed to interpret the types and terms of DCC. We use [[sl] for the meaning of a type s in the category, 
and 1x1 : ~1,. . . ,x,, : sn t- e : s] : [[sl x . x s,,D -+ [[sl for the meaning of a typing judgement. 
We omit the definitions of the meanings of terms since they are standard. Using induction on the definition 
of pointed , we can show that: Proposition 3.1 Ifs is pointed, then 1 I[f] I has a least element. Hence 
recursion can be interpreted via least-fixed points. The monads Te give a way to change the level of 
a type, e.g., as in TH(boolL) = boolH. The operator Te changes the relations not above e to the everywhere 
true relation. More generally, when a type is protected at level e, views of that type at a level e p 
e are the everywhere true relation. Proposition 3.2 lft is a type protected at level e, and e p I, then 
R~t~,e~ = lU4ll x IDllI. 4 Applications I: A Strong Version of Noninterference In languages with recursion 
and some notion of dependency, there are often two ways to state the notion of noninterference. The first 
says that if a program terminates with an input and produces a re- sult, then changing the input to a 
related input still causes the program to terminate and the result is related to the original result. 
This is a strong notion of noninterference. Some calculi, however, do not satisfy the strong property 
but do satisfy a weaker property: if two related inputs cause the program to terminate, the outputs are 
related. Under this property, related inputs may yield different convergence behavior. In this section 
we study calculi with the strong version of nonin- terference. These include calculi based on call-by-name 
semantics, and they turn out to be easier to translate into DCC. In the next section, we study calculi 
that satisfy the weaker version of nonin- terference. 4.1 Call-by-name Functional SLam Calculus Our 
first source calculus is the call-by-name, purely functional ver-sion of the SLam calculus; this calculus 
is essentially the trust cal-culus of @rbrek and Palsberg [27] without the coercion from high to low 
security. Let L denote a join semilattice of security levels and let K range over the levels of _L. The 
types are .._ t ..-unit I (s+s) I (sxs) I(s-+s) .._ s ..- (t,K) and the typing rules appear in Table 
2. In the typing rules, the operation (t,K)*d = (t,KUd) is used to increase the security level of a 
type. The symbol 5 de-notes the subtyping relation. The restriction of recursion to func- tion types 
is not essential in a call-by-name context; the restriction here merely allows us to use the same type 
system for a call-by- value version below. The operational semantics of this calculus deviates from the 
original operational semantics of the SLam calculus [ 131 in that arguments are passed by name rather 
than by value. Evaluation contexts are defined in the style of Felleisen [lo] by the grammar E ::= [.]](Ee) 
I (projiE)](caseEof injt(x).et I injz(x).ez) and the local operational rules are ((J~:s.e)~e ) -+ e[e 
/x] (Proji(el,e2),) -+ G, i= 1,2 W : s. e) -+ 4bf : s. e)lfl (protect,e) -+ e (case(injie)Kof injt(x).el 
I inj2(x).e2)-+ei[e/X]i=1,2  Table 2: Typing Rules for the Functional SLam Calculus. 1-,x:s,rtx:s r 
t e : s s 5 s l- t- e : s l-,x : s, t e : s2 [Lam1 rt(hw:S,.e),:(s, +S~,K) r-t-e] :S, r F e2 : s2 [Pair] 
rk (~~4~: h xs2,4 r F e: Si r-l-(injie),:(Sl+Ss,K) [Protect] [SubUnit] [Uflit] kc] KJPI [Proj] [Case] 
[SubTrans] [Sub&#38;m] [Sub&#38;n] rk ()K:(unit,K) r,f:SFe:s sis a function type r I- (p.f : S. e) : 
s rke:(sl +S2,K) r+e':Sl rl-(ee'):s2*~ rEe:(S, x.72,~) rk(projje):q*K rt-e:(SI+S2,K) r,X:Sjkei:S rF(caseeofinjI(X).eI 
1inj2(x).e2):s*K We write e .lJ v when e rewrites to v and v cannot be rewritten. The translation of 
the SLam calculus into DCC is straightfor- ward. Types are translated into DCC by the following recursive 
definition, where t maps from types t (without a security level) into DCC types, and * maps from types 
s (with a security level) into DCC types. unit+ = unit1 (Sl +Q)+ = (s;+s;)J_ (St x sz)+ = (xi x s;) (q 
--f sz)+ = (s;t --k s;) (t,K)* = &#38;(t+) A SLam typing derivation of I- I- e : s is translated to 
a valid DCC derivation of r* I- e* : S* by the rules in Table 7. It is easy to check that every SLam 
typing derivation yields a DCC typing derivation by the translation. We can also prove the following 
correctness properties of the translation: Theorem 4.1 (Adequacy) Ij according to Table 7, 0k.e: (unit,K) 
*0ke*: (unit,@* then e u v ifS[e*jj # 1. Theorem 4.2 (Noninterference) Let K1 and K2 be any two ele-ments 
of L. Suppose KI g K2 and x: (t,Kl) t-e: ((unit,K2)+(unit,Kz),K2) is derivable in the SL.am type system. 
Then (e[e /x]) u v ifs (e[e /4) U v. Proof: The proof follows directly from the structure of !DC. We 
sketch the argument for the case where L = {L,H} . Suppose x: (t,H) t-e: ((unit,L)+(unit,L),L) is derivable 
in the SLam type system. Applying the typing rule 1-1, 01- (lx: (t,H).e)L: ((t,H) t ((unit,L)+(unit,L),L),L) 
Now, translating to DCC, we have 0l-(hx: (t,H).e)L:TL(TH(t+)dTL((TL(unitl)+TL(unitl))l)) Let f = [( hr 
: (t,H) . e)tl. Since L is the least element of L, f E [[TH(~+) + (unit1 +unitl)ll Let D = ITH( and E 
= [( unitl+unitl)l]. By the I)C condition on morphisms, for all 1 E .G and for all x,y E D, ~RD,I Y implies 
(fx) RE,I WY). In the case 1 is L, RQL is the everywhere true relation, and RE,L is the diagonal relation. 
Hence, for all x,y E D, (f x) = (f y).Thus, [(e[e /x])*I] = U((hx: (r,H).e)L e )*ll = [((hx: (t,H).e)L 
e )*n = U&#38;+ /4*ll and so by adequacy, (e[e /x]) J.l v iff (e[e /x]) .lJ v. . This noninterference 
theorem is stated over one specific type only for readability; it extends to types not involving function 
types. 4.2 Slicing Calculus The slicing calculus, introduced in Section 2, attempts to calculate which 
portions of a program may contribute to the final answer, and which definitely do not. To study slicing, 
we formulate a type- based slicing analysis. The types of the language are exactly the same as in the 
SLam calculus, except that K ranges over sets of labels. The typing rules appear in Table 3. These rules 
resemble the SLam calculus rules, although the rules for value constructors are different. Types are 
translated into DCC exactly as in the call-by-name, functional SLam calculus, and a typing judgement 
r E e : s istrans-lated to a judgement of the form r* k e* : s* by the rules in Ta- ble 8. The correctness 
properties are also the same as for the call- by-name, functional SLam calculus. Table 3: Typing Rules 
for the Slicing Calculus (where subtyping is analogous to subtyping in the SLam calculus). r,x:.~,r~x:s 
Wrl I-i-e:s sls WI r t- e : .d r,x : S, t-e : .v2 km1 r~((hx:.~,.e),:(s,-tS2,{n}) TFel :SI rkel:.yp 
[Puir] rk (el,e2h : (SI X~2,{n)) rke:si Pjl rk (injje), : (~1 +.v,{n}) [Unit] rk On : (unit,(n)) 1-,f 
:st-e:s [Ret] s is a function type rI-(Pf:s.e):.v rt-ee:(.yI+S2,K) rke :.T, PPPI r t- (e e ) : ~2 0 K 
rt-e: (S1XS2,K)  [Proj] I- !-(projje) :si*K Ti-e:(.7,+.72,K) T,x:sit-e;:s [Case] rt-(caseeof inj,(x).el 
1inj2(x).e2):soK Table 4: Typing Rules for the Binding-time Calculus. [VW PubI 1~6 [Pair] [hl r,x:s,r 
t~:.y rt-e:(unit,sta) r 1 e : (unit,dyn) r,x : .q I- e : s2 rI-(hr:.~l.e)p:(.~l~.~2,P) l-t-eel :SI r 
t e2 : .72 rk (el,ez)p : (.u X.v2,P) rFe:.yj rk (inj;e)p: (SI +.yz,P) [Unit] Fe4 LAPPI [Projl [Case] 
r I- ()p : (unit,P) r,f:.yt-e:.7 r I- (uf : S. e) : s sis a function type Tke:(q +s~,P) rke :s[ rt-(ee 
):.v2 rke:(s, xsz,p) rt-(proj;e):s; rl-e : (s, +s2,p) r,x: .yit- ei : s rt-(caseeof injI(x).el 1 inj2(x).ez):s*P 
 4.3 Binding-Time Calculus The goal of binding-time analysis is to annotate a program with binding times 
and specialization directives [ 121. The binding times specify when data is available. For instance, 
if there are only two binding times, static and dynamic, then static denotes known at specialization-time 
and dynamic denotes known at run-time . Binding times are used to specify specialization directives: 
if an expression has static binding time, then it is eliminable, i.e., can be reduced at compile time. 
If an expression has dynamic binding time, then it is residual, i.e., it cannot be reduced at compile 
time. Hatcliff and Danvy define one binding-time type system, fo-cused on the computational lambda calculus 
[ 121. Under their sys-tem, if in a dynamic context l-d an expression e of type int is mapped by the 
analysis to an annotated term w with annotation sta (for static), then w and e must be identical and 
must be equiv- alent to some integer constant it [ 12, Lemma 21. This property is exactly noninterference: 
static data cannot rely on dynamic data. Implicit in the Hatcliff-Danvy type system is a restriction 
on the structure of types. This restriction can be made ex-plicit by defining a notion of well-formedness 
of types [26, 351. For example, if dyn denotes dynamic binding-time with sta 5 dyn, the types ((int,sta) 
--f (int,sta),dyn) and ((int,sta) x (int,sta),dyn) are ill-formed, whereas ((int,dyn) + (int,dyn),sta) 
is well-formed. Using DCC,we can give a more generic account of this system. Specifically, we can show 
that the noninterference property is independent of the notion of well-formedness employed. The specific 
notion of well- formedness is motivated by engineering constraints varying from specializer to specializer. 
In summary, binding-time analysis can be viewed as a dependency calculus (a la DCC) in conjunction with 
a notion of well-formed types. The dependency captures a generic notion of whether or not a computation 
depends on dynamic inputs, and the well-formedness condition captures constraints imposed by the specializer. 
We formalize these ideas in a source language similar to SLam, where the types are annotated with binding 
times s ta 2 dyn. Types in the binding-time calculus are therefore t ::= unit~(s+s)~(~xs)~(s-+s) S ::= 
(t,P) p ::= staldyn The well-formed types [35] are a subset of the types defined as follows: . (unit,P) 
and (~1 +s2,p) are well-formed. . ((tl , PI) OP (h Pd, PI is well-formed iff (tl, I%) and (t2, P2) are 
well-formed and p < pi, where op = x , +. The typing rules are given in Figure 4. The judgement I- k 
e : s means that under assumptions I-, expression e has the well-formed type s. Note that the well-formedness 
restriction on types obviates the need for . in the elimination rules App and Proj, since (t, p) . p 
= (t,P) when p 5 p. The binding-time calculus can be translated into DCC. Types are translated into DCC 
in the same way as in the call-by-name, functional SLam calculus. A typing judgement I-k e : s is translated 
Table 5: Typing Rules for the Smith-Volpano Calculus over Booleans. rH;rLtskip:Tcmd r,;r,te:z xErr rH;rLt(x:= 
e):zcmd rH;rLte:T rH;rLtci:rcmd rH;rLtifethenclelsec2:zcmd to a judgement of the form I-* k e* : S* 
by the rules in Table 9. The correctness properties are the same as for the call-by-name, functional 
SLam calculus. 4.4 Smith-Volpano Calculus The Smith-Volpano calculus [31] is a simple language of while- 
programs, modified so that the types keep track of the security levels of variables and commands. Just 
as in the SLam calculus, the type system prevents high-security inputs from influencing low-security 
outputs. The translation of the Smith-Volpano calculus to DCC, however, looks very different from translations 
of SLam, the slicing calculus, and the binding-time calculus. Part of this differ- ence arises from the 
difference between imperative and functional languages, On a deeper level, some of the subtleties of 
pointed types in DCC are useful in the translation. Types in the Smith-Volpano calculus are divided into 
data types z and phrase types p: r ::= LIH p ::= z(zcmd When L or H is used in a phrase type, it is the 
type of storage cells that hold values of type L or H. The subtyping relation, used in the typing rules, 
is based on the primitive relations L 2 H and H cmd 5 L cmd. The typing rules for the calculus appear 
in Table 5. In order to keep the translation to DCC simple, we modify the original type rules [31] in 
two ways. First, variables have types L or H; variables of command type, possible in the original Smith-Volpano 
calculus, appear to have no use. Typing contexts are consequently split into two parts, r~ and r~, containing 
the sets of high and low variables respectively; the type contexts are just lists of variables because 
of this split. Second, the implicit data type is boolean instead of in- teger. In other words, L is the 
type of low-security booleans and H is the type of high-security booleans. We make this simplifica- tion 
only for expository purposes, because there is no direct way of encoding the integer type in DCC. To 
extend the encoding to the original calculus, we could either directly add an integer type to DCC, whose 
semantic domain would be the flat integers, or add recursive types to DCC so that one could represent 
the integers as a type expression. Both changes would complicate DCC, and essen-tially no new difficulties 
arise with integers. The operational semantics of the language uses a state, i.e., a map B from variables 
to {true, false}. There are two forms of judgement in the operational semantics. A judgement of the form 
(c,o) --t cr , where c is a command, denotes a computation that [Cm?] i- ,q;TLl-k:r k=trueorfalse rH;rLte:7cmd 
rH;rLte':rcmd [Se4 rH;rLt(e;e'):rcmd rw;rLbe:L rn;rLtC:LCmd [While] rH;rLtwhileedoc:Lcmd terminates 
in state d. A judgement of the form (c,o) -+ (c ,~ ) denotes a computation that has not halted yet; the 
command to be run next is c . The following rules define the operational semantics: (skip,o) -+ (T (ecr) 
= v (ec) = false (x:=e,0)-_,cr[x++v] (whileedoc,(3)td (Cl,@ -+ (C;r@ (Cl,(J)-+o ((ClX2),4 + ((4X2)7~') 
((ClX2),(J) -+ (c27(3') (eo)=false (ifethenq elsec2,6)t(c2,0) (e 0) = true (if e thenct elsec2,(3) 
--t (ct,G) (e 0) = true (whileedoc,o)-+((c;whileedoc),(T) We use +* for the reflexive, transitive closure 
of -+. Two observations about the calculus are in order. First, phrases of type (H cmd)never modify variables 
of type L. Thus, a phrase of type (H cmd) is a function from a state to the portion of the state representing 
high variables. Low commands, in contrast, can mod-ify high and low variables. Second, while loops may 
include only low expressions and low commands. Without this restriction, the type system does not satisfy 
the strong noninterference property. Indeed, concurrency can be used to leak information [31]. From the 
restriction on while loops, it follows that only low commands may diverge. The translation of the Smith-Volpano 
calculus into DCC de-pends on these two observations. We define the type boo1 to be the DCC type (unit 
+ uni t), and let  SV(L) = boo1 S (H) = TH(bool) WZl , . . At) = y(T) x , x SV(z! sv(rH,rL,q = svH(rH) 
xsvL(rL)+ b00l sv(rH,rL,H) = svH(rH)x svL(rL) + TH(bOOi) sv(rH,rL,Hcmd) = SvH(rH) x svL(rL) -+ svH(rH) 
sv(rH,rL,Lcmd) = svH(rH)x svL(rL) -+ (wrd x svL(rLh The translations of judgements are closed expressions 
in DCC, with the form rH;rLbe:p+e* :sv(r,,r,,p) where e ranges over expressions and commands, and e 
denotes the result of the translation of e. The complete translation is given in Table 10. For example, 
suppose the last rule used in the typing derivation is [a. The judgement r~; rt I- if e then cl else 
c2 : L cmd is translated as ho. if (e* O) then (CT CT) else (cz (T) where if e then er else e2 is shorthand 
for (case e of inj 1 (x). el 1injz(x). e2) for a fresh variable x. In contrast, the judgement r~;r~ k 
if e then cl else c2 : H cmd is translated to ho. bind v = (e* CI) in if v then (CT 0) else (cz (3) 
Notice the use of the bind in the last rule-the value of the expres- sion e is a high-security boolean, 
and hence must be decomposed. Since both arms of the conditional are protected at level H, this part 
of the translation is well typed. Suppose rL is a set of variables; define (T wt-, B if for all x E 
rL, (T(X) = G (X). We can prove the following theorems from the translation: Theorem 4.3 (Adequacy) Suppose 
(xl,. . . ,x,,); (~1,. . . ,yk) k c : L cmd. Then (c, 0) +* 0 ifs uc*n 2 uGJl)7(u~(YI)ll~~~~    (ob(xl)ll7~~~ 
>U~(Yk)ll))# -L Theorem 4.4 (Noninterference) Suppose TH; rL F c : L cmd is derivable in the Smith-Volpano 
calculus, and o -r, 0 . lf(c, O) -+* 00. then (c, 0 ) +* oh and 00 -r, oh. Dually, if(c,(T ) -+* do, 
then (C,(T) +* CJOand 00 -r, oh. The proof of the noninterference theorem uses the semantic model of 
DCC, whereas the original operational proof uses a more de- tailed operational analysis [31]. Applications 
II: A Weaker Version of Noninterference Not all calculi that track dependency satisfy the strong version 
of noninterference. For example, the original functional SLam calcu- lus uses a call-by-value semantics 
rather than a call-by-name se-mantics. In this calculus, high-security inputs may affect the ter- mination 
behavior-but not the outputs-of a low-security compu- tation. An earlier version of the Smith-Volpano 
calculus, due to Volpano, Smith, and Irvine [38], also satisfies this weaker notion of noninterference; 
the strong version of noninterference seems to require the restriction of while-loops to low commands. 
Unfortunately, it seems difficult to use DCC directly to model these languages. We must alter the syntax 
and semantics of DCC slightly. The main problem lies in the semantics of lifting. Con-sider, for instance, 
the meaning of the DCC type TH(boo1) _$ booll where boo1 = (unit + unit) as before and L 2 H. A function 
of this type must either map all elements to _L or all elements to a constant element of type bool, in 
essence obeying the strong version of noninterference. For the weaker version, we want the relation at 
boo11 to relate I to any element of bool, not just to I; the relation on non-l elements should continue 
to be the diagonal relation. To model the weaker notion, we use the same underlying cat-egory, and change 
the semantics of the lifting operator to have the relations RAI,L=RA,~U{(I,I)}~{(X,I),(I,X) IxE IAt3 
and change the definition of protected to include the clause . If t is protected at level C, then tl 
is protected at level e. We call the new language vDCC, since it is tuned to call-by-value (even though 
the operational semantics is still call-by-name). The meaning of fi(tl) is now isomorphic to (c(t))l, 
via the terms f = hr:fi(tl).bindy=xinseqz=yin(lift (rtez)) g = hx:(4(t))l.seqy=xinbindz=yin(~(liftz)) 
The terms are well typed because of the change in the definition of protected. We now describe two calculi 
satisfying the weak version of noninterference and translations of them into vDCC. 5.1 Call-by-value 
Functional SLam Calculus The first application of vDCC is the call-by-value version of the functional 
SLam calculus in Section 4.1. The syntax and type- checking rules of the language are exactly the same 
as in the call- by-name setting, except that we require in recursion (&#38; : s. e) that s has the form 
(st + ~2, K) where q = s2 . K. The main change is in the operational semantics, where the evaluation 
contexts become V ::= () 1 (l2:s.e) 1(injiv) 1 (V,V) E ::= [.I I (E 4 I (vE) I (inji E) I (ET4 I by,@ 
I (proji E) I (caseE of injI(x). e I inj2(x). e )  and rewrite rules become ((hr : s. e)K v) + +/4 (proj 
i (~1, ~2)~) + Vi (protect,v) -+ v (case(injiv)rof inj*(x).el 1inj2(x).e2) -+ei[v/x] (pf : s. e) -+ 
e[(hr : s1. (pj : s. e) ,~)~/f] s = (s, -+ S2,K)  Types are translated into vDCC as follows: unit+ = 
unit (Sl +s2)+ = (s;+s;) (q x s2)+ = (ST x.71) (s1 -_) s2) + = (sf -($)l) (t,K)* = &#38;(t+) Unlike in 
the call-by-name case, not every type is translated to a pointed type; function types, though, are guaranteed 
to be pointed. A typing judgement r b e : s is translated to a judgement of the form r* k e* : (s*)l 
by the rules in Table 11. Theorem 5.1 (Adequacy) lj according to Table 11, 8t_e:(unit,K)=S@)_e*:(unit,K)* 
 then e 4 v ifs [e*jj # 1. Theorem 5.2 (Noninterference) Let K1 and K2 be any two ele- ments of L. Suppose 
K1 g K2 and x: (t,Kl) be: ((unit,K2)+(unit,K2),K2)  is derivable in the SLum type system. Then (e[e 
/x]) Jj v ifs (+ /xl) U v. Table 6: Typing Rules for the Call-tracking Calculus. W-1 l-,x : s,r i-n 
: s,L [Chit] rt-c?:Sl,K SI 5 S2 WI Wcl KEICI rl-e:S2,d r,x:Sl te:S2,K @ml L@Jl rk(hw:S,.e) n :(S,{kF2). 
>L rkf?] :SI,K~ rte2 ~~2~1~2 [Puir] [ Proj] rf- (el,e2): ($1xS2),K1 UK2 rke:S;,K [@I [Case] rt-(injje):(sl+s2),K 
5.2 Call-tracking Calculus Typesin the call-tracking calculus [33, 341 are given by the gram- mar s::=unit 
1 (s+s) 1 (sxs) 1 (s--%s). where K ranges over sets of labels. (These labels occur only on lambdas.) 
The typing rules appear in Table 6. A term is assigned with a type and an effect (a set of labels of 
lambdas that may be called). We use L to denote the least element of the lattice of sets of labels. The 
subtyping rule for function types is The other subtyping rules are obvious and omitted. Qpes are translated 
into vDCC as follows: unit+ = unit (Sl +s2)* = (S;+S;) (Sl x4* = (ST x $1 (SI +S2)* = (ST -+ (TK(S;))l) 
A typing judgement P + e : s, K is translated to a judgement of the form I-* I- e : (TK(s*))l by the 
rules in Table 12.  Theorem 5.3 (Adequacy) M according to Table 12, 0 I- e : unit,K=% 0 k e* : (T,(unit))l 
fhen e J.l v ifl[[e*l] # 1.  Theorem 5.4 (Noninterference) Let K be an element of L, and n $! K. SuppOSe 
st-e[(hx:s.e ),/f] :unit+unit,K 8 b e[(hr:s.e"),/f: unit+unit,K are derivable in the call-tracking type 
system. Then (e[(hx : s. 4,/f]) U v $f(e[(hx : s. e Mf) U v. This theorem formalizes the intuition expression 
e does not call- ing function f as the property function f can be replace by an arbitrary function (of 
appropriate type) without changing the result of evaluating of e . r/-O: unit,l r,f:St-e:S,K S= (S, --% 
S2) ri-(p,!f:S,e):S,K rl-e:(.q --%S~),K, rFe':s],~~ rk(ee'):S2,KuKIuK2 r!-e:(.u XS~),K l-l-(projie):si,K 
 rFe:(.q+s2),~ r,x:Sikei:S,d rt-(caseeofinj~(x).el Iinj2(x).e2):S,KUd 6 Discussion We have shown how 
many dependency analyses can be cast in DCC. As Section 4 shows, we can compare and contrast various 
dependency analyses in a single framework, For example, the call- by-name functional SLam calculus, the 
slicing calculus, and the binding-time calculus share a common translation of types into DCC and a set 
of common correctness properties; small differences occur only in the translations of terms, Larger differences 
between these calculi and the Smith-Volpano calculus can also be described. Another advantage of the 
translations is their utility in the de- sign of dependency analyses. For instance, we have found a certain 
incompleteness in the functional SLam calculus; it would make se- mantic sense to add a rule r,x:(t,K)te:(t 
,d) Kcd  T,x: (t,ti) t-e : (t ,d) - (since it is easily modelled in DCC), but the original SLam cal- 
culus does not have the rule. DCC can also be used to point out apparent design inconsistencies in some 
of the existing calculi. We are currently redesigning the Imperative SLam Calculus [13] us- ing a translation 
into DCC as a guide for the type system, and as a vehicle for proving noninterference. The model underlying 
DCC simplifies proofs of noninterfer- ence. The model was also invaluable in developing DCC itself. For 
instance, the pattern seqx = e in (bind y = e in e ) occurs frequently in the translations; the type 
of e must be both pointed and protected in order for the translation to work. With- out the concepts 
of pointed and protected , the obvious path might be to adopt an ever increasingly complex set of type 
con- versions and equations. The model was also helpful in developing the weaker notion of noninterference, 
and extending the notion of protected types to lifted types by changing the semantics of lift- ing. It 
would have been difficult to make this change in the syntax of DCC alone (other than, perhaps, by directly 
imposing the equa- tion T&#38;l) = (Te(s))l). Not all aspects of dependency can be translated into DCC. 
For example, the binding-time analyses of Davies and Pfenning 17, 61 cannot be directly translated into 
DCC because DCC cannot model the coercion from run-time objects to compile-time objects. A rather different 
semantics due to Moggi [21] has been developed for such binding-time analyses, using the concept of a 
fibration to model dependency. A similar comment applies to the trust oper-ator that maps from untrusted 
to trusted in (Zlrbaek and Palsberg s work [27]. Other possible extensions of DCC include accounting 
for the spawning of concurrent threads [ 131 and modelling cryptographic operations in such a way that 
encrypting a high-security datum could produce a low-security ciphertext [l]. The relationship of DCC 
to semantic dependency in the context of optimizing com-pilers [4, 111 and to region systems for memory 
management [37] should also be explored. Acknowledgements Thanks to Eugenio Moggi for discussions and 
to the anonymous referees for their comments. Anindya Banerjee is a member of the Church Project and 
is supported in part by NSF grant EIA-9806835. 6 November 1998 References <RefA>111 <SinRef><booktitle>M. Abadi</booktitle>. <title>Secrecy by typing 
in security protocols</title>. In <booktitle>The- oretical Aspects of Computer Software: Third International Symposium, 
volume <volume>1281 </volume>of Lect. Notes in Computer Sci</booktitle>. <publisher>Springer-Verlag</publisher>, <date>1997</date></SinRef>. PI <SinRef><author>M. Abadi</author>, <author>B. Lampson</author>, and <author>J.-J. 
L</author>&#38;y. <title>Analysis and caching of dependencies</title>. In <booktitle>Proceedings.of the 1996 ACMSIGPLAN International Conference 
on Functional Programming</booktitle>, pages <pages>83-91</pages>. <publisher>ACM</publisher>, <date>1996</date></SinRef>. [31 <SinRef><author>S. K. Biswas</author>. <title>Dynamic Slicing in Higher-Order 
Program-ming Languages</title>. <note>PhD thesis</note>, <publisher>University of Pennsylvania</publisher>, <date>1997</date></SinRef>. [41 <SinRef><author>R. Cartwright </author>and <author>M. Felleisen</author>. 
<title>The semantics of program dependence</title>. In <booktitle>Proceedings of the 1989 ACMSIGPLAN Con-ference on Programming 
Language Design and Implementa- tion</booktitle>, pages <pages>13-27</pages>. <publisher>ACM</publisher>, <date>1989</date></SinRef>. r51 <SinRef><author>C. Consel</author>. <title>Binding time analysis for 
higher order untyped functional languages</title>. In <booktitle>Proceedings of the 1990 ACM Con-ference on Lisp and Functional 
Programming</booktitle>, pages <pages>264- 272</pages>. <publisher>ACM</publisher>, <date>1990</date></SinRef>. [61 <SinRef><author>R. Davies</author>. <title>A temporal-logic approach to binding-time anal-ysis</title>. 
In <booktitle>Proceedings, Eleventh Annual IEEE Symposium on Logic in Computer Science</booktitle>, pages <pages>184-195</pages>, <date>1996</date></SinRef>. [71 
<SinRef><author>R. Davies </author>and <author>F. Pfenning</author>. <title>A modal analysis of staged com-putation</title>. In <booktitle>Conference Record of the Twenty-Third 
Annual ACM Symposium on Principles of Programming Languages</booktitle>, pages <pages>258-270</pages>. <publisher>ACM</publisher>, <date>1996</date></SinRef>. PI <SinRef><author>D. Denning</author>. 
<title>A lattice model of secure information flow</title>.<journal> Com-mun. ACM</journal>, <volume>19(5)</volume>:<pages>236-242</pages>, <date>1976</date></SinRef>. [91 <SinRef><author>D. Denning </author>and <author>P. 
Denning</author>. <title>Certification of programs for se- cure information flow</title>. <journal>Commun. ACM</journal>,<volume> 20(7)</volume>:<pages>504-5 13</pages>, <date>1977</date></SinRef>. 
1101 <SinRef><author>M. Felleisen</author>. <title>The theory and practice of first-class prompts</title>. In <booktitle>Conference Record of the Fifteenth 
Annual ACM Sympo-sium on Principles of Programming Languages</booktitle>, pages <pages>180- 190</pages>. <publisher>ACM</publisher>, <date>1988</date></SinRef>. [ill <SinRef><author>J. Ferrante</author>, 
<author>K. J. Ottenstein</author>, and <author>J. D. Warren</author>. <title>The program dependence graph and its use in optimization</title>. <journal>ACM Trans. 
Programming Languages and Systems</journal>, <volume>9(3)</volume>:<pages>3 19-349</pages>, <date>1987</date></SinRef>. WI <SinRef><author>J. Hatcliff </author>and<author> 0. Danvy</author>. <title>A computational 
formalization for partial evaluation</title>. <journal>Mathematical Structures in Computer Sci-ence</journal>, <volume>7</volume>:<pages>507-541</pages>, <date>1997</date>. 
Special issue containing selected pa-pers presented at the 1995 Workshop on Logic, Domains, and Programming 
Languages, <location>Darmstadt, Germany</location></SinRef>. v31 <SinRef><author>N. Heintze </author>and <author>J. G. Riecke</author>. <title>The SLam calculus: program-ming with 
secrecy and integrity</title>. In <booktitle>Conference Record of the Twenty-Fifth Annual ACM Symposium on Principles of 
Pro- gramming Languages</booktitle>, pages <pages>365-377</pages>. <publisher>ACM</publisher>, <date>1998</date></SinRef>. [I41 <SinRef><author>B. T. Howard</author>. <title>Inductive, coinductive, and pointed 
types</title>. In <booktitle>Proceedings of the 1996 ACM SIGPLAN International Con-ference on Functional Programming</booktitle>, pages 
<pages>102-109</pages>. <publisher>ACM</publisher>, <date>1996</date></SinRef>. [I51 <SinRef><author>P. Hudak</author>, <author>S. L. Peyton Jones</author>, <author>P. L. Wadler</author>, <author>Arvind, B. Boutel</author>,<author> J. Fairbairn</author>, 
<author>J. Fasel</author>, <author>M. Guzman</author>, <author>K. Hammond</author>,<author> J. Hughes</author>, <author>T. Johnsson</author>, <author>R. Kieburtz</author>, <author>R. S. Nikhil</author>, <author>W. Partain</author>, and <author>J. 
Pe- terson</author>. <tech>Report on the functional programming language Haskell</tech>, Version <volume>1.2</volume>. <journal>ACM SIGPLAN Notices</journal>, 
<date>May 1992</date></SinRef>. [I61 <SinRef><author>J. Lambek </author>and <author>P. Scott</author>. <title>Introduction to higher order cate-gorical logic</title>.<journal> Cambridge studies 
in advanced mathematics</journal>. <publisher>Cambridge University Press</publisher>, <date>1986</date></SinRef>. [I71 <SinRef><author>J. McLean</author>.<title> Security models.</title> In <editor>J. Marciniak</editor>, 
editor,<booktitle> Ency-clopedia of Software Engineering</booktitle>.<publisher> Wiley Press</publisher>, <date>1994</date></SinRef>. [181 <SinRef><author>J. C. Mitchell</author>. <title>Foundations for 
Programming Languages</title>. <publisher>MIT Press</publisher>, <date>1996</date></SinRef>. [I91 <SinRef><author>M. Mizuno </author>and<author> D. A. Schmidt</author>. <title>A security flow control algo-rithm 
and its denotational semantics correctness proof. For-mal Aspects of Computing</title>, 41727-754, 1992.</SinRef> rw <SinRef>E. 
Moggi. Notions of computation and monads. Information and Control, 93:55-92, 1991</SinRef>. WI <SinRef><author>E. Moggi</author>. <title>A categorical 
account of two-level languages</title>. In <booktitle>Proceedings, Mathematical Foundations of Programming Semantics, Thirteenth 
Annual Conference, Electronic Notes in Theoretical Computer Science. Elsevier</booktitle>, <date>1997</date>. Available <url>fromhttp://www.elsevier.nl/locate/entcs/</url></SinRef>. 
w-1 <SinRef><author>A. C. Myers </author>and <author>B. Liskov</author>. <title>A decentralized model for infor- mation flow control</title>. In <booktitle>Proceedings of 
the Sixteenth ACM Symposium on Operating Systems Principles</booktitle>. <publisher>ACM Press</publisher>, <date>1997</date></SinRef>. ~31 <SinRef><author>A. C. Myers</author>. <title>Practical 
mostly-static information flow con-trol</title>. In <booktitle>Conference Record of the Twenty-sixth Annual ACM Symposium 
on Principles of Programming Languages</booktitle>. <publisher>ACM</publisher>, <date>1999</date></SinRef>. v41 <SinRef><author>F. Nielson</author>. <title>Strictness analysis and denotational 
abstract in-terpretation</title>. In <booktitle>Conference Record of the Fourteenth Annual ACM Symposium on Principles of 
Programming Languages</booktitle>, pages <pages>120-131</pages>. <publisher>ACM</publisher>, <date>1987</date></SinRef>. WI<SinRef> <author>H. R. Nielson </author>and <author>E Nielson</author>. <title>Automatic binding time 
analy- sis for a typed h calculus</title>. <journal>Science of Computer Programming</journal>, <volume>10</volume>:<pages>139-176</pages>, <date>1988</date></SinRef>. [26] <SinRef><author>H. R. Nielson </author>
and <author>F. Nielson</author>. <title>Two-Level Functional Lan-guages</title>, volume <volume>34 </volume>of Cambridge Tracts in Theoretical Com-puter 
Science. <publisher>Cambridge University Press</publisher>, <date>1992</date></SinRef>. [27] <SinRef><author>P. 0rbaek </author>and <author>J. Palsberg</author>. <title>Trust in the h-calculus</title>. <journal>Journal 
of Functional Programming</journal>, <volume>7(6)</volume>:_<pages>557-591</pages>, <date>November 1997</date></SinRef>. [28] <SinRef><author>J. C. Reynolds</author>. <title>Types, abstraction and 
parametric polymor-phism</title>. In <booktitle>R. E. A. Mason, editor, Inform&#38;ion Processing</booktitle> <volume>83</volume>, pages <pages>513-523</pages>. <location>North 
Holland, Amsterdam</location>, <date>1983</date></SinRef>. [29] <SinRef><author>J. G. Riecke </author>and <author>R. Viswanathan</author>. <title>Isolating side effects in sequential 
languages</title>. In <booktitle>Conference Record of the Twenty-Second Annual ACM Symposium on Principles of Program- ming 
Languages</booktitle>, pages<pages> I-12</pages>. <publisher>ACM</publisher>, <date>1995</date>.</SinRef> [30] <SinRef><author>A. Sabelfeld </author>and <author>David Sands</author>. <title>A Per model of secure infor-mation 
flow in sequential programs</title>. <note>Unpublished manuscript</note>, <date>1998</date></SinRef>. [31] <SinRef><author>G. Smith </author>and <author>D. Volpano</author>. <title>Secure information 
flow in a multi- threaded imperative language</title>. In <booktitle>Conference Record of the Twenty-Fifth Annual ACM Symposium 
on Principles of Pro- gramming Languages</booktitle>. <publisher>ACM</publisher>, <date>1998</date></SinRef>. [32] <SinRef><author>C. Strachey</author>. <title>The varieties of programming language</title>. 
In <booktitle>Pro-ceedings of the lnrernational Computing Symposium</booktitle>, pages <pages>222-233</pages>. <publisher>Cini Foundation, Venice</publisher>, <date>1972</date>. 
Reprinted in<editor> Pe- ter O Hearn </editor>and <editor>Robert Tennent</editor>, eds., <booktitle>Algol-like Languages</booktitle>. <location>Birkhhser</location>, <date>1997</date></SinRef>. [33] <SinRef><author>Y.-M. 
Tang</author>. <title>Systkmes d effet et interpktation abstraite pour l analyse de jot de con&#38;le. </title><note>PhD thesis</note>, <journal>Ecole 
Nationale SupCriere des Mines de Paris</journal>, <date>1994</date></SinRef>. [34] <SinRef><author>Y.-M. Tang </author>and <author>P. Jouvelot</author>. <title>Effect systems with subtyping</title>. 
In<booktitle> ACM Conference on Partial Evaluation and Program Ma-nipulation</booktitle>, <date>June 1995</date></SinRef>. [35] <SinRef><author>P. Thiemann</author>. <title>A unified 
framework for binding-time analy-sis</title>. In <editor>M. Bidoit</editor>, editor, <booktitle>Colloquium on Formal Approaches in Software 
Engineering (FASE 97)</booktitle>, volume <volume>1214 </volume>of Lect. Notes in Computer Sci., pages <pages>742-756</pages>. <publisher>Springer-Verlag</publisher>, <date>April 
1997</date></SinRef>. [36] <SinRef><author>F. Tip</author>. <title>A survey of program slicing techniques. Journal of Programming Languages</title>, <volume>3(3)</volume>: <pages>121-189</pages>, 
<date>September 1995</date></SinRef>. [37] <SinRef><author>M. Tofte </author>and <author>J.-P. Talpin</author>. <title>Region-based memory manage-ment</title>. <journal>Information and Computation</journal>, 
<volume>132(2):</volume><pages>109-176</pages>, <date>1997</date></SinRef>. [38] <SinRef><author>D. Volpano</author>, <author>G. Smith</author>, and <author>C. Irvine</author>. <title>A sound type system for secure flow analysis. 
Journal of Computer Security</title>, <volume>4(3)</volume>:<pages> l-21</pages>, <date>1996</date></SinRef>. [39] <SinRef><author>P. Wadler</author>. <title>The marriage of effects and monads</title>. In 
<booktitle>Proceed-ings of the 1998 ACM SIGPLAN International Conference on Functional Programming</booktitle>, pages <pages>63-74</pages>. 
<publisher>ACM</publisher>, <date>1998</date></SinRef>. [40] <SinRef><author>M. Weiser</author>. <title>Program slicing. IEEE Trans. Software Engineer-ing</title>, <volume>10(4):</volume><pages>352-357</pages>, <date>July 1984</date>.</SinRef> </RefA>
 A Translations into DCC The translations of the various source calculi into DCC are given in Tables 
7-12 below. To make the translations more readable, most of the cases of sums and products are left out. 
We also use the DCC combinator and abbreviation  dot : TK(TK (t)) + Tati dot =hr: T,(T~(t)).bindy=xinbindz=yin(~,u~ 
z) (seqbindf =eine ) = (seqv=e inbindf =v ine ) where v is a fresh variable. Most of the translations 
also re-quire a coercion combinator for interpreting subsumption, but these combinators-and a few others-need 
to be defined specially for each system. These definitions are found in each translation. Table 7: Translation 
of the Call-by-name Functional SLam Calculus into DCC (excerpts). coerw, 1s2 : s; --f s; = k~:T~(unit~).bindy=xin(~~y) 
 COerce(,it,k),(unit,~)  = kc: T,(s~~uf).bindy=nin~lc (~z:~~.coerce~,,,,(y(coerce,~,,.~,z))) =oe~ce(.s2+U, 
,w),(s,+U2,~) = hx: T,(s; xuT).bindy=xin~~~~ (coerce,Y,,s2(proj1 y),coerce,,,,,(proj2y)) coerce(.~,,,,,K),(.~,xu,,~) 
 = hr:T,((s~+u~)~).bindy=.~in~~~ (seqz=yin casezcoeYCe(,~,+u,,IC),(SZ+UZ,K ) of injI(w). lift (injl (coerce,T,,,T, 
w)) 1inj2(w).lift (inj2 (coerce,,,,, w))) w4 [Unit] rk(),:(unit,K)* r* I- llK(lift()):TK(unitJ Tl-e:sl 
r* t- e* : S; SliS2 kbl rkees2 * r* t- (coerce,y,,,T, e*) : s; r*,f:s*  r,f :ske:s be*:s* [JW rk(pf:s.e):s 
* r*l-(pf:s*.e*):s* be*:~; v-4 rk(h:sl.e)K:(~l * r* k (qK (LX : s;. e*)) : T,(s; -+ s;) r,x: sl I-e : 
~2 r*,x:s; -+sz,K) l-t-e: (s, --+s~,K) rFel :sl r* k e* : TK(s; --t s;) r* k e; :s; LAPPI rk(eel):s20K 
* r*t-dot(bindf=e*in(qr(fe;))):(s2*K)* jisfresh rt-ei:Si r* I-e: : ST [Pair] rk(el,e2)K:(sl Xs2,K) * 
r* +(r(,(e;,e$)): G(sT Xsb) rte:(Sl Xs2,K) r* l-e* : T,(s; xs;) [WI rk(projie):si*K * I-'* (bindx= e* 
in(TIK (projix))) :(SiOK)* k dot xis fresh TFe:si r* t e* :s; [WI rt(injie)h-:(sl fs2,K) * (qK(lift (injie*))) 
+$)I) r* I- : T,((s; r* k e* : T,( (s; + s;)~) r*,x:sfke;:s* r*t-dot( bindy=e* T+~:(s,+s~,K) r,x:siFei:s 
in (TIK( seqv=yin y fresh   [Case] =+ casev of injI(x).e; 1inj2(x). ez))) : (S*K)* rE(caseeofinjI(x).el 
Iinj2(x).e2):s*K rt-e:s r* f e* :s* [Protect] rt-(protect,e):s*K * r*I-ddot(qre*):(s*K)* Table 8: Translation 
of the Slicing Calculus into DCC (excerpts). W-1 r,x:s,rfkx:s+r*,x:s*,(r')*k~:~* [Unit] rt On : (unit,{n}) 
=+ r*I-r({,)(lift0) :T{,)(unit~) [km1 r,x:sI k e: g r t- (Ix:s~.~),: (s, -+s2,{n}) * r* t- (q{,,) r*,X:Sfke*:s; 
(Lx: sT.e*)) : T{,,)(si -+ ss) Tke: (s, +s~,K) rFel:sl r* t-e* : TK(s; -+ s;) r* t-e; :s; VPPI rt(eel):s20~ 
* r* I- dot (bindf= e* in (Q (fer))) : (s2oK)* fis fresh Table 9: Translation of the Binding-time Calculus 
into DCC (excerpts). r,x:s,r~x:sJr*,x:s*,(r )*~.:s* WI [Unit] rt ()p: (unit,@ *r* I- (qp (lift 0)) : 
Tj(unitl) r-,x: s1 k e : ~2 r*,x:s;t-e*:~;km1 rk(hr:sl.e)p:(s~ -+s2,P) * r* I- (Q (IX :s;.e*)) :Tp(s; 
-+ sz) rte: (~1 +s2,/3) r t- el : s1 j r* k e* : Tg(s; -+ s;) r* ~ T ; f is fresh L%wl rk(eel):s2 
Table 10: Translation true = (if e thene, elsfz; = = proj, = c0ercet.p = c0erceL.H= c~~erceHcmd.Lcmd 
= r*l-(bindf=e*in(fe;)):s; of the Smith-Volpano Calculus into DCC. (inj 1 0) (inj;! 0) (caseeof injl(x).el 
 1inj*(n).ez),n is fresh theprojection statetothe x oftbe variable hf..f , e = L, H, (L cmd),or (H cmd) 
hf.hs:S"f,(rH)XS"L(rL).~H (,fS) hf'.h~:SVff(r~)xSV~(T~).lift (,f's,proj2s)  W4 rH;r~tX:~=+(hO.proj,O):sv(rH,rL,z) 
ifxErT [ TrueH] rH;rL k true :H * (ho.qH true) :sv(rH,rL,H) [FalseHj rH;rL t false:H + (ho.T)H,fdse) 
:sv(rH,rL,H) [True-L] rH;rLI-true: L* (hatrue) :sv(rH,rL,q [FalseL] r,&#38;rL.t false : L + (ho.,fahe) 
: s"(rH,rL,L) P@Hl rH;rLk skip:H cmd+(ha,proj,O):sv(r,,r,,H cmd) [Sk&#38;L] rH;rLbskip:Lcmd+(ho.lift 
CJ):SV(TH,TL,LC~~) WI rH; rL t e : .w .w ISI rH;rLbe:21 * e* : sv(rH,rL,SO) (COerCeSople*) : s"(rH,rL,SI) 
[Assigns] r&#38;rLke: H rH =(~l,...r&#38;) rH;rL!F((xi:=e):Hcmd j e*:sv(rH,rL,H) (h~.(proj,(proj, @,...,(e* 
(~),...,)):Sv(r~,r~,Hcmd) [AssignL] rH;rLte:L rL=h,...,4 rH;rLl-(q:=e):Lcmd * e : sv(rH,rL,L) (ho.lift 
((proj1Q),(proj,(proj*(T),...,(e*cT),...,))):sv(rH,rL,Lcmd) rH;rLkCI:Hcmd rHH;rLb-c2:Hcmd j CT:SV(rH,rL,Hcmd) 
c;:SV(rH,rL,Hcmd) PeNI rH;rL k (cI;c2): H cmd (h0.c;(cl Q,proj2O)):SV(rH,rL,Hcmd) rH;rL+cC1:Lcmd rH;rLkC2:Lcmd 
j Ci :S"(rH,rL,L cmd) C;:s"(rH,rL,L cmd) rH;rLk(Cl;C2):Lcmd (ho.seqal =(Ci6) in(c~a~)):S"(TH,TL,Lcmd) 
WI r&#38;rLke: H rH;rL k Ci :H cmd rH;rLtifethenclelsec;?:H cmd * e*:SV(rH,rL,H) (lcr.bindv= (e* O) c; 
:SV(l-H,r-L,HCrnd) v is fresh inifvthen(Ci cr)else(c;o)):SV(rH,rL,Hcmd) WI rH;rLte:L rH;rLtci:Hcmd rH;rLt-ifethenclelsec2:Lcmd 
e*:sv(rH,rL,L) of:sv(rH,rL,Lcmd) * (ho.if (e* CJ) then{ci o)else (cz o)) :SV(r~,rL,Lcmd) [While] rH;rLte:L 
rH;rLtc:Lcmd j lYH;rLFwhileedOc:Lcmd e*:s"(rH,rL,L) C* :s"(rH,rL,L cmd) (~,?f..ho.if(e*a)thenseqd=(c*(T)in(fd)else(lifto)):SV(r~,rL,Lcmd) 
 Table 11: Translation of the Call-by-value Functional SLam Calculus into vDCC (excerpts). ifs=(sl+.v~,K)and(s:!or)=s~ 
c"erce(,,it,r).(unit,~) fi = p,!f.hg:s*+(s*)~.g(~,(hx:s~.seqbindh=(f'g)in(hx))) = k:T,(unit).bindy=nin(~y) 
c~'erce(.,z+u,.r)~(.~,~uz,n') (hz :si.seqv (y (c~erce,~,.,,~ z)) = hr : T,(s; + (Ui)l).bindy=.XinIld 
= in lift (coerce,,,,2 v)) seqV=e; inseqr=(,f'~)inlift(dot(Tj~r)):(.Q.~); Prl r,n:s,I+ I-(liftx):(s*)~k-x:s* 
r*,x:s*,(r')* [Unit] rt-(),:(unit,K)*r*t-(lift(Ij,())):(T,(unit))~ Pbl rte:.q s, 5 r I- e: s2 92 * r*te*:(s;)I 
r* t- seqw= e* inlift(c0erce,v,,,s2 w) : (.$)I w fresh [Reel r, .f : s I- e : s S = ($1 --f .Q,K) r t- 
(p..f : s : 3.e) (S1.K) = s* * r*,f: S* t e* : (s*)~ r*kji.x(k,f :~*.e*) :(s*)~ [Lam1 r,x: 3, t- e : 
.q r~(hr:.Vl,e)K:(sl -+S2,K) * r*,n: Si t-e* : ($)I r* k lift(?jK(hY:.7i.e*)):(TK(si -+ (S;)I))I PPPI 
rte:(s, --Fs~,K) rte, rI_ (eel) :S~OK :s, a r* k e" : (Tx(Si --f (s;)~))~ r* I- seqbind,f =e*in r* k 
ei : (s;)~ ,f',v,r fresh rte:s r* t-e* : (s*)~ r-t-(protect,e) * r*Fseqm=e*inlift(dot(Ijrm)):(s*K); 
mfresh :SIK Table 12: Translation of the Call-tracking Calculus into vDCC (excerpts). ifs= (~1-% ~2) 
 fir = p,f.hg:~*+(T~(s*))~.g(hr:s~.seqbindh=(f'g)in(h~)) r,x:s,r~x:s,L~r*,n:s*,(r)*~lift(~~x):(T (~*))~ 
rt-() :unit,L* r* k lift (ljr. 0) :(T~(unit))~ : S* I- e : (TK(~*))L Fe4 rt-: s.e) * r*~~((hf :.~*.e*):(T,(.~*))l 
r,.f : s t e : S,K s = (SI -r, .q) r*,f' (p.!f' : s r,x:S, I-e :s~,K r*,n: Si I- e* : (T,(.$))L k4 r-F- 
(hr :.q.e), : (s, q s2),L * I? k (lift(IjL (k:si.seqr=e*in lift (dot (qt,) r))))) : (TL(si -+ (Ti,),,(s;))l))l 
rfresh r* F e* :(T&#38;(si --f (T,(s;))~))~ r* t ei : (T,,(si))l rke:(Sl&#38;S2),Kl r!-el:Slr~2 j r*t-seqbindf'=e*in 
,f ,y,v fresh MPPI  rt (eel):S2,KuKl UK2 seqbindy=eiin seqbindv= (.t'~) inlift(%uK,uK2 ~):(TMJ~,u~~(s;))~ 
   
			


 Proceedings of the 1990 Winter Simulation Conference Osman Balci, Randall P. Sadowski, Richard E. Nance 
(eds.) A FIVE LEVEL HIERARCHY FOR THE MANAGEMENT OF SIMULATION MODELS t Francois E. CeUier Qingsu Wang 
Bernard P. Zeigler Department of Electrical and Computer Engineering The University of Arizona Tucson, 
Arizona 85721 ABSTRACT This advanced tutorial describes the goal-driven automated generation of models 
from a set of design specifications. A five level hierarchy is introduced which supports the automated 
gen- eration of both models and simulation experiments from an ab- stract description of an overall design, 
and from an abstract description of the goals of the simulation study. The aim is to be able to generate 
models and experiments in a top-down fash- ion from a description of static components and the couplings 
between these components by automating the stepwise refine- merit process. Detailed model descriptions 
are extracted from template files residing in model libraries. The paper empha-sizes on the problems 
encountered in the automatic generation of continuous-system models since the synthesis of these models 
is more involved than the synthesis of discrete-event models. The paper starts with an assessment of 
the need for the pro- posed automated model synthesis methodology. In the sequel, the advocated five 
level hierarchy will be presented in a bottom- up fashion starting with classical approaches to continuous-system 
simulation (the first and bottom layer of our hierarchy), and advancing to higher and higher levels of 
abstraction. The paper ends with the presentation of a complete example of the proposed methodology~ 
now presented in a top-down fashion. 1. INTRODUCTION: THE NEED FOR AUTOMATED MODEL SYNTHESIS Applications 
for automated model synthesis technology can be found in unmanned deep Space missions where robots must 
be able to make intelligent model-based decisions. This capabil- ity is important since it reduces the 
necessity for frequent com- munications with Earth which inevitably slow down the decision making process 
due to extensive communication time delays. Applications can also be found in manufacturing. The de- 
sign of either new parts or new tools from similar existing parts or tools is a complex process which 
is accompanied by much responsibility and few rewards. Automated design and simula- tion aids can make 
this process less painful, and can reduce the time needed to educate new design engineers. Finally, applications 
can be found in real-time decision sup- port. Military strategists could use this technology to describe 
proposed scenarios in abstract high-level terms. Detailed mod- els for simulating the proposed scenarios 
could be automatically generated, and the strategist could watch the most likely effects of a proposed 
strategy to unfold before his/her eyes. 1.1 Space When humanity will colonize other planets of our solar 
sys- tem such as planet Mars or the moons of Jupiter and Saturn, this colonization will have to occur 
in three phases. In a first phase, unmanned Space missions will deploy high-autonomy systems which must 
prepare the target planet for human ar-rival. These missions will be carried out by smart robots with 
I" This research is supported in part by NASA-Ames Co-operative Agreement No. NCC 2-525, aA Simulation 
Environment for Laboratory Management by Robot Organitations', and in part by the NASA/University of 
Aritona Space Engineering Research Center for the Utilization of Local Planetary Resources (SERC/CULPR). 
a high degree of decision making capability. The second phase will consist of manned Space missions conducted 
by a few highly specialized astronauts who must be supported in their endeav- ors by an abundance of 
smart automatic devices. During this second phase, the need for high-autonomy systems will not de- crease. 
On the contrary, it will grow. Only in the third phase will it be possible to send larger numbers of 
less specialized hu- mans to the target planet, and only then will life on tiffs planet start to resemble 
life here on Earth. As a first (and very rudimentary) example of this multi- phased approach to colonization, 
the University of Arizona is currently developing a prototype of an automated system that will be able 
to produce oxidizer for rocket fuel on planet Mars from C02 extracted from the Martian atmosphere [Ramohalli 
et al 1989]. This high-autonomy system will be deployed by an unmanned mission to Mars which will not 
return to Earth. The deployed oxygen production plant will then produce oxygen in a basically unsupervised 
operational mode during a period of two years. A manned follow-up mission to Mars will then use the oxygen 
produced by this plant for its return flight to Earth. With this approach, manned missions to Mars can 
be made more economical since it will no longer be necessary to lift the (heavy) oxygen for the return 
flight out of the gravity well of planet Earth. Intelligent decision making requires insight into the 
conse- quences of the decision made. Frequently, the decision making process consists of choosing among 
a series of alternative sce-narios. The decision maker must be able to assess the pro's and con's of 
each alternative by predicting their future effects on the overall plan. For this purpose, he often wishes 
to simulate alternative designs prior to their implementation. A robot roaming around on planet Mars 
is confronted with exactly this problem. To choose between a set of alternative scenarios, it should 
base its decision on a proper assessment of the effects of each one. Since the situation of the robot 
at the time of decision making depends heavily on previous decisions it has made, it is unfeasible to 
carry along individual simula- tion programs for all possible alternatives. Such an approach would quickly 
lead to myriads of simulation programs which are largely the same, but each one of which is slightly 
different from every other. Instead, the decision making process should operate on a "world model" [Albus 
et al. 1987] from which a specific simulation model for any given specific purpose can be automatically 
synthesized at any time [Zeigler et al.t980a]. 1.2 Manufacturing Aircraft manufacturers maintain relational 
databases con-raining large numbers of construction plans for aircraft parts. Whenever a new part is 
needed, a process design engineer searches such a database for one or several similar designs, and modifies 
them until the new design is completed. The new de- sign is then added to the database. This is an extremely 
stress- ful job which carries a lot of responsibility (if the design doesn't work, who is to blame?) 
and few rewards. Consequently, the average process design engineer "lasts" in this job for only 18 to 
24 months, while his or her education consumes the first nine to 12 months of this period. Manufacturers 
obviously have a problem here. An automated model generation system (AMGS) can help overcome such problems. 
With the new technology, a process F.E. Cellier, Q. Wang, and B.P. Zeigler design engineer would start 
by formulating (and formalizing) a set of goals and a set of constraints describing the new design. The 
AMGS would then automatically generate one or several alternative designs together with simulation models 
for these de- signs, alternatives which satisfy all the goals and violate none of the constraints. If 
the number of resulting designs is small, the process design engineer could then simulate all of the 
proposed designs and pick the one which seems to be most attractive. If the AMGS generates too many designs, 
the engineer could formulate additional goals and/or constraints to limit the num- ber of acceptable 
designs, and if the AMGS does not find any solution, the engineer knows that he has overconstrained the 
problem. This new technology will make the job of the process design engineer more interesting and more 
joyful, it will reduce the time needed for his/her education, and it will enhance the quality of the 
end product since the design engineer can explore many more alternative designs than s/he would ever 
have time for in the current manual technology.  1.3 Military Strategic Planning Strategic planning 
requires real-time decision making in a partly unknown environment. In current technology, this prob- 
lem is tackled manually by assembling the general's staff in a room. The general proposes possible strategies 
(scenarios), and his staff will "simulate" the effects of the proposed strategies in a brainstorming 
exercise by throwing potential suggested out- comes back at the general. Finally, the general makes his 
de- cision taking into consideration all the proposed (and partly contradictory) outcomes that he received 
from his staff. We propose that our new technology can provide a more sound basis for decision making. 
While it is impossible to gen- erate ahead of time simulation models for every potential situ- ation, 
it is possible to develop ahead of time a "world model" from which our AMGS can then synthesize on the 
fly simulation models for any proposed scenario. In this way, the effects of a proposed strategy could 
be simulated in real time and could support the general in making the right decision. 2. LEVEL ONE: CLASSICAL 
MODELS FOR CONTINUOUS-SYSTEM SIMULATION Models used for similar purposes often contain similar com- ponents. 
For exampl% a model of a DC-motor can be used to describe the mechanism that drives a windshield wiper 
in a car, the sump pump behind a house, or the food processor in a kitchen. The model is always the same, 
just the parameters as- sume different values. It therefore makes sense to include a DO- motor template 
in the "world model", a generic DC-motor from which a specific DC-motor for any given purpose can be 
gener- ated when needed. In this way, the DC-motor model needs to be debugged only once, and if the template 
model is ever mod- ified, all its future instantiations automatically reference the updated template 
model. It is also possible to equip the model editor with a mechanism which allows it to trace all references 
to the edited model within the model library, and which auto- matieally deletes the compiled versions 
of all those models from the library~ thereby forcing the user to migrate model modifi- cations through 
all simulation programs that make use of those models. Object-oriented programming systems provide powerful 
en- vironments to support such a modular approach. In a previous tutorial [Zeigler et al 1989b], we described 
how modular mod- eling can be developed for discrete-event simulation. In this tutorial, we deal with 
continuous-system models. Here, the sit- uation is a little more complex. Traditionally, "modular" continuous-system 
models were expressed in most Continuous-System Simulation Languages (CSSL's) using a macro processor 
[Augustin et al 19671. Macros are text templates. During compilation of the simulation pro- gram, the 
macro call is replaced by the macro definition body. Let us explain the macro replacement process by 
means of a simple DC-motor macro programmed in the macro language of ACSL [Mitchell and Gauthier 1986]. 
The following m~ro can represent an either armature-controlled or field-controlled DC-motor. MACRO DC 
MOT( the$a, omega, ua, u f, tauL, J L, ... Ra, La, R f, L f , k, Jm, Bin, flag, i ]O, iaO, TO, thO ) 
MACRO redefine in, iadot, if, ifdot, ui, psi MACRO redefine taum, Twist, Tdot MACRO standval ifO : 0.0, 
iaO = 0.0, TO : 0.0 MA.CRO standval thO = 0.0 MACRO if (flag = IND)labind if = uf/Rf ia = (ua -ui)/Ra 
MACRO goto soon MACRO labiud..eorttinue ifdo~ = (uf -Rf * if)ILl if = INTEG(ifdoL ifO) iadot = (ua -ui 
-Ra * ia)/La ia = INTEG(iadot, iaO) MACRO goo~..eontlnue psi = k * if taum = psi * ia ui = psi * omega 
Tdot : taum -~auL -Bm * omega Twist = INTEG(Tdot, T0) omega = Twist/(Jm+ JL) theta = INTEG(omega, thO) 
MACRO END This macro exhibits a number of interesting features. Let us look at the armature equation: 
uo = u, + R~ io + L°-~- 03 Usually, eq(1) will be implemented in the form of a differential equation 
in state-space form, i.e.: di~ uo -u~ -Ro ia (2) dt L~ This is done since we always wish to transform 
continuous mod- els into a state-space form such that all differential equations can be numerically integrated 
rather than differentiated. How- ever, the electrical time constants of the DC-motor are often so much 
smaller than the mechanical time constant that the effect of the armature inductance La on the overall 
system behavior can be neglected. In this case, we cannot operate on eq(2) since, if we set La = 0.0, 
this results in a division by zero. Instead, we must return to eq(1), delete the term in Za from the 
equation, and rewrite it as: ia --Ua --ui R. (3) Notice that this example already confronts us with 
two dif- ferent versions of DC-motor models. Instead of creating two separate macros for these two cases, 
it was decided to code them as two variants within the same macro. The constant parameter flag can assume 
either the value IND or NOIND in the macro call. Depending on the setting of this compile-time parameter, 
the macro replacer will generate code either in the form of eq(2) or in the form of eq(3). Notice however 
that the "macro if" statement is not truly an "advanced feature:' of the ACSL macro handler. It is just 
a crude way to implement only the simplest of the capabilities that a true model management system can 
offer. The above macro can be invoked by a statement such as: DC M OT( theta, omega = ua, u f , tauL, 
Y L, ... Ra, La, R f, El, kmo~, Jm, Bm, "IND') The last few parameters were omitted on the call. Parame-ters, 
which are assigned default values ("macro standval") in the macro definition, can be omitted in the macro 
call. The flag parameter was specified as 'TND", and therefore, both the armature inductance and the 
field inductance are included in the model equations generated in the process of macro text re-placement. 
Let us now look at the equations that the macro handler generates during the macro expansion. The two 
inductances were included. Z09996 = (u f- R] * ZO9997}/Lf Z09997 INTEG(Z09996,0.O) Z09998 (ua - Z09995 
- Ra * ZO9999)/La Z09999 = INTEG(Z09998,0.O) Z09994 = kmot * Z09997 Z09993 = Z09994 * Z09999 Z09995 = 
Z09994 * omega Z09991 = Z09993 - tauL -Bm * omega Z09992 = 1NTEG(Z09991,0.0) omega ZO9992/(Ym -4- JL) 
theia INTEG(omega , O.Q.) AU local variables of the macro (which were declared inside the macro definition 
using the "macro redefine" statement) were renamed into generic names. This is necessary for the reason 
given below. The (differential and algebraic) equations that make up a continuous-system model are basically 
parallel code. Contrary to the discrete-event case where the equal sign in an equation denotes an assignment, 
in continuous-system sinmlation, the equal sign in an equation denotes an equality. It means that the 
quantities on the teft hand side of the equal sigu are at all times equal in size to the quantities on 
the right hand side of the equal sign. Thus, continuous-system model equations are of a declarative nature. 
Most CSSL languages offer an equation sorter which is ac- tivated after the macro replacement has been 
completed, and which will sort the model equations into an executable sequence. Of course, it cannot 
do so if the same variable appears more than once on the left hand side of the equal sign. Thus, in order 
to allow a macro to be invoked more than once in a program, it is necessary to replace all locally defined 
variables by new generic names in each new macro replacement. In the above example, notice that e.g. 
the variable Z09995 is used before it has been defined. The equation sorter will have to arrange the 
sequence of statements such that all variables ex- cept for those defined through integral equations 
are evaluated before they are used. Integral equations are different since all continuous-system simulation 
languages use explicit numerical integration schemes. For example, using forward Euler, we can write: 
~(t + at) = ,(t) + at. ~(t) (4) Since this equation computes a new value for x for a time instant At 
time units into the future, we do not need to evaluate this equation simultaneously with the evaluation 
of the equation for ~(t). And yet, macros are not truly modular. The term "modu-larity" is often used 
in a narrow sense as a means to structuring program code into sections. However, we prefer to define 
the term "modularity" in a much wider sense as the capability of a program segment to represent a real 
object correctly irrespec- tive of the environment in which it is used. Employing this def- inition, 
the term modular modeling becomes synonymous with object-oriented modeling. Notice that DC-motors can 
be used in two different ways. They can be driven electrically (either through the armature or through 
the field) in which case they will transform a portion of the electrical energy entered into the system 
into mechanical energy, as a consequence of which the mechanical axle starts rotating. However, we can 
also rotate the mechanical axle by force, thereby entering mechanical energy into the system, and as 
a result, a portion of that energy will be converted.into elec- trical energy, generating a voltage across 
the two terminals of the armature coil. In this case, the DC-motor is used as a DC-generator. Clearly, 
the physical object is the same irrespective of whether it is used as a motor or as a generator. In an 
object- oriented modeling environment, we should therefore be able to represent both types of operation 
through one and the same software object. Let us write down an ACSL macro describing the DC-motor in 
its generator mode. MACRO DCGENI~heta , omega, ua, tauin, uf, RE, LL, ... Ra, L a, R f , L f, ~, £ m, 
Bin, i fO, iaO, TO, thO ) MACRO redefine in, iadot, if, ifdot, ui, psi MACRO redefine iauL, Twist, Tdot 
MACRO standval if0 = 0.0, iaO ~- 0.0, TO = 0.0 MACRO standval th0 = 0.0 ifdoZ = (uf -Rf * if)/Lf if = 
INTEG(ifdoi,ifO) iadot = (ui -(Ra + RL) * ia)/(La + LL) ia = I NTEG( iadot, iaO) ua = RL * ia + LL * 
iadot psi = k * if tauL = psi * ia ui = psi * omega Tdot = tauin -- tauL -Bm * omega Twist = INTEG(Tdot, 
TO) omega = Twist/Jm theta = INTEG(omega, thO) MACRO END When the machinery is operated in its motor 
mode, the main input to the system is the armature voltage Ua. It causes a current i~ to flow through 
the armature coil. The armature cur-rent then causes a mechanical torque v m to be built up which is 
the cause of the mechanical rotation. However, once the motor rotates, i.e., once its angular velocity 
w builds up, this angular velocity is responsible for an induced voltage ui to be gener- ated back on 
the electrical side which is subtracted from the armature voltage Ua and. thereby reduces the armature 
current i~ until an equilibrium is reached, r L and JL represent the me- chanical load of the motor, 
i.e., they are variables belonging to an external data object. They are not part of the DC-motor data 
object. These two variables are additional inputs to the DC-motor model. When the machinery is operated 
in its generator mode, the main input to the system is the driving torque vim. It causes the motor to 
rotate. Once an angular velocity w is built up, it induces a voltage u i on the electrical side which 
causes a current ia to flow through the armature coil. The armature current ia causes a mechanical torque 
rL to be built up back on the mechanical side which opposes the driving torque ri=. The armature current 
ia is also responsible for building up an armature voltage u a across the two armature terminals. The 
armature voltage ua is subtracted from the induced voltage ui thereby weakening the armature current 
ia. This process contin- ues until an equilibrium is reached. The load is now electrical, symbolized 
in our model by a resistive load .RL and an inductive load LL which~ in themselves, are not part of the 
DC-generator, and are therefore additional inputs to the DC-generator model. For simplicity, we left 
the variant without inductances out. Notice that the equations are basically the same in the motor mode 
and in the generator mode. Minor differences exist as a consequence of the different loads. However, 
what is truly different in the two models is the assignment of inputs and out- puts. In the motor mode, 
Ua is an input to the macro, whereas in the generator mode, ua is an output. We realize that CSSL type 
macros aren't truly modular with respect to the objects they represent. The same physical device calls 
for quite different macros depending on the envi- ronments in which they are supposed to operate. The 
simplest "macro" representing an electrical resistor, for instance, must be stored in the macro library 
in two different versions, one modeling the equation: uR =//- iR (5a) and the other modehng the equation: 
in = u~ (5b) R If the resistor is placed over a current source, the current i R through the resistor 
is known, and we need to use the macro which reflects the model according to eq(5a), whereas if we place 
the resistor over a voltage source, the voltage uR across the re-sistor is known, and we need to use 
the macro which reflects the model according to eq(5b). Obviously, an equation sorter F.E. Cellier, Q. 
Wang, and B.P. Zeigler is insufficient. In an object-oriented continuous-system mod- eling environment, 
we require an equation solver which accepts general equalities of the type: < ezpression >=< ezpression 
> (6a) or: < ezpressian >= 0.0 (6b) and which can solve these equalities for arbitrary variables. 3. 
LEVEL TWO: OBJECT-ORIENTED MODELLING AND THE DYMOLA MODELING LANGUAGE Notice that macro handlers, which 
are commonly consid- ered an intrinsic part of a CSSL language, have in fact noth- ing to do with the 
simulation language itself. The macro text replacement must be performed at source level, and must be 
completed before any other activity of the compiler can begin. The macro handler is often implemented 
as the first path of the compilation, and is completely separate from everything that follows. It would 
make perfect sense to develop a macro han- dler independent of the simulation language for which it is 
being used. The same macro handier could easily be used as a front end to several different simulation 
language compilers. This approach was taken with DYMOLA [tglmqvist 1978]. DYMOLA is a modeling language 
and not a simulation lan-guage. DYMOLA is considerably more general than the con-ventional macro handler, 
but it serves the same purpose. DY-MOLA is a program generator which can generate code for a va- riety 
of different simulation languages. If DYMOLA is used as a preprocessor, the simulation language no longer 
needs a macro handler of its own; in fact, it no longer requires an equation sorter since DYMOLA will 
sort the resulting set of equations into an executable sequence after solving each of them for the appropriate 
variable. The syntax of statements in DYMOLA is that of eq(6a). DYMOLA is able to solve arbitrarily non-linear 
equations for any variable as long as that variable appears linearly in the otherwise non-linear equation. 
DYMOLA cannot currently handle algebraic loops, not even linear algebraic loops (which is a pity). DYMOLA 
cannot currently handle most types of struc- tural singularities as they occur when subsystems are coupled 
together in such a way that the overall system exhibits fewer degrees of freedom than the sum of the 
subsystems. Finally, DYMOLA cannot currently eliminate redundant equations as they appear frequently 
when subsystems are coupled together which have fuzzy borderlines between them, i.e., when one and the 
same equation can be viewed as belonging to one or the other of the subsystems depending on their utilization. 
Other than that, DYMOLA has all the properties needed for truly hi- erarchical modular modeling, i.e., 
for object-oriented modeling. More details about the current capabilities and limitations of DYMOLA can 
be found in [Cellier 1990b]. Let us discuss how the DC-motor example can be coded in DYMOLA. model type 
DCMOT terminal theta, omega, ua, u f, tauZ, J.L local ia, i], ui, psi, laura, Twist parameter Ra, Rf, 
kmot, Ym parameter La = 0.0, L f = 0.0, Bm = 0.0 default ua = 25.0, u f = 25.0 L f*der(if) = uf --Rf 
* if La*der( ia ) = ua -ui -Ra * ia psi = kmo~ * if taum = psi * ia ui = psi * omega der(Twist) =*aum 
-tauL -Bm * omega Twis~ = (Ym + JL) * omega der(theta) = omega end This code is quite self-explanatory. 
However, let us discuss some of the special properties of DYMOLA model descriptions. (i) DYMOLA variables 
belong to either the type terminal or the type local. They are of type terminal if they are sup- posed 
to be connected to something outside the model. They are local if they are totally connected inside the 
model. (2) Terminals can be either inputs or outputs. What they are, often depends on the environment 
to which they are con-nected. The user can explicitly specify what he wants them to be by declaring them 
as "input" or "output" rather than simply as "terminal". (3) Terminals can have de]ault vaMes. In this 
case, they don't need to be externally connected. (4) DYMOLA constants can be declared to be of type 
parame-ter. For parameters, values can be assigned from outside the model. Parameters can have default 
values in which case it is not necessary to assign a value to them from outside the model. (5) Derivatives 
are either expressed using the der(.) operator or a prime ('). It is also allowed to use a der2(.) operator 
or a double prime (") to denote a second derivative, and even higher derivatives are admissible. Contrary 
to most CSSL's, DYMOLA permits the use of these operators anywhere in the equation, both to the left 
and to the right of the equal sign. (6) Consequently, it is not possible to set initial conditions for 
the integrators inside a model which is clearly a disadvan- tage of DYMOLA. (7) DYMOLA equations use 
the syntax of eq(fa). During the process of model expansian, equations are salved for the ap- propriate 
variable. (8) Terms which are multiplied by a zero parameter are au-tomatically eliminated during model 
expansion. Conse-quently, if La = 0.0, the model equation La der(ia) = ua -ui -Ra * ia is first replaced 
by the modified model equation 0.0 = ua -ui -Ra * ia which then results in one of three simulation equations, 
namely (i) ua = ui + Ra * in, (ii) ui = ua -Ra * ia, or (iii) ia = (ua -ui)/ Ra depending on the environment 
in which the model is used. However, if La ~ 0.0, the model equation is always transformed into the simulation 
equation der(ia) = ( ua -ui -Ra * ia) / La. This is a very elegant way to solve the "variant macro" problem 
of ACSL.  (9) The above rule indicates that parameters with value 0.0 are treated in a completely different 
manner than all other parameters. This decision has a side effect. Parameters that are not set equal 
to zero are preserved in the generated simulation code, and can be interactively altered through the 
simulation program directly without a need to return to DYMOLA. Parameters with value O.0 are optimized 
away by the DYMOLA compiler, and are not represented in the simulation code. floweret, the advantages 
of this decision are overwhelming, since this does away with an entire class of structural singularities. 
 The above model can then be invoked in the following way: submodel ( DCMOT) dcml( Ra = 2.0, R] = 5.5, 
kmot = 1.0, ./m = 15.0) It can be connected to the outside world using a dot-notatiom dcml.ua = kalph 
* err dcml.uf = 12.0 dcmtJL = crll.J//.t deal.SauL = crllAauL crll.omega = deal.omega where crll is 
the name of another model of the same or a dif-ferent type. DYMOLA models are much more modular than 
ACSL macros since equations are automatically solved during model expansion for the variable which is 
appropriate in the context of the model call environment. The utilization of named pa-rameters instead 
of positional parameters upon invocation of a DYMOLA model helps with long parameter lists. Default val- 
ues can and should be assigned to many parameters, and with the named parameter convention, the user 
can selectively spec- ify values for those parameters only for which the default values are not appropriate. 
The connection mechanism as presented so far is very general, although a little clumsy. Each connection 
corresponds to connecting two points of a circuit with a wire. It can be noticed that wires are frequently 
grouped into cables or buses. For example, consider an RS232 connector. The RS232 male connector has 
25 pins, while the corresponding RS232 female connector has 25 holes. It seems natural that a modeling 
language should provide for an equivalent mechanism. DYMOLA does this by providing so-called CUTs. Let 
us look at the above example once more. It can be noticed that the two models dcml and erll have three 
variables in conmaon, namely omega, fouL, and ,/./5. We can therefore go ahead and declare those three 
variables in a cut rather than as simple terminals. The modified model type DCMOT now looks as follows: 
model type DCMOT terminal theta, ua, u] cut mech(omega, tauL, YL) local ia, if, ui, psi, taum, Twist 
parameter Ra, R f, kmog, Jm parameter La = 0.0, L f = 0.0, Bm = 0.0 default ua : 25.0, u] = 25.0 L f*der(if) 
= u f- Rf*i] La*der(ia) = ua - ui - Ra * ia psi = kmo~ * if taum : psi * ia ui : psi * omega der(Twist) 
= taum -tauL -Bm * omega Twist : (]m + JL) * omega der(theta) = omega end In the main program, we can 
invoke a De-motor dcml of type DCMO T, and another model called crll which is assumed to contain a declaration 
for the same cut type mech, and we can connect the cut mech of dcml at the cut mech of erll. This is 
accomplished as follows: submodel ( DC M OT) dcml( Ra .... ) submodel (CABREL) crll(Bl .... ) connect 
dcml:mech at crll:mech The connect statement automatically generates the three model equations: dcml.omega 
= crll.omega dcml.tauL : crll.tauL dcml.JL = crll.JL Cuts can be hierarchically structured. We could 
e.g. modify the model type DCMOT once more as follows: model type DCMOT terminal theta cut torch(omega, 
tauL, JL) cut elect(ua, uf) cut both[mech, elect] local ia, if, ui, psi, taum, Twist parameter Ra, R 
f, kmot, Jm parameter La = 0.0, L f = 0.0, Bm = 0.0 default ua = 25.0, uf = 25.0 Lf*der(if) = uf -Rf 
* if La*der(ia) = ua - ui -Ra * ia psi = kmot * if ~aum = psi * ia ui = psi * omega der(Twis~) = taum 
-- tauL -- Bm * omega Twist = (Jm + JL) * omega der(theta) = omega end in which case we can either connect 
the cut mech and tile cut elect separately, or we can connect both together. During ex-pansion of the 
connect statement, DYMOLA checks that the connected cuts are structurally compatible with each other. 
However, even this won't suffice in many cases. We may notice that, by connecting a wire between two 
points in an elec- trical circuit, we actually connect two variables, namely the po- tential at the two 
points, and also the current that flows through the new wire. However, the two connections work differently. 
White the potentials of all cuts that are connected at a point must be equal, the currents must add up 
to zero. Variables of type potential are called across variables, while variables of type current are 
called through variables. DYMOLA provides a connection mechanism also for this second type of connection. 
The generalized form of a DYMOLA cut looks as follows: cut < cug_namc > (< through-variables > / < across_variables 
>) If three models ml, m2, and m3 have each a cut of type A declared as: cut A(~/i) we can use the connect 
statement: connect ml :Aat m2:Aat m3:A which will generate the following model equations: ml.v = m2.v 
m2.v = m3.v ml.i + m2.i + m3.i = 0.0 Notice that currents at cuts are normalized to point into the subsystem. 
If a current is directed the opposite way, it must take a minus sign on the cut definition. This concept 
is more generally useful that just for electrical circtfits. In a mechanical system, all positions, velocities, 
and accelerations are across variables, while all forces and torques are through variables. In a hydraulic 
system, water levels are across variables, while water flow is a through variable. In a thermic system, 
temperature and pressure are across vari-ables, while heat flow is a through variable, etc. These similari- 
ties between different types of physical systems are particularly emphasized in the bond graph modeling 
methodology [Cellier 1990a]. One cut can be declared as the main cut. The main cut is the default cut 
in a connection, i.e. it suffices to specify the model name to connect the main cut of a submodel. Sometimes 
it is useful to allow connections to take place in-side a model instead of across model boundaries. For 
this pur- pose, DYMOLA provides a node declaration. Nodes are named, and cuts can be connected to nodes. 
Nodes are hierarchically structured the same way cuts are. model M    cut A(vl, v2), S(v3, v4), C(v5, 
v6) main cut D[A, B, C] end node N connect M at (N, N, N) This connect statement is equivalent to: 
 connect M : A at N, M : B at N, M : C at N which is identical to saying: connect M:Aat M:Bat M:C 
F.E. Cellier, Q. Wang, and B.P. Zeiglcr which will result in the following set of equations: exchange 
information on a continuous basis. In the context of M,vl = M.v3 M, v3 : M.v5 M, v2 = M.v4 M.v4 = M.v6 
Sometimes, it is also useful to connect a variable through from a source to a destination. For this purpose, 
DYMOLA allows you to declare a directed path from an input "cut to an output cut, Let us assume we have 
a model describing a pump which is declared as follows: model pump cut inwater(wl ), ou~water(w2) path 
water < inwa~er -outwa~er > end Let us assume we have two more models describing a pipe and a tank with 
compatibly declared cuts and paths, then we can connect the water flow from the pump through the pipe 
to the tank with the statement: ccmneet (water) pump to pipe to tank One path can always be declared 
as the main path. If the main path is to be connected, the path name can be omitted in the connect statement. 
Besides the at and to operators, DYMOLA provides some additional connection mechanisms which are sometimes 
useful. The reversed operator allows us to connect a path in the oppo- site direction. The par operator 
allows for a parallel connection of two paths, and the loop operator allows us to connect paths in a 
loop.  3.1 Hierarchical Model Construction Notice that, while there does not exist a strict rule which 
forbids mixing physical equations with connection statements in one model, it is good practice to avoid 
such a mix. At the bottom of the model hierarchy are models which are described solely through physical 
equations and which do not contain any connect statements. These models are called atomic models. Models 
which invoke other models and describe the connec-tions between these submodels are called coupling models. 
Cou-pling models can, of course, refer also to other coupling models, not only to atomic models, i.e., 
coupling models can be hierar- chically structured. [Cellier 1990a] contains an example (solar heated 
house) of a hierarchically structured modular model with five hierarchy levels. Notice however that the 
concept of structuring models in a hierarchical fashion is different from the five level hierarchy of 
model management which is the topic of this paper. Hierar-chically structured, object-oriented models 
(with an arbitrary number of hierarchy levels) occupy just the second level of our hierarchical model 
management methodology, whereas the ex-panded, i.e. flat, simulation models occupy the first hierarchy 
level of the methodology. Notice further that object-oriented modeling does not imply object-oriented 
simulation as well. DYMOLA clearly supports the concept of models representing physical objects in a 
mod- ular, i.e. environment independent, fashion. Thus, DYMOLA supports object-oriented modeling. Yet, 
the generated simu- lation code is a flat simulation program expressed in any of a number of off-the-shelf 
simulation languages which clearly do not support object-oriented simulation. It is a commonly made mistake 
to believe that object-oriented program execution is necessarily desirable. It is the object-oriented 
user interface which is desirable since it simplifies programming. In the con-text of continuous-system 
simulation, an object-oriented ap- proach to simulation would force us to exchange information between 
the simulation data objects using a mechanism of mes- sage passing. This is far too inefficient since 
continuous objects discrete--event simulation, an object-oriented approach to simu- lation is not mandatory~ 
but at least~ it makes some sense since sud~ data objects exchange information only at event times. Thus, 
hierarchy flattening of discrete-event models is feasible and not harmful, but it is not absolutely necessary. 
However, hierarchy flattening of continuous-system models is a must from the point of view of run-time 
execution efficiency. In the last two sections, we have discussed concepts in- volved in object-oriented 
continuous-system modeling. Object oriented discrete-event modeling is similar but somewhat less involved. 
In a discrete-event model, all connection variables are clearly specified as either input or output variables. 
It never happens that the direction of a path needs to be turned around due to the environment in which 
the model is used. Conse-quently, object-oriented discrete-event modeling environments do not require 
an equation solver. This simplifies their imple- mentation to some extent. 4. LEVEL THREE: THE SYSTEM 
ENTITY STRUCTURE One important property of object-oriented modeling has not been discussed yet. Object-oriented 
models hide details of the internal model structure from the outside. Only those properties of a model 
that transpire to its surface are notice- able from the outside. For instanc% once a model has been encapsulated, 
only its input and output ports are still visible. From the outside, it is no longer evident whether 
the encap- sulated model belongs to the class of discrete-event models or whether it belongs to the class 
of continuous-system models. Consequently, from now on, we no longer need to distinguish between discrete-event 
models vs continuous-system models. Everything that will follow (i.e., the hierarchy levels three to 
five) is valid for both model classes indistinguishably, since these hierarchy levels have no access 
to the internal model structure. In other words, the model dynamics have been encapsulated at hierarchy 
level two, and therefore, from hierarchy level three on upwards, we will only deal with objects and their 
relations to each other. The System Entity Structure (SES) is a mechanism to de- scribe hierarchically 
structured sets of objects and their interre- lations. The SES is a labeled tree with attached variables 
types, i.e., a graphical object that describes the decompositions of sys- tems into parts. It is a knowledge 
representation scheme which formalizes the modeling of systems in terms of decomposition, taxonomic, 
and coupling relationships. The scheme supports structured knowledge acquisition for, and flexible restructuring 
of, families of large scale system designs. Figure 1 shows a sketchy decomposition of the solar heated 
house of [Cellier 1990a] into parts. In order to keep Figure 1 small and understandable, only a few of 
the actual decomposi- tions are shown. Solar-Heating I I I I I I collector heat exchanger house storage 
tank water loops I sol ar radiation I heat capacity I water spiral I loss ] heat I water III [ waterloopbackup 
[ heat i 1-dim-cells capacity spirals heater Ill exchangers111 heat III 1-dim-cell water spiral exchanger 
Figure 1. Decomposition of a solar heating into parts Figure 1 is an informal SES of the solar heating 
system. It shows the decomposition of physical objects into parts. How- ever, for practical utilization, 
the informal SES is insufficient. Somewhere, it must be shown how the physical objects are de- composed 
into parts. For this reason, we have developed formal SES's or simply SES's. In a formal SES, physical 
objects are called entities. The children of physical objects are always ab- stract objects called aspects 
and specilizations. The children of these abstract objects are always physical objects again. I.e., physical 
objects and abstract objects always toggle in a formal SES. The root object in a formal SES is always 
an entity. Also the leaf objects of the SES are always entities. They repre- sent the atomic models. 
All entities which are not leaf objects represent coupled models. It is not necessary to represent abstract 
objects differently from physical objects in the SES. It is easy to tell them apart simply by counting 
the number of levels in the SES. Objects at odd levels from the top or from the bottom of the SES rep- 
resent always entities while objects at even levels of the SES are always either aspects or specializations. 
Physical decom- positions are shown as aspects. We shall discuss the purpose of specializations at a 
later time. For the moment, it suffices to mention that it is exactly the distinction between aspects 
and specializations which forces us to formalize these abstract objects rather than implying the decompositions 
by attaching them to the parent entity directly. The formal SES satisfies the following set of axioms: 
 (1) Uniformity: Any two nodes (objects) which have the same labels (names) have identical attached variable 
types and isomorphic subtrees. (2) Strict Hierarchy: No label appears more than once down any path of 
the tree from the root entity to any of the leaf entities. (3) Alternating Mode: Each node has a mode 
which is ei- ther entity, aspect, or specialization; if the mode of a node is entity, then the modes 
of its successors are either aspect or specialization; if the mode of a node is aspect or special-ization, 
then the modes of its children are entity. The mode of the root is entity. (4) Valid Siblings: No two 
siblings have the same label. (5) Attached Variables: No two variable types attached to the same item 
have the same name. (6) Inheritance: Every entity in a specialization inherits all the variables, aspects, 
and specializations from the parent of the specialization.  The SES is completely characterized by its 
axioms [Zeigler 1984, 1990]. However, the interpretation of the axioms cannot be specified, and thus 
is open to the user. When constructing an SES, it may sometimes seem diffi-cult to decide how to represent 
concepts of the real world in the SES. A meaningful decomposition of a system into parts is not always 
easy to accomplish, and yet, an inadequate decision can have serious consequences in terms of the number 
of wires that connect the various submodels to each other. One of the goals of a meaningful system decomposition 
is to limit the number of required connections between its subsystems. As of now, we don't have a tool 
to support the user in this process: i.e., we don't have a tool which can consider various alternative 
decom- positions, and propose one wlfich will result in few subsystem connections. Such a tool would 
require a detailed knowledge of the internal structure of all subsystems. It could infer this knowledge 
by tracing through the nested couplings as is done in hierarchy flattening. 4.1 Automated Model (generation 
and the DEVS-Scheme Modeling Environment DEVS-Scheme [Zeigler 1990] is an application layer above the 
LISP-based PC-Scheme language [Texas Instruments 1986]. It supports the DEVS modeling formalism [Zeigler 
1984]. DEVS stands for Discrete EVent Speeification~ i.e., DEVS was devel- oped primarily for discrete-event 
models. Yet, as we explained above, the higher levels of the DEVS modeling hierarchy are the same for 
both discrete-event models and continuous-system models. DEVS-Scheme contains a set of PC-Scheme (i.e. 
LISP} procedures implementing the DEVS modeling formalism. They were written using the SCOOPS object-oriented 
LISP ex- tensions which form an intrinsic part of the PC-Scheme envi- ronment. They were coded such that 
all PC-Scheme (LISP and SCOOPS) programming tools are transparently usable within DEVS-Scheme as well. 
In this light, DEVS-Scheme is not a specialization of PC-Scheme, but a superset of PC-Scheme. System 
Entity Structures can be coded in DEVS-Scheme in the form of a text file which contains a one-to-one 
translation of the graphical SES representation. An example of such a text file will be presented later 
in this paper. Currently, the trans- lation must still be done manually, but automatic translations from 
the graphical representation to the textual representation are being developed. Once the SES has been 
coded: DEVS- Scheme offers an automated transform procedure which itera- tively generates more and more 
complex coupled models by in- voking submodels and by setting up the coupling relations that were specified 
between them. In this way, transform translates the SES into either one single DEVS model or a set of 
DEVS models. The transform procedure can be requested to either flatten the hierarchy or keep the hierarchy. 
For continuous sys- tems, transform can also automatically generate the necessary DYMOLA coupling models. 
Only the atonfic (i.e. leaf) models must be user coded. The coupled models can be automatically generated 
from the SES. It is possible to store coupled models in the model library as if they were atomic models. 
If transform finds a coupled model in the model library, it Will stop searching for its children, and 
simply use the coupled model as if there were no more children and as if this were an atomic model. Let 
us now return for a moment to the example of the aircraft manufacturer. If we maintain all our designs 
at the first hierarchy level (as this is done in the current technology), we need to store millions of 
different designs in the database. Each design is fiat and therefore fairly complex. If a design is found 
to have a flaw, and if that flaw has been traced back to a particular subcomponent which may be intrinsically 
used also in hundreds of other designs, we should edit all these hundreds of flat design descriptions 
to remove the bug from the database. Of course, this is never done (too much work), and therefore, the 
database is always inconsistent. It can therefore easily happen that another process design engineer 
at a later time bases a new design on another earlier design which contains the same flaw that had been 
discovered once before, but which was never totally removed from the database. If we maintain our designs 
at the second hierarchy level, we still need to store millions of different designs in the database. 
However, these designs will not be flat. They will reference de- sign templates that are stored in a 
hierarchically structured template library. The main design files will thus be much shorter and more 
readable since they reference these templates rather than contain them in an already expanded form. If 
a flaw is traced back to a bug in a design template, the template itself is updated, rather than the 
design that makes use of it. When an atomic template is edited, all coupled templates in the template 
library which reference the atonfic template either directly or indirectly could be automatically deleted 
from the template library. In this way, all future designs will automat- ically reference the updated 
template rather than the original one. If the designs are maintained at the third hierarchy level, we 
still need to store millions of individual designs in the database, but this time, they are stored in 
the form of different System Entity Structures. This does not seem to buy us much in com- parison with 
the previous (i.e., level two) alternative, but al-ready the next section of the paper wilt explain why 
an SES is indeed considerably more powerful than either a DEVS model or a DYMOLA model. 5. LEVEL FOUR: 
THE GENERALIZED SYSTEM ENTITY STRUCTURE We had explained earlier that the SES contains two types of abstract 
objects: aspects and specializations. Specializations enable us to store several variants of similar 
SES's in a single generalized SES. In fact, from now on, we shall call the "gener- F.E. Cellier, Q. Wang, 
and B.P. Zeigler alized SES" simply "the SES". An SES without any specializa- tions is a special case 
of "the SES". It is sometimes referred to as a pure SES. Figure 2 shows an example of an SES which decomposes 
a car into a few components. Notice that the component engine is specialized into either V6 or Diesel. 
Car I car-dec [ en~ne I wheels i I windshield I trunk ~_~__~ wiper! V6 Diesel I w/per-dec I I wiper-motor 
wiper I wmotor-spec blade JL f I DC-motor stepper motor Figure 2. SES with specializations of a car 
Pure SES's can be obtained from general SES's by a process called pruning. Pruning an SES means to cut 
away all special- izations but one. The car SES of Figure 2 can be pruned to retain either the V6 engine 
or the Diesel engine. DEVS-Scheme [Zeigler 1990] contains a software tool called ESP-Scheme [Kim 1988] 
which can prune any SES. The output of the pruning process is a pure SES. Returning once more to the 
aircraft manufacturing exam- ple, we notice that, at the fourth hierarchy level, we no longer need to 
store mSllions of different designs. Maybe, we can re-duce all these designs to a few thousand basic 
designs with many specializations. This makes the SES of a system more powerful than either a corresponding 
DEVS model or a corre- sponding DYMOLA model. One single "model" expressed as an SES with specializations 
can represent many different vari- ants of actual models of a process. This concept replaces the "macro 
if" statement of ACSL's macro handler, but it is consid- erably more powerful. One single SES can be 
used to generate hundreds, maybe thousands, of different models for different purposes. From now on, 
we shall call an ensemble of one or several SES's with specializations which can be used to generate 
specific models for an entire application area a world model. Thus, a world model is an ensemble of System 
Entity Structures with specializations which can generate arbitrary models for an entire application 
area. Returning to our example of the strategic planning tool, it now becomes evident how this problem 
is tackled. We generate a set of models that describe all feasible variants of a battle -not ill the 
form of myriads of individual simulation programs, but in the form of a few SES's with specializations. 
Specific models for any actual situation can then be automatically generated on the fly. Any one of these 
specific models can be simulated, and will lead to a decent forecast of what the consequences of the 
simulated scenario would be (at the level of detail contained in the set of invoked atomic models). 6. 
LEVEL FIVE: GOAL-DRIVEN PRUNING One problem that remains to be solved is the following. How do we prune 
an SES? Which branches do we cut, and which one do we retain? How do we choose between the V8 engine 
and the Diesel engine? The answer is fairly simple. We attach rules to the spe- cialization objects 
in the same way that we attach coupling relations to the aspect objects. For the above example, the following 
rule could be coded: if purchase_price = high and rnain~enance-eosg = low then select Diesel else select 
V6 end if Purchase_price and maintenance_cost are two attached vari- ables of the parent node. They are 
enumerated variables which can assume the values "low", "medium", or "high". The pruner always searches 
specializations for such rules. If it finds one or several rules that cml be fired, it will do so. If 
this process results in a unique selection, the pruner accepts it and proceeds to the next node. If no 
rule has been specified, or if no rule can be fired, or if the fired rules do not lead to a unique selection, 
the pruner enters into an interactive mode and asks the user for a selection. FRASES [Hu et al 1989] 
is an experimental software which implements some of these ideas. Unfortunately, this software has not 
yet been fully integrated with the DEVS-Scheme mod- eling environment. However, such integration is planned. 
 7. AN EXAMPLE: THE CABLE REEL PROBLEM A new light weight fiber optics deep sea communication cable 
is to be laid through the British Channel between Calais in France and Dover in the United Kingdom. The 
cable comes on a huge reel which is placed on a ship. The ship moves slowly from one coast to the other 
by constantly leaving cable behind. A large motor unrolls the cable from the reel. A speedometer detects 
the speed of the cable as it comes off the reel. A simple proportional and integral (PI) controller is 
used to keep the cable speed v at its preset value Vset. Vset is the speed of the ship. A functional 
diagram of the overall system is shown in Figure 3. ,IJJJ/J/JJJJJ,I/J,b,,,'X  tit, Figure 3. Functional 
diagram of the cable reel system Control engineers are used to represent systems in the form of block 
diagrams. Figure 4 shows a block diagram of the overall control system. Fin ~7 F CabSys Figure 4. Block 
diagram of the cable reel system Block diagrams are a good way to depict graphically a hor- izontM cut 
through a System Entity Structure. The SES is cut through an aspect node. The outer frame symbolizes 
the par- cat node, in this case the root entity, whereas the inner boxes symbolize the children of the 
aspect node. Wires connecting inner boxes (in o~ example: err, u~, mech, v, V,n .... and E), are internal 
connections of the aspect node, whereas wires that extend to the outer frame (in our example: Vs,t, ~, 
and v are ez~ernal connections of the aspect node, i.e., these are attached (acp e:CabSys 'cable ' cablereel 
']port I fport) variables of the parent node. Notice that v appears both in the list of internal connections 
and in the list of external connec- tions. However~ this is only a question of convenience. We can easily 
transform the internal v connection into a second external v connection. Notice that any one of the inner 
boxes could easiiy become an outer frame if it were further decomposed into smaller parts. In this sense, 
block diagrams are hierarchical. HIBLITZ is a graphical front end to DYMOLA which follows exactly this 
ap- proach [Elmqvist 1982]. HIBLITZ allows us to zoom in on any of the internal boxes. Breakpoints are 
introduced to denote the magnification where the inner box suddenly becomes an outer frame, and where 
the internal structure of that box becomes visible, i.e., where we jump from one aspect node of the SES 
to another. In HIBLITZ, connections between boxes represent DYMOLA cuts, i.e., they are cables rather 
than wires. One single connection can contain many individual wires which can be either of the across 
type or of the through type, or both. HIBLITZ could be used in our DEVS-Scheme modeling environment to 
graphically represent the connection relations that are attached to aspect nodes. However, HIBLITZ runs 
currently oifly on Silicon Graphics machines, and is therefore incompatible with our modeling environment. 
One of our stu- dents is currently working on a reimplementation of a subset of these capabilities to 
be integrated with the DEVS-Scheme modeling environment. Figure 5 depicts the generalized SES of the 
cable reel prob- lem. CabSys CabSys-dec I I I I I I I cable motor compa-cable controller speedo- reel 
I rator I meter motor-spec controller-spec .K  11-I ~ I ] I DC hydro p PI PID motor motor controller 
controller controller Figure 5. SES with specializations of the cable reel system The root entity CabSys 
is decomposed into six parts. For this purpose, the aspect node CabSys-dec was introduced. Two of the 
component parts, namely the motor and the controller are specialized into variants. The motor can be 
either a DCmotor or a hydromotor. The selection is made in the specialization node motor-spec. Similarly, 
the controller can be either a Pcontroller, a PIcontroller, or a PIDcontrollcr. This selection is made 
in the specialization node controller-spec. Notice that the double lines in the SES qualify the abstract 
nodes motor-spec and controller- spcc as specializations rather than as aspects. The text file version 
of the SES is presented below. ;-Entity Structure for CabSys (make-eutstr tCabSys I (set-c-system-type 
e:CabSys 'system) (ai e:CabSys asp 'Cabsys-dee) (sci e:CabSys 'CabSys-dec) (ai e:CabSys ent 'compare,or) 
(ai e:CabSys ent 'controller) (ai e:CabSys ent amo~or) (ai e:CabSys ent 'cablereel) (ai e:CabSys ent 
'speedometer) (ai e:CabSys ent 'cable) ! (add-variable e:CabSys input (Fez, Vdes)'O) (add-variable e:CabSys 
'output '(radius velocity omega) '()} (acp e:CabSys ~comparator 'controller 'errport I signal) (acp e:CabSys 
'controller 'motor 'command 'uport) (acp e:CabSys motor eableveei mech 'mech) (acp e:CabSys %ablereel 
fspeedometer avpo~ 'vport) (acp e:CabSys 'speedometer 'comparator 'measport 'measport) (acp e:CabSys 
' compara~ov 'cable ' errpart ' errpo~t) (acpz e:CabSys 'CabSys 'comparator 'inl 'setport '(Vdes) '(Vset)) 
(acpz e:CabSys 'CabSys 'cable 'in2 'finport '(Fez,) '(Fin)) (aepz e:CabSys ' C abSys I cablereel ' rport 
Iout l '(radius) '(R)) (acpz e:CabSys 'CabSys 'cablereel tvport 'out2 '(v) '(velocity)) acpz e:CabSys 
'CabSys 'cablereel 'torch 'ouL3 '(omega) '(omega)) sci e:CabSys 'controller) ai e:CabSys spec ' cont~oller-spec) 
sci e:CabSys Icontroller-spec) ai e:CabSys en~ 'Pcontroller) ai e:CabSys enL 'PIcontroller) ai e:CabSys 
ent ' P I Dcontroller ) sci e:CabSys 'motor) (ai e:CabSys spec Smotor-spec) (sci e:CabSys 'motor-spec) 
(ai e:CabSys ent 'DCmotor) (ai e:GabSys ent 'hydromotor) ;--END-- The cable reel "world model" consists 
of: (1) The SES with specializations shown in Figure 5. (2) The block diagram shown in Figure 4 which 
explains how the decomposition of the system into parts is accomplished in the single aspect node CabSys-dec. 
 (3) Two rule bases, one for each specialization node, which for- realize the knowledge when which of 
the specializations is to be used. (4) A model library containing the nine atomic models (coded in DYMOLA) 
describing the nine leaf nodes of the SES.  From this (rudimentary) world model, any one of four dif- 
ferent pure SES's can be obtained by means of pruning. Figure 6 shows one such pure SES. CabSys I CabSys-dec 
 I I I l I I i cable DC comparater cable PI speedo- reel motor controller meter Figure 6. Pure SES 
of the cable reel system The pure SES can now be transformed. This process will generate the previously 
missing DYMOLA coupling model shown below. model CabSys submodel comparator submodel PIcontroller(kint 
= 0.2,kprop = 6.0) submodel DCmotor(Ra = 0.25,Rf = 1.0,kmot = 1.5, -- > ./m = 5.0,Bm= 0.2)tubmodel cablereel(Rempty 
= 0.6, W = 1.5, D = 0.0127,- > rho = 1350.0,BL = 6.5, J0 = 150.0)- >  (ic R = 1.2) submodel speedometer 
submo del cable input Vdes, Fe~l output radius, velocity, omega connect comparator:errport at Plcontroller:signal 
connect PIcont¢ollee:command at DCmoto~:uport connect DCmotor:mech at cab|ereehmeeh connect cablereel:vport 
at speedomeLer:vport cormeet speedometev:measport at comparator:measport connect comparaLor:errport at 
eable:errport connect cable: fport at cablereel:fport cable.Fin = Fext comparator.Vset = Vdes radius 
= cabtere¢l.R velocity = cablereel.v omega = cablereel.ornega end 63 F.E. Cellier, Q. Wang, and B.P. 
Zeigler The transform procedure will then automatically invoke the 1976]. In the synthesized DESIRE program, 
the statements DYMOLA preprocessor which flattens the hierarchy and gen- describing the model and those 
describing the experiment are erates, in our example, a (fiat) DESIRE simulation program wildly interspersed. 
However, this doesn't matter. It is at the [Korn 1989] representing the selected variant of the cable 
reel user interface where a clean separation between model descrip- system. However, the simulation program 
could also have been tion and experiment description is important, not at execution generated for a number 
of alternative simulation languages, time. -CONTINUOUS SYSTEM CabSys - 8. SUMMARY --STATE R Twist theta 
z err In this paper, we have demonstrated the usefulness of au- --DER dR dTwist dtheta dz derr --OUTPUT 
radius velity Cs$orna tomatic model synthesis tools. We have shown how a particu- --INPUT Vdes Fext lar 
implementation of such a tool, the DEVS-Scheme modeling --"PARAMETERS and CONSTANTS : environment, can 
be used to tackle a number of important re- kship= 10.0 Re~*pty=0.6 I W= 1.5 [D=0.0127 alistic application 
problems. The explicit example chosen to rho: 1350.0 BL=6.5 I J0= 150.0 Ipi~-3.14159 illustrate the automatic 
generation of continuous-system mod- Ra : 0.25 [ Rf : 1.0 I kmot = 1.5 [ J'rn = 5.0 Rm = 0.2~ k = 3.0 
[ kint = 0.2 I kprop = d.O els, i.e. the cable reel problem, had obviously to be a very simple --INITIAL 
VALUES OF STATES : one in order to fit onto the limited space provided iu this pa- R=l.2JTwist=0 J theta 
= O [ z = O J err = O per. However, considerably more complex examples have been developed and tested, 
and several (thick!) research reports de- TMAX : 3500 { DT = 0.05 INN = 2000 scribing these examples 
are available from the authors upon Vdes = 15.0 [ Fext : 100.0 scale = l X CCC : I request. label TRY 
drunr if XCCC < 0 then XCCC = -XCCC I scale = 2 * scale ] go to TRY REFERENCES else proceed Albus, 
J.S., H.G. McCain, and R. Lumia (1987), NASA/NBS Stan- DYNAMIC dard Reference Model for Telerobot Control 
System Architecture (NASREM), NBS Technical Note 1235, Robot Systems Division, srSVms=k*x Center for 
Manufacturing Engineering, National Technical Infor- --Submodel : comparatov mation Service, Gaithersburg, 
MD. Pr$err --Vdes -srSVms Augustin D.C., et al (1967), "The SCi Continuous System Simulation --Submodel 
: cable Language (CSSL)," Simulation 9, pp. 281-303. cale$F = lim(kship * PrSerr -Fezt) + Fex~ Cellier, 
F.E. (1990a), "Hierarchical Non-Linear Bond Graphs: A --Suhrnodel : cablereel Unified Methodology for 
Modeling Complex Physical Systems," DCr$JL = 0.5 * pi * W * rho * (R A 4 -- Remp$y A 4) + J0 keynote 
address, Proceedings European Simulation MultiConfer----Submodel : DCmotor ence, B. Schmidt, ed.), Niirnberg, 
FKG, June 10-13, 1990, pp. Dr$oma = Twist/(Jm + DCrSJL) --Submodel : CabSys  1-13. Cs$oma = Dr$oma Cellier, 
F.E. (1990b), Continuous-System Modeling and Simulation ---Submodel : cablereel Volume I: Modeling, Springer 
Verlag, New York. d/dt R = -D * D/(2 * pi * W) * Cs$oma Etmqvist, H. (1978), A Structured Model Language 
for Large Con-DrStaL = BL * Cs$oma -- ealeSF * R tinuous Systems, Ph.D. Dissertation, Report CODEN: LUTFD2/ 
--Submodel : PIcontroller (TFRT-1015), Dept. of Automatic Control, Lurid Institute of Tech- u = kprop 
* Pr$err + kint * err nology, Lund, Sweden. --Submodel : DCmotor Elmqvist, H. (1982), "A Graphical Approach 
to Documentationuf = 25.0 and Implementation of Control Systems," in: Proceedings 3rd DCr$if = uf/Rf 
IFAC/IaVlP Symposium on Software for Computer Control, SO- psi = kmot * DCr$if ui = psi * Dv$orna  COC0'82, 
Madrid, Spain, Pergamon Press. ia = (u -- ui)/Ra Hu, J., J.W, Rozenblit, and Y.M. Huaag (1989), "FRASES 
--A taum = psi * ia Knowledge Representation Scheme for Engineering Design," Pro- d/dt Twist = taum -Dr$taL 
-Bm* Dr$orna ceedings SCS MultiCon[erence on Advances in A.I. and Simulation, d/dt the~a = Dr$oma Tampa, 
FL, pp. 141-146. --Submodel : cablereel Kim, T.G. (1988), A Knowledge-Based Environment ]or Hierarchical 
elity = R * Cs$oma Modelling and Simulation, Ph.D Dissertation., Dept. of Electri- --Submodel : speedometer 
cal and Computer Engineering, University of Arizona, Tucson, AZ d/dr ~ = velity -k * ~e 85721. --Subrnodel 
: PIcou$roller Korn, G.A. (1989), Interactive Dynamic-System Simulation, McGraw d/dr err = PrSerr --Submodel 
: CabSys  Hill, New York. radius = R Mitchell, E.E.L., and J.S. Gauthier (1986), ACSL: Advanced Con-tinuous 
Simulation Language --User Guide / Reference Manual, OUT Mitchell &#38; Gauthier Assoc., 73 Junction 
Square, Concord, MA term Rempty -R 01742. radius = radius * 10 Ramohalli, K., E. Lawton, and R. Ash (1989), 
"Recent Concepts in dispt radius, velity, Cs$oma Missions to Mars: Extraterrestrial Processes", Journal 
of Propul-sion and Power 5, 2, pp. 181-187. Texas Instruments (1986), PC-Scheme Users Manual, Science 
Appli- /PIC 'CabSys.PRC' cations Press. l--Zeigler, B.P. (1976), Theory of Modelling and Simulation, 
John Wiley &#38; Sons, New York. The detailed equations contained in the nine atomic models Zeigler, 
B.P. (1984), Multifacetted Modelling and Discrete Event Sim- are of no direct concern to this paper. 
More details can be ulation, Academic Press, London, U.K. found in [Cetlier 1990b]. Notice that the equations 
stemming Zeigler, B.P. (1990), Object-Oriented Simulation with Hierarchical, from the various submodels 
were both solved and sorted. Also, Modular Models: Intelligent Agents and Endomorphic Systems, a number 
of variables were automatically renamed to conform Academic Press, Boston. with the DESIRE syntax. Zeigler, 
B.P., F.E. Cellier, and J.W. Rozenblit (1989a), "Design of The experiment description (i.e., the specification 
of the a Simulation Environment for Laboratory Management by Robot simulation run length, the termination 
conditions, the desired Organizations," Journal of Intelligent and Robotic Systems I, pp. outputs, etc) 
was synthesized from a second SES in the same 299-309. way as the model was. The SES, and to a large 
extent also Zeigler, B.P,, J. Hu, and J.W. Rozenblit (19895), "Hierarchical, Mod- ular Modelling in DEVS-Seheme," 
in: Proceedings 1989 Winter DYMOLA, support a clean separation of the experiment de- Simulation Conference, 
WSC'89, Washington, D.C., pp, 84-89. scription from the model description as mandated in [Zeigler  
			


 A Language-Independent Approach to Specification Construction N. L&#38;y and G. Smith CRIN&#38; INRIA 
LORRAINE BP. 239, F-54506 Vandomvre-les-Nancy Cedex (France) Abstract An interactive specification development 
environment is pre­sented in which a number of development methodologies and specification languages 
can be supported. Within the environment, design concepts and strategies are captured by the application 
of development operators, i.e. operators which enable the incremental construction and modification of 
specifications. The focus of this paper is to investigate the language in­dependence feature of the environment, 
based on the work done in the Esprit project ICARUS. A set of operators en­abling an object-oriented 
approach to specification develop­ment are instantiated for both the algebraic specification language 
Glider and the model-based specification language Z. These operators are illustrated by the development 
of a case study of a simple card game in both Glider and Z. 1 Introduction Formal methods of specification, 
verification and refinement have long been advocated as a means of reducing design errors and increasing 
confidence in developed software sys­terns. However, they have not yet been widely adopted, generally 
being regarded as too difficult or too impractical to use. One of the main problems is that the construction 
of specifications is a difficult task. While some tools and methodologies exist to aid the steps of verification 
and re­finement (e.g. [Abr88]), there is little to aid the software en­gineer in obtaining the formal 
specification which provides the basis of these subsequent steps. To create good speci­fications, sound 
development methodologies must be used. However, the use of such methodologies within a given spec­ification 
language is not always intuitive or easy. One approach to this problem has been to extend or mod­ify 
existing specification languages to explicitly support par­ticular development methodologies (e.g. [D 
KRS91]). How­ This work M partly sponsored by the ESPRIT? project ICARUS Permission to copy without fee 
all or part of this material is granted provided that the copies are not made or distributed for direct 
commercial advantage, the ACM copyright notice and the title of the publication and its date appear, 
and notice is given that copying is by permission of the Association of Computing Machinery. To copy 
otherwise, or to republish, requires a fee !# &#38;?&#38;?? %! ;&#38;!;~;Orleans LA USA 0 1994 ACM 0-89791-691 
-3/94/0012..$3.50 ever, such an approach requires that the semantics of the specification language be 
extended or even completely mod­ified. Therefore, existing methods of verification and refine­ment and 
support tools already developed for the existing language cannot be used. Moreover, the resulting language 
and, in particular, its semantics can be quite complex mak­ing the development of new methods and tools 
difficult. In this paper, we present an alternative approach which overcomes these problems. It is language-independent 
and so can be used with existing specification languages and the resulting specifications can be verified 
and refined using ex­isting methods and tools. The approach, based on the work done in the Esprit project 
ICARUS [SL93], is intended to form the basis of an interactive specification development environment. 
Wit hin the environment, design concepts and strategies are captured by the application of development 
operators, i.e. operators which enable the incremental con­struction and modification of specifications. 
The operators enable the specifier to develop specifications in an intuitive fashion by separating the 
use of design concepts from the technical details of how they are captured in the specifica­tion language. 
They also offers flexibility since it is possible to define a library of operators capturing alternative 
defini­tions of particular concepts and strategies. Each operator consists of two parts: a language­independent 
part which captures the particular concept or strategy and a language-dependent part which applies that 
concept or strategy in a given specification language. The language-independent part is responsible for 
modifying a workplan which records the design decisions taken during the specification s development. 
The information in the workplan is entirely independent of the specification lan­guage used and represents 
a deeper understanding of the specified system than the specdication alone. It facilitates reading the 
specification and may also aid the steps of ver­ification and refinement [Smi94a]. The language-dependent 
part is responsible for modifying the specification being de­veloped. It alone needs to be modified in 
order to use an operator with a new specification language. This paper presents a set of operators enabling 
an object-oriented [Bo090] approach to specification develop­ment. It extends the work in [Smi94a, Smi94b] 
by address­ing the feature of language-independence: the operators are instantiated for both the algebraic 
specification language Glider [FCP90] and the model-based specification language Z [Spi89]. In generrd, 
such operators can be instantiated for any number of specification languages. The understanding is that 
the specifier chooses one particular language to use throughout the development and is familiar with 
that lan­guage in order to supply syntactically-correct specification text when prompted to do so by 
a development operator. Section 2 describes the environment and Sections 3 and 4 present the operators 
for object-oriented development. These operators are illustrated by the development of a case study of 
a simple card game in both Glider and Z. Section 5 concludes by examining up to what point the presented 
approach is language-independent. 2 Specification Developments This section describes specification developments 
as pro­posed in [SOU93]. The development of a specification can be viewed as a sequence of steps where 
each step corresponds to the application of a development operator to the develop­ment state. The development 
state consists of a ruorkplan, denoting the history of goals and development decisions, and a product, 
denoting the specification. Links associate the workplan and product. 2.1 Workplan The workplan consists 
of a collection of tasks describing goals to be achieved in order to produce the required specifi­cation. 
A task is reduced by the application of a development operator. A reduction consists of decomposing the 
task into several subtssks which together achieve the same goal as the original task. For example, Figure 
1 shows the reduc­tion of the task Specify GAME, by the development operator Specifying with an Object-Oriented 
approach, to the subtasks Specify GAME Types and Constants, Specify GAME Classes and Specify the Class 
GAME. I Sptxlfy GAME II 11 SWIfyuV wih m Ohjcd4)ncntdapproach Spsifi GAME --_--b SpecifyGAME , Speafy 
the Chus TyfM andConstants ClUses GAME Figure 1: First step of the Construction of GAME In general, there 
may be several possible reductions for any gi~en task. A task may, therefore, be reduced by a number 
of different development operators. Often it is desirable to decompose a task into its subtasks progressively, 
i.e. to apply an operator which produces only one, or a limited number, of subtasks at a time. For exam­ple, 
the task Specify GAME Classes could be reduced to a single subtask Specify Class DEALER and then later, 
after the specification of the DEALER class is completed, a sub­task Specify Class PLAYER could be added. 
To enable this, a reduction can either be partial (represented by a non-shaded circle) or complete (represented 
by a shaded circle as in Fig­ure 1). A partial reduction is one which allows the list of its subta.sks 
to be extended. Subtasks of a given task may alSO be related by a prece­dence rekation indicating that 
certain of them should be re­duced before others. A precedence relation is a strict partial order on 
tasks represented graphically by a dashed arrow between the tasks as in Figure 1. It acts aa a hint to 
the specifier as to which subt ask to reduce first.  2.2 Product The product consists of formal text 
in a given specification language and informal explanatory textl. During the devel­opment of a specification, 
an incomplete part of the prod­uct (i.e. a part not yet defined), is represented by a typed piaceholder 
which is linked to a single non-reduced task in the workplan. The type of the placeholder corresponds 
to the kind of specification text it can be replaced with. A placeholder is denoted between ( ). When 
the product rep resented by some place holder is a list, it is denoted between *( )* (for example *(ITEM)* 
denotes the placeholder for a list of items). In order to define the part of a specification a placeholder 
represents, a development operator is applied to the associated task and its subsequent subtaaks. When 
this occurs, the links between the workplan and product are maintained so that each completed part of 
the product is linked to the tasks in the workplan which produced it. Glider Specification Language Glider 
[FCP90] is an algebraic specification language de­fined within the Esprit project ICARUS. It follows 
a loose semantics approach with constraints [OSC89, CJ092]. A specification written in Glider is composed 
of modules called clusters. The general structure of these clusters is either one of the following: TYPE 
CLUSTER (MODULE-NAME) provides all (CONSTRUCTION) (INVARIANT) *( OP.UNIT)* END CLUSTER OPERATION CLUSTER 
(MODULE-NAME) provides all *( OP_UNIT)* END CLUSTER A type cluster implicitly introduces one sort whose 
name is the same as that of the cluster. An operation cluster enriches a specification without introducing 
a new sort. A cluster may be parameterised but this feature will not be used in this paper. Type clusters 
will be used to model both types and classes. The provides clause lists the exported operations. We will 
always export all the operations defined within a cluster. The (CONSTRUCTION) clause is optional and 
is used when defining a type in terms of other types. 1The operators presented m this paper include only 
formal text The type clusters considered will be constructed in terms of a Cartesian product of their 
attributes and objects. A type may have an invariant restraining the set of its objects to those verifying 
it. It is defined by an assertion in first-order predicate logic. The operations can be partially defined 
by a precondition restraining their domain. They are defined by operation units (O P UNIT) generally 
structured as follows where a sort expression is the sort of a type: OPERATION (OPNAME) arity * (SORT_EXPR)* 
+ (SO RT.EXPR) (ASSERTIONS) (PRECONDITION) END OPERATION Z Specification Language Z [Spi89] is a state-based 
specification language based on the mathematics of set theory and first-order predicate logic. A typical 
Z specification consists of a number of globaf type and constant definitions, together with state and 
operation schemas describing the state and operations, respectively, of the specified system. A state 
schema consists of a declaration part which in­troduces state variables and a predicate part which defines 
the relationships that hold between their values. The gen­ eral form is shown below. (Generic parameters 
are not used in this paper. ) \ (PREDICATES) An operation schema defines the relationships between the 
before and after values of variables belonging to one or more state schemas. These are introduced into 
an operation schema s declaration part by the notation ASTATE-NAM E. The general form of an operation 
schema is shown below. (The DECLARATIONS are of input and output variables re­quired for the operation. 
) OP-NAME *( ASTATE.NAME)* (DECLARATIONS) r I (PREDICATES) Z also supports a schema calculus with operators 
en­abling the definition of schemas in terms of other, already existing schemas.  2.3 Development Operators 
Development operators work simultaneously on the work­plan and product to reduce tasks and construct 
or modify the associated product text. They obtain parameters inter­actively from the specifier and from 
the existing workplan and product. Parameters will be denoted by words in upper­case (like NAME and PARAM 
in the schema below). The pa­rameters obtained from the workplan are given in the name of the operator 
(NAME k such a parameter). The parame­ters obtained from the specifier are preceded in the operator definition 
by a message which is printed by the environment asking the specifier for a valne of a given type (PARAM 
is such a parameter). Operators may introduce subtasks that will in tnrn, be reduced by the application 
of development operators. Such subtasks are associated with placeholders (such as ITEM ~) in the product 
text. The precedence relationship between these subtasks is indicated by the clause precedence. Development 
operators consist primarily of a language­independent section which describes the action on the work­plan. 
They must also be instantiated to be used with one or more specification languages. The general form 
of an operator instantiated for Glider and Z is presented below: operator Specifying NAME status complete 
or partial interactive parameter Message to enter the parameter : PARAM subtasks 1: first subtask defines 
(ITEM1) 2: second subtask defines (ITEM2) precedence for exampie : 1< 2 Glider product text (Glider 
text to be defined) --+ Glider text dejined with NAME, PARAM, (ITEM 1), (1TEM2) Z product text (Z text 
to be defined) + Z text defined with NAME, PARAM, (ITEM 1), (iTEM2) The language-indepeudent section 
introduces the name (Specifying), the status of the operator, the parameters (NAME and PARAM), the subtasks 
it produces and the precedence relationship between these subtasks. The language-dependent product parts 
introduced by an operator are composed of keywords of the specification lan­guage, parameters (e.g. NAM 
E), parts introduced manually by the user as interactive parameters (e.g. PARAM), place­holders (e.g. 
(ITEM1 )) associated with the subtasks and parts computed by product operators. Product operators are 
functions whose arguments are the existing product text and parameters of the operator in which they 
are used. The use of such product operators will be illustrated in Sections 3 and 4. To be applicable 
to a task, an operator must modify the kind of product text associated with the task. The place­holder 
(ANY) is the most general representing any kind of product text. Let us note that the kind of product 
text associated with a task represents the only precondition assumed by the present environment for the 
application of an operator. However, preconditions of application are forseen in the next version. 2.4 
Basic Operators The construction process involves resolving (or reducing) a task, either by introducing 
new subtasks or finishing the work assigned to the task. This process is repeated, step by step until 
there are no more unreduced tasks. Some oper­ators are totally method-or language-independent such as 
the ones presented below which we will use in the case study developed in Section 3. To specify an item 
in a list, the operator introducing Item is first applied to introduce the corresponding placeholder. 
operator Introducing Item of NAME status partial interactive parameter Name of the item : ITEM-NAME subtasks 
1: Specify ITEM-NAME of NAME defines (ANY) Glider product text *(ANY)* + (ANY) * (ANY)* Z product text 
*(ANY)* + (ANY) * (ANY)*  For any natural number n (n can be equal to O), an op­erator Reducing to n 
Items can be defined that introduces n subtasks and whose status is complete. For example, for n equal 
to two: operator Reducing to 2 Items of NAME status complete interactive parameters Name of the first 
Item : ITEM-NAM E-1 Name of the second Item : ITEM.NAME-2 subtasks 1: Specify lTEM_NAME_l of NAME defines 
(ANY-1) 2: Specify lTEM_NAME_2 of NAME defines (ANY-2) Glider product text *(ANY)* + (ANY.1) (ANY3) 
 Z product text *(ANY)* + (ANY_l) (ANY_2)  Sometimes, a placeholder is introduced that can be re­solved 
by nothing. This happens for all optional parts of a formal text. The operator Specifying by Nothing 
allow place­holders to be removed in such cases. operator Specifying by Nothing status complete Glider 
product text (ANY) + Z product text (ANY) + At any time during a development, the specifier may want 
to directly define a piece of the specification, without using an operator, i.e. with just the text editor. 
In such cases, the operator Terminating can be applied. This oper­ator is always applicable, i.e. at 
any time and to any task. It increases the flexibility of the approach. Naturally, the interactively 
given text must be syntactically-correct with respect to the chosen specification language. operator 
Terminating status complete interactive parameter Value : STRING Glider product text (ANY) + STRING Z 
product text (ANY) + STRING 3 Modeling the Object-Oriented Approach To enable an object-oriented approach 
to specification con­struction, we introduce a family of development operators from which we will just 
present some of them. These opera­ tors correspond to three global aims: applying design strate­gies, 
identifying components and specifying components. The operators presented here that apply design strategies 
are Specifying with an Object-Oriented Approach, Specifying Class and Specifying Operation. Those identifying 
compo­nents are Introducing Item, Reducing to 2 Items and Specifying by Nothing presented in Section 
2.4. All the other operators defined are to specify components. To start, a task Specify System is introduced 
and then reduced in order to follow an object-oriented approach by applying the operator Specifying with 
an Object-Oriented Ap­ proach. The object-oriented approach to specification construc­tion adopted in 
this paper, views a system as a class defined in terms of objects of other classes and global types and 
con­stants. Generally, a class consists of a state that is defined by a set of attributes and integrity 
constraints (called the class invariant) and a set of operations which manipulate this state. A class 
can also be defined by inheritance, but this will not be considered in this paper. In addition, it may 
be useful to introduce global types and constants which can be referred to in the definition of a class. 
In this paper we will focus on the construction of a sys­tem. The specific operators for specifying types 
and con­stants will not be presented here. 3.1 Specifying a System A system consists of a class of interest, 
other classes used in the definition of this class and global types and constants. The order in which 
these components are defined depends on whether a top-down or a bottom-up approach is followed. Here 
we choose a bottom-up approach. operator Specifying NAME with an Object-Oriented Approach status complete 
subtasks 1: Specify NAME Types and Constants defines * (ANY)* 2: Specify NAME Classes defines * (CLASS)* 
 3: Specify the Class NAME defines (CLASS) precedence 1 <2 &#38; 2 <3 Glider product text (ANY) ---+ 
*(ANY) * *(CLASS) * (CLASS) Z product text (ANY) + *(ANY) * *(CLASS) * (CLASS)  3.2 Specifying a Class 
A class consists of a state and some operations which ma­ nipulate it. The state is defined by its attributes. 
It also satisfies a property called the class invariant. The following operator is used to define any 
kind of class, including the class of a system. In this caae, in addition to the attributes, the class 
includes objects used by the system. For this case, the operator introduces the subtask Spec­ify Objects 
that defines *(( OBJECT), ( FORMULA))* (set of objects and for each its initialisation). If the claas 
to be defined does not contain any objects, these placeholders have to be deleted by application of the 
operator Reducing to O Items. Naturally, we could instead, introduce two dif­ferent operators: one for 
a simple class and another for a system class. In Glider, a class is modeled by a type cluster. The type 
cluster is structured as a Cartesian product of the class attributes and, in the case of a system class, 
the objects of the system. The invariant of the class is defined within the clause assert and the initial 
conditions are specified by the operation called Init. In Z, a class is modeled as a set of schemas including 
two state schemas (one defining the state of the class and one defining its initial conditions) and zero 
or more operation schema-s. The name of the state schema is the class name and the name of the initial 
state schema is the class name appended with Init. This is necessary to avoid name clashes with initiaf 
state schemas in different classes. operator Specifying Class CL_NAME status complete subtasks 1: Specify 
CL.-NAME Attributes defines * (ATT)* 2: Specify CL-NAME Objects defines * ((OBJECT), (FORMULA))* 3: 
Specify CL_NAME Invariant defines (ASSERT_CLAUSE) ~ : Specify CL_NAME Initial Conditions defines (FORMULA_l) 
 5: Specify CL-NAME Operations defines * (OP-UNIT)* precedence l<3&#38;2 <3&#38;3< &#38;&#38;d<5 Glider 
product text (CLASS) + TYPE CLUSTER CL-NAME provides all is CP[*(ATT)*, *(OBJECT)*] (ASSERT-CLAUSE) 
OPERATION lnit arity > CL_NAME assert (FORMULA_l) and *(FORMULA)* END OPERATION *( OP UNIT)* END CLUSTER 
Z product text (CLASS) + &#38; CL.NAME.lnit_ CL_NAME (FORMULA-1) *(FORMULA)* k *( OP_UNIT)* To specify 
the initiaf conditions, we use the operator Ter­minating since we need only ask the specifier for a formula. 
To reduce the other subtasks, we use the specialised opera­tors defined below. An object can be simple 
(we need just one) or an aggregate (we need many of the same class). The operators wilf be different 
for these two cases. Let us note that the tasks concerning the assertions can also be reduced by the 
operator Specifying by Nothing. 3.3 Specifying an Attribute The operator Specifying Attribute is parameterised 
by the name of the attribute to be specified and by its claas name. The specifier need only provide its 
type. operator Specifying Attribute NAME of CL_NAME status complete interactive parameters Type of the 
attribute : TYPE Glider product text (ATT) + NAME : TYPE Z product text (ATT) + NAME: TYPE  3.4 Specifying 
an Invariant The class invariant restricts the possible values of the at­tributes. It is optional. In 
both languages, it can be ex­pressed by a formula. Let us note that the formula given by the specifier 
must be syntactically correct with respect to the chosen language. operator Specifying an Invariant of 
CL_NAME status complete interactive parameters Formula of the Assertion : FORMULA Glider product text 
(ASSERT-CLAUSE) --+ assert FORMULA Z product text (ASSERT-CLAUSE) _ m  3.5 Specifying an Object The 
operator Specifying Object corresponds to declaring a single object of a given class as a component of 
the system. The object is initialised by the initial condition of the sys­tem. The specifier simply supplies 
the name of the object and its class; The initialisation of the object in Z is specified by stating that 
the object belongs to the set of objects sat­isfying the initial conditions of the class, while in Glider, 
by stating that the object is equal to the object Init. The tech­nical details of this expression are 
effectively hidden from the specifier during the specification development. In both Glider and Z, an 
object is defined just as an attribute of the system class. operator Specifying Object NAME of CL_NAME 
status complete interactive parameters Class of the object : OBJECT_CL.NAME Glider product text (OBJECT) 
+ NAME: OBJECT_CL_NAME (FORMULA) ---+ NAM E(self) == Init Z product text (OBJECT) + NAME: OBJECT_CL_NAME 
(FORMULA) + NAME E {OBJECT_CL_NAME_lnit c oOBJECT-CL-NAME} 3.6 Specifying an Aggregate of Objects  The 
operator Specifying Object Aggregate corresponds to specifying an object defined as an aggregate of objects 
of a given class. The aggregate is defined as a total function from a given set of identifiers to objects 
of the class. Opera­tors to define other types of aggregates, e.g. partial functions or sets, could also 
be defined if desired. The aggregate is ini­tialised and, as for an object, the details of initializing 
are performed automatically. operator Specifying Object Aggregate NAME of CL-NAME status complete interactive 
parameters Class of the objects : OBJECT-CL_NAME Type of object identifiers : ID Glider product text 
(OBJECT) - NAME : MAP[lD, OBJECT-CL_NAME] (FORMULA) + (forall var_/oroer(lD) : in-Domain(var_Zower(lD), 
NAM E(lnit)) IS TRUE and Access(NAME(lnit), var-lower(lD)) == Init) Z product text (OBJECT) + NAME : 
ID+ OBJECT_CL-NAME (FORMULA) ­ ran NAME c {O BJECT.CL_NAME lnit OCLASS} In Glider, the names of the classes 
are written in capital letters while the variable names are in small letters. Here, we need to invent 
a variable to be used as an identifier. This variable will be the class name in small letters (computed 
by the product operator lower), prefixed by var. The Card Game example: Specify GAME To illustrate our 
approach, we will show some steps in the construction of a simple card game. A full description and development 
of the game can be found in [LS94]. Basically, the game consists of a dealer and a number of players. 
In order to specify the card game, we first introduce the task Specify GAME. Then we apply to it the 
operator Spec­ifying with an Object-Oriented Approach introducing three subtasks: Specify GAME Types 
and Constants, Specify GAME Classes and Specify the Class GAME. The workplan shown in Figure 1 corresponds 
to this step of the development. We will focus here on the definition of the third one, assum­ing the 
first two have been resolved before. They intro­duce and define the classes DEAL and PLAYER and the type 
PLAYERJD. To specify the class GAME, we first apply the operator Specify Class. Then to reduce the subtasks 
introduced we proceed as follows: 1. As we need one attribute, representing the number of players who 
have been dealt cards, we apply Reducing to 1 Item to the task Specify GAME Attributes with PlayersDealt 
as interactive parameter. 2. This attribute is defined by application of Specifying Attribute with NAT 
for Glider and N for Z as interactive parameter. 3. The system GAME has two objects. We introduce the 
subtaaks to specify them by application of the oper­ator Reducing to 2 Items with Dealer and Players 
as interactive parameters. 4. Dea Ier is defined by application of the operator Speci­fying Object with 
DEALER as interactive parameter. 5. Players is an aggregate defined by application of the operator Specifying 
Object Aggregate with PLAYER and PLAYER-ID as interactive parameters. 6. The system GAME needs no invariant 
so we apply Specifying by Nothing to the task Specify GAME in­variant. 7. The initial conditions concern 
only the attribute PlayersDealt. They are defined as interactive param­eter of the operator Terminating 
with respectively for Glider and Z the following formulas:  Players-Dealt(seIf) == O Players-Dealt = 
O 8. The subtask Specify GAME Operations is at this point, unreduced. At this point of the construction 
of the GAME specifica­tion, the workplan is as given in Figure 2. The Glider and Z specifications are 
as follows: Glider specification TYPE CLUSTER GAME provides all is CP[ Players-Dealt : NAT, Dealer : 
DEALER, Players : MAP[PLAYER-ID, PLAYER]] OPERATION Init arity > GAME assert Players-Dealt(self) == 
O and Dealer(self) == Init and ( forall var-player_id : ln_Domain(var-player_id, Players(lnit)) IS TRUE 
and Access(Players( lnit), var_player-id) == I nit) END OPERATION *( OP_UNIT)* END CLUSTER Z specification 
GAME Players-Dealt : N Dealer : DEALER Players : PLAYER_lD + PLAYER r GAME_lnit rGAMEr Dealer c {DEALER_lnit 
e .9DEALER} ran Players c {PLAYER_lnit 8PLAYER} *( OP_UNIT)* $!+tify GAME krowing classes u * Spiyw 
C!alGAME SpecifyGAb4E Avnbutcs Objm \ ..­  &#38; a g -Tm Figure 2: Construction of GAM E 4 Operators 
to Specify Operations To reduce a task Specify Operation OP_NAME associated with a placeholder (O P UNIT), 
several operators could be defined. Here we present one quite general operator and the operators used 
to reduce its associated subtasks. 4.1 Specifying an Operation An operation has inputs and outputs and 
may modify the current state. The operator Specifying Operation introduces four subtasks: two to specify 
the inputs and outputs and two to specify the pre-and post-conditions. In Z, an oper­ation is defined 
as an operation schema. The name of the operation schema is the class name appended with the op­eration 
name given by the specifier. Once again, this is to avoid name clashes between classes; in this case, 
when two or more classes have a similar-named operation, In Glider, an operation is defined within a 
type cluster by an opera­tion unit. The arity clause details the type of interest, the inputs and outputs 
types. Let us note that in all the opera­tors defined here, the object of the type of interest is called 
self. operator Specifying Operation OP_NAME of CL-NAME status complete subtasks 1: Specify the inputs 
of OP-NAME defines *(( IN PUT.NAME), (l NPUT_TYPE))* 2: Specify the outputs of OP-NAME defines *((OUTPUT-NAME), 
(OUTPUT-TYPE))* 3: Specify OP.NAME of CL_NAME Precondition defines (PRECONDITION) ~ : Specify OP-NAME 
of CL.NAME Postconditions defines (POSTCONDITION) Glider product text (OP_UNIT) + OPERATION OP.NAME 
arity CL.NAME, *(l NPUT_TYPE_)* > CP[CL-NAME, *(OUTPUT-TYPE)*] asserts OP-NAME(self, *( IN PUT.NAME)*) 
== ((self , *(OUTPUT-NAME)*)) (POSTCONDITION) preconditions OP-NAME (self, *(INPUT-NAME)*) is defined 
iff (PRECONDITION) END OPERATION Z product text (OP.-UNIT) + CL_NAME.OP_NAME ACL-NAME *(( OUTPUTNAME)! 
: (OUTPUT-TYPE))* *((INPUT-NAME)? : (INPUT-TYPE))* (PRECONDITION) (POSTCONDITION)  ._ L 4.2 Specifying 
a Variable Since they both define a variable and its type, to specify ((lNPUT_NAME), (INPUT-TYPE)) and 
(( OUTPUT_NAME), (OUTPUT_TYPE)), we introduce just one operator. operator Specifying Variable NAME Type 
status complete interactive parameter Type of NAME: TYPE Glider product text (NAME) ---+ NAME (TYPE) 
+ TYPE Z product text (NAME) + NAME (TYPE) + TYPE  4.3 Specifying a Precondition A precondition, like 
an invariant is expressed by a formula. The specifier must provide it syntactically correct with re­spect 
to the chosen language. operator Defining OP-NAME of CL_NAME Precondition status complete interactive 
parameters Formula of the precondition : FORMULA Glider product text (PRECONDITION) _ FORMULA Z product 
text (PRECONDITION) + FORMULA  4.4 Specifying a Postcondition To Specify the postcondition, post-values 
of t he attributes and objects must be defined. In order to enable a progressive specification, the operators 
used are partial. Like an invari­ant or a precondition, a post condit ion can be expressed in terms of 
a general formula. operator Defining a Postcondition of OPNAME of CL-NAME status partial interactive 
parameters Formula of the postcondition : FORMULA Glider product text (POSTCONDITION) + and FORMULA 
(POSTCONDITION) Z product text (POSTCONDITION) + FORMULA (POSTCONDITION)  4.5 Applying an Operation 
to an Object Postconditions must also describe the post-values of the ob­jects. These can be defined 
by application of the following operator. The Card Game example: Specify the operation Deal of operator 
Applying an Operation to Object OBJ of CL-NAME status partial interactive parameters Name of operation 
to apply : OP-NAME Glider product text (POSTCONDITION) + and OBJ(self ) == OP_NAME(OBJ(self), inPut-uar-numes 
(O P_ NAME, class-of (O BJ))) (POSTCONDITION) Z product text (FORMULA) + OBJ 6 {class.of(OBJ)_OPNAME 
/ OBJ = 6 c/ass._of(OBJ) o Ocbms_of(OBJ) } (POSTCONDITION) To compute the formula, the operator uses 
the product op­erators inzmt vauzarnes and class of. irzpat-var-narrzes delivers for the given operation, 
the names of its input variables. class_of delivers for a given object, the name of its class.  4.6 
Applying an Operation to an Object in an Aggregate The new state of an aggregate can be defined in different 
ways. For example, applying an operation to every elements of the aggregate or just to one. In the latter 
case, the object can be chosen by a function or, in the case of an aggregate defined as a total function 
whose domain is a set of iden­tifiers, by giving one identifier. The operator Applying an Operation to 
an Object in an Aggregate corresponds to this case. In Glider the operation Modify applied to a map says 
that just one entry of the map is modified. operator Applying an Operation to an Identified Object in 
the Aggregate OBJ of CL.NAME status partial interactive parameters Operations to apply : OP-NAME Identifier 
of the object : ID Glider product text (FORMULA) ---+ and OBJ(self ) == Modify (OBJ(self), ID, OP_NAME(access( 
OBJ(self),lD))) (POSTCONDITION) Z product text (FORMULA) + OBJ (ID) G {cJass-of(OBJ(lD) )-OP_NAME / OBJ(ID) 
= dclass_of(OBJ(lD)) o 6ciass_of(OBJ(lD) ) } {ID} <OBJ ={ID}<OBJ (POSTCONDITION)  class of delivers 
for a given object, the name of its class. cllass GAME The GAME operations are introduced one after the 
other by application of the operator Introducing Item, with their name as interactive parameter. To specify 
the operation Deal of GAME, we apply the operator Specifying Operation introducing four subtasks. To 
reduce the subta.sks, we apply the corresponding operators seen before: 1. Specify the Inputs of Deal: 
just one is needed to identify the player to be dealt. We apply successively Red uc­ing to 1 Item and 
Specifying Variable Type with id and PLAYER-ID as respective interactive parameters. 2. Specify the 
outputs of Deal: as there is no output, we apply the operator Reducing to o items. 3. Specify Deal of 
GAME Precondition: the precondition to deal requires that not all players have been dealt cards. The 
operator Defining Precondition is applied  with the following formula as interactive parameter for 
respectively Glider and Z: Players-Dealt(self) < Size( Do main(Players (self))) IS TRUE Players-Dealt 
< # ran Players. 4. S~ecifv Deal of GAME Postconditions: Dostcondition of Dea I s;ys that after the operation 
the ;umber of play­ers who have been dealt cards is increased by 1. The operator Defining a Postcondition 
is applied with the following formula as interactive parameter for respec­tively Glider and Z: Players-Dealt(self 
) == Players_Dealt(self) + 1 players-dealt = players_dealt + 1. After this first operator application, 
the task Specify Postconditions Deal of GAME is only partially reduced: the post-states of the object 
Dealer and the aggregate Players must be defined. The post-state of the object Dealer is defined by ap­plication 
of the operation Dea I of DEALER. We apply the operator Applying an operation to object Dealer of GAME 
with Deal as interactive parameter. As the op­eration Deal of DEALER has no input, the set of input variable 
names computed for the Glider product text is empty. The post-state of the aggregate Players is defined 
by application of the operation Collect of PLAYER to just one player which is given (input of the operation 
Deal). We apply the operator Applying an Operation to an Ob­ject in Aggregate Players of GAME with Collect 
and id as interactive parameter. The workplan of the construction process of the operation Deal of GAME 
is given in Figure 3. The Glider and Z speci­fications are as follows: o ronment is based on that proposed 
in the Esprit project Specify Deal of GAME  ICARUS concerned with the incremental construction of specifications. 
Development operators are used to simulta­ &#38; Ssucifying (lIYTAn Deal of GAME SpecifyUK Specifytie 
Inputs of Ded outputs of Deal + Rduciq m + Spafymg + Germi z Dal &#38; 4b I hem No km O(GAME Pmadii.a 
 J!.-I 4 / Spxify id of Dsal Germingm.( GAME PwmWw ApplyinEm (Mdtkm 1 k objm Cwkr .( GAME Applying 
m OIWAXI to m Wm%d ohjc d $$ 4-Spdying Vmhk id TW i. h. AggregatePhyen of GAME Redwing to OItms Figure 
3: Construction of Deal of GAM E Glider specification OPERATION Deal arity GAME, PLAYER-ID > CP[GAME] 
asserts Deal(self, id) == ((self )) and Players_Dealt(self ) == Players_Dealt(self) + 1 and Dealer(self 
) == Deal(Dealer(self)) and Players(self ) == Modify (Players, id, Collect(access( Players(self), id))) 
 precondition Deal(self, id) is defined iff Players-Dealt(self) < Size(Domain(Players( self))) IS TRUE 
END OPERATION Z specification GAME.Deal AGAME id? : PLAYERJD  r players-dealt < # ran Players players_dealt 
= players...dealt + 1 Dealer c {DEALER-Deal / Dealer = @DEALER ODEALER } Players (id?) G {PLAYER-Collect 
I Players(id?) = oPLAYER .9PLAYERS } {id?} q Players = {id?} q Players 5 Conclusion This paper has 
presented a language-independent environ­ment for the development of specifications. The envi­neously 
construct a workplan, denoting the history of goals to be achieved and corresponding application of operators 
to these goals, and a product, denoting the specification itself. The specification constructed can either 
be in the model­based language Z or in the algebraic language Glider. The workplan describes the development 
of the specifica­tion independent of the specification language chosen. This was illustrated by the definition 
of a set of operators reflect­ing an object-oriented approach to specification construc­tion which were 
instantiated for the algebraic specification language Glider and the model-baaed specification language 
z. The development operators consist of a language­independent section which describes the action on 
the work­plan and of a language-dependent section describing the product text defined by the operator. 
This language­dependent text is composed of keywords of the specification language, the operator parameters, 
parts introduced manu­aUy by the user ax interactive parameters, placeholders asso­ciated with subtasks 
and parts computed by product oper­ators. The operators effectively hide the technical details of how 
object-oriented concepts can be captured in the chosen language, facilitating specification development. 
Therefore, certain choices ax to how the concepts are to be captured are made by the operators. However, 
other operators reflecting different choices could also be defined. Here are some examples of choices 
made by the opera­tors: As Z does not include any modularisation con­trol structure, the name of the 
operations at­tached to a class in Z are prefixed by the name of the class (e.g. GAME. Deal).  In Glider. 
an attribute or an obiect of a class is defined ~ a component of a C~tesian product (or record). Thus, 
the name of the attribute is an access function applied to a variable of the class. This variable is 
always called self.  In order to be as language-independent aa possible, we in­cluded some specific 
operators where basic operators could have been used. For example, the operator for defining a precondition 
is identical to Terminating. However, there ex­ists languages for which the formula given by the user 
will need to be modified by a product operator and then such an operator will be needed. For example, 
in Glider, we may in­troduce an operator insuring that the variables used within the formula are in small 
letters. Extending the operators to be used with other languages is dependent on whether these languages 
can be used to capture the particular concepts. However, it is forseen that concepts need not be captured 
directly. For example, in an untyped specification language, when an operator (such as that for specifying 
an attribute) asks for a type, the opera­tor could produce a comment to the effect that the attribute 
is of the given type or, perhaps, a proof obligation that the attribute ranges over the values defined 
by the given type. However, not all development strategies will suit all lan­guages and it is necessary 
to compromise between the appeal of a particular strategy and the possible loss of readability in the 
resulting specification. The practicality of the proposed approach is dependent [SL93] J. Souqui&#38;es 
and N. L6vy. Description of Specifi­on an environment which manages the workplan and prod-cation Developments. 
In Proceedings IEEE Interna­uct and the links between them. Such an environment is tional Symposium on 
Requirements Engineer-ing, San Diego (CA, USA), January 1993. under development within the Esprit project 
ICARUS. A prototype [BS93] of the environment is already implemented [Smi94a] G. Smith. A Development 
Framework for Object­and allows simple operators to be chosen via a menu which is Oriented Specification 
and Refinement. In B. Magrms­dynamically defined according tothecurrent task type. Two son, B. Meyer, 
J.-M. Nerson, and J.-F. Perrot, editors, Proceedings of TOOLS EUROPE 94, March 1994. languages have 
been implemented and experimented with in the environment: Glider [NM93, SL93] and Z [Smi94b, [Srrri94b] 
G. Smith. An Object-Oriented Development Frame-DS93]. Let us note that presently, the environment does 
work for Z. In J.P. Bowen and J.A. Hall, editors, not allow the use of product operators in the definition 
of Proc. of the 8th Z UseT Meeting (ZUM 94), Cam­bTidge. Springer-Verlag, Workshops in Computing, development 
operators. A more flexible notion of operator June 1994. is presently being developed. [SOU93] J. Souqui&#38;es. 
Aides au d6veloppement de specifica­tions. Th&#38;e d Etat, CRIN, Janvier 1993. Universit Acknowledgements 
de Nancy 1. [Spi89] J.M. Spivey. The Z Notation: A Reference Man-Graeme Smith was supported by a post-doctoral 
fellowship u al. Series in Computer Science. Prentice-Hall Inter­granted by the Direction de la Recherche 
et des Etudes Doc-national, 1989. torates (D. R.E. D) and financed by the Ministbre des Affaires Etrang&#38;es, 
France. Thanks to Guido Bosch, Jean-Michel Hufflen, Jean-Pierre Jacquot and Jeanine Souqui&#38;es with 
whom this work was carried out. Special thanks to the reviewers for their most valuable comments and 
suggestions on this paper. References [Abr88] J.-R. Abrial. The B tool. In R. Bloomfield, L. Mar­ shall, 
and R. Jones, editors, VI) M 88: VDM The Way Ahead, volume 328 of LectuTe Notes in Com­puter Science, 
pages 86 85. Springer-Verlag, 1988.  [Bcm90] G. Booth. Object-Oriented Design with Applications. Addison-Wesley, 
1990. [BS93] G. Bosch and J. Souqukres. Development Editor UseT Manual. Technical report, ICARUS, December 
1993. [CJ092] S. Cl&#38;-ici, R. Jim.6nez, and F. Orejas. Semantic con­structions in the specification 
language Glider. Tech­nical report, ICARUS, June 1992. [DKRS911 R. Duke. P. King. G. Rose, and G. Smith. 
The Obiect­ . .,, Z specification language. In T. Korson, V. Vaishnavi, and B. Meyer, editors, Technology 
of Object-Oriented Languages and Systems: TOOLS 5, pages 465-483. Prentice-Hall International, 1991. 
 [DS93] R. Darimont and J. Souqui&#38;es. A Development Model: Application to Z specifications. In Proc. 
of the WG 8.1 Working C onfeTence on Information Sys­tem Development Process, Como, Italy, 1993. North 
Holland. September 1993.  [FCP90] FUN(Namur), CRIN(Nancy), and PRLB(Brussels). Presentation of Glider. 
Technical report, ICARUS, March 1990. [LS94] N. L6vy and G. Smith. A Language-Independent Approach to 
Object-Oriented Specification Construc­tion. Technical report, CRIN-INRIA-Lorraine, Van­domvre-l&#38;s-Nancy, 
1994.  [NM93] J. Nagel and A. Mullins. Systems and Their Environ­ments: a Case Study. Technical report, 
ICARUS, July 1993. [OSC89] F. Orejas, V. Sacristan, and S, CXrici. Development of Algebraic Specifications 
wzth Constraints, volume 393 of Lecture Notes in Computer Science. Springer Verlag, 1989. 
			
